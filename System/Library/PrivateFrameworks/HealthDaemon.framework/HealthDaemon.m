void HDPowerLogForClient(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  __CFString *v9;
  __CFString *v10;
  __CFString *v11;
  void *v12;
  void *v13;
  _QWORD v14[2];
  _QWORD v15[3];

  v15[2] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = a3;
    v6 = a1;
    objc_msgSend(a2, "process");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = (void *)objc_msgSend(v5, "mutableCopy");

    objc_msgSend(v7, "applicationIdentifier");
    v9 = (__CFString *)objc_claimAutoreleasedReturnValue();
    if (!v9)
    {
      objc_msgSend(v7, "name");
      v9 = (__CFString *)objc_claimAutoreleasedReturnValue();
    }
    v10 = CFSTR("missing");
    if (v9)
      v10 = v9;
    v11 = v10;

    v14[0] = CFSTR("clientId");
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", objc_msgSend(v7, "processIdentifier"));
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v14[1] = CFSTR("bundleId");
    v15[0] = v12;
    v15[1] = v11;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v15, v14, 2);
    v13 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v8, "addEntriesFromDictionary:", v13);
    PLLogRegisteredEvent();

  }
}

void sub_1B7805A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7805C54(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

id HDSampleEntityPredicateForEndDate(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForDate();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("end_date"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDSampleEntityPredicateForDataTypes(void *a1)
{
  id v1;
  void *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C99E20], "set");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v12;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v12 != v6)
          objc_enumerationMutation(v3);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(*(id *)(*((_QWORD *)&v11 + 1) + 8 * v7), "code", (_QWORD)v11));
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v2, "addObject:", v8);

        ++v7;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v5);
  }

  if (objc_msgSend(v2, "count"))
  {
    objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("data_type"), v2);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v9 = 0;
  }

  return v9;
}

id HDSourceEntityPredicateForAppleWatchSources()
{
  void *v0;
  void *v1;

  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:likeValue:", CFSTR("product_type"), CFSTR("Watch%%"));
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  _HDSourceEntityPredicateForNotDeletedWithPredicate(v0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  return v1;
}

id HDDataEntityPredicateForSourceEntitySet(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  objc_msgSend(MEMORY[0x1E0C99E20], "set");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v5 = v3;
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v14;
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v14 != v8)
          objc_enumerationMutation(v5);
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", objc_msgSend(*(id *)(*((_QWORD *)&v13 + 1) + 8 * v9), "persistentID", (_QWORD)v13));
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v4, "addObject:", v10);

        ++v9;
      }
      while (v7 != v9);
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
    }
    while (v7);
  }

  HDDataEntityPredicateForSourceIdentifierSet(a1, v4);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

id HDDataEntityPredicateForSourceIdentifierSet(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;

  v3 = a2;
  v4 = v3;
  if (a1 != 7)
  {
    if (a1 == 2)
    {
      if (objc_msgSend(v3, "count"))
        objc_msgSend(MEMORY[0x1E0D29848], "doesNotContainPredicateWithProperty:values:", CFSTR("data_provenances.source_id"), v4);
      else
        objc_msgSend(MEMORY[0x1E0D29890], "truePredicate");
      goto LABEL_6;
    }
    if (a1 != 1)
    {
      v6 = 0;
      goto LABEL_12;
    }
  }
  if (objc_msgSend(v3, "count"))
    objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("data_provenances.source_id"), v4);
  else
    objc_msgSend(MEMORY[0x1E0D29890], "falsePredicate");
LABEL_6:
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = (void *)v5;
LABEL_12:

  return v6;
}

id HDDataEntityPredicateForType(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  _HDSQLiteValueForNumber();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:equalToValue:", CFSTR("type"), v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDDeletedObjectPredicateForDeletionDate(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForDate();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("creation_date"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDDataCollectorEnumerateBatches(void *a1, void *a2, void *a3, double a4, double a5)
{
  id v9;
  id v10;
  void (**v11)(void *, void *, id);
  void *v12;
  id v13;
  id v14;
  unint64_t v15;
  char v16;
  void *v17;
  void *v18;
  double v19;
  double v20;
  NSObject *v21;
  int v22;
  id v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  NSObject *v28;
  double v29;
  void *v30;
  void *v31;
  void *v32;
  int v33;
  id v34;
  uint64_t v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  void *v40;
  id v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  id v46;
  id v47;
  double v48;
  double v49;
  uint64_t v50;
  void *v52;
  void *v53;
  void *v54;
  int v55;
  uint64_t v56;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  id v62;
  void (**v63)(void *, void *, id);
  void *v64;
  void (**v65)(id, void *, _QWORD, id, void *);
  void *v66;
  _QWORD aBlock[5];
  uint8_t buf[4];
  void *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a2;
  v65 = a3;
  if (!v65)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "id<HDSensorDatum> HDDataCollectorEnumerateBatches(NSArray<id<HDSensorDatum>> *__strong, __strong id<HDSensorDatum>, NSTimeInterval, NSTimeInterval, __strong HDDataCollectorBatchingCallback)");
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v58, "handleFailureInFunction:file:lineNumber:description:", v59, CFSTR("HDDataCollector.m"), 909, CFSTR("Invalid parameter not satisfying: %@"), CFSTR("block != nil"));

  }
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __HDDataCollectorEnumerateBatches_block_invoke;
  aBlock[3] = &__block_descriptor_40_e53___NSDate_24__0___HDSensorDatum__8___HDSensorDatum__16l;
  *(double *)&aBlock[4] = a5;
  v11 = (void (**)(void *, void *, id))_Block_copy(aBlock);
  objc_msgSend(MEMORY[0x1E0C99D68], "date");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v14 = v10;
  objc_msgSend(v14, "endDate");
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = 0;
  v16 = 1;
  v61 = v14;
  v62 = v9;
  v63 = v11;
  v64 = v12;
  while (v15 < objc_msgSend(v9, "count"))
  {
    objc_msgSend(v9, "objectAtIndexedSubscript:", v15);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "endDate");
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v18, "timeIntervalSinceReferenceDate");
    v20 = v19;

    if (v20 >= 0.0)
    {
      if (!v15 && ((objc_opt_respondsToSelector() & 1) == 0 || objc_msgSend(v17, "recordID") >= 2) && !v14)
      {
        v23 = v17;

        v14 = v23;
      }
      if (objc_msgSend(v13, "count"))
      {
        if ((v16 & 1) != 0)
          goto LABEL_16;
LABEL_18:
        v25 = v14;
      }
      else
      {
        objc_msgSend(v13, "addObject:", v17);
        if ((v16 & 1) == 0)
          goto LABEL_18;
LABEL_16:
        objc_msgSend(v13, "firstObject");
        v24 = (void *)objc_claimAutoreleasedReturnValue();
        v25 = v14;
        v11[2](v11, v24, v14);
        v26 = objc_claimAutoreleasedReturnValue();

        v66 = (void *)v26;
      }
      objc_msgSend(v17, "endDate");
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      if (objc_msgSend(v27, "compare:", v12) == 1)
      {
        _HKInitializeLogging();
        v28 = *MEMORY[0x1E0CB52A8];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v69 = v17;
          _os_log_impl(&dword_1B7802000, v28, OS_LOG_TYPE_DEFAULT, "Received sensor datum in the future, aborting (%@)", buf, 0xCu);
        }
        v16 = 0;
        v22 = 5;
      }
      else
      {
        objc_msgSend(v27, "timeIntervalSinceDate:", v66);
        if (v29 <= a4)
        {
          if (v29 >= 0.0)
          {
            objc_msgSend(v13, "addObject:", v17);
            v22 = 0;
            v16 = 0;
            ++v15;
          }
          else
          {
            objc_msgSend(v13, "lastObject");
            v36 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v36, "endDate");
            v37 = (void *)objc_claimAutoreleasedReturnValue();
            v38 = v66;
            v39 = v38;
            v60 = v36;
            if (v38 && v37)
            {
              if (objc_msgSend(v38, "compare:", v37) == 1)
                v40 = v37;
              else
                v40 = v39;
            }
            else if (v38)
            {
              v40 = v38;
            }
            else
            {
              v40 = v37;
            }
            v41 = v40;

            v42 = (void *)objc_msgSend(v13, "copy");
            v43 = v25;
            v44 = v25;
            v45 = v41;
            ((void (**)(id, void *, void *, id, void *))v65)[2](v65, v42, v44, v41, v37);

            objc_msgSend(v13, "removeAllObjects");
            v46 = v60;

            v47 = v37;
            v66 = v47;

            v22 = 0;
            v16 = 0;
            v25 = v46;
            v9 = v62;
            v11 = v63;
            v12 = v64;
          }
        }
        else
        {
          if (v29 < a5)
          {
            objc_msgSend(v13, "addObject:", v17);
            ++v15;
          }
          objc_msgSend(v13, "lastObject");
          v30 = (void *)objc_claimAutoreleasedReturnValue();
          v31 = (void *)objc_msgSend(v13, "copy");
          objc_msgSend(v30, "endDate");
          v32 = (void *)objc_claimAutoreleasedReturnValue();
          v33 = ((uint64_t (*)(id, void *, void *, void *, void *))v65[2])(v65, v31, v25, v66, v32);

          if (v33)
          {
            objc_msgSend(v13, "removeAllObjects");
            v34 = v30;

            objc_msgSend(v34, "endDate");
            v35 = objc_claimAutoreleasedReturnValue();

            v66 = (void *)v35;
          }
          else
          {
            objc_msgSend(v13, "firstObject");
            v34 = (id)objc_claimAutoreleasedReturnValue();

            objc_msgSend(v13, "removeObjectAtIndex:", 0);
          }
          v25 = v34;
          v12 = v64;
          v9 = v62;

          v22 = 0;
          v16 = 1;
          v11 = v63;
        }
      }

      v14 = v25;
      goto LABEL_42;
    }
    _HKInitializeLogging();
    v21 = *MEMORY[0x1E0CB52A8];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v69 = v17;
      _os_log_debug_impl(&dword_1B7802000, v21, OS_LOG_TYPE_DEBUG, "Skipping invalid datum: %@", buf, 0xCu);
    }
    ++v15;
    v22 = 4;
LABEL_42:

    if (v22 == 5)
      break;
  }
  objc_msgSend(v12, "timeIntervalSinceDate:", v66);
  v49 = v48;
  v50 = objc_msgSend(v13, "count");
  if (v49 > a4 && v50 != 0)
  {
    objc_msgSend(v13, "lastObject");
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v52, "endDate");
    v53 = (void *)objc_claimAutoreleasedReturnValue();

    v54 = (void *)objc_msgSend(v13, "copy");
    v55 = ((uint64_t (*)(id, void *, id, void *, void *))v65[2])(v65, v54, v14, v66, v53);

    if (v55)
    {
      objc_msgSend(v13, "lastObject");
      v56 = objc_claimAutoreleasedReturnValue();

      v14 = (id)v56;
    }

    v12 = v64;
  }

  return v14;
}

uint64_t _JobNameFromClientAndTaskNames(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;

  v3 = a2;
  objc_msgSend(a1, "stringByAppendingString:", CFSTR("###"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "stringByAppendingString:", v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = objc_retainAutorelease(v5);
  v7 = objc_msgSend(v6, "UTF8String");

  return v7;
}

void sub_1B7809C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B780A178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location)
{
  id *v12;

  objc_destroyWeak(v12);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B780CC20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B780CE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B780D928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B780E434(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B780E4C0(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1B780E4D4(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B780F850(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id HDSampleEntityPredicateForStartDate(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForDate();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("start_date"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDCategorySampleEntityPredicateForValue(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForNumber();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("value"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_1B7810610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7810E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1B7811BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7811DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1B78135C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78138C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7815798(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t HDDataEntityPredicateForOriginProductType(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:value:comparisonType:", CFSTR("data_provenances.origin_product_type"), a2, a1);
}

void sub_1B7815C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78176A8(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  void *v9;
  id v10;
  void *v11;
  void *v12;

  if (a2 == 2)
  {
    v10 = objc_begin_catch(exc_buf);
    v11 = (void *)MEMORY[0x1E0CB35C8];
    objc_msgSend(v10, "reason");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "hk_error:format:", 102, CFSTR("hk_readValue file error: %@"));
    objc_claimAutoreleasedReturnValue();

    objc_end_catch();
  }
  else
  {
    objc_begin_catch(exc_buf);
  }
  JUMPOUT(0x1B781766CLL);
}

BOOL HDCodableObjectCollectionReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  HDCodableSource *v18;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      if (v9++ >= 9)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(HDCodableSource **)(a1 + 160);
        *(_QWORD *)(a1 + 160) = v17;
        goto LABEL_94;
      case 2u:
        v18 = objc_alloc_init(HDCodableSource);
        objc_storeStrong((id *)(a1 + 152), v18);
        if (!PBReaderPlaceMark() || (HDCodableSourceReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 3u:
        v18 = objc_alloc_init(HDCodableCategorySample);
        objc_msgSend((id)a1, "addCategorySamples:", v18);
        if (!PBReaderPlaceMark() || (HDCodableCategorySampleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 4u:
        v18 = objc_alloc_init(HDCodableQuantitySample);
        objc_msgSend((id)a1, "addQuantitySamples:", v18);
        if (!PBReaderPlaceMark() || (HDCodableQuantitySampleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 5u:
        v18 = objc_alloc_init(HDCodableWorkout);
        objc_msgSend((id)a1, "addWorkouts:", v18);
        if (!PBReaderPlaceMark() || (HDCodableWorkoutReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 6u:
        v18 = objc_alloc_init(HDCodableCorrelation);
        objc_msgSend((id)a1, "addCorrelations:", v18);
        if (!PBReaderPlaceMark() || (HDCodableCorrelationReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 7u:
        v18 = objc_alloc_init(HDCodableActivityCache);
        objc_msgSend((id)a1, "addActivityCaches:", v18);
        if (!PBReaderPlaceMark() || (HDCodableActivityCacheReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 8u:
        v18 = objc_alloc_init(HDCodableBinarySample);
        objc_msgSend((id)a1, "addBinarySamples:", v18);
        if (!PBReaderPlaceMark() || !HDCodableBinarySampleReadFrom((uint64_t)v18, a2))
          goto LABEL_98;
        goto LABEL_93;
      case 9u:
        v18 = objc_alloc_init(HDCodableDeletedSample);
        objc_msgSend((id)a1, "addDeletedSamples:", v18);
        if (!PBReaderPlaceMark() || (HDCodableDeletedSampleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0xAu:
        v18 = objc_alloc_init(HDCodableLocationSeries);
        objc_msgSend((id)a1, "addLocationSeries:", v18);
        if (!PBReaderPlaceMark() || (HDCodableLocationSeriesReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0xBu:
        v18 = objc_alloc_init(HDCodableCDADocumentSample);
        objc_msgSend((id)a1, "addCdaDocumentSamples:", v18);
        if (!PBReaderPlaceMark() || (HDCodableCDADocumentSampleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0xDu:
        v18 = objc_alloc_init(HDCodableFitnessFriendActivitySnapshot);
        objc_msgSend((id)a1, "addFitnessFriendActivitySnapshots:", v18);
        if (!PBReaderPlaceMark()
          || (HDCodableFitnessFriendActivitySnapshotReadFrom((uint64_t)v18, a2) & 1) == 0)
        {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0xEu:
        v18 = objc_alloc_init(HDCodableFitnessFriendAchievement);
        objc_msgSend((id)a1, "addFitnessFriendAchievements:", v18);
        if (!PBReaderPlaceMark()
          || (HDCodableFitnessFriendAchievementReadFrom((uint64_t)v18, a2) & 1) == 0)
        {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0xFu:
        v18 = objc_alloc_init(HDCodableFitnessFriendWorkout);
        objc_msgSend((id)a1, "addFitnessFriendWorkouts:", v18);
        if (!PBReaderPlaceMark() || (HDCodableFitnessFriendWorkoutReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x12u:
        v18 = objc_alloc_init(HDCodableGeneratedObjectCollection);
        objc_storeStrong((id *)(a1 + 96), v18);
        if (!PBReaderPlaceMark() || (HDCodableGeneratedObjectCollectionReadFrom(v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x14u:
        v18 = objc_alloc_init(HDCodableProvenance);
        objc_storeStrong((id *)(a1 + 120), v18);
        if (!PBReaderPlaceMark() || (HDCodableProvenanceReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x15u:
        v18 = objc_alloc_init(HDCodableSleepSchedule);
        objc_msgSend((id)a1, "addSleepSchedules:", v18);
        if (!PBReaderPlaceMark() || (HDCodableSleepScheduleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x16u:
        v18 = objc_alloc_init(HDCodableECGSample);
        objc_msgSend((id)a1, "addEcgSamples:", v18);
        if (!PBReaderPlaceMark() || (HDCodableECGSampleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x17u:
        v18 = objc_alloc_init(HDCodableVisionSample);
        objc_msgSend((id)a1, "addVisionSamples:", v18);
        if (!PBReaderPlaceMark() || (HDCodableVisionSampleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x19u:
        v18 = objc_alloc_init(HDCodableStateOfMind);
        objc_msgSend((id)a1, "addStateOfMindLogs:", v18);
        if (!PBReaderPlaceMark() || (HDCodableStateOfMindReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x1Au:
        v18 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 176), v18);
        if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v18, a2))
          goto LABEL_98;
        goto LABEL_93;
      case 0x1Bu:
        v18 = objc_alloc_init(HDCodableScoredAssessment);
        objc_msgSend((id)a1, "addScoredAssessmentSamples:", v18);
        if (!PBReaderPlaceMark() || (HDCodableScoredAssessmentReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x1Cu:
        v18 = objc_alloc_init(HDCodableWorkoutZones);
        objc_msgSend((id)a1, "addWorkoutZones:", v18);
        if (!PBReaderPlaceMark() || !HDCodableWorkoutZonesReadFrom((uint64_t)v18, a2))
          goto LABEL_98;
        goto LABEL_93;
      case 0x1Du:
        v18 = objc_alloc_init(HDCodableActivityGoalSchedule);
        objc_msgSend((id)a1, "addActivityGoalSchedules:", v18);
        if (!PBReaderPlaceMark() || (HDCodableActivityGoalScheduleReadFrom((uint64_t)v18, a2) & 1) == 0)
          goto LABEL_98;
        goto LABEL_93;
      case 0x1Eu:
        v18 = objc_alloc_init(HDCodablePauseRingsSchedule);
        objc_msgSend((id)a1, "addPauseRingsSchedules:", v18);
        if (PBReaderPlaceMark() && (HDCodablePauseRingsScheduleReadFrom((uint64_t)v18, a2) & 1) != 0)
        {
LABEL_93:
          PBReaderRecallMark();
LABEL_94:

LABEL_95:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_98:

        return 0;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0)
          return 0;
        goto LABEL_95;
    }
  }
}

uint64_t HDCodableQuantitySampleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableSample *v18;
  uint64_t result;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void *v26;
  char v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  BOOL v58;
  uint64_t v59;
  uint64_t v60;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v18 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 88), v18);
        if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2) & 1) != 0)
          goto LABEL_66;
        goto LABEL_100;
      case 2u:
        *(_WORD *)(a1 + 100) |= 0x40u;
        v20 = *v3;
        v21 = *(_QWORD *)(a2 + v20);
        if (v21 <= 0xFFFFFFFFFFFFFFF7 && v21 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v60 = 56;
        goto LABEL_97;
      case 3u:
        *(_WORD *)(a1 + 100) |= 0x80u;
        v23 = *v3;
        v24 = *(_QWORD *)(a2 + v23);
        if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v24);
          *(_QWORD *)(a2 + v23) = v24 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v60 = 64;
        goto LABEL_97;
      case 4u:
        PBReaderReadString();
        v25 = objc_claimAutoreleasedReturnValue();
        v26 = *(void **)(a1 + 72);
        *(_QWORD *)(a1 + 72) = v25;

        goto LABEL_98;
      case 5u:
        v27 = 0;
        v28 = 0;
        v29 = 0;
        *(_WORD *)(a1 + 100) |= 0x200u;
        while (2)
        {
          v30 = *v3;
          v31 = *(_QWORD *)(a2 + v30);
          v32 = v31 + 1;
          if (v31 == -1 || v32 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v31);
            *(_QWORD *)(a2 + v30) = v32;
            v29 |= (unint64_t)(v33 & 0x7F) << v27;
            if (v33 < 0)
            {
              v27 += 7;
              v15 = v28++ >= 9;
              if (v15)
              {
                v29 = 0;
                goto LABEL_73;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v29 = 0;
LABEL_73:
        v58 = v29 != 0;
        v59 = 97;
        goto LABEL_82;
      case 6u:
        v34 = 0;
        v35 = 0;
        v36 = 0;
        *(_WORD *)(a1 + 100) |= 1u;
        while (2)
        {
          v37 = *v3;
          v38 = *(_QWORD *)(a2 + v37);
          v39 = v38 + 1;
          if (v38 == -1 || v39 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v40 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v38);
            *(_QWORD *)(a2 + v37) = v39;
            v36 |= (unint64_t)(v40 & 0x7F) << v34;
            if (v40 < 0)
            {
              v34 += 7;
              v15 = v35++ >= 9;
              if (v15)
              {
                v36 = 0;
                goto LABEL_77;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v36 = 0;
LABEL_77:
        *(_QWORD *)(a1 + 8) = v36;
        goto LABEL_98;
      case 7u:
        v41 = 0;
        v42 = 0;
        v43 = 0;
        *(_WORD *)(a1 + 100) |= 0x100u;
        while (2)
        {
          v44 = *v3;
          v45 = *(_QWORD *)(a2 + v44);
          v46 = v45 + 1;
          if (v45 == -1 || v46 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v47 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v45);
            *(_QWORD *)(a2 + v44) = v46;
            v43 |= (unint64_t)(v47 & 0x7F) << v41;
            if (v47 < 0)
            {
              v41 += 7;
              v15 = v42++ >= 9;
              if (v15)
              {
                v43 = 0;
                goto LABEL_81;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v43 = 0;
LABEL_81:
        v58 = v43 != 0;
        v59 = 96;
LABEL_82:
        *(_BYTE *)(a1 + v59) = v58;
        goto LABEL_98;
      case 8u:
        *(_WORD *)(a1 + 100) |= 4u;
        v48 = *v3;
        v49 = *(_QWORD *)(a2 + v48);
        if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v49);
          *(_QWORD *)(a2 + v48) = v49 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v60 = 24;
        goto LABEL_97;
      case 9u:
        *(_WORD *)(a1 + 100) |= 2u;
        v50 = *v3;
        v51 = *(_QWORD *)(a2 + v50);
        if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v51);
          *(_QWORD *)(a2 + v50) = v51 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v60 = 16;
        goto LABEL_97;
      case 0xAu:
        *(_WORD *)(a1 + 100) |= 8u;
        v52 = *v3;
        v53 = *(_QWORD *)(a2 + v52);
        if (v53 <= 0xFFFFFFFFFFFFFFF7 && v53 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v53);
          *(_QWORD *)(a2 + v52) = v53 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v60 = 32;
        goto LABEL_97;
      case 0xBu:
        *(_WORD *)(a1 + 100) |= 0x10u;
        v54 = *v3;
        v55 = *(_QWORD *)(a2 + v54);
        if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v55);
          *(_QWORD *)(a2 + v54) = v55 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v60 = 40;
        goto LABEL_97;
      case 0xCu:
        v18 = objc_alloc_init(HDCodableQuantitySeriesDatum);
        objc_msgSend((id)a1, "addQuantitySeriesData:", v18);
        if (PBReaderPlaceMark() && HDCodableQuantitySeriesDatumReadFrom((uint64_t)v18, a2))
        {
LABEL_66:
          PBReaderRecallMark();

LABEL_98:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_100:

        return 0;
      case 0xDu:
        *(_WORD *)(a1 + 100) |= 0x20u;
        v56 = *v3;
        v57 = *(_QWORD *)(a2 + v56);
        if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v57);
          *(_QWORD *)(a2 + v56) = v57 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v60 = 48;
LABEL_97:
        *(_QWORD *)(a1 + v60) = v22;
        goto LABEL_98;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_98;
    }
  }
}

uint64_t HDCodableSampleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  BOOL v17;
  HDCodableHealthObject *v18;
  uint64_t result;
  char v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (2)
    {
      if (!*(_BYTE *)(a2 + *v5))
      {
        v8 = 0;
        v9 = 0;
        v10 = 0;
        while (1)
        {
          v11 = *v3;
          v12 = *(_QWORD *)(a2 + v11);
          v13 = v12 + 1;
          if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
            break;
          v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
          *(_QWORD *)(a2 + v11) = v13;
          v10 |= (unint64_t)(v14 & 0x7F) << v8;
          if ((v14 & 0x80) == 0)
            goto LABEL_12;
          v8 += 7;
          v15 = v9++ >= 9;
          if (v15)
          {
            v10 = 0;
            v16 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
        v16 = *(unsigned __int8 *)(a2 + *v5);
        if (*(_BYTE *)(a2 + *v5))
          v10 = 0;
LABEL_14:
        if (v16)
          v17 = 1;
        else
          v17 = (v10 & 7) == 4;
        if (!v17)
        {
          switch((v10 >> 3))
          {
            case 1u:
              v18 = objc_alloc_init(HDCodableHealthObject);
              objc_storeStrong((id *)(a1 + 32), v18);
              if (PBReaderPlaceMark() && (HDCodableHealthObjectReadFrom((uint64_t)v18, a2) & 1) != 0)
              {
                PBReaderRecallMark();

                goto LABEL_46;
              }

              return 0;
            case 2u:
              v20 = 0;
              v21 = 0;
              v22 = 0;
              *(_BYTE *)(a1 + 40) |= 1u;
              break;
            case 3u:
              *(_BYTE *)(a1 + 40) |= 4u;
              v27 = *v3;
              v28 = *(_QWORD *)(a2 + v27);
              if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v28);
                *(_QWORD *)(a2 + v27) = v28 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v29 = 0;
              }
              v32 = 24;
              goto LABEL_45;
            case 4u:
              *(_BYTE *)(a1 + 40) |= 2u;
              v30 = *v3;
              v31 = *(_QWORD *)(a2 + v30);
              if (v31 <= 0xFFFFFFFFFFFFFFF7 && v31 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v31);
                *(_QWORD *)(a2 + v30) = v31 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v29 = 0;
              }
              v32 = 16;
LABEL_45:
              *(_QWORD *)(a1 + v32) = v29;
              goto LABEL_46;
            default:
              result = PBReaderSkipValueWithTag();
              if (!(_DWORD)result)
                return result;
LABEL_46:
              if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
                return *(_BYTE *)(a2 + *v5) == 0;
              continue;
          }
          while (1)
          {
            v23 = *v3;
            v24 = *(_QWORD *)(a2 + v23);
            v25 = v24 + 1;
            if (v24 == -1 || v25 > *(_QWORD *)(a2 + *v4))
              break;
            v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v24);
            *(_QWORD *)(a2 + v23) = v25;
            v22 |= (unint64_t)(v26 & 0x7F) << v20;
            if ((v26 & 0x80) == 0)
              goto LABEL_38;
            v20 += 7;
            v15 = v21++ >= 9;
            if (v15)
            {
              v22 = 0;
              goto LABEL_40;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_38:
          if (*(_BYTE *)(a2 + *v5))
            v22 = 0;
LABEL_40:
          *(_QWORD *)(a1 + 8) = v22;
          goto LABEL_46;
        }
      }
      break;
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableCategorySampleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  HDCodableSample *v17;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v18 = 0;
        v19 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v4))
            break;
          v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0)
            goto LABEL_33;
          v18 += 7;
          v14 = v19++ >= 9;
          if (v14)
          {
            v20 = 0;
            goto LABEL_35;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_33:
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_35:
        *(_QWORD *)(a1 + 8) = v20;
      }
      else if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 16), v17);
        if (!PBReaderPlaceMark() || (HDCodableSampleReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B78197B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7819EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  uint64_t v40;

  _Block_object_dispose(&a40, 8);
  _Block_object_dispose((const void *)(v40 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableFitnessFriendActivitySnapshotReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  __objc2_class **v7;
  int *v8;
  int *v9;
  int *v10;
  int *v11;
  char v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  BOOL v19;
  int v20;
  unint64_t v22;
  int *v23;
  int *v24;
  __objc2_class **v25;
  id v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  char v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char v53;
  uint64_t v54;
  unint64_t v55;
  char v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t result;
  uint64_t v83;
  uint64_t v84;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = off_1E6CE3000;
  v8 = &OBJC_IVAR___HDBackgroundObservationServerExtension__sessionUUID;
  v9 = &OBJC_IVAR___HDBackgroundObservationServerExtension__sessionUUID;
  v10 = &OBJC_IVAR___HDBackgroundObservationServerExtension__sessionUUID;
  v11 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    while (1)
    {
      v15 = *v3;
      v16 = *(_QWORD *)(a2 + v15);
      v17 = v16 + 1;
      if (v16 == -1 || v17 > *(_QWORD *)(a2 + *v4))
        break;
      v18 = *(_BYTE *)(*(_QWORD *)(a2 + *v11) + v16);
      *(_QWORD *)(a2 + v15) = v17;
      v14 |= (unint64_t)(v18 & 0x7F) << v12;
      if ((v18 & 0x80) == 0)
        goto LABEL_12;
      v12 += 7;
      v19 = v13++ >= 9;
      if (v19)
      {
        v14 = 0;
        v20 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v20 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v14 = 0;
LABEL_14:
    if (v20 || (v14 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    v22 = v14 >> 3;
    if ((int)(v14 >> 3) > 39)
    {
      if ((int)v22 <= 60)
      {
        if ((int)v22 <= 49)
        {
          if ((_DWORD)v22 == 40)
          {
            *(_DWORD *)(a1 + v10[738]) |= 1u;
            v72 = *v3;
            v73 = *(_QWORD *)(a2 + v72);
            if (v73 <= 0xFFFFFFFFFFFFFFF7 && v73 + 8 <= *(_QWORD *)(a2 + *v4))
            {
              v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v73);
              *(_QWORD *)(a2 + v72) = v73 + 8;
            }
            else
            {
              *(_BYTE *)(a2 + *v5) = 1;
              v29 = 0;
            }
            v84 = 8;
          }
          else
          {
            if ((_DWORD)v22 != 41)
              goto LABEL_112;
            *(_DWORD *)(a1 + v10[738]) |= 2u;
            v39 = *v3;
            v40 = *(_QWORD *)(a2 + v39);
            if (v40 <= 0xFFFFFFFFFFFFFFF7 && v40 + 8 <= *(_QWORD *)(a2 + *v4))
            {
              v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v40);
              *(_QWORD *)(a2 + v39) = v40 + 8;
            }
            else
            {
              *(_BYTE *)(a2 + *v5) = 1;
              v29 = 0;
            }
            v84 = 16;
          }
        }
        else
        {
          switch((_DWORD)v22)
          {
            case '2':
              *(_DWORD *)(a1 + v10[738]) |= 0x8000u;
              v62 = *v3;
              v63 = *(_QWORD *)(a2 + v62);
              if (v63 <= 0xFFFFFFFFFFFFFFF7 && v63 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v63);
                *(_QWORD *)(a2 + v62) = v63 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v29 = 0;
              }
              v84 = 128;
              break;
            case '3':
              *(_DWORD *)(a1 + v10[738]) |= 0x1000u;
              v64 = *v3;
              v65 = *(_QWORD *)(a2 + v64);
              if (v65 <= 0xFFFFFFFFFFFFFFF7 && v65 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v65);
                *(_QWORD *)(a2 + v64) = v65 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v29 = 0;
              }
              v84 = 104;
              break;
            case '<':
              *(_DWORD *)(a1 + v10[738]) |= 0x400u;
              v27 = *v3;
              v28 = *(_QWORD *)(a2 + v27);
              if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v28);
                *(_QWORD *)(a2 + v27) = v28 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v29 = 0;
              }
              v84 = 88;
              break;
            default:
              goto LABEL_112;
          }
        }
        goto LABEL_157;
      }
      if ((int)v22 > 79)
      {
        switch((_DWORD)v22)
        {
          case 'P':
            *(_DWORD *)(a1 + v10[738]) |= 0x200u;
            v66 = *v3;
            v67 = *(_QWORD *)(a2 + v66);
            if (v67 <= 0xFFFFFFFFFFFFFFF7 && v67 + 8 <= *(_QWORD *)(a2 + *v4))
            {
              v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v67);
              *(_QWORD *)(a2 + v66) = v67 + 8;
            }
            else
            {
              *(_BYTE *)(a2 + *v5) = 1;
              v29 = 0;
            }
            v84 = 80;
            break;
          case 'Q':
            *(_DWORD *)(a1 + v10[738]) |= 0x100u;
            v68 = *v3;
            v69 = *(_QWORD *)(a2 + v68);
            if (v69 <= 0xFFFFFFFFFFFFFFF7 && v69 + 8 <= *(_QWORD *)(a2 + *v4))
            {
              v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v69);
              *(_QWORD *)(a2 + v68) = v69 + 8;
            }
            else
            {
              *(_BYTE *)(a2 + *v5) = 1;
              v29 = 0;
            }
            v84 = 72;
            break;
          case 'R':
            v30 = 0;
            v31 = 0;
            v32 = 0;
            *(_DWORD *)(a1 + v10[738]) |= 4u;
            while (1)
            {
              v33 = *v3;
              v34 = *(_QWORD *)(a2 + v33);
              v35 = v34 + 1;
              if (v34 == -1 || v35 > *(_QWORD *)(a2 + *v4))
                break;
              v36 = *(_BYTE *)(*(_QWORD *)(a2 + *v11) + v34);
              *(_QWORD *)(a2 + v33) = v35;
              v32 |= (unint64_t)(v36 & 0x7F) << v30;
              if ((v36 & 0x80) == 0)
                goto LABEL_115;
              v30 += 7;
              v19 = v31++ >= 9;
              if (v19)
              {
                v32 = 0;
                goto LABEL_117;
              }
            }
            *(_BYTE *)(a2 + *v5) = 1;
LABEL_115:
            if (*(_BYTE *)(a2 + *v5))
              v32 = 0;
LABEL_117:
            v83 = 24;
            goto LABEL_130;
          default:
            goto LABEL_112;
        }
LABEL_157:
        *(_QWORD *)(a1 + v84) = v29;
        goto LABEL_158;
      }
      if ((_DWORD)v22 != 61)
      {
        if ((_DWORD)v22 != 70)
          goto LABEL_112;
        *(_DWORD *)(a1 + v10[738]) |= 0x4000u;
        v41 = *v3;
        v42 = *(_QWORD *)(a2 + v41);
        if (v42 <= 0xFFFFFFFFFFFFFFF7 && v42 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v42);
          *(_QWORD *)(a2 + v41) = v42 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v29 = 0;
        }
        v84 = 120;
        goto LABEL_157;
      }
      v74 = 0;
      v75 = 0;
      v32 = 0;
      *(_DWORD *)(a1 + v10[738]) |= 0x10000u;
      while (1)
      {
        v76 = *v3;
        v77 = *(_QWORD *)(a2 + v76);
        v78 = v77 + 1;
        if (v77 == -1 || v78 > *(_QWORD *)(a2 + *v4))
          break;
        v79 = *(_BYTE *)(*(_QWORD *)(a2 + *v11) + v77);
        *(_QWORD *)(a2 + v76) = v78;
        v32 |= (unint64_t)(v79 & 0x7F) << v74;
        if ((v79 & 0x80) == 0)
          goto LABEL_127;
        v74 += 7;
        v19 = v75++ >= 9;
        if (v19)
        {
          v32 = 0;
          goto LABEL_129;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_127:
      if (*(_BYTE *)(a2 + *v5))
        v32 = 0;
LABEL_129:
      v83 = 136;
LABEL_130:
      *(_QWORD *)(a1 + v83) = v32;
      goto LABEL_158;
    }
    if ((int)v22 > 19)
    {
      if ((int)v22 > 29)
      {
        if ((_DWORD)v22 == 30)
        {
          *(_DWORD *)(a1 + v10[738]) |= 8u;
          v80 = *v3;
          v81 = *(_QWORD *)(a2 + v80);
          if (v81 <= 0xFFFFFFFFFFFFFFF7 && v81 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v81);
            *(_QWORD *)(a2 + v80) = v81 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v29 = 0;
          }
          v84 = 32;
        }
        else
        {
          if ((_DWORD)v22 != 31)
          {
LABEL_112:
            result = PBReaderSkipValueWithTag();
            v10 = &OBJC_IVAR___HDBackgroundObservationServerExtension__sessionUUID;
            if (!(_DWORD)result)
              return result;
            goto LABEL_158;
          }
          *(_DWORD *)(a1 + v10[738]) |= 0x10u;
          v43 = *v3;
          v44 = *(_QWORD *)(a2 + v43);
          if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v44);
            *(_QWORD *)(a2 + v43) = v44 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v29 = 0;
          }
          v84 = 40;
        }
      }
      else if ((_DWORD)v22 == 20)
      {
        *(_DWORD *)(a1 + v10[738]) |= 0x40u;
        v70 = *v3;
        v71 = *(_QWORD *)(a2 + v70);
        if (v71 <= 0xFFFFFFFFFFFFFFF7 && v71 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v71);
          *(_QWORD *)(a2 + v70) = v71 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v29 = 0;
        }
        v84 = 56;
      }
      else
      {
        if ((_DWORD)v22 != 21)
          goto LABEL_112;
        *(_DWORD *)(a1 + v10[738]) |= 0x80u;
        v37 = *v3;
        v38 = *(_QWORD *)(a2 + v37);
        if (v38 <= 0xFFFFFFFFFFFFFFF7 && v38 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v38);
          *(_QWORD *)(a2 + v37) = v38 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v29 = 0;
        }
        v84 = 64;
      }
      goto LABEL_157;
    }
    switch((int)v22)
    {
      case 1:
        v23 = v9;
        v24 = v8;
        v25 = v7;
        v26 = objc_alloc_init(v7[87]);
        objc_storeStrong((id *)(a1 + 152), v26);
        if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v26, a2) & 1) != 0)
        {
          PBReaderRecallMark();

          v7 = v25;
          v8 = v24;
          v9 = v23;
          v10 = &OBJC_IVAR___HDBackgroundObservationServerExtension__sessionUUID;
LABEL_158:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      case 2:
        PBReaderReadData();
        v45 = objc_claimAutoreleasedReturnValue();
        v46 = v8[736];
        goto LABEL_66;
      case 3:
        PBReaderReadData();
        v45 = objc_claimAutoreleasedReturnValue();
        v46 = v9[737];
LABEL_66:
        v47 = *(void **)(a1 + v46);
        *(_QWORD *)(a1 + v46) = v45;

        v10 = &OBJC_IVAR___HDBackgroundObservationServerExtension__sessionUUID;
        goto LABEL_158;
      case 4:
        v48 = 0;
        v49 = 0;
        v32 = 0;
        *(_DWORD *)(a1 + v10[738]) |= 0x800u;
        while (2)
        {
          v50 = *v3;
          v51 = *(_QWORD *)(a2 + v50);
          v52 = v51 + 1;
          if (v51 == -1 || v52 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v53 = *(_BYTE *)(*(_QWORD *)(a2 + *v11) + v51);
            *(_QWORD *)(a2 + v50) = v52;
            v32 |= (unint64_t)(v53 & 0x7F) << v48;
            if (v53 < 0)
            {
              v48 += 7;
              v19 = v49++ >= 9;
              if (v19)
              {
                v32 = 0;
                goto LABEL_121;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v32 = 0;
LABEL_121:
        v83 = 96;
        goto LABEL_130;
      case 5:
        *(_DWORD *)(a1 + v10[738]) |= 0x20u;
        v54 = *v3;
        v55 = *(_QWORD *)(a2 + v54);
        if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v11) + v55);
          *(_QWORD *)(a2 + v54) = v55 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v29 = 0;
        }
        v84 = 48;
        goto LABEL_157;
      case 6:
        v56 = 0;
        v57 = 0;
        v32 = 0;
        *(_DWORD *)(a1 + v10[738]) |= 0x2000u;
        while (2)
        {
          v58 = *v3;
          v59 = *(_QWORD *)(a2 + v58);
          v60 = v59 + 1;
          if (v59 == -1 || v60 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v61 = *(_BYTE *)(*(_QWORD *)(a2 + *v11) + v59);
            *(_QWORD *)(a2 + v58) = v60;
            v32 |= (unint64_t)(v61 & 0x7F) << v56;
            if (v61 < 0)
            {
              v56 += 7;
              v19 = v57++ >= 9;
              if (v19)
              {
                v32 = 0;
                goto LABEL_125;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v32 = 0;
LABEL_125:
        v83 = 112;
        goto LABEL_130;
      default:
        goto LABEL_112;
    }
  }
}

uint64_t HDCodableFitnessFriendAchievementReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableSample *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  void *v34;
  uint64_t v35;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v18 = objc_alloc_init(HDCodableSample);
          objc_storeStrong((id *)(a1 + 40), v18);
          if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2) & 1) != 0)
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          PBReaderReadData();
          v19 = objc_claimAutoreleasedReturnValue();
          v20 = 32;
          goto LABEL_39;
        case 4u:
          *(_BYTE *)(a1 + 56) |= 1u;
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v24 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v23);
            *(_QWORD *)(a2 + v22) = v23 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v24 = 0;
          }
          v35 = 8;
          goto LABEL_48;
        case 5u:
          *(_BYTE *)(a1 + 56) |= 2u;
          v25 = *v3;
          v26 = *(_QWORD *)(a2 + v25);
          if (v26 <= 0xFFFFFFFFFFFFFFF7 && v26 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v24 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v26);
            *(_QWORD *)(a2 + v25) = v26 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v24 = 0;
          }
          v35 = 16;
LABEL_48:
          *(_QWORD *)(a1 + v35) = v24;
          continue;
        case 6u:
          v27 = 0;
          v28 = 0;
          v29 = 0;
          *(_BYTE *)(a1 + 56) |= 4u;
          break;
        case 0xAu:
          PBReaderReadString();
          v19 = objc_claimAutoreleasedReturnValue();
          v20 = 48;
LABEL_39:
          v34 = *(void **)(a1 + v20);
          *(_QWORD *)(a1 + v20) = v19;

          continue;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v30 = *v3;
        v31 = *(_QWORD *)(a2 + v30);
        v32 = v31 + 1;
        if (v31 == -1 || v32 > *(_QWORD *)(a2 + *v4))
          break;
        v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v31);
        *(_QWORD *)(a2 + v30) = v32;
        v29 |= (unint64_t)(v33 & 0x7F) << v27;
        if ((v33 & 0x80) == 0)
          goto LABEL_41;
        v27 += 7;
        v15 = v28++ >= 9;
        if (v15)
        {
          v29 = 0;
          goto LABEL_43;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_41:
      if (*(_BYTE *)(a2 + *v5))
        v29 = 0;
LABEL_43:
      *(_QWORD *)(a1 + 24) = v29;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableMetadataDictionaryReadFrom(void *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableMetadataKeyValuePair *v17;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableMetadataKeyValuePair);
        objc_msgSend(a1, "addKeyValuePairs:", v17);
        if (!PBReaderPlaceMark() || (HDCodableMetadataKeyValuePairReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableMetadataKeyValuePairReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t v31;
  unint64_t v32;
  HDCodableQuantity *v33;
  void *v34;
  uint64_t v35;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 40;
        goto LABEL_40;
      case 2u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 56;
        goto LABEL_40;
      case 3u:
        *(_BYTE *)(a1 + 64) |= 1u;
        v21 = *v3;
        v22 = *(_QWORD *)(a2 + v21);
        if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v23 = 0;
        }
        v35 = 8;
        goto LABEL_49;
      case 4u:
        v24 = 0;
        v25 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 64) |= 4u;
        while (2)
        {
          v27 = *v3;
          v28 = *(_QWORD *)(a2 + v27);
          v29 = v28 + 1;
          if (v28 == -1 || v29 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v29;
            v26 |= (unint64_t)(v30 & 0x7F) << v24;
            if (v30 < 0)
            {
              v24 += 7;
              v15 = v25++ >= 9;
              if (v15)
              {
                v26 = 0;
                goto LABEL_44;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_44:
        *(_QWORD *)(a1 + 24) = v26;
        goto LABEL_50;
      case 5u:
        *(_BYTE *)(a1 + 64) |= 2u;
        v31 = *v3;
        v32 = *(_QWORD *)(a2 + v31);
        if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v32);
          *(_QWORD *)(a2 + v31) = v32 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v23 = 0;
        }
        v35 = 16;
LABEL_49:
        *(_QWORD *)(a1 + v35) = v23;
        goto LABEL_50;
      case 6u:
        v33 = objc_alloc_init(HDCodableQuantity);
        objc_storeStrong((id *)(a1 + 48), v33);
        if (PBReaderPlaceMark() && (HDCodableQuantityReadFrom((uint64_t)v33, a2) & 1) != 0)
        {
          PBReaderRecallMark();

LABEL_50:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      case 7u:
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 32;
LABEL_40:
        v34 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_50;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_50;
    }
  }
}

void sub_1B781C0E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B781FC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a41, 8);
  _Unwind_Resume(a1);
}

id HDSampleEntityPredicateForDataType(void *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(a1, "code"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:equalToValue:", CFSTR("data_type"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1B781FE10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;

  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1B7820224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7820BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;
  void *v25;

  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1B7820CA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B7820F60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B7821024(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B7821C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSourceEntityPredicateForLocalDeviceSource()
{
  void *v0;
  void *v1;

  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("local_device"), MEMORY[0x1E0C9AAB0]);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  _HDSourceEntityPredicateForNotDeletedWithPredicate(v0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  return v1;
}

void sub_1B7822B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7822F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

void sub_1B78239B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78243CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1B7824464(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id HDActivityCacheEntityPredicateForCacheIndex(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;

  v3 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "predicateWithProperty:value:comparisonType:", CFSTR("cache_index"), v4, a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

uint64_t HDDataEntityPredicateForSourceIdentifier(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("data_provenances.source_id"), a1);
}

id HDActivityCacheEntityPredicateForCachesInDateComponentsRange(uint64_t a1, void *a2)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;

  v2 = a2;
  v3 = _HKCacheIndexFromDateComponents();
  v4 = _HKCacheIndexFromDateComponents();

  HDActivityCacheEntityPredicateForCacheIndex(v3, 6);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  HDActivityCacheEntityPredicateForCacheIndex(v4, 4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v5, v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

id HDDataEntityPredicateForDataUUID()
{
  void *v0;
  void *v1;
  void *v2;

  v0 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForUUID();
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "predicateWithProperty:equalToValue:", CFSTR("uuid"), v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

uint64_t HDSyncAnchorRangeMake(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  if (a2 < a1)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "HDSyncAnchorRange HDSyncAnchorRangeMake(HDSyncAnchor, HDSyncAnchor)");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("HDSyncSupport.m"), 14, CFSTR("Invalid parameter not satisfying: %@"), CFSTR("end >= start"));

  }
  return a1;
}

void SetInPersistentUserInfo(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v8 = a1;
  v3 = a2;
  v4 = (void *)objc_msgSend(v3, "copyForPersistentUserInfo");
  v5 = v4;
  if (v4)
  {
    objc_msgSend(v4, "data");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend((id)objc_opt_class(), "persistentUserInfoKey");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v6, v7);

  }
}

id GetFromPersistentUserInfo(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;

  v3 = a1;
  objc_msgSend(a2, "persistentUserInfoKey");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKeyedSubscript:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
    v6 = (void *)objc_msgSend(objc_alloc((Class)a2), "initWithData:", v5);
  else
    v6 = 0;

  return v6;
}

uint64_t HDCodableNanoSyncChangeSetReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableNanoSyncChange *v18;
  uint64_t result;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char v31;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v18 = objc_alloc_init(HDCodableNanoSyncChange);
        objc_msgSend((id)a1, "addChanges:", v18);
        if (PBReaderPlaceMark() && (HDCodableNanoSyncChangeReadFrom((uint64_t)v18, a2) & 1) != 0)
          goto LABEL_30;
        goto LABEL_46;
      case 2u:
        PBReaderReadData();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = *(void **)(a1 + 32);
        *(_QWORD *)(a1 + 32) = v20;

        goto LABEL_44;
      case 3u:
        *(_BYTE *)(a1 + 44) |= 1u;
        v22 = *v3;
        v23 = *(_QWORD *)(a2 + v22);
        if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v24 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v23);
          *(_QWORD *)(a2 + v22) = v23 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v24 = 0;
        }
        *(_QWORD *)(a1 + 8) = v24;
        goto LABEL_44;
      case 4u:
        v18 = objc_alloc_init(HDCodableError);
        objc_storeStrong((id *)(a1 + 24), v18);
        if (PBReaderPlaceMark() && (HDCodableErrorReadFrom((uint64_t)v18, a2) & 1) != 0)
        {
LABEL_30:
          PBReaderRecallMark();

LABEL_44:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_46:

        return 0;
      case 5u:
        v25 = 0;
        v26 = 0;
        v27 = 0;
        *(_BYTE *)(a1 + 44) |= 2u;
        while (2)
        {
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          v30 = v29 + 1;
          if (v29 == -1 || v30 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v31 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
            *(_QWORD *)(a2 + v28) = v30;
            v27 |= (unint64_t)(v31 & 0x7F) << v25;
            if (v31 < 0)
            {
              v25 += 7;
              v15 = v26++ >= 9;
              if (v15)
              {
                LODWORD(v27) = 0;
                goto LABEL_41;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v27) = 0;
LABEL_41:
        *(_DWORD *)(a1 + 40) = v27;
        goto LABEL_44;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_44;
    }
  }
}

uint64_t HDCodableNanoSyncChangeReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  HDCodableNanoSyncAnchor *v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char v41;
  char v42;
  unsigned int v43;
  uint64_t v44;
  unint64_t v45;
  char v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  uint64_t v53;
  BOOL v54;
  uint64_t v55;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 76) |= 8u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_76;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_78;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_76:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_78:
        *(_DWORD *)(a1 + 48) = v19;
        goto LABEL_101;
      case 2u:
        v24 = 0;
        v25 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 76) |= 4u;
        while (2)
        {
          v27 = *v3;
          v28 = *(_QWORD *)(a2 + v27);
          if (v28 == -1 || v28 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v28 + 1;
            v26 |= (unint64_t)(v29 & 0x7F) << v24;
            if (v29 < 0)
            {
              v24 += 7;
              v14 = v25++ >= 9;
              if (v14)
              {
                v26 = 0;
                goto LABEL_82;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_82:
        v53 = 24;
        goto LABEL_95;
      case 3u:
        v30 = 0;
        v31 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 76) |= 1u;
        while (2)
        {
          v32 = *v3;
          v33 = *(_QWORD *)(a2 + v32);
          if (v33 == -1 || v33 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v34 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v33);
            *(_QWORD *)(a2 + v32) = v33 + 1;
            v26 |= (unint64_t)(v34 & 0x7F) << v30;
            if (v34 < 0)
            {
              v30 += 7;
              v14 = v31++ >= 9;
              if (v14)
              {
                v26 = 0;
                goto LABEL_86;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_86:
        v53 = 8;
        goto LABEL_95;
      case 4u:
        PBReaderReadData();
        v35 = (HDCodableNanoSyncAnchor *)objc_claimAutoreleasedReturnValue();
        if (v35)
          objc_msgSend((id)a1, "addObjectData:", v35);
        goto LABEL_74;
      case 5u:
        v35 = objc_alloc_init(HDCodableNanoSyncAnchor);
        objc_msgSend((id)a1, "addRequiredAnchors:", v35);
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncAnchorReadFrom((uint64_t)v35, a2) & 1) == 0)
          goto LABEL_103;
        goto LABEL_73;
      case 6u:
        v36 = 0;
        v37 = 0;
        v38 = 0;
        *(_BYTE *)(a1 + 76) |= 0x20u;
        while (2)
        {
          v39 = *v3;
          v40 = *(_QWORD *)(a2 + v39);
          if (v40 == -1 || v40 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v41 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v40);
            *(_QWORD *)(a2 + v39) = v40 + 1;
            v38 |= (unint64_t)(v41 & 0x7F) << v36;
            if (v41 < 0)
            {
              v36 += 7;
              v14 = v37++ >= 9;
              if (v14)
              {
                v38 = 0;
                goto LABEL_90;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v38 = 0;
LABEL_90:
        v54 = v38 != 0;
        v55 = 73;
        goto LABEL_100;
      case 7u:
        v42 = 0;
        v43 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 76) |= 2u;
        while (2)
        {
          v44 = *v3;
          v45 = *(_QWORD *)(a2 + v44);
          if (v45 == -1 || v45 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v46 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v45);
            *(_QWORD *)(a2 + v44) = v45 + 1;
            v26 |= (unint64_t)(v46 & 0x7F) << v42;
            if (v46 < 0)
            {
              v42 += 7;
              v14 = v43++ >= 9;
              if (v14)
              {
                v26 = 0;
                goto LABEL_94;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_94:
        v53 = 16;
LABEL_95:
        *(_QWORD *)(a1 + v53) = v26;
        goto LABEL_101;
      case 8u:
        v47 = 0;
        v48 = 0;
        v49 = 0;
        *(_BYTE *)(a1 + 76) |= 0x10u;
        while (2)
        {
          v50 = *v3;
          v51 = *(_QWORD *)(a2 + v50);
          if (v51 == -1 || v51 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v52 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v51);
            *(_QWORD *)(a2 + v50) = v51 + 1;
            v49 |= (unint64_t)(v52 & 0x7F) << v47;
            if (v52 < 0)
            {
              v47 += 7;
              v14 = v48++ >= 9;
              if (v14)
              {
                v49 = 0;
                goto LABEL_99;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v49 = 0;
LABEL_99:
        v54 = v49 != 0;
        v55 = 72;
LABEL_100:
        *(_BYTE *)(a1 + v55) = v54;
        goto LABEL_101;
      case 9u:
        v35 = objc_alloc_init(HDCodableEntityIdentifier);
        objc_storeStrong((id *)(a1 + 32), v35);
        if (!PBReaderPlaceMark() || (HDCodableEntityIdentifierReadFrom((uint64_t)v35, a2) & 1) == 0)
          goto LABEL_103;
        goto LABEL_73;
      case 0xAu:
        v35 = objc_alloc_init(HDCodableSyncVersionRange);
        objc_storeStrong((id *)(a1 + 64), v35);
        if (PBReaderPlaceMark() && HDCodableSyncVersionRangeReadFrom((uint64_t)v35, a2))
        {
LABEL_73:
          PBReaderRecallMark();
LABEL_74:

LABEL_101:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_103:

        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_101;
    }
  }
}

id HDNanoSyncDescriptionWithArray(void *a1)
{
  id v1;
  id v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v18;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v18 != v6)
          objc_enumerationMutation(v3);
        v8 = *(void **)(*((_QWORD *)&v17 + 1) + 8 * i);
        objc_msgSend(v8, "nanoSyncDescription");
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        v10 = v9;
        if (v9)
        {
          v11 = v9;
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("<%@:%p>"), objc_opt_class(), v8, (_QWORD)v17);
          v11 = (id)objc_claimAutoreleasedReturnValue();
        }
        v12 = v11;

        objc_msgSend(v2, "addObject:", v12);
      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
    }
    while (v5);
  }

  v13 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(v2, "componentsJoinedByString:", CFSTR(", "));
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "stringWithFormat:", CFSTR("(%@)"), v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

id FormattedMessageDescription(int a1, int a2, int a3, void *a4, void *a5)
{
  __CFString *v9;
  id v10;
  void *v11;
  const char *v12;
  const char *v13;
  const __CFString *v14;
  void *v15;

  v9 = a5;
  v10 = a4;
  HDNanoSyncMessageIDString(a1);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = "outgoing";
  if (a2)
    v12 = "incoming";
  v13 = "response";
  if (a3)
    v13 = "request";
  v14 = &stru_1E6D11BB8;
  if (v9)
    v14 = v9;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s %@ %s %@ %@"), v12, v11, v13, v10, v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

const __CFString *HDNanoSyncMessageIDString(int a1)
{
  if ((a1 - 1) > 0xC)
    return CFSTR("Unknown");
  else
    return off_1E6CFBB40[(__int16)(a1 - 1)];
}

void sub_1B782BD88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1B782BE04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B782F0D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableNanoSyncMessageReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t result;
  HDCodableNanoSyncChangeSet *v27;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 2u:
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 68) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_49;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_51;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_49:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_51:
        *(_DWORD *)(a1 + 64) = v19;
        goto LABEL_46;
      case 3u:
        PBReaderReadData();
        v23 = objc_claimAutoreleasedReturnValue();
        v24 = 48;
        goto LABEL_28;
      case 4u:
        PBReaderReadData();
        v23 = objc_claimAutoreleasedReturnValue();
        v24 = 40;
LABEL_28:
        v25 = *(void **)(a1 + v24);
        *(_QWORD *)(a1 + v24) = v23;

        goto LABEL_46;
      case 7u:
        v27 = objc_alloc_init(HDCodableNanoSyncChangeSet);
        objc_storeStrong((id *)(a1 + 16), v27);
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncChangeSetReadFrom((uint64_t)v27, a2) & 1) == 0)
          goto LABEL_53;
        goto LABEL_45;
      case 8u:
        v27 = objc_alloc_init(HDCodableNanoSyncStatus);
        objc_storeStrong((id *)(a1 + 56), v27);
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncStatusReadFrom((uint64_t)v27, a2) & 1) == 0)
          goto LABEL_53;
        goto LABEL_45;
      case 9u:
        v27 = objc_alloc_init(HDCodableNanoSyncActivationRestore);
        objc_storeStrong((id *)(a1 + 8), v27);
        if (!PBReaderPlaceMark()
          || (HDCodableNanoSyncActivationRestoreReadFrom((uint64_t)v27, a2) & 1) == 0)
        {
          goto LABEL_53;
        }
        goto LABEL_45;
      case 0xAu:
        v27 = objc_alloc_init(HDCodableSyncEntityVersionMap);
        objc_storeStrong((id *)(a1 + 32), v27);
        if (!PBReaderPlaceMark() || (HDCodableSyncEntityVersionMapReadFrom(v27, a2) & 1) == 0)
          goto LABEL_53;
        goto LABEL_45;
      case 0xBu:
        v27 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 24), v27);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v27, a2))
        {
LABEL_45:
          PBReaderRecallMark();

LABEL_46:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_53:

        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_46;
    }
  }
}

uint64_t HDCodableNanoSyncStatusReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  HDCodableNanoSyncAnchor *v23;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v23 = objc_alloc_init(HDCodableNanoSyncAnchor);
        objc_msgSend((id)a1, "addAnchors:", v23);
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncAnchorReadFrom((uint64_t)v23, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 20) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_33;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_35;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_33:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_35:
        *(_DWORD *)(a1 + 16) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableNanoSyncAnchorReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  unint64_t v17;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  HDCodableEntityIdentifier *v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        v24 = objc_alloc_init(HDCodableEntityIdentifier);
        objc_storeStrong((id *)(a1 + 16), v24);
        if (!PBReaderPlaceMark() || (HDCodableEntityIdentifierReadFrom((uint64_t)v24, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else if ((_DWORD)v17 == 2)
      {
        v25 = 0;
        v26 = 0;
        v27 = 0;
        *(_BYTE *)(a1 + 28) |= 1u;
        while (1)
        {
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
            break;
          v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
          *(_QWORD *)(a2 + v28) = v29 + 1;
          v27 |= (unint64_t)(v30 & 0x7F) << v25;
          if ((v30 & 0x80) == 0)
            goto LABEL_45;
          v25 += 7;
          v14 = v26++ >= 9;
          if (v14)
          {
            v27 = 0;
            goto LABEL_47;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_45:
        if (*(_BYTE *)(a2 + *v5))
          v27 = 0;
LABEL_47:
        *(_QWORD *)(a1 + 8) = v27;
      }
      else if ((_DWORD)v17 == 1)
      {
        v18 = 0;
        v19 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 28) |= 2u;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v4))
            break;
          v23 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0)
            goto LABEL_41;
          v18 += 7;
          v14 = v19++ >= 9;
          if (v14)
          {
            LODWORD(v20) = 0;
            goto LABEL_43;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_41:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v20) = 0;
LABEL_43:
        *(_DWORD *)(a1 + 24) = v20;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

id HDNanoSyncDescriptionSafe(void *a1)
{
  id v1;
  void *v2;
  objc_class *v3;

  v1 = a1;
  if (objc_msgSend(v1, "conformsToProtocol:", &unk_1EF1A7A90))
  {
    objc_msgSend(v1, "nanoSyncDescription");
    v2 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v3 = (objc_class *)objc_opt_class();

    NSStringFromClass(v3);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
  }
  return v2;
}

void sub_1B7832748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7832804(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B7832FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1B7833218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B783364C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7833C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7834594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HKWorkoutLocationBundle()
{
  if (qword_1ED552548 != -1)
    dispatch_once(&qword_1ED552548, &__block_literal_global_215);
  return (id)_MergedGlobals_226;
}

void HDSetHealthInUseDefaultWithReason(void *a1)
{
  id v1;
  void *v2;
  char v3;
  NSObject *v4;
  void *v5;
  int v6;
  id v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "BOOLForKey:", CFSTR("HDHealthInUse"));

  if ((v3 & 1) == 0)
  {
    _HKInitializeLogging();
    v4 = *MEMORY[0x1E0CB52C0];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52C0], OS_LOG_TYPE_DEBUG))
    {
      v6 = 138543362;
      v7 = v1;
      _os_log_debug_impl(&dword_1B7802000, v4, OS_LOG_TYPE_DEBUG, "Marking health as in use: %{public}@", (uint8_t *)&v6, 0xCu);
    }
    objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setValue:forKey:", MEMORY[0x1E0C9AAB0], CFSTR("HDHealthInUse"));

  }
}

void sub_1B7835720(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78357C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78358B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1B7835A24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B7835D80(_Unwind_Exception *a1, void *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  va_list va;

  va_start(va, a12);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7836020(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  char v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v12 = a3;
  v7 = operator new(0x20uLL);
  *v7 = &unk_1E6CEA7E0;
  v7[1] = a2;
  v7[2] = &v12;
  v7[3] = a4;
  v14 = v7;
  v8 = health::DataStore::performWriteTransactionWithLambda(a1, (uint64_t)v13);
  v9 = v14;
  if (v14 == v13)
  {
    v10 = 4;
    v9 = v13;
    goto LABEL_5;
  }
  if (v14)
  {
    v10 = 5;
LABEL_5:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  return v8;
}

void sub_1B7836114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t health::DataStore::performWriteTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6[0] = &off_1E6D0AD80;
  v6[1] = a1;
  v6[2] = a2;
  v7 = v6;
  v2 = health::BlockAccessFile::performWriteTransactionWithLambda(a1, (uint64_t)v6);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return v2;
}

void sub_1B78361E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::performWriteTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6[0] = &off_1E6CFC618;
  v6[1] = a1;
  v6[2] = a2;
  v7 = v6;
  v2 = health::TransactionalFile::writeTransactionWithLambda(a1, (uint64_t)v6);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return v2;
}

void sub_1B78362BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t health::TransactionalFile::writeTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  pthread_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  std::runtime_error *exception;
  std::runtime_error *v23;
  std::mutex *v24;
  char v25;
  pthread_t v26;
  std::string __p;
  void *v28[2];
  void *v29[2];
  void *v30[2];
  std::unique_lock<std::mutex> v31;
  _QWORD v32[3];
  _QWORD *v33;
  _QWORD v34[3];
  _QWORD *v35;
  _QWORD v36[3];
  _QWORD *v37;
  _BYTE v38[24];
  _BYTE *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v31.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 584);
  v31.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 584));
  if (!*(_QWORD *)(a1 + 328))
  {
    v4 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v30, "isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v29, "writeTransactionWithLambda");
    std::string::basic_string[abi:ne180100]<0>(v28, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"File has not yet been opened.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v4, (uint64_t)v30, (uint64_t)v29, (uint64_t)v28, 259, (uint64_t)&__p);
  }
  v5 = pthread_self();
  v26 = v5;
  v6 = std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(a1 + 768, (unint64_t)v5);
  if ((_QWORD *)(a1 + 776) != v6)
  {
    v7 = v6;
    std::unique_lock<std::mutex>::unlock(&v31);
    v8 = *(_QWORD *)(a2 + 24);
    if (!v8)
      std::__throw_bad_function_call[abi:ne180100]();
    if (((*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 48))(v8, v7[5]) & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Nested write transaction failed.");
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v9 = 1;
    goto LABEL_33;
  }
  if ((_QWORD *)(a1 + 704) != std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(a1 + 696, (unint64_t)v5))
  {
    v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v23, "Unable to upgrade from a read transaction to a write transaction.");
    goto LABEL_40;
  }
  health::TransactionalFile::_transactionMutex_waitForAvailableWriteTransaction(a1, &v31);
  if (*(_BYTE *)(a1 + 344))
  {
    v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v23, "Write transaction attempted after file was closed.");
LABEL_40:
    v23->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC328;
  }
  v25 = 0;
  v24 = (std::mutex *)(a1 + 416);
  v10 = *(_QWORD *)(a1 + 376);
  v11 = *(_DWORD *)(a1 + 408);
  v12 = operator new(0x28uLL);
  *v12 = &off_1E6CEC060;
  v12[1] = a1;
  v12[2] = &v26;
  v12[3] = &v31;
  v12[4] = a2;
  v39 = v12;
  v36[0] = &off_1E6CEC0F0;
  v36[1] = &v24;
  v36[2] = a1;
  v37 = v36;
  v34[0] = &off_1E6CEC170;
  v34[1] = a1;
  v35 = v34;
  v32[0] = &off_1E6CEC1F0;
  v32[1] = a1;
  v32[2] = &v24;
  v33 = v32;
  v9 = health::WriteAheadLog::runWriteTransaction((health::WriteAheadLog *)(a1 + 16), v10, v11, (uint64_t)v38, (uint64_t)v36, (uint64_t)v34, (uint64_t)v32);
  v13 = v33;
  if (v33 == v32)
  {
    v14 = 4;
    v13 = v32;
  }
  else
  {
    if (!v33)
      goto LABEL_14;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_14:
  v15 = v35;
  if (v35 == v34)
  {
    v16 = 4;
    v15 = v34;
  }
  else
  {
    if (!v35)
      goto LABEL_19;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_19:
  v17 = v37;
  if (v37 == v36)
  {
    v18 = 4;
    v17 = v36;
  }
  else
  {
    if (!v37)
      goto LABEL_24;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_24:
  v19 = v39;
  if (v39 == v38)
  {
    v20 = 4;
    v19 = v38;
    goto LABEL_28;
  }
  if (v39)
  {
    v20 = 5;
LABEL_28:
    (*(void (**)(void))(*v19 + 8 * v20))();
  }
  if (!v31.__owns_)
    std::unique_lock<std::mutex>::lock(&v31);
  std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>((uint64_t **)(a1 + 768), (unint64_t)v26);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 648));
  if (v25)
    std::mutex::unlock(v24);
LABEL_33:
  if (v31.__owns_)
    std::mutex::unlock(v31.__m_);
  return v9;
}

void sub_1B78366F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::mutex *a28,char a29)
{
  if (a14)
    std::mutex::unlock(a13);
  if (a29)
    std::mutex::unlock(a28);
  _Unwind_Resume(exception_object);
}

void sub_1B78366F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::mutex *a28,char a29)
{
  void *v29;

  __cxa_free_exception(v29);
  if (a29)
    std::mutex::unlock(a28);
  _Unwind_Resume(a1);
}

void sub_1B7836710(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char *a33)
{
  uint64_t v33;
  char *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;

  if (!a2)
    JUMPOUT(0x1B78368ACLL);
  v35 = a33;
  if (a33 == &a30)
  {
    v36 = 4;
    v35 = &a30;
  }
  else
  {
    if (!a33)
      goto LABEL_7;
    v36 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v35 + 8 * v36))();
LABEL_7:
  v37 = *(_QWORD **)(v33 - 144);
  if (v37 == (_QWORD *)(v33 - 168))
  {
    v38 = 4;
    v37 = (_QWORD *)(v33 - 168);
  }
  else
  {
    if (!v37)
      goto LABEL_12;
    v38 = 5;
  }
  (*(void (**)(void))(*v37 + 8 * v38))();
LABEL_12:
  v39 = *(_QWORD **)(v33 - 112);
  if (v39 == (_QWORD *)(v33 - 136))
  {
    v40 = 4;
    v39 = (_QWORD *)(v33 - 136);
  }
  else
  {
    if (!v39)
      goto LABEL_17;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_17:
  v41 = *(_QWORD **)(v33 - 80);
  if (v41 == (_QWORD *)(v33 - 104))
  {
    v42 = 4;
    v41 = (_QWORD *)(v33 - 104);
  }
  else
  {
    if (!v41)
      goto LABEL_22;
    v42 = 5;
  }
  (*(void (**)(void))(*v41 + 8 * v42))();
LABEL_22:
  __cxa_begin_catch(a1);
  health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_1::operator()((uint64_t)&a10);
  __cxa_rethrow();
}

void sub_1B78367FC()
{
  __cxa_end_catch();
  JUMPOUT(0x1B7836804);
}

void sub_1B7836818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

off_t health::POSIXFile::size(health::POSIXFile *this)
{
  return lseek(*((_DWORD *)this + 2), 0, 2);
}

void std::unique_lock<std::mutex>::unlock(std::unique_lock<std::mutex> *this)
{
  health::POSIXFile *v2;
  char *v3;

  if (this->__owns_)
  {
    std::mutex::unlock(this->__m_);
    this->__owns_ = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    health::POSIXFile::truncate(v2, v3);
  }
}

uint64_t health::POSIXFile::truncate(health::POSIXFile *this, char *a2)
{
  uint64_t result;
  void *exception;
  uint64_t v4;
  const std::error_category *v5;
  int *v6;
  int *v7;
  char *v8;
  std::string v9;
  char *v10;

  v10 = a2;
  result = ftruncate(*((_DWORD *)this + 2), (off_t)a2);
  if ((_DWORD)result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v4 = *__error();
    v5 = std::system_category();
    v6 = __error();
    v7 = __error();
    v8 = strerror(*v7);
    health::FormatString<long long &,int &,char *>(&v9, &v10, (char **)v6, &v8);
    MEMORY[0x1BCCAC2B4](exception, v4, v5, &v9);
    __cxa_throw(exception, MEMORY[0x1E0DE4E38], MEMORY[0x1E0DE4580]);
  }
  return result;
}

void sub_1B78369BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;
  int v17;

  if (a16 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

unint64_t health::VirtualFile::write<health::WriteAheadLog::LogHeader>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE v9[1024];
  _BYTE *v10;
  unint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  health::SerializeToBuffer<health::WriteAheadLog::LogHeader>(a3, (uint64_t)v9);
  v5 = v11;
  if (v11 <= 0x3FF)
    v6 = v9;
  else
    v6 = v10;
  (*(void (**)(uint64_t, uint64_t, _BYTE *, unint64_t))(*(_QWORD *)a1 + 24))(a1, a2, v6, v11);
  v7 = v10;
  v10 = 0;
  if (v7)
    MEMORY[0x1BCCAC47C](v7, 0x1000C8077774924);
  return v5;
}

void sub_1B7836ABC(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x408];
  STACK[0x408] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::SerializeToBuffer<health::WriteAheadLog::LogHeader>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD v3[3];

  *(_QWORD *)(a2 + 1024) = 0;
  *(_QWORD *)(a2 + 1032) = 24;
  v3[0] = a2;
  v3[1] = a2;
  v3[2] = 24;
  return health::WriteAheadLog::LogHeader::serialize(a1, (uint64_t)v3);
}

void sub_1B7836B30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 1024);
  *(_QWORD *)(v1 + 1024) = 0;
  if (v3)
    MEMORY[0x1BCCAC47C](v3, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned int>(uint64_t result, _DWORD *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 3uLL)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(_DWORD **)(result + 8) = *a2;
  v3 = *(_QWORD *)(result + 16) - 4;
  *(_QWORD *)(result + 8) += 4;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B7836C5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned long long>(uint64_t result, _QWORD *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 7uLL)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(_QWORD **)(result + 8) = *a2;
  v3 = *(_QWORD *)(result + 16) - 8;
  *(_QWORD *)(result + 8) += 8;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B7836DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

ssize_t health::POSIXFile::write(health::POSIXFile *this, char *a2, const unsigned __int8 *__buf, char *__nbyte)
{
  ssize_t result;
  void *exception;
  uint64_t v6;
  const std::error_category *v7;
  int *v8;
  int *v9;
  char *v10;
  std::string v11;
  char *v12;
  char *v13;

  v12 = __nbyte;
  v13 = a2;
  result = pwrite(*((_DWORD *)this + 2), __buf, (size_t)__nbyte, (off_t)a2);
  if (result < 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v6 = *__error();
    v7 = std::system_category();
    v8 = __error();
    v9 = __error();
    v10 = strerror(*v9);
    health::FormatString<unsigned long &,long long &,int &,char *>(&v11, (std::string *)"Error occurred writing {0} bytes at {1}: {2} {3}", &v12, &v13, (char **)v8, &v10);
    MEMORY[0x1BCCAC2B4](exception, v6, v7, &v11);
    __cxa_throw(exception, MEMORY[0x1E0DE4E38], MEMORY[0x1E0DE4580]);
  }
  return result;
}

void sub_1B7836EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

unint64_t health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  health *v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[1024];
  _BYTE *v15;
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16 = 36;
  v10 = (health *)v14;
  v11 = v14;
  v12 = 36;
  LODWORD(v13) = *(_DWORD *)a3;
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)&v10, &v13);
  v13 = *(_QWORD *)(a3 + 8);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)&v10, &v13);
  v13 = *(_QWORD *)(a3 + 16);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)&v10, &v13);
  v13 = *(_QWORD *)(a3 + 24);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)&v10, &v13);
  LODWORD(v13) = *(_DWORD *)(a3 + 32);
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)&v10, &v13);
  LODWORD(v13) = health::FletcherChecksum(v10, (char *)(v11 - (_BYTE *)v10));
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)&v10, &v13);
  v6 = v16;
  if (v16 <= 0x3FF)
    v7 = v14;
  else
    v7 = v15;
  (*(void (**)(uint64_t, uint64_t, _BYTE *, unint64_t))(*(_QWORD *)a1 + 24))(a1, a2, v7, v16);
  v8 = v15;
  v15 = 0;
  if (v8)
    MEMORY[0x1BCCAC47C](v8, 0x1000C8077774924);
  return v6;
}

void sub_1B7837080(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::FletcherChecksum(health *this, char *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned int v8;

  if (!a2)
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  do
  {
    if ((unint64_t)a2 >= 0x16A0A9A)
      v5 = 23726746;
    else
      v5 = (uint64_t)a2;
    v6 = (unsigned __int8 *)this + v2;
    v7 = v5;
    do
    {
      v8 = *v6++;
      v4 += v8;
      v3 += v4;
      --v7;
    }
    while (v7);
    v2 += v5;
    v4 %= 0xFFFFuLL;
    v3 %= 0xFFFFuLL;
    a2 -= v5;
  }
  while (a2);
  return v3 | ((_DWORD)v4 << 16);
}

char **std::deque<health::BlockPointer>::deque(char **a1, _QWORD *a2)
{
  unint64_t v3;
  uint64_t v4;
  char *v5;
  __int128 *v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  unsigned __int8 v29;
  uint64_t v30;
  char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _OWORD *v35;
  __int128 v36;
  __int128 *v37;
  uint64_t v38;
  void *v39;
  char *v40;
  char *v41;
  __int128 v42;
  char **v43;

  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  v3 = a2[4];
  v4 = a2[1];
  v5 = (char *)(v4 + 8 * (v3 >> 8));
  if (a2[2] == v4)
  {
    v6 = 0;
    v9 = 0;
    v8 = (char *)(v4 + 8 * ((a2[5] + v3) >> 8));
  }
  else
  {
    v6 = (__int128 *)(*(_QWORD *)v5 + 16 * v3);
    v7 = a2[5] + v3;
    v8 = (char *)(v4 + 8 * (v7 >> 8));
    v9 = *(_QWORD *)v8 + 16 * v7;
  }
  if ((__int128 *)v9 != v6)
  {
    v10 = ((v9 - *(_QWORD *)v8) >> 4) + 32 * (v8 - v5);
    v11 = (uint64_t)v6 - *(_QWORD *)v5;
    v12 = v10 - (v11 >> 4);
    if (v10 != v11 >> 4)
    {
      if ((_BYTE)v12 == 0xFF)
        v14 = (unint64_t)(v12 + 1) >> 8;
      else
        v14 = ((unint64_t)(v12 + 1) >> 8) + 1;
      if (v14)
      {
        v43 = a1 + 3;
        v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>((uint64_t)(a1 + 3), v14);
        v41 = v40;
        *(_QWORD *)&v42 = v40;
        *((_QWORD *)&v42 + 1) = &v40[8 * v15];
        v16 = -(uint64_t)v14;
        do
        {
          v39 = operator new(0x1000uLL);
          std::__split_buffer<health::BlockPointer *>::push_back(&v40, &v39);
        }
        while (!__CFADD__(v16++, 1));
        v18 = a1[2];
        v19 = -7 - (_QWORD)v18;
        while (v18 != a1[1])
        {
          v18 -= 8;
          v19 += 8;
          std::__split_buffer<health::BlockPointer *>::push_front((uint64_t)&v40, v18);
        }
        v20 = *a1;
        v21 = v41;
        *a1 = v40;
        a1[1] = v21;
        v40 = v20;
        v41 = v18;
        v22 = (char *)v42;
        v23 = *((_OWORD *)a1 + 1);
        *((_OWORD *)a1 + 1) = v42;
        v42 = v23;
        if (v18 != (char *)v23)
          *(_QWORD *)&v42 = v23 + (-(v23 + v19) & 0xFFFFFFFFFFFFFFF8);
        if (v20)
        {
          operator delete(v20);
          v24 = a1[4];
          v21 = a1[1];
          v25 = a1[2];
        }
        else
        {
          v24 = a1[4];
          v25 = v22;
        }
        v27 = a1[5];
        v29 = (_BYTE)v24 + (_BYTE)v27;
        v28 = &v21[8 * ((unint64_t)&v27[(_QWORD)v24] >> 8)];
        if (v25 == v21)
          v26 = 0;
        else
          v26 = *(_QWORD *)v28 + 16 * v29;
      }
      else
      {
        v26 = 0;
        v27 = 0;
        v28 = 0;
      }
      v30 = v12 + ((v26 - *(_QWORD *)v28) >> 4);
      if (v30 < 1)
      {
        v32 = 255 - v30;
        LOBYTE(v30) = ~(-1 - v30);
        v31 = &v28[-8 * (v32 >> 8)];
      }
      else
      {
        v31 = &v28[8 * ((unint64_t)v30 >> 8)];
      }
      v33 = *(_QWORD *)v31 + 16 * v30;
      while (v26 != v33)
      {
        v34 = v33;
        if (v28 != v31)
          v34 = *(_QWORD *)v28 + 4096;
        if (v26 == v34)
        {
          v34 = v26;
        }
        else
        {
          v35 = (_OWORD *)v26;
          do
          {
            v36 = *v6++;
            *v35 = v36;
            if ((__int128 *)((char *)v6 - *(_QWORD *)v5) == (__int128 *)4096)
            {
              v37 = (__int128 *)*((_QWORD *)v5 + 1);
              v5 += 8;
              v6 = v37;
            }
            ++v35;
          }
          while (v35 != (_OWORD *)v34);
          v27 = a1[5];
        }
        v27 += (v34 - v26) >> 4;
        a1[5] = v27;
        if (v28 == v31)
          break;
        v38 = *((_QWORD *)v28 + 1);
        v28 += 8;
        v26 = v38;
      }
    }
  }
  return a1;
}

void sub_1B78373C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  uint64_t v12;

  std::__split_buffer<std::__thread_id *>::~__split_buffer(v12);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2, int a3)
{
  std::runtime_error *exception;

  *(ObjectIdentifier *)(a1 + 72) = *a2;
  if (!health::DataStore::ReadTransaction::retrieveObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(*(health::DataStore::ReadTransaction **)(a1 + 96), (_QWORD *)a1, a2))
  {
    if (!a3)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      _ZN6health15not_found_errorCI1St13runtime_errorEPKc(exception, "The requested sample history does not exist.");
    }
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::_updateHistoryRoot(a1);
  }
  return 1;
}

void sub_1B78374C4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL health::DataStore::ReadTransaction::retrieveObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(health::DataStore::ReadTransaction *a1, _QWORD *a2, ObjectIdentifier *a3)
{
  int v5;
  uint64_t *v6;
  uint64_t *v7;
  _BYTE v9[16];
  unsigned __int8 v10;

  health::DataStore::ReadTransaction::_pointerForObject(a1, a3, (uint64_t)v9);
  v5 = v10;
  if (v10)
  {
    v6 = (uint64_t *)*((_QWORD *)a1 + 3);
    v7 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v9);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v6, *v7, v7[1], a2);
  }
  return v5 != 0;
}

double health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v8;
  _BYTE v10[552];

  v8 = a1[2];
  bzero(v10, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v8 + 16), *a1, a1[1], (uint64_t)v10);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>((uint64_t)a1, 0, (uint64_t)v10, a2, a3, a4);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 547;
  health::RawBuffer::RawBuffer(v11, v12, 547);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 547;
  health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B78376A4(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

_QWORD *health::RawBuffer::RawBuffer(_QWORD *this, unsigned __int8 *a2, uint64_t a3)
{
  void *v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  *this = a2;
  this[1] = a3;
  if (!a2)
  {
    if (a3)
    {
      v3 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v7, "_buffer != nullptr || _length == 0");
      std::string::basic_string[abi:ne180100]<0>(v6, "RawBuffer");
      std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
      health::FormatString<>((std::string *)"Unable to create a raw buffer of length > 0 at nullptr", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v3, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 27, (uint64_t)&__p);
    }
  }
  return this;
}

void sub_1B78377B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 17) < 0)
    operator delete(*(void **)(v26 - 40));
  _Unwind_Resume(exception_object);
}

void health::TransactionalFile::ReadTransaction::readBufferAtOffset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD v6[2];

  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  health::RawBuffer::RawBuffer(v6, *(unsigned __int8 **)a2, *(_QWORD *)(a2 + 8));
  health::TransactionalFile::_readBufferAtOffset(v4, v5, v6, a3);
}

uint64_t health::WriteAheadLog::Transaction::pageAtOffset@<X0>(uint64_t this@<X0>, unint64_t a2@<X1>, health::FilePage *a3@<X8>)
{
  _QWORD *v3;
  _QWORD *v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v3 = *(_QWORD **)(this + 40);
  if (v3)
  {
    v4 = (_QWORD *)(this + 40);
    do
    {
      v5 = v3[4];
      v6 = v5 >= a2;
      if (v5 >= a2)
        v7 = v3;
      else
        v7 = v3 + 1;
      if (v6)
        v4 = v3;
      v3 = (_QWORD *)*v7;
    }
    while (*v7);
    if (v4 != (_QWORD *)(this + 40) && v4[4] <= a2)
      return health::_PageForEntry((uint64_t *)(this + 8), a2, v4 + 5, a3);
  }
  *((_OWORD *)a3 + 1) = 0u;
  *((_OWORD *)a3 + 2) = 0u;
  *(_OWORD *)a3 = 0u;
  return this;
}

uint64_t health::TransactionalCache<unsigned long long,health::FilePage>::_touchCacheEntry(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)(result + 56) != a2 || *(_QWORD *)(result + 64) != a2)
  {
    v2 = *(_QWORD *)(a2 + 88);
    if (v2)
    {
      v3 = *(_QWORD *)(v2 + 88);
      v4 = *(_QWORD *)(a2 + 80);
      if (v3)
        *(_QWORD *)(v3 + 80) = a2;
      *(_QWORD *)(v2 + 80) = v4;
      *(_QWORD *)(v2 + 88) = a2;
      *(_QWORD *)(a2 + 80) = v2;
      *(_QWORD *)(a2 + 88) = v3;
      if (v4)
      {
        *(_QWORD *)(v4 + 88) = v2;
        v3 = *(_QWORD *)(a2 + 88);
      }
      if (!v3)
        *(_QWORD *)(result + 56) = a2;
      if (!*(_QWORD *)(v2 + 80))
        *(_QWORD *)(result + 64) = v2;
    }
  }
  return result;
}

uint64_t health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->(uint64_t result)
{
  std::logic_error *exception;

  if (!*(_BYTE *)(result + 56))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to indirect through to the value of an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
  return result;
}

void sub_1B7837974(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *health::FilePage::slice(health::FilePage *this, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::string v12;
  void *v13[2];
  void *v14[2];
  void *v15[2];
  std::string __p;
  void *v17[2];
  void *v18[2];
  void *v19[2];
  std::string v20;
  _QWORD v21[2];
  _QWORD v22[2];
  _QWORD v23[2];

  if (*(_QWORD *)a2 > a3)
  {
    v6 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v23, "offset >= _offset");
    std::string::basic_string[abi:ne180100]<0>(v22, "slice");
    std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDFilePage.h");
    health::FormatString<>((std::string *)"Attempt to slice starting before the page start.", &v20);
    health::_HDAssertImplementation<std::out_of_range>(v6, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 82, (uint64_t)&v20);
  }
  v7 = a3 - *(_QWORD *)a2;
  if (*(_QWORD *)(a2 + 8) - v7 < a4)
  {
    v8 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v19, "length <= (_length - localOffset)");
    std::string::basic_string[abi:ne180100]<0>(v18, "slice");
    std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDFilePage.h");
    health::FormatString<>((std::string *)"Attempt to slice beyond page end", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v8, (uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 84, (uint64_t)&__p);
  }
  v9 = *(_QWORD *)(a2 + 16);
  if (!v9)
  {
    v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32));
    if (!v9)
    {
      v10 = *MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v15, "rawBytes != nullptr");
      std::string::basic_string[abi:ne180100]<0>(v14, "slice");
      std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDFilePage.h");
      health::FormatString<>((std::string *)"Attempt to slice an invalid page.", &v12);
      health::_HDAssertImplementation<std::out_of_range>(v10, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 86, (uint64_t)&v12);
    }
  }
  return health::RawBuffer::RawBuffer(this, (unsigned __int8 *)(v9 + v7), a4);
}

void sub_1B7837C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,char a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

void *health::RawBuffer::copyFrom(health::RawBuffer *this, const health::RawBuffer *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::string v6;
  void *v7[2];
  void *v8[2];
  void *v9[2];
  std::string __p;
  void *v11[2];
  void *v12[2];
  _QWORD v13[2];
  std::string v14;
  _QWORD v15[2];
  _QWORD v16[2];
  _QWORD v17[2];

  if (*((_QWORD *)a2 + 1) != *((_QWORD *)this + 1))
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v17, "source._length == _length");
    std::string::basic_string[abi:ne180100]<0>(v16, "copyFrom");
    std::string::basic_string[abi:ne180100]<0>(v15, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
    health::FormatString<>((std::string *)"Cannot copy buffers of unequal sizes.", &v14);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v17, (uint64_t)v16, (uint64_t)v15, 73, (uint64_t)&v14);
  }
  if (!*(_QWORD *)this)
  {
    v3 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v13, "_buffer != nullptr");
    std::string::basic_string[abi:ne180100]<0>(v12, "copyFrom");
    std::string::basic_string[abi:ne180100]<0>(v11, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
    health::FormatString<>((std::string *)"Canot copy to an invalid buffer.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v3, (uint64_t)v13, (uint64_t)v12, (uint64_t)v11, 74, (uint64_t)&__p);
  }
  if (!*(_QWORD *)a2)
  {
    v4 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v9, "source._buffer != nullptr");
    std::string::basic_string[abi:ne180100]<0>(v8, "copyFrom");
    std::string::basic_string[abi:ne180100]<0>(v7, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
    health::FormatString<>((std::string *)"Cannot copy from an invalid buffer.", &v6);
    health::_HDAssertImplementation<std::logic_error>(v4, (uint64_t)v9, (uint64_t)v8, (uint64_t)v7, 75, (uint64_t)&v6);
  }
  return memcpy(*(void **)this, *(const void **)a2, *((_QWORD *)this + 1));
}

void sub_1B7837F84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

uint64_t health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

void sub_1B7838188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

void *health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  void *v6;
  std::string v8;
  void *v9[2];
  void *v10[2];
  void *v11[2];
  std::string __p;
  void *v13[2];
  _QWORD v14[2];
  _QWORD v15[2];

  if ((unint64_t)(a5 + a2) >= 0x12)
  {
    v5 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v15, "destinationIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v14, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow destination.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 79, (uint64_t)&__p);
  }
  if ((unint64_t)(a5 + a4) >= 0x12)
  {
    v6 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "sourceIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow source.", &v8);
    health::_HDAssertImplementation<std::out_of_range>(v6, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 80, (uint64_t)&v8);
  }
  return memcpy((void *)(a1 + 32 * a2), (const void *)(a3 + 32 * a4), 32 * a5);
}

void sub_1B78383B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

void *health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::deleteElementAtIndex(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "deleteElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 65, (uint64_t)&__p);
  }
  return memmove((void *)(a1 + 32 * a2), (const void *)(a1 + 32 * a2 + 32), 512 - 32 * a2);
}

void sub_1B7838568(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

__n128 health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(uint64_t a1, __n128 *a2, unint64_t a3)
{
  void *v4;
  __n128 *v5;
  __n128 result;
  std::string __p;
  void *v8[2];
  void *v9[2];
  _QWORD v10[2];

  if (a3 >= 0x11)
  {
    v4 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v10, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v9, "insertElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v8, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v4, (uint64_t)v10, (uint64_t)v9, (uint64_t)v8, 57, (uint64_t)&__p);
  }
  v5 = (__n128 *)(a1 + 32 * a3);
  memmove(&v5[2], v5, 512 - 32 * a3);
  result = a2[1];
  *v5 = *a2;
  v5[1] = result;
  return result;
}

void sub_1B78386D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<long long>(uint64_t result, _QWORD *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 7uLL)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_QWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - 8;
  *(_QWORD *)(result + 8) += 8;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B7838834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned long long>(uint64_t result, _QWORD *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 7uLL)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_QWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - 8;
  *(_QWORD *)(result + 8) += 8;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B7838998(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned short>(uint64_t result, _WORD *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 1uLL)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_WORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - 2;
  *(_QWORD *)(result + 8) += 2;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B7838AFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned char>(uint64_t result, _BYTE *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (!*(_QWORD *)(result + 16))
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_BYTE **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - 1;
  ++*(_QWORD *)(result + 8);
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B7838C5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(uint64_t a1, _QWORD *a2)
{
  void *v4;
  unint64_t v5;
  _QWORD *v6;
  std::string __p;
  void *v9[2];
  void *v10[2];
  _QWORD v11[2];

  if (!*(_WORD *)(a1 + 544))
  {
    v4 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "childCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v10, "childForKey");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for child for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 58, (uint64_t)&__p);
  }
  if (*(_WORD *)(a1 + 544) == 1)
  {
LABEL_9:
    LOWORD(v5) = 0;
  }
  else
  {
    v5 = (unsigned __int16)(*(_WORD *)(a1 + 544) - 1);
    while (1)
    {
      v6 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v5);
      if (*a2 > *v6 || *a2 >= *v6 && a2[1] >= v6[1])
        break;
      if (!(_WORD)--v5)
        goto LABEL_9;
    }
  }
  return (unsigned __int16)v5;
}

void sub_1B7838DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

void sub_1B7838F40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 578;
  health::RawBuffer::RawBuffer(v11, v12, 578);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 578;
  health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783908C(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey(uint64_t a1, _QWORD *a2)
{
  int v4;
  void *v5;
  unsigned int v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v10;
  std::string __p;
  void *v13[2];
  void *v14[2];
  void *v15[2];

  v4 = *(unsigned __int16 *)(a1 + 544);
  if (!*(_WORD *)(a1 + 544))
  {
    v5 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v15, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v14, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 72, (uint64_t)&__p);
  }
  v6 = v4 - 1;
  while (1)
  {
    LOWORD(v4) = v4 - 1;
    v7 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v6);
    if (*a2 > *v7 || *a2 >= *v7 && a2[1] > v7[1])
    {
      v10 = 0x200000000;
      return v10 | (unsigned __int16)v4;
    }
    v8 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v6);
    if (*a2 == *v8 && a2[1] == v8[1])
      break;
    if (!(unsigned __int16)v6--)
    {
      LOWORD(v4) = 0;
      v10 = 0x100000000;
      return v10 | (unsigned __int16)v4;
    }
  }
  v10 = 0;
  LOWORD(v4) = v6;
  return v10 | (unsigned __int16)v4;
}

void sub_1B7839244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

uint64_t health::DataStore::WriteTransaction::storeObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  uint64_t v6;
  health::BlockAccessFile::WriteTransaction *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __n128 v15;
  _OWORD v16[2];
  char v17;
  __int128 v18;
  uint64_t v19;

  v18 = *(_OWORD *)(a1 + 32);
  v19 = a1 + 48;
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v18, a3, 0, v16);
  if (v17)
  {
    v6 = *(_QWORD *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v16)
                   + 24);
    v7 = (health::BlockAccessFile::WriteTransaction *)(a1 + 80);
    v8 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v16);
    v9 = *(_QWORD *)(v8 + 16);
    v10 = *(_QWORD *)(v8 + 24);
    if (v6 == 56)
      return health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>((uint64_t)v7, v9, v10, a2);
    health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v7, v9, v10);
  }
  else
  {
    v7 = (health::BlockAccessFile::WriteTransaction *)(a1 + 80);
  }
  v12 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v7, 56);
  v14 = v13;
  health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>((uint64_t)v7, v12, v13, a2);
  v15.n128_u64[0] = v12;
  v15.n128_u64[1] = v14;
  return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v18, a3, &v15);
}

double health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v8;
  _BYTE v10[552];

  v8 = a1[2];
  bzero(v10, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)v10);
  return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>((uint64_t)a1, 0, (uint64_t)v10, a2, a3, a4);
}

uint64_t health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(health::BlockAccessFile::WriteTransaction *this, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  int v10;

  v9 = a2;
  v10 = 0;
  v4 = *((_QWORD *)this + 3);
  v5 = *(_DWORD *)(v4 + 4);
  if (!*((_BYTE *)this + 48))
    *((_BYTE *)this + 48) = 0;
  if (v5 <= 1)
    v6 = a2;
  else
    v6 = a2 + 12;
  v7 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v4 + 16) = v7 + v6;
  health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(*((health::TransactionalFile::WriteTransaction **)this + 2), v4, 0);
  health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockHeader &>(*((health::TransactionalFile::WriteTransaction **)this + 2), (uint64_t)&v9, v7);
  return v7;
}

uint64_t health::TransactionalFile::ReadTransaction::readObjectAtOffset<health::BTreeNode<unsigned long long,health::BlockAccessFile::FreeSpaceList,unsigned long long,17>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t i;
  _QWORD *v11;
  unint64_t j;
  _QWORD *v13;
  uint64_t result;
  unsigned __int8 *v15[2];
  unsigned __int8 *v16[2];
  _QWORD v17[3];
  _QWORD v18[2];
  unsigned __int8 v19[1024];
  unsigned __int8 *v20;
  unint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  health::SmartBuffer::SmartBuffer((health::SmartBuffer *)v19, 0x6F2uLL);
  if (v21 <= 0x3FF)
    v6 = v19;
  else
    v6 = v20;
  v17[0] = v6;
  v17[1] = v6;
  v17[2] = 1778;
  health::RawBuffer::RawBuffer(v16, v6, v21);
  health::RawBuffer::RawBuffer(v15, v16[0], (uint64_t)v16[1]);
  v9 = a1 + 8;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(_QWORD *)(v9 + 8);
  health::RawBuffer::RawBuffer(v18, v15[0], (uint64_t)v15[1]);
  health::TransactionalFile::_readBufferAtOffset(v8, v7, v18, a3);
  for (i = 0; i != 17; ++i)
  {
    v11 = (_QWORD *)health::StaticArray<health::BTreeNode<unsigned long long,health::BlockAccessFile::FreeSpaceList,unsigned long long,17>::ValueEntry,17ul>::operator[](a2, i);
    v18[0] = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v17, v18);
    *v11 = v18[0];
    health::BlockAccessFile::FreeSpaceList::deserialize((uint64_t)(v11 + 1), (uint64_t)v17);
  }
  for (j = 0; j != 18; ++j)
  {
    v13 = (_QWORD *)health::StaticArray<unsigned long long,18ul>::operator[](a2 + 1632, j);
    v18[0] = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v17, v18);
    *v13 = v18[0];
  }
  LOWORD(v18[0]) = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>((uint64_t)v17, v18);
  *(_WORD *)(a2 + 1776) = v18[0];
  result = (uint64_t)v20;
  v20 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783961C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t health::StaticArray<health::BTreeNode<unsigned long long,health::BlockAccessFile::FreeSpaceList,unsigned long long,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 96 * a2;
}

void sub_1B7839740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::StaticArray<unsigned long long,10ul>::operator[](uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0xA)
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 8 * a2;
}

void sub_1B7839888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::StaticArray<unsigned long long,18ul>::operator[](uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x12)
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 8 * a2;
}

void sub_1B78399D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::_allocateBlockOfLength(health::BlockAccessFile::WriteTransaction *this, uint64_t a2)
{
  health::TransactionalFile::WriteTransaction *v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  v5 = (char *)this + 16;
  v3 = (health::TransactionalFile::WriteTransaction *)*((_QWORD *)this + 2);
  v4 = *((_QWORD *)v5 + 1);
  v6 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v4 + 16) = v6 + a2;
  health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(v3, v4, 0);
  return v6;
}

uint64_t health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(health::TransactionalFile::WriteTransaction *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *v5;
  uint64_t result;
  _QWORD v7[2];
  _QWORD v8[3];
  _BYTE v9[1024];
  unsigned __int8 *v10;
  unint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = 68;
  v8[0] = v9;
  v8[1] = v9;
  v8[2] = 68;
  health::BlockAccessFile::BlockAccessFileHeader::serialize(a2, (uint64_t)v8);
  if (v11 <= 0x3FF)
    v5 = v9;
  else
    v5 = v10;
  health::RawBuffer::RawBuffer(v7, v5, v11);
  health::TransactionalFile::WriteTransaction::writeBufferAtOffset(a1, (const health::RawBuffer *)v7, a3);
  result = (uint64_t)v10;
  v10 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B7839B3C(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::WriteTransaction::writeBufferAtOffset(health::TransactionalFile::WriteTransaction *this, const health::RawBuffer *a2, uint64_t a3)
{
  unint64_t v6;

  health::TransactionalFile::_writeBufferAtOffset(*((health::TransactionalFile **)this + 4), *((_QWORD *)this + 1), a2, a3);
  v6 = *((_QWORD *)a2 + 1) + a3 + *((_QWORD *)this + 3);
  if (v6 > *((_QWORD *)this + 5))
    *((_QWORD *)this + 5) = v6;
}

void *health::FilePage::copy(health::FilePage *this, _QWORD *a2)
{
  size_t v4;
  void **v5;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  void *v9;
  void *result;
  std::string __p;
  void *v12[2];
  void *v13[2];
  void *v14[2];

  v4 = a2[1];
  *(_QWORD *)this = *a2;
  *((_QWORD *)this + 1) = v4;
  v5 = (void **)((char *)this + 16);
  v6 = operator new[]();
  std::shared_ptr<unsigned char>::shared_ptr[abi:ne180100]<unsigned char,std::default_delete<unsigned char []>,void>(v5, v6);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  bzero(*((void **)this + 2), v4);
  v7 = (const void *)a2[2];
  if (v7)
    goto LABEL_5;
  if (!a2[4])
  {
    v8 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v14, "valid()");
    std::string::basic_string[abi:ne180100]<0>(v13, "copy");
    std::string::basic_string[abi:ne180100]<0>(v12, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDFilePage.h");
    health::FormatString<>((std::string *)"Copying an invalid page.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v8, (uint64_t)v14, (uint64_t)v13, (uint64_t)v12, 65, (uint64_t)&__p);
  }
  v7 = (const void *)a2[2];
  if (v7)
  {
LABEL_5:
    v9 = *v5;
    return memcpy(v9, v7, a2[1]);
  }
  result = (void *)a2[4];
  if (result)
  {
    v9 = *v5;
    v7 = (const void *)(*(uint64_t (**)(void *))(*(_QWORD *)result + 16))(result);
    return memcpy(v9, v7, a2[1]);
  }
  return result;
}

void sub_1B7839D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  uint64_t v32;
  uint64_t v33;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v33);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v32);
  _Unwind_Resume(a1);
}

void health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(_QWORD *a1, unint64_t a2, unint64_t *a3, __int128 *a4, unint64_t a5, int a6)
{
  uint64_t *v11;
  _QWORD *v12;
  uint64_t *i;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t *v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *p_shared_owners;
  unint64_t v57;
  std::__shared_weak_count *v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  unint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  unint64_t *v85;
  unint64_t v86;
  std::__shared_weak_count *v87;
  unint64_t *v88;
  unint64_t v89;
  uint64_t *v90;
  unint64_t v91;
  uint64_t *v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  void *v97;
  unint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  char *v106;
  uint64_t v107;
  int64x2_t v108;
  char *v109;
  char *v110;
  void *v111;
  uint64_t *v112;
  uint64_t *v113;
  uint64_t *v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  char *v118;
  char *v119;
  unint64_t *v120;
  unint64_t v121;
  unint64_t *v122;
  unint64_t v123;
  __int128 v125;
  uint64_t v126;
  std::__shared_weak_count *v127;
  uint64_t v128;
  std::__shared_weak_count *v129;
  __int128 v130;
  uint64_t v131;
  std::__shared_weak_count *v132;
  std::string __p;
  void *v134[2];
  unint64_t v135;
  char *v136;
  __int128 v137;
  char *v138;
  _QWORD *v139;
  unint64_t v140;
  int64x2_t v141;
  char *v142;
  _QWORD *v143;

  v11 = a1 + 2;
  v12 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a1 + 2, *a3, a3);
  for (i = (uint64_t *)v12[3]; i != (uint64_t *)v12[4]; ++i)
  {
    if (*(_QWORD *)(*i + 8) == a2)
    {
      v130 = *a4;
      v54 = *((_QWORD *)a4 + 2);
      v55 = (std::__shared_weak_count *)*((_QWORD *)a4 + 3);
      if (v55)
      {
        p_shared_owners = (unint64_t *)&v55->__shared_owners_;
        do
          v57 = __ldxr(p_shared_owners);
        while (__stxr(v57 + 1, p_shared_owners));
      }
      v58 = (std::__shared_weak_count *)*((_QWORD *)a4 + 5);
      v131 = *((_QWORD *)a4 + 4);
      v132 = v58;
      if (v58)
      {
        v59 = (unint64_t *)&v58->__shared_owners_;
        do
          v60 = __ldxr(v59);
        while (__stxr(v60 + 1, v59));
      }
      if (a6 != 1 && *(_DWORD *)*i)
      {
        v61 = *MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(&v140, "(state == CacheEntryState::Dirty) || (entry->state == CacheEntryState::Clean)");
        std::string::basic_string[abi:ne180100]<0>(&v136, "_replaceValueForEntry");
        std::string::basic_string[abi:ne180100]<0>(v134, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDTransactionalCache.hpp");
        health::FormatString<>((std::string *)"Unable to replace a dirty entry with a clean one.", &__p);
        health::_HDAssertImplementation<std::logic_error>(v61, (uint64_t)&v140, (uint64_t)&v136, (uint64_t)v134, 89, (uint64_t)&__p);
      }
      v62 = (_QWORD *)*i;
      v63 = *(_QWORD *)(*i + 16);
      *(_OWORD *)(*i + 32) = v130;
      if (v55)
      {
        v64 = (unint64_t *)&v55->__shared_owners_;
        do
          v65 = __ldxr(v64);
        while (__stxr(v65 + 1, v64));
      }
      v66 = (std::__shared_weak_count *)v62[7];
      v62[6] = v54;
      v62[7] = v55;
      if (v66)
      {
        v67 = (unint64_t *)&v66->__shared_owners_;
        do
          v68 = __ldaxr(v67);
        while (__stlxr(v68 - 1, v67));
        if (!v68)
        {
          ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
          std::__shared_weak_count::__release_weak(v66);
        }
      }
      if (v132)
      {
        v69 = (unint64_t *)&v132->__shared_owners_;
        do
          v70 = __ldxr(v69);
        while (__stxr(v70 + 1, v69));
      }
      v71 = (std::__shared_weak_count *)v62[9];
      v62[8] = v131;
      v62[9] = v132;
      if (v71)
      {
        v72 = (unint64_t *)&v71->__shared_owners_;
        do
          v73 = __ldaxr(v72);
        while (__stlxr(v73 - 1, v72));
        if (!v73)
        {
          ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
          std::__shared_weak_count::__release_weak(v71);
        }
      }
      v74 = *i;
      *(_QWORD *)(v74 + 16) = a5;
      *(_DWORD *)v74 = a6;
      health::TransactionalCache<unsigned long long,health::FilePage>::_touchCacheEntry((uint64_t)a1, v74);
      if (v63 != a5)
      {
        v75 = a1[1];
        v76 = v75 >= v63;
        v77 = v75 - v63;
        if (!v76)
          v77 = 0;
        a1[1] = v77 + a5;
        v78 = a1[8];
        if (v78)
        {
          v79 = *a1;
          while (1)
          {
            v80 = a1[1];
            if (v80 <= v79)
              goto LABEL_88;
            v81 = *(_QWORD *)(v78 + 88);
            if (!*(_DWORD *)v78)
              goto LABEL_85;
            v82 = a1[12];
            if (!v82)
              goto LABEL_85;
            v135 = *(_QWORD *)(v78 + 8);
            if ((*(unsigned int (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(_QWORD *)v82 + 48))(v82, &v135, v78 + 24, v78 + 32))
            {
              break;
            }
LABEL_87:
            v78 = v81;
            if (!v81)
              goto LABEL_88;
          }
          v80 = a1[1];
LABEL_85:
          a1[1] = v80 - *(_QWORD *)(v78 + 16);
          health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)a1, v78);
          v83 = *(_QWORD *)(v78 + 24);
          v135 = v83;
          v84 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v11, v83, &v135);
          health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(v84 + 3, v78);
          if (v84[4] == v84[3])
            std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v11, v83);
          goto LABEL_87;
        }
      }
LABEL_88:
      if (v132)
      {
        v85 = (unint64_t *)&v132->__shared_owners_;
        do
          v86 = __ldaxr(v85);
        while (__stlxr(v86 - 1, v85));
        if (!v86)
        {
          ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
          std::__shared_weak_count::__release_weak(v132);
        }
      }
      v87 = v55;
      if (v55)
      {
        v88 = (unint64_t *)&v55->__shared_owners_;
        do
          v89 = __ldaxr(v88);
        while (__stlxr(v89 - 1, v88));
        goto LABEL_135;
      }
      return;
    }
  }
  v125 = *a4;
  v14 = (std::__shared_weak_count *)*((_QWORD *)a4 + 3);
  v126 = *((_QWORD *)a4 + 2);
  v127 = v14;
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v17 = (std::__shared_weak_count *)*((_QWORD *)a4 + 5);
  v128 = *((_QWORD *)a4 + 4);
  v129 = v17;
  if (v17)
  {
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v123 = a5;
  if (*a1 >= a5)
    v20 = *a1 - a5;
  else
    v20 = 0;
  v21 = a1[8];
  if (v21)
  {
    while (1)
    {
      v22 = a1[1];
      if (v22 <= v20)
        goto LABEL_23;
      v23 = *(_QWORD *)(v21 + 88);
      if (!*(_DWORD *)v21)
        goto LABEL_20;
      v24 = a1[12];
      if (!v24)
        goto LABEL_20;
      v140 = *(_QWORD *)(v21 + 8);
      if ((*(unsigned int (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(_QWORD *)v24 + 48))(v24, &v140, v21 + 24, v21 + 32))
      {
        break;
      }
LABEL_22:
      v21 = v23;
      if (!v23)
        goto LABEL_23;
    }
    v22 = a1[1];
LABEL_20:
    a1[1] = v22 - *(_QWORD *)(v21 + 16);
    health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)a1, v21);
    v25 = *(_QWORD *)(v21 + 24);
    v140 = v25;
    v26 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v11, v25, &v140);
    health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(v26 + 3, v21);
    if (v26[4] == v26[3])
      std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v11, v25);
    goto LABEL_22;
  }
LABEL_23:
  v27 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v11, *a3, a3);
  v28 = v27;
  v30 = v27[3];
  v29 = v27[4];
  if (v30 != v29)
  {
    while (*(_QWORD *)(*(_QWORD *)v30 + 8) <= a2)
    {
      v30 += 8;
      if (v30 == v29)
      {
        v30 = v27[4];
        break;
      }
    }
  }
  v31 = (_QWORD *)operator new();
  *(_DWORD *)v31 = a6;
  v31[1] = a2;
  v31[2] = v123;
  v31[3] = *a3;
  *((_OWORD *)v31 + 2) = v125;
  v31[6] = v126;
  v31[7] = v127;
  if (v127)
  {
    v32 = (unint64_t *)&v127->__shared_owners_;
    do
      v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }
  v31[8] = v128;
  v31[9] = v129;
  if (v129)
  {
    v34 = (unint64_t *)&v129->__shared_owners_;
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
  }
  v134[0] = v31;
  a1[1] += v123;
  v36 = a1[7];
  v31[10] = v36;
  v31[11] = 0;
  if (v36)
    v37 = (_QWORD *)(v36 + 88);
  else
    v37 = a1 + 8;
  *v37 = v31;
  a1[7] = v31;
  v38 = v28[5];
  v40 = v28[3];
  v39 = v28[4];
  v41 = v30 - v40;
  v42 = (v30 - v40) >> 3;
  v43 = (uint64_t *)(v40 + ((v30 - v40) & 0xFFFFFFFFFFFFFFF8));
  if (v39 >= v38)
  {
    v49 = ((uint64_t)(v39 - v40) >> 3) + 1;
    if (v49 >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v50 = v38 - v40;
    if (v50 >> 2 > v49)
      v49 = v50 >> 2;
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8)
      v51 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v51 = v49;
    v139 = v28 + 5;
    if (v51)
    {
      v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v51);
    }
    else
    {
      v53 = 0;
      v52 = 0;
    }
    v90 = (uint64_t *)&v53[8 * v42];
    v136 = v53;
    *(_QWORD *)&v137 = v90;
    *((_QWORD *)&v137 + 1) = v90;
    v138 = &v53[8 * v52];
    if (v42 == v52)
    {
      if (v41 < 1)
      {
        if (v40 == v30)
          v98 = 1;
        else
          v98 = v41 >> 2;
        v143 = v28 + 5;
        v99 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v98);
        v101 = (uint64_t *)v137;
        v102 = *((_QWORD *)&v137 + 1) - v137;
        if (*((_QWORD *)&v137 + 1) == (_QWORD)v137)
        {
          v108 = vdupq_n_s64(v137);
          v104 = (unint64_t)&v99[8 * (v98 >> 2)];
        }
        else
        {
          v103 = v102 >> 3;
          v104 = (unint64_t)&v99[8 * (v98 >> 2) + (v102 & 0xFFFFFFFFFFFFFFF8)];
          v105 = 8 * v103;
          v106 = &v99[8 * (v98 >> 2)];
          do
          {
            v107 = *v101;
            *v101++ = 0;
            *(_QWORD *)v106 = v107;
            v106 += 8;
            v105 -= 8;
          }
          while (v105);
          v108 = (int64x2_t)v137;
        }
        v109 = v136;
        v110 = v138;
        v136 = v99;
        *(_QWORD *)&v137 = &v99[8 * (v98 >> 2)];
        v141 = v108;
        *((_QWORD *)&v137 + 1) = v104;
        v138 = &v99[8 * v100];
        v140 = (unint64_t)v109;
        v142 = v110;
        std::__split_buffer<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::~__split_buffer((uint64_t)&v140);
        v93 = (uint64_t *)*((_QWORD *)&v137 + 1);
        v90 = (uint64_t *)v137;
      }
      else
      {
        v91 = v42 + 2;
        if (v42 >= -1)
          v91 = v42 + 1;
        v92 = &v90[-(v91 >> 1)];
        v93 = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,0>(v90, v90, v92);
        v90 = v92;
      }
    }
    else
    {
      v93 = (uint64_t *)&v53[8 * v42];
    }
    v111 = v134[0];
    v134[0] = 0;
    *v93 = (uint64_t)v111;
    v112 = v93 + 1;
    *((_QWORD *)&v137 + 1) = v112;
    v113 = (uint64_t *)v28[3];
    if (v113 != v43)
    {
      v114 = v43;
      do
      {
        v115 = *--v114;
        *v114 = 0;
        *--v90 = v115;
      }
      while (v114 != v113);
      v112 = (uint64_t *)*((_QWORD *)&v137 + 1);
    }
    *(_QWORD *)&v137 = v90;
    v116 = (uint64_t *)v28[4];
    if (v116 != v43)
    {
      do
      {
        v117 = *v43;
        *v43++ = 0;
        *v112++ = v117;
      }
      while (v43 != v116);
      v90 = (uint64_t *)v137;
      v43 = (uint64_t *)v28[4];
    }
    v118 = (char *)v28[3];
    v28[3] = v90;
    v28[4] = v112;
    v119 = (char *)v28[5];
    v28[5] = v138;
    *((_QWORD *)&v137 + 1) = v43;
    v138 = v119;
    v136 = v118;
    *(_QWORD *)&v137 = v118;
    std::__split_buffer<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::~__split_buffer((uint64_t)&v136);
  }
  else if (v43 == (uint64_t *)v39)
  {
    v134[0] = 0;
    *v43 = (uint64_t)v31;
    v28[4] = v43 + 1;
  }
  else
  {
    v44 = v43 + 1;
    v45 = (uint64_t *)(v39 - 8);
    if (v39 < 8)
    {
      v47 = (_QWORD *)v28[4];
    }
    else
    {
      v46 = (uint64_t *)(v39 - 8);
      v47 = (_QWORD *)v28[4];
      do
      {
        v48 = *v46;
        *v46++ = 0;
        *v47++ = v48;
      }
      while ((unint64_t)v46 < v39);
    }
    v28[4] = v47;
    if ((uint64_t *)v39 != v44)
    {
      v94 = 8 * ((uint64_t)(v39 - (_QWORD)v44) >> 3);
      v95 = v40 + 8 * v42 - 8;
      do
      {
        v96 = *(_QWORD *)(v95 + v94);
        *(_QWORD *)(v95 + v94) = 0;
        std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100](v45--, v96);
        v94 -= 8;
      }
      while (v94);
    }
    v97 = v134[0];
    v134[0] = 0;
    std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100](v43, (uint64_t)v97);
  }
  std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100]((uint64_t *)v134, 0);
  if (v129)
  {
    v120 = (unint64_t *)&v129->__shared_owners_;
    do
      v121 = __ldaxr(v120);
    while (__stlxr(v121 - 1, v120));
    if (!v121)
    {
      ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
      std::__shared_weak_count::__release_weak(v129);
    }
  }
  v87 = v127;
  if (v127)
  {
    v122 = (unint64_t *)&v127->__shared_owners_;
    do
      v89 = __ldaxr(v122);
    while (__stlxr(v89 - 1, v122));
LABEL_135:
    if (!v89)
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }
}

void sub_1B783A65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  uint64_t v37;

  std::__split_buffer<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::~__split_buffer(v37 - 176);
  std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100]((uint64_t *)&a32, 0);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](a9);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](a10);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100]((uint64_t *)(i - 8), 0);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v7;
  uint64_t result;
  _QWORD v9[2];
  _QWORD v10[3];
  _BYTE v11[1024];
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 578;
  v10[0] = v11;
  v10[1] = v11;
  v10[2] = 578;
  health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF)
    v7 = v11;
  else
    v7 = v12;
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  result = (uint64_t)v12;
  v12 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783A830(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned short>(uint64_t result, _WORD *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 1uLL)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(_WORD **)(result + 8) = *a2;
  v3 = *(_QWORD *)(result + 16) - 2;
  *(_QWORD *)(result + 8) += 2;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B783A960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::__thread_id *>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
    operator delete(v4);
  return a1;
}

uint64_t **health::WriteAheadLog::Transaction::updatedPage(health::WriteAheadLog::Transaction *this, const health::FilePage *a2)
{
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **result;
  uint64_t **v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  int v30;

  v4 = (_QWORD *)*((_QWORD *)this + 5);
  v5 = *(_QWORD *)a2;
  if (!v4)
    goto LABEL_16;
  v6 = (_QWORD *)((char *)this + 40);
  do
  {
    v7 = v4[4];
    v8 = v7 >= v5;
    if (v7 >= v5)
      v9 = v4;
    else
      v9 = v4 + 1;
    if (v8)
      v6 = v4;
    v4 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v6 != (_QWORD *)((char *)this + 40) && v5 >= v6[4] && (v10 = v6[7], v10 == *((_QWORD *)a2 + 1)))
  {
    v11 = *(_QWORD *)this;
    v26 = 3;
    v27 = v11;
    v28 = v5;
    v29 = v10;
    v30 = health::FilePage::checksum(a2);
    v12 = v6[6];
    v13 = health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(*((_QWORD *)this + 1), v12, (uint64_t)&v26)
        + v12;
    v14 = *((_QWORD *)this + 1);
    v15 = *((_QWORD *)a2 + 2);
    if (!v15)
      v15 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 4) + 16))(*((_QWORD *)a2 + 4));
    return (uint64_t **)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v14 + 24))(v14, v13, v15, *((_QWORD *)a2 + 1));
  }
  else
  {
LABEL_16:
    v17 = (uint64_t **)((char *)this + 32);
    v18 = *(_QWORD *)this;
    v26 = 3;
    v27 = v18;
    v28 = v5;
    v29 = *((_QWORD *)a2 + 1);
    v30 = health::FilePage::checksum(a2);
    v19 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 48))(*((_QWORD *)this + 1));
    v20 = health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(*((_QWORD *)this + 1), v19, (uint64_t)&v26)
        + v19;
    v21 = *((_QWORD *)this + 1);
    v22 = *((_QWORD *)a2 + 2);
    if (!v22)
      v22 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 4) + 16))(*((_QWORD *)a2 + 4));
    (*(void (**)(uint64_t, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v21 + 24))(v21, v20, v22, *((_QWORD *)a2 + 1));
    v23 = *(uint64_t **)this;
    v24 = (uint64_t *)*((_QWORD *)a2 + 1);
    v25 = *(uint64_t **)a2;
    result = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v17, (unint64_t)v25, &v25);
    result[5] = v23;
    result[6] = (uint64_t *)v19;
    result[7] = v24;
  }
  return result;
}

unint64_t health::WriteAheadLog::Transaction::_writeCompletionEntryOfType(unint64_t result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::string __p;
  uint64_t v10;
  int v11;
  std::string v12;
  void *v13[2];
  void *v14[2];
  void *v15[2];
  std::string v16;
  _QWORD v17[2];
  _QWORD v18[2];
  _QWORD v19[2];

  v3 = result;
  if (*(_DWORD *)(result + 56))
  {
    v4 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v19, "_transactionStatus == Status::Active");
    std::string::basic_string[abi:ne180100]<0>(v18, "_writeCompletionEntryOfType");
    std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::WriteAheadLog::EntryTypeToString(&__p, a2);
    health::FormatString<std::string,unsigned long long &>(&v16, (std::string *)"Attempt to {0} transaction {1} but it has already completed.", (uint64_t)&__p, v3);
    health::_HDAssertImplementation<health::transaction_error>(v4, (uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 600, (uint64_t)&v16);
  }
  if (a2 == 1)
  {
    v5 = 1;
  }
  else
  {
    if (a2 != 2)
    {
      v6 = *MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v15, "false");
      std::string::basic_string[abi:ne180100]<0>(v14, "_writeCompletionEntryOfType");
      std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
      health::WriteAheadLog::EntryTypeToString(&__p, a2);
      health::FormatString<std::string,unsigned long long &>(&v12, (std::string *)"Attempt to {0} a transaction {1} with an invalid entry type {0}", (uint64_t)&__p, v3);
      health::_HDAssertImplementation<health::transaction_error>(v6, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 609, (uint64_t)&v12);
    }
    v5 = 2;
  }
  *(_DWORD *)(result + 56) = v5;
  if (*(_DWORD *)(result + 60) != 1)
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = a2;
    __p.__r_.__value_.__r.__words[2] = 0;
    v10 = 0;
    v7 = *(_QWORD *)(result + 8);
    __p.__r_.__value_.__l.__size_ = *(_QWORD *)result;
    v11 = 0;
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
    return health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(v7, v8, (uint64_t)&__p);
  }
  return result;
}

void sub_1B783ADEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a23 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if (a29 < 0)
    operator delete(a24);
  if (a35 < 0)
    operator delete(a30);
  if (a41 < 0)
    operator delete(a36);
  _Unwind_Resume(exception_object);
}

uint64_t health::POSIXFile::sync(health::POSIXFile *this)
{
  uint64_t result;
  void *exception;
  uint64_t v3;
  const std::error_category *v4;
  int *v5;
  int *v6;
  char *v7;
  std::string v8;

  result = fcntl(*((_DWORD *)this + 2), 85);
  if ((_DWORD)result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v3 = *__error();
    v4 = std::system_category();
    v5 = __error();
    v6 = __error();
    v7 = strerror(*v6);
    health::FormatString<int &,char *>(&v8, (std::string *)"Error occurred while attempting to sync a file: {0} {1}", (char **)v5, &v7);
    MEMORY[0x1BCCAC2B4](exception, v3, v4, &v8);
    __cxa_throw(exception, MEMORY[0x1E0DE4E38], MEMORY[0x1E0DE4580]);
  }
  return result;
}

void sub_1B783AF9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t health::VirtualFile::read<health::WriteAheadLog::LogEntryHeader>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  char *v5;
  health *v6;
  char *v7;
  uint64_t v8;
  std::runtime_error *exception;
  health *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  v18 = 36;
  v11 = (health *)&v15;
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(*(_QWORD *)a1 + 32))(a1, a2, &v15, 36);
  v12 = (char *)&v16;
  v13 = 32;
  *(_DWORD *)a3 = v15;
  v14 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v11, &v14);
  *(_QWORD *)(a3 + 8) = v14;
  v14 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v11, &v14);
  *(_QWORD *)(a3 + 16) = v14;
  v14 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v11, &v14);
  *(_QWORD *)(a3 + 24) = v14;
  LODWORD(v14) = 0;
  health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v11, &v14);
  *(_DWORD *)(a3 + 32) = v14;
  v6 = v11;
  v5 = v12;
  LODWORD(v14) = 0;
  health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v11, &v14);
  v7 = (char *)(v5 - (char *)v6);
  LODWORD(v5) = v14;
  if (health::FletcherChecksum(v11, v7) != (_DWORD)v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Invalid checksum on read object.");
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC2E8;
  }
  v8 = v17;
  v17 = 0;
  if (v8)
    MEMORY[0x1BCCAC47C](v8, 0x1000C8077774924);
  return v4;
}

void sub_1B783B168(_Unwind_Exception *a1)
{
  void *v1;
  unint64_t v3;

  __cxa_free_exception(v1);
  v3 = STACK[0x428];
  STACK[0x428] = 0;
  if (v3)
    MEMORY[0x1BCCAC47C](v3, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

ssize_t health::POSIXFile::read(health::POSIXFile *this, char *a2, unsigned __int8 *__buf, char *__nbyte)
{
  ssize_t result;
  void *exception;
  uint64_t v6;
  const std::error_category *v7;
  int *v8;
  int *v9;
  char *v10;
  std::string v11;
  char *v12;
  char *v13;

  v12 = __nbyte;
  v13 = a2;
  result = pread(*((_DWORD *)this + 2), __buf, (size_t)__nbyte, (off_t)a2);
  if (result < 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v6 = *__error();
    v7 = std::system_category();
    v8 = __error();
    v9 = __error();
    v10 = strerror(*v9);
    health::FormatString<unsigned long &,long long &,int &,char *>(&v11, (std::string *)"Error occurred attempting to read {0} bytes at {1}: {2} {3}", &v12, &v13, (char **)v8, &v10);
    MEMORY[0x1BCCAC2B4](exception, v6, v7, &v11);
    __cxa_throw(exception, MEMORY[0x1E0DE4E38], MEMORY[0x1E0DE4580]);
  }
  return result;
}

void sub_1B783B278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned int>(uint64_t result, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 3uLL)
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_DWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - 4;
  *(_QWORD *)(result + 8) += 4;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B783B3B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<unsigned char  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCAC47CLL);
  return result;
}

uint64_t health::VirtualFile::write<health::TransactionalFile::FileHeader>(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t result;
  _QWORD v6[3];
  uint64_t v7;
  _BYTE v8[1024];
  _BYTE *v9;
  unint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = 36;
  v6[0] = v8;
  v6[1] = v8;
  v6[2] = 36;
  LODWORD(v7) = *(_DWORD *)a2;
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  LODWORD(v7) = *(_DWORD *)(a2 + 4);
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  LODWORD(v7) = *(_DWORD *)(a2 + 8);
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  v7 = *(_QWORD *)(a2 + 16);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  v7 = *(_QWORD *)(a2 + 24);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  v7 = *(_QWORD *)(a2 + 32);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  if (v10 <= 0x3FF)
    v4 = v8;
  else
    v4 = v9;
  (*(void (**)(uint64_t, _QWORD, _BYTE *))(*(_QWORD *)a1 + 24))(a1, 0, v4);
  result = (uint64_t)v9;
  v9 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783B574(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<health::WriteAheadLog::Transaction>::__on_zero_shared(uint64_t a1)
{
  std::__tree<long>::destroy(*(_QWORD **)(a1 + 64));
  return std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](a1 + 32);
}

void std::unique_lock<std::mutex>::lock(std::unique_lock<std::mutex> *this)
{
  std::unique_lock<std::mutex>::mutex_type *m;
  HDSeriesSampleEntity *v3;
  SEL v4;
  int64_t v5;
  id v6;
  id *v7;

  m = this->__m_;
  if (m)
  {
    if (!this->__owns_)
    {
      std::mutex::lock(m);
      this->__owns_ = 1;
      return;
    }
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::lock: references null mutex");
  }
  std::__throw_system_error(11, "unique_lock::lock: already locked");
  -[HDSeriesSampleEntity updateSampleCount:withDatabase:error:](v3, v4, v5, v6, v7);
}

void sub_1B783B718(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B783BC48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

void sub_1B783BDDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B783BF58(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t health::Optional<health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->(uint64_t result)
{
  std::logic_error *exception;

  if (!*(_BYTE *)(result + 40))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to indirect through to the value of an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
  return result;
}

void sub_1B783C030(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(uint64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 56;
  health::RawBuffer::RawBuffer(v11, v12, 56);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 56;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783C12C(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

double health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::insertSample(uint64_t a1, double *a2, uint64_t a3)
{
  health::BlockAccessFile::WriteTransaction *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  double result;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BYTE v37[27];
  _QWORD v38[4];

  v6 = (health::BlockAccessFile::WriteTransaction *)(*(_QWORD *)(a1 + 96) + 80);
  v38[0] = 0;
  v38[1] = 0;
  v38[2] = v6;
  v38[3] = v6;
  v8 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  if (!v8)
  {
    if (v7)
    {
      v8 = 0;
    }
    else
    {
      v36 = 0u;
      memset(v37, 0, sizeof(v37));
      v34 = 0u;
      v35 = 0u;
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v14 = 0u;
      v15 = 0u;
      v13 = 0u;
      v8 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v6, 411);
      v7 = v9;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v6, v8, v9, (uint64_t)&v13);
      *(_QWORD *)(a1 + 16) = v8;
      *(_QWORD *)(a1 + 24) = v7;
    }
  }
  *(_QWORD *)&v13 = v8;
  *((_QWORD *)&v13 + 1) = v7;
  *(_QWORD *)&v14 = v38;
  v10 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::setValueForKey((uint64_t *)&v13, a2, a3);
  v11 = *(_QWORD *)(a1 + 48);
  if (v11)
  {
    if (!v10)
      *(_QWORD *)(a1 + 48) = v11 + 1;
  }
  else
  {
    *(_QWORD *)(a1 + 48) = 1;
    *(_OWORD *)a1 = xmmword_1B7F397A0;
  }
  *(_QWORD *)&result = health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::_updateHistoryRoot(a1).n128_u64[0];
  return result;
}

uint64_t health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 24 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 24 * a2;
}

void sub_1B783C36C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned char>(uint64_t result, _BYTE *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (!*(_QWORD *)(result + 16))
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(_BYTE **)(result + 8) = *a2;
  v3 = *(_QWORD *)(result + 16) - 1;
  ++*(_QWORD *)(result + 8);
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B783C4CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::setValueForKey(uint64_t *a1, double *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  health::BlockAccessFile::WriteTransaction *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[416];
  _OWORD __src[26];
  _OWORD v15[26];

  v6 = a1[2];
  memset(v15, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    v8 = a1[2];
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(v13, __src, sizeof(v13));
    v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 411);
    v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)v13);
    WORD4(__src[25]) = 1;
    *((_QWORD *)&__src[0] + 1) = v10;
    *(_QWORD *)&__src[1] = v12;
    BYTE10(__src[25]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 411;
  health::RawBuffer::RawBuffer(v11, v12, 411);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 411;
  health::bplustree::InteriorNode<double,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783C7C0(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_1B783C8D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::SerializeValues<health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>,unsigned short,health::BlockPointer,health::BlockPointer>(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t i;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v14;

  for (i = 0; i != 17; ++i)
  {
    v11 = (uint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, i);
    v12 = v11 + 1;
    v14 = *v11;
    health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
    _HDRawLocationDatumV1::serialize(v12, a1);
  }
  LOWORD(v14) = *a3;
  health::SerializationBuffer::appendRaw<unsigned short>(a1, &v14);
  v14 = *a4;
  health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
  v14 = a4[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
  v14 = *a5;
  health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
  v14 = a5[1];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 48 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 48 * a2;
}

void sub_1B783CB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v7;
  uint64_t result;
  _QWORD v9[2];
  _QWORD v10[3];
  _BYTE v11[1024];
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 411;
  v10[0] = v11;
  v10[1] = v11;
  v10[2] = 411;
  health::bplustree::InteriorNode<double,health::BlockPointer,17>::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF)
    v7 = v11;
  else
    v7 = v12;
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  result = (uint64_t)v12;
  v12 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783CC50(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->(uint64_t result)
{
  std::logic_error *exception;

  if (!*(_BYTE *)(result + 40))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to indirect through to the value of an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
  return result;
}

void sub_1B783CCD0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned __int8 *v7;
  uint64_t result;
  _QWORD v9[2];
  _QWORD v10[3];
  _BYTE v11[1024];
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 56;
  v10[0] = v11;
  v10[1] = v11;
  v10[2] = 56;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF)
    v7 = v11;
  else
    v7 = v12;
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  result = (uint64_t)v12;
  v12 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783CDBC(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(uint64_t a1, double *a2)
{
  void *v4;
  unsigned __int16 v5;
  double v6;
  std::string __p;
  void *v9[2];
  void *v10[2];
  void *v11[2];

  if (!*(_WORD *)(a1 + 408))
  {
    v4 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "childCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v10, "childForKey");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for child for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 58, (uint64_t)&__p);
  }
  v5 = *(_WORD *)(a1 + 408);
  do
  {
    if (!--v5)
      break;
    v6 = *a2;
  }
  while (v6 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v5));
  return v5;
}

void sub_1B783CF04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 782;
  health::RawBuffer::RawBuffer(v11, v12, 782);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 782;
  health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783D050(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_1B783D168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<int>(uint64_t result, _DWORD *a2)
{
  void *v2;
  uint64_t v3;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (*(_QWORD *)(result + 16) <= 3uLL)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_DWORD **)(result + 8);
  v3 = *(_QWORD *)(result + 16) - 4;
  *(_QWORD *)(result + 8) += 4;
  *(_QWORD *)(result + 16) = v3;
  return result;
}

void sub_1B783D2CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::indexForKey(uint64_t a1, double *a2)
{
  int v4;
  void *v5;
  unsigned int v6;
  double v7;
  double v8;
  uint64_t v10;
  std::string __p;
  void *v13[2];
  void *v14[2];
  void *v15[2];

  v4 = *(unsigned __int16 *)(a1 + 816);
  if (!*(_WORD *)(a1 + 816))
  {
    v5 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v15, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v14, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 72, (uint64_t)&__p);
  }
  v6 = v4 - 1;
  while (1)
  {
    v7 = *a2;
    LOWORD(v4) = v4 - 1;
    if (v7 > *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, v6))
    {
      v10 = 0x200000000;
      return v10 | (unsigned __int16)v4;
    }
    v8 = *a2;
    if (v8 == *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, v6))break;
    if (!(unsigned __int16)v6--)
    {
      LOWORD(v4) = 0;
      v10 = 0x100000000;
      return v10 | (unsigned __int16)v4;
    }
  }
  v10 = 0;
  LOWORD(v4) = v6;
  return v10 | (unsigned __int16)v4;
}

void sub_1B783D49C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

__n128 health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::insertElementAtIndex(uint64_t a1, uint64_t a2, unint64_t a3)
{
  void *v4;
  _OWORD *v5;
  __n128 result;
  __int128 v7;
  std::string __p;
  void *v9[2];
  void *v10[2];
  _QWORD v11[2];

  if (a3 >= 0x11)
  {
    v4 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "insertElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 57, (uint64_t)&__p);
  }
  v5 = (_OWORD *)(a1 + 48 * a3);
  memmove(v5 + 3, v5, 48 * (16 - a3));
  v7 = *(_OWORD *)(a2 + 16);
  result = *(__n128 *)(a2 + 32);
  *v5 = *(_OWORD *)a2;
  v5[1] = v7;
  v5[2] = result;
  return result;
}

void sub_1B783D618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v7;
  uint64_t result;
  _QWORD v9[2];
  _QWORD v10[3];
  _BYTE v11[1024];
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 782;
  v10[0] = v11;
  v10[1] = v11;
  v10[2] = 782;
  health::SerializeValues<health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>,unsigned short,health::BlockPointer,health::BlockPointer>((uint64_t)v10, a4, (_WORD *)(a4 + 816), (uint64_t *)(a4 + 824), (uint64_t *)(a4 + 840));
  if (v13 <= 0x3FF)
    v7 = v11;
  else
    v7 = v12;
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  result = (uint64_t)v12;
  v12 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B783D764(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void *health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  void *v6;
  std::string v8;
  void *v9[2];
  void *v10[2];
  void *v11[2];
  std::string __p;
  void *v13[2];
  _QWORD v14[2];
  _QWORD v15[2];

  if ((unint64_t)(a5 + a2) >= 0x12)
  {
    v5 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v15, "destinationIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v14, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow destination.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 79, (uint64_t)&__p);
  }
  if ((unint64_t)(a5 + a4) >= 0x12)
  {
    v6 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "sourceIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow source.", &v8);
    health::_HDAssertImplementation<std::out_of_range>(v6, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 80, (uint64_t)&v8);
  }
  return memcpy((void *)(a1 + 48 * a2), (const void *)(a3 + 48 * a4), 48 * a5);
}

void sub_1B783D960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

__n128 health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(uint64_t a1, __n128 *a2, unint64_t a3)
{
  void *v4;
  __n128 *v5;
  unint64_t v6;
  __n128 result;
  std::string __p;
  void *v9[2];
  void *v10[2];
  _QWORD v11[2];

  if (a3 >= 0x11)
  {
    v4 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "insertElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 57, (uint64_t)&__p);
  }
  v5 = (__n128 *)(a1 + 24 * a3);
  memmove(&v5[1].n128_i8[8], v5, 24 * (16 - a3));
  v6 = a2[1].n128_u64[0];
  result = *a2;
  *v5 = *a2;
  v5[1].n128_u64[0] = v6;
  return result;
}

void sub_1B783DB3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t HDDataEntityPredicateForRowID(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:value:comparisonType:", CFSTR("data_id"), a1, a2);
}

uint64_t HDCodableErrorReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 24;
      }
      else
      {
        if ((_DWORD)v17 == 2)
        {
          v21 = 0;
          v22 = 0;
          v23 = 0;
          *(_BYTE *)(a1 + 32) |= 1u;
          while (1)
          {
            v24 = *v3;
            v25 = *(_QWORD *)(a2 + v24);
            if (v25 == -1 || v25 >= *(_QWORD *)(a2 + *v4))
              break;
            v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v25);
            *(_QWORD *)(a2 + v24) = v25 + 1;
            v23 |= (unint64_t)(v26 & 0x7F) << v21;
            if ((v26 & 0x80) == 0)
              goto LABEL_34;
            v21 += 7;
            v14 = v22++ >= 9;
            if (v14)
            {
              v23 = 0;
              goto LABEL_36;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_34:
          if (*(_BYTE *)(a2 + *v5))
            v23 = 0;
LABEL_36:
          *(_QWORD *)(a1 + 8) = v23;
          continue;
        }
        if ((_DWORD)v17 != 1)
        {
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
        }
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 16;
      }
      v20 = *(void **)(a1 + v19);
      *(_QWORD *)(a1 + v19) = v18;

    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B783EE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDDecodeDateForValue()
{
  return objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeIntervalSinceReferenceDate:");
}

uint64_t HDDispatchQueueName(void *a1, void *a2)
{
  void *v3;
  uint64_t v4;
  __CFString *v5;
  id v6;
  objc_class *v7;
  uint64_t v8;
  void *v9;
  const __CFString *v10;
  const __CFString *v11;
  void *v12;
  id v13;
  uint64_t v14;

  v3 = (void *)MEMORY[0x1E0CB3940];
  v4 = *MEMORY[0x1E0CB76B8];
  v5 = a2;
  v6 = a1;
  v7 = (objc_class *)objc_opt_class();
  NSStringFromClass(v7);
  v8 = objc_claimAutoreleasedReturnValue();
  v9 = (void *)v8;
  v10 = CFSTR(".");
  v11 = &stru_1E6D11BB8;
  if (v5)
    v11 = v5;
  else
    v10 = &stru_1E6D11BB8;
  objc_msgSend(v3, "stringWithFormat:", CFSTR("%@.%@%@%@.%p"), v4, v8, v10, v11, v6);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  v13 = objc_retainAutorelease(v12);
  v14 = objc_msgSend(v13, "UTF8String");

  return v14;
}

uint64_t HDCreateSerialUtilityDispatchQueue()
{
  return HKCreateSerialDispatchQueueWithQOSClass();
}

void sub_1B7841B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;

  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B78428B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDDataEntityPredicateForSourceEntity(void *a1)
{
  void *v1;
  void *v2;

  if (a1)
  {
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", objc_msgSend(a1, "persistentID"));
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("data_provenances.source_id"), v1);
    v2 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v2 = 0;
  }
  return v2;
}

void sub_1B7844EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7845BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1B78460AC(_Unwind_Exception *exception_object)
{
  char v1;

  if ((v1 & 1) != 0)
    objc_end_catch();
  _Unwind_Resume(exception_object);
}

void sub_1B78460C4(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  id v9;
  void *v10;
  void *v11;

  if (a2 == 2)
  {
    v9 = objc_begin_catch(exc_buf);
    v10 = (void *)MEMORY[0x1E0CB35C8];
    objc_msgSend(v9, "reason");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "hk_error:format:", 102, CFSTR("hk_writeValue file error: %@"));
    objc_claimAutoreleasedReturnValue();

    objc_end_catch();
  }
  else
  {
    objc_begin_catch(exc_buf);
  }
  JUMPOUT(0x1B7846048);
}

void sub_1B78468C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1B7846CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78470C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDActivityCacheEntityPredicateForCacheIndices(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("cache_index"), a1);
}

void sub_1B7847E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDMetadataKeyPredicateForKey(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("key"), a1);
}

id HDPredicateForMetadataValues(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t i;
  void *v41;
  uint64_t v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  void *v50;
  id v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  _BYTE v64[128];
  _BYTE v65[128];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (objc_msgSend(v1, "count"))
  {
    objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v3 = objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v51 = v1;
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    v60 = 0u;
    v61 = 0u;
    v62 = 0u;
    v63 = 0u;
    v4 = v1;
    v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v60, v65, 16);
    v53 = (void *)v3;
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)v61;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v61 != v7)
            objc_enumerationMutation(v4);
          v9 = *(_QWORD *)(*((_QWORD *)&v60 + 1) + 8 * v8);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            _HDSQLiteValueForString();
            v10 = (void *)objc_claimAutoreleasedReturnValue();
            v11 = v2;
          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              _HDSQLiteValueForNumber();
              v10 = (void *)objc_claimAutoreleasedReturnValue();
              v11 = (void *)v3;
            }
            else
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                _HDSQLiteValueForDate();
                v10 = (void *)objc_claimAutoreleasedReturnValue();
                v11 = v55;
              }
              else
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  objc_msgSend(v54, "addObject:", v9);
                  goto LABEL_19;
                }
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0)
                {
                  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
                  v10 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "HDSQLitePredicate * _Nonnull HDPredicateForMetadataValues(NSSet * _Nonnull __strong)");
                  v12 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v12, CFSTR("HDMetadataValueEntity.m"), 784, CFSTR("Unsupported metadata value type!"));

                  v3 = (uint64_t)v53;
                  goto LABEL_18;
                }
                _HDSQLiteValueForData();
                v10 = (void *)objc_claimAutoreleasedReturnValue();
                v11 = v52;
              }
            }
          }
          objc_msgSend(v11, "addObject:", v10);
LABEL_18:

LABEL_19:
          ++v8;
        }
        while (v6 != v8);
        v13 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v60, v65, 16);
        v6 = v13;
      }
      while (v13);
    }

    objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v2, "count"))
    {
      v15 = (void *)MEMORY[0x1E0D29838];
      _HDSQLiteValueForNumber();
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "predicateWithProperty:equalToValue:", CFSTR("value_type"), v16);
      v17 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("string_value"), v2);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v17, v18);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "addObject:", v19);

    }
    else
    {
      v17 = 0;
      v18 = 0;
    }
    if (objc_msgSend(v53, "count"))
    {
      v21 = (void *)MEMORY[0x1E0D29838];
      _HDSQLiteValueForNumber();
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v21, "predicateWithProperty:equalToValue:", CFSTR("value_type"), v22);
      v23 = objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("numerical_value"), v53);
      v24 = objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v23, v24);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "addObject:", v25);

      v17 = (void *)v23;
      v18 = (void *)v24;
    }
    v26 = v54;
    if (objc_msgSend(v55, "count"))
    {
      v27 = (void *)MEMORY[0x1E0D29838];
      _HDSQLiteValueForNumber();
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v27, "predicateWithProperty:equalToValue:", CFSTR("value_type"), v28);
      v29 = objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("date_value"), v55);
      v30 = objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v29, v30);
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "addObject:", v31);

      v17 = (void *)v29;
      v18 = (void *)v30;
    }
    if (objc_msgSend(v54, "count"))
    {
      v50 = v14;
      v32 = (void *)MEMORY[0x1E0D29838];
      _HDSQLiteValueForNumber();
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v32, "predicateWithProperty:equalToValue:", CFSTR("value_type"), v33);
      v34 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0C99DE8], "array");
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      v56 = 0u;
      v57 = 0u;
      v58 = 0u;
      v59 = 0u;
      v36 = v54;
      v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v56, v64, 16);
      if (v37)
      {
        v38 = v37;
        v39 = *(_QWORD *)v57;
        do
        {
          for (i = 0; i != v38; ++i)
          {
            if (*(_QWORD *)v57 != v39)
              objc_enumerationMutation(v36);
            _HDMetadataQuantityComparisonPredicate(1, *(void **)(*((_QWORD *)&v56 + 1) + 8 * i));
            v41 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v35, "addObject:", v41);

          }
          v38 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v56, v64, 16);
        }
        while (v38);
      }

      objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAnyPredicates:", v35);
      v42 = objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v34, v42);
      v43 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = v50;
      objc_msgSend(v50, "addObject:", v43);

      v18 = (void *)v42;
      v26 = v54;
    }
    else
    {
      v34 = v17;
    }
    if (objc_msgSend(v52, "count", v50))
    {
      v44 = (void *)MEMORY[0x1E0D29838];
      _HDSQLiteValueForNumber();
      v45 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v44, "predicateWithProperty:equalToValue:", CFSTR("value_type"), v45);
      v46 = objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("data_value"), v52);
      v47 = objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v46, v47);
      v48 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "addObject:", v48);

      v34 = (void *)v46;
      v18 = (void *)v47;
    }
    objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAnyPredicates:", v14);
    v20 = (void *)objc_claimAutoreleasedReturnValue();

    v1 = v51;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0D29840], "falsePredicate");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v20;
}

uint64_t HDSampleEntityClassForDataType(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "dataObjectClass"), "hd_dataEntityClass");
}

uint64_t HDCodableActivityCacheReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableSample *v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t result;
  uint64_t v46;
  unint64_t v47;
  char v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char v53;
  char v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char v59;
  char v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  char v65;
  char v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char v86;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  char v91;
  char v92;
  unsigned int v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  char v97;
  char v98;
  unsigned int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  char v104;
  uint64_t v105;
  uint64_t v106;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v18 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 208), v18);
        if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2) & 1) != 0)
          goto LABEL_107;
        goto LABEL_203;
      case 2u:
        v19 = 0;
        v20 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x80u;
        while (2)
        {
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          v24 = v23 + 1;
          if (v23 == -1 || v24 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v25 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
            *(_QWORD *)(a2 + v22) = v24;
            v21 |= (unint64_t)(v25 & 0x7F) << v19;
            if (v25 < 0)
            {
              v19 += 7;
              v15 = v20++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_138;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_138:
        v105 = 64;
        goto LABEL_167;
      case 3u:
        *(_DWORD *)(a1 + 220) |= 0x200u;
        v26 = *v3;
        v27 = *(_QWORD *)(a2 + v26);
        if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v27);
          *(_QWORD *)(a2 + v26) = v27 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 80;
        goto LABEL_200;
      case 4u:
        *(_DWORD *)(a1 + 220) |= 0x10u;
        v29 = *v3;
        v30 = *(_QWORD *)(a2 + v29);
        if (v30 <= 0xFFFFFFFFFFFFFFF7 && v30 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v30);
          *(_QWORD *)(a2 + v29) = v30 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 40;
        goto LABEL_200;
      case 5u:
        *(_DWORD *)(a1 + 220) |= 1u;
        v31 = *v3;
        v32 = *(_QWORD *)(a2 + v31);
        if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v32);
          *(_QWORD *)(a2 + v31) = v32 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 8;
        goto LABEL_200;
      case 6u:
        v33 = 0;
        v34 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x40000u;
        while (2)
        {
          v35 = *v3;
          v36 = *(_QWORD *)(a2 + v35);
          v37 = v36 + 1;
          if (v36 == -1 || v37 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v38 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v36);
            *(_QWORD *)(a2 + v35) = v37;
            v21 |= (unint64_t)(v38 & 0x7F) << v33;
            if (v38 < 0)
            {
              v33 += 7;
              v15 = v34++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_142;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_142:
        v105 = 152;
        goto LABEL_167;
      case 7u:
        *(_DWORD *)(a1 + 220) |= 0x400u;
        v39 = *v3;
        v40 = *(_QWORD *)(a2 + v39);
        if (v40 <= 0xFFFFFFFFFFFFFFF7 && v40 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v40);
          *(_QWORD *)(a2 + v39) = v40 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 88;
        goto LABEL_200;
      case 8u:
        *(_DWORD *)(a1 + 220) |= 0x100000u;
        v41 = *v3;
        v42 = *(_QWORD *)(a2 + v41);
        if (v42 <= 0xFFFFFFFFFFFFFFF7 && v42 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v42);
          *(_QWORD *)(a2 + v41) = v42 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 168;
        goto LABEL_200;
      case 9u:
        *(_DWORD *)(a1 + 220) |= 0x800u;
        v43 = *v3;
        v44 = *(_QWORD *)(a2 + v43);
        if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v44);
          *(_QWORD *)(a2 + v43) = v44 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 96;
        goto LABEL_200;
      case 0x12u:
        *(_DWORD *)(a1 + 220) |= 0x100u;
        v46 = *v3;
        v47 = *(_QWORD *)(a2 + v46);
        if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v47);
          *(_QWORD *)(a2 + v46) = v47 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 72;
        goto LABEL_200;
      case 0x14u:
        v48 = 0;
        v49 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x10000u;
        while (2)
        {
          v50 = *v3;
          v51 = *(_QWORD *)(a2 + v50);
          v52 = v51 + 1;
          if (v51 == -1 || v52 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v53 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v51);
            *(_QWORD *)(a2 + v50) = v52;
            v21 |= (unint64_t)(v53 & 0x7F) << v48;
            if (v53 < 0)
            {
              v48 += 7;
              v15 = v49++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_146;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_146:
        v105 = 136;
        goto LABEL_167;
      case 0x16u:
        v54 = 0;
        v55 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x1000u;
        while (2)
        {
          v56 = *v3;
          v57 = *(_QWORD *)(a2 + v56);
          v58 = v57 + 1;
          if (v57 == -1 || v58 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v59 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v57);
            *(_QWORD *)(a2 + v56) = v58;
            v21 |= (unint64_t)(v59 & 0x7F) << v54;
            if (v59 < 0)
            {
              v54 += 7;
              v15 = v55++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_150;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_150:
        v105 = 104;
        goto LABEL_167;
      case 0x18u:
        v60 = 0;
        v61 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x200000u;
        while (2)
        {
          v62 = *v3;
          v63 = *(_QWORD *)(a2 + v62);
          v64 = v63 + 1;
          if (v63 == -1 || v64 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v65 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v63);
            *(_QWORD *)(a2 + v62) = v64;
            v21 |= (unint64_t)(v65 & 0x7F) << v60;
            if (v65 < 0)
            {
              v60 += 7;
              v15 = v61++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_154;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_154:
        v105 = 176;
        goto LABEL_167;
      case 0x1Fu:
        v18 = objc_alloc_init(HDCodableActivityStatisticsQuantityInfo);
        objc_msgSend((id)a1, "addDailyEnergyBurnedStatistics:", v18);
        goto LABEL_105;
      case 0x20u:
        v18 = objc_alloc_init(HDCodableActivityStatisticsQuantityInfo);
        objc_msgSend((id)a1, "addDailyBriskMinutesStatistics:", v18);
        goto LABEL_105;
      case 0x21u:
        v66 = 0;
        v67 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x20000u;
        while (2)
        {
          v68 = *v3;
          v69 = *(_QWORD *)(a2 + v68);
          v70 = v69 + 1;
          if (v69 == -1 || v70 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v71 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v69);
            *(_QWORD *)(a2 + v68) = v70;
            v21 |= (unint64_t)(v71 & 0x7F) << v66;
            if (v71 < 0)
            {
              v66 += 7;
              v15 = v67++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_158;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_158:
        v105 = 144;
        goto LABEL_167;
      case 0x22u:
        *(_DWORD *)(a1 + 220) |= 0x20u;
        v72 = *v3;
        v73 = *(_QWORD *)(a2 + v72);
        if (v73 <= 0xFFFFFFFFFFFFFFF7 && v73 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v73);
          *(_QWORD *)(a2 + v72) = v73 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 48;
        goto LABEL_200;
      case 0x23u:
        *(_DWORD *)(a1 + 220) |= 2u;
        v74 = *v3;
        v75 = *(_QWORD *)(a2 + v74);
        if (v75 <= 0xFFFFFFFFFFFFFFF7 && v75 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v75);
          *(_QWORD *)(a2 + v74) = v75 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 16;
        goto LABEL_200;
      case 0x24u:
        *(_DWORD *)(a1 + 220) |= 0x2000u;
        v76 = *v3;
        v77 = *(_QWORD *)(a2 + v76);
        if (v77 <= 0xFFFFFFFFFFFFFFF7 && v77 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v77);
          *(_QWORD *)(a2 + v76) = v77 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 112;
        goto LABEL_200;
      case 0x25u:
        *(_DWORD *)(a1 + 220) |= 0x4000u;
        v78 = *v3;
        v79 = *(_QWORD *)(a2 + v78);
        if (v79 <= 0xFFFFFFFFFFFFFFF7 && v79 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v79);
          *(_QWORD *)(a2 + v78) = v79 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 120;
        goto LABEL_200;
      case 0x26u:
        *(_DWORD *)(a1 + 220) |= 0x8000u;
        v80 = *v3;
        v81 = *(_QWORD *)(a2 + v80);
        if (v81 <= 0xFFFFFFFFFFFFFFF7 && v81 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v81);
          *(_QWORD *)(a2 + v80) = v81 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 128;
        goto LABEL_200;
      case 0x27u:
        v18 = objc_alloc_init(HDCodableActivityStatisticsQuantityInfo);
        objc_msgSend((id)a1, "addDailyMoveMinutesStatistics:", v18);
LABEL_105:
        if (PBReaderPlaceMark()
          && (HDCodableActivityStatisticsQuantityInfoReadFrom((uint64_t)v18, a2) & 1) != 0)
        {
LABEL_107:
          PBReaderRecallMark();

LABEL_201:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_203:

        return 0;
      case 0x28u:
        *(_DWORD *)(a1 + 220) |= 0x40u;
        v82 = *v3;
        v83 = *(_QWORD *)(a2 + v82);
        if (v83 <= 0xFFFFFFFFFFFFFFF7 && v83 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v83);
          *(_QWORD *)(a2 + v82) = v83 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 56;
        goto LABEL_200;
      case 0x29u:
        *(_DWORD *)(a1 + 220) |= 4u;
        v84 = *v3;
        v85 = *(_QWORD *)(a2 + v84);
        if (v85 <= 0xFFFFFFFFFFFFFFF7 && v85 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v85);
          *(_QWORD *)(a2 + v84) = v85 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v106 = 24;
LABEL_200:
        *(_QWORD *)(a1 + v106) = v28;
        goto LABEL_201;
      case 0x2Au:
        v86 = 0;
        v87 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 8u;
        while (2)
        {
          v88 = *v3;
          v89 = *(_QWORD *)(a2 + v88);
          v90 = v89 + 1;
          if (v89 == -1 || v90 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v91 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v89);
            *(_QWORD *)(a2 + v88) = v90;
            v21 |= (unint64_t)(v91 & 0x7F) << v86;
            if (v91 < 0)
            {
              v86 += 7;
              v15 = v87++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_162;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_162:
        v105 = 32;
        goto LABEL_167;
      case 0x2Bu:
        v92 = 0;
        v93 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x80000u;
        while (2)
        {
          v94 = *v3;
          v95 = *(_QWORD *)(a2 + v94);
          v96 = v95 + 1;
          if (v95 == -1 || v96 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v97 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v95);
            *(_QWORD *)(a2 + v94) = v96;
            v21 |= (unint64_t)(v97 & 0x7F) << v92;
            if (v97 < 0)
            {
              v92 += 7;
              v15 = v93++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_166;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_166:
        v105 = 160;
LABEL_167:
        *(_QWORD *)(a1 + v105) = v21;
        goto LABEL_201;
      case 0x2Cu:
        v98 = 0;
        v99 = 0;
        v100 = 0;
        *(_DWORD *)(a1 + 220) |= 0x400000u;
        while (2)
        {
          v101 = *v3;
          v102 = *(_QWORD *)(a2 + v101);
          v103 = v102 + 1;
          if (v102 == -1 || v103 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v104 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v102);
            *(_QWORD *)(a2 + v101) = v103;
            v100 |= (unint64_t)(v104 & 0x7F) << v98;
            if (v104 < 0)
            {
              v98 += 7;
              v15 = v99++ >= 9;
              if (v15)
              {
                v100 = 0;
                goto LABEL_171;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v100 = 0;
LABEL_171:
        *(_BYTE *)(a1 + 216) = v100 != 0;
        goto LABEL_201;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_201;
    }
  }
}

id HDWorkoutEntityPredicateForWorkoutActivityType(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:value:comparisonType:", CFSTR("activities.activity_type"), v2, 1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1B784AE6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDNanoSyncEntityClassForObjectType(int a1)
{
  void *v1;

  if ((a1 - 1) <= 0x31 && ((0x3E1000067FFAFuLL >> (a1 - 1)) & 1) != 0)
  {
    objc_opt_class();
    v1 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v1 = 0;
  }
  return v1;
}

void sub_1B784BEB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v12 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableSourceReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  int *v8;
  int *v9;
  char v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  BOOL v17;
  int v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  char v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  void *v40;
  int *v41;
  int *v42;
  HDCodableSyncIdentity *v43;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = &OBJC_IVAR___HDDemoDataPerson__rehabLogarithmicConstant;
  v8 = &OBJC_IVAR___HDDemoDataPerson__rehabLogarithmicConstant;
  v9 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    while (1)
    {
      v13 = *v3;
      v14 = *(_QWORD *)(a2 + v13);
      v15 = v14 + 1;
      if (v14 == -1 || v15 > *(_QWORD *)(a2 + *v4))
        break;
      v16 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v14);
      *(_QWORD *)(a2 + v13) = v15;
      v12 |= (unint64_t)(v16 & 0x7F) << v10;
      if ((v16 & 0x80) == 0)
        goto LABEL_12;
      v10 += 7;
      v17 = v11++ >= 9;
      if (v17)
      {
        v12 = 0;
        v18 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v18 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v12 = 0;
LABEL_14:
    if (v18 || (v12 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v12 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = v7[735];
        goto LABEL_43;
      case 2u:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = v8[736];
        goto LABEL_43;
      case 3u:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 48;
        goto LABEL_43;
      case 4u:
        v23 = 0;
        v24 = 0;
        v25 = 0;
        *(_BYTE *)(a1 + 76) |= 2u;
        while (2)
        {
          v26 = *v3;
          v27 = *(_QWORD *)(a2 + v26);
          v28 = v27 + 1;
          if (v27 == -1 || v28 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v27);
            *(_QWORD *)(a2 + v26) = v28;
            v25 |= (unint64_t)(v29 & 0x7F) << v23;
            if (v29 < 0)
            {
              v23 += 7;
              v17 = v24++ >= 9;
              if (v17)
              {
                v25 = 0;
                goto LABEL_52;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v25 = 0;
LABEL_52:
        *(_QWORD *)(a1 + 16) = v25;
        goto LABEL_44;
      case 5u:
        PBReaderReadData();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 64;
        goto LABEL_43;
      case 6u:
        *(_BYTE *)(a1 + 76) |= 1u;
        v30 = *v3;
        v31 = *(_QWORD *)(a2 + v30);
        if (v31 <= 0xFFFFFFFFFFFFFFF7 && v31 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v31);
          *(_QWORD *)(a2 + v30) = v31 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v32 = 0;
        }
        *(_QWORD *)(a1 + 8) = v32;
        goto LABEL_44;
      case 7u:
        v33 = 0;
        v34 = 0;
        v35 = 0;
        *(_BYTE *)(a1 + 76) |= 4u;
        while (2)
        {
          v36 = *v3;
          v37 = *(_QWORD *)(a2 + v36);
          v38 = v37 + 1;
          if (v37 == -1 || v38 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v39 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v37);
            *(_QWORD *)(a2 + v36) = v38;
            v35 |= (unint64_t)(v39 & 0x7F) << v33;
            if (v39 < 0)
            {
              v33 += 7;
              v17 = v34++ >= 9;
              if (v17)
              {
                v35 = 0;
                goto LABEL_56;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v35 = 0;
LABEL_56:
        *(_BYTE *)(a1 + 72) = v35 != 0;
        goto LABEL_44;
      case 8u:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 40;
LABEL_43:
        v40 = *(void **)(a1 + v21);
        *(_QWORD *)(a1 + v21) = v20;

        goto LABEL_44;
      case 9u:
        v41 = v8;
        v42 = v7;
        v43 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 56), v43);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v43, a2))
        {
          PBReaderRecallMark();

          v7 = v42;
          v8 = v41;
LABEL_44:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_44;
    }
  }
}

uint64_t HDCodableProvenanceReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  char v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  void *v36;
  uint64_t v37;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 24;
          goto LABEL_49;
        case 3u:
          PBReaderReadData();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 56;
          goto LABEL_49;
        case 4u:
          PBReaderReadData();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
          goto LABEL_49;
        case 5u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 64;
          goto LABEL_49;
        case 6u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 48;
          goto LABEL_49;
        case 7u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 72;
          goto LABEL_49;
        case 8u:
          v20 = 0;
          v21 = 0;
          v22 = 0;
          *(_BYTE *)(a1 + 80) |= 1u;
          while (2)
          {
            v23 = *v3;
            v24 = *(_QWORD *)(a2 + v23);
            if (v24 == -1 || v24 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v25 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v24);
              *(_QWORD *)(a2 + v23) = v24 + 1;
              v22 |= (unint64_t)(v25 & 0x7F) << v20;
              if (v25 < 0)
              {
                v20 += 7;
                v14 = v21++ >= 9;
                if (v14)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_53;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v22) = 0;
LABEL_53:
          v37 = 32;
          goto LABEL_62;
        case 9u:
          v26 = 0;
          v27 = 0;
          v22 = 0;
          *(_BYTE *)(a1 + 80) |= 2u;
          while (2)
          {
            v28 = *v3;
            v29 = *(_QWORD *)(a2 + v28);
            if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
              *(_QWORD *)(a2 + v28) = v29 + 1;
              v22 |= (unint64_t)(v30 & 0x7F) << v26;
              if (v30 < 0)
              {
                v26 += 7;
                v14 = v27++ >= 9;
                if (v14)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_57;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v22) = 0;
LABEL_57:
          v37 = 36;
          goto LABEL_62;
        case 0xAu:
          v31 = 0;
          v32 = 0;
          v22 = 0;
          *(_BYTE *)(a1 + 80) |= 4u;
          break;
        case 0xBu:
          PBReaderReadData();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 8;
LABEL_49:
          v36 = *(void **)(a1 + v18);
          *(_QWORD *)(a1 + v18) = v17;

          continue;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v33 = *v3;
        v34 = *(_QWORD *)(a2 + v33);
        if (v34 == -1 || v34 >= *(_QWORD *)(a2 + *v4))
          break;
        v35 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v34);
        *(_QWORD *)(a2 + v33) = v34 + 1;
        v22 |= (unint64_t)(v35 & 0x7F) << v31;
        if ((v35 & 0x80) == 0)
          goto LABEL_59;
        v31 += 7;
        v14 = v32++ >= 9;
        if (v14)
        {
          LODWORD(v22) = 0;
          goto LABEL_61;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_59:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v22) = 0;
LABEL_61:
      v37 = 40;
LABEL_62:
      *(_DWORD *)(a1 + v37) = v22;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

id HDSourceEntityPredicateForSourceWithUUID(void *a1, int a2)
{
  void *v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;

  v3 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(a1, "hk_dataForUUIDBytes");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "predicateWithProperty:equalToValue:", CFSTR("uuid"), v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (a2)
  {
    v6 = v5;
  }
  else
  {
    _HDSourceEntityPredicateForNotDeletedWithPredicate(v5);
    v6 = (id)objc_claimAutoreleasedReturnValue();
  }
  v7 = v6;

  return v7;
}

void sub_1B784CEA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;

  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1B784CF44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void HDVersionFromBuildStringForProductType(void *a1@<X0>, void *a2@<X1>, _QWORD *a3@<X8>)
{
  id v5;
  __int128 *v6;
  void *v7;
  void *v8;
  id v9;

  v9 = a1;
  v5 = a2;
  if (objc_msgSend(v9, "isEqualToString:", CFSTR("UnknownBuild")))
    goto LABEL_2;
  if (objc_msgSend(v9, "isEqualToString:", CFSTR("[8.0, 8.2)")))
  {
    v6 = &HDDataProvenanceOperatingSystemVersion8_0_0;
    goto LABEL_7;
  }
  if (objc_msgSend(v9, "isEqualToString:", CFSTR("[8.2, 9.0)")))
  {
    v6 = &HDDataProvenanceOperatingSystemVersion8_2_0;
    goto LABEL_7;
  }
  if (objc_msgSend(v5, "hasPrefix:", CFSTR("iPhone")))
  {
    if (qword_1ED552188 != -1)
      dispatch_once(&qword_1ED552188, &__block_literal_global_295);
    v7 = v9;
    v8 = (void *)qword_1ED552180;
LABEL_17:
    versionFromBuildString(a3, v7, v8);
    goto LABEL_8;
  }
  if (objc_msgSend(v5, "hasPrefix:", CFSTR("Watch")))
  {
    if (qword_1ED552198 != -1)
      dispatch_once(&qword_1ED552198, &__block_literal_global_298);
    v7 = v9;
    v8 = (void *)qword_1ED552190;
    goto LABEL_17;
  }
LABEL_2:
  v6 = &HDDataProvenanceOperatingSystemVersionUnknown;
LABEL_7:
  *(_OWORD *)a3 = *v6;
  a3[2] = *((_QWORD *)v6 + 2);
LABEL_8:

}

void __iOSSortedBuildStrings_block_invoke()
{
  void *v0;

  v0 = (void *)qword_1ED552180;
  qword_1ED552180 = (uint64_t)&unk_1E6DF8888;

}

void versionFromBuildString(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  unint64_t v6;
  id v7;
  uint64_t v8;
  void *v9;
  unint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  id v14;

  v14 = a2;
  v5 = a3;
  v6 = objc_msgSend(v5, "count");
  if (qword_1ED552178 != -1)
    dispatch_once(&qword_1ED552178, &__block_literal_global_189);
  v7 = (id)_MergedGlobals_197;
  objc_msgSend(v7, "objectForKey:", v14);
  v8 = objc_claimAutoreleasedReturnValue();
  v9 = (void *)v8;
  if (v8)
  {
    objc_copyStruct(a1, (const void *)(v8 + 8), 24, 1, 0);
  }
  else
  {
    v10 = objc_msgSend(v5, "indexOfObject:inSortedRange:options:usingComparator:", v14, 0, v6, 1024, &__block_literal_global_4);
    if (v10 >= v6)
    {
      *(_OWORD *)a1 = HDDataProvenanceOperatingSystemVersionUnknown;
      a1[2] = 0;
    }
    else
    {
      objc_msgSend(v5, "objectAtIndexedSubscript:", v10);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "objectForKeyedSubscript:", v11);
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = (void *)v12;
      if (v12)
      {
        objc_copyStruct(a1, (const void *)(v12 + 8), 24, 1, 0);
      }
      else
      {
        *a1 = 0;
        a1[1] = 0;
        a1[2] = 0;
      }

    }
  }

}

void __buildStringToVersionMap_block_invoke()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  _QWORD v54[52];
  _QWORD v55[54];

  v55[52] = *MEMORY[0x1E0C80C00];
  v54[0] = CFSTR("13A0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  v55[0] = v53;
  v54[1] = CFSTR("13A344");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 0);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  v55[1] = v52;
  v54[2] = CFSTR("13A405");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 1);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v55[2] = v51;
  v54[3] = CFSTR("13A452");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 2);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v55[3] = v50;
  v54[4] = CFSTR("13A5325c");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 0);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v55[4] = v49;
  v54[5] = CFSTR("13B143");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 1, 0);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  v55[5] = v48;
  v54[6] = CFSTR("13B5130b");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 1, 0);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  v55[6] = v47;
  v54[7] = CFSTR("13C5060d");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 2, 0);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  v55[7] = v46;
  v54[8] = CFSTR("13D20");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 2, 1);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v55[8] = v45;
  v54[9] = CFSTR("13E237");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 0);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v55[9] = v44;
  v54[10] = CFSTR("13E238");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 1);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v55[10] = v43;
  v54[11] = CFSTR("13E5234a");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 0);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v55[11] = v42;
  v54[12] = CFSTR("13F69");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 2);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  v55[12] = v41;
  v54[13] = CFSTR("13G34");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 3);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v55[13] = v40;
  v54[14] = CFSTR("13G35");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v55[14] = v39;
  v54[15] = CFSTR("13G36");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 5);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v55[15] = v38;
  v54[16] = CFSTR("14A0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v55[16] = v37;
  v54[17] = CFSTR("14A346");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 0);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v55[17] = v36;
  v54[18] = CFSTR("14A403");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 1);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v55[18] = v35;
  v54[19] = CFSTR("14A456");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 2);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v55[19] = v34;
  v54[20] = CFSTR("14A551");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 3);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v55[20] = v33;
  v54[21] = CFSTR("14A5346a");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 0);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v55[21] = v32;
  v54[22] = CFSTR("14B99999");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 1, 0);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v55[22] = v31;
  v54[23] = CFSTR("14C99999");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 2, 0);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v55[23] = v30;
  v54[24] = CFSTR("14E0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v55[24] = v29;
  v54[25] = CFSTR("14E99999");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 3, 0);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v55[25] = v28;
  v54[26] = CFSTR("150");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v55[26] = v27;
  v54[27] = CFSTR("15A99999");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 11, 0, 0);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v55[27] = v26;
  v54[28] = CFSTR("12S0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v55[28] = v25;
  v54[29] = CFSTR("12S507");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 1, 0, 0);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v55[29] = v24;
  v54[30] = CFSTR("12S632");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 1, 0, 1);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v55[30] = v23;
  v54[31] = CFSTR("13S0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v55[31] = v22;
  v54[32] = CFSTR("13S344");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 0, 0);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v55[32] = v21;
  v54[33] = CFSTR("13S428");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 0, 1);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v55[33] = v20;
  v54[34] = CFSTR("13S661");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 1, 0);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v55[34] = v19;
  v54[35] = CFSTR("13S5325c");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 0, 0);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v55[35] = v18;
  v54[36] = CFSTR("13V0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v55[36] = v17;
  v54[37] = CFSTR("13V144");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 0);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v55[37] = v16;
  v54[38] = CFSTR("13V420");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 1);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v55[38] = v15;
  v54[39] = CFSTR("13V604");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 2);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v55[39] = v14;
  v54[40] = CFSTR("13V5143a");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 0);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v55[40] = v13;
  v54[41] = CFSTR("14B0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v55[41] = v12;
  v54[42] = CFSTR("14B471");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 1, 0);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v55[42] = v0;
  v54[43] = CFSTR("14S0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v55[43] = v1;
  v54[44] = CFSTR("14S326");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 0, 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v55[44] = v2;
  v54[45] = CFSTR("14S471");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 1, 0);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v55[45] = v3;
  v54[46] = CFSTR("14S1000");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 1, 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v55[46] = v4;
  v54[47] = CFSTR("14S5869b");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 0, 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v55[47] = v5;
  v54[48] = CFSTR("14V0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v55[48] = v6;
  v54[49] = CFSTR("14V9999");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 3, 0);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v55[49] = v7;
  v54[50] = CFSTR("15R0");
  +[HDNSOperatingSystemVersion unknownVersion]();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v55[50] = v8;
  v54[51] = CFSTR("15R9999");
  +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 4, 0, 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v55[51] = v9;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v55, v54, 52);
  v10 = objc_claimAutoreleasedReturnValue();
  v11 = (void *)_MergedGlobals_197;
  _MergedGlobals_197 = v10;

}

uint64_t __versionFromBuildString_block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "hk_compareBuildVersionWithString:");
}

void __allowedClasses_block_invoke()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  v0 = (void *)MEMORY[0x1E0C99E60];
  v1 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, v7, v8, v9, objc_opt_class(), 0);
  v10 = objc_claimAutoreleasedReturnValue();
  v11 = (void *)qword_1ED552528;
  qword_1ED552528 = v10;

}

void sub_1B784EA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;
  void *v23;

  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1B784EAF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void HDPowerLog(void *a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  id v7;

  v5 = a1;
  v7 = (id)objc_msgSend(a2, "mutableCopy");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "setObject:forKeyedSubscript:", v6, CFSTR("status"));

  PLLogRegisteredEvent();
}

void sub_1B784FF50(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf)
{
  id v11;
  NSObject *v12;
  uint64_t v13;

  if (a2 == 1)
  {
    v11 = objc_begin_catch(a1);
    _HKInitializeLogging();
    HKLogInfrastructure();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = objc_opt_class();
      LODWORD(buf) = 138543618;
      *(_QWORD *)((char *)&buf + 4) = v13;
      WORD6(buf) = 2112;
      _os_log_impl(&dword_1B7802000, v12, OS_LOG_TYPE_DEFAULT, "%{public}@: Exception parsing unit string: %@", (uint8_t *)&buf, 0x16u);
    }

    objc_end_catch();
    JUMPOUT(0x1B784FE8CLL);
  }
  _Unwind_Resume(a1);
}

id sub_1B7850014(uint64_t a1, uint64_t a2)
{
  return sub_1B7850060(a1, a2, (void (*)(void))sub_1B7851328);
}

uint64_t EpochBasedSyncStateUpdaterDelegate.domain.getter()
{
  uint64_t v0;

  v0 = sub_1B7851328();
  swift_bridgeObjectRetain();
  return v0;
}

id sub_1B7850054(uint64_t a1, uint64_t a2)
{
  return sub_1B7850060(a1, a2, (void (*)(void))sub_1B785134C);
}

id sub_1B7850060(uint64_t a1, uint64_t a2, void (*a3)(void))
{
  void *v3;

  a3();
  swift_bridgeObjectRetain();
  v3 = (void *)sub_1B7EF9CB0();
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t EpochBasedSyncStateUpdaterDelegate.key.getter()
{
  uint64_t v0;

  v0 = sub_1B785134C();
  swift_bridgeObjectRetain();
  return v0;
}

uint64_t sub_1B78500E0()
{
  return EpochBasedSyncStateUpdaterDelegate.supportedSyncVersionRange.getter();
}

uint64_t EpochBasedSyncStateUpdaterDelegate.supportedSyncVersionRange.getter()
{
  _QWORD *v0;

  return *(_QWORD *)((char *)v0 + *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v0) + 0x80));
}

uint64_t EpochBasedSyncStateUpdaterDelegate.store.getter@<X0>(uint64_t a1@<X8>)
{
  char *v1;

  return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)(*(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *(_QWORD *)v1)
                                                                            + 0x50)
                                                                - 8)
                                                    + 16))(a1, &v1[*(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *(_QWORD *)v1) + 0x88)]);
}

id EpochBasedSyncStateUpdaterDelegate.__allocating_init(logger:key:supportedSyncVersionRange:domain:store:maxDataSizeInBytes:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  objc_class *v8;
  objc_class *v9;
  id v18;
  id v19;

  v9 = v8;
  v18 = objc_allocWithZone(v9);
  v19 = sub_1B7851370(a1, a2, a3, a4, a5, a6, a7, a8);
  (*(void (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)v9 + 10) - 8) + 8))(a7);
  return v19;
}

id EpochBasedSyncStateUpdaterDelegate.init(logger:key:supportedSyncVersionRange:domain:store:maxDataSizeInBytes:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v10;
  id v11;

  v10 = *MEMORY[0x1E0DEEDD8] & *v8;
  v11 = sub_1B7851370(a1, a2, a3, a4, a5, a6, a7, a8);
  (*(void (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(v10 + 80) - 8) + 8))(a7);
  return v11;
}

uint64_t sub_1B7850254(_QWORD *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, id *a6)
{
  return sub_1B78514D0(a1, a2, a3, a6);
}

uint64_t sub_1B785025C(_QWORD *a1)
{
  __swift_project_boxed_opaque_existential_0(a1, a1[3]);
  swift_getDynamicType();
  sub_1B7853A4C();
  return sub_1B7EF9CC8();
}

uint64_t sub_1B78502AC(void *a1, uint64_t a2, _QWORD *a3, void *a4, uint64_t a5, void *a6, void *a7, id *a8)
{
  id v15;
  id v16;
  id v17;
  uint64_t v18;

  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  v15 = a6;
  v16 = a7;
  v17 = a1;
  v18 = sub_1B78514D0(a3, a4, a5, a8);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();

  return v18;
}

uint64_t sub_1B7850358(void *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AssociatedTypeWitness;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t AssociatedConformanceWitness;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  os_log_type_t type;
  uint64_t v39;
  uint64_t v40[4];
  uint64_t v41;

  v4 = v3;
  swift_getObjectType();
  v8 = *MEMORY[0x1E0DEEDD8] & *v3;
  v9 = *(_QWORD *)(v8 + 80);
  v10 = *(_QWORD *)(v8 + 88);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  v12 = swift_dynamicCastUnknownClass();
  swift_unknownObjectRetain_n();
  if (v12)
  {
    swift_unknownObjectRetain();
    v13 = sub_1B7EF9C2C();
    type = sub_1B7EF9D4C();
    if (os_log_type_enabled(v13, type))
    {
      v14 = swift_slowAlloc();
      v37 = swift_slowAlloc();
      v40[0] = v37;
      *(_DWORD *)v14 = 136446466;
      v15 = sub_1B7EF9F38();
      v41 = sub_1B7850CC0(v15, v16, v40);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v14 + 12) = 2080;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
      v18 = v12;
      v19 = (*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56))(AssociatedTypeWitness, AssociatedConformanceWitness);
      v41 = sub_1B7850CC0(v19, v20, v40);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v13, type, "[%{public}s] Syncing merged state: %s", (uint8_t *)v14, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v37, -1, -1);
      MEMORY[0x1BCCAD16C](v14, -1, -1);

    }
    else
    {
      swift_unknownObjectRelease_n();

      v18 = v12;
    }
    objc_msgSend(a1, sel_setCodableObject_version_profile_, v18, *(int *)((char *)v4 + *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v4) + 0x80)), a3);
    return swift_unknownObjectRelease();
  }
  else
  {
    v21 = sub_1B7EF9C2C();
    v22 = sub_1B7EF9D58();
    if (os_log_type_enabled(v21, v22))
    {
      v23 = swift_slowAlloc();
      v39 = v9;
      v40[0] = swift_slowAlloc();
      v24 = v40[0];
      *(_DWORD *)v23 = 136446466;
      v25 = sub_1B7EF9F38();
      v41 = sub_1B7850CC0(v25, v26, v40);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v23 + 12) = 2080;
      v41 = a2;
      sub_1B785287C();
      swift_unknownObjectRetain();
      v27 = sub_1B7EF9CC8();
      v41 = sub_1B7850CC0(v27, v28, v40);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v21, v22, "[%{public}s] Unexpected object type: %s", (uint8_t *)v23, 0x16u);
      swift_arrayDestroy();
      v29 = v24;
      v9 = v39;
      MEMORY[0x1BCCAD16C](v29, -1, -1);
      MEMORY[0x1BCCAD16C](v23, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    v40[3] = swift_getObjectType();
    v40[0] = a2;
    swift_unknownObjectRetain();
    v31 = sub_1B785025C(v40);
    v33 = v32;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v40);
    v35 = type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure(0, v9, v10, v34);
    MEMORY[0x1BCCAD100](&unk_1B7F39398, v35);
    swift_allocError();
    *v36 = v31;
    v36[1] = v33;
    return swift_willThrow();
  }
}

uint64_t sub_1B7850800(void *a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  id v8;
  id v9;
  id v10;

  v8 = a3;
  swift_unknownObjectRetain();
  v9 = a5;
  v10 = a1;
  sub_1B7850358(v8, a4, (uint64_t)v9);

  swift_unknownObjectRelease();
  return 1;
}

uint64_t sub_1B78508C0(uint64_t a1)
{
  return sub_1B78528D0(a1);
}

uint64_t sub_1B78508D4(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;

  swift_unknownObjectRetain();
  v7 = a4;
  v8 = a1;
  sub_1B78528D0(a3);

  swift_unknownObjectRelease();
  return 1;
}

void sub_1B7850980(_QWORD *a1)
{
  sub_1B7852D5C(a1);
}

uint64_t sub_1B7850994(void *a1, uint64_t a2, _QWORD *a3, void *a4, void *a5)
{
  id v8;
  id v9;
  id v10;

  v8 = a4;
  v9 = a5;
  v10 = a1;
  sub_1B7852D5C(a3);

  return 1;
}

uint64_t sub_1B7850A3C(_QWORD *a1, void *a2, uint64_t a3, _QWORD *a4)
{
  return sub_1B7852FF0(a1, a2, a4);
}

uint64_t sub_1B7850A44(void *a1, uint64_t a2, _QWORD *a3, void *a4, void *a5, _QWORD *a6)
{
  id v10;
  id v11;
  id v12;
  uint64_t v13;

  v10 = a4;
  v11 = a5;
  v12 = a1;
  v13 = sub_1B7852FF0(a3, v10, a6);

  return v13;
}

id EpochBasedSyncStateUpdaterDelegate.__allocating_init()()
{
  objc_class *v0;

  return objc_msgSend(objc_allocWithZone(v0), sel_init);
}

void EpochBasedSyncStateUpdaterDelegate.init()()
{
  sub_1B7853538();
}

void sub_1B7850AF4()
{
  sub_1B7853538();
}

id EpochBasedSyncStateUpdaterDelegate.__deallocating_deinit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  objc_class *v5;
  objc_super v7;

  v5 = (objc_class *)type metadata accessor for EpochBasedSyncStateUpdaterDelegate(0, *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v4) + 0x50), *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v4) + 0x58), a4);
  v7.receiver = v4;
  v7.super_class = v5;
  return objc_msgSendSuper2(&v7, sel_dealloc);
}

uint64_t sub_1B7850B5C(char *a1)
{
  _QWORD *v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;

  v2 = (_QWORD *)MEMORY[0x1E0DEEDD8];
  v3 = *MEMORY[0x1E0DEEDD8] & *(_QWORD *)a1;
  v4 = &a1[*(_QWORD *)(v3 + 0x68)];
  v5 = sub_1B7EF9C38();
  (*(void (**)(char *, uint64_t))(*(_QWORD *)(v5 - 8) + 8))(v4, v5);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return (*(uint64_t (**)(char *))(*(_QWORD *)(*(_QWORD *)(v3 + 80) - 8) + 8))(&a1[*(_QWORD *)((*v2 & *(_QWORD *)a1) + 0x88)]);
}

unint64_t sub_1B7850C10(uint64_t a1, uint64_t a2)
{
  if (!a2)
    return 0xD000000000000030;
  sub_1B7EF9DD0();
  swift_bridgeObjectRelease();
  sub_1B7EF9CE0();
  return 0xD00000000000002CLL;
}

unint64_t sub_1B7850CB8()
{
  uint64_t *v0;

  return sub_1B7850C10(*v0, v0[1]);
}

uint64_t sub_1B7850CC0(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t ObjectType;

  v6 = sub_1B7850D90(v12, 0, 0, 1, a1, a2);
  v7 = v12[0];
  if (v6)
  {
    v8 = v6;
    ObjectType = swift_getObjectType();
    v12[0] = v8;
    v9 = *a3;
    if (*a3)
    {
      sub_1B78539A4((uint64_t)v12, *a3);
      *a3 = v9 + 32;
    }
  }
  else
  {
    ObjectType = MEMORY[0x1E0DEC2B8];
    v12[0] = a1;
    v12[1] = a2;
    v10 = *a3;
    if (*a3)
    {
      sub_1B78539A4((uint64_t)v12, *a3);
      *a3 = v10 + 32;
    }
    swift_bridgeObjectRetain();
  }
  __swift_destroy_boxed_opaque_existential_0((uint64_t)v12);
  return v7;
}

uint64_t sub_1B7850D90(uint64_t *a1, char *__dst, uint64_t a3, char a4, uint64_t a5, unint64_t a6)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  _QWORD __src[2];

  if ((a6 & 0x2000000000000000) != 0)
  {
    if ((a4 & 1) == 0)
    {
      if (__dst)
      {
        v11 = HIBYTE(a6) & 0xF;
        if (a3 - (uint64_t)__dst > v11)
        {
          __src[0] = a5;
          __src[1] = a6 & 0xFFFFFFFFFFFFFFLL;
          if (__src >= (_QWORD *)&__dst[v11] || (char *)__src + v11 <= __dst)
          {
            memcpy(__dst, __src, HIBYTE(a6) & 0xF);
            sub_1B7EF9DA0();
            result = 0;
            *a1 = (uint64_t)__dst;
            return result;
          }
          goto LABEL_17;
        }
      }
    }
LABEL_13:
    result = sub_1B7850F48(a5, a6);
    *a1 = v12;
    return result;
  }
  if ((a6 & 0x1000000000000000) != 0)
    goto LABEL_13;
  if ((a5 & 0x1000000000000000) != 0)
  {
    v8 = (a6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    goto LABEL_5;
  }
  v8 = sub_1B7EF9E00();
  if (!v8)
  {
    sub_1B7EF9E54();
    __break(1u);
LABEL_17:
    result = sub_1B7EF9EA8();
    __break(1u);
    return result;
  }
LABEL_5:
  *a1 = v8;
  if ((a6 & 0x8000000000000000) != 0)
    return 0;
  else
    return swift_unknownObjectRetain();
}

uint64_t sub_1B7850F48(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = sub_1B7850FDC(a1, a2);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    v2 = sub_1B78511C8(0, *(_QWORD *)(v2 + 16) + 1, 1, (char *)v2);
  v4 = *(_QWORD *)(v2 + 16);
  v3 = *(_QWORD *)(v2 + 24);
  if (v4 >= v3 >> 1)
    v2 = sub_1B78511C8(v3 > 1, v4 + 1, 1, (char *)v2);
  *(_QWORD *)(v2 + 16) = v4 + 1;
  *(_BYTE *)(v2 + 32 + v4) = 0;
  return v2;
}

uint64_t sub_1B7850FDC(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t result;

  if ((a2 & 0x1000000000000000) != 0)
    goto LABEL_10;
  if ((a2 & 0x2000000000000000) != 0)
    v2 = HIBYTE(a2) & 0xF;
  else
    v2 = a1 & 0xFFFFFFFFFFFFLL;
  if (v2)
  {
    while (1)
    {
      v3 = sub_1B7851150(v2, 0);
      if (v2 < 0)
        break;
      v4 = v3;
      v5 = sub_1B7EF9DDC();
      if ((v6 & 1) != 0)
        goto LABEL_14;
      if (v5 == v2)
        return (uint64_t)v4;
      sub_1B7EF9E54();
      __break(1u);
LABEL_10:
      v2 = sub_1B7EF9CEC();
      if (!v2)
        return MEMORY[0x1E0DEE9D8];
    }
    sub_1B7EF9EA8();
    __break(1u);
LABEL_14:
    result = sub_1B7EF9E54();
    __break(1u);
  }
  else
  {
    return MEMORY[0x1E0DEE9D8];
  }
  return result;
}

_QWORD *sub_1B7851150(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  size_t v5;

  if (a2 <= a1)
    v2 = a1;
  else
    v2 = a2;
  if (!v2)
    return (_QWORD *)MEMORY[0x1E0DEE9D8];
  sub_1B78539E0(0, &qword_1EF192720, MEMORY[0x1E0DEDE70], (uint64_t (*)(_QWORD, uint64_t))MEMORY[0x1E0DED1E8]);
  v4 = (_QWORD *)swift_allocObject();
  v5 = _swift_stdlib_malloc_size(v4);
  v4[2] = a1;
  v4[3] = 2 * v5 - 64;
  return v4;
}

uint64_t sub_1B78511C8(char a1, int64_t a2, char a3, char *a4)
{
  unint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;
  uint64_t result;

  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_30;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    sub_1B78539E0(0, &qword_1EF192720, MEMORY[0x1E0DEDE70], (uint64_t (*)(_QWORD, uint64_t))MEMORY[0x1E0DED1E8]);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    v10 = (char *)MEMORY[0x1E0DEE9D8];
  }
  v12 = v10 + 32;
  v13 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v10 != a4 || v12 >= &v13[v8])
      memmove(v12, v13, v8);
    *((_QWORD *)a4 + 2) = 0;
    goto LABEL_28;
  }
  if (v13 >= &v12[v8] || v12 >= &v13[v8])
  {
    memcpy(v12, v13, v8);
LABEL_28:
    swift_bridgeObjectRelease();
    return (uint64_t)v10;
  }
LABEL_30:
  result = sub_1B7EF9EA8();
  __break(1u);
  return result;
}

uint64_t sub_1B7851328()
{
  _QWORD *v0;

  return *(_QWORD *)((char *)v0 + *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v0) + 0x70));
}

uint64_t sub_1B785134C()
{
  _QWORD *v0;

  return *(_QWORD *)((char *)v0 + *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v0) + 0x78));
}

id sub_1B7851370(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  objc_class *v22;
  id v23;
  objc_super v29;

  v13 = (_QWORD *)MEMORY[0x1E0DEEDD8];
  v14 = (_QWORD *)(*MEMORY[0x1E0DEEDD8] & *(_QWORD *)v8);
  v15 = &v8[v14[13]];
  v16 = sub_1B7EF9C38();
  v17 = *(_QWORD *)(v16 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v15, a1, v16);
  v18 = &v8[*(_QWORD *)((*v13 & *(_QWORD *)v8) + 0x78)];
  *(_QWORD *)v18 = a2;
  *((_QWORD *)v18 + 1) = a3;
  *(_QWORD *)&v8[*(_QWORD *)((*v13 & *(_QWORD *)v8) + 0x80)] = a4;
  v19 = &v8[*(_QWORD *)((*v13 & *(_QWORD *)v8) + 0x70)];
  *(_QWORD *)v19 = a5;
  *((_QWORD *)v19 + 1) = a6;
  v20 = v14[10];
  (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v20 - 8) + 16))(&v8[*(_QWORD *)((*v13 & *(_QWORD *)v8) + 0x88)], a7, v20);
  *(_QWORD *)&v8[*(_QWORD *)((*v13 & *(_QWORD *)v8) + 0x60)] = a8;
  v22 = (objc_class *)type metadata accessor for EpochBasedSyncStateUpdaterDelegate(0, v20, v14[11], v21);
  v29.receiver = v8;
  v29.super_class = v22;
  v23 = objc_msgSendSuper2(&v29, sel_init);
  (*(void (**)(uint64_t, uint64_t))(v17 + 8))(a1, v16);
  return v23;
}

uint64_t sub_1B78514D0(_QWORD *a1, void *a2, uint64_t a3, id *a4)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(uint64_t, uint64_t);
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  void *v21;
  NSObject *v22;
  os_log_type_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t *v37;
  id v38;
  id v39;
  id v40;
  id v41;
  NSObject *v42;
  os_log_type_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  id v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v56;
  NSObject *v57;
  os_log_type_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  void *v62;
  void *v63;
  id v64;
  NSObject *v65;
  os_log_type_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  void *v70;
  void *v71;
  id v72;
  id v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  NSObject *log;
  void *v79;
  void (*v80)(uint64_t, uint64_t);
  os_log_type_t v81;
  void *v82;
  _QWORD *v83;
  void *v84;
  void *v85;
  void *v86;
  uint64_t v87;
  uint64_t v89;
  id v90;
  id v91[5];

  v5 = v4;
  swift_getObjectType();
  v9 = *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v5) + 0x50);
  v8 = *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v5) + 0x58);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  if (swift_dynamicCastUnknownClass() && (v11 = swift_dynamicCastUnknownClass()) != 0)
  {
    v12 = v11;
    v83 = a1;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
    v14 = *(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 8);
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v15 = v14(AssociatedTypeWitness, AssociatedConformanceWitness);
    if (v14(AssociatedTypeWitness, AssociatedConformanceWitness) >= v15)
    {
      v56 = v14(AssociatedTypeWitness, AssociatedConformanceWitness);
      if (v14(AssociatedTypeWitness, AssociatedConformanceWitness) >= v56)
      {
        v82 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 32))(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRetain_n();
        v65 = sub_1B7EF9C2C();
        v66 = sub_1B7EF9D64();
        if (os_log_type_enabled(v65, v66))
        {
          log = v65;
          v67 = swift_slowAlloc();
          v79 = (void *)swift_slowAlloc();
          v91[0] = v79;
          *(_DWORD *)v67 = 136446466;
          v68 = sub_1B7EF9F38();
          sub_1B7850CC0(v68, v69, (uint64_t *)v91);
          sub_1B7EF9D94();
          swift_bridgeObjectRelease();
          *(_WORD *)(v67 + 12) = 2048;
          v70 = (void *)v14(AssociatedTypeWitness, AssociatedConformanceWitness);
          swift_unknownObjectRelease();
          v90 = v70;
          sub_1B7EF9D94();
          swift_unknownObjectRelease();
          _os_log_impl(&dword_1B7802000, log, v66, "[%{public}s] Merging local and cloud state with same epoch (%lld)", (uint8_t *)v67, 0x16u);
          swift_arrayDestroy();
          MEMORY[0x1BCCAD16C](v79, -1, -1);
          MEMORY[0x1BCCAD16C](v67, -1, -1);

        }
        else
        {

          swift_unknownObjectRelease_n();
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 40))(v12, AssociatedTypeWitness, AssociatedConformanceWitness);
        v74 = objc_msgSend(v82, sel_data);
        if (v74)
        {
          v75 = v74;
          sub_1B7EF9BD8();
          v77 = v76;

          __asm { BR              X10 }
        }
        __break(1u);
        JUMPOUT(0x1B7852840);
      }
      swift_unknownObjectRetain_n();
      swift_unknownObjectRetain_n();
      v57 = sub_1B7EF9C2C();
      v58 = sub_1B7EF9D64();
      if (os_log_type_enabled(v57, v58))
      {
        v59 = swift_slowAlloc();
        v85 = (void *)swift_slowAlloc();
        v91[0] = v85;
        *(_DWORD *)v59 = 136446722;
        v81 = v58;
        v60 = sub_1B7EF9F38();
        sub_1B7850CC0(v60, v61, (uint64_t *)v91);
        sub_1B7EF9D94();
        swift_bridgeObjectRelease();
        *(_WORD *)(v59 + 12) = 2048;
        v14(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRelease();
        sub_1B7EF9D94();
        swift_unknownObjectRelease();
        *(_WORD *)(v59 + 22) = 2048;
        v62 = (void *)v14(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRelease();
        v90 = v62;
        sub_1B7EF9D94();
        swift_unknownObjectRelease();
        _os_log_impl(&dword_1B7802000, v57, v81, "[%{public}s] Choosing local state, it has a higher epoch (%lld vs %lld)", (uint8_t *)v59, 0x20u);
        swift_arrayDestroy();
        MEMORY[0x1BCCAD16C](v85, -1, -1);
        MEMORY[0x1BCCAD16C](v59, -1, -1);

      }
      else
      {

        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease_n();
      }
      v71 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 32))(AssociatedTypeWitness, AssociatedConformanceWitness);
      v72 = v71;
      *v83 = v71;
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      return 3;
    }
    else
    {
      v80 = (void (*)(uint64_t, uint64_t))v14;
      swift_unknownObjectRetain_n();
      swift_unknownObjectRetain_n();
      v16 = sub_1B7EF9C2C();
      v17 = sub_1B7EF9D64();
      if (os_log_type_enabled(v16, v17))
      {
        v18 = swift_slowAlloc();
        v84 = (void *)swift_slowAlloc();
        v91[0] = v84;
        *(_DWORD *)v18 = 136446722;
        v19 = sub_1B7EF9F38();
        sub_1B7850CC0(v19, v20, (uint64_t *)v91);
        sub_1B7EF9D94();
        swift_bridgeObjectRelease();
        *(_WORD *)(v18 + 12) = 2048;
        v80(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRelease();
        sub_1B7EF9D94();
        swift_unknownObjectRelease();
        *(_WORD *)(v18 + 22) = 2048;
        v21 = (void *)((uint64_t (*)(uint64_t, uint64_t))v80)(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRelease();
        v90 = v21;
        sub_1B7EF9D94();
        swift_unknownObjectRelease();
        _os_log_impl(&dword_1B7802000, v16, v17, "[%{public}s] Choosing cloud state, it has a higher epoch (%lld vs %lld)", (uint8_t *)v18, 0x20u);
        swift_arrayDestroy();
        MEMORY[0x1BCCAD16C](v84, -1, -1);
        MEMORY[0x1BCCAD16C](v18, -1, -1);

      }
      else
      {

        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease_n();
      }
      v63 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 32))(AssociatedTypeWitness, AssociatedConformanceWitness);
      v64 = v63;
      *v83 = v63;
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      return 2;
    }
  }
  else
  {
    swift_unknownObjectRetain_n();
    swift_unknownObjectRetain_n();
    v22 = sub_1B7EF9C2C();
    v23 = sub_1B7EF9D58();
    if (os_log_type_enabled(v22, v23))
    {
      v24 = swift_slowAlloc();
      v86 = (void *)swift_slowAlloc();
      v91[0] = v86;
      *(_DWORD *)v24 = 136446722;
      v25 = sub_1B7EF9F38();
      sub_1B7850CC0(v25, v26, (uint64_t *)v91);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v24 + 12) = 2080;
      sub_1B785287C();
      swift_unknownObjectRetain();
      v27 = sub_1B7EF9CC8();
      sub_1B7850CC0(v27, v28, (uint64_t *)v91);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      *(_WORD *)(v24 + 22) = 2080;
      swift_unknownObjectRetain();
      v29 = sub_1B7EF9CC8();
      v90 = (id)sub_1B7850CC0(v29, v30, (uint64_t *)v91);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v22, v23, "[%{public}s] Unexpected type for object, cloud: %s local: %s", (uint8_t *)v24, 0x20u);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v86, -1, -1);
      MEMORY[0x1BCCAD16C](v24, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
      swift_unknownObjectRelease_n();
    }

    v91[3] = (id)swift_getObjectType();
    v91[0] = a2;
    swift_unknownObjectRetain();
    v31 = sub_1B785025C(v91);
    v33 = v32;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v91);
    v35 = type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure(0, v9, v8, v34);
    MEMORY[0x1BCCAD100](&unk_1B7F39398, v35);
    v36 = (void *)swift_allocError();
    *v37 = v31;
    v37[1] = v33;
    swift_willThrow();
    v91[0] = v36;
    sub_1B7853A88();
    sub_1B7853ADC();
    swift_dynamicCast();
    v38 = v90;
    if (a4)
    {
      v39 = v90;
      *a4 = v90;
      v40 = v39;
    }
    swift_unknownObjectRetain_n();
    swift_unknownObjectRetain_n();
    v41 = v38;
    v42 = sub_1B7EF9C2C();
    v43 = sub_1B7EF9D58();
    if (os_log_type_enabled(v42, v43))
    {
      v44 = swift_slowAlloc();
      v87 = swift_slowAlloc();
      v89 = v87;
      *(_DWORD *)v44 = 136446978;
      v45 = sub_1B7EF9F38();
      sub_1B7850CC0(v45, v46, &v89);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v44 + 12) = 2080;
      v47 = objc_msgSend(v41, sel_localizedDescription);
      v48 = sub_1B7EF9CBC();
      v50 = v49;

      sub_1B7850CC0(v48, v50, &v89);
      sub_1B7EF9D94();

      swift_bridgeObjectRelease();
      *(_WORD *)(v44 + 22) = 2080;
      sub_1B785287C();
      swift_unknownObjectRetain();
      v51 = sub_1B7EF9CC8();
      sub_1B7850CC0(v51, v52, &v89);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      *(_WORD *)(v44 + 32) = 2080;
      swift_unknownObjectRetain();
      v53 = sub_1B7EF9CC8();
      sub_1B7850CC0(v53, v54, &v89);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v42, v43, "[%{public}s] Error when trying to update: %s local: %s cloud: %s", (uint8_t *)v44, 0x2Au);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v87, -1, -1);
      MEMORY[0x1BCCAD16C](v44, -1, -1);

    }
    else
    {
      swift_unknownObjectRelease_n();
      swift_unknownObjectRelease_n();

    }
    return 0;
  }
}

uint64_t __swift_destroy_boxed_opaque_existential_0(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 24) - 8);
  if ((*(_BYTE *)(v1 + 82) & 2) != 0)
    return swift_release();
  else
    return (*(uint64_t (**)(void))(v1 + 8))();
}

uint64_t type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for EpochBasedSyncStateUpdaterDelegate.Failure);
}

unint64_t sub_1B785287C()
{
  unint64_t result;

  result = qword_1EF1924E8;
  if (!qword_1EF1924E8)
  {
    result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF1924E8);
  }
  return result;
}

uint64_t sub_1B78528D0(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t AssociatedTypeWitness;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t AssociatedConformanceWitness;
  uint64_t v14;
  unint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  os_log_type_t type;
  uint64_t v34;
  uint64_t v35[4];
  uint64_t v36;

  v2 = v1;
  swift_getObjectType();
  v4 = *MEMORY[0x1E0DEEDD8] & *v1;
  v5 = *(_QWORD *)(v4 + 80);
  v6 = *(_QWORD *)(v4 + 88);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  v8 = swift_dynamicCastUnknownClass();
  swift_unknownObjectRetain_n();
  if (v8)
  {
    swift_unknownObjectRetain();
    v9 = sub_1B7EF9C2C();
    type = sub_1B7EF9D4C();
    if (os_log_type_enabled(v9, type))
    {
      v10 = swift_slowAlloc();
      v32 = swift_slowAlloc();
      v35[0] = v32;
      *(_DWORD *)v10 = 136446466;
      v11 = sub_1B7EF9F38();
      v36 = sub_1B7850CC0(v11, v12, v35);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v10 + 12) = 2080;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
      v14 = (*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56))(AssociatedTypeWitness, AssociatedConformanceWitness);
      v36 = sub_1B7850CC0(v14, v15, v35);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v9, type, "[%{public}s] Persisting cloud state locally: %s", (uint8_t *)v10, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v32, -1, -1);
      MEMORY[0x1BCCAD16C](v10, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v2) + 0x58) + 24))(v8, *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v2) + 0x50));
    return swift_unknownObjectRelease();
  }
  else
  {
    v16 = sub_1B7EF9C2C();
    v17 = sub_1B7EF9D58();
    if (os_log_type_enabled(v16, v17))
    {
      v34 = v5;
      v18 = swift_slowAlloc();
      v19 = swift_slowAlloc();
      v35[0] = v19;
      *(_DWORD *)v18 = 136446466;
      v20 = sub_1B7EF9F38();
      v36 = sub_1B7850CC0(v20, v21, v35);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v18 + 12) = 2080;
      v36 = a1;
      sub_1B785287C();
      swift_unknownObjectRetain();
      v22 = sub_1B7EF9CC8();
      v36 = sub_1B7850CC0(v22, v23, v35);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v16, v17, "[%{public}s] returned object is not the expected type: %s", (uint8_t *)v18, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v19, -1, -1);
      v24 = v18;
      v5 = v34;
      MEMORY[0x1BCCAD16C](v24, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    v35[3] = swift_getObjectType();
    v35[0] = a1;
    swift_unknownObjectRetain();
    v26 = sub_1B785025C(v35);
    v28 = v27;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v35);
    v30 = type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure(0, v5, v6, v29);
    MEMORY[0x1BCCAD100](&unk_1B7F39398, v30);
    swift_allocError();
    *v31 = v26;
    v31[1] = v28;
    return swift_willThrow();
  }
}

void sub_1B7852D5C(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v2;
  void *v4;
  void *v5;
  id v6;
  NSObject *v7;
  os_log_type_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t AssociatedConformanceWitness;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;

  swift_getObjectType();
  v4 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v1) + 0x58) + 32))(*(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v1) + 0x50), *(_QWORD *)((*MEMORY[0x1E0DEEDD8] & *v1) + 0x58));
  if (!v2)
  {
    v5 = v4;
    v6 = objc_retainAutorelease(v4);
    v7 = sub_1B7EF9C2C();
    v8 = sub_1B7EF9D64();
    if (os_log_type_enabled(v7, v8))
    {
      v19 = a1;
      v9 = swift_slowAlloc();
      v18 = swift_slowAlloc();
      v20 = v18;
      *(_DWORD *)v9 = 136446466;
      v10 = sub_1B7EF9F38();
      sub_1B7850CC0(v10, v11, &v20);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v9 + 12) = 2080;
      if (v5)
      {
        swift_getAssociatedTypeWitness();
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
        v13 = *(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56);
        v14 = swift_checkMetadataState();
        v15 = v13(v14, AssociatedConformanceWitness);
        v17 = v16;
      }
      else
      {
        v17 = 0xE300000000000000;
        v15 = 7104878;
      }
      sub_1B7850CC0(v15, v17, &v20);
      sub_1B7EF9D94();

      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v7, v8, "%{public}s Retrieved local state: %s", (uint8_t *)v9, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v18, -1, -1);
      MEMORY[0x1BCCAD16C](v9, -1, -1);

      a1 = v19;
    }
    else
    {

    }
    *a1 = v5;
  }
}

uint64_t sub_1B7852FF0(_QWORD *a1, void *a2, _QWORD *a3)
{
  _QWORD *v3;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t AssociatedTypeWitness;
  uint64_t ObjCClassFromMetadata;
  uint64_t v11;
  unsigned int v12;
  void *v13;
  id v14;
  void *v15;
  id v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t AssociatedConformanceWitness;
  uint64_t v23;
  unint64_t v24;
  id v25;
  void *v26;
  void *v27;
  id v28;
  id v30;
  id v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  id v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  id v49;
  uint64_t v50[5];

  v50[4] = *MEMORY[0x1E0C80C00];
  swift_getObjectType();
  v6 = (_QWORD *)(*MEMORY[0x1E0DEEDD8] & *v3);
  v8 = v6[10];
  v7 = v6[11];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  ObjCClassFromMetadata = swift_getObjCClassFromMetadata();
  v11 = *(int *)((char *)v3 + v6[16]);
  v49 = 0;
  v50[0] = 0;
  v12 = objc_msgSend(a2, sel_decodedObjectOfClass_version_decodedObject_error_, ObjCClassFromMetadata, v11, v50, &v49);
  v14 = v49;
  v13 = (void *)v50[0];
  if (!v12)
  {
    v25 = v49;
    swift_unknownObjectRetain();
    v26 = (void *)sub_1B7EF9BCC();

    swift_willThrow();
    swift_unknownObjectRelease();
    if (!a3)
    {
LABEL_8:

      return 0;
    }
LABEL_7:
    v27 = (void *)sub_1B7EF9BC0();
    v28 = v27;
    *a3 = v27;
    goto LABEL_8;
  }
  if (!v50[0])
  {
    v30 = v49;
    return 2;
  }
  v15 = (void *)swift_dynamicCastUnknownClass();
  swift_unknownObjectRetain_n();
  if (!v15)
  {
    v31 = v14;
    swift_unknownObjectRetain();
    v32 = sub_1B7EF9C2C();
    v33 = sub_1B7EF9D58();
    if (os_log_type_enabled(v32, (os_log_type_t)v33))
    {
      v34 = swift_slowAlloc();
      v35 = swift_slowAlloc();
      v50[0] = v35;
      *(_DWORD *)v34 = 136446466;
      v36 = sub_1B7EF9F38();
      v49 = (id)sub_1B7850CC0(v36, v37, v50);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v34 + 12) = 2080;
      v49 = v13;
      sub_1B785287C();
      swift_unknownObjectRetain();
      v38 = sub_1B7EF9CC8();
      v49 = (id)sub_1B7850CC0(v38, v39, v50);
      sub_1B7EF9D94();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v32, (os_log_type_t)v33, "[%{public}s] object is not of the expected type: %s", (uint8_t *)v34, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v35, -1, -1);
      MEMORY[0x1BCCAD16C](v34, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    v50[3] = swift_getObjectType();
    v50[0] = (uint64_t)v13;
    swift_unknownObjectRetain();
    v41 = sub_1B785025C(v50);
    v43 = v42;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v50);
    v45 = type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure(0, v8, v7, v44);
    MEMORY[0x1BCCAD100](&unk_1B7F39398, v45);
    v26 = (void *)swift_allocError();
    *v46 = v41;
    v46[1] = v43;
    swift_willThrow();
    swift_unknownObjectRelease_n();
    if (!a3)
      goto LABEL_8;
    goto LABEL_7;
  }
  swift_unknownObjectRetain_n();
  v16 = v14;
  v17 = sub_1B7EF9C2C();
  v18 = sub_1B7EF9D64();
  if (os_log_type_enabled(v17, v18))
  {
    v19 = swift_slowAlloc();
    v47 = swift_slowAlloc();
    v50[0] = v47;
    *(_DWORD *)v19 = 136446466;
    v20 = sub_1B7EF9F38();
    v49 = (id)sub_1B7850CC0(v20, v21, v50);
    sub_1B7EF9D94();
    swift_bridgeObjectRelease();
    *(_WORD *)(v19 + 12) = 2080;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
    v23 = (*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56))(AssociatedTypeWitness, AssociatedConformanceWitness);
    v49 = (id)sub_1B7850CC0(v23, v24, v50);
    sub_1B7EF9D94();
    swift_unknownObjectRelease_n();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1B7802000, v17, v18, "[%{public}s] Retrieved cloud data: %s", (uint8_t *)v19, 0x16u);
    swift_arrayDestroy();
    MEMORY[0x1BCCAD16C](v47, -1, -1);
    MEMORY[0x1BCCAD16C](v19, -1, -1);
  }
  else
  {
    swift_unknownObjectRelease_n();
  }

  v40 = v15;
  *a1 = v15;
  swift_unknownObjectRelease_n();
  return 1;
}

void sub_1B7853538()
{
  _swift_stdlib_reportUnimplementedInitializer();
  __break(1u);
}

uint64_t type metadata accessor for EpochBasedSyncStateUpdaterDelegate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for EpochBasedSyncStateUpdaterDelegate);
}

uint64_t dispatch thunk of LocalStorageProvider.setModel(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of LocalStorageProvider.fetchLocallyPersistedData()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.epoch.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.epoch.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.epoch.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.makeCopy()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.merge(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.purgeCoherentMetadataAndIncrementEpoch()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.logDescription.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t sub_1B78535FC()
{
  uint64_t result;
  unint64_t v1;
  unint64_t v2;

  result = sub_1B7EF9C38();
  if (v1 <= 0x3F)
  {
    result = swift_checkMetadataState();
    if (v2 <= 0x3F)
    {
      result = swift_initClassMetadata2();
      if (!result)
        return 0;
    }
  }
  return result;
}

uint64_t method lookup function for EpochBasedSyncStateUpdaterDelegate()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.__allocating_init(logger:key:supportedSyncVersionRange:domain:store:maxDataSizeInBytes:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 144))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.shouldUpdate(withMergedState:cloudState:localState:profile:transaction:error:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xA0))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.update(_:withMergeState:profile:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xA8))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.persistCloudState(_:profile:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xB0))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.fetchLocalState(_:profile:transaction:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xB8))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.fetchCloudState(_:codableSyncState:profile:error:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xC0))();
}

_QWORD *__swift_memcpy8_4(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t sub_1B785378C(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 8))
    return (*(_DWORD *)a1 + 1);
  else
    return 0;
}

uint64_t sub_1B78537AC(uint64_t result, int a2, int a3)
{
  char v3;

  if (a2)
  {
    *(_QWORD *)result = (a2 - 1);
    if (!a3)
      return result;
    v3 = 1;
  }
  else
  {
    if (!a3)
      return result;
    v3 = 0;
  }
  *(_BYTE *)(result + 8) = v3;
  return result;
}

void type metadata accessor for HDSyncVersionRange(uint64_t a1)
{
  sub_1B78539E0(a1, &qword_1EF192690, (uint64_t)&unk_1E6CE7330, MEMORY[0x1E0DEEC78]);
}

void type metadata accessor for os_unfair_lock_s(uint64_t a1)
{
  sub_1B78539E0(a1, qword_1EF192698, (uint64_t)&unk_1E6CE7358, MEMORY[0x1E0DEEC78]);
}

uint64_t sub_1B785380C()
{
  return swift_allocateGenericValueMetadata();
}

_QWORD *sub_1B7853814(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t sub_1B7853840()
{
  return swift_bridgeObjectRelease();
}

_QWORD *sub_1B7853848(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

_QWORD *sub_1B7853894(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t sub_1B78538C4(uint64_t a1, unsigned int a2)
{
  unint64_t v3;

  if (!a2)
    return 0;
  if (a2 >= 0x7FFFFFFF && *(_BYTE *)(a1 + 16))
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3 >= 0xFFFFFFFF)
    LODWORD(v3) = -1;
  if ((v3 + 1) >= 2)
    return v3;
  else
    return 0;
}

uint64_t sub_1B7853914(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 8) = 0;
    *(_DWORD *)result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 16) = 0;
    if (a2)
      *(_QWORD *)(result + 8) = a2;
  }
  return result;
}

uint64_t sub_1B7853968(uint64_t a1)
{
  unint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1 >= 0xFFFFFFFF)
    LODWORD(v1) = -1;
  return (v1 + 1);
}

_QWORD *sub_1B7853984(_QWORD *result, int a2)
{
  if (a2 < 0)
  {
    *result = a2 ^ 0x80000000;
    result[1] = 0;
  }
  else if (a2)
  {
    result[1] = (a2 - 1);
  }
  return result;
}

uint64_t sub_1B78539A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

void sub_1B78539E0(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t (*a4)(_QWORD, uint64_t))
{
  unint64_t v5;
  uint64_t v6;

  if (!*a2)
  {
    v5 = a4(0, a3);
    if (!v6)
      atomic_store(v5, a2);
  }
}

_QWORD *__swift_project_boxed_opaque_existential_0(_QWORD *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(_QWORD *)(a2 - 8) + 80) & 0x20000) != 0)
    return (_QWORD *)(*result
                    + ((*(_DWORD *)(*(_QWORD *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(_QWORD *)(a2 - 8) + 80)));
  return result;
}

unint64_t sub_1B7853A4C()
{
  unint64_t result;

  result = qword_1EF192728;
  if (!qword_1EF192728)
  {
    result = swift_getExistentialMetatypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF192728);
  }
  return result;
}

unint64_t sub_1B7853A88()
{
  unint64_t result;

  result = qword_1EF192730;
  if (!qword_1EF192730)
  {
    result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF192730);
  }
  return result;
}

unint64_t sub_1B7853ADC()
{
  unint64_t result;

  result = qword_1EF192738;
  if (!qword_1EF192738)
  {
    objc_opt_self();
    result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF192738);
  }
  return result;
}

uint64_t sub_1B7853B18(uint64_t a1, unint64_t a2)
{
  uint64_t result;

  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2)
      return result;
    swift_release();
  }
  return swift_release();
}

uint64_t __swift_instantiateGenericMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD v6[3];

  v6[0] = a2;
  v6[1] = a3;
  v6[2] = a4;
  return MEMORY[0x1BCCAD0C4](a1, v6, a5);
}

uint64_t sub_1B7853BBC()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;

  v1 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker;
  if (*(_QWORD *)((char *)v0 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker))
  {
    v2 = *(_QWORD *)((char *)v0 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker);
  }
  else
  {
    v2 = (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xB8))();
    *(_QWORD *)((char *)v0 + v1) = v2;
    swift_unknownObjectRetain();
    swift_unknownObjectRelease();
  }
  swift_unknownObjectRetain();
  return v2;
}

uint64_t sub_1B7853C68(uint64_t a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker) = a1;
  return swift_unknownObjectRelease();
}

uint64_t (*sub_1B7853C80(uint64_t *a1))(_QWORD *a1)
{
  uint64_t v1;

  a1[1] = v1;
  *a1 = sub_1B7853BBC();
  return sub_1B7853CB4;
}

uint64_t sub_1B7853CB4(_QWORD *a1)
{
  *(_QWORD *)(a1[1] + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker) = *a1;
  return swift_unknownObjectRelease();
}

char *HDSwimTracker.__allocating_init(profile:)(void *a1)
{
  objc_class *v1;
  id v3;

  v3 = objc_allocWithZone(v1);
  return HDSwimTracker.init(profile:)(a1);
}

char *HDSwimTracker.init(profile:)(void *a1)
{
  char *v1;
  uint64_t v3;
  void *v4;
  id v5;
  char *v6;
  id v7;
  void *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  id v15;
  char *v16;
  void *v17;
  void *v18;
  char *v19;
  id v20;
  objc_super v22;

  *(_QWORD *)&v1[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker] = 0;
  v3 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers;
  v4 = (void *)*MEMORY[0x1E0CB5380];
  v5 = objc_allocWithZone(MEMORY[0x1E0CB6CA8]);
  v6 = v1;
  v7 = v4;
  v8 = (void *)sub_1B7EF9CB0();
  v9 = objc_msgSend(v5, sel_initWithName_loggingCategory_, v8, v7);

  *(_QWORD *)&v1[v3] = v9;
  *(_QWORD *)&v6[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData] = 0;
  v10 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_startLock;
  sub_1B7853EC4(0, &qword_1EF192880);
  v11 = swift_allocObject();
  *(_DWORD *)(v11 + 20) = 0;
  *(_BYTE *)(v11 + 16) = 0;
  *(_QWORD *)&v6[v10] = v11;
  v12 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_generalLock;
  sub_1B7853EC4(0, &qword_1EF192890);
  v13 = swift_allocObject();
  *(_DWORD *)(v13 + 16) = 0;
  *(_QWORD *)&v6[v12] = v13;
  v14 = objc_allocWithZone((Class)type metadata accessor for HDSwimmingDataCollector());
  v15 = a1;
  *(_QWORD *)&v6[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_dataCollector] = HDSwimmingDataCollector.init(profile:)(v15);

  v22.receiver = v6;
  v22.super_class = (Class)type metadata accessor for HDSwimTracker();
  v16 = (char *)objc_msgSendSuper2(&v22, sel_init);
  v17 = *(void **)&v16[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_dataCollector];
  v18 = *(void **)&v16[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers];
  v19 = v16;
  v20 = v17;
  objc_msgSend(v18, sel_registerObserver_, v20);

  return v19;
}

void sub_1B7853EC4(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  uint64_t v4;

  if (!*a2)
  {
    type metadata accessor for os_unfair_lock_s(255);
    v3 = sub_1B7EF9DF4();
    if (!v4)
      atomic_store(v3, a2);
  }
}

id sub_1B7853F44()
{
  id v0;
  objc_class *v1;
  char *v2;
  id v3;
  id v4;
  objc_super v6;

  v0 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E0CA56E8]), sel_init);
  v1 = (objc_class *)type metadata accessor for HDCMSwimTracker();
  v2 = (char *)objc_allocWithZone(v1);
  *(_QWORD *)&v2[OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker] = v0;
  v6.receiver = v2;
  v6.super_class = v1;
  v3 = v0;
  v4 = objc_msgSendSuper2(&v6, sel_init);

  return v4;
}

void sub_1B7854074()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t ObjectType;
  uint64_t v3;
  uint64_t v4;
  os_log_type_t v5;
  uint8_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  NSObject *v11;
  os_log_type_t v12;
  uint8_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  id v17;
  void *v18;
  id v19;
  objc_class *v20;
  char *v21;
  id v22;
  uint64_t v23;
  void *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  id v30;
  NSObject *oslog;
  uint64_t aBlock[6];
  objc_super v33;
  uint64_t v34;

  v1 = v0;
  ObjectType = swift_getObjectType();
  v3 = *(_QWORD *)(v0 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_startLock);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 20));
  if ((*(_BYTE *)(v3 + 16) & 1) != 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 20));
    if (qword_1EF192480 != -1)
      swift_once();
    v4 = sub_1B7EF9C38();
    __swift_project_value_buffer(v4, (uint64_t)qword_1EF199E70);
    oslog = sub_1B7EF9C2C();
    v5 = sub_1B7EF9D64();
    if (os_log_type_enabled(oslog, v5))
    {
      v6 = (uint8_t *)swift_slowAlloc();
      v7 = swift_slowAlloc();
      aBlock[0] = v7;
      *(_DWORD *)v6 = 136446210;
      v8 = sub_1B7EF9F38();
      v34 = sub_1B7850CC0(v8, v9, aBlock);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, oslog, v5, "%{public}s Start called twice. Ignoring...", v6, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v7, -1, -1);
      MEMORY[0x1BCCAD16C](v6, -1, -1);

    }
    else
    {

    }
  }
  else
  {
    *(_BYTE *)(v3 + 16) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 20));
    if (qword_1EF192480 != -1)
      swift_once();
    v10 = sub_1B7EF9C38();
    __swift_project_value_buffer(v10, (uint64_t)qword_1EF199E70);
    v11 = sub_1B7EF9C2C();
    v12 = sub_1B7EF9D64();
    if (os_log_type_enabled(v11, v12))
    {
      v13 = (uint8_t *)swift_slowAlloc();
      v14 = swift_slowAlloc();
      aBlock[0] = v14;
      *(_DWORD *)v13 = 136446210;
      v15 = sub_1B7EF9F38();
      v34 = sub_1B7850CC0(v15, v16, aBlock);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v11, v12, "%{public}s Starting monitoring for swim updates", v13, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v14, -1, -1);
      MEMORY[0x1BCCAD16C](v13, -1, -1);
    }

    v17 = objc_allocWithZone(MEMORY[0x1E0CA56E0]);
    v18 = (void *)sub_1B7EF9C08();
    v19 = objc_msgSend(v17, sel_initWithSessionId_, v18);

    v20 = (objc_class *)type metadata accessor for HDCMSwimData();
    v21 = (char *)objc_allocWithZone(v20);
    *(_QWORD *)&v21[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data] = v19;
    v33.receiver = v21;
    v33.super_class = v20;
    v22 = objc_msgSendSuper2(&v33, sel_init);
    v23 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData;
    v24 = *(void **)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData);
    *(_QWORD *)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData) = v22;

    v25 = (void *)sub_1B7853BBC();
    v26 = *(void **)(v1 + v23);
    v27 = swift_allocObject();
    swift_unknownObjectWeakInit();
    v28 = swift_allocObject();
    *(_QWORD *)(v28 + 16) = v27;
    *(_QWORD *)(v28 + 24) = ObjectType;
    aBlock[4] = (uint64_t)sub_1B7855768;
    aBlock[5] = v28;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 1107296256;
    aBlock[2] = (uint64_t)sub_1B7854704;
    aBlock[3] = (uint64_t)&block_descriptor;
    v29 = _Block_copy(aBlock);
    v30 = v26;
    swift_release();
    objc_msgSend(v25, sel_startUpdatesFromRecord_handler_, v30, v29);
    _Block_release(v29);
    swift_unknownObjectRelease();

  }
}

void sub_1B78544EC(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  os_log_type_t v9;
  uint8_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  NSObject *oslog;
  uint64_t v15[4];

  if (a1)
  {
    if (a1 >> 62)
    {
      swift_bridgeObjectRetain();
      v7 = sub_1B7EF9E6C();
      swift_bridgeObjectRelease();
      if (v7 >= 1)
      {
LABEL_4:
        swift_beginAccess();
        v5 = MEMORY[0x1BCCAD1CC](a3 + 16);
        if (v5)
        {
          v6 = (void *)v5;
          sub_1B7854BBC(a1);

        }
        return;
      }
    }
    else if (*(uint64_t *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10) >= 1)
    {
      goto LABEL_4;
    }
  }
  if (qword_1EF192480 != -1)
    swift_once();
  v8 = sub_1B7EF9C38();
  __swift_project_value_buffer(v8, (uint64_t)qword_1EF199E70);
  oslog = sub_1B7EF9C2C();
  v9 = sub_1B7EF9D58();
  if (os_log_type_enabled(oslog, v9))
  {
    v10 = (uint8_t *)swift_slowAlloc();
    v11 = swift_slowAlloc();
    v15[0] = v11;
    *(_DWORD *)v10 = 136446210;
    v12 = sub_1B7EF9F38();
    v15[3] = sub_1B7850CC0(v12, v13, v15);
    sub_1B7EF9D94();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1B7802000, oslog, v9, "%{public}s Received nil or empty swim data from core motion", v10, 0xCu);
    swift_arrayDestroy();
    MEMORY[0x1BCCAD16C](v11, -1, -1);
    MEMORY[0x1BCCAD16C](v10, -1, -1);

  }
  else
  {

  }
}

uint64_t sub_1B7854704(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  void (*v5)(uint64_t, void *);
  id v6;

  v4 = a2;
  v5 = *(void (**)(uint64_t, void *))(a1 + 32);
  if (a2)
  {
    type metadata accessor for HDCMSwimData();
    v4 = sub_1B7EF9D10();
  }
  swift_retain();
  v6 = a3;
  v5(v4, a3);
  swift_release();

  return swift_bridgeObjectRelease();
}

void sub_1B785481C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  os_log_type_t v4;
  uint8_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  os_unfair_lock_s *v9;
  uint64_t v10;

  v1 = v0;
  swift_getObjectType();
  if (qword_1EF192480 != -1)
    swift_once();
  v2 = sub_1B7EF9C38();
  __swift_project_value_buffer(v2, (uint64_t)qword_1EF199E70);
  v3 = sub_1B7EF9C2C();
  v4 = sub_1B7EF9D64();
  if (os_log_type_enabled(v3, v4))
  {
    v5 = (uint8_t *)swift_slowAlloc();
    v6 = swift_slowAlloc();
    v10 = v6;
    *(_DWORD *)v5 = 136446210;
    v7 = sub_1B7EF9F38();
    sub_1B7850CC0(v7, v8, &v10);
    sub_1B7EF9D94();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1B7802000, v3, v4, "%{public}s Stopping swim updates", v5, 0xCu);
    swift_arrayDestroy();
    MEMORY[0x1BCCAD16C](v6, -1, -1);
    MEMORY[0x1BCCAD16C](v5, -1, -1);
  }

  v9 = (os_unfair_lock_s *)(*(_QWORD *)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_generalLock) + 16);
  os_unfair_lock_lock(v9);
  sub_1B78549C8(v1);
  os_unfair_lock_unlock(v9);
}

uint64_t sub_1B78549C8(uint64_t a1)
{
  void *v2;
  id v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t i;
  uint64_t v8;

  objc_msgSend((id)sub_1B7853BBC(), sel_stopUpdates);
  swift_unknownObjectRelease();
  v2 = *(void **)(a1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers);
  v3 = objc_msgSend(v2, sel_allObservers);
  sub_1B7855C5C();
  v4 = sub_1B7EF9D10();

  if (!(v4 >> 62))
  {
    v5 = *(_QWORD *)((v4 & 0xFFFFFFFFFFFFF8) + 0x10);
    result = swift_bridgeObjectRetain();
    if (v5)
      goto LABEL_3;
    return swift_bridgeObjectRelease_n();
  }
  swift_bridgeObjectRetain();
  result = sub_1B7EF9E6C();
  v5 = result;
  if (!result)
    return swift_bridgeObjectRelease_n();
LABEL_3:
  if (v5 >= 1)
  {
    for (i = 0; i != v5; ++i)
    {
      if ((v4 & 0xC000000000000001) != 0)
      {
        v8 = MEMORY[0x1BCCAAC7C](i, v4);
      }
      else
      {
        v8 = *(_QWORD *)(v4 + 8 * i + 32);
        swift_unknownObjectRetain();
      }
      objc_msgSend(v2, sel_unregisterObserver_, v8);
      swift_unknownObjectRelease();
    }
    return swift_bridgeObjectRelease_n();
  }
  __break(1u);
  return result;
}

id sub_1B7854B4C(uint64_t a1)
{
  uint64_t v1;

  return sub_1B78557E0(a1, v1);
}

void sub_1B7854BBC(uint64_t a1)
{
  uint64_t v1;
  uint64_t ObjectType;
  void *v4;
  id v5;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  void *v9;
  id v10;
  uint64_t v11;
  os_log_type_t v12;
  uint8_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  NSObject *oslog;
  uint64_t aBlock[7];

  ObjectType = swift_getObjectType();
  v4 = *(void **)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData);
  if (v4)
  {
    v5 = v4;
    v6 = (void *)sub_1B7853BBC();
    v7 = swift_allocObject();
    swift_unknownObjectWeakInit();
    v8 = (_QWORD *)swift_allocObject();
    v8[2] = v5;
    v8[3] = v7;
    v8[4] = a1;
    v8[5] = ObjectType;
    aBlock[4] = (uint64_t)sub_1B7855968;
    aBlock[5] = (uint64_t)v8;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 1107296256;
    aBlock[2] = (uint64_t)sub_1B7854704;
    aBlock[3] = (uint64_t)&block_descriptor_10;
    v9 = _Block_copy(aBlock);
    v10 = v5;
    swift_bridgeObjectRetain();
    swift_release();
    objc_msgSend(v6, sel_querySwimUpdatesFromRecord_handler_, v10, v9);
    _Block_release(v9);
    swift_unknownObjectRelease();

  }
  else
  {
    if (qword_1EF192480 != -1)
      swift_once();
    v11 = sub_1B7EF9C38();
    __swift_project_value_buffer(v11, (uint64_t)qword_1EF199E70);
    oslog = sub_1B7EF9C2C();
    v12 = sub_1B7EF9D58();
    if (os_log_type_enabled(oslog, v12))
    {
      v13 = (uint8_t *)swift_slowAlloc();
      v14 = swift_slowAlloc();
      aBlock[0] = v14;
      *(_DWORD *)v13 = 136446210;
      v15 = sub_1B7EF9F38();
      aBlock[6] = sub_1B7850CC0(v15, v16, aBlock);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, oslog, v12, "%{public}s Reference is nil", v13, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v14, -1, -1);
      MEMORY[0x1BCCAD16C](v13, -1, -1);

    }
    else
    {

    }
  }
}

void sub_1B7854E4C(unint64_t a1, uint64_t a2, char *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  id v12;
  void *v13;
  uint64_t v14;
  void *v15;
  id v16;
  uint64_t v17;
  void *v18;
  char *v19;
  uint64_t v20;
  void *v21;
  id v22;
  uint64_t v23;
  void *v24;
  char *v25;
  char *v26;
  unint64_t v27;
  char v28;
  char v29;
  void *v30;
  void *v31;
  uint64_t v32;
  id v33;
  uint64_t v34;
  id v35;
  NSObject *v36;
  os_log_type_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  id v41;
  char *v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  os_log_type_t v46;
  uint8_t *v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t aBlock;
  uint64_t v54;
  uint64_t (*v55)(uint64_t);
  void *v56;
  void (*v57)(void *);
  uint64_t v58;

  v8 = a4 + 16;
  if (!objc_msgSend(*(id *)&a3[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data], sel_recordId))
  {
    swift_beginAccess();
    v9 = MEMORY[0x1BCCAD1CC](v8);
    if (v9)
    {
      v10 = (char *)v9;
      if (a5 >> 62)
      {
        swift_bridgeObjectRetain();
        v11 = sub_1B7EF9E6C();
        if (v11)
          goto LABEL_5;
      }
      else
      {
        v11 = *(_QWORD *)((a5 & 0xFFFFFFFFFFFFF8) + 0x10);
        swift_bridgeObjectRetain();
        if (v11)
        {
LABEL_5:
          if ((a5 & 0xC000000000000001) != 0)
          {
            v12 = (id)MEMORY[0x1BCCAAC7C](0, a5);
          }
          else
          {
            if (!*(_QWORD *)((a5 & 0xFFFFFFFFFFFFF8) + 0x10))
            {
              __break(1u);
              return;
            }
            v12 = *(id *)(a5 + 32);
          }
          v11 = (uint64_t)v12;
        }
      }
      swift_bridgeObjectRelease();
      v13 = *(void **)&v10[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData];
      *(_QWORD *)&v10[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData] = v11;

    }
  }
  swift_beginAccess();
  v14 = MEMORY[0x1BCCAD1CC](v8);
  if (v14)
  {
    v15 = (void *)v14;
    v16 = *(id *)(v14 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers);

    v17 = swift_allocObject();
    *(_QWORD *)(v17 + 16) = a5;
    *(_QWORD *)(v17 + 24) = a3;
    v57 = sub_1B7855978;
    v58 = v17;
    aBlock = MEMORY[0x1E0C809B0];
    v54 = 1107296256;
    v55 = sub_1B7855518;
    v56 = &block_descriptor_16;
    v18 = _Block_copy(&aBlock);
    swift_bridgeObjectRetain();
    v19 = a3;
    swift_release();
    objc_msgSend(v16, sel_notifyObservers_, v18);
    _Block_release(v18);

  }
  if (!a1)
    goto LABEL_30;
  if (!(a1 >> 62))
  {
    if (*(uint64_t *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10) >= 1)
      goto LABEL_15;
LABEL_30:
    if (qword_1EF192480 != -1)
      swift_once();
    v45 = sub_1B7EF9C38();
    __swift_project_value_buffer(v45, (uint64_t)qword_1EF199E70);
    v43 = sub_1B7EF9C2C();
    v46 = sub_1B7EF9D58();
    if (os_log_type_enabled(v43, v46))
    {
      v47 = (uint8_t *)swift_slowAlloc();
      v48 = swift_slowAlloc();
      aBlock = v48;
      *(_DWORD *)v47 = 136446210;
      v49 = sub_1B7EF9F38();
      sub_1B7850CC0(v49, v50, &aBlock);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v43, v46, "%{public}s Queried swim data is nil or empty", v47, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v48, -1, -1);
      MEMORY[0x1BCCAD16C](v47, -1, -1);
    }
LABEL_34:

    return;
  }
  swift_bridgeObjectRetain();
  v44 = sub_1B7EF9E6C();
  swift_bridgeObjectRelease();
  if (v44 < 1)
    goto LABEL_30;
LABEL_15:
  swift_beginAccess();
  v20 = MEMORY[0x1BCCAD1CC](v8);
  if (v20)
  {
    v21 = (void *)v20;
    v22 = *(id *)(v20 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers);

    v23 = swift_allocObject();
    *(_QWORD *)(v23 + 16) = a1;
    *(_QWORD *)(v23 + 24) = a3;
    v57 = sub_1B78559C8;
    v58 = v23;
    aBlock = MEMORY[0x1E0C809B0];
    v54 = 1107296256;
    v55 = sub_1B7855518;
    v56 = &block_descriptor_22;
    v24 = _Block_copy(&aBlock);
    v25 = a3;
    swift_bridgeObjectRetain();
    swift_release();
    objc_msgSend(v22, sel_notifyObservers_, v24);
    _Block_release(v24);

  }
  v26 = a3;
  v27 = sub_1B78559E8(a1, v26);
  v29 = v28;

  if ((v29 & 1) == 0)
  {
    v30 = (void *)sub_1B7855788(v27, a1);
    v31 = v30;
    if (v30)
    {
      v32 = qword_1EF192480;
      v33 = v30;
      if (v32 != -1)
        swift_once();
      v34 = sub_1B7EF9C38();
      __swift_project_value_buffer(v34, (uint64_t)qword_1EF199E70);
      v35 = v33;
      v36 = sub_1B7EF9C2C();
      v37 = sub_1B7EF9D64();
      if (os_log_type_enabled(v36, v37))
      {
        v38 = swift_slowAlloc();
        v51 = (_QWORD *)swift_slowAlloc();
        v52 = swift_slowAlloc();
        aBlock = v52;
        *(_DWORD *)v38 = 136446466;
        v39 = sub_1B7EF9F38();
        sub_1B7850CC0(v39, v40, &aBlock);
        sub_1B7EF9D94();
        swift_bridgeObjectRelease();
        *(_WORD *)(v38 + 12) = 2112;
        v41 = v35;
        sub_1B7EF9D94();
        *v51 = v31;

        _os_log_impl(&dword_1B7802000, v36, v37, "%{public}s Setting swim reference to %@", (uint8_t *)v38, 0x16u);
        sub_1B7855BCC();
        swift_arrayDestroy();
        MEMORY[0x1BCCAD16C](v51, -1, -1);
        swift_arrayDestroy();
        MEMORY[0x1BCCAD16C](v52, -1, -1);
        MEMORY[0x1BCCAD16C](v38, -1, -1);

      }
      else
      {

      }
      swift_beginAccess();
      v42 = (char *)MEMORY[0x1BCCAD1CC](v8);
      if (!v42)
      {

        return;
      }
      v43 = *(NSObject **)&v42[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData];
      *(_QWORD *)&v42[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData] = v31;

      goto LABEL_34;
    }
  }
}

uint64_t sub_1B7855518(uint64_t a1)
{
  void (*v1)(uint64_t);
  uint64_t v2;

  v1 = *(void (**)(uint64_t))(a1 + 32);
  swift_retain();
  v2 = swift_unknownObjectRetain();
  v1(v2);
  swift_release();
  return swift_unknownObjectRelease();
}

void sub_1B7855560(void *a1, uint64_t a2, uint64_t a3, SEL *a4)
{
  id v7;

  type metadata accessor for HDCMSwimData();
  v7 = (id)sub_1B7EF9D04();
  objc_msgSend(a1, *a4, v7, a3);

}

id HDSwimTracker.__allocating_init()()
{
  objc_class *v0;

  return objc_msgSend(objc_allocWithZone(v0), sel_init);
}

void HDSwimTracker.init()()
{
  _swift_stdlib_reportUnimplementedInitializer();
  __break(1u);
}

id HDSwimTracker.__deallocating_deinit()
{
  void *v0;
  objc_super v2;

  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDSwimTracker();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t type metadata accessor for HDSwimTracker()
{
  return objc_opt_self();
}

uint64_t __swift_project_value_buffer(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(*(_QWORD *)(a1 - 8) + 82) & 2) != 0)
    return *(_QWORD *)a2;
  return a2;
}

uint64_t sub_1B7855720()
{
  swift_unknownObjectWeakDestroy();
  return swift_deallocObject();
}

uint64_t sub_1B7855744()
{
  swift_release();
  return swift_deallocObject();
}

void sub_1B7855768(unint64_t a1, uint64_t a2)
{
  uint64_t v2;

  sub_1B78544EC(a1, a2, *(_QWORD *)(v2 + 16));
}

uint64_t block_copy_helper(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper()
{
  return swift_release();
}

unint64_t sub_1B7855788(unint64_t result, uint64_t a2)
{
  if ((a2 & 0xC000000000000001) != 0)
    return MEMORY[0x1BCCAAC7C]();
  if ((result & 0x8000000000000000) != 0)
  {
    __break(1u);
  }
  else if (*(_QWORD *)((a2 & 0xFFFFFFFFFFFFF8) + 0x10) > result)
  {
    return (unint64_t)*(id *)(a2 + 8 * result + 32);
  }
  __break(1u);
  return result;
}

id sub_1B78557E0(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a2 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers), sel_registerObserver_, a1);
}

uint64_t sub_1B78557FC@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result;

  result = sub_1B7853BBC();
  *a1 = result;
  return result;
}

uint64_t sub_1B7855824(_QWORD *a1, _QWORD *a2)
{
  *(_QWORD *)(*a2 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker) = *a1;
  swift_unknownObjectRetain();
  return swift_unknownObjectRelease();
}

uint64_t method lookup function for HDSwimTracker()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of HDSwimTracker.tracker.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x80))();
}

uint64_t dispatch thunk of HDSwimTracker.tracker.setter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x88))();
}

uint64_t dispatch thunk of HDSwimTracker.tracker.modify()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x90))();
}

uint64_t dispatch thunk of HDSwimTracker.__allocating_init(profile:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 176))();
}

uint64_t dispatch thunk of HDSwimTracker.makeSwimTracker()()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xB8))();
}

uint64_t dispatch thunk of HDSwimTracker.start(with:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xC0))();
}

uint64_t dispatch thunk of HDSwimTracker.stop()()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xC8))();
}

uint64_t dispatch thunk of HDSwimTracker.registerObserver(_:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xD0))();
}

uint64_t sub_1B7855934()
{
  uint64_t v0;

  swift_release();
  swift_bridgeObjectRelease();
  return swift_deallocObject();
}

void sub_1B7855968(unint64_t a1, uint64_t a2)
{
  uint64_t v2;

  sub_1B7854E4C(a1, a2, *(char **)(v2 + 16), *(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 32));
}

void sub_1B7855978(void *a1)
{
  uint64_t v1;

  sub_1B7855560(a1, *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24), (SEL *)&selRef_onDemandSwimmingDataDidUpdate_reference_);
}

uint64_t objectdestroy_12Tm()
{
  uint64_t v0;

  swift_bridgeObjectRelease();

  return swift_deallocObject();
}

void sub_1B78559C8(void *a1)
{
  uint64_t v1;

  sub_1B7855560(a1, *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24), (SEL *)&selRef_historicalSwimmingDataDidUpdate_reference_);
}

unint64_t sub_1B78559E8(unint64_t a1, char *a2)
{
  unint64_t v4;
  char *v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  double v11;
  double v12;
  double v13;
  id v14;
  id v15;

  if (a1 >> 62)
    goto LABEL_21;
  v4 = *(_QWORD *)((a1 & 0xFFFFFFFFFFFFF8) + 0x10);
  while (v4)
  {
    a2 = *(char **)&a2[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data];
    while (!__OFSUB__(v4--, 1))
    {
      if ((a1 & 0xC000000000000001) != 0)
      {
        v6 = (char *)MEMORY[0x1BCCAAC7C](v4, a1);
      }
      else
      {
        if ((v4 & 0x8000000000000000) != 0)
          goto LABEL_19;
        if (v4 >= *(_QWORD *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10))
          goto LABEL_20;
        v6 = (char *)*(id *)(a1 + 32 + 8 * v4);
      }
      v7 = v6;
      v8 = *(void **)&v6[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data];
      v9 = objc_msgSend(v8, sel_lapCount);
      if ((uint64_t)objc_msgSend(a2, sel_lapCount) < (uint64_t)v9
        || (v10 = objc_msgSend(v8, sel_segment), (uint64_t)objc_msgSend(a2, sel_segment) < (uint64_t)v10)
        || (objc_msgSend(v8, sel_distance), v12 = v11, objc_msgSend(a2, sel_distance), v13 < v12))
      {

        return v4;
      }
      v14 = objc_msgSend(v8, sel_strokeCount);
      v15 = objc_msgSend(a2, sel_strokeCount);

      if ((uint64_t)v15 < (uint64_t)v14 || !v4)
        return v4;
    }
    __break(1u);
LABEL_19:
    __break(1u);
LABEL_20:
    __break(1u);
LABEL_21:
    swift_bridgeObjectRetain();
    v4 = sub_1B7EF9E6C();
    swift_bridgeObjectRelease();
  }
  return v4;
}

void sub_1B7855BCC()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1EF192A30)
  {
    sub_1B7855C20();
    v0 = sub_1B7EF9D88();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1EF192A30);
  }
}

unint64_t sub_1B7855C20()
{
  unint64_t result;

  result = qword_1EF1928C8;
  if (!qword_1EF1928C8)
  {
    objc_opt_self();
    result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF1928C8);
  }
  return result;
}

unint64_t sub_1B7855C5C()
{
  unint64_t result;

  result = qword_1EF1928D0;
  if (!qword_1EF1928D0)
  {
    result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF1928D0);
  }
  return result;
}

id sub_1B7855CC8()
{
  uint64_t v0;
  uint64_t v1;
  void *v2;
  id v3;
  id v4;
  id v5;
  void *v6;
  id v7;

  v1 = OBJC_IVAR___HDDatabaseAccessibilityAssertionStoreServer____lazy_storage___queue;
  v2 = *(void **)(v0 + OBJC_IVAR___HDDatabaseAccessibilityAssertionStoreServer____lazy_storage___queue);
  if (v2)
  {
    v3 = *(id *)(v0 + OBJC_IVAR___HDDatabaseAccessibilityAssertionStoreServer____lazy_storage___queue);
  }
  else
  {
    type metadata accessor for DatabaseAccessibilityAssertionStoreServer();
    v4 = objc_msgSend((id)swift_getObjCClassFromMetadata(), sel_description);
    if (!v4)
    {
      sub_1B7EF9CBC();
      v4 = (id)sub_1B7EF9CB0();
      swift_bridgeObjectRelease();
    }
    v5 = (id)HKCreateSerialDispatchQueue();

    v6 = *(void **)(v0 + v1);
    *(_QWORD *)(v0 + v1) = v5;
    v3 = v5;

    v2 = 0;
  }
  v7 = v2;
  return v3;
}

id DatabaseAccessibilityAssertionStoreServer.__deallocating_deinit()
{
  void *v0;
  objc_super v2;

  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for DatabaseAccessibilityAssertionStoreServer();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t type metadata accessor for DatabaseAccessibilityAssertionStoreServer()
{
  return objc_opt_self();
}

void DatabaseAccessibilityAssertionStoreServer.remote_invalidateDatabaseAccessibilityAssertion(_:)(void *a1)
{
  void *v1;
  id v2;
  id v3;
  id v4;
  id v5;
  void *v6;
  id v7;

  if (a1)
  {
    v7 = a1;
    v2 = objc_msgSend(v1, sel_client);
    v3 = objc_msgSend(v2, sel_assertionForHKDatabaseAccessibilityAssertion_, v7);

    if (v3)
    {
      v4 = v3;
      objc_msgSend(v4, sel_invalidate);
      v5 = objc_msgSend(v1, sel_client);
      objc_msgSend(v5, sel_removeAssertionMappingForAssertion_, v4);

      v6 = v5;
    }
    else
    {
      v6 = v7;
    }

  }
}

uint64_t DatabaseAccessibilityAssertionStoreServer.remote_requestDatabaseAccessibilityAssertion(forOwnerIdentifier:completion:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  id v15;
  _QWORD *v16;
  void *v17;
  id v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD aBlock[6];

  v9 = sub_1B7EF9C50();
  v22 = *(_QWORD *)(v9 - 8);
  MEMORY[0x1E0C80A78]();
  v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = sub_1B7EF9C68();
  v12 = *(_QWORD *)(v21 - 8);
  MEMORY[0x1E0C80A78]();
  v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = sub_1B7855CC8();
  v16 = (_QWORD *)swift_allocObject();
  v16[2] = v4;
  v16[3] = a1;
  v16[4] = a2;
  v16[5] = a3;
  v16[6] = a4;
  aBlock[4] = sub_1B78563B0;
  aBlock[5] = v16;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_1B7856634;
  aBlock[3] = &block_descriptor_0;
  v17 = _Block_copy(aBlock);
  v18 = v4;
  swift_bridgeObjectRetain();
  swift_retain();
  sub_1B7EF9C5C();
  v23 = MEMORY[0x1E0DEE9D8];
  sub_1B78566CC(&qword_1ED5520E0, (uint64_t (*)(uint64_t))MEMORY[0x1E0DEF4F8], MEMORY[0x1E0DEF510]);
  sub_1B7856678();
  sub_1B78566CC((unint64_t *)&unk_1ED5520F0, (uint64_t (*)(uint64_t))sub_1B7856678, MEMORY[0x1E0DEAF38]);
  sub_1B7EF9DB8();
  MEMORY[0x1BCCAAC10](0, v14, v11, v17);
  _Block_release(v17);

  (*(void (**)(char *, uint64_t))(v22 + 8))(v11, v9);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v21);
  return swift_release();
}

void sub_1B78562E8(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(id, _QWORD))
{
  id v5;

  v5 = sub_1B78563C0();
  a4(v5, 0);

}

uint64_t sub_1B785637C()
{
  uint64_t v0;

  swift_bridgeObjectRelease();
  swift_release();
  return swift_deallocObject();
}

void sub_1B78563B0()
{
  uint64_t v0;

  sub_1B78562E8(*(_QWORD *)(v0 + 16), *(_QWORD *)(v0 + 24), *(_QWORD *)(v0 + 32), *(void (**)(id, _QWORD))(v0 + 40));
}

id sub_1B78563C0()
{
  void *v0;
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  id v18;
  id v19;
  _QWORD v21[2];
  id v22[2];

  v2 = v0;
  v22[1] = *(id *)MEMORY[0x1E0C80C00];
  v3 = sub_1B7EF9C20();
  v4 = *(_QWORD *)(v3 - 8);
  MEMORY[0x1E0C80A78]();
  v6 = (char *)v21 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = objc_msgSend(v2, sel_profile);
  if (!v7)
    return 0;
  v8 = v7;
  v21[1] = v1;
  v9 = objc_msgSend(v7, sel_database);

  v10 = (void *)sub_1B7EF9CB0();
  v22[0] = 0;
  v11 = objc_msgSend(v9, sel_takeAccessibilityAssertionWithOwnerIdentifier_shouldPerformTransaction_timeout_error_, v10, 0, v22, 600.0);

  if (v11)
  {
    v12 = v22[0];
    v13 = v11;
    v14 = objc_msgSend(v13, sel_UUID);
    sub_1B7EF9C14();

    sub_1B7EF9BFC();
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    v15 = objc_allocWithZone(MEMORY[0x1E0CB6590]);
    swift_bridgeObjectRetain();
    v16 = (void *)sub_1B7EF9CB0();
    swift_bridgeObjectRelease();
    v17 = (void *)sub_1B7EF9CB0();
    swift_bridgeObjectRelease();
    v18 = objc_msgSend(v15, sel_initWithOwnerIdentifier_uuidString_, v16, v17);

    v19 = objc_msgSend(v2, sel_client);
    objc_msgSend(v19, sel_addAssertionMapping_, v13);

  }
  else
  {
    v18 = v22[0];
    sub_1B7EF9BCC();

    swift_willThrow();
  }
  return v18;
}

uint64_t sub_1B7856634(uint64_t a1)
{
  void (*v1)(uint64_t);
  uint64_t v2;

  v1 = *(void (**)(uint64_t))(a1 + 32);
  v2 = swift_retain();
  v1(v2);
  return swift_release();
}

uint64_t block_copy_helper_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_0()
{
  return swift_release();
}

void sub_1B7856678()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1ED5520E8)
  {
    sub_1B7EF9C50();
    v0 = sub_1B7EF9D40();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1ED5520E8);
  }
}

uint64_t sub_1B78566CC(unint64_t *a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  uint64_t result;
  uint64_t v6;

  result = *a1;
  if (!result)
  {
    v6 = a2(255);
    result = MEMORY[0x1BCCAD100](a3, v6);
    atomic_store(result, a1);
  }
  return result;
}

uint64_t method lookup function for DatabaseAccessibilityAssertionStoreServer()
{
  return swift_lookUpClassMethod();
}

void sub_1B78567B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  id v6;

  if (a2)
    v5 = sub_1B7EF9BC0();
  else
    v5 = 0;
  v6 = (id)v5;
  (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, a1);

}

uint64_t sub_1B7856808()
{
  uint64_t v0;

  _Block_release(*(const void **)(v0 + 16));
  return swift_deallocObject();
}

void sub_1B785682C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  sub_1B78567B0(a1, a2, *(_QWORD *)(v2 + 16));
}

uint64_t HDSwimmingDataCollector.__allocating_init(profile:)(void *a1)
{
  objc_class *v1;
  id v3;

  v3 = objc_allocWithZone(v1);
  return HDSwimmingDataCollector.init(profile:)(a1);
}

uint64_t HDSwimmingDataCollector.init(profile:)(void *a1)
{
  char *v1;
  uint64_t v3;
  void *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  id v15;
  void *v16;
  void *v17;
  id v18;
  id v19;
  id v20;
  char *v21;
  char *v22;
  void *v23;
  char *v24;
  objc_super v25;
  uint64_t v26;

  swift_unknownObjectWeakInit();
  v3 = OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_aggregators;
  v4 = (void *)objc_opt_self();
  v5 = v1;
  *(_QWORD *)&v1[v3] = objc_msgSend(v4, sel_mapTableWithKeyOptions_valueOptions_, 0, 5);
  v6 = OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_quantityTypes;
  sub_1B7856B40();
  v7 = swift_allocObject();
  *(_OWORD *)(v7 + 16) = xmmword_1B7F39480;
  sub_1B7858824(0, &qword_1EF192970);
  *(_QWORD *)(v7 + 32) = MEMORY[0x1BCCAAC04]((id)*MEMORY[0x1E0CB5C60]);
  *(_QWORD *)(v7 + 40) = MEMORY[0x1BCCAAC04]((id)*MEMORY[0x1E0CB5D80]);
  v26 = v7;
  sub_1B7EF9D1C();
  *(_QWORD *)&v5[v6] = v7;

  v25.receiver = v5;
  v25.super_class = (Class)type metadata accessor for HDSwimmingDataCollector();
  v8 = (char *)objc_msgSendSuper2(&v25, sel_init);
  v23 = a1;
  v24 = &v8[OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_profile];
  swift_unknownObjectWeakAssign();
  v9 = *(_QWORD *)&v8[OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_quantityTypes];
  if (!(v9 >> 62))
  {
    v10 = *(_QWORD *)((v9 & 0xFFFFFFFFFFFFF8) + 0x10);
    v11 = v8;
    result = swift_bridgeObjectRetain();
    if (v10)
      goto LABEL_3;
LABEL_16:

    swift_bridgeObjectRelease();
    return (uint64_t)v8;
  }
  v22 = v8;
  swift_bridgeObjectRetain();
  result = sub_1B7EF9E6C();
  v10 = result;
  if (!result)
    goto LABEL_16;
LABEL_3:
  if (v10 >= 1)
  {
    v13 = 0;
    v14 = OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_aggregators;
    do
    {
      if ((v9 & 0xC000000000000001) != 0)
        v15 = (id)MEMORY[0x1BCCAAC7C](v13, v9);
      else
        v15 = *(id *)(v9 + 8 * v13 + 32);
      v16 = v15;
      v17 = (void *)MEMORY[0x1BCCAD1CC](v24);
      v18 = v17;
      if (v17)
      {
        v19 = objc_msgSend(v17, sel_dataCollectionManager);

        if (v19)
        {
          v18 = objc_msgSend(v19, sel_aggregatorForType_, v16);

        }
        else
        {
          v18 = 0;
        }
      }
      objc_msgSend(*(id *)&v8[v14], sel_setObject_forKey_, v18, v16);
      v20 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E0CB6578]), sel_init);
      if (v18)
      {
        v21 = v8;
        objc_msgSend(v18, sel_registerDataCollector_state_, v21, v20);

      }
      ++v13;

    }
    while (v10 != v13);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

void sub_1B7856B40()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1ED552128)
  {
    v0 = sub_1B7EF9EC0();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1ED552128);
  }
}

uint64_t type metadata accessor for HDSwimmingDataCollector()
{
  return objc_opt_self();
}

void sub_1B7856BBC(unint64_t a1, void *a2)
{
  id v2;
  uint64_t v5;
  id v6;
  unint64_t v7;
  char v8;
  id v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;
  char v15;
  uint64_t v16;
  void *v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  id v25;
  void *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  NSObject *v30;
  os_log_type_t v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  id v37;
  void *v38;
  id v39;
  id v40;
  void *v41;
  id v42;
  uint64_t v43;
  id v44;
  id v45;
  id v46;
  uint64_t v47;
  uint64_t v48[3];
  unint64_t v49;
  unint64_t v50;

  swift_getObjectType();
  if (a1 >> 62)
    goto LABEL_54;
  v5 = *(_QWORD *)((a1 & 0xFFFFFFFFFFFFF8) + 0x10);
  if (v5)
  {
    v49 = MEMORY[0x1E0DEE9D8];
    v50 = MEMORY[0x1E0DEE9D8];
    swift_bridgeObjectRetain();
    v6 = a2;
    while (1)
    {
      v7 = 0;
      v8 = 0;
      if ((a1 & 0xC000000000000001) != 0)
      {
LABEL_5:
        v9 = (id)MEMORY[0x1BCCAAC7C](v7, a1);
        goto LABEL_8;
      }
      while (1)
      {
        if (v7 >= *(_QWORD *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10))
          goto LABEL_53;
        v9 = *(id *)(a1 + 8 * v7 + 32);
LABEL_8:
        v10 = v9;
        if (__OFADD__(v7, 1))
          break;
        if ((v8 & 1) != 0)

        v2 = v10;
        v11 = sub_1B785744C((char *)a2, (uint64_t)v2);
        if (v11)
        {
          v12 = v11;
          MEMORY[0x1BCCAAB8C]();
          if (*(_QWORD *)((v50 & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(_QWORD *)((v50 & 0xFFFFFFFFFFFFFF8) + 0x18) >> 1)
            sub_1B7EF9D28();
          sub_1B7EF9D34();
          sub_1B7EF9D1C();

        }
        v13 = sub_1B7857BC0((uint64_t)a2, (uint64_t)v2);
        if (v13)
        {
          v14 = v13;
          MEMORY[0x1BCCAAB8C]();
          if (*(_QWORD *)((v49 & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(_QWORD *)((v49 & 0xFFFFFFFFFFFFFF8) + 0x18) >> 1)
            sub_1B7EF9D28();
          sub_1B7EF9D34();
          sub_1B7EF9D1C();

        }
        if (v7 + 1 == v5)
        {
          v15 = 0;
LABEL_23:
          swift_bridgeObjectRelease();
          v16 = v47 + OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_profile;
          v17 = (void *)MEMORY[0x1BCCAD1CC](v47 + OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_profile);
          if (v17
            && (v18 = v17,
                v19 = objc_msgSend(v17, sel_dataCollectionManager),
                v18,
                v19))
          {
            sub_1B7858824(0, &qword_1EF192970);
            v20 = (void *)MEMORY[0x1BCCAAC04]((id)*MEMORY[0x1E0CB5D80]);
            v46 = objc_msgSend(v19, sel_aggregatorForType_, v20);

          }
          else
          {
            v46 = 0;
          }
          v21 = (void *)MEMORY[0x1BCCAD1CC](v16);
          if (v21
            && (v22 = v21,
                v23 = objc_msgSend(v21, sel_dataCollectionManager),
                v22,
                v23))
          {
            sub_1B7858824(0, &qword_1EF192970);
            v24 = (void *)MEMORY[0x1BCCAAC04]((id)*MEMORY[0x1E0CB5C60]);
            v25 = objc_msgSend(v23, sel_aggregatorForType_, v24);

          }
          else
          {
            v25 = 0;
          }
          v26 = v46;
          if (qword_1EF192480 != -1)
            swift_once();
          v27 = sub_1B7EF9C38();
          __swift_project_value_buffer(v27, (uint64_t)qword_1EF199E70);
          v29 = v49;
          v28 = v50;
          swift_bridgeObjectRetain_n();
          swift_bridgeObjectRetain_n();
          v30 = sub_1B7EF9C2C();
          v31 = sub_1B7EF9D64();
          if (os_log_type_enabled(v30, v31))
          {
            v32 = v15;
            v33 = swift_slowAlloc();
            v34 = swift_slowAlloc();
            v48[0] = v34;
            *(_DWORD *)v33 = 136446722;
            v35 = sub_1B7EF9F38();
            sub_1B7850CC0(v35, v36, v48);
            sub_1B7EF9D94();
            swift_bridgeObjectRelease();
            *(_WORD *)(v33 + 12) = 2048;
            if (v28 >> 62)
            {
              swift_bridgeObjectRetain();
              sub_1B7EF9E6C();
              swift_bridgeObjectRelease();
            }
            swift_bridgeObjectRelease();
            sub_1B7EF9D94();
            swift_bridgeObjectRelease();
            *(_WORD *)(v33 + 22) = 2048;
            if (v29 >> 62)
            {
              swift_bridgeObjectRetain();
              sub_1B7EF9E6C();
              swift_bridgeObjectRelease();
            }
            swift_bridgeObjectRelease();
            sub_1B7EF9D94();
            swift_bridgeObjectRelease();
            _os_log_impl(&dword_1B7802000, v30, v31, "%{public}s Creating %ld stroke datums and %ld distance datums", (uint8_t *)v33, 0x20u);
            swift_arrayDestroy();
            MEMORY[0x1BCCAD16C](v34, -1, -1);
            MEMORY[0x1BCCAD16C](v33, -1, -1);

            v15 = v32;
            v26 = v46;
          }
          else
          {

            swift_bridgeObjectRelease_n();
            swift_bridgeObjectRelease_n();
          }
          if (v26)
          {
            swift_beginAccess();
            if (v50 >> 62)
            {
              sub_1B7858540();
              v44 = v26;
              swift_bridgeObjectRetain();
              sub_1B7EF9E60();
              swift_bridgeObjectRelease();
            }
            else
            {
              v37 = v26;
              swift_bridgeObjectRetain();
              sub_1B7EF9ED8();
              sub_1B7858540();
            }
            swift_bridgeObjectRelease();
            sub_1B7858540();
            v38 = (void *)sub_1B7EF9D04();
            swift_bridgeObjectRelease();
            v39 = objc_msgSend((id)objc_opt_self(), sel_localDevice);
            objc_msgSend(v26, sel_dataCollector_didCollectSensorData_device_, v47, v38, v39);

            if (v25)
            {
LABEL_44:
              swift_beginAccess();
              if (v49 >> 62)
              {
                sub_1B7858540();
                v45 = v25;
                swift_bridgeObjectRetain();
                sub_1B7EF9E60();
                swift_bridgeObjectRelease();
              }
              else
              {
                v40 = v25;
                swift_bridgeObjectRetain();
                sub_1B7EF9ED8();
                sub_1B7858540();
              }
              swift_bridgeObjectRelease();
              sub_1B7858540();
              v41 = (void *)sub_1B7EF9D04();
              swift_bridgeObjectRelease();
              v42 = objc_msgSend((id)objc_opt_self(), sel_localDevice);
              objc_msgSend(v25, sel_dataCollector_didCollectSensorData_device_, v47, v41, v42);

              if ((v15 & 1) != 0)
                return;
LABEL_50:

              return;
            }
          }
          else
          {
            swift_bridgeObjectRelease();
            if (v25)
              goto LABEL_44;
          }

          swift_bridgeObjectRelease();
          if ((v15 & 1) != 0)
            return;
          goto LABEL_50;
        }
        ++v7;
        v8 = 1;
        a2 = v2;
        if ((a1 & 0xC000000000000001) != 0)
          goto LABEL_5;
      }
      __break(1u);
LABEL_53:
      __break(1u);
LABEL_54:
      swift_bridgeObjectRetain();
      v43 = sub_1B7EF9E6C();
      swift_bridgeObjectRelease();
      if (v43 <= 0)
        break;
      v49 = MEMORY[0x1E0DEE9D8];
      v50 = MEMORY[0x1E0DEE9D8];
      swift_bridgeObjectRetain();
      v2 = a2;
      v5 = sub_1B7EF9E6C();
      if (!v5)
      {
        v15 = 1;
        goto LABEL_23;
      }
    }
  }
}

id sub_1B785744C(char *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  _BYTE *v15;
  _BYTE *v16;
  BOOL v17;
  uint64_t v18;
  id v19;
  id v20;
  id v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  void (*v33)(char *, uint64_t);
  char *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  os_log_type_t v40;
  uint8_t *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  id v45;
  id v46;
  char *v47;
  uint64_t inited;
  uint64_t v49;
  id v50;
  id v51;
  void *v52;
  char *v53;
  void *v54;
  void *v55;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t ObjectType;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  id v66;
  char *v67;
  uint64_t v68;
  uint64_t v69[2];

  ObjectType = swift_getObjectType();
  v4 = sub_1B7EF9C20();
  v5 = *(_QWORD *)(v4 - 8);
  ((void (*)(void))MEMORY[0x1E0C80A78])();
  v65 = (char *)&v57 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1B7EF9BF0();
  v7 = ((uint64_t (*)(void))MEMORY[0x1E0C80A78])();
  v9 = (char *)&v57 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v7);
  v64 = sub_1B7EF9BB4();
  v10 = *(_QWORD *)(v64 - 8);
  v11 = MEMORY[0x1E0C80A78](v64);
  v13 = (char *)&v57 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v11);
  v67 = (char *)&v57 - v14;
  v63 = a2;
  v66 = *(id *)(a2 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data);
  v15 = objc_msgSend(v66, sel_strokeCount);
  v16 = objc_msgSend(*(id *)&a1[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data], sel_strokeCount);
  v17 = __OFSUB__(v15, v16);
  v18 = v15 - v16;
  if (v17)
  {
    __break(1u);
    goto LABEL_15;
  }
  if (v18 >= 1)
  {
    v60 = v5;
    v61 = v4;
    v19 = v66;
    v20 = objc_msgSend(v66, sel_startDate);
    sub_1B7EF9BE4();

    v21 = objc_msgSend(v19, sel_endDate);
    sub_1B7EF9BE4();

    a1 = v67;
    sub_1B7EF9BA8();
    v22 = objc_msgSend((id)objc_opt_self(), sel_countUnit);
    v9 = (char *)objc_msgSend((id)objc_opt_self(), sel_quantityWithUnit_doubleValue_, v22, (double)v18);

    if (qword_1EF192480 == -1)
    {
LABEL_4:
      v23 = sub_1B7EF9C38();
      __swift_project_value_buffer(v23, (uint64_t)qword_1EF199E70);
      v24 = v64;
      (*(void (**)(char *, char *, uint64_t))(v10 + 16))(v13, a1, v64);
      v25 = v9;
      v26 = sub_1B7EF9C2C();
      v27 = sub_1B7EF9D64();
      if (os_log_type_enabled(v26, v27))
      {
        v28 = swift_slowAlloc();
        v58 = (_QWORD *)swift_slowAlloc();
        v59 = swift_slowAlloc();
        v69[0] = v59;
        *(_DWORD *)v28 = 136446722;
        v29 = sub_1B7EF9F38();
        v68 = sub_1B7850CC0(v29, v30, v69);
        sub_1B7EF9D94();
        swift_bridgeObjectRelease();
        *(_WORD *)(v28 + 12) = 2080;
        sub_1B78587DC();
        v31 = sub_1B7EF9EB4();
        v68 = sub_1B7850CC0(v31, v32, v69);
        sub_1B7EF9D94();
        swift_bridgeObjectRelease();
        v33 = *(void (**)(char *, uint64_t))(v10 + 8);
        v33(v13, v24);
        *(_WORD *)(v28 + 22) = 2112;
        v68 = (uint64_t)v25;
        v34 = v25;
        sub_1B7EF9D94();
        v35 = v58;
        *v58 = v25;

        v36 = v24;
        _os_log_impl(&dword_1B7802000, v26, v27, "%{public}s Creating stroke datum with date interval %s and quantity %@", (uint8_t *)v28, 0x20u);
        sub_1B7855BCC();
        swift_arrayDestroy();
        MEMORY[0x1BCCAD16C](v35, -1, -1);
        v37 = v59;
        swift_arrayDestroy();
        MEMORY[0x1BCCAD16C](v37, -1, -1);
        MEMORY[0x1BCCAD16C](v28, -1, -1);

      }
      else
      {
        v33 = *(void (**)(char *, uint64_t))(v10 + 8);
        v33(v13, v24);

        v36 = v24;
      }
      v46 = objc_msgSend(v66, sel_sourceId);
      v47 = v65;
      sub_1B7EF9C14();

      sub_1B7858720();
      inited = swift_initStackObject();
      *(_OWORD *)(inited + 16) = xmmword_1B7F39490;
      *(_QWORD *)(inited + 32) = sub_1B7EF9CBC();
      *(_QWORD *)(inited + 40) = v49;
      v50 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E0CB37E8]), sel_initWithInteger_, sub_1B7858BCC());
      *(_QWORD *)(inited + 72) = sub_1B7858824(0, &qword_1EF192A20);
      *(_QWORD *)(inited + 48) = v50;
      sub_1B78596A0(inited);
      v51 = objc_allocWithZone((Class)HDQuantityDatum);
      v52 = (void *)sub_1B7EF9C08();
      v53 = v67;
      v54 = (void *)sub_1B7EF9B9C();
      v55 = (void *)sub_1B7EF9CA4();
      swift_bridgeObjectRelease();
      v45 = objc_msgSend(v51, sel_initWithIdentifier_dateInterval_quantity_metadata_resumeContextProvider_, v52, v54, v25, v55, 0);

      (*(void (**)(char *, uint64_t))(v60 + 8))(v47, v61);
      v33(v53, v36);
      return v45;
    }
LABEL_15:
    swift_once();
    goto LABEL_4;
  }
  if (qword_1EF192480 != -1)
    swift_once();
  v38 = sub_1B7EF9C38();
  __swift_project_value_buffer(v38, (uint64_t)qword_1EF199E70);
  v39 = sub_1B7EF9C2C();
  v40 = sub_1B7EF9D64();
  if (os_log_type_enabled(v39, v40))
  {
    v41 = (uint8_t *)swift_slowAlloc();
    v42 = swift_slowAlloc();
    v69[0] = v42;
    *(_DWORD *)v41 = 136446210;
    v43 = sub_1B7EF9F38();
    v68 = sub_1B7850CC0(v43, v44, v69);
    sub_1B7EF9D94();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1B7802000, v39, v40, "%{public}s Stroke difference between current and prior swim objects is not greater than zero.", v41, 0xCu);
    swift_arrayDestroy();
    MEMORY[0x1BCCAD16C](v42, -1, -1);
    MEMORY[0x1BCCAD16C](v41, -1, -1);
  }

  return 0;
}

id sub_1B7857BC0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  void *v14;
  double v15;
  double v16;
  double v17;
  double v18;
  id v19;
  id v20;
  id v21;
  id v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(char *, char *, uint64_t);
  char *v27;
  uint64_t v28;
  id v29;
  NSObject *v30;
  os_log_type_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  void (*v37)(char *, uint64_t);
  id v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;
  os_log_type_t v44;
  uint8_t *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  id v49;
  id v50;
  char *v51;
  uint64_t inited;
  uint64_t v53;
  id v54;
  id v55;
  void *v56;
  char *v57;
  void *v58;
  void *v59;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t ObjectType;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73[2];

  ObjectType = swift_getObjectType();
  v4 = sub_1B7EF9C20();
  v5 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](v4);
  v71 = (char *)&v61 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = sub_1B7EF9BF0();
  v8 = MEMORY[0x1E0C80A78](v7);
  MEMORY[0x1E0C80A78](v8);
  v70 = sub_1B7EF9BB4();
  v67 = *(_QWORD *)(v70 - 8);
  v9 = MEMORY[0x1E0C80A78](v70);
  v11 = (char *)&v61 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v61 - v12;
  v69 = a2;
  v14 = *(void **)(a2 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data);
  objc_msgSend(v14, sel_distance);
  v16 = v15;
  objc_msgSend(*(id *)(a1 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_distance);
  v18 = v16 - v17;
  if (v18 <= 2.22044605e-16)
  {
    if (qword_1EF192480 != -1)
      swift_once();
    v42 = sub_1B7EF9C38();
    __swift_project_value_buffer(v42, (uint64_t)qword_1EF199E70);
    v43 = sub_1B7EF9C2C();
    v44 = sub_1B7EF9D64();
    if (os_log_type_enabled(v43, v44))
    {
      v45 = (uint8_t *)swift_slowAlloc();
      v46 = swift_slowAlloc();
      v73[0] = v46;
      *(_DWORD *)v45 = 136446210;
      v47 = sub_1B7EF9F38();
      v72 = sub_1B7850CC0(v47, v48, v73);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1B7802000, v43, v44, "%{public}s Distance difference between current and prior swim objects is too small", v45, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v46, -1, -1);
      MEMORY[0x1BCCAD16C](v45, -1, -1);
    }

    return 0;
  }
  else
  {
    v65 = v5;
    v66 = v4;
    v19 = objc_msgSend(v14, sel_startDate);
    sub_1B7EF9BE4();

    v20 = objc_msgSend(v14, sel_endDate);
    sub_1B7EF9BE4();

    sub_1B7EF9BA8();
    v21 = objc_msgSend((id)objc_opt_self(), sel_meterUnit);
    v22 = objc_msgSend((id)objc_opt_self(), sel_quantityWithUnit_doubleValue_, v21, v18);

    v23 = v14;
    if (qword_1EF192480 != -1)
      swift_once();
    v24 = sub_1B7EF9C38();
    __swift_project_value_buffer(v24, (uint64_t)qword_1EF199E70);
    v25 = v67;
    v26 = *(void (**)(char *, char *, uint64_t))(v67 + 16);
    v64 = v13;
    v27 = v13;
    v28 = v70;
    v26(v11, v27, v70);
    v29 = v22;
    v30 = sub_1B7EF9C2C();
    v31 = sub_1B7EF9D64();
    if (os_log_type_enabled(v30, v31))
    {
      v32 = swift_slowAlloc();
      v62 = (_QWORD *)swift_slowAlloc();
      v63 = swift_slowAlloc();
      v73[0] = v63;
      *(_DWORD *)v32 = 136446722;
      v33 = sub_1B7EF9F38();
      v72 = sub_1B7850CC0(v33, v34, v73);
      ObjectType = (uint64_t)v23;
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      *(_WORD *)(v32 + 12) = 2080;
      sub_1B78587DC();
      v35 = sub_1B7EF9EB4();
      v72 = sub_1B7850CC0(v35, v36, v73);
      sub_1B7EF9D94();
      swift_bridgeObjectRelease();
      v37 = *(void (**)(char *, uint64_t))(v25 + 8);
      v37(v11, v28);
      *(_WORD *)(v32 + 22) = 2112;
      v72 = (uint64_t)v29;
      v38 = v29;
      v23 = (void *)ObjectType;
      sub_1B7EF9D94();
      v39 = v62;
      *v62 = v29;

      v40 = v28;
      _os_log_impl(&dword_1B7802000, v30, v31, "%{public}s Creating distance datum with date interval %s and quantity %@", (uint8_t *)v32, 0x20u);
      sub_1B7855BCC();
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v39, -1, -1);
      v41 = v63;
      swift_arrayDestroy();
      MEMORY[0x1BCCAD16C](v41, -1, -1);
      MEMORY[0x1BCCAD16C](v32, -1, -1);

    }
    else
    {
      v37 = *(void (**)(char *, uint64_t))(v25 + 8);
      v37(v11, v28);

      v40 = v28;
    }
    v50 = objc_msgSend(v23, sel_sourceId);
    v51 = v71;
    sub_1B7EF9C14();

    sub_1B7858720();
    inited = swift_initStackObject();
    *(_OWORD *)(inited + 16) = xmmword_1B7F39490;
    *(_QWORD *)(inited + 32) = sub_1B7EF9CBC();
    *(_QWORD *)(inited + 40) = v53;
    v54 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E0CB37E8]), sel_initWithInteger_, sub_1B7858BCC());
    *(_QWORD *)(inited + 72) = sub_1B7858824(0, &qword_1EF192A20);
    *(_QWORD *)(inited + 48) = v54;
    sub_1B78596A0(inited);
    v55 = objc_allocWithZone((Class)HDQuantityDatum);
    v56 = (void *)sub_1B7EF9C08();
    v57 = v64;
    v58 = (void *)sub_1B7EF9B9C();
    v59 = (void *)sub_1B7EF9CA4();
    swift_bridgeObjectRelease();
    v49 = objc_msgSend(v55, sel_initWithIdentifier_dateInterval_quantity_metadata_resumeContextProvider_, v56, v58, v29, v59, 0);

    (*(void (**)(char *, uint64_t))(v65 + 8))(v51, v66);
    v37(v57, v40);
  }
  return v49;
}

uint64_t sub_1B785833C()
{
  return sub_1B7858824(0, &qword_1EF192980);
}

id sub_1B785838C()
{
  return objc_msgSend((id)objc_opt_self(), sel__localDeviceSource);
}

id HDSwimmingDataCollector.__allocating_init()()
{
  objc_class *v0;

  return objc_msgSend(objc_allocWithZone(v0), sel_init);
}

void HDSwimmingDataCollector.init()()
{
  _swift_stdlib_reportUnimplementedInitializer();
  __break(1u);
}

id HDSwimmingDataCollector.__deallocating_deinit()
{
  void *v0;
  objc_super v2;

  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDSwimmingDataCollector();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

unint64_t sub_1B7858540()
{
  unint64_t result;

  result = qword_1EF192978;
  if (!qword_1EF192978)
  {
    result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF192978);
  }
  return result;
}

uint64_t sub_1B7858594()
{
  void *v0;
  id v1;

  v1 = objc_msgSend(v0, sel_description);
  sub_1B7EF9CBC();

  sub_1B7EF9CE0();
  swift_bridgeObjectRelease();
  sub_1B7EF9CE0();
  sub_1B7EF9E48();
  return 0;
}

uint64_t method lookup function for HDSwimmingDataCollector()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.__allocating_init(profile:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 152))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.onDemandSwimmingDataDidUpdate(_:reference:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xA8))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.historicalSwimmingDataDidUpdate(_:reference:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xB0))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.beginCollection(for:lastPersistedSensorDatum:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xC8))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.dataAggregator(_:wantsCollectionWith:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xD0))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.sensorDatumClass(for:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xD8))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.source(for:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xE0))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.identifier(for:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xE8))();
}

void sub_1B7858720()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1EF192A10)
  {
    sub_1B7858774();
    v0 = sub_1B7EF9EC0();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1EF192A10);
  }
}

void sub_1B7858774()
{
  unint64_t TupleTypeMetadata2;
  uint64_t v1;

  if (!qword_1EF192A18)
  {
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1)
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1EF192A18);
  }
}

unint64_t sub_1B78587DC()
{
  unint64_t result;
  uint64_t v1;

  result = qword_1EF192A28;
  if (!qword_1EF192A28)
  {
    v1 = sub_1B7EF9BB4();
    result = MEMORY[0x1BCCAD100](MEMORY[0x1E0CAE608], v1);
    atomic_store(result, (unint64_t *)&qword_1EF192A28);
  }
  return result;
}

uint64_t sub_1B7858824(uint64_t a1, unint64_t *a2)
{
  uint64_t result;

  result = *a2;
  if (!*a2)
  {
    objc_opt_self();
    result = swift_getObjCClassMetadata();
    atomic_store(result, a2);
  }
  return result;
}

uint64_t sub_1B7858860()
{
  uint64_t v0;
  id v1;

  v0 = sub_1B7EF9C38();
  __swift_allocate_value_buffer(v0, qword_1EF199E70);
  __swift_project_value_buffer(v0, (uint64_t)qword_1EF199E70);
  _HKInitializeLogging();
  v1 = (id)*MEMORY[0x1E0CB52A8];
  return sub_1B7EF9C44();
}

void sub_1B78588F4()
{
  sub_1B7858A7C((SEL *)&selRef_startDate, (void (*)(void))MEMORY[0x1E0CB07E8]);
}

void sub_1B785892C()
{
  sub_1B7858A7C((SEL *)&selRef_endDate, (void (*)(void))MEMORY[0x1E0CB07E8]);
}

id sub_1B7858958()
{
  uint64_t v0;

  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_recordId);
}

id sub_1B7858994(char *a1, uint64_t a2, uint64_t (*a3)(_QWORD), SEL *a4, void (*a5)(void), uint64_t (*a6)(void))
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  id v16;
  void *v17;
  uint64_t v19;

  v10 = a3(0);
  v11 = *(_QWORD *)(v10 - 8);
  MEMORY[0x1E0C80A78](v10);
  v13 = (char *)&v19 - v12;
  v14 = *(void **)&a1[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data];
  v15 = a1;
  v16 = objc_msgSend(v14, *a4);
  a5();

  v17 = (void *)a6();
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v10);
  return v17;
}

void sub_1B7858A68()
{
  sub_1B7858A7C((SEL *)&selRef_sourceId, (void (*)(void))MEMORY[0x1E0CB0958]);
}

void sub_1B7858A7C(SEL *a1, void (*a2)(void))
{
  uint64_t v2;
  id v4;

  v4 = objc_msgSend(*(id *)(v2 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), *a1);
  a2();

}

id sub_1B7858AF4()
{
  uint64_t v0;

  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_lapCount);
}

id sub_1B7858B24()
{
  uint64_t v0;

  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_segment);
}

id sub_1B7858B54()
{
  uint64_t v0;

  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_distance);
}

id sub_1B7858B84()
{
  uint64_t v0;

  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_strokeCount);
}

uint64_t sub_1B7858BCC()
{
  uint64_t v0;
  char *v1;

  v1 = (char *)objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_strokeType);
  if ((unint64_t)(v1 - 1) > 5)
    return 0;
  else
    return qword_1B7F39510[(_QWORD)(v1 - 1)];
}

id HDCMSwimData.__allocating_init()()
{
  objc_class *v0;

  return objc_msgSend(objc_allocWithZone(v0), sel_init);
}

void HDCMSwimData.init()()
{
  _swift_stdlib_reportUnimplementedInitializer();
  __break(1u);
}

id HDCMSwimData.__deallocating_deinit()
{
  return sub_1B78593AC(type metadata accessor for HDCMSwimData);
}

uint64_t type metadata accessor for HDCMSwimData()
{
  return objc_opt_self();
}

void sub_1B7858D64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1B7858F48(a1, a2, a3, (uint64_t)&unk_1E6CE7618, (uint64_t)sub_1B7858DAC, (uint64_t)&block_descriptor_1, (SEL *)&selRef_startUpdatesFromRecord_handler_);
}

uint64_t sub_1B7858D88()
{
  swift_release();
  return swift_deallocObject();
}

uint64_t sub_1B7858DAC(unint64_t a1, uint64_t a2)
{
  uint64_t v2;

  return sub_1B7859050(a1, a2, *(void (**)(uint64_t, uint64_t))(v2 + 16));
}

uint64_t sub_1B7858DC4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  void (*v5)(uint64_t, void *);
  id v6;

  v4 = a2;
  v5 = *(void (**)(uint64_t, void *))(a1 + 32);
  if (a2)
  {
    sub_1B7859580();
    v4 = sub_1B7EF9D10();
  }
  swift_retain();
  v6 = a3;
  v5(v4, a3);
  swift_release();

  return swift_bridgeObjectRelease();
}

uint64_t block_copy_helper_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_1()
{
  return swift_release();
}

void sub_1B7858E74(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  id v7;

  v5 = a1;
  if (a1)
  {
    type metadata accessor for HDCMSwimData();
    v5 = (void *)sub_1B7EF9D04();
  }
  if (a2)
    v6 = sub_1B7EF9BC0();
  else
    v6 = 0;
  v7 = (id)v6;
  (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v5);

}

id sub_1B7858EF4()
{
  uint64_t v0;

  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker), sel_stopUpdates);
}

void sub_1B7858F24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1B7858F48(a1, a2, a3, (uint64_t)&unk_1E6CE7668, (uint64_t)sub_1B7859614, (uint64_t)&block_descriptor_6, (SEL *)&selRef_querySwimUpdatesFromRecord_handler_);
}

void sub_1B7858F48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, SEL *a7)
{
  uint64_t v7;
  void *v8;
  id v14;
  uint64_t v15;
  void *v16;
  id v17;
  _QWORD v18[6];

  v8 = *(void **)(v7 + OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker);
  if (v8)
  {
    if (a1)
      v14 = *(id *)(a1 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data);
    else
      v14 = 0;
    v15 = swift_allocObject();
    *(_QWORD *)(v15 + 16) = a2;
    *(_QWORD *)(v15 + 24) = a3;
    v18[4] = a5;
    v18[5] = v15;
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 1107296256;
    v18[2] = sub_1B7858DC4;
    v18[3] = a6;
    v16 = _Block_copy(v18);
    v17 = v8;
    swift_retain();
    swift_release();
    objc_msgSend(v17, *a7, v14, v16);
    _Block_release(v16);

  }
}

uint64_t sub_1B7859050(unint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t))
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  id v9;
  id v10;
  objc_class *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  objc_super v15;
  uint64_t v16;

  if (!a1)
  {
    v14 = 0;
LABEL_14:
    a3(v14, a2);
    return swift_bridgeObjectRelease();
  }
  if (!(a1 >> 62))
  {
    v6 = *(_QWORD *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
    swift_bridgeObjectRetain();
    if (v6)
      goto LABEL_4;
    goto LABEL_13;
  }
  swift_bridgeObjectRetain();
  v6 = sub_1B7EF9E6C();
  if (!v6)
  {
LABEL_13:
    swift_bridgeObjectRelease();
    v14 = MEMORY[0x1E0DEE9D8];
    goto LABEL_14;
  }
LABEL_4:
  v16 = MEMORY[0x1E0DEE9D8];
  result = sub_1B7EF9E24();
  if ((v6 & 0x8000000000000000) == 0)
  {
    v8 = 0;
    do
    {
      if ((a1 & 0xC000000000000001) != 0)
        v9 = (id)MEMORY[0x1BCCAAC7C](v8, a1);
      else
        v9 = *(id *)(a1 + 8 * v8 + 32);
      v10 = v9;
      ++v8;
      v11 = (objc_class *)type metadata accessor for HDCMSwimData();
      v12 = (char *)objc_allocWithZone(v11);
      *(_QWORD *)&v12[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data] = v10;
      v15.receiver = v12;
      v15.super_class = v11;
      objc_msgSendSuper2(&v15, sel_init);
      sub_1B7EF9E0C();
      sub_1B7EF9E30();
      sub_1B7EF9E3C();
      sub_1B7EF9E18();
    }
    while (v6 != v8);
    v13 = v16;
    swift_bridgeObjectRelease();
    a3(v13, a2);
    return swift_bridgeObjectRelease();
  }
  __break(1u);
  return result;
}

uint64_t sub_1B7859204(void *a1, int a2, void *a3, void *aBlock, uint64_t a5, uint64_t a6, void (*a7)(void *, uint64_t, uint64_t))
{
  void *v11;
  uint64_t v12;
  id v13;
  id v14;

  v11 = _Block_copy(aBlock);
  v12 = swift_allocObject();
  *(_QWORD *)(v12 + 16) = v11;
  v13 = a3;
  v14 = a1;
  a7(a3, a6, v12);

  return swift_release();
}

id HDCMSwimTracker.init()()
{
  char *v0;
  objc_super v2;

  *(_QWORD *)&v0[OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker] = 0;
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDCMSwimTracker();
  return objc_msgSendSuper2(&v2, sel_init);
}

uint64_t type metadata accessor for HDCMSwimTracker()
{
  return objc_opt_self();
}

id HDCMSwimTracker.__deallocating_deinit()
{
  return sub_1B78593AC(type metadata accessor for HDCMSwimTracker);
}

id sub_1B78593AC(uint64_t (*a1)(void))
{
  void *v1;
  objc_super v3;

  v3.receiver = v1;
  v3.super_class = (Class)a1();
  return objc_msgSendSuper2(&v3, sel_dealloc);
}

uint64_t method lookup function for HDCMSwimData()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of HDCMSwimData.startDate.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x58))();
}

uint64_t dispatch thunk of HDCMSwimData.endDate.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x60))();
}

uint64_t dispatch thunk of HDCMSwimData.recordId.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x68))();
}

uint64_t dispatch thunk of HDCMSwimData.sourceId.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x70))();
}

uint64_t dispatch thunk of HDCMSwimData.lapCount.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x78))();
}

uint64_t dispatch thunk of HDCMSwimData.segment.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x80))();
}

uint64_t dispatch thunk of HDCMSwimData.distance.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x88))();
}

uint64_t dispatch thunk of HDCMSwimData.strokeCount.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x90))();
}

uint64_t dispatch thunk of HDCMSwimData.strokeType.getter()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x98))();
}

uint64_t method lookup function for HDCMSwimTracker()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of HDCMSwimTracker.startUpdates(fromRecord:handler:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x70))();
}

uint64_t dispatch thunk of HDCMSwimTracker.stopUpdates()()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x78))();
}

uint64_t dispatch thunk of HDCMSwimTracker.querySwimUpdates(fromRecord:handler:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x80))();
}

void sub_1B7859554(void *a1, uint64_t a2)
{
  uint64_t v2;

  sub_1B7858E74(a1, a2, *(_QWORD *)(v2 + 16));
}

uint64_t sub_1B785955C()
{
  uint64_t v0;

  _Block_release(*(const void **)(v0 + 16));
  return swift_deallocObject();
}

unint64_t sub_1B7859580()
{
  unint64_t result;

  result = qword_1EF192A98;
  if (!qword_1EF192A98)
  {
    objc_opt_self();
    result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1EF192A98);
  }
  return result;
}

uint64_t *__swift_allocate_value_buffer(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;

  if ((*(_DWORD *)(*(_QWORD *)(a1 - 8) + 80) & 0x20000) != 0)
  {
    v3 = swift_slowAlloc();
    *a2 = v3;
    return (uint64_t *)v3;
  }
  return a2;
}

_QWORD *sub_1B7859618(uint64_t a1)
{
  _QWORD *result;
  int v3;
  char v4;
  uint64_t v5;

  result = (_QWORD *)sub_1B785B108(a1);
  if ((v4 & 1) != 0)
    goto LABEL_8;
  if (*(_DWORD *)(a1 + 36) != v3)
  {
    __break(1u);
LABEL_8:
    __break(1u);
    return result;
  }
  if (result == (_QWORD *)(1 << *(_BYTE *)(a1 + 32)))
    return 0;
  else
    return sub_1B785B190(&v5, (uint64_t)result, v3, 0, a1);
}

unint64_t sub_1B78596A0(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t result;
  char v10;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  if (!*(_QWORD *)(a1 + 16))
  {
    v3 = (_QWORD *)MEMORY[0x1E0DEE9E0];
    goto LABEL_9;
  }
  sub_1B785B420();
  v2 = sub_1B7EF9E90();
  v3 = (_QWORD *)v2;
  v4 = *(_QWORD *)(a1 + 16);
  if (!v4)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  v5 = v2 + 64;
  v6 = a1 + 32;
  swift_retain();
  while (1)
  {
    sub_1B785B488(v6, (uint64_t)&v15);
    v7 = v15;
    v8 = v16;
    result = sub_1B785A5C0(v15, v16);
    if ((v10 & 1) != 0)
      break;
    *(_QWORD *)(v5 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    v11 = (uint64_t *)(v3[6] + 16 * result);
    *v11 = v7;
    v11[1] = v8;
    result = (unint64_t)sub_1B785B4CC(&v17, (_OWORD *)(v3[7] + 32 * result));
    v12 = v3[2];
    v13 = __OFADD__(v12, 1);
    v14 = v12 + 1;
    if (v13)
      goto LABEL_11;
    v3[2] = v14;
    v6 += 48;
    if (!--v4)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1B78597C4(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void **v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  id v8;
  unint64_t result;
  char v10;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;

  if (!*(_QWORD *)(a1 + 16))
  {
    v2 = (_QWORD *)MEMORY[0x1E0DEE9E0];
    goto LABEL_9;
  }
  sub_1B785AEF8();
  v2 = (_QWORD *)sub_1B7EF9E90();
  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  v4 = (void **)(a1 + 48);
  while (1)
  {
    v5 = (uint64_t)*(v4 - 2);
    v6 = (uint64_t)*(v4 - 1);
    v7 = *v4;
    swift_bridgeObjectRetain();
    v8 = v7;
    result = sub_1B785A5C0(v5, v6);
    if ((v10 & 1) != 0)
      break;
    *(_QWORD *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    v11 = (uint64_t *)(v2[6] + 16 * result);
    *v11 = v5;
    v11[1] = v6;
    *(_QWORD *)(v2[7] + 8 * result) = v8;
    v12 = v2[2];
    v13 = __OFADD__(v12, 1);
    v14 = v12 + 1;
    if (v13)
      goto LABEL_11;
    v2[2] = v14;
    v4 += 3;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

id HDHealthStoreClientAssertions.__deallocating_deinit()
{
  void *v0;
  objc_super v2;

  sub_1B7859960();
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDHealthStoreClientAssertions();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

id sub_1B7859960()
{
  uint64_t v0;
  os_unfair_lock_s *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int64_t v8;
  id result;
  int64_t v10;
  unint64_t v11;
  unint64_t v12;
  int64_t v13;
  unint64_t v14;
  int64_t v15;

  v1 = (os_unfair_lock_s *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v1);
  swift_endAccess();
  v2 = (uint64_t *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  v3 = *v2;
  v4 = v3 + 64;
  v5 = 1 << *(_BYTE *)(v3 + 32);
  v6 = -1;
  if (v5 < 64)
    v6 = ~(-1 << v5);
  v7 = v6 & *(_QWORD *)(v3 + 64);
  v8 = (unint64_t)(v5 + 63) >> 6;
  result = (id)swift_bridgeObjectRetain();
  v10 = 0;
  while (1)
  {
    if (v7)
    {
      v11 = __clz(__rbit64(v7));
      v7 &= v7 - 1;
      v12 = v11 | (v10 << 6);
      goto LABEL_5;
    }
    v13 = v10 + 1;
    if (__OFADD__(v10, 1))
    {
      __break(1u);
      goto LABEL_25;
    }
    if (v13 >= v8)
      goto LABEL_23;
    v14 = *(_QWORD *)(v4 + 8 * v13);
    ++v10;
    if (!v14)
    {
      v10 = v13 + 1;
      if (v13 + 1 >= v8)
        goto LABEL_23;
      v14 = *(_QWORD *)(v4 + 8 * v10);
      if (!v14)
      {
        v10 = v13 + 2;
        if (v13 + 2 >= v8)
          goto LABEL_23;
        v14 = *(_QWORD *)(v4 + 8 * v10);
        if (!v14)
        {
          v10 = v13 + 3;
          if (v13 + 3 >= v8)
            goto LABEL_23;
          v14 = *(_QWORD *)(v4 + 8 * v10);
          if (!v14)
            break;
        }
      }
    }
LABEL_22:
    v7 = (v14 - 1) & v14;
    v12 = __clz(__rbit64(v14)) + (v10 << 6);
LABEL_5:
    result = objc_msgSend(*(id *)(*(_QWORD *)(v3 + 56) + 8 * v12), sel_invalidate);
  }
  v15 = v13 + 4;
  if (v15 >= v8)
  {
LABEL_23:
    swift_release();
    swift_beginAccess();
    os_unfair_lock_unlock(v1);
    return (id)swift_endAccess();
  }
  v14 = *(_QWORD *)(v4 + 8 * v15);
  if (v14)
  {
    v10 = v15;
    goto LABEL_22;
  }
  while (1)
  {
    v10 = v15 + 1;
    if (__OFADD__(v15, 1))
      break;
    if (v10 >= v8)
      goto LABEL_23;
    v14 = *(_QWORD *)(v4 + 8 * v10);
    ++v15;
    if (v14)
      goto LABEL_22;
  }
LABEL_25:
  __break(1u);
  return result;
}

uint64_t type metadata accessor for HDHealthStoreClientAssertions()
{
  return objc_opt_self();
}

uint64_t sub_1B7859B88()
{
  uint64_t v0;
  os_unfair_lock_s *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = (os_unfair_lock_s *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v1);
  swift_endAccess();
  v2 = (uint64_t *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  sub_1B7859618(*v2);
  if (v4)
  {
    v5 = v3;
    swift_bridgeObjectRelease();
  }
  else
  {
    v5 = 0;
  }
  swift_beginAccess();
  os_unfair_lock_unlock(v1);
  swift_endAccess();
  return v5;
}

unint64_t sub_1B7859D10()
{
  uint64_t v0;
  os_unfair_lock_s *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v5;

  v1 = (os_unfair_lock_s *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v1);
  swift_endAccess();
  swift_beginAccess();
  v2 = swift_bridgeObjectRetain();
  v3 = (unint64_t)sub_1B785A4DC(v2);
  swift_bridgeObjectRelease();
  swift_beginAccess();
  os_unfair_lock_unlock(v1);
  swift_endAccess();
  if ((v3 & 0x8000000000000000) != 0 || (v3 & 0x4000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    v5 = sub_1B7EF9E6C();
    swift_release();
    if (v5)
      return v3;
    goto LABEL_4;
  }
  if (!*(_QWORD *)(v3 + 16))
  {
LABEL_4:
    swift_release();
    return 0;
  }
  return v3;
}

void *sub_1B7859E64(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  os_unfair_lock_s *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  void *v17;
  id v18;
  _BYTE v20[24];

  v2 = v1;
  v4 = sub_1B7EF9C20();
  v5 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](v4);
  v7 = &v20[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v8 = (os_unfair_lock_s *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v8);
  swift_endAccess();
  v9 = objc_msgSend(a1, sel_UUID);
  sub_1B7EF9C14();

  v10 = sub_1B7EF9BFC();
  v12 = v11;
  (*(void (**)(_BYTE *, uint64_t))(v5 + 8))(v7, v4);
  v13 = (uint64_t *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  v14 = *v13;
  if (!*(_QWORD *)(v14 + 16))
    goto LABEL_6;
  swift_bridgeObjectRetain();
  v15 = sub_1B785A5C0(v10, v12);
  if ((v16 & 1) == 0)
  {
    swift_bridgeObjectRelease();
LABEL_6:
    swift_bridgeObjectRelease();
    v17 = 0;
    goto LABEL_7;
  }
  v17 = *(void **)(*(_QWORD *)(v14 + 56) + 8 * v15);
  v18 = v17;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
LABEL_7:
  swift_beginAccess();
  os_unfair_lock_unlock(v8);
  swift_endAccess();
  return v17;
}

uint64_t sub_1B785A048(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  os_unfair_lock_s *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  id v14;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v17;

  v2 = v1;
  v4 = sub_1B7EF9C20();
  v5 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](v4);
  v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = (os_unfair_lock_s *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v8);
  swift_endAccess();
  v9 = objc_msgSend(a1, sel_UUID);
  sub_1B7EF9C14();

  v10 = sub_1B7EF9BFC();
  v12 = v11;
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  v13 = (uint64_t *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  v14 = a1;
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  v17 = *v13;
  *v13 = 0x8000000000000000;
  sub_1B785ACAC((uint64_t)v14, v10, v12, isUniquelyReferenced_nonNull_native);
  *v13 = v17;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_endAccess();
  swift_beginAccess();
  os_unfair_lock_unlock(v8);
  return swift_endAccess();
}

uint64_t sub_1B785A228(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  os_unfair_lock_s *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v15;

  v2 = v1;
  v4 = sub_1B7EF9C20();
  v5 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](v4);
  v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = (os_unfair_lock_s *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v8);
  swift_endAccess();
  v9 = objc_msgSend(a1, sel_UUID);
  sub_1B7EF9C14();

  v10 = sub_1B7EF9BFC();
  v12 = v11;
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  swift_beginAccess();
  v13 = (void *)sub_1B785A704(v10, v12);
  swift_endAccess();
  swift_bridgeObjectRelease();

  swift_beginAccess();
  os_unfair_lock_unlock(v8);
  return swift_endAccess();
}

id HDHealthStoreClientAssertions.__allocating_init()()
{
  objc_class *v0;

  return objc_msgSend(objc_allocWithZone(v0), sel_init);
}

id HDHealthStoreClientAssertions.init()()
{
  char *v0;
  uint64_t v1;
  char *v2;
  objc_super v4;

  *(_DWORD *)&v0[OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock] = 0;
  v1 = OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions;
  v2 = v0;
  *(_QWORD *)&v0[v1] = sub_1B78597C4(MEMORY[0x1E0DEE9D8]);

  v4.receiver = v2;
  v4.super_class = (Class)type metadata accessor for HDHealthStoreClientAssertions();
  return objc_msgSendSuper2(&v4, sel_init);
}

_QWORD *sub_1B785A4DC(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;
  int64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v8;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    return (_QWORD *)MEMORY[0x1E0DEE9D8];
  sub_1B7856B40();
  v3 = (_QWORD *)swift_allocObject();
  v4 = _swift_stdlib_malloc_size(v3);
  v5 = v4 - 32;
  if (v4 < 32)
    v5 = v4 - 25;
  v3[2] = v1;
  v3[3] = (2 * (v5 >> 3)) | 1;
  v6 = sub_1B785B220(&v8, v3 + 4, v1, a1);
  swift_bridgeObjectRetain();
  sub_1B785B418();
  if (v6 != (_QWORD *)v1)
  {
    __break(1u);
    return (_QWORD *)MEMORY[0x1E0DEE9D8];
  }
  return v3;
}

unint64_t sub_1B785A5C0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  sub_1B7EF9F20();
  sub_1B7EF9CD4();
  v4 = sub_1B7EF9F2C();
  return sub_1B785A624(a1, a2, v4);
}

unint64_t sub_1B785A624(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v9;
  _QWORD *v10;
  BOOL v11;
  uint64_t v12;
  _QWORD *v13;
  BOOL v14;

  v4 = v3 + 64;
  v5 = -1 << *(_BYTE *)(v3 + 32);
  v6 = a3 & ~v5;
  if (((*(_QWORD *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8)) >> v6) & 1) != 0)
  {
    v9 = *(_QWORD *)(v3 + 48);
    v10 = (_QWORD *)(v9 + 16 * v6);
    v11 = *v10 == a1 && v10[1] == a2;
    if (!v11 && (sub_1B7EF9ECC() & 1) == 0)
    {
      v12 = ~v5;
      do
      {
        v6 = (v6 + 1) & v12;
        if (((*(_QWORD *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8)) >> v6) & 1) == 0)
          break;
        v13 = (_QWORD *)(v9 + 16 * v6);
        v14 = *v13 == a1 && v13[1] == a2;
      }
      while (!v14 && (sub_1B7EF9ECC() & 1) == 0);
    }
  }
  return v6;
}

uint64_t sub_1B785A704(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  unint64_t v6;
  char v7;
  int isUniquelyReferenced_nonNull_native;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  v3 = v2;
  swift_bridgeObjectRetain();
  v6 = sub_1B785A5C0(a1, a2);
  LOBYTE(a2) = v7;
  swift_bridgeObjectRelease();
  if ((a2 & 1) == 0)
    return 0;
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  v9 = *v3;
  v12 = *v3;
  *v3 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    sub_1B785AF5C();
    v9 = v12;
  }
  swift_bridgeObjectRelease();
  v10 = *(_QWORD *)(*(_QWORD *)(v9 + 56) + 8 * v6);
  sub_1B785AAD8(v6, v9);
  *v3 = v9;
  swift_bridgeObjectRelease();
  return v10;
}

uint64_t sub_1B785A7D0(uint64_t a1, char a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t result;
  int64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  int64_t v21;
  _QWORD *v22;
  unint64_t v23;
  int64_t v24;
  char v25;
  unint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  id v33;
  uint64_t v34;
  uint64_t *v35;
  int64_t v36;
  uint64_t v37;
  char v38;

  v3 = v2;
  v5 = *v2;
  sub_1B785AEF8();
  v38 = a2;
  v6 = sub_1B7EF9E84();
  v7 = v6;
  if (!*(_QWORD *)(v5 + 16))
    goto LABEL_40;
  v8 = 1 << *(_BYTE *)(v5 + 32);
  v37 = v5 + 64;
  if (v8 < 64)
    v9 = ~(-1 << v8);
  else
    v9 = -1;
  v10 = v9 & *(_QWORD *)(v5 + 64);
  v35 = v2;
  v36 = (unint64_t)(v8 + 63) >> 6;
  v11 = v6 + 64;
  result = swift_retain();
  v13 = 0;
  while (1)
  {
    if (v10)
    {
      v19 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      v20 = v19 | (v13 << 6);
      goto LABEL_31;
    }
    v21 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v21 >= v36)
      break;
    v22 = (_QWORD *)(v5 + 64);
    v23 = *(_QWORD *)(v37 + 8 * v21);
    ++v13;
    if (!v23)
    {
      v13 = v21 + 1;
      if (v21 + 1 >= v36)
        goto LABEL_33;
      v23 = *(_QWORD *)(v37 + 8 * v13);
      if (!v23)
      {
        v24 = v21 + 2;
        if (v24 >= v36)
        {
LABEL_33:
          swift_release();
          v3 = v35;
          if ((v38 & 1) == 0)
            goto LABEL_40;
          goto LABEL_36;
        }
        v23 = *(_QWORD *)(v37 + 8 * v24);
        if (!v23)
        {
          while (1)
          {
            v13 = v24 + 1;
            if (__OFADD__(v24, 1))
              goto LABEL_42;
            if (v13 >= v36)
              goto LABEL_33;
            v23 = *(_QWORD *)(v37 + 8 * v13);
            ++v24;
            if (v23)
              goto LABEL_30;
          }
        }
        v13 = v24;
      }
    }
LABEL_30:
    v10 = (v23 - 1) & v23;
    v20 = __clz(__rbit64(v23)) + (v13 << 6);
LABEL_31:
    v29 = (uint64_t *)(*(_QWORD *)(v5 + 48) + 16 * v20);
    v31 = *v29;
    v30 = v29[1];
    v32 = *(void **)(*(_QWORD *)(v5 + 56) + 8 * v20);
    if ((v38 & 1) == 0)
    {
      swift_bridgeObjectRetain();
      v33 = v32;
    }
    sub_1B7EF9F20();
    sub_1B7EF9CD4();
    result = sub_1B7EF9F2C();
    v14 = -1 << *(_BYTE *)(v7 + 32);
    v15 = result & ~v14;
    v16 = v15 >> 6;
    if (((-1 << v15) & ~*(_QWORD *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      v17 = __clz(__rbit64((-1 << v15) & ~*(_QWORD *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      v25 = 0;
      v26 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        v27 = v16 == v26;
        if (v16 == v26)
          v16 = 0;
        v25 |= v27;
        v28 = *(_QWORD *)(v11 + 8 * v16);
      }
      while (v28 == -1);
      v17 = __clz(__rbit64(~v28)) + (v16 << 6);
    }
    *(_QWORD *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    v18 = (_QWORD *)(*(_QWORD *)(v7 + 48) + 16 * v17);
    *v18 = v31;
    v18[1] = v30;
    *(_QWORD *)(*(_QWORD *)(v7 + 56) + 8 * v17) = v32;
    ++*(_QWORD *)(v7 + 16);
  }
  swift_release();
  v3 = v35;
  v22 = (_QWORD *)(v5 + 64);
  if ((v38 & 1) == 0)
    goto LABEL_40;
LABEL_36:
  v34 = 1 << *(_BYTE *)(v5 + 32);
  if (v34 >= 64)
    bzero(v22, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  else
    *v22 = -1 << v34;
  *(_QWORD *)(v5 + 16) = 0;
LABEL_40:
  result = swift_release();
  *v3 = v7;
  return result;
}

unint64_t sub_1B785AAD8(unint64_t result, uint64_t a2)
{
  int64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  _OWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;

  v3 = result;
  v4 = a2 + 64;
  v5 = -1 << *(_BYTE *)(a2 + 32);
  v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(_QWORD *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    v7 = ~v5;
    result = sub_1B7EF9DC4();
    if ((*(_QWORD *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      v8 = (result + 1) & v7;
      do
      {
        sub_1B7EF9F20();
        swift_bridgeObjectRetain();
        sub_1B7EF9CD4();
        v9 = sub_1B7EF9F2C();
        result = swift_bridgeObjectRelease();
        v10 = v9 & v7;
        if (v3 >= (uint64_t)v8)
        {
          if (v10 < v8)
            goto LABEL_5;
        }
        else if (v10 >= v8)
        {
          goto LABEL_11;
        }
        if (v3 >= (uint64_t)v10)
        {
LABEL_11:
          v11 = *(_QWORD *)(a2 + 48);
          v12 = (_OWORD *)(v11 + 16 * v3);
          v13 = (_OWORD *)(v11 + 16 * v6);
          if (v3 != v6 || v12 >= v13 + 1)
            *v12 = *v13;
          v14 = *(_QWORD *)(a2 + 56);
          v15 = (_QWORD *)(v14 + 8 * v3);
          v16 = (_QWORD *)(v14 + 8 * v6);
          if (v3 != v6 || (v3 = v6, v15 >= v16 + 1))
          {
            *v15 = *v16;
            v3 = v6;
          }
        }
LABEL_5:
        v6 = (v6 + 1) & v7;
      }
      while (((*(_QWORD *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    v17 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    v18 = *v17;
    v19 = (-1 << v3) - 1;
  }
  else
  {
    v17 = (uint64_t *)(v4 + 8 * (result >> 6));
    v19 = *v17;
    v18 = (-1 << result) - 1;
  }
  *v17 = v19 & v18;
  v20 = *(_QWORD *)(a2 + 16);
  v21 = __OFSUB__(v20, 1);
  v22 = v20 - 1;
  if (v21)
  {
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a2 + 16) = v22;
    ++*(_DWORD *)(a2 + 36);
  }
  return result;
}

void sub_1B785ACAC(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v10;
  char v11;
  unint64_t v12;
  uint64_t v13;
  _BOOL8 v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  char v21;
  uint64_t *v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;

  v5 = v4;
  v10 = *v4;
  v12 = sub_1B785A5C0(a2, a3);
  v13 = *(_QWORD *)(v10 + 16);
  v14 = (v11 & 1) == 0;
  v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  v16 = v11;
  v17 = *(_QWORD *)(v10 + 24);
  if (v17 >= v15 && (a4 & 1) != 0)
    goto LABEL_7;
  if (v17 >= v15 && (a4 & 1) == 0)
  {
    sub_1B785AF5C();
LABEL_7:
    v18 = (_QWORD *)*v5;
    if ((v16 & 1) != 0)
    {
LABEL_8:
      v19 = v18[7];

      *(_QWORD *)(v19 + 8 * v12) = a1;
      return;
    }
LABEL_11:
    v18[(v12 >> 6) + 8] |= 1 << v12;
    v22 = (uint64_t *)(v18[6] + 16 * v12);
    *v22 = a2;
    v22[1] = a3;
    *(_QWORD *)(v18[7] + 8 * v12) = a1;
    v23 = v18[2];
    v24 = __OFADD__(v23, 1);
    v25 = v23 + 1;
    if (!v24)
    {
      v18[2] = v25;
      swift_bridgeObjectRetain();
      return;
    }
    goto LABEL_14;
  }
  sub_1B785A7D0(v15, a4 & 1);
  v20 = sub_1B785A5C0(a2, a3);
  if ((v16 & 1) == (v21 & 1))
  {
    v12 = v20;
    v18 = (_QWORD *)*v5;
    if ((v16 & 1) != 0)
      goto LABEL_8;
    goto LABEL_11;
  }
LABEL_15:
  sub_1B7EF9EE4();
  __break(1u);
}

uint64_t method lookup function for HDHealthStoreClientAssertions()
{
  return swift_lookUpClassMethod();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.invalidateAssertions()()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x90))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.firstAssertion()()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0x98))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.accessibilityAssertions()()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xA0))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.assertionForHKDatabaseAccessibilityAssertion(hkDatabaseAccessibilityAssertion:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xA8))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.addAssertionMapping(assertion:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xB0))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.removeAssertionMapping(assertion:)()
{
  _QWORD *v0;

  return (*(uint64_t (**)(void))((*MEMORY[0x1E0DEEDD8] & *v0) + 0xB8))();
}

unint64_t sub_1B785AEBC()
{
  unint64_t result;

  result = qword_1ED552158;
  if (!qword_1ED552158)
  {
    objc_opt_self();
    result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1ED552158);
  }
  return result;
}

void sub_1B785AEF8()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1ED552160)
  {
    sub_1B785AEBC();
    v0 = sub_1B7EF9E9C();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1ED552160);
  }
}

id sub_1B785AF5C()
{
  uint64_t *v0;
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id result;
  uint64_t v6;
  unint64_t v7;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  int64_t v22;
  unint64_t v23;
  int64_t v24;

  v1 = v0;
  sub_1B785AEF8();
  v2 = *v0;
  v3 = sub_1B7EF9E78();
  v4 = v3;
  if (!*(_QWORD *)(v2 + 16))
  {
LABEL_26:
    result = (id)swift_release();
    *v1 = v4;
    return result;
  }
  result = (id)(v3 + 64);
  v6 = v2 + 64;
  v7 = (unint64_t)((1 << *(_BYTE *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7)
    result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  v9 = 0;
  *(_QWORD *)(v4 + 16) = *(_QWORD *)(v2 + 16);
  v10 = 1 << *(_BYTE *)(v2 + 32);
  v11 = -1;
  if (v10 < 64)
    v11 = ~(-1 << v10);
  v12 = v11 & *(_QWORD *)(v2 + 64);
  v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    v22 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v22 >= v13)
      goto LABEL_26;
    v23 = *(_QWORD *)(v6 + 8 * v22);
    ++v9;
    if (!v23)
    {
      v9 = v22 + 1;
      if (v22 + 1 >= v13)
        goto LABEL_26;
      v23 = *(_QWORD *)(v6 + 8 * v9);
      if (!v23)
        break;
    }
LABEL_25:
    v12 = (v23 - 1) & v23;
    v15 = __clz(__rbit64(v23)) + (v9 << 6);
LABEL_12:
    v16 = 16 * v15;
    v17 = (_QWORD *)(*(_QWORD *)(v2 + 48) + 16 * v15);
    v18 = v17[1];
    v19 = 8 * v15;
    v20 = *(void **)(*(_QWORD *)(v2 + 56) + v19);
    v21 = (_QWORD *)(*(_QWORD *)(v4 + 48) + v16);
    *v21 = *v17;
    v21[1] = v18;
    *(_QWORD *)(*(_QWORD *)(v4 + 56) + v19) = v20;
    swift_bridgeObjectRetain();
    result = v20;
  }
  v24 = v22 + 2;
  if (v24 >= v13)
    goto LABEL_26;
  v23 = *(_QWORD *)(v6 + 8 * v24);
  if (v23)
  {
    v9 = v24;
    goto LABEL_25;
  }
  while (1)
  {
    v9 = v24 + 1;
    if (__OFADD__(v24, 1))
      break;
    if (v9 >= v13)
      goto LABEL_26;
    v23 = *(_QWORD *)(v6 + 8 * v9);
    ++v24;
    if (v23)
      goto LABEL_25;
  }
LABEL_28:
  __break(1u);
  return result;
}

uint64_t sub_1B785B108(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v1 = *(_QWORD *)(a1 + 64);
  if (v1)
  {
    v2 = 0;
    return __clz(__rbit64(v1)) + v2;
  }
  v5 = *(_BYTE *)(a1 + 32);
  v6 = v5 & 0x3F;
  v3 = 1 << v5;
  if (v6 < 7)
    return v3;
  v1 = *(_QWORD *)(a1 + 72);
  if (v1)
  {
    v2 = 64;
    return __clz(__rbit64(v1)) + v2;
  }
  v7 = (unint64_t)(v3 + 63) >> 6;
  if (v7 <= 2)
    v7 = 2;
  v8 = v7 - 2;
  v9 = (unint64_t *)(a1 + 80);
  v2 = 64;
  while (v8)
  {
    v10 = *v9++;
    v1 = v10;
    --v8;
    v2 += 64;
    if (v10)
      return __clz(__rbit64(v1)) + v2;
  }
  return v3;
}

_QWORD *sub_1B785B190(_QWORD *result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  void *v6;
  id v7;

  if (a2 < 0 || 1 << *(_BYTE *)(a5 + 32) <= a2)
  {
    __break(1u);
    goto LABEL_7;
  }
  if (((*(_QWORD *)(a5 + (((unint64_t)a2 >> 3) & 0xFFFFFFFFFFFFF8) + 64) >> a2) & 1) == 0)
  {
LABEL_7:
    __break(1u);
    goto LABEL_8;
  }
  if (*(_DWORD *)(a5 + 36) == a3)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(a5 + 48) + 16 * a2);
    v6 = *(void **)(*(_QWORD *)(a5 + 56) + 8 * a2);
    *result = v6;
    swift_bridgeObjectRetain();
    v7 = v6;
    return (_QWORD *)v5;
  }
LABEL_8:
  __break(1u);
  return result;
}

_QWORD *sub_1B785B220(_QWORD *result, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;
  int64_t v14;
  unint64_t v15;
  unint64_t v16;
  int64_t v17;
  unint64_t v18;
  int64_t v19;
  void *v20;
  id v21;

  v5 = result;
  v6 = a4 + 64;
  v7 = -1 << *(_BYTE *)(a4 + 32);
  if (-v7 < 64)
    v8 = ~(-1 << -(char)v7);
  else
    v8 = -1;
  v9 = v8 & *(_QWORD *)(a4 + 64);
  if (!a2)
  {
    v12 = 0;
    v10 = 0;
LABEL_38:
    *v5 = a4;
    v5[1] = v6;
    v5[2] = ~v7;
    v5[3] = v12;
    v5[4] = v9;
    return (_QWORD *)v10;
  }
  v10 = a3;
  if (!a3)
  {
    v12 = 0;
    goto LABEL_38;
  }
  if (a3 < 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  v11 = a2;
  v12 = 0;
  v13 = 0;
  v14 = (unint64_t)(63 - v7) >> 6;
  if (!v9)
    goto LABEL_9;
LABEL_8:
  v15 = __clz(__rbit64(v9));
  v9 &= v9 - 1;
  v16 = v15 | (v12 << 6);
  while (1)
  {
    ++v13;
    v20 = *(void **)(*(_QWORD *)(a4 + 56) + 8 * v16);
    *v11 = v20;
    if (v13 == v10)
    {
      v21 = v20;
      goto LABEL_38;
    }
    ++v11;
    result = v20;
    if (v9)
      goto LABEL_8;
LABEL_9:
    v17 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      goto LABEL_40;
    }
    if (v17 >= v14)
      goto LABEL_33;
    v18 = *(_QWORD *)(v6 + 8 * v17);
    if (!v18)
      break;
LABEL_18:
    v9 = (v18 - 1) & v18;
    v16 = __clz(__rbit64(v18)) + (v17 << 6);
    v12 = v17;
  }
  v12 += 2;
  if (v17 + 1 >= v14)
  {
    v9 = 0;
    v12 = v17;
    goto LABEL_37;
  }
  v18 = *(_QWORD *)(v6 + 8 * v12);
  if (v18)
    goto LABEL_14;
  v19 = v17 + 2;
  if (v17 + 2 >= v14)
    goto LABEL_33;
  v18 = *(_QWORD *)(v6 + 8 * v19);
  if (v18)
    goto LABEL_17;
  v12 = v17 + 3;
  if (v17 + 3 >= v14)
  {
    v9 = 0;
    v12 = v17 + 2;
    goto LABEL_37;
  }
  v18 = *(_QWORD *)(v6 + 8 * v12);
  if (v18)
  {
LABEL_14:
    v17 = v12;
    goto LABEL_18;
  }
  v19 = v17 + 4;
  if (v17 + 4 >= v14)
  {
LABEL_33:
    v9 = 0;
LABEL_37:
    v10 = v13;
    goto LABEL_38;
  }
  v18 = *(_QWORD *)(v6 + 8 * v19);
  if (v18)
  {
LABEL_17:
    v17 = v19;
    goto LABEL_18;
  }
  while (1)
  {
    v17 = v19 + 1;
    if (__OFADD__(v19, 1))
      break;
    if (v17 >= v14)
    {
      v9 = 0;
      v12 = v14 - 1;
      goto LABEL_37;
    }
    v18 = *(_QWORD *)(v6 + 8 * v17);
    ++v19;
    if (v18)
      goto LABEL_18;
  }
LABEL_41:
  __break(1u);
  return result;
}

uint64_t sub_1B785B418()
{
  return swift_release();
}

void sub_1B785B420()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1EF192AB0)
  {
    v0 = sub_1B7EF9E9C();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1EF192AB0);
  }
}

uint64_t sub_1B785B488(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  sub_1B7858774();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

_OWORD *sub_1B785B4CC(_OWORD *a1, _OWORD *a2)
{
  __int128 v2;

  v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

void HDKeyValueDomain.data(for:)()
{
  void *v0;
  id v1;
  uint64_t v2;

  v1 = v0;
  swift_bridgeObjectRetain();
  sub_1B785B548(v1, &v2);
}

void sub_1B785B548(void *a1@<X1>, uint64_t *a2@<X8>)
{
  void *v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  id v11;
  id v12;
  id v13[2];

  v13[1] = *(id *)MEMORY[0x1E0C80C00];
  v4 = (void *)sub_1B7EF9CB0();
  v13[0] = 0;
  v5 = objc_msgSend(a1, sel_dataForKey_error_, v4, v13);

  v6 = v13[0];
  if (v5)
  {
    v7 = v13[0];
    v8 = sub_1B7EF9BD8();
    v10 = v9;

    if (v6)
      goto LABEL_3;
LABEL_6:
    v11 = a1;
    goto LABEL_7;
  }
  v12 = v13[0];
  v8 = 0;
  v10 = 0xF000000000000000;
  if (!v6)
    goto LABEL_6;
LABEL_3:
  v11 = v6;
  if (objc_msgSend(v11, sel_hk_isHealthKitErrorWithCode_, 11))
  {

    sub_1B785C094(v8, v10);
    v8 = 0;
    v10 = 0xF000000000000000;
LABEL_7:

    *a2 = v8;
    a2[1] = v10;
    swift_bridgeObjectRelease();
    return;
  }
  swift_willThrow();
  sub_1B785C094(v8, v10);
  swift_bridgeObjectRelease();

}

void sub_1B785B6AC(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  sub_1B785BFC0();
  MEMORY[0x1E0C80A78](v4);
  v6 = (char *)v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = (void *)sub_1B7EF9CB0();
  v16[0] = 0;
  v8 = objc_msgSend(a1, sel_dateForKey_error_, v7, v16);

  v9 = (void *)v16[0];
  if (v8)
  {
    sub_1B7EF9BE4();
    v10 = v9;

    v11 = sub_1B7EF9BF0();
    (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(v11 - 8) + 56))(v6, 0, 1, v11);
    if (v9)
      goto LABEL_3;
LABEL_6:
    sub_1B785C014((uint64_t)v6, a2, (uint64_t (*)(_QWORD))sub_1B785BFC0);
    goto LABEL_7;
  }
  v14 = sub_1B7EF9BF0();
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v14 - 8) + 56))(v6, 1, 1, v14);
  v15 = v9;
  if (!v9)
    goto LABEL_6;
LABEL_3:
  v12 = v9;
  if ((objc_msgSend(v12, sel_hk_isHealthKitErrorWithCode_, 11) & 1) != 0)
  {

    sub_1B785C058((uint64_t)v6, (uint64_t (*)(_QWORD))sub_1B785BFC0);
    v13 = sub_1B7EF9BF0();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 56))(a2, 1, 1, v13);
LABEL_7:

    swift_bridgeObjectRelease();
    return;
  }
  swift_willThrow();
  sub_1B785C058((uint64_t)v6, (uint64_t (*)(_QWORD))sub_1B785BFC0);
  swift_bridgeObjectRelease();

}

void sub_1B785B8B4(void *a1@<X1>, _OWORD *a2@<X8>)
{
  void *v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  _OWORD v11[2];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = (void *)sub_1B7EF9CB0();
  v10 = 0;
  v5 = objc_msgSend(a1, sel_propertyListValueForKey_error_, v4, &v10);

  v6 = v10;
  if (v5)
  {
    v7 = v10;
    sub_1B7EF9DAC();
    swift_unknownObjectRelease();
    if (v6)
      goto LABEL_3;
LABEL_6:
    sub_1B785C014((uint64_t)v11, (uint64_t)a2, (uint64_t (*)(_QWORD))sub_1B785BF68);
    goto LABEL_7;
  }
  memset(v11, 0, sizeof(v11));
  v9 = v10;
  if (!v6)
    goto LABEL_6;
LABEL_3:
  v8 = v6;
  if ((objc_msgSend(v8, sel_hk_isHealthKitErrorWithCode_, 11) & 1) != 0)
  {

    sub_1B785C058((uint64_t)v11, (uint64_t (*)(_QWORD))sub_1B785BF68);
    *a2 = 0u;
    a2[1] = 0u;
LABEL_7:

    swift_bridgeObjectRelease();
    return;
  }
  swift_willThrow();
  sub_1B785C058((uint64_t)v11, (uint64_t (*)(_QWORD))sub_1B785BF68);
  swift_bridgeObjectRelease();

}

void HDKeyValueDomain.date(for:)(uint64_t a1@<X8>)
{
  void *v1;
  id v3;

  v3 = v1;
  swift_bridgeObjectRetain();
  sub_1B785B6AC(v3, a1);
}

HKQuantity_optional __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> HDKeyValueDomain.quantity(for:unit:)(Swift::String a1, HKUnit unit)
{
  void *v2;
  void *object;
  uint64_t countAndFlagsBits;
  id v6;
  objc_class *v7;
  objc_class *v8;
  Swift::Bool v9;
  objc_class *v10;
  HKQuantity_optional result;

  object = a1._object;
  countAndFlagsBits = a1._countAndFlagsBits;
  v6 = v2;
  swift_bridgeObjectRetain();
  v7 = unit.super.isa;
  v8 = (objc_class *)sub_1B785BC4C(v6, countAndFlagsBits, (uint64_t)object, (uint64_t)v7);

  swift_bridgeObjectRelease();
  v10 = v8;
  result.value.super.isa = v10;
  result.is_nil = v9;
  return result;
}

NSNumber_optional __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> HDKeyValueDomain.number(for:)(Swift::String a1)
{
  void *v1;
  id v2;
  objc_class *v3;
  Swift::Bool v4;
  objc_class *v5;
  NSNumber_optional result;

  v2 = v1;
  swift_bridgeObjectRetain();
  v3 = (objc_class *)sub_1B785BD44(v2);

  swift_bridgeObjectRelease();
  v5 = v3;
  result.value.super.super.isa = v5;
  result.is_nil = v4;
  return result;
}

Swift::String_optional __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> HDKeyValueDomain.string(for:)(Swift::String a1)
{
  void *v1;
  id v2;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  Swift::String_optional result;

  v2 = v1;
  swift_bridgeObjectRetain();
  v3 = sub_1B785BE34(v2);
  v5 = v4;

  swift_bridgeObjectRelease();
  v6 = v3;
  v7 = v5;
  result.value._object = v7;
  result.value._countAndFlagsBits = v6;
  return result;
}

void HDKeyValueDomain.propertyListValue(for:)(_OWORD *a1@<X8>)
{
  void *v1;
  id v3;

  v3 = v1;
  swift_bridgeObjectRetain();
  sub_1B785B8B4(v3, a1);
}

id sub_1B785BC4C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  id v7;
  id v8;
  id v10[2];

  v10[1] = *(id *)MEMORY[0x1E0C80C00];
  v6 = (void *)sub_1B7EF9CB0();
  v10[0] = 0;
  v7 = objc_msgSend(a1, sel_quantityForKey_unit_error_, v6, a4, v10);

  if (v10[0])
  {
    v8 = v10[0];
    if ((objc_msgSend(v8, sel_hk_isHealthKitErrorWithCode_, 11) & 1) != 0)
    {

      return 0;
    }
    else
    {
      swift_willThrow();

    }
  }
  return v7;
}

id sub_1B785BD44(void *a1)
{
  void *v2;
  id v3;
  id v4;
  id v6[2];

  v6[1] = *(id *)MEMORY[0x1E0C80C00];
  v2 = (void *)sub_1B7EF9CB0();
  v6[0] = 0;
  v3 = objc_msgSend(a1, sel_numberForKey_error_, v2, v6);

  if (v6[0])
  {
    v4 = v6[0];
    if ((objc_msgSend(v4, sel_hk_isHealthKitErrorWithCode_, 11) & 1) != 0)
    {

      return 0;
    }
    else
    {
      swift_willThrow();

    }
  }
  return v3;
}

uint64_t sub_1B785BE34(void *a1)
{
  void *v2;
  id v3;
  id v4;
  uint64_t v5;
  id v6;
  id v7;
  id v8;
  id v10[2];

  v10[1] = *(id *)MEMORY[0x1E0C80C00];
  v2 = (void *)sub_1B7EF9CB0();
  v10[0] = 0;
  v3 = objc_msgSend(a1, sel_stringForKey_error_, v2, v10);

  v4 = v10[0];
  if (v3)
  {
    v5 = sub_1B7EF9CBC();
    v6 = v4;

    if (!v4)
      return v5;
  }
  else
  {
    v7 = v10[0];
    v5 = 0;
    if (!v4)
      return v5;
  }
  v8 = v4;
  if (objc_msgSend(v8, sel_hk_isHealthKitErrorWithCode_, 11))
  {

    swift_bridgeObjectRelease();
    return 0;
  }
  else
  {
    swift_willThrow();

    swift_bridgeObjectRelease();
  }
  return v5;
}

void sub_1B785BF68()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1ED552168)
  {
    v0 = sub_1B7EF9D88();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1ED552168);
  }
}

void sub_1B785BFC0()
{
  unint64_t v0;
  uint64_t v1;

  if (!qword_1EF192AB8)
  {
    sub_1B7EF9BF0();
    v0 = sub_1B7EF9D88();
    if (!v1)
      atomic_store(v0, (unint64_t *)&qword_1EF192AB8);
  }
}

uint64_t sub_1B785C014(uint64_t a1, uint64_t a2, uint64_t (*a3)(_QWORD))
{
  uint64_t v5;

  v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_1B785C058(uint64_t a1, uint64_t (*a2)(_QWORD))
{
  uint64_t v3;

  v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_1B785C094(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15)
    return sub_1B7853B18(a1, a2);
  return a1;
}

void HDSetRecordClassesForDecoding(id obj)
{
  objc_storeStrong((id *)&_recordClasses, obj);
}

id HDRecordClassesForDecoding()
{
  if (_recordClasses)
    return (id)_recordClasses;
  else
    return MEMORY[0x1E0C9AA60];
}

__CFString *HDCloudSyncContextPurposeToString(unint64_t a1)
{
  if (a1 < 0x14)
    return off_1E6CE7970[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%zd)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

__CFString *HDCloudSyncOperationResultToString(uint64_t a1)
{
  __CFString *v1;

  if (!a1)
    return CFSTR("Error");
  if (a1 == 1)
  {
    v1 = CFSTR("Success");
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%zd)"), a1);
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  return v1;
}

__CFString *HDCloudSyncRebaseReasonToString(unint64_t a1)
{
  if (a1 < 6)
    return off_1E6CE7A10[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%zd)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

__CFString *HDCloudSyncRebaseTriggerToString(uint64_t a1)
{
  __CFString *v1;

  if (a1 == 1)
    return CFSTR("third party deleted samples");
  if (a1)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%zd)"), a1);
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v1 = CFSTR("health deleted samples");
  }
  return v1;
}

__CFString *HDCloudSyncRestorePhaseToString(uint64_t a1)
{
  __CFString *v1;

  if (!a1)
    return CFSTR("Restore Phase Sync Complete");
  if (a1 == 1)
  {
    v1 = CFSTR("Restore Phase Ingest Complete");
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%zd)"), a1);
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  return v1;
}

uint64_t isCloudKitManateeEnabled(char a1)
{
  return a1 & 1;
}

void HDCloudSyncUpdateProgressOnQueueForObjectAndLog(void *a1, void *a2, void *a3, uint64_t a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  NSObject *v11;
  id v12;
  _QWORD v13[4];
  id v14;
  id v15;
  id v16;
  uint64_t v17;

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __HDCloudSyncUpdateProgressOnQueueForObjectAndLog_block_invoke;
  v13[3] = &unk_1E6CE78C0;
  v14 = v7;
  v15 = v8;
  v16 = v9;
  v17 = a4;
  v10 = v9;
  v11 = v8;
  v12 = v7;
  dispatch_async(v11, v13);

}

void HDCloudSyncUpdateProgressAssertQueueForObjectAndLog(void *a1, NSObject *a2, void *a3, uint64_t a4)
{
  id v7;
  id v8;
  NSObject *v9;
  int v10;
  id v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  id v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a3;
  dispatch_assert_queue_V2(a2);
  objc_msgSend(v7, "setCompletedUnitCount:", a4);
  _HKInitializeLogging();
  v9 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_INFO))
  {
    v10 = 138543874;
    v11 = v8;
    v12 = 2048;
    v13 = a4;
    v14 = 2114;
    v15 = v7;
    _os_log_impl(&dword_1B7802000, v9, OS_LOG_TYPE_INFO, "%{public}@: Update progress.completedUnitCount = (%lld): %{public}@", (uint8_t *)&v10, 0x20u);
  }

}

void HDCloudSyncUpdateProgressOnQueueByAmountForObjectAndLog(void *a1, void *a2, void *a3, uint64_t a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  NSObject *v11;
  id v12;
  _QWORD v13[4];
  id v14;
  id v15;
  id v16;
  uint64_t v17;

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __HDCloudSyncUpdateProgressOnQueueByAmountForObjectAndLog_block_invoke;
  v13[3] = &unk_1E6CE78C0;
  v14 = v7;
  v15 = v8;
  v16 = v9;
  v17 = a4;
  v10 = v9;
  v11 = v8;
  v12 = v7;
  dispatch_async(v11, v13);

}

HDKeyValueDomain *HDCloudSyncKeyValueDomainWithProfile(void *a1)
{
  id v1;
  HDKeyValueDomain *v2;

  v1 = a1;
  v2 = -[HDKeyValueDomain initWithCategory:domainName:profile:]([HDKeyValueDomain alloc], "initWithCategory:domainName:profile:", 0, CFSTR("CloudSync"), v1);

  return v2;
}

HDKeyValueDomain *HDCloudSyncProtectedAndSyncedKeyValueDomainWithProfile(void *a1)
{
  id v1;
  HDKeyValueDomain *v2;

  v1 = a1;
  v2 = -[HDKeyValueDomain initWithCategory:domainName:profile:]([HDKeyValueDomain alloc], "initWithCategory:domainName:profile:", 105, CFSTR("CloudSync"), v1);

  return v2;
}

HDKeyValueDomain *HDCloudSyncUnprotectedAndSyncedKeyValueDomainWithProfile(void *a1)
{
  id v1;
  HDKeyValueDomain *v2;

  v1 = a1;
  v2 = -[HDKeyValueDomain initWithCategory:domainName:profile:]([HDKeyValueDomain alloc], "initWithCategory:domainName:profile:", 5, CFSTR("CloudSync"), v1);

  return v2;
}

uint64_t HDCloudSyncLastSuccessfulPullKeyForContainerIdentifier(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@%@"), CFSTR("LastSuccessfulPull-"), a1);
}

uint64_t HDCloudSyncLastSuccessfulPushKeyForContainerIdentifier(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@%@"), CFSTR("LastSuccessfulPush-"), a1);
}

uint64_t HDCloudSyncLastSuccessfulLitePushKeyForContainerIdentifier(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@%@"), CFSTR("LastSuccessfulLitePush-"), a1);
}

id HDMostRecentSuccessfulPullDateForProfile(void *a1, _QWORD *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  NSObject *v10;
  uint64_t v11;
  void *v12;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(_QWORD *, void *, uint64_t, _BYTE *);
  void *v17;
  id v18;
  uint64_t *v19;
  __int128 *p_buf;
  id obj;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t, uint64_t);
  void (*v26)(uint64_t);
  id v27;
  __int128 buf;
  uint64_t v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  void (*v31)(uint64_t);
  id v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  HDCloudSyncKeyValueDomainWithProfile(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = 0;
  v23 = &v22;
  v24 = 0x3032000000;
  v25 = __Block_byref_object_copy_;
  v26 = __Block_byref_object_dispose_;
  v27 = 0;
  obj = 0;
  objc_msgSend(v4, "allValuesWithError:", &obj);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_storeStrong(&v27, obj);
  if (v5 || !v23[5])
  {
    objc_msgSend(v5, "allKeys");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "hk_map:", &__block_literal_global);
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v29 = 0x3032000000;
    v30 = __Block_byref_object_copy_;
    v31 = __Block_byref_object_dispose_;
    v32 = 0;
    v14 = MEMORY[0x1E0C809B0];
    v15 = 3221225472;
    v16 = __HDMostRecentSuccessfulPullDateForProfile_block_invoke_2;
    v17 = &unk_1E6CE7928;
    v19 = &v22;
    v18 = v4;
    p_buf = &buf;
    objc_msgSend(v7, "enumerateObjectsUsingBlock:", &v14);
    v8 = (id)v23[5];
    v9 = v8;
    if (v8)
    {
      if (a2)
        *a2 = objc_retainAutorelease(v8);
      else
        _HKLogDroppedError();
    }

    v12 = (void *)objc_msgSend(*(id *)(*((_QWORD *)&buf + 1) + 40), "copy", v14, v15, v16, v17);
    _Block_object_dispose(&buf, 8);

  }
  else
  {
    _HKInitializeLogging();
    v10 = *MEMORY[0x1E0CB5370];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_DEFAULT))
    {
      v11 = v23[5];
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v11;
      _os_log_impl(&dword_1B7802000, v10, OS_LOG_TYPE_DEFAULT, "Could not get keys/values out of cloud sync domain: %{public}@", (uint8_t *)&buf, 0xCu);
    }
    v12 = 0;
  }

  _Block_object_dispose(&v22, 8);
  return v12;
}

void sub_1B785E924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

id HDOldestSampleStartDate(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  void *v5;
  os_log_t *v6;
  NSObject *v7;
  NSObject *v8;
  id v10;
  uint8_t buf[4];
  void *v12;
  __int16 v13;
  id v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  HDCloudSyncProtectedAndSyncedKeyValueDomainWithProfile(v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = 0;
  objc_msgSend(v2, "dateForKey:error:", CFSTR("OldestSampleStartDate"), &v10);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v10;
  v5 = v4;
  v6 = (os_log_t *)MEMORY[0x1E0CB5370];
  if (!v3)
  {
    if (v4)
    {
      _HKInitializeLogging();
      v7 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v12 = v5;
        _os_log_error_impl(&dword_1B7802000, v7, OS_LOG_TYPE_ERROR, "Failed to get persisted oldest sample start date from key value store, Error %{public}@", buf, 0xCu);
      }
    }
  }
  _HKInitializeLogging();
  v8 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543618;
    v12 = v3;
    v13 = 2114;
    v14 = v1;
    _os_log_impl(&dword_1B7802000, v8, OS_LOG_TYPE_DEFAULT, "Retrieving oldest sample start date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }

  return v3;
}

void HDSetOldestSampleStartDate(void *a1, void *a2)
{
  id v3;
  id v4;
  os_log_t *v5;
  NSObject *v6;
  void *v7;
  char v8;
  id v9;
  NSObject *v10;
  id v11;
  uint8_t buf[4];
  id v13;
  __int16 v14;
  id v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  _HKInitializeLogging();
  v5 = (os_log_t *)MEMORY[0x1E0CB5370];
  v6 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543618;
    v13 = v3;
    v14 = 2114;
    v15 = v4;
    _os_log_impl(&dword_1B7802000, v6, OS_LOG_TYPE_DEFAULT, "Setting oldest sample start date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  HDCloudSyncProtectedAndSyncedKeyValueDomainWithProfile(v4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 0;
  v8 = objc_msgSend(v7, "setDate:forKey:error:", v3, CFSTR("OldestSampleStartDate"), &v11);
  v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      v13 = v3;
      v14 = 2114;
      v15 = v9;
      _os_log_error_impl(&dword_1B7802000, v10, OS_LOG_TYPE_ERROR, "Failed to persist oldest sample start date %{public}@ to key value store, Error %{public}@", buf, 0x16u);
    }
  }

}

id HDCloudSyncRestorePhaseSyncCompleteStartDate(void *a1)
{
  void *v1;
  void *v2;
  id v3;
  void *v4;
  NSObject *v5;
  id v7;
  uint8_t buf[4];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  HDCloudSyncKeyValueDomainWithProfile(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = 0;
  objc_msgSend(v1, "dateForKey:error:", CFSTR("CloudSyncRestoreSyncStartDate"), &v7);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v7;
  v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      v5 = *MEMORY[0x1E0CB5370];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v9 = v4;
        _os_log_error_impl(&dword_1B7802000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve cloud sync restore phase sync complete start date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncRestorePhaseSyncCompleteStartDate(void *a1, void *a2)
{
  id v3;
  id v4;
  os_log_t *v5;
  NSObject *v6;
  void *v7;
  char v8;
  id v9;
  NSObject *v10;
  id v11;
  uint8_t buf[4];
  id v13;
  __int16 v14;
  id v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  _HKInitializeLogging();
  v5 = (os_log_t *)MEMORY[0x1E0CB5370];
  v6 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543618;
    v13 = v3;
    v14 = 2114;
    v15 = v4;
    _os_log_impl(&dword_1B7802000, v6, OS_LOG_TYPE_INFO, "Setting cloud sync restore phase sync complete start date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  HDCloudSyncKeyValueDomainWithProfile(v4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 0;
  v8 = objc_msgSend(v7, "setDate:forKey:error:", v3, CFSTR("CloudSyncRestoreSyncStartDate"), &v11);
  v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      v13 = v3;
      v14 = 2114;
      v15 = v9;
      _os_log_error_impl(&dword_1B7802000, v10, OS_LOG_TYPE_ERROR, "Failed to persist cloud sync restore phase sync complete end date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
    }
  }

}

id HDCloudSyncRestorePhaseSyncCompleteEndDate(void *a1)
{
  void *v1;
  void *v2;
  id v3;
  void *v4;
  NSObject *v5;
  id v7;
  uint8_t buf[4];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  HDCloudSyncKeyValueDomainWithProfile(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = 0;
  objc_msgSend(v1, "dateForKey:error:", CFSTR("CloudSyncRestoreSyncEndDate"), &v7);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v7;
  v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      v5 = *MEMORY[0x1E0CB5370];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v9 = v4;
        _os_log_error_impl(&dword_1B7802000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve cloud sync restore phase sync complete end date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncRestorPhaseSyncCompleteEndDate(void *a1, void *a2)
{
  id v3;
  id v4;
  os_log_t *v5;
  NSObject *v6;
  void *v7;
  char v8;
  id v9;
  NSObject *v10;
  id v11;
  uint8_t buf[4];
  id v13;
  __int16 v14;
  id v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  _HKInitializeLogging();
  v5 = (os_log_t *)MEMORY[0x1E0CB5370];
  v6 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543618;
    v13 = v3;
    v14 = 2114;
    v15 = v4;
    _os_log_impl(&dword_1B7802000, v6, OS_LOG_TYPE_INFO, "Setting cloud sync restore phase sync complete end date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  HDCloudSyncKeyValueDomainWithProfile(v4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 0;
  v8 = objc_msgSend(v7, "setDate:forKey:error:", v3, CFSTR("CloudSyncRestoreSyncEndDate"), &v11);
  v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      v13 = v3;
      v14 = 2114;
      v15 = v9;
      _os_log_error_impl(&dword_1B7802000, v10, OS_LOG_TYPE_ERROR, "Failed to persist cloud sync restore phase sync complete end date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
    }
  }

}

id HDCloudSyncRestorePhaseMergeCompleteEndDate(void *a1)
{
  void *v1;
  void *v2;
  id v3;
  void *v4;
  NSObject *v5;
  id v7;
  uint8_t buf[4];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  HDCloudSyncKeyValueDomainWithProfile(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = 0;
  objc_msgSend(v1, "dateForKey:error:", CFSTR("CloudSyncRestoreMergeEndDate"), &v7);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v7;
  v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      v5 = *MEMORY[0x1E0CB5370];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v9 = v4;
        _os_log_error_impl(&dword_1B7802000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve cloud sync restore merge complete end date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncRestorPhaseMergeCompleteEndDate(void *a1, void *a2)
{
  id v3;
  id v4;
  os_log_t *v5;
  NSObject *v6;
  void *v7;
  char v8;
  id v9;
  NSObject *v10;
  id v11;
  uint8_t buf[4];
  id v13;
  __int16 v14;
  id v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  _HKInitializeLogging();
  v5 = (os_log_t *)MEMORY[0x1E0CB5370];
  v6 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543618;
    v13 = v3;
    v14 = 2114;
    v15 = v4;
    _os_log_impl(&dword_1B7802000, v6, OS_LOG_TYPE_INFO, "Setting cloud sync restore phase merge complete end date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  HDCloudSyncKeyValueDomainWithProfile(v4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 0;
  v8 = objc_msgSend(v7, "setDate:forKey:error:", v3, CFSTR("CloudSyncRestoreMergeEndDate"), &v11);
  v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      v13 = v3;
      v14 = 2114;
      v15 = v9;
      _os_log_error_impl(&dword_1B7802000, v10, OS_LOG_TYPE_ERROR, "Failed to persist cloud sync restore phase merge complete end date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
    }
  }

}

void HDUpdateOldestSampleStartDateForProfile(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  int v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  NSObject *v9;
  NSObject *v10;
  id v11;
  uint8_t buf[4];
  id v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(v1, "daemon");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "behavior");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "tinkerModeEnabled");

  if (v4)
  {
    HDOldestSampleStartDate(v1);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = 0;
    +[HDSampleEntity minimumSampleStartDateForProfile:error:](HDSampleEntity, "minimumSampleStartDateForProfile:error:", v1, &v11);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v11;
    if (v6)
    {
      if (v5 && !objc_msgSend(v6, "hk_isBeforeDate:", v5))
        goto LABEL_13;
      v8 = v6;
    }
    else
    {
      _HKInitializeLogging();
      v9 = *MEMORY[0x1E0CB5370];
      v10 = *MEMORY[0x1E0CB5370];
      if (v7)
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          v13 = v7;
          _os_log_error_impl(&dword_1B7802000, v9, OS_LOG_TYPE_ERROR, "Error fetching oldest sample date %{public}@", buf, 0xCu);
        }
        goto LABEL_13;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B7802000, v9, OS_LOG_TYPE_DEFAULT, "Setting oldest sample date to nil.", buf, 2u);
      }
      v8 = 0;
    }
    HDSetOldestSampleStartDate(v8, v1);
LABEL_13:

  }
}

id HDCloudSyncLastPulledUpdateDate(void *a1)
{
  void *v1;
  void *v2;
  id v3;
  void *v4;
  NSObject *v5;
  id v7;
  uint8_t buf[4];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  HDCloudSyncKeyValueDomainWithProfile(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = 0;
  objc_msgSend(v1, "dateForKey:error:", CFSTR("HDCloudSyncLastPulledUpdateDate"), &v7);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v7;
  v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      v5 = *MEMORY[0x1E0CB5370];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v9 = v4;
        _os_log_error_impl(&dword_1B7802000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve most recent tinker update date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDCloudSyncDidPullUpdateWithDate(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  id v6;
  id v7;
  BOOL v8;
  id v9;
  NSObject *v10;
  _QWORD v11[4];
  id v12;
  id v13;
  id v14;
  uint8_t buf[4];
  id v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  objc_msgSend(v4, "database");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = 0;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = __HDCloudSyncDidPullUpdateWithDate_block_invoke;
  v11[3] = &unk_1E6CE7950;
  v6 = v4;
  v12 = v6;
  v7 = v3;
  v13 = v7;
  v8 = +[HDHealthEntity performWriteTransactionWithHealthDatabase:error:block:](HDUnprotectedKeyValueEntity, "performWriteTransactionWithHealthDatabase:error:block:", v5, &v14, v11);
  v9 = v14;

  if (!v8)
  {
    _HKInitializeLogging();
    v10 = *MEMORY[0x1E0CB5370];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v16 = v9;
      _os_log_error_impl(&dword_1B7802000, v10, OS_LOG_TYPE_ERROR, "Failed to update most recent tinker update date from key value store, Error: %{public}@", buf, 0xCu);
    }
  }

}

id HDCloudSyncLastSuccessfulPushDateForCoordinatedSync(void *a1)
{
  void *v1;
  void *v2;
  id v3;
  void *v4;
  NSObject *v5;
  id v7;
  uint8_t buf[4];
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  HDCloudSyncUnprotectedAndSyncedKeyValueDomainWithProfile(a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = 0;
  objc_msgSend(v1, "dateForKey:error:", CFSTR("LastSuccessfulPushForCoordinatedSync"), &v7);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v7;
  v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      v5 = *MEMORY[0x1E0CB5370];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v9 = v4;
        _os_log_error_impl(&dword_1B7802000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve last successful push date for coordinated sync from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncLastSuccessfulPushDateForCoordinatedSync(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  int v7;
  os_log_t *v8;
  NSObject *v9;
  void *v10;
  char v11;
  id v12;
  NSObject *v13;
  id v14;
  uint8_t buf[4];
  id v16;
  __int16 v17;
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  objc_msgSend(v4, "daemon");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "behavior");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "supportsCoordinatedCloudSync");

  if (v7)
  {
    _HKInitializeLogging();
    v8 = (os_log_t *)MEMORY[0x1E0CB5370];
    v9 = *MEMORY[0x1E0CB5370];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138543618;
      v16 = v3;
      v17 = 2114;
      v18 = v4;
      _os_log_impl(&dword_1B7802000, v9, OS_LOG_TYPE_INFO, "Recording successful push for coordinated sync, date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
    }
    HDCloudSyncUnprotectedAndSyncedKeyValueDomainWithProfile(v4);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = 0;
    v11 = objc_msgSend(v10, "setDate:forKey:error:", v3, CFSTR("LastSuccessfulPushForCoordinatedSync"), &v14);
    v12 = v14;
    if ((v11 & 1) == 0)
    {
      _HKInitializeLogging();
      v13 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543618;
        v16 = v3;
        v17 = 2114;
        v18 = v12;
        _os_log_error_impl(&dword_1B7802000, v13, OS_LOG_TYPE_ERROR, "Failed to persist successful push for coordinated sync, date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
      }
    }

  }
}

id HDCloudSyncAttachmentManagementUUID(void *a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;

  HDCloudSyncKeyValueDomainWithProfile(a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "stringForKey:error:", CFSTR("CloudSyncAttachmentManagement"), a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDString:", v4);

  return v5;
}

uint64_t HDSetCloudSyncAttachmentManagementUUID(void *a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;

  v5 = a1;
  HDCloudSyncKeyValueDomainWithProfile(a2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "UUIDString");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = objc_msgSend(v6, "setString:forKey:error:", v7, CFSTR("CloudSyncAttachmentManagement"), a3);
  return v8;
}

uint64_t HDCloudSyncAttachmentReferenceEpoch(void *a1, uint64_t a2)
{
  void *v3;
  void *v4;
  uint64_t v5;

  HDCloudSyncKeyValueDomainWithProfile(a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "numberForKey:error:", CFSTR("CloudSyncAttachmentReferenceEpoch"), a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "longLongValue");

  return v5;
}

uint64_t HDSetCloudSyncAttachmentReferenceEpoch(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  uint64_t v7;

  HDCloudSyncKeyValueDomainWithProfile(a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v5, "setNumber:forKey:error:", v6, CFSTR("CloudSyncAttachmentReferenceEpoch"), a3);

  return v7;
}

uint64_t HDCloudSyncAttachmentReferenceTombstoneEpoch(void *a1, uint64_t a2)
{
  void *v3;
  void *v4;
  uint64_t v5;

  HDCloudSyncKeyValueDomainWithProfile(a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "numberForKey:error:", CFSTR("CloudSyncAttachmentReferenceTombstoneEpoch"), a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "longLongValue");

  return v5;
}

uint64_t HDSetCloudSyncAttachmentReferenceTombstoneEpoch(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  uint64_t v7;

  HDCloudSyncKeyValueDomainWithProfile(a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v5, "setNumber:forKey:error:", v6, CFSTR("CloudSyncAttachmentReferenceTombstoneEpoch"), a3);

  return v7;
}

uint64_t HDUpgradedToSyncIdentity(void *a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;

  HDCloudSyncKeyValueDomainWithProfile(a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "numberForKey:error:", CFSTR("CloudSyncUpgradedToSyncIdentity"), a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (v4)
    v6 = objc_msgSend(v4, "BOOLValue");
  else
    v6 = _HDIsUnitTesting != 0;

  return v6;
}

uint64_t HDSetUpgradedToSyncIdentity(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  uint64_t v7;

  HDCloudSyncKeyValueDomainWithProfile(a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", a1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v5, "setNumber:forKey:error:", v6, CFSTR("CloudSyncUpgradedToSyncIdentity"), a3);

  return v7;
}

uint64_t HDCompletedTransitionToSyncIdentity(void *a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;

  HDCloudSyncKeyValueDomainWithProfile(a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "numberForKey:error:", CFSTR("CloudSyncCompletedTransitionToSyncIdentity"), a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (v4)
    v6 = objc_msgSend(v4, "BOOLValue");
  else
    v6 = 0;

  return v6;
}

uint64_t HDSetCompletedTransitionToSyncIdentity(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  uint64_t v7;

  HDCloudSyncKeyValueDomainWithProfile(a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", a1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v5, "setNumber:forKey:error:", v6, CFSTR("CloudSyncCompletedTransitionToSyncIdentity"), a3);

  return v7;
}

__CFString *HDCKAcceptanceStatusToString(unint64_t a1)
{
  if (a1 < 4)
    return off_1E6CE7A40[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("unknown status(%ld)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

__CFString *HDCKPermissionToString(unint64_t a1)
{
  if (a1 < 4)
    return off_1E6CE7A60[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("unknown permission (%ld)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

__CFString *HDCKRoleToString(unint64_t a1)
{
  __CFString *v1;

  if (a1 < 5 && ((0x1Bu >> a1) & 1) != 0)
  {
    v1 = off_1E6CE7A80[a1];
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("unknown role (%ld)"), a1);
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  return v1;
}

uint64_t HDOptionsForRequest(void *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  objc_msgSend(a1, "changesSyncRequest");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v1;
  if (v1)
  {
    if (objc_msgSend(v1, "push"))
    {
      if (objc_msgSend(v2, "lite"))
        v3 = 128;
      else
        v3 = 0;
    }
    else
    {
      v3 = 0;
    }
    if (objc_msgSend(v2, "pull") && objc_msgSend(v2, "lite"))
      v3 |= 0x1000uLL;
    if (!objc_msgSend(v2, "push"))
      v3 |= 4uLL;
    if (!objc_msgSend(v2, "pull"))
      v3 |= 2uLL;
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1B7860E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{

}

void sub_1B786143C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78615D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _allEventCollectorClasses()
{
  _QWORD v1[4];

  v1[3] = *MEMORY[0x1E0C80C00];
  v1[0] = objc_opt_class();
  v1[1] = objc_opt_class();
  v1[2] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v1, 3);
  return (id)objc_claimAutoreleasedReturnValue();
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{

}

void sub_1B7863C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7864184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1B7864B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  uint64_t v54;

  _Block_object_dispose(&a54, 8);
  _Block_object_dispose((const void *)(v54 - 216), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{

}

__CFString *HDWorkoutDataDestinationStateToString(unint64_t a1)
{
  if (a1 < 5)
    return off_1E6CE7F88[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("unknown(%ld)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

uint64_t HDCodableMedicalIDAllergyReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  void *v18;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(void **)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v17;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{

}

void sub_1B7869570(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{

}

void sub_1B786A914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id HDCloudSyncRecordClassForRecord(void *a1, _QWORD *a2)
{
  id v3;
  void *v4;
  id v6;

  v3 = a1;
  if (+[HDCloudSyncSubscriptionRecord isSubscriptionRecord:](HDCloudSyncSubscriptionRecord, "isSubscriptionRecord:", v3)|| +[HDCloudSyncRegistryRecord isRegistryRecord:](HDCloudSyncRegistryRecord, "isRegistryRecord:", v3)|| +[HDCloudSyncMasterRecord isMasterRecord:](HDCloudSyncMasterRecord, "isMasterRecord:", v3)|| +[HDCloudSyncStoreRecord isStoreRecord:](HDCloudSyncStoreRecord, "isStoreRecord:", v3)|| +[HDCloudSyncSequenceRecord isSequenceRecord:](HDCloudSyncSequenceRecord, "isSequenceRecord:", v3)|| +[HDCloudSyncChangeRecord isChangeRecord:](HDCloudSyncChangeRecord, "isChangeRecord:", v3)|| +[HDCloudSyncMedicalIDRecord isMedicalIDRecord:](HDCloudSyncMedicalIDRecord, "isMedicalIDRecord:", v3)|| +[HDCloudSyncSharedSummaryParticipantRecord isParticipantRecord:](HDCloudSyncSharedSummaryParticipantRecord, "isParticipantRecord:", v3)|| +[HDCloudSyncSharedSummaryAuthorizationRecord isAuthorizationRecord:](HDCloudSyncSharedSummaryAuthorizationRecord, "isAuthorizationRecord:",
         v3)
    || +[HDCloudSyncSharedSummaryTransactionRecord isTransactionRecord:](HDCloudSyncSharedSummaryTransactionRecord, "isTransactionRecord:", v3)|| +[HDCloudSyncSharedSummaryRecord isSummaryRecord:](HDCloudSyncSharedSummaryRecord, "isSummaryRecord:", v3)|| +[HDCloudSyncStateRecord isStateRecord:](HDCloudSyncStateRecord, "isStateRecord:", v3)|| +[HDCloudSyncDeviceContextRecord isDeviceContextRecord:](HDCloudSyncDeviceContextRecord, "isDeviceContextRecord:", v3)|| +[HDCloudSyncDeviceKeyValueRecord isDeviceKeyValueRecord:](HDCloudSyncDeviceKeyValueRecord, "isDeviceKeyValueRecord:", v3)|| +[HDCloudSyncAttachmentManagementRecord isAttachmentManagementRecord:](HDCloudSyncAttachmentManagementRecord, "isAttachmentManagementRecord:",
         v3)
    || +[HDCloudSyncAttachmentRecord isAttachmentRecord:](HDCloudSyncAttachmentRecord, "isAttachmentRecord:", v3)|| +[HDCloudSyncAttachmentReferenceRecord isAttachmentReferenceRecord:](HDCloudSyncAttachmentReferenceRecord, "isAttachmentReferenceRecord:", v3)|| +[HDCloudSyncAttachmentReferenceTombstoneRecord isAttachmentReferenceTombstoneRecord:](HDCloudSyncAttachmentReferenceTombstoneRecord, "isAttachmentReferenceTombstoneRecord:", v3))
  {
    objc_opt_class();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB35C8], "hk_error:format:", 713, CFSTR("Record %@ does not appear to be of any known class"), v3);
    v6 = (id)objc_claimAutoreleasedReturnValue();
    if (v6)
    {
      if (a2)
        *a2 = objc_retainAutorelease(v6);
      else
        _HKLogDroppedError();
    }

    v4 = 0;
  }

  return v4;
}

void sub_1B786CF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{

}

uint64_t HDCodableOntologyLocalizedEducationContentReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableOntologyLocalizedEducationContentSection *v18;
  uint64_t result;
  char v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char v36;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v18 = objc_alloc_init(HDCodableOntologyLocalizedEducationContentSection);
          objc_msgSend((id)a1, "addSections:", v18);
          if (PBReaderPlaceMark()
            && (HDCodableOntologyLocalizedEducationContentSectionReadFrom((uint64_t)v18, a2) & 1) != 0)
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          v20 = 0;
          v21 = 0;
          v22 = 0;
          *(_BYTE *)(a1 + 36) |= 2u;
          while (1)
          {
            v23 = *v3;
            v24 = *(_QWORD *)(a2 + v23);
            v25 = v24 + 1;
            if (v24 == -1 || v25 > *(_QWORD *)(a2 + *v4))
              break;
            v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v24);
            *(_QWORD *)(a2 + v23) = v25;
            v22 |= (unint64_t)(v26 & 0x7F) << v20;
            if ((v26 & 0x80) == 0)
              goto LABEL_42;
            v20 += 7;
            v15 = v21++ >= 9;
            if (v15)
            {
              v22 = 0;
              goto LABEL_44;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_42:
          if (*(_BYTE *)(a2 + *v5))
            v22 = 0;
LABEL_44:
          *(_QWORD *)(a1 + 16) = v22;
          continue;
        case 3u:
          *(_BYTE *)(a1 + 36) |= 1u;
          v27 = *v3;
          v28 = *(_QWORD *)(a2 + v27);
          if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v29 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v28 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v29 = 0;
          }
          *(_QWORD *)(a1 + 8) = v29;
          continue;
        case 4u:
          v30 = 0;
          v31 = 0;
          v32 = 0;
          *(_BYTE *)(a1 + 36) |= 4u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v33 = *v3;
        v34 = *(_QWORD *)(a2 + v33);
        v35 = v34 + 1;
        if (v34 == -1 || v35 > *(_QWORD *)(a2 + *v4))
          break;
        v36 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v34);
        *(_QWORD *)(a2 + v33) = v35;
        v32 |= (unint64_t)(v36 & 0x7F) << v30;
        if ((v36 & 0x80) == 0)
          goto LABEL_46;
        v30 += 7;
        v15 = v31++ >= 9;
        if (v15)
        {
          v32 = 0;
          goto LABEL_48;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_46:
      if (*(_BYTE *)(a2 + *v5))
        v32 = 0;
LABEL_48:
      *(_BYTE *)(a1 + 32) = v32 != 0;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDStatisticsCumulative::addSample(uint64_t this, const HDRawQuantitySample *a2, int a3)
{
  *(double *)this = a2->var0 + *(double *)this;
  if (a3)
    ++*(_QWORD *)(this + 8);
  return this;
}

__n128 HDStatisticsCumulative::updateMostRecentSample(__n128 *this, const HDRawQuantitySample *a2)
{
  __n128 result;
  __n128 v3;

  if (!this[3].n128_u8[0] || (result.n128_u64[0] = this[1].n128_u64[1], result.n128_f64[0] <= a2->var1))
  {
    result = *(__n128 *)&a2->var0;
    v3 = *(__n128 *)&a2->var2;
    this[3].n128_u16[0] = *(_WORD *)&a2->var4;
    this[1] = result;
    this[2] = v3;
  }
  return result;
}

double HDStatisticsCumulative::unarchive@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double result;
  uint64_t v3;
  uint64_t v4;

  *(_WORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  result = *(double *)(a1 + 152);
  *(double *)a2 = result;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(a1 + 112);
  if (v3)
  {
    result = *(double *)(v3 + 8);
    v4 = *(_QWORD *)(v3 + 16);
    *(int8x16_t *)(a2 + 16) = vextq_s8(*(int8x16_t *)(v3 + 24), *(int8x16_t *)(v3 + 24), 8uLL);
    *(double *)(a2 + 32) = result;
    *(_QWORD *)(a2 + 40) = v4;
    *(_BYTE *)(a2 + 48) = 1;
  }
  return result;
}

void HDStatisticsCumulative::archive(int8x16_t *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  _QWORD v6[3];
  int8x16_t v7;
  __int16 v8;
  char v9;
  int v10;

  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  v4 = (uint64_t *)(a2 + 112);
  *(_QWORD *)(a2 + 160) = 0;
  *(_QWORD *)a2 = &off_1E6CEA528;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 152) = this->i64[0];
  v5 = this->i64[1];
  *(_DWORD *)(a2 + 204) = 1025;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = v5;
  statistics::Statistics::makeMostRecentDatum((_QWORD *)a2);
  v6[0] = &off_1E6CFF278;
  v10 = 127;
  v7 = vextq_s8(this[1], this[1], 8uLL);
  v6[1] = this[2].i64[0];
  v6[2] = this[2].i64[1];
  v8 = 0;
  v9 = 0;
  statistics::RawQuantitySample::operator=(*v4, (uint64_t)v6);
  PB::Base::~Base((PB::Base *)v6);
}

void sub_1B786E7A8(_Unwind_Exception *a1)
{
  statistics::Statistics *v1;

  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

const __CFString *NSStringForRapportSchemaIdentifier(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  if (a1 != 1)
    return CFSTR("HKMirroredWorkoutSession");
  objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("Cannot use HDRapportSchemaIdentifierCount"), v1, v2);
  return 0;
}

void __watchOSSortedBuildStrings_block_invoke()
{
  void *v0;

  v0 = (void *)qword_1ED552190;
  qword_1ED552190 = (uint64_t)&unk_1E6DF88A0;

}

void sub_1B78706A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{

}

void sub_1B7870B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1B7873D90(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__7(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{

}

void sub_1B78743A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDPredicateForDatabaseIDAndRecordZone(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  void *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  _QWORD v21[4];

  v21[3] = *MEMORY[0x1E0C80C00];
  v5 = (void *)MEMORY[0x1E0D29838];
  v6 = (void *)MEMORY[0x1E0CB37E8];
  v7 = a3;
  v8 = a2;
  objc_msgSend(v6, "numberWithLongLong:", a1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "predicateWithProperty:equalToValue:", CFSTR("database_id"), v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  v11 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForString();
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v11, "predicateWithProperty:equalToValue:", CFSTR("zone_name"), v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  v14 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForString();
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v14, "predicateWithProperty:equalToValue:", CFSTR("owner_name"), v15);
  v16 = (void *)objc_claimAutoreleasedReturnValue();

  v17 = (void *)MEMORY[0x1E0D29840];
  v21[0] = v10;
  v21[1] = v13;
  v21[2] = v16;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v21, 3);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "predicateMatchingAllPredicates:", v18);
  v19 = (void *)objc_claimAutoreleasedReturnValue();

  return v19;
}

void sub_1B7876C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__8(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8(uint64_t a1)
{

}

id HDPredicateForDatabaseID(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:equalToValue:", CFSTR("database_id"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1B7877740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1B7879770(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__9(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__9(uint64_t a1)
{

}

uint64_t HDCodableLocationDatumReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  unint64_t v7;
  unint64_t v8;
  int *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  BOOL v27;
  int v28;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t result;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char v64;
  uint64_t v65;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = 0x1EF182000uLL;
    v8 = 0x1EF182000uLL;
    v9 = (int *)MEMORY[0x1E0D82BB8];
    v10 = 0x1EF182000uLL;
    v11 = 0x1EF182000uLL;
    v12 = 0x1EF182000uLL;
    v13 = 0x1EF182000uLL;
    v14 = 0x1EF182000uLL;
    v15 = 0x1EF182000uLL;
    v16 = 0x1EF182000uLL;
    v17 = 0x1EF182000uLL;
    v18 = 0x1EF182000uLL;
    v19 = 0x1EF182000uLL;
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      while (1)
      {
        v23 = *v3;
        v24 = *(_QWORD *)(a2 + v23);
        v25 = v24 + 1;
        if (v24 == -1 || v25 > *(_QWORD *)(a2 + *v4))
          break;
        v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v24);
        *(_QWORD *)(a2 + v23) = v25;
        v22 |= (unint64_t)(v26 & 0x7F) << v20;
        if ((v26 & 0x80) == 0)
          goto LABEL_12;
        v20 += 7;
        v27 = v21++ >= 9;
        if (v27)
        {
          v22 = 0;
          v28 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v28 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v22 = 0;
LABEL_14:
      if (v28 || (v22 & 7) == 4)
        break;
      switch((v22 >> 3))
      {
        case 1u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 0x100u;
          v30 = *v3;
          v31 = *(_QWORD *)(a2 + v30);
          if (v31 <= 0xFFFFFFFFFFFFFFF7 && v31 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v31);
            *(_QWORD *)(a2 + v30) = v31 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v8 + 3156);
          goto LABEL_82;
        case 2u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 0x10u;
          v40 = *v3;
          v41 = *(_QWORD *)(a2 + v40);
          if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v41);
            *(_QWORD *)(a2 + v40) = v41 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v10 + 3160);
          goto LABEL_82;
        case 3u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 0x20u;
          v42 = *v3;
          v43 = *(_QWORD *)(a2 + v42);
          if (v43 <= 0xFFFFFFFFFFFFFFF7 && v43 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v43);
            *(_QWORD *)(a2 + v42) = v43 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v11 + 3164);
          goto LABEL_82;
        case 4u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 1u;
          v44 = *v3;
          v45 = *(_QWORD *)(a2 + v44);
          if (v45 <= 0xFFFFFFFFFFFFFFF7 && v45 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v45);
            *(_QWORD *)(a2 + v44) = v45 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v12 + 3168);
          goto LABEL_82;
        case 5u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 0x40u;
          v46 = *v3;
          v47 = *(_QWORD *)(a2 + v46);
          if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v47);
            *(_QWORD *)(a2 + v46) = v47 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v13 + 3172);
          goto LABEL_82;
        case 6u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 2u;
          v48 = *v3;
          v49 = *(_QWORD *)(a2 + v48);
          if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v49);
            *(_QWORD *)(a2 + v48) = v49 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v14 + 3176);
          goto LABEL_82;
        case 7u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 8u;
          v50 = *v3;
          v51 = *(_QWORD *)(a2 + v50);
          if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v51);
            *(_QWORD *)(a2 + v50) = v51 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v15 + 3180);
          goto LABEL_82;
        case 8u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 0x200u;
          v52 = *v3;
          v53 = *(_QWORD *)(a2 + v52);
          if (v53 <= 0xFFFFFFFFFFFFFFF7 && v53 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v53);
            *(_QWORD *)(a2 + v52) = v53 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v16 + 3184);
          goto LABEL_82;
        case 9u:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 0x80u;
          v54 = *v3;
          v55 = *(_QWORD *)(a2 + v54);
          if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v55);
            *(_QWORD *)(a2 + v54) = v55 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v17 + 3188);
          goto LABEL_82;
        case 0xAu:
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 4u;
          v56 = *v3;
          v57 = *(_QWORD *)(a2 + v56);
          if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v57);
            *(_QWORD *)(a2 + v56) = v57 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v32 = 0;
          }
          v65 = *(int *)(v18 + 3192);
LABEL_82:
          *(_QWORD *)(a1 + v65) = v32;
          continue;
        case 0xBu:
          v58 = 0;
          v59 = 0;
          v60 = 0;
          *(_WORD *)(a1 + *(int *)(v7 + 3152)) |= 0x400u;
          break;
        default:
          v33 = v8;
          v34 = v10;
          v35 = v7;
          v36 = v11;
          v37 = v12;
          v38 = a1;
          result = PBReaderSkipValueWithTag();
          v19 = 0x1EF182000;
          a1 = v38;
          v13 = 0x1EF182000;
          v5 = (int *)MEMORY[0x1E0D82BC8];
          v12 = v37;
          v14 = 0x1EF182000;
          v11 = v36;
          v15 = 0x1EF182000;
          v7 = v35;
          v18 = 0x1EF182000;
          v10 = v34;
          v16 = 0x1EF182000;
          v8 = v33;
          v17 = 0x1EF182000;
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v61 = *v3;
        v62 = *(_QWORD *)(a2 + v61);
        v63 = v62 + 1;
        if (v62 == -1 || v63 > *(_QWORD *)(a2 + *v4))
          break;
        v64 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v62);
        *(_QWORD *)(a2 + v61) = v63;
        v60 |= (unint64_t)(v64 & 0x7F) << v58;
        if ((v64 & 0x80) == 0)
          goto LABEL_59;
        v58 += 7;
        v27 = v59++ >= 9;
        if (v27)
        {
          LODWORD(v60) = 0;
          goto LABEL_61;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_59:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v60) = 0;
LABEL_61:
      *(_DWORD *)(a1 + *(int *)(v19 + 3196)) = v60;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCloudSyncCodableDeviceKeyValueReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableSyncIdentity *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char v32;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v18 = objc_alloc_init(HDCodableSyncIdentity);
          objc_storeStrong((id *)(a1 + 40), v18);
          if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v18, a2))
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 24;
          goto LABEL_27;
        case 3u:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 32;
          goto LABEL_27;
        case 4u:
          PBReaderReadData();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 48;
LABEL_27:
          v22 = *(void **)(a1 + v21);
          *(_QWORD *)(a1 + v21) = v20;

          continue;
        case 5u:
          *(_BYTE *)(a1 + 56) |= 1u;
          v23 = *v3;
          v24 = *(_QWORD *)(a2 + v23);
          if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v25 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v24);
            *(_QWORD *)(a2 + v23) = v24 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v25 = 0;
          }
          *(_QWORD *)(a1 + 8) = v25;
          continue;
        case 6u:
          v26 = 0;
          v27 = 0;
          v28 = 0;
          *(_BYTE *)(a1 + 56) |= 2u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v29 = *v3;
        v30 = *(_QWORD *)(a2 + v29);
        v31 = v30 + 1;
        if (v30 == -1 || v31 > *(_QWORD *)(a2 + *v4))
          break;
        v32 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v30);
        *(_QWORD *)(a2 + v29) = v31;
        v28 |= (unint64_t)(v32 & 0x7F) << v26;
        if ((v32 & 0x80) == 0)
          goto LABEL_39;
        v26 += 7;
        v15 = v27++ >= 9;
        if (v15)
        {
          v28 = 0;
          goto LABEL_41;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_39:
      if (*(_BYTE *)(a2 + *v5))
        v28 = 0;
LABEL_41:
      *(_QWORD *)(a1 + 16) = v28;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableRoutineLocationReadFrom(_DWORD *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  unint64_t v7;
  unint64_t v8;
  int *v9;
  unint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  int v19;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t result;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  void *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  HDCodableRoutineLocationVisit *v44;
  uint64_t v45;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = 0x1EF182000uLL;
  v8 = 0x1EF182000uLL;
  v9 = (int *)MEMORY[0x1E0D82BB8];
  v10 = 0x1EF182000uLL;
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    while (1)
    {
      v14 = *v3;
      v15 = *(_QWORD *)(a2 + v14);
      v16 = v15 + 1;
      if (v15 == -1 || v16 > *(_QWORD *)(a2 + *v4))
        break;
      v17 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v15);
      *(_QWORD *)(a2 + v14) = v16;
      v13 |= (unint64_t)(v17 & 0x7F) << v11;
      if ((v17 & 0x80) == 0)
        goto LABEL_12;
      v11 += 7;
      v18 = v12++ >= 9;
      if (v18)
      {
        v13 = 0;
        v19 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v19 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v13 = 0;
LABEL_14:
    if (v19 || (v13 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v13 >> 3))
    {
      case 1u:
        *((_BYTE *)a1 + *(int *)(v7 + 3244)) |= 2u;
        v21 = *v3;
        v22 = *(_QWORD *)(a2 + v21);
        if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v23 = 0;
        }
        v45 = *(int *)(v8 + 3248);
        goto LABEL_58;
      case 2u:
        *((_BYTE *)a1 + *(int *)(v7 + 3244)) |= 4u;
        v25 = *v3;
        v26 = *(_QWORD *)(a2 + v25);
        if (v26 <= 0xFFFFFFFFFFFFFFF7 && v26 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v26);
          *(_QWORD *)(a2 + v25) = v26 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v23 = 0;
        }
        v45 = *(int *)(v10 + 3252);
        goto LABEL_58;
      case 3u:
        *((_BYTE *)a1 + *(int *)(v7 + 3244)) |= 8u;
        v27 = *v3;
        v28 = *(_QWORD *)(a2 + v27);
        if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v28);
          *(_QWORD *)(a2 + v27) = v28 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v23 = 0;
        }
        v45 = 32;
        goto LABEL_58;
      case 4u:
        *((_BYTE *)a1 + *(int *)(v7 + 3244)) |= 1u;
        v29 = *v3;
        v30 = *(_QWORD *)(a2 + v29);
        if (v30 <= 0xFFFFFFFFFFFFFFF7 && v30 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v30);
          *(_QWORD *)(a2 + v29) = v30 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v23 = 0;
        }
        v45 = 8;
LABEL_58:
        *(_QWORD *)((char *)a1 + v45) = v23;
        goto LABEL_59;
      case 5u:
        PBReaderReadString();
        v31 = objc_claimAutoreleasedReturnValue();
        v32 = 14;
        goto LABEL_42;
      case 6u:
        v33 = 0;
        v34 = 0;
        v35 = 0;
        *((_BYTE *)a1 + *(int *)(v7 + 3244)) |= 0x10u;
        while (2)
        {
          v36 = *v3;
          v37 = *(_QWORD *)(a2 + v36);
          v38 = v37 + 1;
          if (v37 == -1 || v38 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v39 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v37);
            *(_QWORD *)(a2 + v36) = v38;
            v35 |= (unint64_t)(v39 & 0x7F) << v33;
            if (v39 < 0)
            {
              v33 += 7;
              v18 = v34++ >= 9;
              if (v18)
              {
                LODWORD(v35) = 0;
                goto LABEL_49;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v35) = 0;
LABEL_49:
        a1[12] = v35;
        goto LABEL_59;
      case 7u:
        PBReaderReadData();
        v31 = objc_claimAutoreleasedReturnValue();
        v32 = 10;
LABEL_42:
        v40 = *(void **)&a1[v32];
        *(_QWORD *)&a1[v32] = v31;

        goto LABEL_59;
      case 8u:
        v41 = v10;
        v42 = v7;
        v43 = v8;
        v44 = objc_alloc_init(HDCodableRoutineLocationVisit);
        objc_msgSend(a1, "addVisits:", v44);
        if (PBReaderPlaceMark() && HDCodableRoutineLocationVisitReadFrom((uint64_t)v44, a2))
        {
          PBReaderRecallMark();

          v8 = v43;
          v7 = v42;
          v10 = v41;
LABEL_59:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_59;
    }
  }
}

void sub_1B788077C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 168), 8);
  _Block_object_dispose((const void *)(v11 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableStateOfMindReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  unint64_t v7;
  int *v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  int v19;
  int v20;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  HDCodableSample *v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t result;
  char v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char v50;
  uint64_t v51;
  void *v52;
  char v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char v59;
  char v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char v66;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = 0x1EF182000uLL;
    v8 = (int *)MEMORY[0x1E0D82BB8];
    v9 = 0x1EF182000uLL;
    v10 = 0x1EF182000uLL;
    while (2)
    {
      if (!*(_BYTE *)(a2 + *v5))
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        while (1)
        {
          v14 = *v3;
          v15 = *(_QWORD *)(a2 + v14);
          v16 = v15 + 1;
          if (v15 == -1 || v16 > *(_QWORD *)(a2 + *v4))
            break;
          v17 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v15);
          *(_QWORD *)(a2 + v14) = v16;
          v13 |= (unint64_t)(v17 & 0x7F) << v11;
          if ((v17 & 0x80) == 0)
            goto LABEL_12;
          v11 += 7;
          v18 = v12++ >= 9;
          if (v18)
          {
            v13 = 0;
            v19 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
        v19 = *(unsigned __int8 *)(a2 + *v5);
        if (*(_BYTE *)(a2 + *v5))
          v13 = 0;
LABEL_14:
        v20 = v13 & 7;
        if (!v19 && v20 != 4)
        {
          switch((v13 >> 3))
          {
            case 1u:
              v22 = v10;
              v23 = v9;
              v24 = v7;
              v25 = objc_alloc_init(HDCodableSample);
              objc_storeStrong((id *)(a1 + 80), v25);
              if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v25, a2) & 1) != 0)
              {
                PBReaderRecallMark();

                v7 = v24;
                v9 = v23;
                v10 = v22;
                goto LABEL_84;
              }

              return 0;
            case 2u:
              v26 = 0;
              v27 = 0;
              v28 = 0;
              *(_BYTE *)(a1 + *(int *)(v7 + 3300)) |= 1u;
              while (2)
              {
                v29 = *v3;
                v30 = *(_QWORD *)(a2 + v29);
                v31 = v30 + 1;
                if (v30 == -1 || v31 > *(_QWORD *)(a2 + *v4))
                {
                  *(_BYTE *)(a2 + *v5) = 1;
                }
                else
                {
                  v32 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v30);
                  *(_QWORD *)(a2 + v29) = v31;
                  v28 |= (unint64_t)(v32 & 0x7F) << v26;
                  if (v32 < 0)
                  {
                    v26 += 7;
                    v18 = v27++ >= 9;
                    if (v18)
                    {
                      v28 = 0;
                      goto LABEL_65;
                    }
                    continue;
                  }
                }
                break;
              }
              if (*(_BYTE *)(a2 + *v5))
                v28 = 0;
LABEL_65:
              *(_QWORD *)(a1 + 56) = v28;
              goto LABEL_84;
            case 3u:
              *(_BYTE *)(a1 + *(int *)(v7 + 3300)) |= 2u;
              v33 = *v3;
              v34 = *(_QWORD *)(a2 + v33);
              if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v8) + v34);
                *(_QWORD *)(a2 + v33) = v34 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v35 = 0;
              }
              *(_QWORD *)(a1 + 64) = v35;
              goto LABEL_84;
            case 4u:
              if (v20 != 2)
              {
                v53 = 0;
                v54 = 0;
                v55 = 0;
                while (1)
                {
                  v56 = *v3;
                  v57 = *(_QWORD *)(a2 + v56);
                  v58 = v57 + 1;
                  if (v57 == -1 || v58 > *(_QWORD *)(a2 + *v4))
                    goto LABEL_80;
                  v59 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v57);
                  *(_QWORD *)(a2 + v56) = v58;
                  v55 |= (unint64_t)(v59 & 0x7F) << v53;
                  if (v59 < 0)
                  {
                    v53 += 7;
                    v18 = v54++ >= 9;
                    if (!v18)
                      continue;
                  }
                  goto LABEL_81;
                }
              }
              result = PBReaderPlaceMark();
              if (!(_DWORD)result)
                return result;
              while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4) && !*(_BYTE *)(a2 + *v5))
              {
                v37 = 0;
                v38 = 0;
                v39 = 0;
                while (1)
                {
                  v40 = *v3;
                  v41 = *(_QWORD *)(a2 + v40);
                  v42 = v41 + 1;
                  if (v41 == -1 || v42 > *(_QWORD *)(a2 + *v4))
                    break;
                  v43 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v41);
                  *(_QWORD *)(a2 + v40) = v42;
                  v39 |= (unint64_t)(v43 & 0x7F) << v37;
                  if (v43 < 0)
                  {
                    v37 += 7;
                    v18 = v38++ >= 9;
                    if (!v18)
                      continue;
                  }
                  goto LABEL_44;
                }
                *(_BYTE *)(a2 + *v5) = 1;
LABEL_44:
                PBRepeatedInt64Add();
              }
              goto LABEL_61;
            case 5u:
              if (v20 == 2)
              {
                result = PBReaderPlaceMark();
                if (!(_DWORD)result)
                  return result;
                while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4) && !*(_BYTE *)(a2 + *v5))
                {
                  v44 = 0;
                  v45 = 0;
                  v46 = 0;
                  while (1)
                  {
                    v47 = *v3;
                    v48 = *(_QWORD *)(a2 + v47);
                    v49 = v48 + 1;
                    if (v48 == -1 || v49 > *(_QWORD *)(a2 + *v4))
                      break;
                    v50 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v48);
                    *(_QWORD *)(a2 + v47) = v49;
                    v46 |= (unint64_t)(v50 & 0x7F) << v44;
                    if (v50 < 0)
                    {
                      v44 += 7;
                      v18 = v45++ >= 9;
                      if (!v18)
                        continue;
                    }
                    goto LABEL_57;
                  }
                  *(_BYTE *)(a2 + *v5) = 1;
LABEL_57:
                  PBRepeatedInt64Add();
                }
LABEL_61:
                PBReaderRecallMark();
              }
              else
              {
                v60 = 0;
                v61 = 0;
                v62 = 0;
                while (1)
                {
                  v63 = *v3;
                  v64 = *(_QWORD *)(a2 + v63);
                  v65 = v64 + 1;
                  if (v64 == -1 || v65 > *(_QWORD *)(a2 + *v4))
                    break;
                  v66 = *(_BYTE *)(*(_QWORD *)(a2 + *v8) + v64);
                  *(_QWORD *)(a2 + v63) = v65;
                  v62 |= (unint64_t)(v66 & 0x7F) << v60;
                  if (v66 < 0)
                  {
                    v60 += 7;
                    v18 = v61++ >= 9;
                    if (!v18)
                      continue;
                  }
                  goto LABEL_81;
                }
LABEL_80:
                *(_BYTE *)(a2 + *v5) = 1;
LABEL_81:
                PBRepeatedInt64Add();
              }
LABEL_84:
              if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
                return *(_BYTE *)(a2 + *v5) == 0;
              continue;
            case 7u:
              PBReaderReadString();
              v51 = objc_claimAutoreleasedReturnValue();
              v52 = *(void **)(a1 + 72);
              *(_QWORD *)(a1 + 72) = v51;

              goto LABEL_84;
            default:
              if ((PBReaderSkipValueWithTag() & 1) != 0)
                goto LABEL_84;
              return 0;
          }
        }
      }
      break;
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7884894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a69;
  uint64_t v69;

  _Block_object_dispose(&a69, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  _Block_object_dispose(&STACK[0x230], 8);
  _Block_object_dispose(&STACK[0x260], 8);
  _Block_object_dispose((const void *)(v69 - 192), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__10(uint64_t a1)
{

}

uint64_t HDCodableUserDomainConceptTypeIdentifierReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  uint64_t v17;
  void *v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v19 = 0;
        v20 = 0;
        v21 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          if (v23 == -1 || v23 >= *(_QWORD *)(a2 + *v4))
            break;
          v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
          *(_QWORD *)(a2 + v22) = v23 + 1;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0)
            goto LABEL_31;
          v19 += 7;
          v14 = v20++ >= 9;
          if (v14)
          {
            v21 = 0;
            goto LABEL_33;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_33:
        *(_QWORD *)(a1 + 8) = v21;
      }
      else if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v17;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableDeletedSampleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableSample *v17;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 8), v17);
        if (!PBReaderPlaceMark() || (HDCodableSampleReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDBinnedAnalyticsValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1)
    return 0;
  if (a1 <= a3)
    return a3;
  if (a1 <= a2)
    return (uint64_t)((double)a3 * (double)(a1 / a3));
  a3 = a4;
  if (a1 < a5)
    return (uint64_t)((double)a3 * (double)(a1 / a3));
  return a5;
}

uint64_t HDBucketedDatabaseSizeInMB(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  if (a1 > 99)
  {
    if (a1 == 100)
    {
      return 100;
    }
    else
    {
      if ((unint64_t)a1 < 0x3E9)
      {
        v2 = 100;
      }
      else
      {
        if ((unint64_t)a1 >> 3 > 0x270)
          return 5000;
        v2 = 1000;
      }
      return (uint64_t)((double)v2 * (double)((unsigned __int16)a1 / v2));
    }
  }
  else if (a1)
  {
    v1 = 10;
    if (a1 >= 11)
      return 10 * (a1 / 0xAu);
  }
  else
  {
    return 0;
  }
  return v1;
}

uint64_t HDDatabaseSizeInMB(void *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  objc_msgSend(a1, "database");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "databaseSizeInBytes");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  if (v2)
    v3 = objc_msgSend(v2, "longLongValue") / 0x100000;
  else
    v3 = 0;

  return v3;
}

uint64_t HDDatabaseBucketedSizeInMBForDatabaseType(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  uint64_t v7;

  objc_msgSend(a1, "database");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "databaseSizeInBytesForTypeUnprotected:WAL:", a2, a3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v7 = HDBucketedDatabaseSizeInMB(objc_msgSend(v6, "integerValue") / 0x100000);
  return v7;
}

id HDAnalyticsBucketedNumberOfStandAndIdleHours(void *a1, void *a2, _QWORD *a3)
{
  void *v5;
  uint64_t v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  uint64_t v11;
  id v12;
  BOOL v13;
  id v14;
  id v16;

  v5 = (void *)MEMORY[0x1E0CB6380];
  v6 = *MEMORY[0x1E0CB4880];
  v7 = a2;
  v8 = a1;
  objc_msgSend(v5, "categoryTypeForIdentifier:", v6);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForDateInterval(v7, v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  v16 = 0;
  v11 = +[HDSampleEntity countOfSamplesWithType:profile:matchingPredicate:withError:](HDSampleEntity, "countOfSamplesWithType:profile:matchingPredicate:withError:", v9, v8, v10, &v16);

  v12 = v16;
  if (v11)
    v13 = 1;
  else
    v13 = v12 == 0;
  if (v13)
  {
    if (v11)
    {
      if ((unint64_t)v11 >= 4)
      {
        if ((unint64_t)(v11 - 4) >= 3)
        {
          if ((unint64_t)(v11 - 7) >= 3)
          {
            if ((unint64_t)(v11 - 10) >= 3)
            {
              if ((unint64_t)(v11 - 13) >= 4)
              {
                if ((unint64_t)(v11 - 17) >= 4)
                {
                  if (v11 <= 20)
                    v14 = (id)*MEMORY[0x1E0CB46A8];
                  else
                    v14 = &unk_1E6DFA7D8;
                }
                else
                {
                  v14 = &unk_1E6DFA7C0;
                }
              }
              else
              {
                v14 = &unk_1E6DFA7A8;
              }
            }
            else
            {
              v14 = &unk_1E6DFA790;
            }
          }
          else
          {
            v14 = &unk_1E6DFA778;
          }
        }
        else
        {
          v14 = &unk_1E6DFA760;
        }
      }
      else
      {
        v14 = &unk_1E6DFA748;
      }
    }
    else
    {
      v14 = &unk_1E6DFA730;
    }
  }
  else if (a3)
  {
    v14 = 0;
    *a3 = objc_retainAutorelease(v12);
  }
  else
  {
    _HKLogDroppedError();
    v14 = 0;
  }

  return v14;
}

id HDAnalyticsCountOfSamples(void *a1, void *a2, void *a3, void *a4, _QWORD *a5)
{
  id v9;
  id v10;
  id v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  int64_t v17;
  id v18;
  void *v19;
  BOOL v20;
  void *v21;
  id v23;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a2;
  v11 = a4;
  HDSampleEntityPredicateForDateInterval(a3, v10);
  v12 = objc_claimAutoreleasedReturnValue();
  v13 = (void *)v12;
  if (v11)
  {
    v14 = (void *)MEMORY[0x1E0D29840];
    v24[0] = v12;
    v24[1] = v11;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v24, 2);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "predicateMatchingAllPredicates:", v15);
    v16 = objc_claimAutoreleasedReturnValue();

    v13 = (void *)v16;
  }
  v23 = 0;
  v17 = +[HDSampleEntity countOfSamplesWithType:profile:matchingPredicate:withError:](HDSampleEntity, "countOfSamplesWithType:profile:matchingPredicate:withError:", v10, v9, v13, &v23);
  v18 = v23;
  v19 = v18;
  if (v17)
    v20 = 1;
  else
    v20 = v18 == 0;
  if (v20)
  {
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v17);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else if (a5)
  {
    v21 = 0;
    *a5 = objc_retainAutorelease(v18);
  }
  else
  {
    _HKLogDroppedError();
    v21 = 0;
  }

  return v21;
}

id HDAnalyticsCountOfIntervalsForQuantityType(void *a1, void *a2, void *a3, unint64_t a4, void *a5, void *a6, _QWORD *a7)
{
  void *v9;
  id v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  id v18;
  void *v19;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  id v25;
  _BYTE v26[128];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  HDAnalyticsStatisticsCollectionOfIntervalsForQuantityType(a1, a2, a3, a5, a6, &v25);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = v25;
  v11 = v10;
  if (v9)
  {
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    objc_msgSend(v9, "statistics", 0);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v21, v26, 16);
    if (v13)
    {
      v14 = v13;
      v15 = 0;
      v16 = *(_QWORD *)v22;
      do
      {
        for (i = 0; i != v14; ++i)
        {
          if (*(_QWORD *)v22 != v16)
            objc_enumerationMutation(v12);
          if (objc_msgSend(*(id *)(*((_QWORD *)&v21 + 1) + 8 * i), "dataCount") >= a4)
            ++v15;
        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v21, v26, 16);
      }
      while (v14);
    }
    else
    {
      v15 = 0;
    }

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v15);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v18 = v10;
    if (v18)
    {
      if (a7)
        *a7 = objc_retainAutorelease(v18);
      else
        _HKLogDroppedError();
    }

    v19 = 0;
  }

  return v19;
}

id HDAnalyticsStatisticsCollectionOfIntervalsForQuantityType(void *a1, void *a2, void *a3, void *a4, void *a5, _QWORD *a6)
{
  id v10;
  id v11;
  id v12;
  id v13;
  objc_class *v14;
  id v15;
  id v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  id v25;
  id v26;
  void *v27;
  uint64_t v28;
  id v29;
  id v30;
  void *v31;
  id v32;
  id v33;
  void *v34;
  void *v37;
  id v38;
  _QWORD v39[4];
  id v40;
  _QWORD v41[3];

  v41[2] = *MEMORY[0x1E0C80C00];
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = (objc_class *)MEMORY[0x1E0CB6F60];
  v15 = a1;
  v16 = [v14 alloc];
  objc_msgSend(v12, "startDate");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = objc_msgSend(v16, "initWithAnchorDate:intervalComponents:", v17, v10);

  v37 = (void *)v18;
  +[HDStatisticsCollectionCalculator calculatorForQuantityType:intervalCollection:options:mergeStrategy:](HDStatisticsCollectionCalculator, "calculatorForQuantityType:intervalCollection:options:mergeStrategy:", v11, v18, _HKStatisticsOptionPresence(), 1);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForDateInterval(v12, v11);
  v20 = objc_claimAutoreleasedReturnValue();
  v21 = (void *)v20;
  if (v13)
  {
    v22 = (void *)MEMORY[0x1E0D29840];
    v41[0] = v20;
    v41[1] = v13;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v41, 2);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v22, "predicateMatchingAllPredicates:", v23);
    v24 = objc_claimAutoreleasedReturnValue();

    v21 = (void *)v24;
  }
  v25 = -[HDStatisticsCollectionCalculatorDefaultDataSource initForProfile:quantityType:predicate:restrictedSourceEntities:]([HDStatisticsCollectionCalculatorDefaultDataSource alloc], "initForProfile:quantityType:predicate:restrictedSourceEntities:", v15, v11, v21, 0);

  objc_msgSend(v19, "setDataSource:", v25);
  v26 = objc_alloc(MEMORY[0x1E0CB6C70]);
  objc_msgSend(v12, "startDate");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = objc_msgSend(v26, "initWithAnchorDate:statisticsInterval:", v27, v10);

  v39[0] = MEMORY[0x1E0C809B0];
  v39[1] = 3221225472;
  v39[2] = __HDAnalyticsStatisticsCollectionOfIntervalsForQuantityType_block_invoke;
  v39[3] = &unk_1E6CE97C8;
  v29 = (id)v28;
  v40 = v29;
  objc_msgSend(v19, "setStatisticsHandler:", v39);
  v38 = 0;
  LOBYTE(v28) = objc_msgSend(v19, "queryForInitialStatisticsWithError:", &v38);
  v30 = v38;
  v31 = v30;
  if ((v28 & 1) != 0)
  {
    v32 = v29;
  }
  else
  {
    v33 = v30;
    v34 = v33;
    if (v33)
    {
      if (a6)
        *a6 = objc_retainAutorelease(v33);
      else
        _HKLogDroppedError();
    }

    v32 = 0;
  }

  return v32;
}

id HDAnalyticsCountOfSleepDaysWithStandHoursPriorToDate(void *a1, void *a2, void *a3, uint64_t a4, _QWORD *a5)
{
  void *v9;
  uint64_t v10;
  id v11;
  id v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;

  v9 = (void *)MEMORY[0x1E0CB6380];
  v10 = *MEMORY[0x1E0CB4880];
  v11 = a3;
  v12 = a2;
  v13 = a1;
  objc_msgSend(v9, "categoryTypeForIdentifier:", v10);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "hk_sleepDayStartWithCalendar:", v11);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v11, "dateByAddingUnit:value:toDate:options:", 16, -a4, v15, 0);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = objc_alloc_init(MEMORY[0x1E0C99D78]);
  objc_msgSend(v17, "setCalendar:", v11);

  objc_msgSend(v17, "setDay:", 1);
  v18 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3588]), "initWithStartDate:endDate:", v16, v15);
  HDAnalyticsCountOfIntervalsForCategoryType(v13, v17, v14, v18, a5);
  v19 = (void *)objc_claimAutoreleasedReturnValue();

  return v19;
}

id HDAnalyticsCountOfIntervalsForCategoryType(void *a1, void *a2, void *a3, void *a4, _QWORD *a5)
{
  id v8;
  id v9;
  id v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  id v23;
  id v24;
  void *v25;
  uint64_t v26;
  id v27;
  id v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t i;
  id v36;
  void *v37;
  void *v38;
  void *v41;
  void *v42;
  id v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  void *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  id v54;
  _QWORD v55[4];
  id v56;
  _BYTE v57[128];
  _QWORD v58[8];

  v58[6] = *MEMORY[0x1E0C80C00];
  v43 = a1;
  v48 = a2;
  v8 = a3;
  v9 = a4;
  v10 = objc_alloc(MEMORY[0x1E0CB6F60]);
  objc_msgSend(v9, "startDate");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = objc_msgSend(v10, "initWithAnchorDate:intervalComponents:", v11, v48);

  v49 = v8;
  v46 = (void *)v12;
  +[HDStatisticsCollectionCalculator calculatorForCategoryType:intervalCollection:options:mergeStrategy:](HDStatisticsCollectionCalculator, "calculatorForCategoryType:intervalCollection:options:mergeStrategy:", v8, v12, _HKStatisticsOptionPresence(), 1);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = (void *)MEMORY[0x1E0D29840];
  HDSampleEntityPredicateForDataType(v8);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  v58[0] = v47;
  HDDataEntityPredicateForObjectsFromAppleWatchSources(1);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v58[1] = v44;
  objc_msgSend(v9, "startDate");
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForStartDate(6);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v58[2] = v14;
  objc_msgSend(v9, "endDate");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForStartDate(3);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v58[3] = v16;
  objc_msgSend(v9, "endDate");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForEndDate(4);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v58[4] = v18;
  objc_msgSend(v9, "startDate");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForEndDate(6);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v58[5] = v20;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v58, 6);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "predicateMatchingAllPredicates:", v21);
  v22 = objc_claimAutoreleasedReturnValue();

  v45 = (void *)v22;
  v23 = -[HDStatisticsCollectionCalculatorDefaultDataSource initForProfile:categoryType:predicate:restrictedSourceEntities:]([HDStatisticsCollectionCalculatorDefaultDataSource alloc], "initForProfile:categoryType:predicate:restrictedSourceEntities:", v43, v49, v22, 0);
  objc_msgSend(v42, "setDataSource:", v23);
  v24 = objc_alloc(MEMORY[0x1E0CB6C70]);
  objc_msgSend(v9, "startDate");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = objc_msgSend(v24, "initWithAnchorDate:statisticsInterval:", v25, v48);

  v55[0] = MEMORY[0x1E0C809B0];
  v55[1] = 3221225472;
  v55[2] = __HDAnalyticsCountOfIntervalsForCategoryType_block_invoke;
  v55[3] = &unk_1E6CE97C8;
  v27 = (id)v26;
  v56 = v27;
  objc_msgSend(v42, "setStatisticsHandler:", v55);
  v54 = 0;
  LOBYTE(v26) = objc_msgSend(v42, "queryForInitialStatisticsWithError:", &v54);
  v28 = v54;
  v29 = v28;
  if ((v26 & 1) != 0)
  {
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    objc_msgSend(v27, "statistics");
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v31 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v50, v57, 16);
    if (v31)
    {
      v32 = v31;
      v33 = 0;
      v34 = *(_QWORD *)v51;
      do
      {
        for (i = 0; i != v32; ++i)
        {
          if (*(_QWORD *)v51 != v34)
            objc_enumerationMutation(v30);
          if (objc_msgSend(*(id *)(*((_QWORD *)&v50 + 1) + 8 * i), "dataCount"))
            ++v33;
        }
        v32 = objc_msgSend(v30, "countByEnumeratingWithState:objects:count:", &v50, v57, 16);
      }
      while (v32);
    }
    else
    {
      v33 = 0;
    }

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v33);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v36 = v28;
    v37 = v36;
    if (v36)
    {
      if (a5)
        *a5 = objc_retainAutorelease(v36);
      else
        _HKLogDroppedError();
    }

    v38 = 0;
  }

  return v38;
}

void sub_1B788A5C8(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x220], 8);
  _Unwind_Resume(a1);
}

BOOL HDCloudSyncCodableSharedSummaryTransactionRecordReadFrom(char *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 32;
          goto LABEL_26;
        case 2u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
          goto LABEL_26;
        case 3u:
          PBReaderReadString();
          v19 = (void *)objc_claimAutoreleasedReturnValue();
          if (v19)
            objc_msgSend(a1, "addSummaryIdentifiers:", v19);
          goto LABEL_27;
        case 4u:
          PBReaderReadData();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 8;
LABEL_26:
          v19 = *(void **)&a1[v18];
          *(_QWORD *)&a1[v18] = v17;
LABEL_27:

          goto LABEL_28;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0)
            return 0;
LABEL_28:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          break;
      }
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7890D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  uint64_t v54;

  _Block_object_dispose((const void *)(v54 - 192), 8);
  _Block_object_dispose(&a54, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__11(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{

}

uint64_t HDCloudSyncCodableLogReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  int v16;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        PBReaderReadString();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v21;

      }
      else if ((v10 >> 3) == 1)
      {
        *(_BYTE *)(a1 + 24) |= 1u;
        v18 = *v3;
        v19 = *(_QWORD *)(a2 + v18);
        if (v19 <= 0xFFFFFFFFFFFFFFF7 && v19 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v20 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v19);
          *(_QWORD *)(a2 + v18) = v19 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v20 = 0;
        }
        *(_QWORD *)(a1 + 8) = v20;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableRoutinePredictedLocationReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableRoutineLocation *v18;
  uint64_t result;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  char v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v18 = objc_alloc_init(HDCodableRoutineLocation);
          objc_storeStrong((id *)(a1 + 32), v18);
          if (PBReaderPlaceMark() && (HDCodableRoutineLocationReadFrom(v18, a2) & 1) != 0)
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          *(_BYTE *)(a1 + 48) |= 1u;
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 <= 0xFFFFFFFFFFFFFFF7 && v21 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v21);
            *(_QWORD *)(a2 + v20) = v21 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v22 = 0;
          }
          v41 = 8;
          goto LABEL_58;
        case 3u:
          *(_BYTE *)(a1 + 48) |= 2u;
          v23 = *v3;
          v24 = *(_QWORD *)(a2 + v23);
          if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v24);
            *(_QWORD *)(a2 + v23) = v24 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v22 = 0;
          }
          v41 = 16;
LABEL_58:
          *(_QWORD *)(a1 + v41) = v22;
          continue;
        case 4u:
          v25 = 0;
          v26 = 0;
          v27 = 0;
          *(_BYTE *)(a1 + 48) |= 4u;
          while (2)
          {
            v28 = *v3;
            v29 = *(_QWORD *)(a2 + v28);
            v30 = v29 + 1;
            if (v29 == -1 || v30 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v31 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
              *(_QWORD *)(a2 + v28) = v30;
              v27 |= (unint64_t)(v31 & 0x7F) << v25;
              if (v31 < 0)
              {
                v25 += 7;
                v15 = v26++ >= 9;
                if (v15)
                {
                  LODWORD(v27) = 0;
                  goto LABEL_48;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v27) = 0;
LABEL_48:
          v40 = 40;
          goto LABEL_53;
        case 5u:
          v32 = 0;
          v33 = 0;
          v27 = 0;
          *(_BYTE *)(a1 + 48) |= 8u;
          break;
        case 6u:
          PBReaderReadData();
          v38 = objc_claimAutoreleasedReturnValue();
          v39 = *(void **)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v38;

          continue;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v34 = *v3;
        v35 = *(_QWORD *)(a2 + v34);
        v36 = v35 + 1;
        if (v35 == -1 || v36 > *(_QWORD *)(a2 + *v4))
          break;
        v37 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v35);
        *(_QWORD *)(a2 + v34) = v36;
        v27 |= (unint64_t)(v37 & 0x7F) << v32;
        if ((v37 & 0x80) == 0)
          goto LABEL_50;
        v32 += 7;
        v15 = v33++ >= 9;
        if (v15)
        {
          LODWORD(v27) = 0;
          goto LABEL_52;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_50:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v27) = 0;
LABEL_52:
      v40 = 44;
LABEL_53:
      *(_DWORD *)(a1 + v40) = v27;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7893860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12(uint64_t a1)
{

}

void sub_1B7893FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B789426C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__13(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{

}

void sub_1B7894C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1B78952C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v32;

  _Block_object_dispose(&a32, 8);
  _Block_object_dispose((const void *)(v32 - 152), 8);
  _Unwind_Resume(a1);
}

id HDSharedSummaryMergeAuthorizationIdentifiers(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v5 = (void *)MEMORY[0x1E0C99E20];
  v6 = a3;
  v7 = a2;
  objc_msgSend(v5, "setWithArray:", a1);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99E60], "setWithArray:", v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v8, "unionSet:", v9);
  objc_msgSend(MEMORY[0x1E0C99E60], "setWithArray:", v6);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v8, "minusSet:", v10);
  objc_msgSend(v8, "allObjects");
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

id HDCNContactForCodableEntry(void *a1, void *a2)
{
  id v3;
  id v4;
  NSObject *v5;
  void *v6;
  void *v7;
  id v8;
  id v9;
  id v10;
  void *v11;
  int v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  void *v17;
  int v18;
  void *v19;
  id v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  void *v25;
  uint64_t v26;
  NSObject *v27;
  _BOOL4 v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t j;
  void *v39;
  uint64_t v40;
  id v41;
  id v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t k;
  void *v48;
  uint64_t v49;
  void *v50;
  void *v51;
  void *v52;
  id v53;
  id v54;
  NSObject *v55;
  id v57;
  void *v58;
  void *v59;
  id obj;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint8_t v69[16];
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  _BYTE v74[128];
  uint8_t v75[128];
  uint8_t buf[4];
  uint64_t v77;
  __int16 v78;
  void *v79;
  __int16 v80;
  void *v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  _HKInitializeLogging();
  HKLogSharing();
  v5 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    objc_msgSend(v3, "primaryContactIdentifier");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "uuid");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138478083;
    v77 = (uint64_t)v6;
    v78 = 2114;
    v79 = v7;
    _os_log_impl(&dword_1B7802000, v5, OS_LOG_TYPE_DEFAULT, "[summary-sharing] Updating name for entry with identifier %{private}@ and UUID %{public}@", buf, 0x16u);

  }
  v8 = objc_alloc_init(MEMORY[0x1E0C99E20]);
  v9 = v3;
  v10 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  objc_msgSend(v9, "primaryContactIdentifier");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = objc_msgSend(v11, "_appearsToBePhoneNumber");

  if (v12)
  {
    objc_msgSend(v9, "primaryContactIdentifier");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "addObject:", v13);

  }
  v14 = (void *)objc_msgSend(v10, "copy");

  v15 = v9;
  v16 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  objc_msgSend(v15, "primaryContactIdentifier");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = objc_msgSend(v17, "_appearsToBeEmail");

  if (v18)
  {
    objc_msgSend(v15, "primaryContactIdentifier");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "addObject:", v19);

  }
  v59 = (void *)objc_msgSend(v16, "copy");

  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v20 = v14;
  v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v65, v75, 16);
  if (v21)
  {
    v22 = v21;
    v23 = *(_QWORD *)v66;
    do
    {
      for (i = 0; i != v22; ++i)
      {
        if (*(_QWORD *)v66 != v23)
          objc_enumerationMutation(v20);
        _HDContactsForContactIdentifier(*(void **)(*((_QWORD *)&v65 + 1) + 8 * i), v4);
        v25 = (void *)objc_claimAutoreleasedReturnValue();
        if (v25)
          objc_msgSend(v8, "addObjectsFromArray:", v25);

      }
      v22 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v65, v75, 16);
    }
    while (v22);
  }

  v26 = objc_msgSend(v8, "count");
  _HKInitializeLogging();
  HKLogSharing();
  v27 = objc_claimAutoreleasedReturnValue();
  v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
  v58 = v15;
  if (v26)
  {
    if (!v28)
      goto LABEL_34;
    v29 = objc_msgSend(v8, "count");
    objc_msgSend(v15, "primaryContactIdentifier");
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "uuid");
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 134218499;
    v77 = v29;
    v78 = 2113;
    v79 = v30;
    v80 = 2114;
    v81 = v31;
    goto LABEL_33;
  }
  if (v28)
  {
    objc_msgSend(v15, "primaryContactIdentifier");
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "uuid");
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138478083;
    v77 = (uint64_t)v32;
    v78 = 2114;
    v79 = v33;
    _os_log_impl(&dword_1B7802000, v27, OS_LOG_TYPE_DEFAULT, "[summary-sharing] Looking for email address contacts for identifiers %{private}@ and UUID %{public}@", buf, 0x16u);

  }
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v34 = v59;
  v35 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v61, v74, 16);
  if (v35)
  {
    v36 = v35;
    v37 = *(_QWORD *)v62;
    do
    {
      for (j = 0; j != v36; ++j)
      {
        if (*(_QWORD *)v62 != v37)
          objc_enumerationMutation(v34);
        _HDContactsForContactIdentifier(*(void **)(*((_QWORD *)&v61 + 1) + 8 * j), v4);
        v39 = (void *)objc_claimAutoreleasedReturnValue();
        if (v39)
          objc_msgSend(v8, "addObjectsFromArray:", v39);

      }
      v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v61, v74, 16);
    }
    while (v36);
  }

  if (!objc_msgSend(v8, "count"))
  {
    v45 = 0;
    goto LABEL_55;
  }
  _HKInitializeLogging();
  HKLogSharing();
  v27 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    v40 = objc_msgSend(v8, "count");
    objc_msgSend(v58, "primaryContactIdentifier");
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v58, "uuid");
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 134218499;
    v77 = v40;
    v78 = 2113;
    v79 = v30;
    v80 = 2114;
    v81 = v31;
LABEL_33:
    _os_log_impl(&dword_1B7802000, v27, OS_LOG_TYPE_DEFAULT, "[summary-sharing] Found %lu contacts. Finding best match for %{private}@ and UUID %{public}@", buf, 0x20u);

  }
LABEL_34:

  v41 = v8;
  if (objc_msgSend(v41, "count"))
  {
    v72 = 0u;
    v73 = 0u;
    v70 = 0u;
    v71 = 0u;
    v42 = v41;
    v43 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v70, buf, 16);
    if (v43)
    {
      v44 = v43;
      v57 = v41;
      v45 = 0;
      v46 = *(_QWORD *)v71;
      obj = v42;
      while (2)
      {
        for (k = 0; k != v44; ++k)
        {
          if (*(_QWORD *)v71 != v46)
            objc_enumerationMutation(obj);
          v48 = *(void **)(*((_QWORD *)&v70 + 1) + 8 * k);
          objc_msgSend(v48, "givenName", v57);
          v49 = objc_claimAutoreleasedReturnValue();
          if (v49)
          {
            v50 = (void *)v49;
            objc_msgSend(v48, "familyName");
            v51 = (void *)objc_claimAutoreleasedReturnValue();

            if (v51)
            {
              v54 = v48;

              v45 = v54;
              v41 = v57;
              goto LABEL_54;
            }
          }
          objc_msgSend(v48, "givenName");
          v52 = (void *)objc_claimAutoreleasedReturnValue();

          if (v52)
          {
            v53 = v48;

            v45 = v53;
          }
        }
        v42 = obj;
        v44 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v70, buf, 16);
        if (v44)
          continue;
        break;
      }

      v41 = v57;
      if (v45)
        goto LABEL_54;
    }
    else
    {

    }
    _HKInitializeLogging();
    HKLogSharing();
    v55 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v69 = 0;
      _os_log_impl(&dword_1B7802000, v55, OS_LOG_TYPE_DEFAULT, "[summary-sharing] No first name found for any requested contacts.", v69, 2u);
    }

    objc_msgSend(v42, "anyObject");
    v45 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v45 = 0;
  }
LABEL_54:

LABEL_55:
  return v45;
}

id _HDContactsForContactIdentifier(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;
  id v13;
  char v14;
  id v15;
  void *v16;
  NSObject *v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t);
  void *v22;
  id v23;
  id v24;
  uint8_t buf[4];
  id v26;
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = objc_alloc(MEMORY[0x1E0C97210]);
  v6 = *MEMORY[0x1E0C966C0];
  v27[0] = *MEMORY[0x1E0C966D0];
  v27[1] = v6;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v27, 2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = (void *)objc_msgSend(v5, "initWithKeysToFetch:", v7);

  if (objc_msgSend(v3, "_appearsToBeEmail"))
  {
    objc_msgSend(MEMORY[0x1E0C97200], "predicateForContactsMatchingEmailAddress:", v3);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setPredicate:", v9);
  }
  else
  {
    if (!objc_msgSend(v3, "_appearsToBePhoneNumber"))
    {
      v16 = 0;
      goto LABEL_12;
    }
    v10 = (void *)MEMORY[0x1E0C97200];
    objc_msgSend(MEMORY[0x1E0C97398], "phoneNumberWithStringValue:", v3);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "predicateForContactsMatchingPhoneNumber:", v9);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setPredicate:", v11);

  }
  objc_msgSend(v8, "setUnifyResults:", 0);
  v12 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v24 = 0;
  v19 = MEMORY[0x1E0C809B0];
  v20 = 3221225472;
  v21 = ___HDContactsForContactIdentifier_block_invoke;
  v22 = &unk_1E6CEA3A0;
  v13 = v12;
  v23 = v13;
  v14 = objc_msgSend(v4, "enumerateContactsWithFetchRequest:error:usingBlock:", v8, &v24, &v19);
  v15 = v24;
  if ((v14 & 1) != 0)
  {
    v16 = (void *)objc_msgSend(v13, "copy", v19, v20, v21, v22);
  }
  else
  {
    _HKInitializeLogging();
    HKLogSharing();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v26 = v15;
      _os_log_error_impl(&dword_1B7802000, v17, OS_LOG_TYPE_ERROR, "[summary-sharing] Contacts error occured %{public}@", buf, 0xCu);
    }

    v16 = 0;
  }

LABEL_12:
  return v16;
}

uint64_t HDMergedSharingStatus(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  _QWORD *v5;

  result = a2;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = a1;
      if (a2 < 5)
      {
        v5 = &unk_1B7F39690;
        goto LABEL_9;
      }
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = a1;
      if (a2 < 5)
      {
        v5 = &unk_1B7F396E0;
        goto LABEL_9;
      }
      break;
    case 4:
      result = a1;
      if (a2 < 5)
      {
        v5 = &unk_1B7F396B8;
LABEL_9:
        result = v5[a2];
      }
      break;
    default:
      result = a1;
      break;
  }
  return result;
}

uint64_t HDCodableSyncAnchorRangeMapReadFrom(void *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableSyncAnchorRange *v17;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableSyncAnchorRange);
        objc_msgSend(a1, "addAnchorRanges:", v17);
        if (!PBReaderPlaceMark() || (HDCodableSyncAnchorRangeReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t statistics::Statistics::Statistics(uint64_t this)
{
  *(_QWORD *)(this + 72) = 0;
  *(_QWORD *)(this + 80) = 0;
  *(_QWORD *)(this + 64) = 0;
  *(_QWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 204) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)this = &off_1E6CEA528;
  *(_QWORD *)(this + 120) = 0;
  *(_QWORD *)(this + 128) = 0;
  *(_QWORD *)(this + 112) = 0;
  return this;
}

{
  *(_QWORD *)(this + 72) = 0;
  *(_QWORD *)(this + 80) = 0;
  *(_QWORD *)(this + 64) = 0;
  *(_QWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 204) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)this = &off_1E6CEA528;
  *(_QWORD *)(this + 120) = 0;
  *(_QWORD *)(this + 128) = 0;
  *(_QWORD *)(this + 112) = 0;
  return this;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void statistics::Statistics::~Statistics(statistics::Statistics *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void **v8;

  *(_QWORD *)this = &off_1E6CEA528;
  v2 = *((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v8 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v8);
  v6 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v6)
    std::default_delete<std::string>::operator()[abi:ne180100]((uint64_t)this + 16, v6);
  v7 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  PB::Base::~Base(this);
}

{
  statistics::Statistics::~Statistics(this);
  JUMPOUT(0x1BCCAC494);
}

statistics::Statistics *statistics::Statistics::Statistics(statistics::Statistics *this, const statistics::RawQuantitySample **a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  const statistics::RawQuantitySample *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char v19;
  statistics::QuantityOverlapProcessorState *v20;
  statistics::QuantityOverlapProcessorState *v21;
  uint64_t v22;
  int v23;
  char v24;
  const statistics::RawQuantitySample *v25;
  std::string *v26;
  std::string *v27;
  const statistics::RawQuantitySample *v28;
  __int128 v29;
  const statistics::RawQuantitySample *v30;
  const statistics::RawQuantitySample *v31;
  const statistics::RawQuantitySample *v32;
  const statistics::RawQuantitySample *v33;
  const statistics::RawQuantitySample *v34;
  const statistics::RawQuantitySample *v35;
  const statistics::RawQuantitySample *v36;
  const statistics::RawQuantitySample *v37;
  const statistics::RawQuantitySample *v38;
  const statistics::RawQuantitySample *v39;
  const statistics::RawQuantitySample *v40;
  const statistics::RawQuantitySample *v41;
  const statistics::RawQuantitySample *v42;
  uint64_t v43;
  statistics::Statistics *v44;
  uint64_t v45;
  uint64_t v46;
  statistics::Statistics *v47;
  uint64_t v48;
  uint64_t v49;

  *(_QWORD *)this = &off_1E6CEA528;
  *((_QWORD *)this + 1) = 0;
  v4 = (uint64_t *)((char *)this + 8);
  *((_QWORD *)this + 2) = 0;
  v5 = (uint64_t *)((char *)this + 16);
  *((_QWORD *)this + 8) = 0;
  v6 = (uint64_t **)((char *)this + 64);
  *((_QWORD *)this + 14) = 0;
  v7 = (uint64_t *)((char *)this + 112);
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 51) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  if (a2[14])
  {
    v8 = operator new();
    v9 = statistics::RawQuantitySample::RawQuantitySample(v8, a2[14]);
    v10 = *v7;
    *v7 = v9;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  }
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 1) != 0)
  {
    v30 = a2[3];
    *((_DWORD *)this + 51) |= 1u;
    *((_QWORD *)this + 3) = v30;
    v11 = *((_DWORD *)a2 + 51);
    if ((v11 & 0x400) == 0)
    {
LABEL_6:
      if ((v11 & 0x40) == 0)
        goto LABEL_7;
      goto LABEL_39;
    }
  }
  else if ((v11 & 0x400) == 0)
  {
    goto LABEL_6;
  }
  v31 = a2[19];
  *((_DWORD *)this + 51) |= 0x400u;
  *((_QWORD *)this + 19) = v31;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 0x40) == 0)
  {
LABEL_7:
    if ((v11 & 0x80) == 0)
      goto LABEL_8;
    goto LABEL_40;
  }
LABEL_39:
  v32 = a2[12];
  *((_DWORD *)this + 51) |= 0x40u;
  *((_QWORD *)this + 12) = v32;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 0x80) == 0)
  {
LABEL_8:
    if ((v11 & 0x20) == 0)
      goto LABEL_9;
    goto LABEL_41;
  }
LABEL_40:
  v33 = a2[13];
  *((_DWORD *)this + 51) |= 0x80u;
  *((_QWORD *)this + 13) = v33;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 0x20) == 0)
  {
LABEL_9:
    if ((v11 & 0x2000) == 0)
      goto LABEL_10;
    goto LABEL_42;
  }
LABEL_41:
  v34 = a2[11];
  *((_DWORD *)this + 51) |= 0x20u;
  *((_QWORD *)this + 11) = v34;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 0x2000) == 0)
  {
LABEL_10:
    if ((v11 & 0x4000) == 0)
      goto LABEL_11;
    goto LABEL_43;
  }
LABEL_42:
  v35 = a2[23];
  *((_DWORD *)this + 51) |= 0x2000u;
  *((_QWORD *)this + 23) = v35;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 0x4000) == 0)
  {
LABEL_11:
    if ((v11 & 0x10) == 0)
      goto LABEL_12;
    goto LABEL_44;
  }
LABEL_43:
  v36 = a2[24];
  *((_DWORD *)this + 51) |= 0x4000u;
  *((_QWORD *)this + 24) = v36;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 0x10) == 0)
  {
LABEL_12:
    if ((v11 & 8) == 0)
      goto LABEL_13;
    goto LABEL_45;
  }
LABEL_44:
  v37 = a2[7];
  *((_DWORD *)this + 51) |= 0x10u;
  *((_QWORD *)this + 7) = v37;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 8) == 0)
  {
LABEL_13:
    if ((v11 & 4) == 0)
      goto LABEL_14;
    goto LABEL_46;
  }
LABEL_45:
  v38 = a2[6];
  *((_DWORD *)this + 51) |= 8u;
  *((_QWORD *)this + 6) = v38;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 4) == 0)
  {
LABEL_14:
    if ((v11 & 0x800) == 0)
      goto LABEL_15;
LABEL_47:
    v40 = a2[21];
    *((_DWORD *)this + 51) |= 0x800u;
    *((_QWORD *)this + 21) = v40;
    if ((*((_DWORD *)a2 + 51) & 0x1000) == 0)
      goto LABEL_17;
    goto LABEL_16;
  }
LABEL_46:
  v39 = a2[5];
  *((_DWORD *)this + 51) |= 4u;
  *((_QWORD *)this + 5) = v39;
  v11 = *((_DWORD *)a2 + 51);
  if ((v11 & 0x800) != 0)
    goto LABEL_47;
LABEL_15:
  if ((v11 & 0x1000) != 0)
  {
LABEL_16:
    v12 = a2[22];
    *((_DWORD *)this + 51) |= 0x1000u;
    *((_QWORD *)this + 22) = v12;
  }
LABEL_17:
  v13 = (uint64_t *)a2[8];
  v14 = (uint64_t *)a2[9];
  while (v13 != v14)
    PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval const&>(v6, *v13++);
  if (a2[20])
  {
    v15 = operator new();
    v16 = statistics::RawQuantitySample::RawQuantitySample(v15, a2[20]);
    v17 = *((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = v16;
    if (v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  }
  v18 = *((_DWORD *)a2 + 51);
  if ((v18 & 0x100) == 0)
  {
    if ((v18 & 2) == 0)
      goto LABEL_25;
LABEL_50:
    v42 = a2[4];
    *((_DWORD *)this + 51) |= 2u;
    *((_QWORD *)this + 4) = v42;
    if ((*((_DWORD *)a2 + 51) & 0x10000) == 0)
      goto LABEL_27;
    goto LABEL_26;
  }
  v41 = a2[17];
  *((_DWORD *)this + 51) |= 0x100u;
  *((_QWORD *)this + 17) = v41;
  v18 = *((_DWORD *)a2 + 51);
  if ((v18 & 2) != 0)
    goto LABEL_50;
LABEL_25:
  if ((v18 & 0x10000) != 0)
  {
LABEL_26:
    v19 = *((_BYTE *)a2 + 201);
    *((_DWORD *)this + 51) |= 0x10000u;
    *((_BYTE *)this + 201) = v19;
  }
LABEL_27:
  if (a2[15])
  {
    v20 = (statistics::QuantityOverlapProcessorState *)operator new();
    v21 = statistics::QuantityOverlapProcessorState::QuantityOverlapProcessorState(v20, a2[15]);
    v22 = *((_QWORD *)this + 15);
    *((_QWORD *)this + 15) = v21;
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  }
  v23 = *((_DWORD *)a2 + 51);
  if ((v23 & 0x8000) != 0)
  {
    v24 = *((_BYTE *)a2 + 200);
    *((_DWORD *)this + 51) |= 0x8000u;
    *((_BYTE *)this + 200) = v24;
    v23 = *((_DWORD *)a2 + 51);
  }
  if ((v23 & 0x200) != 0)
  {
    v25 = a2[18];
    *((_DWORD *)this + 51) |= 0x200u;
    *((_QWORD *)this + 18) = v25;
  }
  if (a2[2])
  {
    v26 = (std::string *)operator new();
    v27 = v26;
    v28 = a2[2];
    if (*((char *)v28 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v26, *(const std::string::value_type **)v28, *((_QWORD *)v28 + 1));
    }
    else
    {
      v29 = *(_OWORD *)v28;
      v26->__r_.__value_.__r.__words[2] = *((_QWORD *)v28 + 2);
      *(_OWORD *)&v26->__r_.__value_.__l.__data_ = v29;
    }
    v43 = *v5;
    *v5 = (uint64_t)v27;
    if (v43)
      std::default_delete<std::string>::operator()[abi:ne180100]((uint64_t)v5, v43);
  }
  if (a2[16])
  {
    v44 = (statistics::Statistics *)operator new();
    v45 = statistics::Statistics::Statistics(v44, a2[16]);
    v46 = *((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v45;
    if (v46)
      (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
  }
  if (a2[1])
  {
    v47 = (statistics::Statistics *)operator new();
    v48 = statistics::Statistics::Statistics(v47, a2[1]);
    v49 = *v4;
    *v4 = v48;
    if (v49)
      (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
  }
  return this;
}

uint64_t PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval const&>(uint64_t **a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  int64x2_t v24;
  char *v25;
  uint64_t v26;
  int64x2_t v27;
  char *v28;
  _QWORD *v29;

  v4 = operator new();
  v5 = v4;
  *(_QWORD *)v4 = &off_1E6D0A7D0;
  *(_DWORD *)(v4 + 24) = 0;
  v6 = *(_BYTE *)(a2 + 24);
  if ((v6 & 2) != 0)
  {
    v8 = *(_QWORD *)(a2 + 16);
    *(_BYTE *)(v4 + 24) = 2;
    *(_QWORD *)(v4 + 16) = v8;
    v7 = 3;
    if ((v6 & 1) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = 1;
  if ((*(_BYTE *)(a2 + 24) & 1) != 0)
  {
LABEL_5:
    v9 = *(_QWORD *)(a2 + 8);
    *(_BYTE *)(v4 + 24) = v7;
    *(_QWORD *)(v4 + 8) = v9;
  }
LABEL_6:
  result = (uint64_t)(a1 + 2);
  v11 = (unint64_t)a1[2];
  v12 = a1[1];
  if ((unint64_t)v12 >= v11)
  {
    v14 = v12 - *a1;
    if ((unint64_t)(v14 + 1) >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v15 = v11 - (_QWORD)*a1;
    v16 = v15 >> 2;
    if (v15 >> 2 <= (unint64_t)(v14 + 1))
      v16 = v14 + 1;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    v29 = a1 + 2;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(result, v17);
    else
      v18 = 0;
    v19 = (uint64_t *)&v18[8 * v14];
    v20 = &v18[8 * v17];
    v28 = v20;
    *v19 = v5;
    v13 = v19 + 1;
    v27.i64[1] = (uint64_t)(v19 + 1);
    v22 = *a1;
    v21 = a1[1];
    if (v21 == *a1)
    {
      v24 = vdupq_n_s64((unint64_t)v21);
    }
    else
    {
      do
      {
        v23 = *--v21;
        *v21 = 0;
        *--v19 = v23;
      }
      while (v21 != v22);
      v24 = *(int64x2_t *)a1;
      v13 = (uint64_t *)v27.i64[1];
      v20 = v28;
    }
    *a1 = v19;
    a1[1] = v13;
    v27 = v24;
    v25 = (char *)a1[2];
    a1[2] = (uint64_t *)v20;
    v28 = v25;
    v26 = v24.i64[0];
    result = std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v26);
  }
  else
  {
    *v12 = v5;
    v13 = v12 + 1;
  }
  a1[1] = v13;
  return result;
}

void sub_1B789C360(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

statistics *statistics::Statistics::operator=(statistics *a1, const statistics::RawQuantitySample **a2)
{
  statistics::Statistics *v3;
  _BYTE v5[208];

  if (a1 != (statistics *)a2)
  {
    statistics::Statistics::Statistics((statistics::Statistics *)v5, a2);
    statistics::swap(a1, (statistics::Statistics *)v5, v3);
    statistics::Statistics::~Statistics((statistics::Statistics *)v5);
  }
  return a1;
}

double statistics::swap(statistics *this, statistics::Statistics *a2, statistics::Statistics *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double result;
  uint64_t v29;

  v3 = *((_DWORD *)this + 51);
  *((_DWORD *)this + 51) = *((_DWORD *)a2 + 51);
  *((_DWORD *)a2 + 51) = v3;
  v4 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = *((_QWORD *)a2 + 14);
  *((_QWORD *)a2 + 14) = v4;
  v5 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = *((_QWORD *)a2 + 8);
  *((_QWORD *)a2 + 8) = v5;
  v6 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
  *((_QWORD *)a2 + 9) = v6;
  v7 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = *((_QWORD *)a2 + 10);
  *((_QWORD *)a2 + 10) = v7;
  v8 = *((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = *((_QWORD *)a2 + 20);
  *((_QWORD *)a2 + 20) = v8;
  v9 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = *((_QWORD *)a2 + 15);
  *((_QWORD *)a2 + 15) = v9;
  v11 = *((_QWORD *)this + 2);
  v10 = *((_QWORD *)this + 3);
  v12 = *((_QWORD *)a2 + 3);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_QWORD *)this + 3) = v12;
  *((_QWORD *)a2 + 3) = v10;
  v13 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = v13;
  v14 = *((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = *((_QWORD *)a2 + 21);
  *((_QWORD *)a2 + 21) = v14;
  *((_QWORD *)a2 + 2) = v11;
  v16 = *((_QWORD *)this + 16);
  v15 = *((_QWORD *)this + 17);
  v17 = *((_QWORD *)a2 + 17);
  *((_QWORD *)this + 16) = *((_QWORD *)a2 + 16);
  *((_QWORD *)this + 17) = v17;
  *((_QWORD *)a2 + 17) = v15;
  v18 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 4) = v18;
  LOBYTE(v18) = *((_BYTE *)this + 201);
  *((_BYTE *)this + 201) = *((_BYTE *)a2 + 201);
  *((_BYTE *)a2 + 201) = v18;
  LOBYTE(v18) = *((_BYTE *)this + 200);
  *((_BYTE *)this + 200) = *((_BYTE *)a2 + 200);
  *((_BYTE *)a2 + 200) = v18;
  v19 = *((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = *((_QWORD *)a2 + 18);
  v20 = *((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = *((_QWORD *)a2 + 19);
  *((_QWORD *)a2 + 19) = v20;
  v21 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = *((_QWORD *)a2 + 12);
  *((_QWORD *)a2 + 12) = v21;
  v22 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = *((_QWORD *)a2 + 13);
  *((_QWORD *)a2 + 13) = v22;
  v23 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = *((_QWORD *)a2 + 11);
  *((_QWORD *)a2 + 11) = v23;
  v24 = *((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = *((_QWORD *)a2 + 23);
  *((_QWORD *)a2 + 23) = v24;
  v25 = *((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = *((_QWORD *)a2 + 24);
  *((_QWORD *)a2 + 24) = v25;
  v26 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *((_QWORD *)a2 + 7) = v26;
  v27 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 5) = v27;
  result = *((double *)this + 22);
  *((_QWORD *)this + 22) = *((_QWORD *)a2 + 22);
  *((double *)a2 + 22) = result;
  *((_QWORD *)a2 + 18) = v19;
  *((_QWORD *)a2 + 16) = v16;
  v29 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = v29;
  return result;
}

uint64_t statistics::Statistics::Statistics(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)a1 = &off_1E6CEA528;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  v5 = a1 + 16;
  *(_QWORD *)(a1 + 64) = 0;
  v6 = (_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 204) = *(_DWORD *)(a2 + 204);
  *(_DWORD *)(a2 + 204) = 0;
  v7 = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 112) = 0;
  v8 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = v7;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate(v6);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  v9 = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(a2 + 160) = 0;
  v10 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(a1 + 160) = v9;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 201) = *(_BYTE *)(a2 + 201);
  v11 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = 0;
  v12 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = v11;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  *(_BYTE *)(a1 + 200) = *(_BYTE *)(a2 + 200);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  v13 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v14 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v13;
  if (v14)
    std::default_delete<std::string>::operator()[abi:ne180100](v5, v14);
  v15 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = 0;
  v16 = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 128) = v15;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  v17 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v18 = *v4;
  *v4 = v17;
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
  return a1;
}

statistics *statistics::Statistics::operator=(statistics *a1, uint64_t a2)
{
  statistics::Statistics *v3;
  _BYTE v5[208];

  if (a1 != (statistics *)a2)
  {
    statistics::Statistics::Statistics((uint64_t)v5, a2);
    statistics::swap(a1, (statistics::Statistics *)v5, v3);
    statistics::Statistics::~Statistics((statistics::Statistics *)v5);
  }
  return a1;
}

uint64_t statistics::Statistics::formatText(statistics::Statistics *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  int v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 1);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "auxiliaryStatistics");
  if (*((_QWORD *)this + 2))
    PB::TextFormatter::format();
  v6 = *((_DWORD *)this + 51);
  if ((v6 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "count");
    v6 = *((_DWORD *)this + 51);
    if ((v6 & 2) == 0)
    {
LABEL_7:
      if ((v6 & 0x8000) == 0)
        goto LABEL_8;
      goto LABEL_39;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_7;
  }
  PB::TextFormatter::format(a2, "effectiveCount");
  v6 = *((_DWORD *)this + 51);
  if ((v6 & 0x8000) == 0)
  {
LABEL_8:
    if ((v6 & 4) == 0)
      goto LABEL_9;
    goto LABEL_40;
  }
LABEL_39:
  PB::TextFormatter::format(a2, "enableOverlapProcessing");
  v6 = *((_DWORD *)this + 51);
  if ((v6 & 4) == 0)
  {
LABEL_9:
    if ((v6 & 8) == 0)
      goto LABEL_10;
    goto LABEL_41;
  }
LABEL_40:
  PB::TextFormatter::format(a2, "freezeTimestamp", *((double *)this + 5));
  v6 = *((_DWORD *)this + 51);
  if ((v6 & 8) == 0)
  {
LABEL_10:
    if ((v6 & 0x10) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_41:
  PB::TextFormatter::format(a2, "frozenBucketCount");
  if ((*((_DWORD *)this + 51) & 0x10) != 0)
LABEL_11:
    PB::TextFormatter::format(a2, "frozenMean", *((double *)this + 7));
LABEL_12:
  v7 = (uint64_t *)*((_QWORD *)this + 8);
  v8 = (uint64_t *)*((_QWORD *)this + 9);
  while (v7 != v8)
  {
    v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v9 + 32))(v9, a2, "intervals");
  }
  v10 = *((_DWORD *)this + 51);
  if ((v10 & 0x20) != 0)
  {
    PB::TextFormatter::format(a2, "max", *((double *)this + 11));
    v10 = *((_DWORD *)this + 51);
    if ((v10 & 0x40) == 0)
    {
LABEL_16:
      if ((v10 & 0x80) == 0)
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  else if ((v10 & 0x40) == 0)
  {
    goto LABEL_16;
  }
  PB::TextFormatter::format(a2, "mean", *((double *)this + 12));
  if ((*((_DWORD *)this + 51) & 0x80) != 0)
LABEL_17:
    PB::TextFormatter::format(a2, "min", *((double *)this + 13));
LABEL_18:
  v11 = *((_QWORD *)this + 14);
  if (v11)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v11 + 32))(v11, a2, "mostRecentDatum");
  v12 = *((_QWORD *)this + 15);
  if (v12)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v12 + 32))(v12, a2, "overlapProcessorState");
  v13 = *((_QWORD *)this + 16);
  if (v13)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v13 + 32))(v13, a2, "primaryStatistics");
  v14 = *((_DWORD *)this + 51);
  if ((v14 & 0x100) != 0)
  {
    PB::TextFormatter::format(a2, "relativeValueState");
    v14 = *((_DWORD *)this + 51);
    if ((v14 & 0x10000) == 0)
    {
LABEL_26:
      if ((v14 & 0x200) == 0)
        goto LABEL_27;
      goto LABEL_48;
    }
  }
  else if ((v14 & 0x10000) == 0)
  {
    goto LABEL_26;
  }
  PB::TextFormatter::format(a2, "setAnchorTime");
  v14 = *((_DWORD *)this + 51);
  if ((v14 & 0x200) == 0)
  {
LABEL_27:
    if ((v14 & 0x400) == 0)
      goto LABEL_29;
    goto LABEL_28;
  }
LABEL_48:
  PB::TextFormatter::format(a2, "sourceID");
  if ((*((_DWORD *)this + 51) & 0x400) != 0)
LABEL_28:
    PB::TextFormatter::format(a2, "sum", *((double *)this + 19));
LABEL_29:
  v15 = *((_QWORD *)this + 20);
  if (v15)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v15 + 32))(v15, a2, "unfinishedDatum");
  v16 = *((_DWORD *)this + 51);
  if ((v16 & 0x800) != 0)
  {
    PB::TextFormatter::format(a2, "unfrozenCount");
    v16 = *((_DWORD *)this + 51);
    if ((v16 & 0x1000) == 0)
    {
LABEL_33:
      if ((v16 & 0x2000) == 0)
        goto LABEL_34;
LABEL_52:
      PB::TextFormatter::format(a2, "weightTotal", *((double *)this + 23));
      if ((*((_DWORD *)this + 51) & 0x4000) == 0)
        return PB::TextFormatter::endObject(a2);
      goto LABEL_35;
    }
  }
  else if ((v16 & 0x1000) == 0)
  {
    goto LABEL_33;
  }
  PB::TextFormatter::format(a2, "unfrozenMean", *((double *)this + 22));
  v16 = *((_DWORD *)this + 51);
  if ((v16 & 0x2000) != 0)
    goto LABEL_52;
LABEL_34:
  if ((v16 & 0x4000) != 0)
LABEL_35:
    PB::TextFormatter::format(a2, "weightedMean", *((double *)this + 24));
  return PB::TextFormatter::endObject(a2);
}

uint64_t statistics::Statistics::readFrom(statistics::Statistics *this, PB::Reader *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t *v8;
  uint64_t **v9;
  void (**v10)(statistics::Statistics *__hidden);
  uint64_t v11;
  char v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  BOOL v17;
  char v18;
  unsigned int v19;
  unint64_t v20;
  char v21;
  uint64_t result;
  unint64_t v23;
  void (**v24)(statistics::Statistics *__hidden);
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void (**v31)(statistics::Statistics *__hidden);
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  char v51;
  unsigned int v52;
  uint64_t v53;
  unint64_t v54;
  char v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  char v60;
  unsigned int v61;
  uint64_t v62;
  unint64_t v63;
  char v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  char v70;
  unsigned int v71;
  uint64_t v72;
  unint64_t v73;
  char v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  char v78;
  unsigned int v79;
  uint64_t v80;
  unint64_t v81;
  char v82;
  unint64_t v83;
  unint64_t v84;
  int v85;
  BOOL v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  int v90;
  BOOL v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  char v95;
  unsigned int v96;
  uint64_t v97;
  unint64_t v98;
  char v99;
  uint64_t v100;
  void (**v101)(statistics::Statistics *__hidden);
  uint64_t v102;
  char v103;
  unsigned int v104;
  unint64_t v105;
  char v106;
  char v107;
  unsigned int v108;
  unint64_t v109;
  char v110;
  char v111;
  unsigned int v112;
  unint64_t v113;
  char v114;
  char v115;
  unsigned int v116;
  unint64_t v117;
  char v118;
  char v119;
  unsigned int v120;
  unint64_t v121;
  char v122;
  char v123;
  unsigned int v124;
  unint64_t v125;
  char v126;
  uint64_t v128;

  v2 = *((_QWORD *)a2 + 1);
  v3 = *((_QWORD *)a2 + 2);
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v8 = (uint64_t *)((char *)this + 16);
    v9 = (uint64_t **)((char *)this + 64);
    v10 = &off_1E6CEA528;
    do
    {
      v11 = *(_QWORD *)a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v18 = 0;
        v19 = 0;
        v14 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v20 = v2 + 1;
          v21 = *(_BYTE *)(v11 + v2);
          *((_QWORD *)a2 + 1) = v20;
          v14 |= (unint64_t)(v21 & 0x7F) << v18;
          if ((v21 & 0x80) == 0)
            goto LABEL_22;
          v18 += 7;
          v2 = v20;
          v17 = v19++ > 8;
          if (v17)
            goto LABEL_20;
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v12 = 0;
      v13 = 0;
      v14 = 0;
      while (1)
      {
        v15 = v2 + 1;
        *((_QWORD *)a2 + 1) = v2 + 1;
        v16 = *(_BYTE *)(v11 + v2);
        v14 |= (unint64_t)(v16 & 0x7F) << v12;
        if ((v16 & 0x80) == 0)
          break;
        v12 += 7;
        v2 = v15;
        v17 = v13++ > 8;
        if (v17)
          goto LABEL_20;
      }
LABEL_22:
      if ((v14 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v23 = v14 >> 3;
      if ((int)(v14 >> 3) > 99)
      {
        if ((int)v23 > 999)
        {
          if ((_DWORD)v23 == 1000)
          {
            v100 = operator new();
            v101 = v10;
            v25 = v100;
            *(_QWORD *)(v100 + 72) = 0;
            *(_QWORD *)(v100 + 80) = 0;
            *(_QWORD *)(v100 + 64) = 0;
            *(_QWORD *)(v100 + 160) = 0;
            *(_DWORD *)(v100 + 204) = 0;
            *(_QWORD *)(v100 + 8) = 0;
            *(_QWORD *)(v100 + 16) = 0;
            v24 = v101;
            *(_QWORD *)v100 = v101;
            *(_QWORD *)(v100 + 120) = 0;
            *(_QWORD *)(v100 + 128) = 0;
            *(_QWORD *)(v100 + 112) = 0;
            v102 = *((_QWORD *)this + 16);
            *((_QWORD *)this + 16) = v25;
            if (v102)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v102 + 8))(v102);
              v25 = *((_QWORD *)this + 16);
            }
          }
          else
          {
            if ((_DWORD)v23 != 1001)
            {
LABEL_20:
              result = PB::Reader::skip(a2);
              if (!(_DWORD)result)
                return result;
              goto LABEL_193;
            }
            v30 = operator new();
            v31 = v10;
            v25 = v30;
            *(_QWORD *)(v30 + 72) = 0;
            *(_QWORD *)(v30 + 80) = 0;
            *(_QWORD *)(v30 + 64) = 0;
            *(_QWORD *)(v30 + 160) = 0;
            *(_DWORD *)(v30 + 204) = 0;
            *(_QWORD *)(v30 + 8) = 0;
            *(_QWORD *)(v30 + 16) = 0;
            v24 = v31;
            *(_QWORD *)v30 = v31;
            *(_QWORD *)(v30 + 120) = 0;
            *(_QWORD *)(v30 + 128) = 0;
            *(_QWORD *)(v30 + 112) = 0;
            v32 = *((_QWORD *)this + 1);
            *((_QWORD *)this + 1) = v25;
            if (v32)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
              v25 = *((_QWORD *)this + 1);
            }
          }
LABEL_118:
          if (!PB::Reader::placeMark()
            || ((*(uint64_t (**)(uint64_t, PB::Reader *))(*(_QWORD *)v25 + 16))(v25, a2) & 1) == 0)
          {
            return 0;
          }
          PB::Reader::recallMark();
          v10 = v24;
        }
        else if ((_DWORD)v23 == 100)
        {
          *((_DWORD *)this + 51) |= 0x200u;
          v92 = *((_QWORD *)a2 + 1);
          v93 = *((_QWORD *)a2 + 2);
          v94 = *(_QWORD *)a2;
          if (v92 > 0xFFFFFFFFFFFFFFF5 || v92 + 10 > v93)
          {
            v123 = 0;
            v124 = 0;
            v97 = 0;
            if (v93 <= v92)
              v93 = *((_QWORD *)a2 + 1);
            while (1)
            {
              if (v93 == v92)
              {
                v97 = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_192;
              }
              v125 = v92 + 1;
              v126 = *(_BYTE *)(v94 + v92);
              *((_QWORD *)a2 + 1) = v125;
              v97 |= (unint64_t)(v126 & 0x7F) << v123;
              if ((v126 & 0x80) == 0)
                break;
              v123 += 7;
              v92 = v125;
              v17 = v124++ > 8;
              if (v17)
              {
LABEL_166:
                v97 = 0;
                goto LABEL_192;
              }
            }
            if (*((_BYTE *)a2 + 24))
              v97 = 0;
          }
          else
          {
            v95 = 0;
            v96 = 0;
            v97 = 0;
            while (1)
            {
              v98 = v92 + 1;
              *((_QWORD *)a2 + 1) = v92 + 1;
              v99 = *(_BYTE *)(v94 + v92);
              v97 |= (unint64_t)(v99 & 0x7F) << v95;
              if ((v99 & 0x80) == 0)
                break;
              v95 += 7;
              v92 = v98;
              v17 = v96++ > 8;
              if (v17)
                goto LABEL_166;
            }
          }
LABEL_192:
          *((_QWORD *)this + 18) = v97;
        }
        else
        {
          if ((_DWORD)v23 != 101)
            goto LABEL_20;
          v27 = (_QWORD *)operator new();
          v27[1] = 0;
          v27[2] = 0;
          *v27 = 0;
          v128 = 0;
          v28 = *v8;
          *v8 = (uint64_t)v27;
          if (v28)
          {
            std::default_delete<std::string>::operator()[abi:ne180100]((uint64_t)v8, v28);
            v29 = v128;
            v128 = 0;
            if (v29)
              std::default_delete<std::string>::operator()[abi:ne180100]((uint64_t)&v128, v29);
          }
          PB::Reader::read();
        }
      }
      else
      {
        switch((int)v23)
        {
          case 1:
            v24 = v10;
            v25 = operator new();
            *(_QWORD *)v25 = &off_1E6CFF278;
            *(_DWORD *)(v25 + 44) = 0;
            v26 = *((_QWORD *)this + 14);
            *((_QWORD *)this + 14) = v25;
            if (v26)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
              v25 = *((_QWORD *)this + 14);
            }
            goto LABEL_118;
          case 2:
            *((_DWORD *)this + 51) |= 1u;
            v33 = *((_QWORD *)a2 + 1);
            v34 = *((_QWORD *)a2 + 2);
            v35 = *(_QWORD *)a2;
            if (v33 <= 0xFFFFFFFFFFFFFFF5 && v33 + 10 <= v34)
            {
              v36 = 0;
              v37 = 0;
              v38 = 0;
              do
              {
                v39 = v33 + 1;
                *((_QWORD *)a2 + 1) = v33 + 1;
                v40 = *(_BYTE *)(v35 + v33);
                v38 |= (unint64_t)(v40 & 0x7F) << v36;
                if ((v40 & 0x80) == 0)
                  goto LABEL_172;
                v36 += 7;
                v33 = v39;
                v17 = v37++ > 8;
              }
              while (!v17);
LABEL_127:
              v38 = 0;
              goto LABEL_172;
            }
            v103 = 0;
            v104 = 0;
            v38 = 0;
            if (v34 <= v33)
              v34 = *((_QWORD *)a2 + 1);
            while (2)
            {
              if (v34 == v33)
              {
                v38 = 0;
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                v105 = v33 + 1;
                v106 = *(_BYTE *)(v35 + v33);
                *((_QWORD *)a2 + 1) = v105;
                v38 |= (unint64_t)(v106 & 0x7F) << v103;
                if (v106 < 0)
                {
                  v103 += 7;
                  v33 = v105;
                  v17 = v104++ > 8;
                  if (v17)
                    goto LABEL_127;
                  continue;
                }
                if (*((_BYTE *)a2 + 24))
                  v38 = 0;
              }
              break;
            }
LABEL_172:
            *((_QWORD *)this + 3) = v38;
            goto LABEL_193;
          case 3:
            *((_DWORD *)this + 51) |= 0x400u;
            v41 = *((_QWORD *)a2 + 1);
            if (v41 > 0xFFFFFFFFFFFFFFF7 || v41 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 19) = *(_QWORD *)(*(_QWORD *)a2 + v41);
            goto LABEL_168;
          case 4:
            *((_DWORD *)this + 51) |= 0x40u;
            v42 = *((_QWORD *)a2 + 1);
            if (v42 > 0xFFFFFFFFFFFFFFF7 || v42 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 12) = *(_QWORD *)(*(_QWORD *)a2 + v42);
            goto LABEL_168;
          case 5:
            *((_DWORD *)this + 51) |= 0x80u;
            v43 = *((_QWORD *)a2 + 1);
            if (v43 > 0xFFFFFFFFFFFFFFF7 || v43 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 13) = *(_QWORD *)(*(_QWORD *)a2 + v43);
            goto LABEL_168;
          case 6:
            *((_DWORD *)this + 51) |= 0x20u;
            v44 = *((_QWORD *)a2 + 1);
            if (v44 > 0xFFFFFFFFFFFFFFF7 || v44 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 11) = *(_QWORD *)(*(_QWORD *)a2 + v44);
            goto LABEL_168;
          case 7:
            *((_DWORD *)this + 51) |= 0x2000u;
            v45 = *((_QWORD *)a2 + 1);
            if (v45 > 0xFFFFFFFFFFFFFFF7 || v45 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 23) = *(_QWORD *)(*(_QWORD *)a2 + v45);
            goto LABEL_168;
          case 8:
            *((_DWORD *)this + 51) |= 0x4000u;
            v46 = *((_QWORD *)a2 + 1);
            if (v46 > 0xFFFFFFFFFFFFFFF7 || v46 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 24) = *(_QWORD *)(*(_QWORD *)a2 + v46);
            goto LABEL_168;
          case 9:
            *((_DWORD *)this + 51) |= 0x10u;
            v47 = *((_QWORD *)a2 + 1);
            if (v47 > 0xFFFFFFFFFFFFFFF7 || v47 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 7) = *(_QWORD *)(*(_QWORD *)a2 + v47);
            goto LABEL_168;
          case 10:
            *((_DWORD *)this + 51) |= 8u;
            v48 = *((_QWORD *)a2 + 1);
            v49 = *((_QWORD *)a2 + 2);
            v50 = *(_QWORD *)a2;
            if (v48 <= 0xFFFFFFFFFFFFFFF5 && v48 + 10 <= v49)
            {
              v51 = 0;
              v52 = 0;
              v53 = 0;
              do
              {
                v54 = v48 + 1;
                *((_QWORD *)a2 + 1) = v48 + 1;
                v55 = *(_BYTE *)(v50 + v48);
                v53 |= (unint64_t)(v55 & 0x7F) << v51;
                if ((v55 & 0x80) == 0)
                  goto LABEL_176;
                v51 += 7;
                v48 = v54;
                v17 = v52++ > 8;
              }
              while (!v17);
LABEL_134:
              v53 = 0;
              goto LABEL_176;
            }
            v107 = 0;
            v108 = 0;
            v53 = 0;
            if (v49 <= v48)
              v49 = *((_QWORD *)a2 + 1);
            while (2)
            {
              if (v49 == v48)
              {
                v53 = 0;
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                v109 = v48 + 1;
                v110 = *(_BYTE *)(v50 + v48);
                *((_QWORD *)a2 + 1) = v109;
                v53 |= (unint64_t)(v110 & 0x7F) << v107;
                if (v110 < 0)
                {
                  v107 += 7;
                  v48 = v109;
                  v17 = v108++ > 8;
                  if (v17)
                    goto LABEL_134;
                  continue;
                }
                if (*((_BYTE *)a2 + 24))
                  v53 = 0;
              }
              break;
            }
LABEL_176:
            *((_QWORD *)this + 6) = v53;
            goto LABEL_193;
          case 11:
            *((_DWORD *)this + 51) |= 4u;
            v56 = *((_QWORD *)a2 + 1);
            if (v56 > 0xFFFFFFFFFFFFFFF7 || v56 + 8 > *((_QWORD *)a2 + 2))
              goto LABEL_85;
            *((_QWORD *)this + 5) = *(_QWORD *)(*(_QWORD *)a2 + v56);
            goto LABEL_168;
          case 12:
            *((_DWORD *)this + 51) |= 0x800u;
            v57 = *((_QWORD *)a2 + 1);
            v58 = *((_QWORD *)a2 + 2);
            v59 = *(_QWORD *)a2;
            if (v57 <= 0xFFFFFFFFFFFFFFF5 && v57 + 10 <= v58)
            {
              v60 = 0;
              v61 = 0;
              v62 = 0;
              do
              {
                v63 = v57 + 1;
                *((_QWORD *)a2 + 1) = v57 + 1;
                v64 = *(_BYTE *)(v59 + v57);
                v62 |= (unint64_t)(v64 & 0x7F) << v60;
                if ((v64 & 0x80) == 0)
                  goto LABEL_180;
                v60 += 7;
                v57 = v63;
                v17 = v61++ > 8;
              }
              while (!v17);
LABEL_141:
              v62 = 0;
              goto LABEL_180;
            }
            v111 = 0;
            v112 = 0;
            v62 = 0;
            if (v58 <= v57)
              v58 = *((_QWORD *)a2 + 1);
            while (2)
            {
              if (v58 == v57)
              {
                v62 = 0;
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                v113 = v57 + 1;
                v114 = *(_BYTE *)(v59 + v57);
                *((_QWORD *)a2 + 1) = v113;
                v62 |= (unint64_t)(v114 & 0x7F) << v111;
                if (v114 < 0)
                {
                  v111 += 7;
                  v57 = v113;
                  v17 = v112++ > 8;
                  if (v17)
                    goto LABEL_141;
                  continue;
                }
                if (*((_BYTE *)a2 + 24))
                  v62 = 0;
              }
              break;
            }
LABEL_180:
            *((_QWORD *)this + 21) = v62;
            goto LABEL_193;
          case 13:
            *((_DWORD *)this + 51) |= 0x1000u;
            v65 = *((_QWORD *)a2 + 1);
            if (v65 <= 0xFFFFFFFFFFFFFFF7 && v65 + 8 <= *((_QWORD *)a2 + 2))
            {
              *((_QWORD *)this + 22) = *(_QWORD *)(*(_QWORD *)a2 + v65);
LABEL_168:
              *((_QWORD *)a2 + 1) += 8;
            }
            else
            {
LABEL_85:
              *((_BYTE *)a2 + 24) = 1;
            }
            goto LABEL_193;
          case 14:
            v24 = v10;
            PB::PtrVector<statistics::Interval>::emplace_back<>(v9);
            v25 = *(_QWORD *)(*((_QWORD *)this + 9) - 8);
            goto LABEL_118;
          case 15:
            v24 = v10;
            v25 = operator new();
            *(_QWORD *)v25 = &off_1E6CFF278;
            *(_DWORD *)(v25 + 44) = 0;
            v66 = *((_QWORD *)this + 20);
            *((_QWORD *)this + 20) = v25;
            if (v66)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v66 + 8))(v66);
              v25 = *((_QWORD *)this + 20);
            }
            goto LABEL_118;
          case 16:
            *((_DWORD *)this + 51) |= 0x100u;
            v67 = *((_QWORD *)a2 + 1);
            v68 = *((_QWORD *)a2 + 2);
            v69 = *(_QWORD *)a2;
            if (v67 <= 0xFFFFFFFFFFFFFFF5 && v67 + 10 <= v68)
            {
              v70 = 0;
              v71 = 0;
              v72 = 0;
              do
              {
                v73 = v67 + 1;
                *((_QWORD *)a2 + 1) = v67 + 1;
                v74 = *(_BYTE *)(v69 + v67);
                v72 |= (unint64_t)(v74 & 0x7F) << v70;
                if ((v74 & 0x80) == 0)
                  goto LABEL_184;
                v70 += 7;
                v67 = v73;
                v17 = v71++ > 8;
              }
              while (!v17);
LABEL_148:
              v72 = 0;
              goto LABEL_184;
            }
            v115 = 0;
            v116 = 0;
            v72 = 0;
            if (v68 <= v67)
              v68 = *((_QWORD *)a2 + 1);
            while (2)
            {
              if (v68 == v67)
              {
                v72 = 0;
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                v117 = v67 + 1;
                v118 = *(_BYTE *)(v69 + v67);
                *((_QWORD *)a2 + 1) = v117;
                v72 |= (unint64_t)(v118 & 0x7F) << v115;
                if (v118 < 0)
                {
                  v115 += 7;
                  v67 = v117;
                  v17 = v116++ > 8;
                  if (v17)
                    goto LABEL_148;
                  continue;
                }
                if (*((_BYTE *)a2 + 24))
                  v72 = 0;
              }
              break;
            }
LABEL_184:
            *((_QWORD *)this + 17) = v72;
            goto LABEL_193;
          case 17:
            *((_DWORD *)this + 51) |= 2u;
            v75 = *((_QWORD *)a2 + 1);
            v76 = *((_QWORD *)a2 + 2);
            v77 = *(_QWORD *)a2;
            if (v75 <= 0xFFFFFFFFFFFFFFF5 && v75 + 10 <= v76)
            {
              v78 = 0;
              v79 = 0;
              v80 = 0;
              do
              {
                v81 = v75 + 1;
                *((_QWORD *)a2 + 1) = v75 + 1;
                v82 = *(_BYTE *)(v77 + v75);
                v80 |= (unint64_t)(v82 & 0x7F) << v78;
                if ((v82 & 0x80) == 0)
                  goto LABEL_188;
                v78 += 7;
                v75 = v81;
                v17 = v79++ > 8;
              }
              while (!v17);
LABEL_155:
              v80 = 0;
              goto LABEL_188;
            }
            v119 = 0;
            v120 = 0;
            v80 = 0;
            if (v76 <= v75)
              v76 = *((_QWORD *)a2 + 1);
            break;
          case 18:
            *((_DWORD *)this + 51) |= 0x10000u;
            v83 = *((_QWORD *)a2 + 1);
            if (v83 >= *((_QWORD *)a2 + 2))
            {
              v86 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v84 = v83 + 1;
              v85 = *(unsigned __int8 *)(*(_QWORD *)a2 + v83);
              *((_QWORD *)a2 + 1) = v84;
              v86 = v85 != 0;
            }
            *((_BYTE *)this + 201) = v86;
            goto LABEL_193;
          case 19:
            v24 = v10;
            v25 = operator new();
            *(_QWORD *)v25 = off_1E6D037C8;
            *(_QWORD *)(v25 + 40) = 0;
            *(_QWORD *)(v25 + 48) = 0;
            *(_QWORD *)(v25 + 32) = 0;
            *(_DWORD *)(v25 + 60) = 0;
            v87 = *((_QWORD *)this + 15);
            *((_QWORD *)this + 15) = v25;
            if (v87)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v87 + 8))(v87);
              v25 = *((_QWORD *)this + 15);
            }
            goto LABEL_118;
          case 20:
            *((_DWORD *)this + 51) |= 0x8000u;
            v88 = *((_QWORD *)a2 + 1);
            if (v88 >= *((_QWORD *)a2 + 2))
            {
              v91 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v89 = v88 + 1;
              v90 = *(unsigned __int8 *)(*(_QWORD *)a2 + v88);
              *((_QWORD *)a2 + 1) = v89;
              v91 = v90 != 0;
            }
            *((_BYTE *)this + 200) = v91;
            goto LABEL_193;
          default:
            goto LABEL_20;
        }
        while (1)
        {
          if (v76 == v75)
          {
            v80 = 0;
            *((_BYTE *)a2 + 24) = 1;
            goto LABEL_188;
          }
          v121 = v75 + 1;
          v122 = *(_BYTE *)(v77 + v75);
          *((_QWORD *)a2 + 1) = v121;
          v80 |= (unint64_t)(v122 & 0x7F) << v119;
          if ((v122 & 0x80) == 0)
            break;
          v119 += 7;
          v75 = v121;
          v17 = v120++ > 8;
          if (v17)
            goto LABEL_155;
        }
        if (*((_BYTE *)a2 + 24))
          v80 = 0;
LABEL_188:
        *((_QWORD *)this + 4) = v80;
      }
LABEL_193:
      v2 = *((_QWORD *)a2 + 1);
      v3 = *((_QWORD *)a2 + 2);
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && v4 == 0);
  }
  return v4 == 0;
}

uint64_t PB::PtrVector<statistics::Interval>::emplace_back<>(uint64_t **a1)
{
  uint64_t v2;
  uint64_t result;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t *v12;
  char *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  int64x2_t v17;
  uint64_t *v18;
  uint64_t v19;
  int64x2_t v20;
  char *v21;
  _QWORD *v22;

  v2 = operator new();
  *(_QWORD *)v2 = &off_1E6D0A7D0;
  *(_DWORD *)(v2 + 24) = 0;
  result = (uint64_t)(a1 + 2);
  v4 = (unint64_t)a1[2];
  v5 = a1[1];
  if ((unint64_t)v5 >= v4)
  {
    v7 = v5 - *a1;
    if ((unint64_t)(v7 + 1) >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v8 = v4 - (_QWORD)*a1;
    v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1))
      v9 = v7 + 1;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    v22 = a1 + 2;
    if (v10)
      v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(result, v10);
    else
      v11 = 0;
    v12 = (uint64_t *)&v11[8 * v7];
    v13 = &v11[8 * v10];
    v21 = v13;
    *v12 = v2;
    v6 = v12 + 1;
    v20.i64[1] = (uint64_t)(v12 + 1);
    v15 = *a1;
    v14 = a1[1];
    if (v14 == *a1)
    {
      v17 = vdupq_n_s64((unint64_t)v14);
    }
    else
    {
      do
      {
        v16 = *--v14;
        *v14 = 0;
        *--v12 = v16;
      }
      while (v14 != v15);
      v17 = *(int64x2_t *)a1;
      v6 = (uint64_t *)v20.i64[1];
      v13 = v21;
    }
    *a1 = v12;
    a1[1] = v6;
    v20 = v17;
    v18 = a1[2];
    a1[2] = (uint64_t *)v13;
    v21 = (char *)v18;
    v19 = v17.i64[0];
    result = std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v19);
  }
  else
  {
    *v5 = v2;
    v6 = v5 + 1;
  }
  a1[1] = v6;
  return result;
}

void sub_1B789D848(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t statistics::Statistics::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  int v5;
  const PB::Base **v6;
  const PB::Base **v7;
  const PB::Base *v8;
  const PB::Base *v9;
  int v10;
  const PB::Base *v11;
  int v12;
  const PB::Base *v13;
  const PB::Base *v14;

  v3 = this;
  v4 = *(const PB::Base **)(this + 112);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v5 = *(_DWORD *)(v3 + 204);
    if ((v5 & 0x400) == 0)
    {
LABEL_5:
      if ((v5 & 0x40) == 0)
        goto LABEL_6;
      goto LABEL_39;
    }
  }
  else if ((v5 & 0x400) == 0)
  {
    goto LABEL_5;
  }
  this = PB::Writer::write(a2, *(double *)(v3 + 152));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x40) == 0)
  {
LABEL_6:
    if ((v5 & 0x80) == 0)
      goto LABEL_7;
    goto LABEL_40;
  }
LABEL_39:
  this = PB::Writer::write(a2, *(double *)(v3 + 96));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x80) == 0)
  {
LABEL_7:
    if ((v5 & 0x20) == 0)
      goto LABEL_8;
    goto LABEL_41;
  }
LABEL_40:
  this = PB::Writer::write(a2, *(double *)(v3 + 104));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x20) == 0)
  {
LABEL_8:
    if ((v5 & 0x2000) == 0)
      goto LABEL_9;
    goto LABEL_42;
  }
LABEL_41:
  this = PB::Writer::write(a2, *(double *)(v3 + 88));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x2000) == 0)
  {
LABEL_9:
    if ((v5 & 0x4000) == 0)
      goto LABEL_10;
    goto LABEL_43;
  }
LABEL_42:
  this = PB::Writer::write(a2, *(double *)(v3 + 184));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x4000) == 0)
  {
LABEL_10:
    if ((v5 & 0x10) == 0)
      goto LABEL_11;
    goto LABEL_44;
  }
LABEL_43:
  this = PB::Writer::write(a2, *(double *)(v3 + 192));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x10) == 0)
  {
LABEL_11:
    if ((v5 & 8) == 0)
      goto LABEL_12;
    goto LABEL_45;
  }
LABEL_44:
  this = PB::Writer::write(a2, *(double *)(v3 + 56));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 8) == 0)
  {
LABEL_12:
    if ((v5 & 4) == 0)
      goto LABEL_13;
    goto LABEL_46;
  }
LABEL_45:
  this = PB::Writer::writeVarInt(a2);
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 4) == 0)
  {
LABEL_13:
    if ((v5 & 0x800) == 0)
      goto LABEL_14;
LABEL_47:
    this = PB::Writer::writeVarInt(a2);
    if ((*(_DWORD *)(v3 + 204) & 0x1000) == 0)
      goto LABEL_16;
    goto LABEL_15;
  }
LABEL_46:
  this = PB::Writer::write(a2, *(double *)(v3 + 40));
  v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x800) != 0)
    goto LABEL_47;
LABEL_14:
  if ((v5 & 0x1000) != 0)
LABEL_15:
    this = PB::Writer::write(a2, *(double *)(v3 + 176));
LABEL_16:
  v6 = *(const PB::Base ***)(v3 + 64);
  v7 = *(const PB::Base ***)(v3 + 72);
  while (v6 != v7)
  {
    v8 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v8);
  }
  v9 = *(const PB::Base **)(v3 + 160);
  if (v9)
    this = PB::Writer::writeSubmessage(a2, v9);
  v10 = *(_DWORD *)(v3 + 204);
  if ((v10 & 0x100) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v10 = *(_DWORD *)(v3 + 204);
    if ((v10 & 2) == 0)
    {
LABEL_23:
      if ((v10 & 0x10000) == 0)
        goto LABEL_25;
      goto LABEL_24;
    }
  }
  else if ((v10 & 2) == 0)
  {
    goto LABEL_23;
  }
  this = PB::Writer::writeVarInt(a2);
  if ((*(_DWORD *)(v3 + 204) & 0x10000) != 0)
LABEL_24:
    this = PB::Writer::write(a2);
LABEL_25:
  v11 = *(const PB::Base **)(v3 + 120);
  if (v11)
    this = PB::Writer::writeSubmessage(a2, v11);
  v12 = *(_DWORD *)(v3 + 204);
  if ((v12 & 0x8000) != 0)
  {
    this = PB::Writer::write(a2);
    v12 = *(_DWORD *)(v3 + 204);
  }
  if ((v12 & 0x200) != 0)
    this = PB::Writer::writeVarInt(a2);
  if (*(_QWORD *)(v3 + 16))
    this = PB::Writer::write();
  v13 = *(const PB::Base **)(v3 + 128);
  if (v13)
    this = PB::Writer::writeSubmessage(a2, v13);
  v14 = *(const PB::Base **)(v3 + 8);
  if (v14)
    return PB::Writer::writeSubmessage(a2, v14);
  return this;
}

uint64_t statistics::Statistics::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  uint64_t v19;

  v4 = *(_QWORD *)(a1 + 112);
  v5 = *(_QWORD *)(a2 + 112);
  if (v4)
  {
    if (!v5 || !statistics::RawQuantitySample::operator==(v4, v5))
      return 0;
  }
  else if (v5)
  {
    return 0;
  }
  v6 = *(_DWORD *)(a1 + 204);
  v7 = *(_DWORD *)(a2 + 204);
  if ((v6 & 1) != 0)
  {
    if ((v7 & 1) == 0 || *(_QWORD *)(a1 + 24) != *(_QWORD *)(a2 + 24))
      return 0;
  }
  else if ((v7 & 1) != 0)
  {
    return 0;
  }
  if ((v6 & 0x400) != 0)
  {
    if ((v7 & 0x400) == 0 || *(double *)(a1 + 152) != *(double *)(a2 + 152))
      return 0;
  }
  else if ((v7 & 0x400) != 0)
  {
    return 0;
  }
  if ((v6 & 0x40) != 0)
  {
    if ((v7 & 0x40) == 0 || *(double *)(a1 + 96) != *(double *)(a2 + 96))
      return 0;
  }
  else if ((v7 & 0x40) != 0)
  {
    return 0;
  }
  if ((v6 & 0x80) != 0)
  {
    if ((v7 & 0x80) == 0 || *(double *)(a1 + 104) != *(double *)(a2 + 104))
      return 0;
  }
  else if ((v7 & 0x80) != 0)
  {
    return 0;
  }
  if ((v6 & 0x20) != 0)
  {
    if ((v7 & 0x20) == 0 || *(double *)(a1 + 88) != *(double *)(a2 + 88))
      return 0;
  }
  else if ((v7 & 0x20) != 0)
  {
    return 0;
  }
  if ((v6 & 0x2000) != 0)
  {
    if ((v7 & 0x2000) == 0 || *(double *)(a1 + 184) != *(double *)(a2 + 184))
      return 0;
  }
  else if ((v7 & 0x2000) != 0)
  {
    return 0;
  }
  if ((v6 & 0x4000) != 0)
  {
    if ((v7 & 0x4000) == 0 || *(double *)(a1 + 192) != *(double *)(a2 + 192))
      return 0;
  }
  else if ((v7 & 0x4000) != 0)
  {
    return 0;
  }
  if ((v6 & 0x10) != 0)
  {
    if ((v7 & 0x10) == 0 || *(double *)(a1 + 56) != *(double *)(a2 + 56))
      return 0;
  }
  else if ((v7 & 0x10) != 0)
  {
    return 0;
  }
  if ((v6 & 8) != 0)
  {
    if ((v7 & 8) == 0 || *(_QWORD *)(a1 + 48) != *(_QWORD *)(a2 + 48))
      return 0;
  }
  else if ((v7 & 8) != 0)
  {
    return 0;
  }
  if ((v6 & 4) != 0)
  {
    if ((v7 & 4) == 0 || *(double *)(a1 + 40) != *(double *)(a2 + 40))
      return 0;
  }
  else if ((v7 & 4) != 0)
  {
    return 0;
  }
  if ((v6 & 0x800) != 0)
  {
    if ((v7 & 0x800) == 0 || *(_QWORD *)(a1 + 168) != *(_QWORD *)(a2 + 168))
      return 0;
  }
  else if ((v7 & 0x800) != 0)
  {
    return 0;
  }
  if ((v6 & 0x1000) != 0)
  {
    if ((v7 & 0x1000) == 0 || *(double *)(a1 + 176) != *(double *)(a2 + 176))
      return 0;
  }
  else if ((v7 & 0x1000) != 0)
  {
    return 0;
  }
  result = PB::PtrVector<statistics::Interval>::operator==((uint64_t *)(a1 + 64), a2 + 64);
  if (!(_DWORD)result)
    return result;
  v9 = *(_QWORD *)(a1 + 160);
  v10 = *(_QWORD *)(a2 + 160);
  if (v9)
  {
    if (!v10 || !statistics::RawQuantitySample::operator==(v9, v10))
      return 0;
  }
  else if (v10)
  {
    return 0;
  }
  v11 = *(_DWORD *)(a1 + 204);
  v12 = *(_DWORD *)(a2 + 204);
  if ((v11 & 0x100) != 0)
  {
    if ((v12 & 0x100) == 0 || *(_QWORD *)(a1 + 136) != *(_QWORD *)(a2 + 136))
      return 0;
  }
  else if ((v12 & 0x100) != 0)
  {
    return 0;
  }
  if ((v11 & 2) != 0)
  {
    if ((v12 & 2) == 0 || *(_QWORD *)(a1 + 32) != *(_QWORD *)(a2 + 32))
      return 0;
  }
  else if ((v12 & 2) != 0)
  {
    return 0;
  }
  if ((v11 & 0x10000) != 0)
  {
    if ((v12 & 0x10000) == 0 || *(unsigned __int8 *)(a1 + 201) != *(unsigned __int8 *)(a2 + 201))
      return 0;
  }
  else if ((v12 & 0x10000) != 0)
  {
    return 0;
  }
  v13 = *(_QWORD *)(a1 + 120);
  v14 = *(_QWORD *)(a2 + 120);
  if (v13)
  {
    if (!v14
      || !statistics::QuantityOverlapProcessorState::operator==(v13, v14)
      && *(_QWORD *)(a1 + 120) | *(_QWORD *)(a2 + 120))
    {
      return 0;
    }
  }
  else if (v14)
  {
    return 0;
  }
  v15 = *(_DWORD *)(a1 + 204);
  v16 = *(_DWORD *)(a2 + 204);
  if ((v15 & 0x8000) != 0)
  {
    if ((v16 & 0x8000) == 0 || *(unsigned __int8 *)(a1 + 200) != *(unsigned __int8 *)(a2 + 200))
      return 0;
  }
  else if ((v16 & 0x8000) != 0)
  {
    return 0;
  }
  if ((v15 & 0x200) != 0)
  {
    if ((v16 & 0x200) == 0 || *(_QWORD *)(a1 + 144) != *(_QWORD *)(a2 + 144))
      return 0;
  }
  else if ((v16 & 0x200) != 0)
  {
    return 0;
  }
  v17 = *(unsigned __int8 **)(a1 + 16);
  v18 = *(unsigned __int8 **)(a2 + 16);
  if (v17)
  {
    if (!v18 || !std::operator==[abi:ne180100]<std::allocator<char>>(v17, v18))
      return 0;
  }
  else if (v18)
  {
    return 0;
  }
  v19 = *(_QWORD *)(a2 + 128);
  if (*(_QWORD *)(a1 + 128))
  {
    if (!v19 || (statistics::Statistics::operator==() & 1) == 0 && *(_QWORD *)(a1 + 128) | *(_QWORD *)(a2 + 128))
      return 0;
LABEL_114:
    if (!*(_QWORD *)(a1 + 8))
      return *(_QWORD *)(a2 + 8) == 0;
    if (*(_QWORD *)(a2 + 8))
    {
      if ((statistics::Statistics::operator==() & 1) != 0)
        return 1;
      if (!*(_QWORD *)(a1 + 8))
        return *(_QWORD *)(a2 + 8) == 0;
    }
    return 0;
  }
  if (!v19)
    goto LABEL_114;
  return 0;
}

BOOL PB::PtrVector<statistics::Interval>::operator==(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 result;
  BOOL v8;

  v2 = *a1;
  v3 = a1[1];
  v4 = *(uint64_t **)a2;
  if (v3 - *a1 != *(_QWORD *)(a2 + 8) - *(_QWORD *)a2)
    return 0;
  if (v2 == v3)
    return 1;
  v5 = v2 + 8;
  do
  {
    v6 = *v4++;
    result = statistics::Interval::operator==(*(_QWORD *)(v5 - 8), v6);
    v8 = !result || v5 == v3;
    v5 += 8;
  }
  while (!v8);
  return result;
}

BOOL std::operator==[abi:ne180100]<std::allocator<char>>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  BOOL v12;
  BOOL v13;
  _BOOL8 v14;

  v2 = a1[23];
  if ((v2 & 0x80u) == 0)
    v3 = a1[23];
  else
    v3 = *((_QWORD *)a1 + 1);
  v4 = a2[23];
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *((_QWORD *)a2 + 1);
  if (v3 != v4)
    return 0;
  if (v5 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v2 & 0x80) != 0)
    return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) == 0;
  if (!a1[23])
    return 1;
  v6 = v2 - 1;
  do
  {
    v8 = *a1++;
    v7 = v8;
    v10 = *a2++;
    v9 = v10;
    v12 = v6-- != 0;
    v13 = v7 == v9;
    v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

unint64_t statistics::Statistics::hash_value(statistics::Statistics *this)
{
  statistics::RawQuantitySample *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t i;
  uint64_t v20;
  double v21;
  double v22;
  statistics::RawQuantitySample *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  statistics::QuantityOverlapProcessorState *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  _QWORD *v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  statistics::Statistics *v113;
  uint64_t v114;
  unint64_t v115;
  int v117;
  uint64_t v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  statistics::QuantityOverlapProcessorState *v133;

  v2 = (statistics::RawQuantitySample *)*((_QWORD *)this + 14);
  if (v2)
    v3 = statistics::RawQuantitySample::hash_value(v2);
  else
    v3 = 0;
  v4 = *((_DWORD *)this + 51);
  if ((v4 & 1) == 0)
  {
    v5 = 0;
    if ((v4 & 0x400) != 0)
      goto LABEL_6;
LABEL_44:
    v6 = 0;
    if ((v4 & 0x40) != 0)
      goto LABEL_10;
LABEL_45:
    v7 = 0;
    if ((v4 & 0x80) != 0)
      goto LABEL_14;
LABEL_46:
    v8 = 0;
    if ((v4 & 0x20) != 0)
      goto LABEL_18;
LABEL_47:
    v9 = 0;
    if ((v4 & 0x2000) != 0)
      goto LABEL_22;
LABEL_48:
    v10 = 0;
    if ((v4 & 0x4000) != 0)
      goto LABEL_26;
LABEL_49:
    v11 = 0;
    if ((v4 & 0x10) != 0)
      goto LABEL_30;
LABEL_50:
    v12 = 0;
    if ((v4 & 8) != 0)
      goto LABEL_34;
    goto LABEL_51;
  }
  v5 = *((_QWORD *)this + 3);
  if ((v4 & 0x400) == 0)
    goto LABEL_44;
LABEL_6:
  if (*((double *)this + 19) == 0.0)
    v6 = 0;
  else
    v6 = *((_QWORD *)this + 19);
  if ((v4 & 0x40) == 0)
    goto LABEL_45;
LABEL_10:
  if (*((double *)this + 12) == 0.0)
    v7 = 0;
  else
    v7 = *((_QWORD *)this + 12);
  if ((v4 & 0x80) == 0)
    goto LABEL_46;
LABEL_14:
  if (*((double *)this + 13) == 0.0)
    v8 = 0;
  else
    v8 = *((_QWORD *)this + 13);
  if ((v4 & 0x20) == 0)
    goto LABEL_47;
LABEL_18:
  if (*((double *)this + 11) == 0.0)
    v9 = 0;
  else
    v9 = *((_QWORD *)this + 11);
  if ((v4 & 0x2000) == 0)
    goto LABEL_48;
LABEL_22:
  if (*((double *)this + 23) == 0.0)
    v10 = 0;
  else
    v10 = *((_QWORD *)this + 23);
  if ((v4 & 0x4000) == 0)
    goto LABEL_49;
LABEL_26:
  if (*((double *)this + 24) == 0.0)
    v11 = 0;
  else
    v11 = *((_QWORD *)this + 24);
  if ((v4 & 0x10) == 0)
    goto LABEL_50;
LABEL_30:
  if (*((double *)this + 7) == 0.0)
    v12 = 0;
  else
    v12 = *((_QWORD *)this + 7);
  if ((v4 & 8) != 0)
  {
LABEL_34:
    v13 = *((_QWORD *)this + 6);
    if ((v4 & 4) != 0)
      goto LABEL_35;
LABEL_52:
    v14 = 0;
    if ((v4 & 0x800) != 0)
      goto LABEL_39;
    goto LABEL_53;
  }
LABEL_51:
  v13 = 0;
  if ((v4 & 4) == 0)
    goto LABEL_52;
LABEL_35:
  if (*((double *)this + 5) == 0.0)
    v14 = 0;
  else
    v14 = *((_QWORD *)this + 5);
  if ((v4 & 0x800) != 0)
  {
LABEL_39:
    v15 = *((_QWORD *)this + 21);
    if ((v4 & 0x1000) != 0)
      goto LABEL_40;
LABEL_54:
    v16 = 0;
    goto LABEL_55;
  }
LABEL_53:
  v15 = 0;
  if ((v4 & 0x1000) == 0)
    goto LABEL_54;
LABEL_40:
  if (*((double *)this + 22) == 0.0)
    v16 = 0;
  else
    v16 = *((_QWORD *)this + 22);
LABEL_55:
  v17 = (uint64_t *)*((_QWORD *)this + 8);
  v18 = (uint64_t *)*((_QWORD *)this + 9);
  v129 = v12;
  v130 = v11;
  for (i = 0; v17 != v18; ++v17)
  {
    v20 = *v17;
    if ((*(_BYTE *)(*v17 + 24) & 2) != 0)
    {
      v21 = *(double *)(v20 + 16);
      if (v21 == 0.0)
        v21 = 0.0;
      if ((*(_BYTE *)(*v17 + 24) & 1) != 0)
      {
LABEL_58:
        v22 = *(double *)(v20 + 8);
        if (v22 == 0.0)
          v22 = 0.0;
        goto LABEL_65;
      }
    }
    else
    {
      v21 = 0.0;
      if ((*(_BYTE *)(*v17 + 24) & 1) != 0)
        goto LABEL_58;
    }
    v22 = 0.0;
LABEL_65:
    i ^= *(_QWORD *)&v21 ^ *(_QWORD *)&v22;
  }
  v23 = (statistics::RawQuantitySample *)*((_QWORD *)this + 20);
  v127 = v14;
  v128 = v13;
  v125 = v16;
  v126 = v15;
  if (v23)
  {
    v24 = statistics::RawQuantitySample::hash_value(v23);
    if ((v4 & 0x100) == 0)
      goto LABEL_68;
  }
  else
  {
    v24 = 0;
    if ((v4 & 0x100) == 0)
    {
LABEL_68:
      v25 = 0;
      if ((v4 & 2) != 0)
        goto LABEL_69;
LABEL_73:
      v26 = 0;
      if ((v4 & 0x10000) != 0)
        goto LABEL_70;
      goto LABEL_74;
    }
  }
  v25 = *((_QWORD *)this + 17);
  if ((v4 & 2) == 0)
    goto LABEL_73;
LABEL_69:
  v26 = *((_QWORD *)this + 4);
  if ((v4 & 0x10000) != 0)
  {
LABEL_70:
    v27 = *((unsigned __int8 *)this + 201);
    goto LABEL_75;
  }
LABEL_74:
  v27 = 0;
LABEL_75:
  v28 = (statistics::QuantityOverlapProcessorState *)*((_QWORD *)this + 15);
  v123 = v25;
  v124 = v24;
  v121 = v27;
  v122 = v26;
  if (v28)
  {
    v28 = (statistics::QuantityOverlapProcessorState *)statistics::QuantityOverlapProcessorState::hash_value(v28);
    v4 = *((_DWORD *)this + 51);
  }
  if ((v4 & 0x8000) != 0)
  {
    v29 = *((unsigned __int8 *)this + 200);
    if ((v4 & 0x200) != 0)
      goto LABEL_79;
  }
  else
  {
    v29 = 0;
    if ((v4 & 0x200) != 0)
    {
LABEL_79:
      v30 = *((_QWORD *)this + 18);
      goto LABEL_82;
    }
  }
  v30 = 0;
LABEL_82:
  v31 = (unsigned __int8 *)*((_QWORD *)this + 2);
  v132 = v9;
  v133 = v28;
  v131 = v8;
  if (!v31)
  {
    v34 = v5;
    v35 = v3;
    v39 = 0;
    goto LABEL_99;
  }
  v32 = *((_QWORD *)v31 + 1);
  if ((v31[23] & 0x80u) == 0)
  {
    v33 = v31[23];
  }
  else
  {
    v31 = *(unsigned __int8 **)v31;
    v33 = v32;
  }
  v34 = v5;
  v35 = v3;
  if (v33 > 0x20)
  {
    if (v33 > 0x40)
    {
      v65 = 0x9DDFEA08EB382D69;
      v75 = *(_QWORD *)&v31[v33 - 48];
      v74 = *(_QWORD *)&v31[v33 - 40];
      v76 = *(_QWORD *)&v31[v33 - 24];
      v78 = *(_QWORD *)&v31[v33 - 64];
      v77 = *(_QWORD *)&v31[v33 - 56];
      v79 = *(_QWORD *)&v31[v33 - 16];
      v80 = *(_QWORD *)&v31[v33 - 8];
      v81 = v77 + v79;
      v82 = 0x9DDFEA08EB382D69
          * (v76 ^ ((0x9DDFEA08EB382D69 * (v76 ^ (v75 + v33))) >> 47) ^ (0x9DDFEA08EB382D69 * (v76 ^ (v75 + v33))));
      v83 = 0x9DDFEA08EB382D69 * (v82 ^ (v82 >> 47));
      v84 = v75 + v77 + v78 + v33;
      v85 = v84 + v74;
      v86 = __ROR8__(v84, 44) + v78 + v33 + __ROR8__(v78 + v33 + v74 - 0x622015F714C7D297 * (v82 ^ (v82 >> 47)), 21);
      v87 = v77 + v79 + *(_QWORD *)&v31[v33 - 32] - 0x4B6D499041670D8DLL;
      v88 = v76 + v79 + v87;
      v89 = __ROR8__(v88, 44);
      v90 = v88 + v80;
      v91 = v89 + v87 + __ROR8__(v87 + v74 + v80, 21);
      v93 = *(_QWORD *)v31;
      v92 = v31 + 32;
      v94 = v93 - 0x4B6D499041670D8DLL * v74;
      v95 = -(uint64_t)((v33 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        v96 = *(v92 - 3);
        v97 = v94 + v85 + v81 + v96;
        v98 = v92[2];
        v99 = v92[3];
        v100 = v92[1];
        v81 = v100 + v85 - 0x4B6D499041670D8DLL * __ROR8__(v81 + v86 + v98, 42);
        v101 = v83 + v90;
        v102 = *(v92 - 2);
        v103 = *(v92 - 1);
        v104 = *(v92 - 4) - 0x4B6D499041670D8DLL * v86;
        v105 = v104 + v90 + v103;
        v106 = v104 + v96 + v102;
        v85 = v106 + v103;
        v107 = __ROR8__(v106, 44) + v104;
        v108 = (0xB492B66FBE98F273 * __ROR8__(v97, 37)) ^ v91;
        v94 = 0xB492B66FBE98F273 * __ROR8__(v101, 33);
        v86 = v107 + __ROR8__(v105 + v108, 21);
        v109 = v94 + v91 + *v92;
        v90 = v100 + v98 + v109 + v99;
        v91 = __ROR8__(v100 + v98 + v109, 44) + v109 + __ROR8__(v81 + v102 + v109 + v99, 21);
        v92 += 8;
        v83 = v108;
        v95 += 64;
      }
      while (v95);
      v110 = 0x9DDFEA08EB382D69
           * (v90 ^ ((0x9DDFEA08EB382D69 * (v90 ^ v85)) >> 47) ^ (0x9DDFEA08EB382D69 * (v90 ^ v85)));
      v111 = v94
           - 0x622015F714C7D297
           * ((0x9DDFEA08EB382D69
             * (v91 ^ ((0x9DDFEA08EB382D69 * (v91 ^ v86)) >> 47) ^ (0x9DDFEA08EB382D69 * (v91 ^ v86)))) ^ ((0x9DDFEA08EB382D69 * (v91 ^ ((0x9DDFEA08EB382D69 * (v91 ^ v86)) >> 47) ^ (0x9DDFEA08EB382D69 * (v91 ^ v86)))) >> 47));
      v112 = 0x9DDFEA08EB382D69
           * (v111 ^ (v108 - 0x4B6D499041670D8DLL * (v81 ^ (v81 >> 47)) - 0x622015F714C7D297 * (v110 ^ (v110 >> 47))));
      v66 = 0x9DDFEA08EB382D69 * (v111 ^ (v112 >> 47) ^ v112);
    }
    else
    {
      v40 = &v31[v33];
      v41 = *(_QWORD *)&v31[v33 - 16];
      v42 = *(_QWORD *)&v31[v33 - 8];
      v43 = *((_QWORD *)v31 + 1);
      v44 = *(_QWORD *)v31 - 0x3C5A37A36834CED9 * (v41 + v33);
      v47 = v31 + 16;
      v45 = *((_QWORD *)v31 + 2);
      v46 = *((_QWORD *)v47 + 1);
      v48 = __ROR8__(v44 + v46, 52);
      v49 = __ROR8__(v44, 37);
      v50 = v44 + v43;
      v51 = __ROR8__(v50, 7);
      v52 = v50 + v45;
      v53 = v51 + v49;
      v54 = *((_QWORD *)v40 - 4) + v45;
      v55 = v42 + v46;
      v56 = __ROR8__(v55 + v54, 52);
      v57 = v53 + v48;
      v58 = __ROR8__(v54, 37);
      v59 = *((_QWORD *)v40 - 3) + v54;
      v60 = __ROR8__(v59, 7);
      v61 = v57 + __ROR8__(v52, 31);
      v62 = v59 + v41;
      v63 = v62 + v55;
      v64 = v52 + v46 + v58 + v60 + v56 + __ROR8__(v62, 31);
      v65 = 0x9AE16A3B2F90404FLL;
      v66 = v61
          - 0x3C5A37A36834CED9
          * ((0xC3A5C85C97CB3127 * (v63 + v61) - 0x651E95C4D06FBFB1 * v64) ^ ((0xC3A5C85C97CB3127 * (v63 + v61)
                                                                                 - 0x651E95C4D06FBFB1 * v64) >> 47));
    }
    v39 = (v66 ^ (v66 >> 47)) * v65;
  }
  else
  {
    if (v33 > 0x10)
    {
      v67 = *((_QWORD *)v31 + 1);
      v68 = 0xB492B66FBE98F273 * *(_QWORD *)v31;
      v69 = 0x9AE16A3B2F90404FLL * *(_QWORD *)&v31[v33 - 8];
      v70 = __ROR8__(v69, 30) + __ROR8__(v68 - v67, 43);
      v71 = v68 + v33 + __ROR8__(v67 ^ 0xC949D7C7509E6557, 20) - v69;
      v72 = 0x9DDFEA08EB382D69 * ((v70 - 0x3C5A37A36834CED9 * *(_QWORD *)&v31[v33 - 16]) ^ v71);
      v73 = v71 ^ (v72 >> 47) ^ v72;
LABEL_94:
      v39 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v73) ^ ((0x9DDFEA08EB382D69 * v73) >> 47));
      goto LABEL_99;
    }
    if (v33 >= 9)
    {
      v36 = *(_QWORD *)v31;
      v37 = *(_QWORD *)&v31[v33 - 8];
      v38 = __ROR8__(v37 + v33, v33);
      v39 = (0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69
             * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v36)))) ^ ((0x9DDFEA08EB382D69 * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v36)))) >> 47))) ^ v37;
      goto LABEL_99;
    }
    if (v33 >= 4)
    {
      v117 = *(_DWORD *)v31;
      v118 = *(unsigned int *)&v31[v33 - 4];
      v119 = 0x9DDFEA08EB382D69 * ((v33 + (8 * v117)) ^ v118);
      v73 = v118 ^ (v119 >> 47) ^ v119;
      goto LABEL_94;
    }
    v39 = 0x9AE16A3B2F90404FLL;
    if (v33)
    {
      v120 = (0xC949D7C7509E6557 * (v33 + 4 * v31[v33 - 1])) ^ (0x9AE16A3B2F90404FLL
                                                                  * (*v31 | ((unint64_t)v31[v33 >> 1] << 8)));
      v39 = 0x9AE16A3B2F90404FLL * (v120 ^ (v120 >> 47));
    }
  }
LABEL_99:
  v113 = (statistics::Statistics *)*((_QWORD *)this + 16);
  if (v113)
    v114 = statistics::Statistics::hash_value(v113);
  else
    v114 = 0;
  v115 = *((_QWORD *)this + 1);
  if (v115)
    v115 = statistics::Statistics::hash_value((statistics::Statistics *)v115);
  return v34 ^ v35 ^ v6 ^ v7 ^ v131 ^ v132 ^ v10 ^ v130 ^ v129 ^ v128 ^ v127 ^ v126 ^ v125 ^ i ^ v124 ^ v123 ^ v122 ^ v121 ^ (unint64_t)v133 ^ v29 ^ v30 ^ v39 ^ v114 ^ v115;
}

_QWORD *statistics::Statistics::makeMostRecentDatum(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;

  if (!this[14])
  {
    v1 = this;
    v2 = operator new();
    *(_QWORD *)v2 = &off_1E6CFF278;
    *(_DWORD *)(v2 + 44) = 0;
    this = (_QWORD *)v1[14];
    v1[14] = v2;
    if (this)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

_QWORD *statistics::Statistics::makeUnfinishedDatum(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;

  if (!this[20])
  {
    v1 = this;
    v2 = operator new();
    *(_QWORD *)v2 = &off_1E6CFF278;
    *(_DWORD *)(v2 + 44) = 0;
    this = (_QWORD *)v1[20];
    v1[20] = v2;
    if (this)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

_QWORD *statistics::Statistics::makeOverlapProcessorState(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;

  if (!this[15])
  {
    v1 = this;
    v2 = operator new();
    *(_QWORD *)v2 = off_1E6D037C8;
    *(_QWORD *)(v2 + 40) = 0;
    *(_QWORD *)(v2 + 48) = 0;
    *(_QWORD *)(v2 + 32) = 0;
    *(_DWORD *)(v2 + 60) = 0;
    this = (_QWORD *)v1[15];
    v1[15] = v2;
    if (this)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

_QWORD *statistics::Statistics::makePrimaryStatistics(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;

  if (!this[16])
  {
    v1 = this;
    v2 = operator new();
    *(_QWORD *)(v2 + 72) = 0;
    *(_QWORD *)(v2 + 80) = 0;
    *(_QWORD *)(v2 + 64) = 0;
    *(_QWORD *)(v2 + 160) = 0;
    *(_DWORD *)(v2 + 204) = 0;
    *(_QWORD *)(v2 + 8) = 0;
    *(_QWORD *)(v2 + 16) = 0;
    *(_QWORD *)v2 = &off_1E6CEA528;
    *(_QWORD *)(v2 + 120) = 0;
    *(_QWORD *)(v2 + 128) = 0;
    *(_QWORD *)(v2 + 112) = 0;
    this = (_QWORD *)v1[16];
    v1[16] = v2;
    if (this)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

_QWORD *statistics::Statistics::makeAuxiliaryStatistics(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;

  if (!this[1])
  {
    v1 = this;
    v2 = operator new();
    *(_QWORD *)(v2 + 72) = 0;
    *(_QWORD *)(v2 + 80) = 0;
    *(_QWORD *)(v2 + 64) = 0;
    *(_QWORD *)(v2 + 160) = 0;
    *(_DWORD *)(v2 + 204) = 0;
    *(_QWORD *)(v2 + 8) = 0;
    *(_QWORD *)(v2 + 16) = 0;
    *(_QWORD *)v2 = &off_1E6CEA528;
    *(_QWORD *)(v2 + 120) = 0;
    *(_QWORD *)(v2 + 128) = 0;
    *(_QWORD *)(v2 + 112) = 0;
    this = (_QWORD *)v1[1];
    v1[1] = v2;
    if (this)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

void std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6CE6208, MEMORY[0x1E0DE42D0]);
}

void sub_1B789EAE8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

void std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v1 = (_QWORD *)*a1;
  if (*a1)
  {
    v3 = (_QWORD *)a1[1];
    v4 = (_QWORD *)*a1;
    if (v3 != v1)
    {
      do
      {
        v6 = *--v3;
        v5 = v6;
        *v3 = 0;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      }
      while (v3 != v1);
      v4 = (_QWORD *)*a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::default_delete<std::string>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(char *)(a2 + 23) < 0)
      operator delete(*(void **)a2);
    JUMPOUT(0x1BCCAC494);
  }
}

void std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

uint64_t std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

double statistics::StatisticsBucket::StatisticsBucket(statistics::StatisticsBucket *this)
{
  double result;

  *(_QWORD *)this = &off_1E6CEA578;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 47) = 0;
  result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_QWORD *)this + 22) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_1E6CEA578;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 47) = 0;
  result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_QWORD *)this + 22) = 0;
  return result;
}

void statistics::StatisticsBucket::~StatisticsBucket(statistics::StatisticsBucket *this)
{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_1E6CEA578;
  v3 = (void **)((char *)this + 160);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 136);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 112);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)((char *)this + 80);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

{
  statistics::StatisticsBucket::~StatisticsBucket(this);
  JUMPOUT(0x1BCCAC494);
}

statistics::StatisticsBucket *statistics::StatisticsBucket::StatisticsBucket(statistics::StatisticsBucket *this, const statistics::StatisticsBucket *a2)
{
  uint64_t **v4;
  uint64_t **v5;
  statistics::Statistics ***v6;
  statistics::Statistics ***v7;
  __int16 v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const statistics::RawQuantitySample **v13;
  const statistics::RawQuantitySample **v14;
  statistics::Statistics *v15;
  statistics::Statistics *v16;
  uint64_t v17;
  const statistics::RawQuantitySample ***v18;
  const statistics::RawQuantitySample ***v19;
  const statistics::RawQuantitySample ***v20;
  const statistics::RawQuantitySample ***v21;
  const statistics::RawQuantitySample ***v22;
  const statistics::RawQuantitySample ***i;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v27;
  char v28;
  char v29;
  char v30;
  char v31;
  uint64_t v32;
  uint64_t v33;

  *(_QWORD *)this = &off_1E6CEA578;
  *((_QWORD *)this + 5) = 0;
  v4 = (uint64_t **)((char *)this + 40);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_OWORD *)this + 5) = 0u;
  v5 = (uint64_t **)((char *)this + 80);
  *((_OWORD *)this + 7) = 0u;
  v6 = (statistics::Statistics ***)((char *)this + 112);
  *((_OWORD *)this + 10) = 0u;
  v7 = (statistics::Statistics ***)((char *)this + 160);
  *((_DWORD *)this + 47) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_QWORD *)this + 22) = 0;
  v8 = *((_WORD *)a2 + 94);
  if ((v8 & 2) != 0)
  {
    v10 = *((_QWORD *)a2 + 2);
    v9 = 2;
    *((_WORD *)this + 94) = 2;
    *((_QWORD *)this + 2) = v10;
    v8 = *((_WORD *)a2 + 94);
    if ((v8 & 1) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v9 = 0;
  if ((v8 & 1) != 0)
  {
LABEL_5:
    v11 = *((_QWORD *)a2 + 1);
    v9 |= 1u;
    *((_WORD *)this + 94) = v9;
    *((_QWORD *)this + 1) = v11;
    v8 = *((_WORD *)a2 + 94);
  }
LABEL_6:
  if ((v8 & 0x10) != 0)
  {
    v27 = *((_QWORD *)a2 + 8);
    v9 |= 0x10u;
    *((_WORD *)this + 94) = v9;
    *((_QWORD *)this + 8) = v27;
    v8 = *((_WORD *)a2 + 94);
    if ((v8 & 0x80) == 0)
    {
LABEL_8:
      if ((v8 & 0x200) == 0)
        goto LABEL_9;
      goto LABEL_35;
    }
  }
  else if ((v8 & 0x80) == 0)
  {
    goto LABEL_8;
  }
  v28 = *((_BYTE *)a2 + 185);
  v9 |= 0x80u;
  *((_WORD *)this + 94) = v9;
  *((_BYTE *)this + 185) = v28;
  v8 = *((_WORD *)a2 + 94);
  if ((v8 & 0x200) == 0)
  {
LABEL_9:
    if ((v8 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_36;
  }
LABEL_35:
  v29 = *((_BYTE *)a2 + 187);
  v9 |= 0x200u;
  *((_WORD *)this + 94) = v9;
  *((_BYTE *)this + 187) = v29;
  v8 = *((_WORD *)a2 + 94);
  if ((v8 & 0x100) == 0)
  {
LABEL_10:
    if ((v8 & 0x40) == 0)
      goto LABEL_11;
    goto LABEL_37;
  }
LABEL_36:
  v30 = *((_BYTE *)a2 + 186);
  v9 |= 0x100u;
  *((_WORD *)this + 94) = v9;
  *((_BYTE *)this + 186) = v30;
  v8 = *((_WORD *)a2 + 94);
  if ((v8 & 0x40) == 0)
  {
LABEL_11:
    if ((v8 & 8) == 0)
      goto LABEL_12;
    goto LABEL_38;
  }
LABEL_37:
  v31 = *((_BYTE *)a2 + 184);
  v9 |= 0x40u;
  *((_WORD *)this + 94) = v9;
  *((_BYTE *)this + 184) = v31;
  v8 = *((_WORD *)a2 + 94);
  if ((v8 & 8) == 0)
  {
LABEL_12:
    if ((v8 & 4) == 0)
      goto LABEL_13;
LABEL_39:
    v33 = *((_QWORD *)a2 + 3);
    v9 |= 4u;
    *((_WORD *)this + 94) = v9;
    *((_QWORD *)this + 3) = v33;
    if ((*((_WORD *)a2 + 94) & 0x20) == 0)
      goto LABEL_15;
    goto LABEL_14;
  }
LABEL_38:
  v32 = *((_QWORD *)a2 + 4);
  v9 |= 8u;
  *((_WORD *)this + 94) = v9;
  *((_QWORD *)this + 4) = v32;
  v8 = *((_WORD *)a2 + 94);
  if ((v8 & 4) != 0)
    goto LABEL_39;
LABEL_13:
  if ((v8 & 0x20) != 0)
  {
LABEL_14:
    v12 = *((_QWORD *)a2 + 9);
    *((_WORD *)this + 94) = v9 | 0x20;
    *((_QWORD *)this + 9) = v12;
  }
LABEL_15:
  v13 = (const statistics::RawQuantitySample **)*((_QWORD *)a2 + 10);
  v14 = (const statistics::RawQuantitySample **)*((_QWORD *)a2 + 11);
  while (v13 != v14)
    PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample const&>(v5, *v13++);
  if (*((_QWORD *)a2 + 13))
  {
    v15 = (statistics::Statistics *)operator new();
    v16 = statistics::Statistics::Statistics(v15, *((const statistics::RawQuantitySample ***)a2 + 13));
    v17 = *((_QWORD *)this + 13);
    *((_QWORD *)this + 13) = v16;
    if (v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  }
  v18 = (const statistics::RawQuantitySample ***)*((_QWORD *)a2 + 20);
  v19 = (const statistics::RawQuantitySample ***)*((_QWORD *)a2 + 21);
  while (v18 != v19)
    PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>(v7, *v18++);
  v20 = (const statistics::RawQuantitySample ***)*((_QWORD *)a2 + 14);
  v21 = (const statistics::RawQuantitySample ***)*((_QWORD *)a2 + 15);
  while (v20 != v21)
    PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>(v6, *v20++);
  v22 = (const statistics::RawQuantitySample ***)*((_QWORD *)a2 + 17);
  for (i = (const statistics::RawQuantitySample ***)*((_QWORD *)a2 + 18); v22 != i; ++v22)
    PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>((statistics::Statistics ***)this + 17, *v22);
  v25 = (uint64_t *)*((_QWORD *)a2 + 5);
  v24 = (uint64_t *)*((_QWORD *)a2 + 6);
  while (v25 != v24)
    PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval const&>(v4, *v25++);
  return this;
}

uint64_t PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample const&>(uint64_t **a1, const statistics::RawQuantitySample *a2)
{
  uint64_t v4;
  uint64_t result;
  unint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  int64x2_t v19;
  uint64_t *v20;
  uint64_t v21;
  int64x2_t v22;
  char *v23;
  _QWORD *v24;

  v4 = operator new();
  statistics::RawQuantitySample::RawQuantitySample(v4, a2);
  result = (uint64_t)(a1 + 2);
  v6 = (unint64_t)a1[2];
  v7 = a1[1];
  if ((unint64_t)v7 >= v6)
  {
    v9 = v7 - *a1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v10 = v6 - (_QWORD)*a1;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    v24 = a1 + 2;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(result, v12);
    else
      v13 = 0;
    v14 = (uint64_t *)&v13[8 * v9];
    v15 = &v13[8 * v12];
    v23 = v15;
    *v14 = v4;
    v8 = v14 + 1;
    v22.i64[1] = (uint64_t)(v14 + 1);
    v17 = *a1;
    v16 = a1[1];
    if (v16 == *a1)
    {
      v19 = vdupq_n_s64((unint64_t)v16);
    }
    else
    {
      do
      {
        v18 = *--v16;
        *v16 = 0;
        *--v14 = v18;
      }
      while (v16 != v17);
      v19 = *(int64x2_t *)a1;
      v8 = (uint64_t *)v22.i64[1];
      v15 = v23;
    }
    *a1 = v14;
    a1[1] = v8;
    v22 = v19;
    v20 = a1[2];
    a1[2] = (uint64_t *)v15;
    v23 = (char *)v20;
    v21 = v19.i64[0];
    result = std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v21);
  }
  else
  {
    *v7 = v4;
    v8 = v7 + 1;
  }
  a1[1] = v8;
  return result;
}

void sub_1B789F1A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>(statistics::Statistics ***a1, const statistics::RawQuantitySample **a2)
{
  statistics::Statistics *v4;
  uint64_t result;
  unint64_t v6;
  statistics::Statistics **v7;
  statistics::Statistics **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  statistics::Statistics **v14;
  char *v15;
  statistics::Statistics **v16;
  statistics::Statistics **v17;
  statistics::Statistics *v18;
  int64x2_t v19;
  statistics::Statistics **v20;
  uint64_t v21;
  int64x2_t v22;
  char *v23;
  _QWORD *v24;

  v4 = (statistics::Statistics *)operator new();
  statistics::Statistics::Statistics(v4, a2);
  result = (uint64_t)(a1 + 2);
  v6 = (unint64_t)a1[2];
  v7 = a1[1];
  if ((unint64_t)v7 >= v6)
  {
    v9 = v7 - *a1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v10 = v6 - (_QWORD)*a1;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    v24 = a1 + 2;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(result, v12);
    else
      v13 = 0;
    v14 = (statistics::Statistics **)&v13[8 * v9];
    v15 = &v13[8 * v12];
    v23 = v15;
    *v14 = v4;
    v8 = v14 + 1;
    v22.i64[1] = (uint64_t)(v14 + 1);
    v17 = *a1;
    v16 = a1[1];
    if (v16 == *a1)
    {
      v19 = vdupq_n_s64((unint64_t)v16);
    }
    else
    {
      do
      {
        v18 = *--v16;
        *v16 = 0;
        *--v14 = v18;
      }
      while (v16 != v17);
      v19 = *(int64x2_t *)a1;
      v8 = (statistics::Statistics **)v22.i64[1];
      v15 = v23;
    }
    *a1 = v14;
    a1[1] = v8;
    v22 = v19;
    v20 = a1[2];
    a1[2] = (statistics::Statistics **)v15;
    v23 = (char *)v20;
    v21 = v19.i64[0];
    result = std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v21);
  }
  else
  {
    *v7 = v4;
    v8 = v7 + 1;
  }
  a1[1] = v8;
  return result;
}

void sub_1B789F2F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

statistics *statistics::StatisticsBucket::operator=(statistics *a1, const statistics::StatisticsBucket *a2)
{
  statistics::StatisticsBucket *v3;
  _BYTE v5[192];

  if (a1 != a2)
  {
    statistics::StatisticsBucket::StatisticsBucket((statistics::StatisticsBucket *)v5, a2);
    statistics::swap(a1, (statistics::StatisticsBucket *)v5, v3);
    statistics::StatisticsBucket::~StatisticsBucket((statistics::StatisticsBucket *)v5);
  }
  return a1;
}

double statistics::swap(statistics *this, statistics::StatisticsBucket *a2, statistics::StatisticsBucket *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v3 = *((_DWORD *)this + 47);
  *((_DWORD *)this + 47) = *((_DWORD *)a2 + 47);
  *((_DWORD *)a2 + 47) = v3;
  v4 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = v4;
  v5 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = v5;
  v6 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = *((_QWORD *)a2 + 8);
  *((_QWORD *)a2 + 8) = v6;
  LOBYTE(v3) = *((_BYTE *)this + 185);
  *((_BYTE *)this + 185) = *((_BYTE *)a2 + 185);
  *((_BYTE *)a2 + 185) = v3;
  LOBYTE(v3) = *((_BYTE *)this + 187);
  *((_BYTE *)this + 187) = *((_BYTE *)a2 + 187);
  *((_BYTE *)a2 + 187) = v3;
  LOBYTE(v3) = *((_BYTE *)this + 186);
  *((_BYTE *)this + 186) = *((_BYTE *)a2 + 186);
  *((_BYTE *)a2 + 186) = v3;
  LOBYTE(v3) = *((_BYTE *)this + 184);
  *((_BYTE *)this + 184) = *((_BYTE *)a2 + 184);
  *((_BYTE *)a2 + 184) = v3;
  v7 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 4) = v7;
  v8 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  *((_QWORD *)a2 + 3) = v8;
  result = *((double *)this + 9);
  *((_QWORD *)this + 9) = *((_QWORD *)a2 + 9);
  *((double *)a2 + 9) = result;
  v10 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = *((_QWORD *)a2 + 10);
  *((_QWORD *)a2 + 10) = v10;
  v11 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = *((_QWORD *)a2 + 11);
  *((_QWORD *)a2 + 11) = v11;
  v12 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = *((_QWORD *)a2 + 12);
  *((_QWORD *)a2 + 12) = v12;
  v13 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = *((_QWORD *)a2 + 13);
  *((_QWORD *)a2 + 13) = v13;
  v14 = *((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = *((_QWORD *)a2 + 20);
  *((_QWORD *)a2 + 20) = v14;
  v15 = *((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = *((_QWORD *)a2 + 21);
  *((_QWORD *)a2 + 21) = v15;
  v16 = *((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = *((_QWORD *)a2 + 22);
  *((_QWORD *)a2 + 22) = v16;
  v17 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = *((_QWORD *)a2 + 14);
  *((_QWORD *)a2 + 14) = v17;
  v18 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = *((_QWORD *)a2 + 15);
  *((_QWORD *)a2 + 15) = v18;
  v19 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = *((_QWORD *)a2 + 16);
  *((_QWORD *)a2 + 16) = v19;
  v20 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = *((_QWORD *)a2 + 17);
  *((_QWORD *)a2 + 17) = v20;
  v21 = *((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = *((_QWORD *)a2 + 18);
  *((_QWORD *)a2 + 18) = v21;
  v22 = *((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = *((_QWORD *)a2 + 19);
  *((_QWORD *)a2 + 19) = v22;
  v23 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 5) = v23;
  v24 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = v24;
  v25 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *((_QWORD *)a2 + 7) = v25;
  return result;
}

uint64_t statistics::StatisticsBucket::StatisticsBucket(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = &off_1E6CEA578;
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (_QWORD *)(a1 + 40);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  v5 = (_OWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 188);
  *(_DWORD *)(a2 + 188) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 185) = *(_BYTE *)(a2 + 185);
  *(_BYTE *)(a1 + 187) = *(_BYTE *)(a2 + 187);
  *(_BYTE *)(a1 + 186) = *(_BYTE *)(a2 + 186);
  *(_BYTE *)(a1 + 184) = *(_BYTE *)(a2 + 184);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((_QWORD *)(a1 + 80));
  *v5 = *(_OWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(_QWORD *)(a2 + 104);
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  v7 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = v6;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((_QWORD *)(a1 + 160));
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
  *(_QWORD *)(a2 + 160) = 0;
  *(_QWORD *)(a2 + 168) = 0;
  *(_QWORD *)(a2 + 176) = 0;
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((_QWORD *)(a1 + 112));
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((_QWORD *)(a1 + 136));
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a2 + 136) = 0;
  *(_QWORD *)(a2 + 144) = 0;
  *(_QWORD *)(a2 + 152) = 0;
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate(v4);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return a1;
}

statistics *statistics::StatisticsBucket::operator=(statistics *a1, uint64_t a2)
{
  statistics::StatisticsBucket *v3;
  _BYTE v5[192];

  if (a1 != (statistics *)a2)
  {
    statistics::StatisticsBucket::StatisticsBucket((uint64_t)v5, a2);
    statistics::swap(a1, (statistics::StatisticsBucket *)v5, v3);
    statistics::StatisticsBucket::~StatisticsBucket((statistics::StatisticsBucket *)v5);
  }
  return a1;
}

uint64_t statistics::StatisticsBucket::formatText(statistics::StatisticsBucket *this, PB::TextFormatter *a2, const char *a3)
{
  __int16 v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  __int16 v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_WORD *)this + 94);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "bucketEndTime", *((double *)this + 1));
    v5 = *((_WORD *)this + 94);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_30;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "bucketStartTime", *((double *)this + 2));
  v5 = *((_WORD *)this + 94);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
    goto LABEL_31;
  }
LABEL_30:
  PB::TextFormatter::format(a2, "dataEndTime", *((double *)this + 3));
  v5 = *((_WORD *)this + 94);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x40) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_31:
  PB::TextFormatter::format(a2, "dataStartTime", *((double *)this + 4));
  if ((*((_WORD *)this + 94) & 0x40) != 0)
LABEL_6:
    PB::TextFormatter::format(a2, "inclusiveEndTimeBoundary");
LABEL_7:
  v6 = (uint64_t *)*((_QWORD *)this + 5);
  v7 = (uint64_t *)*((_QWORD *)this + 6);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "maskedIntervals");
  }
  v9 = *((_WORD *)this + 94);
  if ((v9 & 0x10) != 0)
  {
    PB::TextFormatter::format(a2, "mergeGranularity", *((double *)this + 8));
    v9 = *((_WORD *)this + 94);
  }
  if ((v9 & 0x20) != 0)
    PB::TextFormatter::format(a2, "mergePoint", *((double *)this + 9));
  v10 = (uint64_t *)*((_QWORD *)this + 10);
  v11 = (uint64_t *)*((_QWORD *)this + 11);
  while (v10 != v11)
  {
    v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v12 + 32))(v12, a2, "remainders");
  }
  v13 = *((_WORD *)this + 94);
  if ((v13 & 0x80) != 0)
  {
    PB::TextFormatter::format(a2, "shouldCombineSources");
    v13 = *((_WORD *)this + 94);
    if ((v13 & 0x100) == 0)
    {
LABEL_17:
      if ((v13 & 0x200) == 0)
        goto LABEL_19;
      goto LABEL_18;
    }
  }
  else if ((*((_WORD *)this + 94) & 0x100) == 0)
  {
    goto LABEL_17;
  }
  PB::TextFormatter::format(a2, "shouldComputePerBundleIDStatistics");
  if ((*((_WORD *)this + 94) & 0x200) != 0)
LABEL_18:
    PB::TextFormatter::format(a2, "shouldComputePerSourceIDStatistics");
LABEL_19:
  v14 = *((_QWORD *)this + 13);
  if (v14)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v14 + 32))(v14, a2, "statistics");
  v15 = (uint64_t *)*((_QWORD *)this + 14);
  v16 = (uint64_t *)*((_QWORD *)this + 15);
  while (v15 != v16)
  {
    v17 = *v15++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v17 + 32))(v17, a2, "statisticsByBundleIdentifier");
  }
  v18 = (uint64_t *)*((_QWORD *)this + 17);
  v19 = (uint64_t *)*((_QWORD *)this + 18);
  while (v18 != v19)
  {
    v20 = *v18++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v20 + 32))(v20, a2, "statisticsByCanonicalSourceID");
  }
  v21 = (uint64_t *)*((_QWORD *)this + 20);
  v22 = (uint64_t *)*((_QWORD *)this + 21);
  while (v21 != v22)
  {
    v23 = *v21++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v23 + 32))(v23, a2, "statisticsBySourceID");
  }
  return PB::TextFormatter::endObject(a2);
}

uint64_t statistics::StatisticsBucket::readFrom(statistics::StatisticsBucket *this, PB::Reader *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  char v21;
  unsigned int v22;
  unint64_t v23;
  char v24;
  uint64_t result;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  BOOL v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  BOOL v42;
  unint64_t v43;
  unint64_t v44;
  int v45;
  BOOL v46;
  unint64_t v47;
  unint64_t v48;
  int v49;
  BOOL v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t **v54;

  v4 = *((_QWORD *)a2 + 1);
  v5 = *((_QWORD *)a2 + 2);
  v6 = *((unsigned __int8 *)a2 + 24);
  if (v4 >= v5 || v6 != 0)
    return v6 == 0;
  v10 = (uint64_t **)((char *)this + 40);
  v11 = (uint64_t **)((char *)this + 136);
  v12 = (uint64_t **)((char *)this + 112);
  v13 = (uint64_t **)((char *)this + 160);
  v54 = (uint64_t **)((char *)this + 80);
  while (1)
  {
    v14 = *(_QWORD *)a2;
    if (v4 <= 0xFFFFFFFFFFFFFFF5 && v4 + 10 <= v5)
    {
      v15 = 0;
      v16 = 0;
      v17 = 0;
      while (1)
      {
        v18 = v4 + 1;
        *((_QWORD *)a2 + 1) = v4 + 1;
        v19 = *(_BYTE *)(v14 + v4);
        v17 |= (unint64_t)(v19 & 0x7F) << v15;
        if ((v19 & 0x80) == 0)
          break;
        v15 += 7;
        v4 = v18;
        v20 = v16++ > 8;
        if (v20)
          goto LABEL_20;
      }
LABEL_22:
      if ((v17 & 7) == 4)
      {
        v6 = 0;
        return v6 == 0;
      }
      v26 = v17 >> 3;
      switch((v17 >> 3))
      {
        case 1u:
          *((_WORD *)this + 94) |= 2u;
          v27 = *((_QWORD *)a2 + 1);
          if (v27 > 0xFFFFFFFFFFFFFFF7 || v27 + 8 > *((_QWORD *)a2 + 2))
            goto LABEL_54;
          *((_QWORD *)this + 2) = *(_QWORD *)(*(_QWORD *)a2 + v27);
          goto LABEL_72;
        case 2u:
          *((_WORD *)this + 94) |= 1u;
          v33 = *((_QWORD *)a2 + 1);
          if (v33 > 0xFFFFFFFFFFFFFFF7 || v33 + 8 > *((_QWORD *)a2 + 2))
            goto LABEL_54;
          *((_QWORD *)this + 1) = *(_QWORD *)(*(_QWORD *)a2 + v33);
          goto LABEL_72;
        case 3u:
          *((_WORD *)this + 94) |= 0x10u;
          v34 = *((_QWORD *)a2 + 1);
          if (v34 > 0xFFFFFFFFFFFFFFF7 || v34 + 8 > *((_QWORD *)a2 + 2))
            goto LABEL_54;
          *((_QWORD *)this + 8) = *(_QWORD *)(*(_QWORD *)a2 + v34);
          goto LABEL_72;
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
          goto LABEL_20;
        case 0xAu:
          *((_WORD *)this + 94) |= 0x80u;
          v35 = *((_QWORD *)a2 + 1);
          if (v35 >= *((_QWORD *)a2 + 2))
          {
            v38 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v36 = v35 + 1;
            v37 = *(unsigned __int8 *)(*(_QWORD *)a2 + v35);
            *((_QWORD *)a2 + 1) = v36;
            v38 = v37 != 0;
          }
          *((_BYTE *)this + 185) = v38;
          goto LABEL_73;
        case 0xBu:
          *((_WORD *)this + 94) |= 0x200u;
          v39 = *((_QWORD *)a2 + 1);
          if (v39 >= *((_QWORD *)a2 + 2))
          {
            v42 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v40 = v39 + 1;
            v41 = *(unsigned __int8 *)(*(_QWORD *)a2 + v39);
            *((_QWORD *)a2 + 1) = v40;
            v42 = v41 != 0;
          }
          *((_BYTE *)this + 187) = v42;
          goto LABEL_73;
        case 0xCu:
          *((_WORD *)this + 94) |= 0x100u;
          v43 = *((_QWORD *)a2 + 1);
          if (v43 >= *((_QWORD *)a2 + 2))
          {
            v46 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v44 = v43 + 1;
            v45 = *(unsigned __int8 *)(*(_QWORD *)a2 + v43);
            *((_QWORD *)a2 + 1) = v44;
            v46 = v45 != 0;
          }
          *((_BYTE *)this + 186) = v46;
          goto LABEL_73;
        case 0xDu:
          *((_WORD *)this + 94) |= 0x40u;
          v47 = *((_QWORD *)a2 + 1);
          if (v47 >= *((_QWORD *)a2 + 2))
          {
            v50 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v48 = v47 + 1;
            v49 = *(unsigned __int8 *)(*(_QWORD *)a2 + v47);
            *((_QWORD *)a2 + 1) = v48;
            v50 = v49 != 0;
          }
          *((_BYTE *)this + 184) = v50;
          goto LABEL_73;
        case 0x14u:
          *((_WORD *)this + 94) |= 8u;
          v51 = *((_QWORD *)a2 + 1);
          if (v51 > 0xFFFFFFFFFFFFFFF7 || v51 + 8 > *((_QWORD *)a2 + 2))
            goto LABEL_54;
          *((_QWORD *)this + 4) = *(_QWORD *)(*(_QWORD *)a2 + v51);
          goto LABEL_72;
        case 0x15u:
          *((_WORD *)this + 94) |= 4u;
          v53 = *((_QWORD *)a2 + 1);
          if (v53 > 0xFFFFFFFFFFFFFFF7 || v53 + 8 > *((_QWORD *)a2 + 2))
            goto LABEL_54;
          *((_QWORD *)this + 3) = *(_QWORD *)(*(_QWORD *)a2 + v53);
          goto LABEL_72;
        case 0x16u:
          *((_WORD *)this + 94) |= 0x20u;
          v52 = *((_QWORD *)a2 + 1);
          if (v52 > 0xFFFFFFFFFFFFFFF7 || v52 + 8 > *((_QWORD *)a2 + 2))
          {
LABEL_54:
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *((_QWORD *)this + 9) = *(_QWORD *)(*(_QWORD *)a2 + v52);
LABEL_72:
            *((_QWORD *)a2 + 1) += 8;
          }
          goto LABEL_73;
        default:
          switch((int)v26)
          {
            case '(':
              v28 = v3;
              v29 = v2;
              v30 = operator new();
              *(_QWORD *)(v30 + 72) = 0;
              *(_QWORD *)(v30 + 80) = 0;
              *(_QWORD *)(v30 + 64) = 0;
              *(_QWORD *)(v30 + 160) = 0;
              *(_DWORD *)(v30 + 204) = 0;
              *(_QWORD *)(v30 + 8) = 0;
              *(_QWORD *)(v30 + 16) = 0;
              *(_QWORD *)v30 = &off_1E6CEA528;
              *(_QWORD *)(v30 + 120) = 0;
              *(_QWORD *)(v30 + 128) = 0;
              *(_QWORD *)(v30 + 112) = 0;
              v31 = *((_QWORD *)this + 13);
              *((_QWORD *)this + 13) = v30;
              if (v31)
              {
                (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
                v30 = *((_QWORD *)this + 13);
              }
              goto LABEL_60;
            case ')':
              v28 = v3;
              v29 = v2;
              PB::PtrVector<statistics::Statistics>::emplace_back<>(v13);
              v32 = *((_QWORD *)this + 21);
              goto LABEL_59;
            case '*':
              v28 = v3;
              v29 = v2;
              PB::PtrVector<statistics::Statistics>::emplace_back<>(v12);
              v32 = *((_QWORD *)this + 15);
              goto LABEL_59;
            case '+':
              v28 = v3;
              v29 = v2;
              PB::PtrVector<statistics::Statistics>::emplace_back<>(v11);
              v32 = *((_QWORD *)this + 18);
              goto LABEL_59;
            case ',':
            case '-':
            case '.':
            case '/':
            case '0':
            case '1':
              goto LABEL_20;
            case '2':
              v28 = v3;
              v29 = v2;
              PB::PtrVector<statistics::Interval>::emplace_back<>(v10);
              v32 = *((_QWORD *)this + 6);
              goto LABEL_59;
            default:
              if ((_DWORD)v26 != 30)
                goto LABEL_20;
              v28 = v3;
              v29 = v2;
              PB::PtrVector<statistics::RawQuantitySample>::emplace_back<>(v54);
              v32 = *((_QWORD *)this + 11);
LABEL_59:
              v30 = *(_QWORD *)(v32 - 8);
LABEL_60:
              if (!PB::Reader::placeMark()
                || ((*(uint64_t (**)(uint64_t, PB::Reader *))(*(_QWORD *)v30 + 16))(v30, a2) & 1) == 0)
              {
                return 0;
              }
              PB::Reader::recallMark();
              v2 = v29;
              v3 = v28;
              break;
          }
          break;
      }
      goto LABEL_73;
    }
    v21 = 0;
    v22 = 0;
    v17 = 0;
    if (v4 > v5)
      v5 = v4;
    do
    {
      if (v5 == v4)
      {
        v6 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v6 == 0;
      }
      v23 = v4 + 1;
      v24 = *(_BYTE *)(v14 + v4);
      *((_QWORD *)a2 + 1) = v23;
      v17 |= (unint64_t)(v24 & 0x7F) << v21;
      if ((v24 & 0x80) == 0)
        goto LABEL_22;
      v21 += 7;
      v4 = v23;
      v20 = v22++ > 8;
    }
    while (!v20);
LABEL_20:
    result = PB::Reader::skip(a2);
    if (!(_DWORD)result)
      return result;
LABEL_73:
    v4 = *((_QWORD *)a2 + 1);
    v5 = *((_QWORD *)a2 + 2);
    v6 = *((unsigned __int8 *)a2 + 24);
    if (v4 >= v5 || *((_BYTE *)a2 + 24))
      return v6 == 0;
  }
}

uint64_t PB::PtrVector<statistics::RawQuantitySample>::emplace_back<>(uint64_t **a1)
{
  uint64_t v2;
  uint64_t result;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t *v12;
  char *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  int64x2_t v17;
  uint64_t *v18;
  uint64_t v19;
  int64x2_t v20;
  char *v21;
  _QWORD *v22;

  v2 = operator new();
  *(_QWORD *)v2 = &off_1E6CFF278;
  *(_DWORD *)(v2 + 44) = 0;
  result = (uint64_t)(a1 + 2);
  v4 = (unint64_t)a1[2];
  v5 = a1[1];
  if ((unint64_t)v5 >= v4)
  {
    v7 = v5 - *a1;
    if ((unint64_t)(v7 + 1) >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v8 = v4 - (_QWORD)*a1;
    v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1))
      v9 = v7 + 1;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    v22 = a1 + 2;
    if (v10)
      v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(result, v10);
    else
      v11 = 0;
    v12 = (uint64_t *)&v11[8 * v7];
    v13 = &v11[8 * v10];
    v21 = v13;
    *v12 = v2;
    v6 = v12 + 1;
    v20.i64[1] = (uint64_t)(v12 + 1);
    v15 = *a1;
    v14 = a1[1];
    if (v14 == *a1)
    {
      v17 = vdupq_n_s64((unint64_t)v14);
    }
    else
    {
      do
      {
        v16 = *--v14;
        *v14 = 0;
        *--v12 = v16;
      }
      while (v14 != v15);
      v17 = *(int64x2_t *)a1;
      v6 = (uint64_t *)v20.i64[1];
      v13 = v21;
    }
    *a1 = v12;
    a1[1] = v6;
    v20 = v17;
    v18 = a1[2];
    a1[2] = (uint64_t *)v13;
    v21 = (char *)v18;
    v19 = v17.i64[0];
    result = std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v19);
  }
  else
  {
    *v5 = v2;
    v6 = v5 + 1;
  }
  a1[1] = v6;
  return result;
}

void sub_1B78A0038(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t PB::PtrVector<statistics::Statistics>::emplace_back<>(uint64_t **a1)
{
  uint64_t v2;
  uint64_t result;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t *v12;
  char *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  int64x2_t v17;
  uint64_t *v18;
  uint64_t v19;
  int64x2_t v20;
  char *v21;
  _QWORD *v22;

  v2 = operator new();
  *(_QWORD *)(v2 + 72) = 0;
  *(_QWORD *)(v2 + 80) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  *(_QWORD *)(v2 + 160) = 0;
  *(_DWORD *)(v2 + 204) = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)v2 = &off_1E6CEA528;
  *(_QWORD *)(v2 + 120) = 0;
  *(_QWORD *)(v2 + 128) = 0;
  *(_QWORD *)(v2 + 112) = 0;
  result = (uint64_t)(a1 + 2);
  v4 = (unint64_t)a1[2];
  v5 = a1[1];
  if ((unint64_t)v5 >= v4)
  {
    v7 = v5 - *a1;
    if ((unint64_t)(v7 + 1) >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v8 = v4 - (_QWORD)*a1;
    v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1))
      v9 = v7 + 1;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    v22 = a1 + 2;
    if (v10)
      v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(result, v10);
    else
      v11 = 0;
    v12 = (uint64_t *)&v11[8 * v7];
    v13 = &v11[8 * v10];
    v21 = v13;
    *v12 = v2;
    v6 = v12 + 1;
    v20.i64[1] = (uint64_t)(v12 + 1);
    v15 = *a1;
    v14 = a1[1];
    if (v14 == *a1)
    {
      v17 = vdupq_n_s64((unint64_t)v14);
    }
    else
    {
      do
      {
        v16 = *--v14;
        *v14 = 0;
        *--v12 = v16;
      }
      while (v14 != v15);
      v17 = *(int64x2_t *)a1;
      v6 = (uint64_t *)v20.i64[1];
      v13 = v21;
    }
    *a1 = v12;
    a1[1] = v6;
    v20 = v17;
    v18 = a1[2];
    a1[2] = (uint64_t *)v13;
    v21 = (char *)v18;
    v19 = v17.i64[0];
    result = std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v19);
  }
  else
  {
    *v5 = v2;
    v6 = v5 + 1;
  }
  a1[1] = v6;
  return result;
}

void sub_1B78A01A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t statistics::StatisticsBucket::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  __int16 v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;
  const PB::Base *v8;
  const PB::Base **v9;
  const PB::Base **v10;
  const PB::Base *v11;
  const PB::Base **v12;
  const PB::Base **v13;
  const PB::Base *v14;
  const PB::Base **v15;
  const PB::Base **v16;
  const PB::Base *v17;
  const PB::Base **v18;
  const PB::Base **v19;
  const PB::Base *v20;

  v3 = this;
  v4 = *(_WORD *)(this + 188);
  if ((v4 & 2) != 0)
  {
    this = PB::Writer::write(a2, *(double *)(this + 16));
    v4 = *(_WORD *)(v3 + 188);
    if ((v4 & 1) == 0)
    {
LABEL_3:
      if ((v4 & 0x10) == 0)
        goto LABEL_4;
      goto LABEL_32;
    }
  }
  else if ((v4 & 1) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::write(a2, *(double *)(v3 + 8));
  v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x10) == 0)
  {
LABEL_4:
    if ((v4 & 0x80) == 0)
      goto LABEL_5;
    goto LABEL_33;
  }
LABEL_32:
  this = PB::Writer::write(a2, *(double *)(v3 + 64));
  v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x80) == 0)
  {
LABEL_5:
    if ((v4 & 0x200) == 0)
      goto LABEL_6;
    goto LABEL_34;
  }
LABEL_33:
  this = PB::Writer::write(a2);
  v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x200) == 0)
  {
LABEL_6:
    if ((v4 & 0x100) == 0)
      goto LABEL_7;
    goto LABEL_35;
  }
LABEL_34:
  this = PB::Writer::write(a2);
  v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x100) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_36;
  }
LABEL_35:
  this = PB::Writer::write(a2);
  v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 8) == 0)
      goto LABEL_9;
    goto LABEL_37;
  }
LABEL_36:
  this = PB::Writer::write(a2);
  v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 8) == 0)
  {
LABEL_9:
    if ((v4 & 4) == 0)
      goto LABEL_10;
LABEL_38:
    this = PB::Writer::write(a2, *(double *)(v3 + 24));
    if ((*(_WORD *)(v3 + 188) & 0x20) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_37:
  this = PB::Writer::write(a2, *(double *)(v3 + 32));
  v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 4) != 0)
    goto LABEL_38;
LABEL_10:
  if ((v4 & 0x20) != 0)
LABEL_11:
    this = PB::Writer::write(a2, *(double *)(v3 + 72));
LABEL_12:
  v5 = *(const PB::Base ***)(v3 + 80);
  v6 = *(const PB::Base ***)(v3 + 88);
  while (v5 != v6)
  {
    v7 = *v5++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  v8 = *(const PB::Base **)(v3 + 104);
  if (v8)
    this = PB::Writer::writeSubmessage(a2, v8);
  v9 = *(const PB::Base ***)(v3 + 160);
  v10 = *(const PB::Base ***)(v3 + 168);
  while (v9 != v10)
  {
    v11 = *v9++;
    this = PB::Writer::writeSubmessage(a2, v11);
  }
  v12 = *(const PB::Base ***)(v3 + 112);
  v13 = *(const PB::Base ***)(v3 + 120);
  while (v12 != v13)
  {
    v14 = *v12++;
    this = PB::Writer::writeSubmessage(a2, v14);
  }
  v15 = *(const PB::Base ***)(v3 + 136);
  v16 = *(const PB::Base ***)(v3 + 144);
  while (v15 != v16)
  {
    v17 = *v15++;
    this = PB::Writer::writeSubmessage(a2, v17);
  }
  v19 = *(const PB::Base ***)(v3 + 40);
  v18 = *(const PB::Base ***)(v3 + 48);
  while (v19 != v18)
  {
    v20 = *v19++;
    this = PB::Writer::writeSubmessage(a2, v20);
  }
  return this;
}

BOOL statistics::StatisticsBucket::operator==(uint64_t a1, uint64_t a2)
{
  __int16 v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *(_WORD *)(a1 + 188);
  v5 = *(_WORD *)(a2 + 188);
  if ((v4 & 2) != 0)
  {
    if ((v5 & 2) == 0 || *(double *)(a1 + 16) != *(double *)(a2 + 16))
      return 0;
  }
  else if ((v5 & 2) != 0)
  {
    return 0;
  }
  if ((v4 & 1) != 0)
  {
    if ((v5 & 1) == 0 || *(double *)(a1 + 8) != *(double *)(a2 + 8))
      return 0;
  }
  else if ((v5 & 1) != 0)
  {
    return 0;
  }
  if ((v4 & 0x10) != 0)
  {
    if ((v5 & 0x10) == 0 || *(double *)(a1 + 64) != *(double *)(a2 + 64))
      return 0;
  }
  else if ((v5 & 0x10) != 0)
  {
    return 0;
  }
  if ((v4 & 0x80) != 0)
  {
    if ((v5 & 0x80) == 0 || *(unsigned __int8 *)(a1 + 185) != *(unsigned __int8 *)(a2 + 185))
      return 0;
  }
  else if ((v5 & 0x80) != 0)
  {
    return 0;
  }
  if ((*(_WORD *)(a1 + 188) & 0x200) != 0)
  {
    if ((*(_WORD *)(a2 + 188) & 0x200) == 0 || *(unsigned __int8 *)(a1 + 187) != *(unsigned __int8 *)(a2 + 187))
      return 0;
  }
  else if ((*(_WORD *)(a2 + 188) & 0x200) != 0)
  {
    return 0;
  }
  if ((*(_WORD *)(a1 + 188) & 0x100) != 0)
  {
    if ((*(_WORD *)(a2 + 188) & 0x100) == 0 || *(unsigned __int8 *)(a1 + 186) != *(unsigned __int8 *)(a2 + 186))
      return 0;
  }
  else if ((*(_WORD *)(a2 + 188) & 0x100) != 0)
  {
    return 0;
  }
  if ((v4 & 0x40) != 0)
  {
    if ((v5 & 0x40) == 0 || *(unsigned __int8 *)(a1 + 184) != *(unsigned __int8 *)(a2 + 184))
      return 0;
  }
  else if ((v5 & 0x40) != 0)
  {
    return 0;
  }
  if ((v4 & 8) != 0)
  {
    if ((v5 & 8) == 0 || *(double *)(a1 + 32) != *(double *)(a2 + 32))
      return 0;
  }
  else if ((v5 & 8) != 0)
  {
    return 0;
  }
  if ((v4 & 4) != 0)
  {
    if ((v5 & 4) == 0 || *(double *)(a1 + 24) != *(double *)(a2 + 24))
      return 0;
  }
  else if ((v5 & 4) != 0)
  {
    return 0;
  }
  if ((v4 & 0x20) != 0)
  {
    if ((v5 & 0x20) == 0 || *(double *)(a1 + 72) != *(double *)(a2 + 72))
      return 0;
  }
  else if ((v5 & 0x20) != 0)
  {
    return 0;
  }
  if (PB::PtrVector<statistics::RawQuantitySample>::operator==((uint64_t *)(a1 + 80), a2 + 80))
  {
    v6 = *(_QWORD *)(a1 + 104);
    v7 = *(_QWORD *)(a2 + 104);
    if (v6)
    {
      if (!v7 || (statistics::Statistics::operator==(v6, v7) & 1) == 0 && *(_QWORD *)(a1 + 104) | *(_QWORD *)(a2 + 104))
        return 0;
    }
    else if (v7)
    {
      return 0;
    }
    if (PB::PtrVector<statistics::Statistics>::operator==((uint64_t **)(a1 + 160), *(uint64_t **)(a2 + 160), *(_QWORD *)(a2 + 168))&& PB::PtrVector<statistics::Statistics>::operator==((uint64_t **)(a1 + 112), *(uint64_t **)(a2 + 112), *(_QWORD *)(a2 + 120))&& PB::PtrVector<statistics::Statistics>::operator==((uint64_t **)(a1 + 136), *(uint64_t **)(a2 + 136), *(_QWORD *)(a2 + 144)))
    {
      return PB::PtrVector<statistics::Interval>::operator==((uint64_t *)(a1 + 40), a2 + 40);
    }
  }
  return 0;
}

BOOL PB::PtrVector<statistics::RawQuantitySample>::operator==(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 result;
  BOOL v8;

  v2 = *a1;
  v3 = a1[1];
  v4 = *(uint64_t **)a2;
  if (v3 - *a1 != *(_QWORD *)(a2 + 8) - *(_QWORD *)a2)
    return 0;
  if (v2 == v3)
    return 1;
  v5 = v2 + 8;
  do
  {
    v6 = *v4++;
    result = statistics::RawQuantitySample::operator==(*(_QWORD *)(v5 - 8), v6);
    v8 = !result || v5 == v3;
    v5 += 8;
  }
  while (!v8);
  return result;
}

uint64_t PB::PtrVector<statistics::Statistics>::operator==(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t result;

  v4 = *a1;
  v3 = a1[1];
  if ((char *)v3 - (char *)*a1 != a3 - (_QWORD)a2)
    return 0;
  if (v4 == v3)
    return 1;
  v5 = a2;
  do
  {
    result = statistics::Statistics::operator==(*v4, *v5);
    if (!(_DWORD)result)
      break;
    ++v4;
    ++v5;
  }
  while (v4 != a1[1]);
  return result;
}

unint64_t statistics::StatisticsBucket::hash_value(statistics::StatisticsBucket *this)
{
  __int16 v2;
  double v3;
  double v4;
  double v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  statistics::RawQuantitySample **v9;
  statistics::RawQuantitySample **v10;
  uint64_t v11;
  statistics::RawQuantitySample *v12;
  statistics::Statistics *v13;
  unint64_t v14;
  statistics::Statistics **v15;
  statistics::Statistics **v16;
  uint64_t v17;
  statistics::Statistics *v18;
  statistics::Statistics **v19;
  statistics::Statistics **v20;
  uint64_t v21;
  statistics::Statistics *v22;
  statistics::Statistics **v23;
  statistics::Statistics **v24;
  uint64_t v25;
  statistics::Statistics *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  double v32;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  double v40;
  double v41;

  v2 = *((_WORD *)this + 94);
  if ((v2 & 2) == 0)
  {
    v41 = 0.0;
    if ((v2 & 1) != 0)
      goto LABEL_3;
LABEL_26:
    v40 = 0.0;
    if ((v2 & 0x10) != 0)
      goto LABEL_6;
LABEL_27:
    v39 = 0.0;
    if ((v2 & 0x80) != 0)
      goto LABEL_9;
    goto LABEL_28;
  }
  v8 = *((double *)this + 2);
  if (v8 == 0.0)
    v8 = 0.0;
  v41 = v8;
  if ((v2 & 1) == 0)
    goto LABEL_26;
LABEL_3:
  v3 = *((double *)this + 1);
  if (v3 == 0.0)
    v3 = 0.0;
  v40 = v3;
  if ((v2 & 0x10) == 0)
    goto LABEL_27;
LABEL_6:
  v4 = *((double *)this + 8);
  if (v4 == 0.0)
    v4 = 0.0;
  v39 = v4;
  if ((v2 & 0x80) != 0)
  {
LABEL_9:
    v38 = *((unsigned __int8 *)this + 185);
    if ((*((_WORD *)this + 94) & 0x200) != 0)
      goto LABEL_10;
    goto LABEL_29;
  }
LABEL_28:
  v38 = 0;
  if ((*((_WORD *)this + 94) & 0x200) != 0)
  {
LABEL_10:
    v37 = *((unsigned __int8 *)this + 187);
    if ((*((_WORD *)this + 94) & 0x100) != 0)
      goto LABEL_11;
    goto LABEL_30;
  }
LABEL_29:
  v37 = 0;
  if ((*((_WORD *)this + 94) & 0x100) != 0)
  {
LABEL_11:
    v36 = *((unsigned __int8 *)this + 186);
    if ((v2 & 0x40) != 0)
      goto LABEL_12;
    goto LABEL_31;
  }
LABEL_30:
  v36 = 0;
  if ((v2 & 0x40) != 0)
  {
LABEL_12:
    v35 = *((unsigned __int8 *)this + 184);
    if ((v2 & 8) != 0)
      goto LABEL_13;
LABEL_32:
    v34 = 0.0;
    if ((v2 & 4) != 0)
      goto LABEL_16;
    goto LABEL_33;
  }
LABEL_31:
  v35 = 0;
  if ((v2 & 8) == 0)
    goto LABEL_32;
LABEL_13:
  v5 = *((double *)this + 4);
  if (v5 == 0.0)
    v5 = 0.0;
  v34 = v5;
  if ((v2 & 4) != 0)
  {
LABEL_16:
    if (*((double *)this + 3) == 0.0)
      v6 = 0;
    else
      v6 = *((_QWORD *)this + 3);
    if ((v2 & 0x20) != 0)
      goto LABEL_20;
    goto LABEL_34;
  }
LABEL_33:
  v6 = 0;
  if ((v2 & 0x20) != 0)
  {
LABEL_20:
    if (*((double *)this + 9) == 0.0)
      v7 = 0;
    else
      v7 = *((_QWORD *)this + 9);
    goto LABEL_35;
  }
LABEL_34:
  v7 = 0;
LABEL_35:
  v9 = (statistics::RawQuantitySample **)*((_QWORD *)this + 10);
  v10 = (statistics::RawQuantitySample **)*((_QWORD *)this + 11);
  if (v9 == v10)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    do
    {
      v12 = *v9++;
      v11 ^= statistics::RawQuantitySample::hash_value(v12);
    }
    while (v9 != v10);
  }
  v13 = (statistics::Statistics *)*((_QWORD *)this + 13);
  if (v13)
    v14 = statistics::Statistics::hash_value(v13);
  else
    v14 = 0;
  v15 = (statistics::Statistics **)*((_QWORD *)this + 20);
  v16 = (statistics::Statistics **)*((_QWORD *)this + 21);
  if (v15 == v16)
  {
    v17 = 0;
  }
  else
  {
    v17 = 0;
    do
    {
      v18 = *v15++;
      v17 ^= statistics::Statistics::hash_value(v18);
    }
    while (v15 != v16);
  }
  v19 = (statistics::Statistics **)*((_QWORD *)this + 14);
  v20 = (statistics::Statistics **)*((_QWORD *)this + 15);
  if (v19 == v20)
  {
    v21 = 0;
  }
  else
  {
    v21 = 0;
    do
    {
      v22 = *v19++;
      v21 ^= statistics::Statistics::hash_value(v22);
    }
    while (v19 != v20);
  }
  v23 = (statistics::Statistics **)*((_QWORD *)this + 17);
  v24 = (statistics::Statistics **)*((_QWORD *)this + 18);
  if (v23 == v24)
  {
    v25 = 0;
  }
  else
  {
    v25 = 0;
    do
    {
      v26 = *v23++;
      v25 ^= statistics::Statistics::hash_value(v26);
    }
    while (v23 != v24);
  }
  v27 = (uint64_t *)*((_QWORD *)this + 5);
  v28 = (uint64_t *)*((_QWORD *)this + 6);
  if (v27 != v28)
  {
    v29 = 0;
    while (1)
    {
      v30 = *v27;
      if ((*(_BYTE *)(*v27 + 24) & 2) != 0)
      {
        v31 = *(double *)(v30 + 16);
        if (v31 == 0.0)
          v31 = 0.0;
        if ((*(_BYTE *)(*v27 + 24) & 1) != 0)
        {
LABEL_62:
          v32 = *(double *)(v30 + 8);
          if (v32 == 0.0)
            v32 = 0.0;
          goto LABEL_69;
        }
      }
      else
      {
        v31 = 0.0;
        if ((*(_BYTE *)(*v27 + 24) & 1) != 0)
          goto LABEL_62;
      }
      v32 = 0.0;
LABEL_69:
      v29 ^= *(_QWORD *)&v31 ^ *(_QWORD *)&v32;
      if (++v27 == v28)
        return *(_QWORD *)&v40 ^ *(_QWORD *)&v41 ^ *(_QWORD *)&v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ *(_QWORD *)&v34 ^ v6 ^ v7 ^ v11 ^ v14 ^ v17 ^ v21 ^ v25 ^ v29;
    }
  }
  v29 = 0;
  return *(_QWORD *)&v40 ^ *(_QWORD *)&v41 ^ *(_QWORD *)&v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ *(_QWORD *)&v34 ^ v6 ^ v7 ^ v11 ^ v14 ^ v17 ^ v21 ^ v25 ^ v29;
}

_QWORD *statistics::StatisticsBucket::makeStatistics(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;

  if (!this[13])
  {
    v1 = this;
    v2 = operator new();
    *(_QWORD *)(v2 + 72) = 0;
    *(_QWORD *)(v2 + 80) = 0;
    *(_QWORD *)(v2 + 64) = 0;
    *(_QWORD *)(v2 + 160) = 0;
    *(_DWORD *)(v2 + 204) = 0;
    *(_QWORD *)(v2 + 8) = 0;
    *(_QWORD *)(v2 + 16) = 0;
    *(_QWORD *)v2 = &off_1E6CEA528;
    *(_QWORD *)(v2 + 120) = 0;
    *(_QWORD *)(v2 + 128) = 0;
    *(_QWORD *)(v2 + 112) = 0;
    this = (_QWORD *)v1[13];
    v1[13] = v2;
    if (this)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  return this;
}

BOOL HDCodableTinkerPairingResponseReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  uint64_t v18;
  HDCodableSharingSetupMetadata *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
        break;
      if ((_DWORD)v17 == 2)
      {
        v19 = objc_alloc_init(HDCodableSharingSetupMetadata);
        objc_storeStrong((id *)(a1 + 24), v19);
        if (!PBReaderPlaceMark() || !HDCodableSharingSetupMetadataReadFrom((char *)v19, a2))
          goto LABEL_33;
LABEL_27:
        PBReaderRecallMark();
        goto LABEL_28;
      }
      if ((_DWORD)v17 == 1)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = *(HDCodableSharingSetupMetadata **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v18;
LABEL_28:

        goto LABEL_30;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_30:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v19 = objc_alloc_init(HDCodableError);
    objc_storeStrong((id *)(a1 + 8), v19);
    if (!PBReaderPlaceMark() || (HDCodableErrorReadFrom((uint64_t)v19, a2) & 1) == 0)
    {
LABEL_33:

      return 0;
    }
    goto LABEL_27;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B78A1A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{

}

void sub_1B78A1B88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78A2480(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78A2640(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A27C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A28A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A2998(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A2A30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A2B64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A2C1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A2CD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A2D68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A2F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78A3024(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A30B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A3134(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A332C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;

  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1B78A3470(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A3560(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A3630(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A3720(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A37B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A3830(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78A39CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B78A3AC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{

}

void sub_1B78A3C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  char *v15;
  char *v17;
  uint64_t v18;

  v17 = a15;
  if (a15 == v15)
  {
    v18 = 4;
    v17 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v17 + 8 * v18))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CEA740;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE7__cloneEPNS0_6__baseIS9_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEA740;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEEclES8_(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[6];

  objc_msgSend(**(id **)(a1 + 8), "transaction");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = *(_QWORD *)(a1 + 24);
  v7 = **(_QWORD **)(a1 + 16);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionE_block_invoke;
  v10[3] = &__block_descriptor_48_e26_B24__0__HDSQLiteRow__8__16l;
  v10[4] = a2;
  v10[5] = v6;
  v8 = objc_msgSend(v5, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT data_id FROM data_series ds INNER JOIN samples s USING (data_id) WHERE data_type = 102"), v7, 0, v10);

  return v8;
}

void sub_1B78A3D64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE11target_typeEv()
{
  return &_ZTIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0;
}

uint64_t ___ZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionE_block_invoke(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  ObjectIdentifier v10;
  ObjectIdentifier v11;
  char v12;
  __int128 v13;
  uint64_t v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = HDSQLiteColumnAsInt64();
  v10.objectType = 0;
  v10.identifier = v2;
  v3 = *(_QWORD *)(a1 + 32);
  v13 = *(_OWORD *)(v3 + 32);
  v14 = v3;
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v13, &v10, 0, &v11);
  if (!v12)
    return 1;
  v11.objectType = -1;
  v11.identifier = v2;
  health::DataStore::WriteTransaction::renameObjectWithIdentifier(*(health::DataStore::WriteTransaction **)(a1 + 32), &v10, (__n128 *)&v11);
  v4 = *(uint64_t **)(a1 + 40);
  v5 = *v4;
  v15[0] = &off_1E6CEA8A0;
  v15[1] = v4;
  v15[2] = &v11;
  v16 = v15;
  v6 = health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(v5, (uint64_t)&v10, 1, (uint64_t)v15);
  v7 = v16;
  if (v16 == v15)
  {
    v8 = 4;
    v7 = v15;
    goto LABEL_7;
  }
  if (v16)
  {
    v8 = 5;
LABEL_7:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v6;
}

void sub_1B78A3EE4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;

  v4 = *(_QWORD **)(v2 - 48);
  if (v4 == v1)
  {
    v5 = 4;
    v4 = (_QWORD *)(v2 - 72);
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &unk_1E6CEA7E0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E6CEA7E0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1} &,health::DataStore::WriteTransaction &>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1} &,health::DataStore::WriteTransaction &>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  _BYTE v5[16];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v7 = 0u;
  v6 = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = a2;
  v11 = a2;
  result = health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)a1, **(unsigned __int8 **)(a1 + 8));
  if ((_DWORD)result)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
    if (!v4)
      std::__throw_bad_function_call[abi:ne180100]();
    return (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v4 + 48))(v4, v5);
  }
  return result;
}

__n128 health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::_updateHistoryRoot(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  __n128 result;
  __n128 *v5;
  _BYTE v6[24];

  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 96);
  if (v2 == 56)
  {
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v3 + 80, *(_QWORD *)(a1 + 56), 56, (uint64_t *)a1);
  }
  else
  {
    health::DataStore::WriteTransaction::storeObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v3, (uint64_t *)a1, (__n128 *)(a1 + 72));
    health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 96), (ObjectIdentifier *)(a1 + 72), (uint64_t)v6);
    v5 = (__n128 *)health::Optional<health::BlockPointer>::get((uint64_t)v6);
    result = *v5;
    *(__n128 *)(a1 + 56) = *v5;
  }
  return result;
}

std::runtime_error *_ZN6health15not_found_errorCI1St13runtime_errorEPKc(std::runtime_error *a1, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEA868;
  return result;
}

uint64_t health::Optional<health::BlockPointer>::get(uint64_t result)
{
  std::logic_error *exception;

  if (!*(_BYTE *)(result + 16))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to get the value from an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
  return result;
}

void sub_1B78A4174(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::_HDAssertImplementation<std::out_of_range>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  id v10;
  uint64_t v11;
  char **v12;
  _QWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  std::logic_error *exception;
  char **v35;
  std::string *v36;
  std::string::size_type size;
  _QWORD *v38;
  void *__p[2];
  char v40;
  std::string v41;
  uint64_t v42;
  uint64_t v43;
  void *v44[2];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v10 = a1;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  *(_OWORD *)v44 = 0u;
  v45 = 0u;
  LODWORD(v11) = backtrace(v44, 20);
  v12 = backtrace_symbols(v44, v11);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v42);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v42, (uint64_t)"Critical Error: ", 16);
  v14 = *(char *)(a6 + 23);
  if (v14 >= 0)
    v15 = a6;
  else
    v15 = *(_QWORD *)a6;
  if (v14 >= 0)
    v16 = *(unsigned __int8 *)(a6 + 23);
  else
    v16 = *(_QWORD *)(a6 + 8);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v15, v16);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"\n", 1);
  v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v42, (uint64_t)"Failed assertion '", 18);
  v19 = *(char *)(a2 + 23);
  if (v19 >= 0)
    v20 = a2;
  else
    v20 = *(_QWORD *)a2;
  if (v19 >= 0)
    v21 = *(unsigned __int8 *)(a2 + 23);
  else
    v21 = *(_QWORD *)(a2 + 8);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, v20, v21);
  v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"' in '", 6);
  v24 = *(char *)(a3 + 23);
  if (v24 >= 0)
    v25 = a3;
  else
    v25 = *(_QWORD *)a3;
  if (v24 >= 0)
    v26 = *(unsigned __int8 *)(a3 + 23);
  else
    v26 = *(_QWORD *)(a3 + 8);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, v25, v26);
  v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"' at ", 5);
  v29 = *(char *)(a4 + 23);
  if (v29 >= 0)
    v30 = a4;
  else
    v30 = *(_QWORD *)a4;
  if (v29 >= 0)
    v31 = *(unsigned __int8 *)(a4 + 23);
  else
    v31 = *(_QWORD *)(a4 + 8);
  v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, v30, v31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)":", 1);
  v33 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"\n", 1);
  if ((_DWORD)v11)
  {
    v11 = (int)v11;
    v35 = v12;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, *v35);
      health::HDDemangleBacktraceLine((uint64_t)__p, (unint64_t)&v41);
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v36 = &v41;
      else
        v36 = (std::string *)v41.__r_.__value_.__r.__words[0];
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v41.__r_.__value_.__r.__words[2]);
      else
        size = v41.__r_.__value_.__l.__size_;
      v38 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v42, (uint64_t)v36, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"\n", 1);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      if (v40 < 0)
        operator delete(__p[0]);
      ++v35;
      --v11;
    }
    while (v11);
  }
  free(v12);
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v43, &v41);
  std::logic_error::logic_error(exception, &v41);
  exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
}

void sub_1B78A43F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  void *v38;

  if (a14 < 0)
    operator delete(__p);
  a21 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a21 + *(_QWORD *)(a21 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a22 = MEMORY[0x1E0DE4FB8] + 16;
  if (a35 < 0)
    operator delete(a30);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&a38);

  _Unwind_Resume(a1);
}

void health::FormatString<>(std::string *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<>(a1, a2, 0);
}

void sub_1B78A4528(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x1E0DE4FE0] + 64;
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1B78A4608(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x1BCCAC2C0](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x1BCCAC2CC](v13);
  return a1;
}

void sub_1B78A4738(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x1BCCAC2CC](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1B78A4718);
}

void sub_1B78A4780(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_1B78A48B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:ne180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  unint64_t v4;
  const void *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  result = std::stringbuf::view[abi:ne180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = (const void *)result;
  v6 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v4;
    if (!v4)
      goto LABEL_9;
  }
  result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((_BYTE *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:ne180100](uint64_t a1)
{
  int v1;
  unint64_t v3;

  v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    v3 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(a1 + 88) < v3)
      *(_QWORD *)(a1 + 88) = v3;
    return *(_QWORD *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(_QWORD *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void health::FormatImplementation<>(std::string *a1, std::string *this, std::string::size_type a3)
{
  uint64_t v6;
  char v7;
  char *i;
  int v9;
  int v10;
  uint64_t v11;
  char *v12;
  int v13;
  std::runtime_error *exception;
  uint64_t v15;
  char *v16;

  v6 = 0;
  v7 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v16 = i;
    if (*i != 123)
      break;
    v9 = i[1];
    if (v9 != 123)
    {
      if (v9 == 42)
      {
        v16 = i + 2;
        v10 = i[2];
        if ((v10 - 48) > 9)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
        }
        else
        {
          v11 = 0;
          v12 = i + 3;
          do
          {
            v16 = v12;
            v11 = (v10 - 48) + 10 * v11;
            v13 = *v12++;
            v10 = v13;
          }
          while ((v13 - 58) >= 0xFFFFFFF6);
          v16 = v12;
          if (*(v12 - 1) == 125)
            health::FormatterParameters<0ul>::formatOptionsAtIndex<>();
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
        }
        __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
      }
      health::FormatOptions::FormatOptions((uint64_t)&v15, (const char **)&v16);
      health::FormatterParameters<0ul>::formatParameterAtIndex<health::FormatterParameters<0ul>>();
    }
    v16 = i + 1;
    v7 = 1;
    ++i;
LABEL_7:
    --v6;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(this, a3 - v6, 0);
  if (v6)
    health::CopyFormatSectionToResult(a1, this, a3, -v6, v7 & 1);
}

void sub_1B78A4D04(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul>::formatOptionsAtIndex<>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B78A4D58(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul>::formatParameterAtIndex<health::FormatterParameters<0ul>>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B78A4DA8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::deserialize(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;

  v4 = a1 + 2;
  v5 = a1 + 4;
  v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v7);
  *a1 = v7;
  v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v7);
  a1[1] = v7;
  health::BlockPointer::deserialize(v4, a2);
  health::BlockPointer::deserialize(v5, a2);
  v7 = 0;
  result = health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
  a1[6] = v7;
  return result;
}

uint64_t health::BlockPointer::deserialize(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v5);
  *a1 = v5;
  v5 = 0;
  result = health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v5);
  a1[1] = v5;
  return result;
}

uint64_t health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5;

  v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[2];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[3];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[4];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[5];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[6];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey(uint64_t *a1, __n128 *a2, __n128 *a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  health::BlockAccessFile::WriteTransaction *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE __dst[552];
  _QWORD __src[69];
  _BYTE v15[552];

  v6 = a1[2];
  bzero(v15, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    v8 = a1[2];
    bzero(__src, 0x223uLL);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(__dst, __src, sizeof(__dst));
    v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 547);
    v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)__dst);
    LOWORD(__src[68]) = 1;
    __src[2] = v10;
    __src[3] = v12;
    BYTE2(__src[68]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

double health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X4>, _OWORD *a6@<X8>)
{
  signed int v12;
  uint64_t v13;
  double result;
  __int128 v15;
  _OWORD v16[2];
  __int128 v17;

  if (*(_WORD *)(a3 + 544))
  {
    v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a3, a4);
    v13 = (a2 + 1);
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(a1, v13, a3, v12, a4, a5, (uint64_t)v16);
    if (BYTE8(v17) || *(unsigned __int16 *)(a3 + 544) - 1 <= v12)
    {
      v15 = v16[1];
      *a6 = v16[0];
      a6[1] = v15;
      result = *(double *)&v17;
      a6[2] = v17;
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(a1, v13, a3, (unsigned __int16)(v12 + 1), a4, a5, (uint64_t)a6);
    }
  }
  else
  {
    result = 0.0;
    *(_OWORD *)((char *)a6 + 25) = 0u;
    *a6 = 0u;
    a6[1] = 0u;
  }
  return result;
}

uint64_t health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;
  __int16 v8;
  char v9;

  for (i = 0; i != 17; ++i)
  {
    v5 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    v6 = v5 + 2;
    health::DataStore::ObjectIdentifier::deserialize(v5, a2);
    health::BlockPointer::deserialize(v6, a2);
  }
  v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 544) = v8;
  v9 = 0;
  result = health::DeserializationBuffer::extractRaw<unsigned char>(a2, &v9);
  *(_BYTE *)(a1 + 546) = v9 != 0;
  return result;
}

uint64_t health::DataStore::ObjectIdentifier::deserialize(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *a1 = v5;
  v5 = 0;
  result = health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v5);
  a1[1] = v5;
  return result;
}

void health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, _QWORD *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[69];
  __int128 v18;
  __int128 v19;
  std::string v20;
  _QWORD v21[2];
  _QWORD v22[2];
  _QWORD v23[2];

  if (*(unsigned __int16 *)(a3 + 544) <= a4)
  {
    v12 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v23, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v22, "_valueForKeyInChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v20);
    health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 158, (uint64_t)&v20);
  }
  if (*(_BYTE *)(a3 + 546))
  {
    v13 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    v14 = *(_QWORD *)(v13 + 16);
    v15 = *(_QWORD *)(v13 + 24);
    v16 = *(_QWORD *)(a1 + 16);
    bzero(v17, 0x222uLL);
    v18 = 0u;
    v19 = 0u;
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v16 + 24), v14, v15, (uint64_t)v17);
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>((uint64_t)v17, a5, a6, a7);
  }
  else
  {
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(a1, a2, a3, a4, v17);
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>(a1, a2, v17, a5, a6);
  }
}

void sub_1B78A5414(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 153) < 0)
    operator delete(*(void **)(v1 - 176));
  if (*(char *)(v1 - 129) < 0)
    operator delete(*(void **)(v1 - 152));
  if (*(char *)(v1 - 105) < 0)
    operator delete(*(void **)(v1 - 128));
  if (*(char *)(v1 - 81) < 0)
    operator delete(*(void **)(v1 - 104));
  _Unwind_Resume(exception_object);
}

void health::_HDAssertImplementation<health::btree_access_error>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  id v10;
  uint64_t v11;
  char **v12;
  _QWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  std::runtime_error *exception;
  char **v35;
  std::string *v36;
  std::string::size_type size;
  _QWORD *v38;
  void *__p[2];
  char v40;
  std::string v41;
  uint64_t v42;
  uint64_t v43;
  void *v44[2];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v10 = a1;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  *(_OWORD *)v44 = 0u;
  v45 = 0u;
  LODWORD(v11) = backtrace(v44, 20);
  v12 = backtrace_symbols(v44, v11);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v42);
  v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v42, (uint64_t)"Critical Error: ", 16);
  v14 = *(char *)(a6 + 23);
  if (v14 >= 0)
    v15 = a6;
  else
    v15 = *(_QWORD *)a6;
  if (v14 >= 0)
    v16 = *(unsigned __int8 *)(a6 + 23);
  else
    v16 = *(_QWORD *)(a6 + 8);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v15, v16);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"\n", 1);
  v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v42, (uint64_t)"Failed assertion '", 18);
  v19 = *(char *)(a2 + 23);
  if (v19 >= 0)
    v20 = a2;
  else
    v20 = *(_QWORD *)a2;
  if (v19 >= 0)
    v21 = *(unsigned __int8 *)(a2 + 23);
  else
    v21 = *(_QWORD *)(a2 + 8);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, v20, v21);
  v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"' in '", 6);
  v24 = *(char *)(a3 + 23);
  if (v24 >= 0)
    v25 = a3;
  else
    v25 = *(_QWORD *)a3;
  if (v24 >= 0)
    v26 = *(unsigned __int8 *)(a3 + 23);
  else
    v26 = *(_QWORD *)(a3 + 8);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, v25, v26);
  v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"' at ", 5);
  v29 = *(char *)(a4 + 23);
  if (v29 >= 0)
    v30 = a4;
  else
    v30 = *(_QWORD *)a4;
  if (v29 >= 0)
    v31 = *(unsigned __int8 *)(a4 + 23);
  else
    v31 = *(_QWORD *)(a4 + 8);
  v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, v30, v31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)":", 1);
  v33 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"\n", 1);
  if ((_DWORD)v11)
  {
    v11 = (int)v11;
    v35 = v12;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, *v35);
      health::HDDemangleBacktraceLine((uint64_t)__p, (unint64_t)&v41);
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v36 = &v41;
      else
        v36 = (std::string *)v41.__r_.__value_.__r.__words[0];
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v41.__r_.__value_.__r.__words[2]);
      else
        size = v41.__r_.__value_.__l.__size_;
      v38 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v42, (uint64_t)v36, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"\n", 1);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
      if (v40 < 0)
        operator delete(__p[0]);
      ++v35;
      --v11;
    }
    while (v11);
  }
  free(v12);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v43, &v41);
  std::runtime_error::runtime_error(exception, &v41);
  exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEAB08;
}

void sub_1B78A56E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  void *v38;

  if (a14 < 0)
    operator delete(__p);
  a21 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a21 + *(_QWORD *)(a21 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a22 = MEMORY[0x1E0DE4FB8] + 16;
  if (a35 < 0)
    operator delete(a30);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&a38);

  _Unwind_Resume(a1);
}

void health::btree_access_error::~btree_access_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1BCCAC494);
}

double health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t a1@<X2>, _QWORD *a2@<X3>, int a3@<W4>, uint64_t a4@<X8>)
{
  uint64_t v7;
  __int128 v8;
  __int128 *v9;
  __int128 v10;
  __int128 *v11;
  __int128 v12;
  unint64_t v13;
  __int128 *v14;
  __int128 v15;

  if (!*(_WORD *)(a1 + 544))
    goto LABEL_16;
  v7 = health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey(a1, a2);
  if (!HIDWORD(v7))
  {
    v9 = (__int128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, (unsigned __int16)v7);
    v8 = *v9;
    v10 = v9[1];
    *(_OWORD *)a4 = *v9;
    *(_OWORD *)(a4 + 16) = v10;
    *(_DWORD *)(a4 + 32) = 0;
    goto LABEL_15;
  }
  switch(a3)
  {
    case 2:
      if (HIDWORD(v7) != 2)
        goto LABEL_16;
      v11 = (__int128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, (unsigned __int16)v7);
      v8 = *v11;
      v12 = v11[1];
      *(_OWORD *)a4 = *v11;
      *(_OWORD *)(a4 + 16) = v12;
      *(_DWORD *)(a4 + 32) = 2;
LABEL_15:
      *(_BYTE *)(a4 + 40) = 1;
      return *(double *)&v8;
    case 1:
      if (HIDWORD(v7) == 1)
      {
        v13 = (unsigned __int16)v7;
LABEL_14:
        v14 = (__int128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v13);
        v8 = *v14;
        v15 = v14[1];
        *(_OWORD *)a4 = *v14;
        *(_OWORD *)(a4 + 16) = v15;
        *(_DWORD *)(a4 + 32) = 1;
        goto LABEL_15;
      }
      if ((unsigned __int16)v7 < *(unsigned __int16 *)(a1 + 544) - 1)
      {
        v13 = (unsigned __int16)v7 + 1;
        goto LABEL_14;
      }
LABEL_16:
      *(_QWORD *)&v8 = 0;
      *(_OWORD *)(a4 + 25) = 0u;
      *(_OWORD *)a4 = 0u;
      *(_OWORD *)(a4 + 16) = 0u;
      return *(double *)&v8;
    case 0:
      goto LABEL_16;
  }
  return *(double *)&v8;
}

_QWORD *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, _QWORD *a5@<X8>)
{
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *result;
  void *v16;
  _QWORD *v17;
  void *v18;
  std::string v19;
  void *v20[2];
  void *v21[2];
  void *v22[2];
  std::string v23;
  void *v24[2];
  void *v25[2];
  void *v26[2];
  std::string __p;
  void *v28[2];
  _QWORD v29[2];
  _QWORD v30[2];
  std::string v31;
  _QWORD v32[2];
  _QWORD v33[2];
  _QWORD v34[2];

  if (*(unsigned __int16 *)(a3 + 544) <= a4)
  {
    v9 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v34, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v33, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v32, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v31);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v34, (uint64_t)v33, (uint64_t)v32, 137, (uint64_t)&v31);
  }
  if (a2 >= 64)
  {
    v10 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v30, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v29, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v28, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v30, (uint64_t)v29, (uint64_t)v28, 138, (uint64_t)&__p);
  }
  v11 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
  v12 = *(_QWORD *)(v11 + 16);
  v13 = *(_QWORD *)(v11 + 24);
  v14 = *(_QWORD *)(a1 + 16);
  bzero(a5, 0x223uLL);
  result = (_QWORD *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, (uint64_t)a5);
  if (*((_WORD *)a5 + 272))
  {
    result = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    if (*a5 <= *result && (*a5 < *result || a5[1] < result[1]))
    {
      v16 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v26, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v25, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v23);
      health::_HDAssertImplementation<health::btree_access_error>(v16, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 144, (uint64_t)&v23);
    }
    if (*(unsigned __int16 *)(a3 + 544) - 1 > (int)a4)
    {
      v17 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)a5, *((unsigned __int16 *)a5 + 272) - 1);
      result = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4 + 1);
      if (*v17 >= *result && (*v17 > *result || v17[1] >= result[1]))
      {
        v18 = (void *)*MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v22, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v21, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v20, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v19);
        health::_HDAssertImplementation<health::btree_access_error>(v18, (uint64_t)v22, (uint64_t)v21, (uint64_t)v20, 146, (uint64_t)&v19);
      }
    }
  }
  return result;
}

void sub_1B78A5CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  _QWORD *v5;
  _QWORD *v6;
  __int16 v8;

  for (i = 0; i != 17; ++i)
  {
    v5 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    v6 = v5 + 2;
    health::DataStore::ObjectIdentifier::deserialize(v5, a2);
    health::BlockPointer::deserialize(v6, a2);
  }
  v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 544) = v8;
  health::BlockPointer::deserialize((_QWORD *)(a1 + 552), a2);
  return health::BlockPointer::deserialize((_QWORD *)(a1 + 568), a2);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, __n128 *a5, __n128 *a6)
{
  int v10;
  __int128 *v12;
  __n128 v13;
  health::BlockAccessFile::WriteTransaction *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD v18[34];
  __int16 v19;
  __int128 v20;
  __int128 v21;

  if (*(_WORD *)(a4 + 544))
  {
    v10 = a2 + 1;
    if (*(_BYTE *)(a4 + 546))
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithLeafChildren(a1, v10, a3, a4, a5, a6);
    else
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithInteriorChildren(a1, v10, a3, a4, a5, (uint64_t)a6);
  }
  else
  {
    memset(&v18[2], 0, 512);
    v12 = *(__int128 **)(a1 + 16);
    v20 = *v12;
    v21 = *v12;
    v19 = 1;
    v13 = *a6;
    v18[0] = *a5;
    v18[1] = v13;
    v14 = (health::BlockAccessFile::WriteTransaction *)*((_QWORD *)v12 + 3);
    v15 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v14, 578);
    v17 = v16;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>((uint64_t)v14, v15, v16, (uint64_t)v18);
    *(__n128 *)a4 = *a5;
    *(_QWORD *)(a4 + 16) = v15;
    *(_QWORD *)(a4 + 24) = v17;
    *(_WORD *)(a4 + 544) = 1;
    *(_BYTE *)(a4 + 546) = 1;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithLeafChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, __n128 *a5, __n128 *a6)
{
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  __n128 v22;
  health::BlockAccessFile::WriteTransaction *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  unint64_t v29;
  uint64_t v30;
  health::BlockAccessFile::WriteTransaction *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  _BYTE *v38;
  uint64_t v40;
  uint64_t *v41;
  __int128 v42;
  __int128 v43;
  __n128 v44;
  uint64_t v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  _OWORD v49[34];
  __int16 v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[544];
  unsigned __int16 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;

  v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a4, a5);
  v57 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 16);
  v13 = *(_QWORD *)(a1 + 16);
  bzero(v53, 0x222uLL);
  v55 = 0u;
  v56 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v13 + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)v53);
  v14 = (a2 + 1);
  v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, (uint64_t *)&v57, (uint64_t)v53, a5, a6);
  v16 = v15;
  if (v15 > 1)
  {
    v18 = *(unsigned __int16 *)(a4 + 544);
    if (v18 == 17)
    {
      if ((_DWORD)v15 == 4)
        v19 = 4;
      else
        v19 = 2;
      if ((_DWORD)v15 == 3)
        v20 = 3;
      else
        v20 = 2;
      if (v12)
        v21 = 2;
      else
        v21 = v20;
      if (v12 == 16)
        return v19;
      else
        return v21;
    }
    else if ((_DWORD)v15 == 4 && v18 - 1 == v12)
    {
      memset(&v49[2], 0, 512);
      v50 = 1;
      v22 = *a6;
      v49[0] = *a5;
      v49[1] = v22;
      v51 = v57;
      v52 = v56;
      v23 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v24 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v23, 578);
      v26 = v25;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>((uint64_t)v23, v24, v25, (uint64_t)v49);
      *(_QWORD *)&v56 = v24;
      *((_QWORD *)&v56 + 1) = v26;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)v53);
      v27 = *(_QWORD *)(a1 + 16);
      v28 = v52;
      if (v52 != *(_OWORD *)v27)
      {
        bzero(&v44, 0x222uLL);
        v47 = 0u;
        v48 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v27 + 24), v28, *((uint64_t *)&v28 + 1), (uint64_t)&v44);
        *(_QWORD *)&v47 = v24;
        *((_QWORD *)&v47 + 1) = v26;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v52, *((uint64_t *)&v52 + 1), (uint64_t)&v44);
      }
      v29 = *(unsigned __int16 *)(a4 + 544);
      v30 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v29);
      *(_QWORD *)(v30 + 16) = v24;
      *(_QWORD *)(v30 + 24) = v26;
      *(__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v29) = *a5;
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
    else
    {
      v41 = a3;
      v43 = v57;
      bzero(v49, 0x222uLL);
      v51 = v57;
      v52 = v56;
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v49, 0, (uint64_t)v53, v54 - 8, 8);
      v54 -= 8;
      v50 = 8;
      v31 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v32 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v31, 578);
      v34 = v33;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>((uint64_t)v31, v32, v33, (uint64_t)v49);
      *(_QWORD *)&v42 = v32;
      *((_QWORD *)&v42 + 1) = v34;
      v56 = v42;
      v35 = *(_QWORD *)(a1 + 16);
      v36 = v52;
      if (v52 != *(_OWORD *)v35)
      {
        v40 = *((_QWORD *)&v52 + 1);
        bzero(&v44, 0x222uLL);
        v47 = 0u;
        v48 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v35 + 24), v36, v40, (uint64_t)&v44);
        v47 = v42;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v52, *((uint64_t *)&v52 + 1), (uint64_t)&v44);
      }
      v44 = (__n128)v49[0];
      v45 = v32;
      v46 = v34;
      health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v44, v12 + 1);
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v43, *((uint64_t *)&v43 + 1), (uint64_t)v53);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *v41, v41[1], a4);
      if ((int64_t)a5->n128_u64[0] <= *(uint64_t *)&v49[0]
        && ((int64_t)a5->n128_u64[0] < *(uint64_t *)&v49[0] || a5->n128_u64[1] <= *((_QWORD *)&v49[0] + 1)))
      {
        v37 = (uint64_t *)&v43;
        v38 = v53;
      }
      else
      {
        v37 = (uint64_t *)&v42;
        v38 = v49;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, v37, (uint64_t)v38, a5, a6);
    }
  }
  else
  {
    v17 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12);
    if ((int64_t)a5->n128_u64[0] < *v17 || (int64_t)a5->n128_u64[0] <= *v17 && a5->n128_u64[1] < v17[1])
    {
      *(__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12) = *a5;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithInteriorChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, _QWORD *a5, uint64_t a6)
{
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  health::BlockAccessFile::WriteTransaction *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  __n128 *v23;
  __n128 v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[2];
  __n128 v29;
  __int16 v30;
  char v31;
  __int128 v32;
  _QWORD v33[68];
  unsigned __int16 v34;
  char v35;
  __int128 v36;

  v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a4, a5);
  v13 = v12;
  v36 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 16);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(a1, a2, a4, v12, v33);
  v14 = (a2 + 1);
  v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, &v36, v33, a5, a6);
  if (v15 > 1)
  {
    if (*(_WORD *)(a4 + 544) == 17)
    {
      return 2;
    }
    else
    {
      v32 = v36;
      bzero(&v29, 0x223uLL);
      v31 = v35;
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)&v29, 0, (uint64_t)v33, v34 - 8, 8);
      v34 -= 8;
      v30 = 8;
      v18 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v19 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v18, 547);
      v21 = v20;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>((uint64_t)v18, v19, v20, (uint64_t)&v29);
      v28[0] = v19;
      v28[1] = v21;
      v25 = v29;
      v26 = v19;
      v27 = v21;
      health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v25, v13 + 1);
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v32, *((uint64_t *)&v32 + 1), (uint64_t)v33);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      if (*a5 <= v29.n128_i64[0] && (*a5 < v29.n128_i64[0] || a5[1] <= v29.n128_u64[1]))
      {
        v22 = &v32;
        v23 = (__n128 *)v33;
      }
      else
      {
        v22 = (__int128 *)v28;
        v23 = &v29;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, v22, v23, a5, a6);
    }
  }
  else
  {
    v16 = v15;
    v17 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13);
    if (*a5 < *v17 || *a5 <= *v17 && a5[1] < v17[1])
    {
      *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13) = *(_OWORD *)a5;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::serialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  uint64_t *v5;
  uint64_t v7;

  for (i = 0; i != 17; ++i)
  {
    v5 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry::serialize(v5, a2);
  }
  LOWORD(v7) = *(_WORD *)(a1 + 544);
  health::SerializationBuffer::appendRaw<unsigned short>(a2, &v7);
  v7 = *(_QWORD *)(a1 + 552);
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
  v7 = *(_QWORD *)(a1 + 560);
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
  v7 = *(_QWORD *)(a1 + 568);
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
  v7 = *(_QWORD *)(a1 + 576);
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5;

  v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[2];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[3];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, __n128 *a5, __n128 *a6)
{
  uint64_t v11;
  uint64_t v12;
  unint64_t v14;
  __n128 v15;
  uint64_t v16;
  __n128 v17[2];

  v11 = health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey(a4, a5);
  if (HIDWORD(v11))
  {
    if (*(_WORD *)(a4 + 544) == 17)
    {
      v12 = a5->n128_u64[0];
      if ((int64_t)a5->n128_u64[0] < *(_QWORD *)a4
        || (int64_t)a5->n128_u64[0] <= *(_QWORD *)a4 && a5->n128_u64[1] < *(_QWORD *)(a4 + 8))
      {
        return 3;
      }
      else
      {
        v16 = *(_QWORD *)(a4 + 512);
        if (v12 > v16 || v12 >= v16 && a5->n128_u64[1] > *(_QWORD *)(a4 + 520))
          return 4;
        else
          return 2;
      }
    }
    else
    {
      if (HIDWORD(v11) == 2)
        v14 = (unsigned __int16)v11 + 1;
      else
        v14 = (unsigned __int16)v11;
      v15 = *a6;
      v17[0] = *a5;
      v17[1] = v15;
      health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, v17, v14);
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
  }
  else
  {
    *(__n128 *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, (unsigned __int16)v11)+ 16) = *a6;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 1;
  }
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v7;
  uint64_t result;
  _QWORD v9[2];
  _QWORD v10[3];
  _BYTE v11[1024];
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = 547;
  v10[0] = v11;
  v10[1] = v11;
  v10[2] = 547;
  health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF)
    v7 = v11;
  else
    v7 = v12;
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  result = (uint64_t)v12;
  v12 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B78A6AE4(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::serialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  uint64_t *v5;
  __int16 v7;
  char v8;

  for (i = 0; i != 17; ++i)
  {
    v5 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry::serialize(v5, a2);
  }
  v7 = *(_WORD *)(a1 + 544);
  health::SerializationBuffer::appendRaw<unsigned short>(a2, &v7);
  v8 = *(_BYTE *)(a1 + 546);
  return health::SerializationBuffer::appendRaw<unsigned char>(a2, &v8);
}

void health::not_found_error::~not_found_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1BCCAC494);
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1BCCAC494);
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

void _ZNSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E6CEA8A0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE7__cloneEPNS0_6__baseISE_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEA8A0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EEclESA_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  char v10;
  _QWORD v11[3];
  _QWORD *v12;
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 16);
  v3 = **(_QWORD **)(a1 + 8);
  v11[0] = &off_1E6CEA9B0;
  v11[1] = a2;
  v12 = v11;
  v10 = 0;
  v4 = operator new(0x20uLL);
  *v4 = &off_1E6CEA920;
  v4[1] = v2;
  v4[2] = v11;
  v4[3] = &v10;
  v14 = v4;
  health::DataStore::performReadTransactionWithLambda(v3, (uint64_t)v13);
  v5 = v14;
  if (v14 == v13)
  {
    v6 = 4;
    v5 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v12;
  if (v12 == v11)
  {
    v8 = 4;
    v7 = v11;
    goto LABEL_10;
  }
  if (v12)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return 1;
}

void sub_1B78A6DD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  char *v17;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;

  v19 = a17;
  if (a17 == v17)
  {
    v20 = 4;
    v19 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v20 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v19 + 8 * v20))();
LABEL_6:
  v21 = a13;
  if (a13 == &a10)
  {
    v22 = 4;
    v21 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_11;
    v22 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE11target_typeEv()
{
  return &_ZTIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CEA920;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEA920;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, health::DataStore::ReadTransaction *a2)
{
  ObjectIdentifier *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  _QWORD v12[2];
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  ObjectIdentifier v17;
  health::DataStore::ReadTransaction *v18;
  _BYTE v19[24];
  _QWORD v20[3];
  _QWORD v21[2];
  uint64_t v22;
  _BYTE v23[1024];
  _BYTE *v24;
  unint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v13 = 0u;
  v14 = 0u;
  v16 = 0u;
  v17 = (ObjectIdentifier)0;
  v18 = a2;
  v4 = *(ObjectIdentifier **)(a1 + 8);
  health::DataStore::ReadTransaction::_pointerForObject(a2, v4, (uint64_t)v19);
  if (v19[16])
  {
    v5 = (uint64_t *)*((_QWORD *)a2 + 3);
    v6 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v19);
    v7 = *v6;
    v8 = v6[1];
    v24 = 0;
    v25 = 56;
    v21[0] = v23;
    v21[1] = 56;
    health::BlockAccessFile::ReadTransaction::retrieveBlock(v5, v7, v8, (uint64_t)v21);
    if (v25 <= 0x3FF)
      v9 = v23;
    else
      v9 = v24;
    v20[0] = v9;
    v20[1] = v9;
    v20[2] = 56;
    v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    v12[0] = v22;
    v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    v12[1] = v22;
    v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *(_QWORD *)&v13 = v22;
    v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *((_QWORD *)&v13 + 1) = v22;
    v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *(_QWORD *)&v14 = v22;
    v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *((_QWORD *)&v14 + 1) = v22;
    v22 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v20, &v22);
    v15 = v22;
    v10 = v24;
    v24 = 0;
    if (v10)
      MEMORY[0x1BCCAC47C](v10, 0x1000C8077774924);
    v17 = *v4;
    v16 = *(_OWORD *)health::Optional<health::BlockPointer>::get((uint64_t)v19);
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
    if (!v11)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v11 + 48))(v11, v12);
    **(_BYTE **)(a1 + 24) = 1;
  }
}

void sub_1B78A7104(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x4A8];
  STACK[0x4A8] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

void _ZNSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *_ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CEA9B0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE7__cloneEPNS0_6__baseISK_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CEA9B0;
  a2[1] = v2;
  return result;
}

_QWORD *_ZNSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EEclESG_(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9[3];
  _QWORD v10[3];
  _OWORD v11[26];
  _QWORD v12[3];
  _QWORD *v13;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  v12[0] = &off_1E6CEAA30;
  v12[1] = v2;
  result = v12;
  v13 = v12;
  if (!a2[6])
  {
    v8 = 4;
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }
  v4 = *(uint64_t **)(a2[11] + 24);
  v10[0] = 0;
  v10[1] = 0;
  v10[2] = v4;
  v5 = a2[3];
  v9[0] = a2[2];
  v9[1] = v5;
  v9[2] = (uint64_t)v10;
  v15 = v14;
  v14[0] = &off_1E6CEAA30;
  v14[1] = v2;
  memset(v11, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v4, v9[0], v5, (uint64_t)v11);
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV0>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>)::{lambda(double const&,_HDRawLocationDatumV0 const&)#1}>((uint64_t)v9, 0, (uint64_t)v11, (uint64_t)v14);
  v6 = v15;
  if (v15 == v14)
  {
    v7 = 4;
    v6 = v14;
  }
  else
  {
    if (!v15)
      goto LABEL_8;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_8:
  result = v13;
  if (v13 == v12)
  {
    v8 = 4;
    result = v12;
  }
  else
  {
    if (!v13)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1B78A7350(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v3 = *(_QWORD **)(v1 - 32);
  if (v3 == (_QWORD *)(v1 - 56))
  {
    v4 = 4;
    v3 = (_QWORD *)(v1 - 56);
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = *(_QWORD **)(v1 - 64);
  if (v5 == (_QWORD *)(v1 - 88))
  {
    v6 = 4;
    v5 = (_QWORD *)(v1 - 88);
  }
  else
  {
    if (!v5)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_EUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE11target_typeEv()
{
  return &_ZTIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_EUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV0>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>)::{lambda(double const&,_HDRawLocationDatumV0 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void **v10;
  unint64_t v11;
  double v12;
  unint64_t *v13;
  uint64_t v14;
  __n128 v15;
  void *v16;
  uint64_t v17;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __n128 v23;
  void *v24;
  unint64_t *v25;
  void *v26;
  uint64_t i;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  unint64_t j;
  double *v32;
  uint64_t v33;
  __n128 v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  void *__p[2];
  unsigned __int16 v39;
  __int128 v40;
  __int128 v41;
  std::string v42;
  _OWORD v43[34];
  unsigned __int16 v44;
  __int128 v45;
  __int128 v46;
  std::string v47;
  void *v48[2];
  void *v49[2];
  std::string v50;
  std::string v51;
  _QWORD v52[2];
  _QWORD v53[2];
  std::string v54;
  std::string v55;
  _QWORD v56[2];
  _QWORD v57[2];

  if (*(_WORD *)(a3 + 408))
  {
    v6 = result;
    if (*(_BYTE *)(a3 + 410))
    {
      v7 = *(_QWORD *)(a3 + 8);
      v8 = *(_QWORD *)(a3 + 16);
      v37 = result;
      v9 = *(_QWORD *)(result + 16);
      bzero(__p, 0x222uLL);
      v40 = 0u;
      v41 = 0u;
      result = health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>>(*(uint64_t **)(v9 + 16), v7, v8, (uint64_t)__p);
      v10 = (void **)MEMORY[0x1E0CB52B0];
      if (v39)
      {
        v11 = 0;
        v12 = 0.0;
        while (1)
        {
          v13 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__p, v11);
          v14 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__p, v11);
          if (v11)
          {
            v15.n128_u64[0] = *v13;
            if (*(double *)v13 <= v12)
            {
              v16 = *v10;
              std::string::basic_string[abi:ne180100]<0>(v57, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v56, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v55, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v54);
              health::_HDAssertImplementation<health::btree_access_error>(v16, (uint64_t)v57, (uint64_t)v56, (uint64_t)&v55, 382, (uint64_t)&v54);
            }
          }
          v17 = *(_QWORD *)(a4 + 24);
          if (!v17)
LABEL_35:
            std::__throw_bad_function_call[abi:ne180100]();
          v12 = *(double *)v13;
          result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v17 + 48))(v17, v13, v14 + 8, v15);
          if ((result & 1) == 0)
            break;
          if (++v11 >= v39)
            goto LABEL_23;
        }
      }
      else
      {
        v12 = 0.0;
LABEL_23:
        v28 = *((_QWORD *)&v41 + 1);
        for (i = v41; ; i = v46)
        {
          v29 = *(_QWORD *)(v37 + 16);
          if (i == *(_QWORD *)v29 && v28 == *(_QWORD *)(v29 + 8))
            break;
          bzero(v43, 0x222uLL);
          v45 = 0u;
          v46 = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>>(*(uint64_t **)(v29 + 16), i, v28, (uint64_t)v43);
          if (!v44)
          {
            v30 = *v10;
            std::string::basic_string[abi:ne180100]<0>(v53, "leaf.valueCount > 0");
            std::string::basic_string[abi:ne180100]<0>(v52, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(&v51, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v50);
            health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v53, (uint64_t)v52, (uint64_t)&v51, 392, (uint64_t)&v50);
          }
          for (j = 0; j < v44; ++j)
          {
            v32 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v43, j);
            v33 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v43, j);
            if (*v32 <= v12)
            {
              v35 = *v10;
              std::string::basic_string[abi:ne180100]<0>(v49, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v48, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v47, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v42);
              health::_HDAssertImplementation<health::btree_access_error>(v35, (uint64_t)v49, (uint64_t)v48, (uint64_t)&v47, 396, (uint64_t)&v42);
            }
            v36 = *(_QWORD *)(a4 + 24);
            if (!v36)
              goto LABEL_35;
            v12 = *v32;
            v34.n128_f64[0] = *v32;
            result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v36 + 48))(v36, v32, v33 + 8, v34);
            if ((result & 1) == 0)
              return result;
          }
          v28 = *((_QWORD *)&v46 + 1);
        }
      }
    }
    else
    {
      if (a2 >= 64)
      {
        v19 = (void *)*MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(__p, "depth < kMaximumRecursionDepth");
        std::string::basic_string[abi:ne180100]<0>(v57, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v56, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Maximum recursion depth reached.", &v55);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)__p, (uint64_t)v57, (uint64_t)v56, 138, (uint64_t)&v55);
      }
      v20 = *(_QWORD *)(a3 + 8);
      v21 = *(_QWORD *)(a3 + 16);
      v22 = *(_QWORD *)(result + 16);
      memset(v43, 0, 411);
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v22 + 16), v20, v21, (uint64_t)v43);
      if (WORD4(v43[25]))
      {
        v23.n128_u64[0] = *(_QWORD *)&v43[0];
        if (*(double *)v43 < *(double *)a3)
        {
          v24 = (void *)*MEMORY[0x1E0CB52B0];
          std::string::basic_string[abi:ne180100]<0>(&v54, "child.children[0].key >= node.children[index].key");
          std::string::basic_string[abi:ne180100]<0>(v53, "_interiorChildAtIndex");
          std::string::basic_string[abi:ne180100]<0>(v52, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v51);
          health::_HDAssertImplementation<health::btree_access_error>(v24, (uint64_t)&v54, (uint64_t)v53, (uint64_t)v52, 144, (uint64_t)&v51);
        }
        if (*(unsigned __int16 *)(a3 + 408) >= 2u)
        {
          v25 = (unint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v43, WORD4(v43[25]) - 1);
          v23.n128_u64[0] = *v25;
          if (*(double *)v25 >= *(double *)(a3 + 24))
          {
            v26 = (void *)*MEMORY[0x1E0CB52B0];
            std::string::basic_string[abi:ne180100]<0>(&v50, "child.children[child.childCount - 1].key < node.children[index + 1].key");
            std::string::basic_string[abi:ne180100]<0>(v49, "_interiorChildAtIndex");
            std::string::basic_string[abi:ne180100]<0>(v48, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v47);
            health::_HDAssertImplementation<health::btree_access_error>(v26, (uint64_t)&v50, (uint64_t)v49, (uint64_t)v48, 146, (uint64_t)&v47);
          }
        }
      }
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV0>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>)::{lambda(double const&,_HDRawLocationDatumV0 const&)#1}>(v6, (a2 + 1), v43, a4, v23);
    }
  }
  return result;
}

void sub_1B78A7AB8(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x4D7]) < 0)
    operator delete((void *)STACK[0x4C0]);
  if (SLOBYTE(STACK[0x4EF]) < 0)
    operator delete((void *)STACK[0x4D8]);
  if (SLOBYTE(STACK[0x507]) < 0)
    operator delete((void *)STACK[0x4F0]);
  if (SLOBYTE(STACK[0x51F]) < 0)
    operator delete((void *)STACK[0x508]);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  __int16 v8;
  char v9;

  for (i = 0; i != 17; ++i)
  {
    v5 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    v7 = 0;
    health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
    *v5 = v7;
    health::BlockPointer::deserialize(v5 + 1, a2);
  }
  v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 408) = v8;
  v9 = 0;
  result = health::DeserializationBuffer::extractRaw<unsigned char>(a2, &v9);
  *(_BYTE *)(a1 + 410) = v9 != 0;
  return result;
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t result;
  _QWORD v12[3];
  _QWORD v13[2];
  uint64_t v14;
  unsigned __int8 v15[1024];
  unsigned __int8 *v16;
  unint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v17 = 578;
  health::RawBuffer::RawBuffer(v13, v15, 578);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v13);
  v8 = 0;
  v9 = v15;
  if (v17 > 0x3FF)
    v9 = v16;
  v12[0] = v9;
  v12[1] = v9;
  v12[2] = 578;
  do
  {
    v10 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a4, v8);
    v14 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v12, &v14);
    *(_QWORD *)v10 = v14;
    v14 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v12, &v14);
    *(_QWORD *)(v10 + 8) = v14;
    v14 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v12, &v14);
    *(_QWORD *)(v10 + 16) = v14;
    LODWORD(v14) = 0;
    health::DeserializationBuffer::extractRaw<int>((uint64_t)v12, &v14);
    *(_DWORD *)(v10 + 24) = v14;
    LODWORD(v14) = 0;
    health::DeserializationBuffer::extractRaw<int>((uint64_t)v12, &v14);
    *(_DWORD *)(v10 + 28) = v14;
    ++v8;
  }
  while (v8 != 17);
  LOWORD(v14) = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>((uint64_t)v12, &v14);
  *(_WORD *)(a4 + 544) = v14;
  health::BlockPointer::deserialize((_QWORD *)(a4 + 552), (uint64_t)v12);
  health::BlockPointer::deserialize((_QWORD *)(a4 + 568), (uint64_t)v12);
  result = (uint64_t)v16;
  v16 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B78A7F3C(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x438];
  STACK[0x438] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

void sub_1B78A8054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

void sub_1B78A819C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *_ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CEAA30;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CEAA30;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EEclESP_SK_(uint64_t a1, uint64_t *a2, __int128 *a3)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  v8 = *a2;
  v4 = *a3;
  v5 = *((_QWORD *)a3 + 2);
  v6 = 3212836864;
  v7 = 0;
  health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::insertSample(*(_QWORD *)(a1 + 8), (double *)&v8, (uint64_t)&v4);
  return 1;
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_ENKUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESD_EUldRK21_HDRawLocationDatumV0E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE11target_typeEv()
{
  return &_ZTIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_ENKUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESD_EUldRK21_HDRawLocationDatumV0E_;
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::serialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  uint64_t *v5;
  __int16 v7;
  char v8;

  for (i = 0; i != 17; ++i)
  {
    v5 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry::serialize(v5, a2);
  }
  v7 = *(_WORD *)(a1 + 408);
  health::SerializationBuffer::appendRaw<unsigned short>(a2, &v7);
  v8 = *(_BYTE *)(a1 + 410);
  return health::SerializationBuffer::appendRaw<unsigned char>(a2, &v8);
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5;

  v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[2];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t a6)
{
  int v11;
  __int128 *v13;
  __int128 v14;
  health::BlockAccessFile::WriteTransaction *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  _WORD v23[388];
  __int128 v24;
  __int128 v25;

  if (*(_WORD *)(a4 + 408))
  {
    v11 = a2 + 1;
    if (*(_BYTE *)(a4 + 410))
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithLeafChildren(a1, v11, a3, a4, a5, a6);
    else
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithInteriorChildren(a1, v11, a3, a4, a5, a6);
  }
  else
  {
    bzero(v23, 0x300uLL);
    v13 = *(__int128 **)(a1 + 16);
    v24 = *v13;
    v25 = *v13;
    v19 = *a5;
    v14 = *(_OWORD *)(a6 + 16);
    v20 = *(_OWORD *)a6;
    v21 = v14;
    v23[384] = 1;
    v22 = *(_QWORD *)(a6 + 32);
    v15 = (health::BlockAccessFile::WriteTransaction *)*((_QWORD *)v13 + 3);
    v16 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v15, 782);
    v18 = v17;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>((uint64_t)v15, v16, v17, (uint64_t)&v19);
    *(double *)a4 = *a5;
    *(_QWORD *)(a4 + 8) = v16;
    *(_QWORD *)(a4 + 16) = v18;
    *(_WORD *)(a4 + 408) = 1;
    *(_BYTE *)(a4 + 410) = 1;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithLeafChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t a6)
{
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  double v18;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  __int128 v23;
  health::BlockAccessFile::WriteTransaction *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  unint64_t v30;
  uint64_t v31;
  double v32;
  health::BlockAccessFile::WriteTransaction *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  double *v40;
  uint64_t v42;
  uint64_t *v43;
  __int128 v44;
  __int128 v45;
  __n128 v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  double v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  __int16 v55;
  __int128 v56;
  __int128 v57;
  _BYTE v58[816];
  unsigned __int16 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;

  v12 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  v62 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 8);
  v13 = *(_QWORD *)(a1 + 16);
  bzero(v58, 0x332uLL);
  v60 = 0u;
  v61 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v13 + 24), v62, *((uint64_t *)&v62 + 1), (uint64_t)v58);
  v14 = (a2 + 1);
  v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, (uint64_t *)&v62, (uint64_t)v58, a5, (__int128 *)a6);
  v16 = v15;
  if (v15 > 1)
  {
    v19 = *(unsigned __int16 *)(a4 + 408);
    if (v19 == 17)
    {
      if ((_DWORD)v15 == 4)
        v20 = 4;
      else
        v20 = 2;
      if ((_DWORD)v15 == 3)
        v21 = 3;
      else
        v21 = 2;
      if (v12)
        v22 = 2;
      else
        v22 = v21;
      if (v12 == 16)
        return v20;
      else
        return v22;
    }
    else if ((_DWORD)v15 == 4 && v19 - 1 == v12)
    {
      bzero(&v54, 0x300uLL);
      v50 = *a5;
      v23 = *(_OWORD *)a6;
      v52 = *(_OWORD *)(a6 + 16);
      v55 = 1;
      v53 = *(_QWORD *)(a6 + 32);
      v51 = v23;
      v56 = v62;
      v57 = v61;
      v24 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v25 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v24, 782);
      v27 = v26;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>((uint64_t)v24, v25, v26, (uint64_t)&v50);
      *(_QWORD *)&v61 = v25;
      *((_QWORD *)&v61 + 1) = v27;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v62, *((uint64_t *)&v62 + 1), (uint64_t)v58);
      v28 = *(_QWORD *)(a1 + 16);
      v29 = v57;
      if (v57 != *(_OWORD *)v28)
      {
        bzero(&v46, 0x332uLL);
        v48 = 0u;
        v49 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v28 + 24), v29, *((uint64_t *)&v29 + 1), (uint64_t)&v46);
        *(_QWORD *)&v48 = v25;
        *((_QWORD *)&v48 + 1) = v27;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)&v46);
      }
      v30 = *(unsigned __int16 *)(a4 + 408);
      v31 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v30);
      *(_QWORD *)(v31 + 8) = v25;
      *(_QWORD *)(v31 + 16) = v27;
      v32 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v30) = v32;
      ++*(_WORD *)(a4 + 408);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
    else
    {
      v43 = a3;
      v45 = v62;
      bzero(&v50, 0x332uLL);
      v56 = v62;
      v57 = v61;
      health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)&v50, 0, (uint64_t)v58, v59 - 8, 8);
      v59 -= 8;
      v55 = 8;
      v33 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v34 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v33, 782);
      v36 = v35;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>((uint64_t)v33, v34, v35, (uint64_t)&v50);
      *(_QWORD *)&v44 = v34;
      *((_QWORD *)&v44 + 1) = v36;
      v61 = v44;
      v37 = *(_QWORD *)(a1 + 16);
      v38 = v57;
      if (v57 != *(_OWORD *)v37)
      {
        v42 = *((_QWORD *)&v57 + 1);
        bzero(&v46, 0x332uLL);
        v48 = 0u;
        v49 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v37 + 24), v38, v42, (uint64_t)&v46);
        v48 = v44;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)&v46);
      }
      v46.n128_f64[0] = v50;
      v46.n128_u64[1] = v34;
      v47 = v36;
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v46, v12 + 1);
      ++*(_WORD *)(a4 + 408);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v45, *((uint64_t *)&v45 + 1), (uint64_t)v58);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *v43, v43[1], a4);
      if (*a5 <= v50)
      {
        v39 = (uint64_t *)&v45;
        v40 = (double *)v58;
      }
      else
      {
        v39 = (uint64_t *)&v44;
        v40 = &v50;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, v39, (uint64_t)v40, a5, (__int128 *)a6);
    }
  }
  else
  {
    v17 = *a5;
    if (v17 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12))
    {
      v18 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12) = v18;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithInteriorChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t a6)
{
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  double v18;
  health::BlockAccessFile::WriteTransaction *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 *v23;
  _BYTE *v24;
  __n128 v26;
  uint64_t v27;
  _QWORD v28[2];
  _OWORD v29[26];
  __int128 v30;
  _BYTE v31[408];
  unsigned __int16 v32;
  char v33;
  __int128 v34;

  v12 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  v13 = v12;
  v34 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 8);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_interiorChildAtIndex(a1, a2, a4, v12, (uint64_t)v31);
  v14 = (a2 + 1);
  v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, &v34, v31, a5, a6);
  if (v15 > 1)
  {
    if (*(_WORD *)(a4 + 408) == 17)
    {
      return 2;
    }
    else
    {
      v30 = v34;
      memset(v29, 0, 411);
      BYTE10(v29[25]) = v33;
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v29, 0, (uint64_t)v31, v32 - 8, 8);
      v32 -= 8;
      WORD4(v29[25]) = 8;
      v19 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v20 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v19, 411);
      v22 = v21;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v19, v20, v21, (uint64_t)v29);
      v28[0] = v20;
      v28[1] = v22;
      v26.n128_u64[0] = *(_QWORD *)&v29[0];
      v26.n128_u64[1] = v20;
      v27 = v22;
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v26, v13 + 1);
      ++*(_WORD *)(a4 + 408);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v30, *((uint64_t *)&v30 + 1), (uint64_t)v31);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      if (*a5 <= *(double *)v29)
      {
        v23 = &v30;
        v24 = v31;
      }
      else
      {
        v23 = (__int128 *)v28;
        v24 = v29;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, v23, v24, a5, a6);
    }
  }
  else
  {
    v16 = v15;
    v17 = *a5;
    if (v17 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13))
    {
      v18 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13) = v18;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t _HDRawLocationDatumV1::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5;

  v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 4);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 5);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 6);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 7);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 8);
  return health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, double *a5, __int128 *a6)
{
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  unint64_t v16;
  double v17;
  __int128 v18;
  double v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v11 = health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::indexForKey(a4, a5);
  if (HIDWORD(v11))
  {
    if (*(_WORD *)(a4 + 816) == 17)
    {
      if (*a5 >= *(double *)a4)
      {
        if (*a5 <= *(double *)(a4 + 768))
          return 2;
        else
          return 4;
      }
      else
      {
        return 3;
      }
    }
    else
    {
      if (HIDWORD(v11) == 2)
        v16 = (unsigned __int16)v11 + 1;
      else
        v16 = (unsigned __int16)v11;
      v17 = *a5;
      v18 = a6[1];
      v20 = *a6;
      v21 = v18;
      v22 = *((_QWORD *)a6 + 4);
      v19 = v17;
      health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::insertElementAtIndex(a4, (uint64_t)&v19, v16);
      ++*(_WORD *)(a4 + 816);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
  }
  else
  {
    v13 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a4, (unsigned __int16)v11);
    v14 = *((_QWORD *)a6 + 4);
    v15 = a6[1];
    *(_OWORD *)(v13 + 8) = *a6;
    *(_OWORD *)(v13 + 24) = v15;
    *(_QWORD *)(v13 + 40) = v14;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 1;
  }
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  _QWORD *v5;
  uint64_t v7;
  __int16 v8;

  for (i = 0; i != 17; ++i)
  {
    v5 = (_QWORD *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, i);
    v7 = 0;
    health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
    *v5 = v7;
    _HDRawLocationDatumV1::deserialize((uint64_t)(v5 + 1), a2);
  }
  v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 816) = v8;
  health::BlockPointer::deserialize((_QWORD *)(a1 + 824), a2);
  return health::BlockPointer::deserialize((_QWORD *)(a1 + 840), a2);
}

float _HDRawLocationDatumV1::deserialize(uint64_t a1, uint64_t a2)
{
  float result;
  uint64_t v5;

  v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *(_QWORD *)a1 = v5;
  v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *(_QWORD *)(a1 + 8) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 16) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 20) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 24) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 28) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  result = *(float *)&v5;
  *(_DWORD *)(a1 + 32) = v5;
  return result;
}

double *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_interiorChildAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *result;
  double v16;
  void *v17;
  double v18;
  void *v19;
  std::string v20;
  void *v21[2];
  void *v22[2];
  void *v23[2];
  std::string v24;
  void *v25[2];
  void *v26[2];
  void *v27[2];
  std::string __p;
  void *v29[2];
  _QWORD v30[2];
  _QWORD v31[2];
  std::string v32;
  _QWORD v33[2];
  _QWORD v34[2];
  _QWORD v35[2];

  if (*(unsigned __int16 *)(a3 + 408) <= a4)
  {
    v9 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a2 >= 64)
  {
    v10 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
  v12 = *(_QWORD *)(v11 + 8);
  v13 = *(_QWORD *)(v11 + 16);
  v14 = *(_QWORD *)(a1 + 16);
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 208) = 0u;
  *(_OWORD *)(a5 + 224) = 0u;
  *(_OWORD *)(a5 + 240) = 0u;
  *(_OWORD *)(a5 + 256) = 0u;
  *(_OWORD *)(a5 + 272) = 0u;
  *(_OWORD *)(a5 + 288) = 0u;
  *(_OWORD *)(a5 + 304) = 0u;
  *(_OWORD *)(a5 + 320) = 0u;
  *(_OWORD *)(a5 + 336) = 0u;
  *(_OWORD *)(a5 + 352) = 0u;
  *(_OWORD *)(a5 + 368) = 0u;
  *(_OWORD *)(a5 + 384) = 0u;
  *(_OWORD *)(a5 + 395) = 0u;
  result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, a5);
  if (*(_WORD *)(a5 + 408))
  {
    v16 = *(double *)a5;
    result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    if (v16 < *result)
    {
      v17 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a3 + 408) - 1 > (int)a4)
    {
      v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, *(unsigned __int16 *)(a5 + 408) - 1);
      result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4 + 1);
      if (v18 >= *result)
      {
        v19 = (void *)*MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1B78A9368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

void *health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  void *v6;
  std::string v8;
  void *v9[2];
  void *v10[2];
  void *v11[2];
  std::string __p;
  void *v13[2];
  _QWORD v14[2];
  _QWORD v15[2];

  if ((unint64_t)(a5 + a2) >= 0x12)
  {
    v5 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v15, "destinationIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v14, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow destination.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 79, (uint64_t)&__p);
  }
  if ((unint64_t)(a5 + a4) >= 0x12)
  {
    v6 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "sourceIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow source.", &v8);
    health::_HDAssertImplementation<std::out_of_range>(v6, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 80, (uint64_t)&v8);
  }
  return memcpy((void *)(a1 + 24 * a2), (const void *)(a3 + 24 * a4), 24 * a5);
}

void sub_1B78A96B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

void sub_1B78A9910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__16(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__16(uint64_t a1)
{

}

void sub_1B78A9B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableNanoSyncActivationRestoreReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  void *v31;
  uint64_t result;
  void *v33;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadData();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 32;
          goto LABEL_35;
        case 2u:
          v19 = 0;
          v20 = 0;
          v21 = 0;
          *(_BYTE *)(a1 + 44) |= 1u;
          while (2)
          {
            v22 = *v3;
            v23 = *(_QWORD *)(a2 + v22);
            if (v23 == -1 || v23 >= *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
              *(_QWORD *)(a2 + v22) = v23 + 1;
              v21 |= (unint64_t)(v24 & 0x7F) << v19;
              if (v24 < 0)
              {
                v19 += 7;
                v14 = v20++ >= 9;
                if (v14)
                {
                  v21 = 0;
                  goto LABEL_44;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            v21 = 0;
LABEL_44:
          *(_QWORD *)(a1 + 8) = v21;
          continue;
        case 3u:
          v25 = 0;
          v26 = 0;
          v27 = 0;
          *(_BYTE *)(a1 + 44) |= 2u;
          break;
        case 4u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
LABEL_35:
          v31 = *(void **)(a1 + v18);
          *(_QWORD *)(a1 + v18) = v17;

          continue;
        case 6u:
          PBReaderReadData();
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          if (v33)
            objc_msgSend((id)a1, "addObliteratedHealthPairingUUIDs:", v33);

          continue;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v28 = *v3;
        v29 = *(_QWORD *)(a2 + v28);
        if (v29 == -1 || v29 >= *(_QWORD *)(a2 + *v4))
          break;
        v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
        *(_QWORD *)(a2 + v28) = v29 + 1;
        v27 |= (unint64_t)(v30 & 0x7F) << v25;
        if ((v30 & 0x80) == 0)
          goto LABEL_46;
        v25 += 7;
        v14 = v26++ >= 9;
        if (v14)
        {
          LODWORD(v27) = 0;
          goto LABEL_48;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_46:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v27) = 0;
LABEL_48:
      *(_DWORD *)(a1 + 40) = v27;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCategorySampleEntityPredicateEqualToValues(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29840], "predicateWithProperty:equalToValues:", CFSTR("value"), a1);
}

uint64_t HDDatabaseCurrentSchemaVersion(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = 100002;
  if (a1 == 2)
    v2 = 100017;
  if (a2)
    return v2;
  else
    return 18006;
}

uint64_t HDCodableRoutineLocationResponseReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableRoutineLocation *v17;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableRoutineLocation);
        objc_storeStrong((id *)(a1 + 8), v17);
        if (!PBReaderPlaceMark() || (HDCodableRoutineLocationReadFrom(v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B78B0138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a64;
  char a68;
  char a72;
  uint64_t v72;
  void *v74;

  _Block_object_dispose(&a64, 8);
  _Block_object_dispose(&a68, 8);
  _Block_object_dispose(&a72, 8);
  _Block_object_dispose(&STACK[0x218], 8);
  _Block_object_dispose(&STACK[0x238], 8);

  _Block_object_dispose((const void *)(v72 - 240), 8);
  _Block_object_dispose(&STACK[0x290], 8);
  v74 = (void *)STACK[0x2C8];
  if (STACK[0x2C8])
  {
    STACK[0x2D0] = (unint64_t)v74;
    operator delete(v74);
  }
  _Block_object_dispose(&STACK[0x2F0], 8);
  _Block_object_dispose((const void *)(v72 - 192), 8);

  _Block_object_dispose(&STACK[0x310], 8);
  _Unwind_Resume(a1);
}

void sub_1B78B0584(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78B05F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78B069C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__17(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__17(uint64_t a1)
{

}

__n128 __Block_byref_object_copy__206(__n128 *a1, uint64_t a2)
{
  unsigned __int32 v2;
  __n128 result;

  v2 = *(_DWORD *)(a2 + 48);
  a1[3].n128_u8[4] = *(_BYTE *)(a2 + 52);
  a1[3].n128_u32[0] = v2;
  a1[4].n128_u64[0] = 0;
  a1[4].n128_u64[1] = 0;
  a1[3].n128_u64[1] = 0;
  *(__n128 *)((char *)a1 + 56) = *(__n128 *)(a2 + 56);
  a1[4].n128_u64[1] = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  result = *(__n128 *)(a2 + 80);
  a1[5] = result;
  return result;
}

void __Block_byref_object_dispose__207(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

{

}

void sub_1B78B07A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78B0E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;

  _Block_object_dispose(&a30, 8);
  _Unwind_Resume(a1);
}

void sub_1B78B10A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1B78B14A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1B78B178C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78B1888(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B78B190C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78B1978(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78B1A98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78B1B38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double _overlappingSampleDistanceForInterval(void *a1, double *a2, BOOL *a3)
{
  id v5;
  void *v6;
  double v7;
  double v8;
  void *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;

  v5 = a1;
  objc_msgSend(v5, "startDate");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "timeIntervalSinceReferenceDate");
  v8 = v7;

  objc_msgSend(v5, "endDate");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "timeIntervalSinceReferenceDate");
  v11 = v10;

  v12 = *a2;
  v13 = a2[1];
  v14 = a2[2];
  if (a3)
    *a3 = v13 < v11;
  v15 = v14 / (v13 - v12);
  if (v11 < v13)
    v13 = v11;
  if (v8 >= v12)
    v12 = v8;
  v16 = v15 * fmax(v13 - v12, 0.0);

  return v16;
}

void sub_1B78B1BFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78B1F50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B78B2194(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B78B23BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a1);
}

void __cxx_global_array_dtor()
{
  uint64_t i;

  for (i = 0; i != -21; i -= 3)
  {

  }
}

void sub_1B78B3950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__18(uint64_t a1)
{

}

void sub_1B78B3CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id unimplementedError()
{
  void *v0;
  uint64_t v1;
  void *v2;
  void *v3;
  uint64_t v5;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v0 = (void *)MEMORY[0x1E0CB35C8];
  v1 = *MEMORY[0x1E0CB4E20];
  v5 = *MEMORY[0x1E0CB2D50];
  v6[0] = CFSTR("Unimplemented");
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v6, &v5, 1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "errorWithDomain:code:userInfo:", v1, 100, v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1B78B5EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1B78B6130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__19(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__19(uint64_t a1)
{

}

void sub_1B78B6C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1B78B7210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1B78B996C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__20(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20(uint64_t a1)
{

}

void sub_1B78BB118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a39, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__21(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__21(uint64_t a1)
{

}

void sub_1B78BD068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78BE88C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78BF5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDPauseRingsScheduleEntityPredicateForCacheIndexRange(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v3 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "predicateWithProperty:value:comparisonType:", CFSTR("start_date_index"), v4, 4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "predicateWithProperty:value:comparisonType:", CFSTR("end_date_index"), v7, 6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v5, v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

void sub_1B78C5464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__22(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__22(uint64_t a1)
{

}

BOOL HDCodableSharingSetupMetadataReadFrom(char *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  HDCodableSharingSetupInvitationToken *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      if (v9++ >= 9)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 48;
        goto LABEL_28;
      case 2u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 24;
        goto LABEL_28;
      case 3u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 40;
        goto LABEL_28;
      case 4u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 32;
        goto LABEL_28;
      case 5u:
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 16;
LABEL_28:
        v19 = *(HDCodableSharingSetupInvitationToken **)&a1[v18];
        *(_QWORD *)&a1[v18] = v17;
        goto LABEL_29;
      default:
        if ((v10 >> 3) != 100)
        {
          if ((PBReaderSkipValueWithTag() & 1) == 0)
            return 0;
LABEL_30:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
        v19 = objc_alloc_init(HDCodableSharingSetupInvitationToken);
        objc_msgSend(a1, "addInvitationToken:", v19);
        if (PBReaderPlaceMark() && HDCodableSharingSetupInvitationTokenReadFrom((uint64_t)v19, a2))
        {
          PBReaderRecallMark();
LABEL_29:

          goto LABEL_30;
        }

        return 0;
    }
  }
}

void sub_1B78C78A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__23(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__23(uint64_t a1)
{

}

void sub_1B78C8B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__24(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__24(uint64_t a1)
{

}

uint64_t HDCodableStartWorkoutAppResponseReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  unint64_t v17;
  uint64_t v18;
  void *v19;
  HDCodableError *v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        v20 = objc_alloc_init(HDCodableError);
        objc_storeStrong((id *)(a1 + 8), v20);
        if (!PBReaderPlaceMark() || (HDCodableErrorReadFrom((uint64_t)v20, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else if ((_DWORD)v17 == 2)
      {
        v21 = 0;
        v22 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 28) |= 1u;
        while (1)
        {
          v24 = *v3;
          v25 = *(_QWORD *)(a2 + v24);
          if (v25 == -1 || v25 >= *(_QWORD *)(a2 + *v4))
            break;
          v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v25);
          *(_QWORD *)(a2 + v24) = v25 + 1;
          v23 |= (unint64_t)(v26 & 0x7F) << v21;
          if ((v26 & 0x80) == 0)
            goto LABEL_35;
          v21 += 7;
          v14 = v22++ >= 9;
          if (v14)
          {
            v23 = 0;
            goto LABEL_37;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_35:
        if (*(_BYTE *)(a2 + *v5))
          v23 = 0;
LABEL_37:
        *(_BYTE *)(a1 + 24) = v23 != 0;
      }
      else if ((_DWORD)v17 == 1)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v18;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDBackgroundObservationSupportedForDataTypeCode(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;

  result = 0;
  if (a1 <= 174)
  {
    v3 = a1 - 64;
    if (v3 <= 0x27 && ((1 << v3) & 0x9001730007) != 0)
      return result;
    return 1;
  }
  if ((unint64_t)(a1 - 175) >= 3 && a1 != 218 && a1 != 257)
    return 1;
  return result;
}

void sub_1B78CA42C(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 104));
  _Unwind_Resume(a1);
}

_QWORD *health::TransactionalFile::ReadTransaction::ReadTransaction(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *result = &off_1E6CEBCF8;
  result[1] = a3;
  result[2] = a2;
  result[3] = a4;
  return result;
}

{
  *result = &off_1E6CEBCF8;
  result[1] = a3;
  result[2] = a2;
  result[3] = a4;
  return result;
}

void health::TransactionalFile::_readBufferAtOffset(uint64_t a1, unint64_t a2, _QWORD *a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::mutex *v19;
  _QWORD v20[2];
  uint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  std::string __p;
  void *v26[2];
  void *v27[2];
  _QWORD v28[2];

  v19 = (std::mutex *)(a1 + 416);
  std::mutex::lock((std::mutex *)(a1 + 416));
  v8 = a3[1];
  if (v8)
  {
    v9 = 0;
    v10 = *(unsigned int *)(a1 + 360) + a4;
    do
    {
      health::TransactionalFile::_cacheMutex_pageForOffset(a1, a2, v10, 0, (uint64_t)&v21);
      if (v21 - v10 + v22 >= v8)
        v11 = v8;
      else
        v11 = v21 - v10 + v22;
      if (v11 + v9 > a3[1])
      {
        v12 = *MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v28, "(start + length) <= _length");
        std::string::basic_string[abi:ne180100]<0>(v27, "slice");
        std::string::basic_string[abi:ne180100]<0>(v26, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
        health::FormatString<>((std::string *)"Slice extends beyond end of buffer.", &__p);
        health::_HDAssertImplementation<std::out_of_range>(v12, (uint64_t)v28, (uint64_t)v27, (uint64_t)v26, 61, (uint64_t)&__p);
      }
      health::RawBuffer::RawBuffer(v20, (unsigned __int8 *)(*a3 + v9), v11);
      health::FilePage::slice((health::FilePage *)v28, (uint64_t)&v21, v10, v11);
      health::RawBuffer::copyFrom((health::RawBuffer *)v20, (const health::RawBuffer *)v28);
      v13 = v24;
      if (v24)
      {
        p_shared_owners = (unint64_t *)&v24->__shared_owners_;
        do
          v15 = __ldaxr(p_shared_owners);
        while (__stlxr(v15 - 1, p_shared_owners));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }
      v16 = v23;
      if (v23)
      {
        v17 = (unint64_t *)&v23->__shared_owners_;
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v10 += v11;
      v9 += v11;
      v8 -= v11;
    }
    while (v8);
  }
  std::mutex::unlock(v19);
}

void sub_1B78CBAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;

  if (a35 < 0)
    operator delete(__p);
  if (*(char *)(v35 - 89) < 0)
    operator delete(*(void **)(v35 - 112));
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a14);
  std::mutex::unlock(a9);
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::ReadTransaction::size(health::TransactionalFile::ReadTransaction *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 328) + 48))(*(_QWORD *)(*((_QWORD *)this + 2) + 328));
  v3 = health::WriteAheadLog::maximumCommittedSizeForTransaction((std::mutex *)(*((_QWORD *)this + 2) + 16), *((_QWORD *)this + 1));
  if (v2 <= v3)
    v4 = v3;
  else
    v4 = v2;
  return (v4 - *((_QWORD *)this + 3)) & ~((v4 - *((_QWORD *)this + 3)) >> 63);
}

health::TransactionalFile::WriteTransaction *health::TransactionalFile::WriteTransaction::WriteTransaction(health::TransactionalFile::WriteTransaction *this, health::TransactionalFile *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a4;
  *(_QWORD *)this = &off_1E6CEBD20;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 4) = a2;
  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 41) + 48))(*((_QWORD *)a2 + 41));
  v7 = health::WriteAheadLog::maximumCommittedSizeForTransaction((std::mutex *)(*((_QWORD *)this + 2) + 16), *((_QWORD *)this + 1));
  if (v6 <= v7)
    v8 = v7;
  else
    v8 = v6;
  *((_QWORD *)this + 5) = ((v8 - *((_QWORD *)this + 3)) & ~((v8 - *((_QWORD *)this + 3)) >> 63)) + a4;
  return this;
}

void health::TransactionalFile::_writeBufferAtOffset(health::TransactionalFile *this, unint64_t a2, const health::RawBuffer *a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::mutex *v22;
  _QWORD v23[2];
  std::string __p;
  void *v25[2];
  void *v26[2];
  void *v27[2];
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  std::string v33;
  _QWORD v34[2];
  _QWORD v35[2];
  _QWORD v36[2];

  v8 = *((unsigned int *)this + 90);
  v9 = *((_QWORD *)a3 + 1);
  v22 = (std::mutex *)((char *)this + 416);
  std::mutex::lock((std::mutex *)((char *)this + 416));
  if (v9)
  {
    v10 = 0;
    v11 = v8 + a4;
    v12 = (uint64_t *)MEMORY[0x1E0CB52B0];
    do
    {
      health::TransactionalFile::_cacheMutex_pageForOffset((uint64_t)this, a2, v11, 1, (uint64_t)&v28);
      if (v31)
      {
        v13 = *v12;
        std::string::basic_string[abi:ne180100]<0>(v27, "!page.is_mapped()");
        std::string::basic_string[abi:ne180100]<0>(v26, "_writeBufferAtOffset");
        std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
        health::FormatString<>((std::string *)"Attempt to write to a mapped page.", &__p);
        health::_HDAssertImplementation<std::logic_error>(v13, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 465, (uint64_t)&__p);
      }
      if (v28 - v11 + v29 >= v9)
        v14 = v9;
      else
        v14 = v28 - v11 + v29;
      if (v14 + v10 > *((_QWORD *)a3 + 1))
      {
        v15 = *v12;
        std::string::basic_string[abi:ne180100]<0>(v36, "(start + length) <= _length");
        std::string::basic_string[abi:ne180100]<0>(v35, "slice");
        std::string::basic_string[abi:ne180100]<0>(v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
        health::FormatString<>((std::string *)"Slice extends beyond end of buffer.", &v33);
        health::_HDAssertImplementation<std::out_of_range>(v15, (uint64_t)v36, (uint64_t)v35, (uint64_t)v34, 67, (uint64_t)&v33);
      }
      health::RawBuffer::RawBuffer(v23, (unsigned __int8 *)(*(_QWORD *)a3 + v10), v14);
      health::FilePage::slice((health::FilePage *)v36, (uint64_t)&v28, v11, v14);
      health::RawBuffer::copyFrom((health::RawBuffer *)v36, (const health::RawBuffer *)v23);
      health::TransactionalFile::_cacheMutex_writePage(this, a2, (health::FilePage *)&v28);
      v16 = v32;
      if (v32)
      {
        p_shared_owners = (unint64_t *)&v32->__shared_owners_;
        do
          v18 = __ldaxr(p_shared_owners);
        while (__stlxr(v18 - 1, p_shared_owners));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v19 = v30;
      if (v30)
      {
        v20 = (unint64_t *)&v30->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      v11 += v14;
      v10 += v14;
      v9 -= v14;
    }
    while (v9);
  }
  std::mutex::unlock(v22);
}

void sub_1B78CBEEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  uint64_t v49;

  if (a49 < 0)
    operator delete(__p);
  if (*(char *)(v49 - 137) < 0)
    operator delete(*(void **)(v49 - 160));
  if (*(char *)(v49 - 113) < 0)
    operator delete(*(void **)(v49 - 136));
  if (*(char *)(v49 - 89) < 0)
    operator delete(*(void **)(v49 - 112));
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](a10);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a40);
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::WriteTransaction::size(health::TransactionalFile::WriteTransaction *this)
{
  return *((_QWORD *)this + 5) - *((_QWORD *)this + 3);
}

uint64_t health::TransactionalFile::TransactionalFile(uint64_t a1, __int128 *a2)
{
  _QWORD v3[2];

  v3[0] = 0;
  v3[1] = 0;
  return health::TransactionalFile::TransactionalFile(a1, a2, v3);
}

{
  _QWORD v3[2];

  v3[0] = 0;
  v3[1] = 0;
  return health::TransactionalFile::TransactionalFile(a1, a2, v3);
}

void sub_1B78CC01C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::TransactionalFile(uint64_t a1, __int128 *a2, _QWORD *a3)
{
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  _QWORD *v8;
  size_t v9;
  void **v10;
  const std::string::value_type *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::string *v17;
  __int128 v18;
  int v19;
  _QWORD v21[2];
  void *__p[2];
  char v23;

  if (*a3)
  {
    *(_QWORD *)a1 = *a3;
    v5 = a3[1];
    *(_QWORD *)(a1 + 8) = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    v8 = operator new(0x20uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &off_1E6D0A388;
    *(_QWORD *)(a1 + 8) = v8;
    v8[3] = &off_1E6D0A2A8;
    *(_QWORD *)a1 = v8 + 3;
  }
  if (*((char *)a2 + 23) >= 0)
    v9 = *((unsigned __int8 *)a2 + 23);
  else
    v9 = *((_QWORD *)a2 + 1);
  v10 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v9 + 4);
  if (v23 < 0)
    v10 = (void **)__p[0];
  if (v9)
  {
    if (*((char *)a2 + 23) >= 0)
      v11 = (const std::string::value_type *)a2;
    else
      v11 = *(const std::string::value_type **)a2;
    memmove(v10, v11, v9);
  }
  strcpy((char *)v10 + v9, "-wal");
  v12 = *(std::__shared_weak_count **)(a1 + 8);
  v21[0] = *(_QWORD *)a1;
  v21[1] = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  health::WriteAheadLog::WriteAheadLog(a1 + 16, (__int128 *)__p, v21);
  if (v12)
  {
    v15 = (unint64_t *)&v12->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (v23 < 0)
    operator delete(__p[0]);
  v17 = (std::string *)(a1 + 304);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v17, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v18 = *a2;
    *(_QWORD *)(a1 + 320) = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v17->__r_.__value_.__l.__data_ = v18;
  }
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_BYTE *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = 0x1484B5446;
  *(_DWORD *)(a1 + 360) = 1024;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  v19 = getpagesize();
  *(_QWORD *)(a1 + 392) = v19;
  *(_QWORD *)(a1 + 400) = -(uint64_t)v19;
  *(_DWORD *)(a1 + 408) = 1;
  *(_QWORD *)(a1 + 416) = 850045863;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_QWORD *)(a1 + 472) = 0;
  *(_QWORD *)(a1 + 480) = 16 * v19;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_QWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 528) = 1065353216;
  *(_QWORD *)(a1 + 576) = 0;
  *(_QWORD *)(a1 + 544) = 0;
  *(_QWORD *)(a1 + 536) = 0;
  *(_QWORD *)(a1 + 584) = 850045863;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_QWORD *)(a1 + 640) = 0;
  *(_QWORD *)(a1 + 648) = 1018212795;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_QWORD *)(a1 + 688) = 0;
  *(_QWORD *)(a1 + 704) = 0;
  *(_QWORD *)(a1 + 712) = 0;
  *(_QWORD *)(a1 + 696) = a1 + 704;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_QWORD *)(a1 + 776) = 0;
  *(_QWORD *)(a1 + 784) = 0;
  *(_QWORD *)(a1 + 768) = a1 + 776;
  *(_QWORD *)(a1 + 552) = &off_1E6CEBD70;
  *(_QWORD *)(a1 + 560) = a1;
  *(_QWORD *)(a1 + 576) = a1 + 552;
  return a1;
}

void sub_1B78CC2CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v16;
  health::WriteAheadLog *v17;

  health::WriteAheadLog::~WriteAheadLog(v17);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v16);
  _Unwind_Resume(a1);
}

void sub_1B78CC33C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::open(uint64_t *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned int padding;
  std::__shared_weak_count *size;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint32_t v20;
  uint64_t v21;
  std::string::size_type v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  std::runtime_error *exception;
  std::string v35;
  void *v36[2];
  void *v37[2];
  void *v38[2];
  std::string v39;
  void *v40[2];
  void *v41[2];
  void *v42[2];
  std::string __p;
  void *v44[2];
  void *v45[2];
  void *v46[2];
  uint64_t v47;
  std::string __token;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD v52[3];
  _QWORD *v53;
  _QWORD v54[3];
  _QWORD *v55;
  _QWORD v56[3];
  _QWORD *v57;
  std::random_device v58[2];
  std::string *p_token;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (a1[41])
  {
    v4 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v46, "!isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v45, "open");
    std::string::basic_string[abi:ne180100]<0>(v44, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"File is already open.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v4, (uint64_t)v46, (uint64_t)v45, (uint64_t)v44, 101, (uint64_t)&__p);
  }
  v5 = 0;
  v6 = 0;
  v7 = a1 + 41;
  v8 = *a1;
  *(_QWORD *)&v58[0].__padding_ = 0x100000000;
  LODWORD(p_token) = 2;
  do
  {
    padding = v58[v5].__padding_;
    if (padding >= 4)
      std::__throw_out_of_range[abi:ne180100]("bitset set argument out of range");
    v6 |= 1 << padding;
    ++v5;
  }
  while (v5 != 3);
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v8 + 16))(&__token);
  std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100]((uint64_t)(a1 + 41), (__int128 *)&__token);
  size = (std::__shared_weak_count *)__token.__r_.__value_.__l.__size_;
  if (__token.__r_.__value_.__l.__size_)
  {
    v11 = (unint64_t *)(__token.__r_.__value_.__l.__size_ + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }
  if (!*v7)
  {
    v13 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v42, "isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v41, "open");
    std::string::basic_string[abi:ne180100]<0>(v40, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"File failed to open as expected.", &v39);
    health::_HDAssertImplementation<health::transaction_error>(v13, (uint64_t)v42, (uint64_t)v41, (uint64_t)v40, 106, (uint64_t)&v39);
  }
  if (a2 == 2)
    *((_DWORD *)a1 + 102) = 0;
  if ((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v7 + 48))(*v7))
  {
    v14 = a1[41];
    v49 = 0;
    v50 = 36;
    *(_QWORD *)&v58[0].__padding_ = &__token;
    p_token = &__token;
    v60 = 36;
    v15 = (*(uint64_t (**)(uint64_t, _QWORD, std::string *, uint64_t))(*(_QWORD *)v14 + 32))(v14, 0, &__token, 36);
    LODWORD(v47) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)v58, &v47);
    *((_DWORD *)a1 + 88) = v47;
    LODWORD(v47) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)v58, &v47);
    *((_DWORD *)a1 + 89) = v47;
    LODWORD(v47) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)v58, &v47);
    *((_DWORD *)a1 + 90) = v47;
    v47 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v58, &v47);
    a1[46] = v47;
    v47 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v58, &v47);
    a1[47] = v47;
    v47 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v58, &v47);
    a1[48] = v47;
    v16 = v49;
    v49 = 0;
    if (v16)
      MEMORY[0x1BCCAC47C](v16, 0x1000C8077774924);
    if (v15 != 36)
    {
      v17 = *MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v38, "headerBytes == _header.serializedSize()");
      std::string::basic_string[abi:ne180100]<0>(v37, "open");
      std::string::basic_string[abi:ne180100]<0>(v36, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
      health::FormatString<>((std::string *)"Failed to read full file header.", &v35);
      health::_HDAssertImplementation<health::file_access_error>(v17, (uint64_t)v38, (uint64_t)v37, (uint64_t)v36, 118, (uint64_t)&v35);
    }
    if (*((_DWORD *)a1 + 89) == 1)
    {
      if (*((_DWORD *)a1 + 88) == 1212896326)
      {
        health::WriteAheadLog::open((std::mutex *)(a1 + 2), a1[47]);
        v18 = a1[48];
        v19 = a1[49];
        if (v18 == v19)
        {
          if (a2 == 1)
          {
LABEL_35:
            __token.__r_.__value_.__s.__data_[0] = 0;
            v27 = a1[47];
            v57 = v56;
            v54[0] = &off_1E6CEBED0;
            v54[1] = a1;
            v54[2] = &__token;
            v55 = v54;
            v56[0] = &off_1E6CEBE40;
            v52[0] = &off_1E6CEBF60;
            v52[1] = a1;
            v53 = v52;
            health::WriteAheadLog::checkpoint((std::mutex *)(a1 + 2), v27, (uint64_t)v56, (uint64_t)v54, (uint64_t)v52);
            v28 = v53;
            if (v53 == v52)
            {
              v29 = 4;
              v28 = v52;
            }
            else
            {
              if (!v53)
                goto LABEL_40;
              v29 = 5;
            }
            (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_40:
            v30 = v55;
            if (v55 == v54)
            {
              v31 = 4;
              v30 = v54;
            }
            else
            {
              if (!v55)
                goto LABEL_45;
              v31 = 5;
            }
            (*(void (**)(void))(*v30 + 8 * v31))();
LABEL_45:
            v32 = v57;
            if (v57 == v56)
            {
              v33 = 4;
              v32 = v56;
            }
            else
            {
              if (!v57)
                goto LABEL_50;
              v33 = 5;
            }
            (*(void (**)(void))(*v32 + 8 * v33))();
LABEL_50:
            if (__token.__r_.__value_.__s.__data_[0])
              return 2;
            else
              return 1;
          }
        }
        else
        {
          if (a2 != 2 || !v18)
          {
            a1[48] = v19;
            goto LABEL_35;
          }
          health::TransactionalFile::_configurePageSize((health::TransactionalFile *)a1, v18);
        }
        return 3;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Transactional file header has incorrect magic word.");
    }
    else
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid header version for transactional file.");
    }
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC2E8;
  }
  health::WriteAheadLog::discardLog((std::mutex *)(a1 + 2));
  std::string::basic_string[abi:ne180100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(v58, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__token.__r_.__value_.__l.__data_);
  v20 = arc4random();
  v21 = 1;
  v22 = v20;
  do
  {
    v22 = v21 + 0x5851F42D4C957F2DLL * (v22 ^ (v22 >> 62));
    __token.__r_.__value_.__r.__words[v21++] = v22;
  }
  while (v21 != 312);
  v23 = v51 ^ ((__token.__r_.__value_.__r.__words[1] & 0x7FFFFFFE | (unint64_t)(v20 & 0x80000000)) >> 1) ^ ((uint64_t)(__token.__r_.__value_.__l.__size_ << 63) >> 63) & 0xB5026F5AA96619E9;
  v24 = (((v23 >> 29) & 0x5555555555555555 ^ v23) << 17) & 0x71D67FFFEDA60000 ^ (v23 >> 29) & 0x5555555555555555 ^ v23;
  v25 = a1[49];
  a1[47] = (v24 << 37) & 0xFFF7EEE000000000 ^ v24 ^ (((v24 << 37) & 0xFFF7EEE000000000 ^ v24) >> 43);
  a1[48] = v25;
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(a1[41], (uint64_t)(a1 + 44));
  (*(void (**)(_QWORD))(*(_QWORD *)*v7 + 16))(*v7);
  health::WriteAheadLog::open((std::mutex *)(a1 + 2), a1[47]);
  std::random_device::~random_device(v58);
  return 0;
}

void sub_1B78CCA68(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  if (!a2)
    _Unwind_Resume(a1);
  v6 = *(_QWORD **)(v4 - 152);
  if (v6 == (_QWORD *)(v4 - 176))
  {
    v7 = 4;
    v6 = (_QWORD *)(v4 - 176);
  }
  else
  {
    if (!v6)
      goto LABEL_7;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_7:
  v8 = *(_QWORD **)(v4 - 120);
  if (v8 == (_QWORD *)(v4 - 144))
  {
    v9 = 4;
    v8 = (_QWORD *)(v4 - 144);
  }
  else
  {
    if (!v8)
      goto LABEL_12;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_12:
  v10 = *(_QWORD **)(v4 - 88);
  if (v10 == (_QWORD *)(v4 - 112))
  {
    v11 = 4;
    v10 = (_QWORD *)(v4 - 112);
  }
  else
  {
    if (!v10)
      goto LABEL_17;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_17:
  __cxa_begin_catch(a1);
  *(_QWORD *)(v4 - 80) = 0;
  *(_QWORD *)(v4 - 72) = 0;
  std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100](v3, (__int128 *)(v4 - 80));
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v4 - 80);
  health::WriteAheadLog::reset((std::mutex *)(v2 + 16));
  __cxa_rethrow();
}

void sub_1B78CCCE4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B78CCCF0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void health::_HDAssertImplementation<health::transaction_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  char **v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  std::runtime_error *exception;
  char **v34;
  std::string *v35;
  std::string::size_type size;
  _QWORD *v37;
  void *__p[2];
  char v39;
  std::string v40;
  uint64_t v41;
  uint64_t v42;
  void *v43[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)v43 = 0u;
  v44 = 0u;
  LODWORD(v10) = backtrace(v43, 20);
  v11 = backtrace_symbols(v43, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Critical Error: ", 16);
  v13 = *(char *)(a6 + 23);
  if (v13 >= 0)
    v14 = a6;
  else
    v14 = *(_QWORD *)a6;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a6 + 23);
  else
    v15 = *(_QWORD *)(a6 + 8);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Failed assertion '", 18);
  v18 = *(char *)(a2 + 23);
  if (v18 >= 0)
    v19 = a2;
  else
    v19 = *(_QWORD *)a2;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(a2 + 23);
  else
    v20 = *(_QWORD *)(a2 + 8);
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  v23 = *(char *)(a3 + 23);
  if (v23 >= 0)
    v24 = a3;
  else
    v24 = *(_QWORD *)a3;
  if (v23 >= 0)
    v25 = *(unsigned __int8 *)(a3 + 23);
  else
    v25 = *(_QWORD *)(a3 + 8);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  v28 = *(char *)(a4 + 23);
  if (v28 >= 0)
    v29 = a4;
  else
    v29 = *(_QWORD *)a4;
  if (v28 >= 0)
    v30 = *(unsigned __int8 *)(a4 + 23);
  else
    v30 = *(_QWORD *)(a4 + 8);
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  v32 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  v10 = (int)v10;
  if ((_DWORD)v10)
  {
    v34 = v11;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, *v34);
      health::HDDemangleBacktraceLine((uint64_t)__p, (unint64_t)&v40);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v35 = &v40;
      else
        v35 = (std::string *)v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      else
        size = v40.__r_.__value_.__l.__size_;
      v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)v35, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
      if (v39 < 0)
        operator delete(__p[0]);
      ++v34;
      --v10;
    }
    while (v10);
  }
  free(v11);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v42, &v40);
  std::runtime_error::runtime_error(exception, &v40);
  exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC328;
}

void sub_1B78CCF70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0)
    operator delete(__p);
  a21 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a21 + *(_QWORD *)(a21 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a22 = MEMORY[0x1E0DE4FB8] + 16;
  if (a35 < 0)
    operator delete(a30);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&a38);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void health::_HDAssertImplementation<health::file_access_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  char **v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  std::runtime_error *exception;
  char **v34;
  std::string *v35;
  std::string::size_type size;
  _QWORD *v37;
  void *__p[2];
  char v39;
  std::string v40;
  uint64_t v41;
  uint64_t v42;
  void *v43[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)v43 = 0u;
  v44 = 0u;
  LODWORD(v10) = backtrace(v43, 20);
  v11 = backtrace_symbols(v43, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Critical Error: ", 16);
  v13 = *(char *)(a6 + 23);
  if (v13 >= 0)
    v14 = a6;
  else
    v14 = *(_QWORD *)a6;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a6 + 23);
  else
    v15 = *(_QWORD *)(a6 + 8);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Failed assertion '", 18);
  v18 = *(char *)(a2 + 23);
  if (v18 >= 0)
    v19 = a2;
  else
    v19 = *(_QWORD *)a2;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(a2 + 23);
  else
    v20 = *(_QWORD *)(a2 + 8);
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  v23 = *(char *)(a3 + 23);
  if (v23 >= 0)
    v24 = a3;
  else
    v24 = *(_QWORD *)a3;
  if (v23 >= 0)
    v25 = *(unsigned __int8 *)(a3 + 23);
  else
    v25 = *(_QWORD *)(a3 + 8);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  v28 = *(char *)(a4 + 23);
  if (v28 >= 0)
    v29 = a4;
  else
    v29 = *(_QWORD *)a4;
  if (v28 >= 0)
    v30 = *(unsigned __int8 *)(a4 + 23);
  else
    v30 = *(_QWORD *)(a4 + 8);
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  v32 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  v10 = (int)v10;
  if ((_DWORD)v10)
  {
    v34 = v11;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, *v34);
      health::HDDemangleBacktraceLine((uint64_t)__p, (unint64_t)&v40);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v35 = &v40;
      else
        v35 = (std::string *)v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      else
        size = v40.__r_.__value_.__l.__size_;
      v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)v35, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
      if (v39 < 0)
        operator delete(__p[0]);
      ++v34;
      --v10;
    }
    while (v10);
  }
  free(v11);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v42, &v40);
  std::runtime_error::runtime_error(exception, &v40);
  exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEBE18;
}

void sub_1B78CD314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0)
    operator delete(__p);
  a21 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a21 + *(_QWORD *)(a21 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a22 = MEMORY[0x1E0DE4FB8] + 16;
  if (a35 < 0)
    operator delete(a30);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&a38);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::_configurePageSize(health::TransactionalFile *this, unint64_t a2)
{
  uint8x8_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  std::string __p;
  void *v14[2];
  void *v15[2];
  void *v16[2];
  unint64_t v17;

  if (a2 < 2 || (v4 = (uint8x8_t)vcnt_s8((int8x8_t)a2), v4.i16[0] = vaddlv_u8(v4), v4.u32[0] >= 2uLL))
  {
    v5 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v16, "pageSize > 1 && !(pageSize & (pageSize - 1))");
    std::string::basic_string[abi:ne180100]<0>(v15, "_configurePageSize");
    std::string::basic_string[abi:ne180100]<0>(v14, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"pageSize must be a power of 2", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v5, (uint64_t)v16, (uint64_t)v15, (uint64_t)v14, 408, (uint64_t)&__p);
  }
  if (*((_QWORD *)this + 49) != a2)
  {
    std::mutex::lock((std::mutex *)((char *)this + 416));
    v6 = *((_QWORD *)this + 60);
    *((_QWORD *)this + 60) = 0;
    v7 = *((_QWORD *)this + 68);
    if (v7)
    {
      while (1)
      {
        v8 = *((_QWORD *)this + 61);
        if (!v8)
          goto LABEL_14;
        v9 = *(_QWORD *)(v7 + 88);
        if (!*(_DWORD *)v7)
          goto LABEL_11;
        v10 = *((_QWORD *)this + 72);
        if (!v10)
          goto LABEL_11;
        v17 = *(_QWORD *)(v7 + 8);
        if ((*(unsigned int (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(_QWORD *)v10 + 48))(v10, &v17, v7 + 24, v7 + 32))
        {
          break;
        }
LABEL_13:
        v7 = v9;
        if (!v9)
          goto LABEL_14;
      }
      v8 = *((_QWORD *)this + 61);
LABEL_11:
      *((_QWORD *)this + 61) = v8 - *(_QWORD *)(v7 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)this + 480, v7);
      v11 = *(_QWORD *)(v7 + 24);
      v17 = v11;
      v12 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)this + 62, v11, &v17);
      health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(v12 + 3, v7);
      if (v12[4] == v12[3])
        std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>((_QWORD *)this + 62, v11);
      goto LABEL_13;
    }
LABEL_14:
    *((_QWORD *)this + 60) = v6;
    *((_QWORD *)this + 49) = a2;
    *((_QWORD *)this + 50) = -(uint64_t)a2;
    std::mutex::unlock((std::mutex *)((char *)this + 416));
  }
}

void sub_1B78CD5EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(exception_object);
}

void health::TransactionalFile::invalidate(health::TransactionalFile *this)
{
  pthread_t v2;
  health::TransactionalFile *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 v11;
  std::string v12;
  void *v13[2];
  void *v14[2];
  void *v15[2];
  std::string __p;
  void *v17[2];
  _QWORD v18[2];
  _QWORD v19[2];
  std::unique_lock<std::mutex> __lk;

  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 584);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 584));
  v2 = pthread_self();
  v3 = (health::TransactionalFile *)std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>((uint64_t)this + 696, (unint64_t)v2);
  v4 = (uint64_t *)MEMORY[0x1E0CB52B0];
  if ((health::TransactionalFile *)((char *)this + 704) != v3)
  {
    v5 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v19, "_activeReadTransactions.find(threadID) == _activeReadTransactions.end()");
    std::string::basic_string[abi:ne180100]<0>(v18, "invalidate");
    std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"Attempt to invalidate the transactional file from within a read transaction.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v5, (uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 183, (uint64_t)&__p);
  }
  if ((_QWORD *)((char *)this + 776) != std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>((uint64_t)this + 768, (unint64_t)v2))
  {
    v6 = *v4;
    std::string::basic_string[abi:ne180100]<0>(v15, "_activeWriteTransactions.find(threadID) == _activeWriteTransactions.end()");
    std::string::basic_string[abi:ne180100]<0>(v14, "invalidate");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"Attempt to invalidate the transactional file from within a write transaction.", &v12);
    health::_HDAssertImplementation<std::logic_error>(v6, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 184, (uint64_t)&v12);
  }
  if (!*((_BYTE *)this + 344))
  {
    *((_BYTE *)this + 344) = 1;
    while (*((_QWORD *)this + 89) || *((_QWORD *)this + 98))
      std::condition_variable::wait((std::condition_variable *)((char *)this + 648), &__lk);
    v7 = *((_QWORD *)this + 41);
    if (v7)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 64))(v7);
      v11 = 0uLL;
      std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100]((uint64_t)this + 328, &v11);
      v8 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
      if (*((_QWORD *)&v11 + 1))
      {
        v9 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
        do
          v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
      health::WriteAheadLog::reset((std::mutex *)((char *)this + 16));
    }
  }
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
}

void sub_1B78CD8D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  std::mutex *v46;

  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  if (a34 < 0)
    operator delete(a29);
  std::mutex::unlock(v46);
  _Unwind_Resume(a1);
}

void health::_HDAssertImplementation<std::logic_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  char **v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  std::logic_error *exception;
  char **v34;
  std::string *v35;
  std::string::size_type size;
  _QWORD *v37;
  void *__p[2];
  char v39;
  std::string v40;
  uint64_t v41;
  uint64_t v42;
  void *v43[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)v43 = 0u;
  v44 = 0u;
  LODWORD(v10) = backtrace(v43, 20);
  v11 = backtrace_symbols(v43, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Critical Error: ", 16);
  v13 = *(char *)(a6 + 23);
  if (v13 >= 0)
    v14 = a6;
  else
    v14 = *(_QWORD *)a6;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a6 + 23);
  else
    v15 = *(_QWORD *)(a6 + 8);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Failed assertion '", 18);
  v18 = *(char *)(a2 + 23);
  if (v18 >= 0)
    v19 = a2;
  else
    v19 = *(_QWORD *)a2;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(a2 + 23);
  else
    v20 = *(_QWORD *)(a2 + 8);
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  v23 = *(char *)(a3 + 23);
  if (v23 >= 0)
    v24 = a3;
  else
    v24 = *(_QWORD *)a3;
  if (v23 >= 0)
    v25 = *(unsigned __int8 *)(a3 + 23);
  else
    v25 = *(_QWORD *)(a3 + 8);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  v28 = *(char *)(a4 + 23);
  if (v28 >= 0)
    v29 = a4;
  else
    v29 = *(_QWORD *)a4;
  if (v28 >= 0)
    v30 = *(unsigned __int8 *)(a4 + 23);
  else
    v30 = *(_QWORD *)(a4 + 8);
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  v32 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  v10 = (int)v10;
  if ((_DWORD)v10)
  {
    v34 = v11;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, *v34);
      health::HDDemangleBacktraceLine((uint64_t)__p, (unint64_t)&v40);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v35 = &v40;
      else
        v35 = (std::string *)v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      else
        size = v40.__r_.__value_.__l.__size_;
      v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)v35, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
      if (v39 < 0)
        operator delete(__p[0]);
      ++v34;
      --v10;
    }
    while (v10);
  }
  free(v11);
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v42, &v40);
  std::logic_error::logic_error(exception, &v40);
  __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
}

void sub_1B78CDC08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0)
    operator delete(__p);
  a21 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a21 + *(_QWORD *)(a21 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a22 = MEMORY[0x1E0DE4FB8] + 16;
  if (a35 < 0)
    operator delete(a30);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&a38);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::setCacheSize(health::TransactionalFile *this, unint64_t a2)
{
  std::mutex *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  std::string __p;
  void *v19[2];
  void *v20[2];
  void *v21[2];
  unint64_t v22;

  v4 = (std::mutex *)((char *)this + 416);
  std::mutex::lock((std::mutex *)((char *)this + 416));
  if (!a2)
  {
    v5 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v21, "maxSize > 0");
    std::string::basic_string[abi:ne180100]<0>(v20, "setMaxSize");
    std::string::basic_string[abi:ne180100]<0>(v19, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDTransactionalCache.hpp");
    health::FormatString<>((std::string *)"Cache max size must be greater than 0.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v5, (uint64_t)v21, (uint64_t)v20, (uint64_t)v19, 30, (uint64_t)&__p);
  }
  *((_QWORD *)this + 60) = a2;
  v6 = *((_QWORD *)this + 68);
  if (v6)
  {
    do
    {
      v7 = *((_QWORD *)this + 61);
      if (v7 <= a2)
        break;
      v8 = *(_QWORD *)(v6 + 88);
      if (!*(_DWORD *)v6)
      {
        *((_QWORD *)this + 61) = v7 - *(_QWORD *)(v6 + 16);
        health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)this + 480, v6);
        v9 = *(_QWORD *)(v6 + 24);
        v22 = v9;
        v10 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)this + 62, v9, &v22);
        health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(v10 + 3, v6);
        if (v10[4] == v10[3])
          std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>((_QWORD *)this + 62, v9);
      }
      v6 = v8;
    }
    while (v8);
    v11 = *((_QWORD *)this + 68);
    if (v11)
    {
      v12 = *((_QWORD *)this + 60);
      while (1)
      {
        v13 = *((_QWORD *)this + 61);
        if (v13 <= v12)
          goto LABEL_19;
        v14 = *(_QWORD *)(v11 + 88);
        if (!*(_DWORD *)v11)
          goto LABEL_16;
        v15 = *((_QWORD *)this + 72);
        if (!v15)
          goto LABEL_16;
        v22 = *(_QWORD *)(v11 + 8);
        if ((*(unsigned int (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(_QWORD *)v15 + 48))(v15, &v22, v11 + 24, v11 + 32))
        {
          break;
        }
LABEL_18:
        v11 = v14;
        if (!v14)
          goto LABEL_19;
      }
      v13 = *((_QWORD *)this + 61);
LABEL_16:
      *((_QWORD *)this + 61) = v13 - *(_QWORD *)(v11 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)this + 480, v11);
      v16 = *(_QWORD *)(v11 + 24);
      v22 = v16;
      v17 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)this + 62, v16, &v22);
      health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(v17 + 3, v11);
      if (v17[4] == v17[3])
        std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>((_QWORD *)this + 62, v16);
      goto LABEL_18;
    }
  }
LABEL_19:
  std::mutex::unlock(v4);
}

void sub_1B78CDF28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  std::mutex *v33;

  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  std::mutex::unlock(v33);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::readTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  pthread_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  _opaque_pthread_t *v11;
  char v12;
  BOOL v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  std::runtime_error *exception;
  std::string __p;
  void *v21[2];
  void *v22[2];
  void *v23[2];
  std::unique_lock<std::mutex> v24;
  pthread_t v25;
  _BYTE v26[24];
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = pthread_self();
  v25 = v4;
  v24.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 584);
  v24.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 584));
  if (*(_BYTE *)(a1 + 344))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Read transaction attempted after file was closed.");
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC328;
  }
  if (!*(_QWORD *)(a1 + 328))
  {
    v5 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v23, "isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v22, "readTransactionWithLambda");
    std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"File has not yet been opened.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v5, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 220, (uint64_t)&__p);
  }
  v6 = std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(a1 + 696, (unint64_t)v4);
  if ((_QWORD *)(a1 + 704) != v6)
  {
    v7 = v6;
    std::unique_lock<std::mutex>::unlock(&v24);
    v8 = *(_QWORD *)(a2 + 24);
    if (!v8)
      std::__throw_bad_function_call[abi:ne180100]();
    goto LABEL_6;
  }
  v10 = *(_QWORD **)(a1 + 776);
  if (!v10)
    goto LABEL_30;
  v7 = (_QWORD *)(a1 + 776);
  do
  {
    v11 = (_opaque_pthread_t *)v10[4];
    if (v11)
    {
      if (!v4 || v11 != v4)
      {
        if (v11 >= v4)
          v12 = 1;
        else
          v12 = -1;
        goto LABEL_18;
      }
    }
    else if (v4)
    {
      v12 = -1;
      goto LABEL_18;
    }
    v12 = 0;
LABEL_18:
    v13 = (v12 & 0x80) == 0;
    if (v12 < 0)
      v14 = v10 + 1;
    else
      v14 = v10;
    if (v13)
      v7 = v10;
    v10 = (_QWORD *)*v14;
  }
  while (*v14);
  if ((_QWORD *)(a1 + 776) == v7)
    goto LABEL_30;
  v15 = v7[4];
  if (!v4)
  {
    if (!v15)
      goto LABEL_27;
    goto LABEL_30;
  }
  if (v15 > (unint64_t)v4)
  {
LABEL_30:
    v9 = 1;
    goto LABEL_31;
  }
LABEL_27:
  std::unique_lock<std::mutex>::unlock(&v24);
  v8 = *(_QWORD *)(a2 + 24);
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
LABEL_6:
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 48))(v8, v7[5]);
  v9 = 0;
LABEL_31:
  if (v24.__owns_)
    std::mutex::unlock(v24.__m_);
  if (v9)
  {
    v16 = operator new(0x20uLL);
    *v16 = &off_1E6CEBFE0;
    v16[1] = a1;
    v16[2] = &v25;
    v16[3] = a2;
    v27 = v16;
    health::WriteAheadLog::runReadTransaction(a1 + 16, (uint64_t)v26);
    v17 = v27;
    if (v27 == v26)
    {
      v18 = 4;
      v17 = v26;
LABEL_38:
      (*(void (**)(void))(*v17 + 8 * v18))();
    }
    else if (v27)
    {
      v18 = 5;
      goto LABEL_38;
    }
  }
}

void sub_1B78CE288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,std::mutex *a33,char a34)
{
  if (a34)
    std::mutex::unlock(a33);
  _Unwind_Resume(exception_object);
}

BOOL health::TransactionalFile::_transactionMutex_waitForAvailableWriteTransaction(uint64_t a1, std::unique_lock<std::mutex> *a2)
{
  _opaque_pthread_t *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  int64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  char *v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  void *v55;
  std::__thread_id v56;
  _BOOL8 result;
  std::__thread_id v58;
  const void **v59;
  void *v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  uint64_t i;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  unint64_t v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  uint64_t *v87;
  char *v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  void *v93;
  char *v94;
  uint64_t v95;
  char *v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  int64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  char *v111;
  uint64_t *v112;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  void *v117;

  v4 = pthread_self();
  v5 = *(char **)(a1 + 736);
  v6 = *(char **)(a1 + 728);
  v7 = v5 - v6;
  if (v5 == v6)
    v8 = 0;
  else
    v8 = ((v5 - v6) << 6) - 1;
  v9 = *(_QWORD *)(a1 + 752);
  v10 = *(_QWORD *)(a1 + 760);
  v11 = v10 + v9;
  if (v8 == v10 + v9)
  {
    if (v9 < 0x200)
    {
      v26 = v7 >> 3;
      v27 = *(char **)(a1 + 744);
      v28 = *(char **)(a1 + 720);
      if (v7 >> 3 >= (unint64_t)((v27 - v28) >> 3))
      {
        if (v27 == v28)
          v31 = 1;
        else
          v31 = (v27 - v28) >> 2;
        v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v31);
        v34 = v33;
        v35 = operator new(0x1000uLL);
        v36 = &v32[8 * v26];
        v37 = v34;
        v38 = &v32[8 * v34];
        if (v26 == v37)
        {
          v39 = 8 * v26;
          v40 = (uint64_t *)(a1 + 728);
          if (v7 < 1)
          {
            v60 = v35;
            v61 = v39 >> 2;
            if (v5 == v6)
              v62 = 1;
            else
              v62 = v61;
            v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v62);
            v36 = &v63[8 * (v62 >> 2)];
            v38 = &v63[8 * v64];
            if (v32)
              operator delete(v32);
            v32 = v63;
            v35 = v60;
          }
          else
          {
            v41 = v39 >> 3;
            if (v41 >= -1)
              v42 = v41 + 1;
            else
              v42 = v41 + 2;
            v36 -= 8 * (v42 >> 1);
          }
        }
        else
        {
          v40 = (uint64_t *)(a1 + 728);
        }
        *(_QWORD *)v36 = v35;
        v65 = v36 + 8;
        v66 = *(_QWORD *)(a1 + 736);
        for (i = *(_QWORD *)(a1 + 728); v66 != i; i = *v40)
        {
          if (v36 == v32)
          {
            if (v65 >= v38)
            {
              if (v38 == v32)
                v72 = 1;
              else
                v72 = (v38 - v32) >> 2;
              v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v72);
              v75 = v73;
              v36 = &v73[(2 * v72 + 6) & 0xFFFFFFFFFFFFFFF8];
              v76 = v65 - v32;
              v43 = v65 == v32;
              v65 = v36;
              if (!v43)
              {
                v65 = &v36[v76 & 0xFFFFFFFFFFFFFFF8];
                v77 = 8 * (v76 >> 3);
                v78 = v36;
                v79 = (uint64_t *)v32;
                do
                {
                  v80 = *v79++;
                  *(_QWORD *)v78 = v80;
                  v78 += 8;
                  v77 -= 8;
                }
                while (v77);
              }
              v38 = &v73[8 * v74];
              if (v32)
                operator delete(v32);
              v32 = v75;
            }
            else
            {
              v68 = (v38 - v65) >> 3;
              if (v68 >= -1)
                v69 = v68 + 1;
              else
                v69 = v68 + 2;
              v70 = v69 >> 1;
              v36 = &v32[8 * (v69 >> 1)];
              v71 = v32;
              if (v65 != v32)
              {
                memmove(v36, v32, v65 - v32);
                v71 = v65;
              }
              v65 = &v71[8 * v70];
            }
          }
          v81 = *(_QWORD *)(v66 - 8);
          v66 -= 8;
          *((_QWORD *)v36 - 1) = v81;
          v36 -= 8;
        }
        v82 = *(void **)(a1 + 720);
        *(_QWORD *)(a1 + 720) = v32;
        *(_QWORD *)(a1 + 728) = v36;
        *(_QWORD *)(a1 + 736) = v65;
        *(_QWORD *)(a1 + 744) = v38;
        if (v82)
          operator delete(v82);
        goto LABEL_37;
      }
      v29 = operator new(0x1000uLL);
      v30 = v29;
      if (v27 == v5)
      {
        if (v6 == v28)
        {
          if (v5 == v6)
            v83 = 1;
          else
            v83 = (v27 - v6) >> 2;
          v84 = 2 * v83;
          v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v83);
          v6 = &v85[(v84 + 6) & 0xFFFFFFFFFFFFFFF8];
          v87 = *(uint64_t **)(a1 + 728);
          v88 = v6;
          v89 = *(_QWORD *)(a1 + 736) - (_QWORD)v87;
          v59 = (const void **)(a1 + 728);
          if (v89)
          {
            v88 = &v6[v89 & 0xFFFFFFFFFFFFFFF8];
            v90 = 8 * (v89 >> 3);
            v91 = &v85[(v84 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              v92 = *v87++;
              *(_QWORD *)v91 = v92;
              v91 += 8;
              v90 -= 8;
            }
            while (v90);
          }
          v93 = *(void **)(a1 + 720);
          *(_QWORD *)(a1 + 720) = v85;
          *(_QWORD *)(a1 + 728) = v6;
          *(_QWORD *)(a1 + 736) = v88;
          *(_QWORD *)(a1 + 744) = &v85[8 * v86];
          if (v93)
          {
            operator delete(v93);
            v6 = *(char **)(a1 + 728);
          }
        }
        else
        {
          v59 = (const void **)(a1 + 728);
        }
        *((_QWORD *)v6 - 1) = v30;
        v94 = *(char **)(a1 + 728);
        *(_QWORD *)(a1 + 728) = v94 - 8;
        v95 = *((_QWORD *)v94 - 1);
        *(_QWORD *)(a1 + 728) = v94;
        v96 = *(char **)(a1 + 736);
        if (v96 == *(char **)(a1 + 744))
        {
          v97 = *(_QWORD *)(a1 + 720);
          v98 = (uint64_t)&v94[-v97];
          if ((unint64_t)v94 <= v97)
          {
            v106 = (uint64_t)&v96[-v97];
            v43 = v106 == 0;
            v107 = v106 >> 2;
            if (v43)
              v108 = 1;
            else
              v108 = v107;
            v109 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v108);
            v111 = &v109[8 * (v108 >> 2)];
            v112 = *(uint64_t **)(a1 + 728);
            v96 = v111;
            v113 = *(_QWORD *)(a1 + 736) - (_QWORD)v112;
            if (v113)
            {
              v96 = &v111[v113 & 0xFFFFFFFFFFFFFFF8];
              v114 = 8 * (v113 >> 3);
              v115 = &v109[8 * (v108 >> 2)];
              do
              {
                v116 = *v112++;
                *(_QWORD *)v115 = v116;
                v115 += 8;
                v114 -= 8;
              }
              while (v114);
            }
            v117 = *(void **)(a1 + 720);
            *(_QWORD *)(a1 + 720) = v109;
            *(_QWORD *)(a1 + 728) = v111;
            *(_QWORD *)(a1 + 736) = v96;
            *(_QWORD *)(a1 + 744) = &v109[8 * v110];
            if (v117)
            {
              operator delete(v117);
              v96 = *(char **)(a1 + 736);
            }
          }
          else
          {
            v99 = v98 >> 3;
            v18 = v98 >> 3 < -1;
            v100 = (v98 >> 3) + 2;
            if (v18)
              v101 = v100;
            else
              v101 = v99 + 1;
            v102 = -(v101 >> 1);
            v103 = v101 >> 1;
            v104 = &v94[-8 * v103];
            v105 = v96 - v94;
            if (v96 != v94)
            {
              memmove(&v94[-8 * v103], v94, v96 - v94);
              v94 = (char *)*v59;
            }
            v96 = &v104[v105];
            *(_QWORD *)(a1 + 736) = &v104[v105];
            *(_QWORD *)(a1 + 728) = &v94[8 * v102];
          }
        }
        *(_QWORD *)v96 = v95;
      }
      else
      {
        *(_QWORD *)v5 = v29;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 752) = v9 - 512;
      v14 = *(_QWORD *)v6;
      v12 = v6 + 8;
      v13 = v14;
      *(_QWORD *)(a1 + 728) = v12;
      if (v5 == *(char **)(a1 + 744))
      {
        v15 = *(_QWORD *)(a1 + 720);
        v16 = (uint64_t)&v12[-v15];
        if ((unint64_t)v12 <= v15)
        {
          v44 = (uint64_t)&v5[-v15];
          v43 = v44 == 0;
          v45 = v44 >> 2;
          if (v43)
            v46 = 1;
          else
            v46 = v45;
          v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v46);
          v49 = &v47[8 * (v46 >> 2)];
          v50 = *(uint64_t **)(a1 + 728);
          v5 = v49;
          v51 = *(_QWORD *)(a1 + 736) - (_QWORD)v50;
          if (v51)
          {
            v5 = &v49[v51 & 0xFFFFFFFFFFFFFFF8];
            v52 = 8 * (v51 >> 3);
            v53 = &v47[8 * (v46 >> 2)];
            do
            {
              v54 = *v50++;
              *(_QWORD *)v53 = v54;
              v53 += 8;
              v52 -= 8;
            }
            while (v52);
          }
          v55 = *(void **)(a1 + 720);
          *(_QWORD *)(a1 + 720) = v47;
          *(_QWORD *)(a1 + 728) = v49;
          *(_QWORD *)(a1 + 736) = v5;
          *(_QWORD *)(a1 + 744) = &v47[8 * v48];
          if (v55)
          {
            operator delete(v55);
            v5 = *(char **)(a1 + 736);
          }
        }
        else
        {
          v17 = v16 >> 3;
          v18 = v16 >> 3 < -1;
          v19 = (v16 >> 3) + 2;
          if (v18)
            v20 = v19;
          else
            v20 = v17 + 1;
          v21 = -(v20 >> 1);
          v22 = v20 >> 1;
          v23 = &v12[-8 * v22];
          v24 = v5 - v12;
          if (v5 != v12)
          {
            memmove(&v12[-8 * v22], v12, v5 - v12);
            v5 = *(char **)(a1 + 728);
          }
          v25 = &v5[8 * v21];
          v5 = &v23[v24];
          *(_QWORD *)(a1 + 736) = &v23[v24];
          *(_QWORD *)(a1 + 728) = v25;
        }
      }
      *(_QWORD *)v5 = v13;
    }
    *(_QWORD *)(a1 + 736) += 8;
LABEL_37:
    v10 = *(_QWORD *)(a1 + 760);
    v6 = *(char **)(a1 + 728);
    v11 = *(_QWORD *)(a1 + 752) + v10;
  }
  *(_QWORD *)(*(_QWORD *)&v6[(v11 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v11 & 0x1FF)) = v4;
  *(_QWORD *)(a1 + 760) = v10 + 1;
  v56.__id_ = v4;
  for (result = health::TransactionalFile::_transactionMutex_canStartWriteTransaction((health::TransactionalFile *)a1, v56);
        !result;
        result = health::TransactionalFile::_transactionMutex_canStartWriteTransaction((health::TransactionalFile *)a1, v58))
  {
    if (*(_BYTE *)(a1 + 344))
      break;
    std::condition_variable::wait((std::condition_variable *)(a1 + 648), a2);
    v58.__id_ = v4;
  }
  return result;
}

void sub_1B78CE8E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);
  if (v1)
    operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL health::TransactionalFile::_transactionMutex_canStartWriteTransaction(health::TransactionalFile *this, std::__thread_id a2)
{
  _BOOL8 result;
  _opaque_pthread_t *v3;

  if (*((_BYTE *)this + 344) || *((_QWORD *)this + 98))
    return 0;
  if (!*((_QWORD *)this + 95))
    return 1;
  v3 = *(_opaque_pthread_t **)(*(_QWORD *)(*((_QWORD *)this + 91) + ((*((_QWORD *)this + 94) >> 6) & 0x3FFFFFFFFFFFFF8))
                             + 8 * (*((_QWORD *)this + 94) & 0x1FFLL));
  if (!v3)
    return !a2.__id_;
  result = 0;
  if (a2.__id_ && v3 == a2.__id_)
    return 1;
  return result;
}

void health::TransactionalFile::configurePageSize(health::TransactionalFile *this, unint64_t a2)
{
  uint64_t v2;
  std::string __p;
  void *v4[2];
  void *v5[2];
  _QWORD v6[2];

  if (*((_QWORD *)this + 41))
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v6, "!isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v5, "configurePageSize");
    std::string::basic_string[abi:ne180100]<0>(v4, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"Page size must be configured before the file is opened.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v2, (uint64_t)v6, (uint64_t)v5, (uint64_t)v4, 423, (uint64_t)&__p);
  }
  health::TransactionalFile::_configurePageSize(this, a2);
}

void sub_1B78CEA60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

void health::TransactionalFile::_cacheMutex_writePage(health::TransactionalFile *this, unint64_t a2, health::FilePage *a3)
{
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t v21;

  v21 = *(_QWORD *)a3;
  v16 = *(_OWORD *)a3;
  v3 = (std::__shared_weak_count *)*((_QWORD *)a3 + 3);
  v17 = *((_QWORD *)a3 + 2);
  v18 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v6 = *((_QWORD *)a3 + 4);
  v7 = (std::__shared_weak_count *)*((_QWORD *)a3 + 5);
  v19 = v6;
  v20 = v7;
  if (v7)
  {
    v8 = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    v6 = *((_QWORD *)a3 + 4);
  }
  if (v6)
    v10 = 48;
  else
    v10 = *((_QWORD *)a3 + 1);
  health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey((_QWORD *)this + 60, a2, &v21, &v16, v10, 1);
  if (v7)
  {
    v11 = (unint64_t *)&v7->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v13 = v18;
  if (v18)
  {
    v14 = (unint64_t *)&v18->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1B78CEBEC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v2);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::_cacheMutex_pageForOffset(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  __int128 v36;
  size_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  __int128 v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  std::__shared_weak_count *v78;
  unint64_t *v79;
  unint64_t v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  __int128 v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  uint64_t v87;
  std::__shared_weak_count *v88;
  uint64_t v89;
  std::__shared_weak_count *v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  uint64_t v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  _OWORD v98[4];
  unint64_t v99[3];

  v9 = -*(_QWORD *)(a1 + 392) & a3;
  v99[0] = v9;
  v10 = (_QWORD *)(a1 + 480);
  v11 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>((_QWORD *)(a1 + 496), v9);
  if (v11)
  {
    v12 = v11[4];
    while (v12 != v11[3])
    {
      v14 = *(_QWORD *)(v12 - 8);
      v12 -= 8;
      v13 = v14;
      if (*(_QWORD *)(v14 + 8) <= a2)
      {
        health::TransactionalCache<unsigned long long,health::FilePage>::_touchCacheEntry((uint64_t)v10, v13);
        v15 = *(_QWORD *)(v13 + 8);
        v95 = *(_OWORD *)(v13 + 32);
        v17 = *(_QWORD *)(v13 + 48);
        v16 = *(_QWORD *)(v13 + 56);
        if (v16)
        {
          v18 = (unint64_t *)(v16 + 8);
          do
            v19 = __ldxr(v18);
          while (__stxr(v19 + 1, v18));
        }
        v21 = *(_QWORD *)(v13 + 64);
        v20 = *(_QWORD *)(v13 + 72);
        if (v20)
        {
          v22 = (unint64_t *)(v20 + 8);
          do
            v23 = __ldxr(v22);
          while (__stxr(v23 + 1, v22));
        }
        *(_OWORD *)((char *)v98 + 8) = v95;
        *(_QWORD *)&v98[0] = v15;
        *((_QWORD *)&v98[1] + 1) = v17;
        *(_QWORD *)&v98[2] = v16;
        *((_QWORD *)&v98[2] + 1) = v21;
        *(_QWORD *)&v98[3] = v20;
        BYTE8(v98[3]) = 1;
        health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v98);
        if (*(_QWORD *)&v98[0] == a2)
        {
          health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v98);
          health::TransactionalFile::_sanitizedPageForTransaction((_QWORD *)v98 + 1, a4, (health::FilePage *)a5);
          goto LABEL_61;
        }
        goto LABEL_14;
      }
    }
  }
  memset(v98, 0, 57);
LABEL_14:
  health::WriteAheadLog::pageAtOffset((std::mutex *)(a1 + 16), a2, v9, (health::FilePage *)&v95);
  v24 = v97;
  if ((unint64_t)v96 | (unint64_t)v97)
  {
    v91 = v95;
    v92 = v96;
    if (*((_QWORD *)&v96 + 1))
    {
      v25 = (unint64_t *)(*((_QWORD *)&v96 + 1) + 8);
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      v24 = v97;
    }
    v27 = (std::__shared_weak_count *)*((_QWORD *)&v97 + 1);
    v93 = v24;
    v94 = *((_QWORD *)&v97 + 1);
    if (*((_QWORD *)&v97 + 1))
    {
      v28 = (unint64_t *)(*((_QWORD *)&v97 + 1) + 8);
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
      v24 = v97;
    }
    if (v24)
      v30 = 48;
    else
      v30 = *((_QWORD *)&v95 + 1);
    health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(v10, a2, v99, &v91, v30, 0);
    if (v27)
    {
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      do
        v32 = __ldaxr(p_shared_owners);
      while (__stlxr(v32 - 1, p_shared_owners));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    v33 = (std::__shared_weak_count *)*((_QWORD *)&v92 + 1);
    if (*((_QWORD *)&v92 + 1))
    {
      v34 = (unint64_t *)(*((_QWORD *)&v92 + 1) + 8);
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
    v36 = v96;
    *(_OWORD *)a5 = v95;
    *(_OWORD *)(a5 + 16) = v36;
    v96 = 0uLL;
    *(_OWORD *)(a5 + 32) = v97;
    v97 = 0uLL;
  }
  else if (BYTE8(v98[3]))
  {
    if (a4 == 1)
    {
      health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v98);
      health::FilePage::copy((health::FilePage *)a5, (_QWORD *)v98 + 1);
    }
    else
    {
      health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v98);
      *(_OWORD *)a5 = *(_OWORD *)((char *)v98 + 8);
      v42 = *(_QWORD *)&v98[2];
      *(_QWORD *)(a5 + 16) = *((_QWORD *)&v98[1] + 1);
      *(_QWORD *)(a5 + 24) = v42;
      if (v42)
      {
        v43 = (unint64_t *)(v42 + 8);
        do
          v44 = __ldxr(v43);
        while (__stxr(v44 + 1, v43));
      }
      v45 = *(_QWORD *)&v98[3];
      *(_QWORD *)(a5 + 32) = *((_QWORD *)&v98[2] + 1);
      *(_QWORD *)(a5 + 40) = v45;
      if (v45)
      {
        v46 = (unint64_t *)(v45 + 8);
        do
          v47 = __ldxr(v46);
        while (__stxr(v47 + 1, v46));
      }
    }
  }
  else
  {
    v37 = *(_QWORD *)(a1 + 392);
    if (a4 || (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 328) + 48))(*(_QWORD *)(a1 + 328)) < v37 + v9)
    {
      *(_QWORD *)a5 = v9;
      *(_QWORD *)(a5 + 8) = v37;
      v38 = operator new[]();
      std::shared_ptr<unsigned char>::shared_ptr[abi:ne180100]<unsigned char,std::default_delete<unsigned char []>,void>((_QWORD *)(a5 + 16), v38);
      *(_QWORD *)(a5 + 32) = 0;
      *(_QWORD *)(a5 + 40) = 0;
      v39 = (_QWORD *)(a5 + 32);
      bzero((void *)*(v39 - 2), v37);
      v40 = *(_QWORD *)(a1 + 328);
      v41 = *(v39 - 2);
      if (!v41)
        v41 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v39 + 16))(*v39);
      (*(void (**)(uint64_t, unint64_t, uint64_t, size_t))(*(_QWORD *)v40 + 32))(v40, v9, v41, v37);
    }
    else
    {
      (*(void (**)(uint64_t *__return_ptr, _QWORD, unint64_t, size_t))(**(_QWORD **)(a1 + 328) + 40))(&v89, *(_QWORD *)(a1 + 328), v9, v37);
      v60 = v89;
      v61 = v90;
      if (v90)
      {
        v62 = (unint64_t *)&v90->__shared_owners_;
        do
          v63 = __ldxr(v62);
        while (__stxr(v63 + 1, v62));
      }
      v64 = *(_OWORD *)(v60 + 8);
      *(_QWORD *)(a5 + 16) = 0;
      *(_OWORD *)a5 = v64;
      *(_QWORD *)(a5 + 24) = 0;
      *(_QWORD *)(a5 + 32) = v60;
      *(_QWORD *)(a5 + 40) = v61;
      if (v61)
      {
        v65 = (unint64_t *)&v61->__shared_owners_;
        do
          v66 = __ldxr(v65);
        while (__stxr(v66 + 1, v65));
        do
          v67 = __ldaxr(v65);
        while (__stlxr(v67 - 1, v65));
        if (!v67)
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
      }
      v84 = *(_OWORD *)a5;
      v68 = *(std::__shared_weak_count **)(a5 + 24);
      v85 = *(_QWORD *)(a5 + 16);
      v86 = v68;
      if (v68)
      {
        v69 = (unint64_t *)&v68->__shared_owners_;
        do
          v70 = __ldxr(v69);
        while (__stxr(v70 + 1, v69));
      }
      v71 = *(_QWORD *)(a5 + 32);
      v72 = *(std::__shared_weak_count **)(a5 + 40);
      v87 = v71;
      v88 = v72;
      if (v72)
      {
        v73 = (unint64_t *)&v72->__shared_owners_;
        do
          v74 = __ldxr(v73);
        while (__stxr(v74 + 1, v73));
        v71 = *(_QWORD *)(a5 + 32);
      }
      if (v71)
        v75 = 48;
      else
        v75 = *(_QWORD *)(a5 + 8);
      health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(v10, a2, v99, &v84, v75, 0);
      if (v72)
      {
        v76 = (unint64_t *)&v72->__shared_owners_;
        do
          v77 = __ldaxr(v76);
        while (__stlxr(v77 - 1, v76));
        if (!v77)
        {
          ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
          std::__shared_weak_count::__release_weak(v72);
        }
      }
      v78 = v86;
      if (v86)
      {
        v79 = (unint64_t *)&v86->__shared_owners_;
        do
          v80 = __ldaxr(v79);
        while (__stlxr(v80 - 1, v79));
        if (!v80)
        {
          ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
          std::__shared_weak_count::__release_weak(v78);
        }
      }
      v81 = v90;
      if (v90)
      {
        v82 = (unint64_t *)&v90->__shared_owners_;
        do
          v83 = __ldaxr(v82);
        while (__stlxr(v83 - 1, v82));
        if (!v83)
        {
          ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
          std::__shared_weak_count::__release_weak(v81);
        }
      }
    }
  }
  v48 = (std::__shared_weak_count *)*((_QWORD *)&v97 + 1);
  if (*((_QWORD *)&v97 + 1))
  {
    v49 = (unint64_t *)(*((_QWORD *)&v97 + 1) + 8);
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  v51 = (std::__shared_weak_count *)*((_QWORD *)&v96 + 1);
  if (*((_QWORD *)&v96 + 1))
  {
    v52 = (unint64_t *)(*((_QWORD *)&v96 + 1) + 8);
    do
      v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
LABEL_61:
  v54 = *(std::__shared_weak_count **)&v98[3];
  if (*(_QWORD *)&v98[3])
  {
    v55 = (unint64_t *)(*(_QWORD *)&v98[3] + 8);
    do
      v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
      std::__shared_weak_count::__release_weak(v54);
    }
  }
  v57 = *(std::__shared_weak_count **)&v98[2];
  if (*(_QWORD *)&v98[2])
  {
    v58 = (unint64_t *)(*(_QWORD *)&v98[2] + 8);
    do
      v59 = __ldaxr(v58);
    while (__stlxr(v59 - 1, v58));
    if (!v59)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
}

void sub_1B78CF244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v39);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v38);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v37);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v36);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v35);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v34);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a34);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a32);
  _Unwind_Resume(a1);
}

void *health::TransactionalFile::_sanitizedPageForTransaction@<X0>(_QWORD *a1@<X1>, int a2@<W2>, health::FilePage *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  void *result;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;

  v3 = a1[2];
  v4 = a1[4];
  if (v3 | v4)
  {
    if (a2 == 1 && v4)
    {
      return health::FilePage::copy(a3, a1);
    }
    else
    {
      *(_OWORD *)a3 = *(_OWORD *)a1;
      v10 = a1[3];
      *((_QWORD *)a3 + 2) = v3;
      *((_QWORD *)a3 + 3) = v10;
      if (v10)
      {
        v11 = (unint64_t *)(v10 + 8);
        do
          v12 = __ldxr(v11);
        while (__stxr(v12 + 1, v11));
        v4 = a1[4];
      }
      v13 = a1[5];
      *((_QWORD *)a3 + 4) = v4;
      *((_QWORD *)a3 + 5) = v13;
      if (v13)
      {
        v14 = (unint64_t *)(v13 + 8);
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }
    }
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)a1;
    v6 = a1[3];
    *((_QWORD *)a3 + 2) = 0;
    *((_QWORD *)a3 + 3) = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
      v9 = a1[4];
    }
    else
    {
      v9 = 0;
    }
    v16 = a1[5];
    *((_QWORD *)a3 + 4) = v9;
    *((_QWORD *)a3 + 5) = v16;
    if (v16)
    {
      v17 = (unint64_t *)(v16 + 8);
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }
  }
  return result;
}

uint64_t health::TransactionalFile::_resize(health::TransactionalFile *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 41) + 56))(*((_QWORD *)this + 41));
}

uint64_t health::TransactionalFile::_finishCheckpoint(health::TransactionalFile *this)
{
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*((_QWORD *)this + 41), (uint64_t)this + 352);
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 41) + 16))(*((_QWORD *)this + 41));
}

void health::TransactionalFile::ReadTransaction::~ReadTransaction(health::TransactionalFile::ReadTransaction *this)
{
  JUMPOUT(0x1BCCAC494);
}

void health::TransactionalFile::WriteTransaction::~WriteTransaction(health::TransactionalFile::WriteTransaction *this)
{
  JUMPOUT(0x1BCCAC494);
}

void health::_HDAssertImplementation<std::out_of_range>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  char **v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  std::logic_error *exception;
  char **v34;
  std::string *v35;
  std::string::size_type size;
  _QWORD *v37;
  void *__p[2];
  char v39;
  std::string v40;
  uint64_t v41;
  uint64_t v42;
  void *v43[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)v43 = 0u;
  v44 = 0u;
  LODWORD(v10) = backtrace(v43, 20);
  v11 = backtrace_symbols(v43, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Critical Error: ", 16);
  v13 = *(char *)(a6 + 23);
  if (v13 >= 0)
    v14 = a6;
  else
    v14 = *(_QWORD *)a6;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a6 + 23);
  else
    v15 = *(_QWORD *)(a6 + 8);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Failed assertion '", 18);
  v18 = *(char *)(a2 + 23);
  if (v18 >= 0)
    v19 = a2;
  else
    v19 = *(_QWORD *)a2;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(a2 + 23);
  else
    v20 = *(_QWORD *)(a2 + 8);
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  v23 = *(char *)(a3 + 23);
  if (v23 >= 0)
    v24 = a3;
  else
    v24 = *(_QWORD *)a3;
  if (v23 >= 0)
    v25 = *(unsigned __int8 *)(a3 + 23);
  else
    v25 = *(_QWORD *)(a3 + 8);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  v28 = *(char *)(a4 + 23);
  if (v28 >= 0)
    v29 = a4;
  else
    v29 = *(_QWORD *)a4;
  if (v28 >= 0)
    v30 = *(unsigned __int8 *)(a4 + 23);
  else
    v30 = *(_QWORD *)(a4 + 8);
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  v32 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  v10 = (int)v10;
  if ((_DWORD)v10)
  {
    v34 = v11;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, *v34);
      health::HDDemangleBacktraceLine((uint64_t)__p, (unint64_t)&v40);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v35 = &v40;
      else
        v35 = (std::string *)v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      else
        size = v40.__r_.__value_.__l.__size_;
      v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)v35, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
      if (v39 < 0)
        operator delete(__p[0]);
      ++v34;
      --v10;
    }
    while (v10);
  }
  free(v11);
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v42, &v40);
  std::logic_error::logic_error(exception, &v40);
  exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
}

void sub_1B78CF688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0)
    operator delete(__p);
  a21 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a21 + *(_QWORD *)(a21 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a22 = MEMORY[0x1E0DE4FB8] + 16;
  if (a35 < 0)
    operator delete(a30);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&a38);
  _Unwind_Resume(a1);
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

uint64_t std::deque<std::__thread_id>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 256;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 512;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<std::__thread_id *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__deallocate_node(a1, *(char **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__deallocate_node(uint64_t a1, char *a2)
{
  char *v2;
  char *v3;
  void **v4;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *(char **)v2;
      v4 = (void **)(v2 + 24);
      std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](&v4);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  uint64_t *v2;
  uint64_t *v4;
  void *v5;

  v1 = *a1;
  v2 = (uint64_t *)**a1;
  if (v2)
  {
    v4 = (uint64_t *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v2 + 64);
    std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v2 + 48);
    JUMPOUT(0x1BCCAC494);
  }
  return result;
}

void health::data_corruption_error::~data_corruption_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1BCCAC494);
}

void health::transaction_error::~transaction_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1BCCAC494);
}

uint64_t std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

_QWORD *std::shared_ptr<unsigned char>::shared_ptr[abi:ne180100]<unsigned char,std::default_delete<unsigned char []>,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E6CEC288;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B78CFAC0(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (v1)
    MEMORY[0x1BCCAC47C](v1, 0x1000C8077774924);
  __cxa_rethrow();
}

void sub_1B78CFAE8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<unsigned char  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCAC494);
}

uint64_t std::__shared_ptr_pointer<unsigned char  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

void std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CEBD70;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CEBD70;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::operator()(uint64_t a1, unint64_t *a2, uint64_t a3, const health::FilePage *a4)
{
  health::WriteAheadLog::updatedPage((std::mutex *)(*(_QWORD *)(a1 + 8) + 16), *a2, a4);
  return 1;
}

uint64_t std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::target_type()
{
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
}

void sub_1B78CFCB4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

void health::file_access_error::~file_access_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1BCCAC494);
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E6CEBE40;
  return result;
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E6CEBE40;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::target_type()
{
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E6CEBED0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEBED0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 328);
  v6 = *a3;
  v7 = a3[2];
  if (!v7)
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3[4] + 16))(a3[4]);
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 24))(v5, v6, v7, a3[1]);
  **(_BYTE **)(a1 + 16) = 1;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::target_type()
{
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CEBF60;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CEBF60;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::operator()(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*(_QWORD *)(v1 + 328), v1 + 352);
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 328) + 16))(*(_QWORD *)(v1 + 328));
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::target_type()
{
}

_QWORD *std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(uint64_t a1, unint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  char v7;
  BOOL v8;
  _QWORD *v9;
  unint64_t v10;

  v4 = *(_QWORD **)(a1 + 8);
  v2 = (_QWORD *)(a1 + 8);
  v3 = v4;
  if (!v4)
    return v2;
  v5 = v2;
  do
  {
    v6 = v3[4];
    if (v6)
    {
      if (!a2 || v6 != a2)
      {
        if (v6 >= a2)
          v7 = 1;
        else
          v7 = -1;
        goto LABEL_12;
      }
    }
    else if (a2)
    {
      v7 = -1;
      goto LABEL_12;
    }
    v7 = 0;
LABEL_12:
    v8 = (v7 & 0x80) == 0;
    if (v7 < 0)
      v9 = v3 + 1;
    else
      v9 = v3;
    if (v8)
      v5 = v3;
    v3 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v2 == v5)
    return v2;
  v10 = v5[4];
  if (!a2)
  {
    if (!v10)
      return v5;
    return v2;
  }
  if (v10 > a2)
    return v2;
  return v5;
}

uint64_t health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a2 + 80);
  if (v2)
    *(_QWORD *)(v2 + 88) = *(_QWORD *)(a2 + 88);
  v3 = *(_QWORD *)(a2 + 88);
  if (v3)
    *(_QWORD *)(v3 + 80) = v2;
  if (*(_QWORD *)(result + 64) == a2)
    *(_QWORD *)(result + 64) = v3;
  if (*(_QWORD *)(result + 56) == a2)
    *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 80);
  return result;
}

uint64_t *health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(uint64_t *result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;

  v2 = (uint64_t *)*result;
  v3 = (uint64_t *)result[1];
  if ((uint64_t *)*result != v3)
  {
    v5 = result;
    while (*v2 != a2)
    {
      if (++v2 == v3)
        return result;
    }
    if (v2 != v3)
    {
      v6 = v2 + 1;
      if (v2 + 1 != v3)
      {
        do
        {
          v7 = *v6;
          if (*v6 != a2)
          {
            *v6 = 0;
            result = std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100](v2++, v7);
          }
          ++v6;
        }
        while (v6 != v3);
        v3 = (uint64_t *)v5[1];
      }
    }
    if (v2 != v3)
    {
      result = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,0>(v3, v3, v2);
      v8 = result;
      v9 = (uint64_t *)v5[1];
      if (v9 != result)
      {
        do
          result = std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100](--v9, 0);
        while (v9 != v8);
      }
      v5[1] = (uint64_t)v8;
    }
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v5 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = a1 + 2;
  i = operator new(0x30uLL);
  *i = 0;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0;
  i[4] = 0;
  i[5] = 0;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v15 = 1;
  if (v7 >= 3)
    v15 = (v7 & (v7 - 1)) != 0;
  v16 = v15 | (2 * v7);
  v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17)
    prime = (int8x8_t)v17;
  else
    prime = (int8x8_t)v16;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = a1[1];
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      v25 = std::__next_prime(v25);
    }
    else
    {
      v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2)
        v25 = v27;
    }
    if (*(_QWORD *)&prime <= v25)
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v34 = (void *)*a1;
      *a1 = 0;
      if (v34)
        operator delete(v34);
      v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v19 = operator new(8 * *(_QWORD *)&prime);
  v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20)
    operator delete(v20);
  v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(_QWORD *)(*a1 + 8 * v21++) = 0;
  while (*(_QWORD *)&prime != v21);
  v22 = (_QWORD *)*v12;
  if (*v12)
  {
    v23 = v22[1];
    v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&prime)
        v23 %= *(_QWORD *)&prime;
    }
    else
    {
      v23 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*a1 + 8 * v23) = v12;
    v28 = (_QWORD *)*v22;
    if (*v22)
    {
      do
      {
        v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(_QWORD *)&prime)
            v29 %= *(_QWORD *)&prime;
        }
        else
        {
          v29 &= *(_QWORD *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(_QWORD *)(*a1 + 8 * v29))
          {
            *(_QWORD *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *v22 = *v28;
          *v28 = **(_QWORD **)(*a1 + 8 * v29);
          **(_QWORD **)(*a1 + 8 * v29) = v28;
          v28 = v22;
        }
        v29 = v23;
LABEL_56:
        v22 = v28;
        v28 = (_QWORD *)*v28;
        v23 = v29;
      }
      while (v28);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v5);
  if (v31)
  {
    *i = *v31;
LABEL_72:
    *v31 = i;
    goto LABEL_73;
  }
  *i = *v12;
  *v12 = i;
  *(_QWORD *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    v32 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return i;
}

void sub_1B78D0548(_Unwind_Exception *a1)
{
  void **v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  void **v3;

  if (a1)
  {
    v3 = __p + 3;
    std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p)
    operator delete(__p);
}

uint64_t *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t v6;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *v5;
      *v5++ = 0;
      std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>::reset[abi:ne180100](a3++, v6);
    }
    while (v5 != a2);
  }
  return a3;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(_QWORD *a1, unint64_t a2)
{
  void **v3;
  void **v4;
  int8x8_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  void **v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  void **v14;

  v3 = (void **)std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(a1, a2);
  if (v3)
  {
    v4 = v3;
    v5 = (int8x8_t)a1[1];
    v6 = *v3;
    v7 = (unint64_t)v3[1];
    v8 = (uint8x8_t)vcnt_s8(v5);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      if (v7 >= *(_QWORD *)&v5)
        v7 %= *(_QWORD *)&v5;
    }
    else
    {
      v7 &= *(_QWORD *)&v5 - 1;
    }
    v9 = *(void ***)(*a1 + 8 * v7);
    do
    {
      v10 = v9;
      v9 = (void **)*v9;
    }
    while (v9 != v3);
    if (v10 == a1 + 2)
      goto LABEL_19;
    v11 = (unint64_t)v10[1];
    if (v8.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v5)
        v11 %= *(_QWORD *)&v5;
    }
    else
    {
      v11 &= *(_QWORD *)&v5 - 1;
    }
    if (v11 != v7)
    {
LABEL_19:
      if (v6)
      {
        v12 = v6[1];
        if (v8.u32[0] > 1uLL)
        {
          v13 = v6[1];
          if (v12 >= *(_QWORD *)&v5)
            v13 = v12 % *(_QWORD *)&v5;
        }
        else
        {
          v13 = v12 & (*(_QWORD *)&v5 - 1);
        }
        if (v13 == v7)
          goto LABEL_23;
      }
      *(_QWORD *)(*a1 + 8 * v7) = 0;
      v6 = *v3;
    }
    if (!v6)
    {
LABEL_29:
      *v10 = v6;
      *v3 = 0;
      --a1[3];
      v14 = v3 + 3;
      std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](&v14);
      operator delete(v4);
      return;
    }
    v12 = v6[1];
LABEL_23:
    if (v8.u32[0] > 1uLL)
    {
      if (v12 >= *(_QWORD *)&v5)
        v12 %= *(_QWORD *)&v5;
    }
    else
    {
      v12 &= *(_QWORD *)&v5 - 1;
    }
    if (v12 != v7)
    {
      *(_QWORD *)(*a1 + 8 * v12) = v10;
      v6 = *v3;
    }
    goto LABEL_29;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *result;
  unint64_t v7;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (*(_QWORD *)&v2 <= a2)
      v4 = a2 % *(_QWORD *)&v2;
  }
  else
  {
    v4 = (*(_QWORD *)&v2 - 1) & a2;
  }
  v5 = *(_QWORD **)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  result = (_QWORD *)*v5;
  if (*v5)
  {
    do
    {
      v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(_QWORD *)&v2)
            v7 %= *(_QWORD *)&v2;
        }
        else
        {
          v7 &= *(_QWORD *)&v2 - 1;
        }
        if (v7 != v4)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

void std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CEBFE0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEBFE0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::operator()(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  _QWORD **v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t **v18;
  _QWORD v19[4];
  std::unique_lock<std::mutex> v20;

  v3 = *a2;
  v4 = a1[1];
  v20.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v4 + 584);
  v20.__owns_ = 1;
  std::mutex::lock((std::mutex *)(v4 + 584));
  v5 = *(unsigned int *)(v4 + 360);
  v19[0] = &off_1E6CEBCF8;
  v19[1] = v3;
  v19[2] = v4;
  v19[3] = v5;
  v6 = (unint64_t *)a1[2];
  v7 = a1[3];
  v8 = (_QWORD **)(v4 + 696);
  v9 = *v6;
  v10 = *(_QWORD **)(v4 + 704);
  if (v10)
  {
    while (1)
    {
      v11 = v10;
      v12 = v10[4];
      if (!v9)
        break;
      if (v12)
        v13 = v12 == v9;
      else
        v13 = 0;
      if (v13)
      {
LABEL_18:
        v14 = v11;
        goto LABEL_19;
      }
      if (v12 > v9)
      {
LABEL_12:
        v10 = (_QWORD *)*v11;
        v18 = (uint64_t **)v11;
        if (!*v11)
          goto LABEL_15;
      }
      else
      {
        if (v12 >= v9)
          goto LABEL_18;
        v10 = (_QWORD *)v11[1];
        if (!v10)
        {
          v18 = (uint64_t **)(v11 + 1);
          goto LABEL_15;
        }
      }
    }
    if (!v12)
      goto LABEL_18;
    goto LABEL_12;
  }
  v18 = (uint64_t **)(v4 + 704);
  v11 = (_QWORD *)(v4 + 704);
LABEL_15:
  v14 = (uint64_t *)operator new(0x30uLL);
  v14[4] = v9;
  v14[5] = 0;
  *v14 = 0;
  v14[1] = 0;
  v14[2] = (uint64_t)v11;
  *v18 = v14;
  v15 = (_QWORD *)**v8;
  v16 = v14;
  if (v15)
  {
    *v8 = v15;
    v16 = *v18;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 704), v16);
  ++*(_QWORD *)(v4 + 712);
LABEL_19:
  v14[5] = (uint64_t)v19;
  std::unique_lock<std::mutex>::unlock(&v20);
  v17 = *(_QWORD *)(v7 + 24);
  if (!v17)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v17 + 48))(v17, v19);
  std::unique_lock<std::mutex>::lock(&v20);
  std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>((uint64_t **)(v4 + 696), *v6);
  std::condition_variable::notify_all((std::condition_variable *)(v4 + 648));
  if (v20.__owns_)
    std::mutex::unlock(v20.__m_);
}

void sub_1B78D0A14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::unique_lock<std::mutex> a13)
{
  __break(1u);
}

void sub_1B78D0A48()
{
  __cxa_end_catch();
  JUMPOUT(0x1B78D0A50);
}

uint64_t std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::target_type()
{
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>(uint64_t **a1, unint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  BOOL v8;
  uint64_t *v9;

  v3 = std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v3)
  {
    v4 = v3;
    v5 = (uint64_t *)v3[1];
    if (v5)
    {
      do
      {
        v6 = v5;
        v5 = (uint64_t *)*v5;
      }
      while (v5);
    }
    else
    {
      v7 = v3;
      do
      {
        v6 = (uint64_t *)v7[2];
        v8 = *v6 == (_QWORD)v7;
        v7 = v6;
      }
      while (!v8);
    }
    if (*a1 == v3)
      *a1 = v6;
    v9 = a1[1];
    a1[2] = (uint64_t *)((char *)a1[2] - 1);
    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v9, v4);
    operator delete(v4);
  }
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 != v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v18 = v7[1];
      *(_QWORD *)v12 = v18;
      if (v18)
        *(_QWORD *)(v18 + 16) = v12;
      v7[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(_QWORD *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12)
        result = v7;
      v7 = *(uint64_t **)v12;
    }
    v19 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24))
      goto LABEL_68;
    v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        v20 = v7;
      }
      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v26 = *v20;
        v7[1] = *v20;
        if (v26)
          *(_QWORD *)(v26 + 16) = v7;
        v20[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
        *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        v19 = v7;
      }
      v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      v24 = *(uint64_t **)v23;
      v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      *(_QWORD *)v23 = v27;
      if (v27)
        *(_QWORD *)(v27 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v13 = *(uint64_t **)(v12 + 8);
    v14 = *v13;
    *(_QWORD *)(v12 + 8) = *v13;
    if (v14)
      *(_QWORD *)(v14 + 16) = v12;
    v13[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
    *v13 = v12;
    *(_QWORD *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7)
      result = v7;
    v7 = *(uint64_t **)(*v7 + 8);
  }
  v15 = (_QWORD *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_59;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
    goto LABEL_49;
  }
  v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    v15 = v7;
  }
  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v22 = v15[1];
    *v7 = v22;
    if (v22)
      *(_QWORD *)(v22 + 16) = v7;
    v15[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    v16 = v7;
  }
  v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  v24 = *(uint64_t **)(v23 + 8);
  v25 = *v24;
  *(_QWORD *)(v23 + 8) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  *v24 = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(unint64_t a1)
{
  if (a1 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a1);
}

void health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_1::operator()(uint64_t a1)
{
  std::unique_lock<std::mutex> *v2;
  uint64_t v3;

  v2 = *(std::unique_lock<std::mutex> **)a1;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v2->__owns_)
    std::unique_lock<std::mutex>::lock(v2);
  std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>((uint64_t **)(v3 + 768), **(_QWORD **)(a1 + 16));
  std::condition_variable::notify_all((std::condition_variable *)(v3 + 648));
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CEC060;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEC060;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::operator()(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t **v11;
  unint64_t v12;
  BOOL v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  _opaque_pthread_t *v17;
  pthread_t v18;
  uint64_t v19;
  int64x2_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t i;
  uint64_t **v25;
  std::string __p;
  void *v27[2];
  void *v28[2];
  void *v29[2];
  uint64_t (**v30)(health::TransactionalFile::WriteTransaction *__hidden);
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(unsigned int *)(v4 + 360);
  v32 = v4;
  v33 = v5;
  v30 = &off_1E6CEBD20;
  v31 = v3;
  v34 = v4;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 328) + 48))(*(_QWORD *)(v4 + 328));
  v7 = health::WriteAheadLog::maximumCommittedSizeForTransaction((std::mutex *)(v4 + 16), v3);
  if (v6 <= v7)
    v8 = v7;
  else
    v8 = v6;
  v35 = ((v8 - v5) & ~((v8 - v5) >> 63)) + v5;
  v9 = **(uint64_t ***)(a1 + 16);
  v10 = *(uint64_t **)(v4 + 776);
  if (!v10)
  {
    v25 = (uint64_t **)(v4 + 776);
    v11 = (uint64_t **)(v4 + 776);
    goto LABEL_18;
  }
  do
  {
    while (1)
    {
      v11 = (uint64_t **)v10;
      v12 = v10[4];
      if (!v9)
      {
        if (!v12)
          goto LABEL_21;
        goto LABEL_15;
      }
      if (v12)
        v13 = v12 == (_QWORD)v9;
      else
        v13 = 0;
      if (v13)
        goto LABEL_21;
      if (v12 <= (unint64_t)v9)
        break;
LABEL_15:
      v10 = *v11;
      v25 = v11;
      if (!*v11)
        goto LABEL_18;
    }
    if (v12 >= (unint64_t)v9)
      goto LABEL_21;
    v10 = v11[1];
  }
  while (v10);
  v25 = v11 + 1;
LABEL_18:
  v14 = (uint64_t *)v11;
  v11 = (uint64_t **)operator new(0x30uLL);
  v11[4] = v9;
  v11[5] = 0;
  *v11 = 0;
  v11[1] = 0;
  v11[2] = v14;
  *v25 = (uint64_t *)v11;
  v15 = **(_QWORD **)(v4 + 768);
  v16 = (uint64_t *)v11;
  if (v15)
  {
    *(_QWORD *)(v4 + 768) = v15;
    v16 = *v25;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 776), v16);
  ++*(_QWORD *)(v4 + 784);
LABEL_21:
  v11[5] = (uint64_t *)&v30;
  v17 = *(_opaque_pthread_t **)(*(_QWORD *)(*(_QWORD *)(v4 + 728) + ((*(_QWORD *)(v4 + 752) >> 6) & 0x3FFFFFFFFFFFFF8))
                              + 8 * (*(_QWORD *)(v4 + 752) & 0x1FFLL));
  v18 = pthread_self();
  if (v17)
  {
    if (!v18 || v17 != v18)
    {
LABEL_26:
      v19 = *MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v29, "_waitingWriterThreads.front() == std::this_thread::get_id()");
      std::string::basic_string[abi:ne180100]<0>(v28, "operator()");
      std::string::basic_string[abi:ne180100]<0>(v27, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
      health::FormatString<>((std::string *)"Improper thread at write transaction start.", &__p);
      health::_HDAssertImplementation<std::logic_error>(v19, (uint64_t)v29, (uint64_t)v28, (uint64_t)v27, 309, (uint64_t)&__p);
    }
  }
  else if (v18)
  {
    goto LABEL_26;
  }
  v20 = vaddq_s64(*(int64x2_t *)(v4 + 752), (int64x2_t)xmmword_1B7F3A670);
  *(int64x2_t *)(v4 + 752) = v20;
  if (v20.i64[0] >= 0x400uLL)
  {
    operator delete(**(void ***)(v4 + 728));
    *(_QWORD *)(v4 + 728) += 8;
    *(_QWORD *)(v4 + 752) -= 512;
  }
  std::unique_lock<std::mutex>::unlock(*(std::unique_lock<std::mutex> **)(a1 + 24));
  v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
  if (!v21)
    std::__throw_bad_function_call[abi:ne180100]();
  v22 = (*(uint64_t (**)(uint64_t, uint64_t (***)(health::TransactionalFile::WriteTransaction *__hidden)))(*(_QWORD *)v21 + 48))(v21, &v30);
  if ((v22 & 1) != 0)
  {
    std::mutex::lock((std::mutex *)(v4 + 416));
    for (i = *(_QWORD *)(v4 + 536); i; i = *(_QWORD *)(i + 80))
    {
      if (*(_DWORD *)i == 1)
      {
        health::WriteAheadLog::updatedPage((std::mutex *)(v4 + 16), *(_QWORD *)(i + 8), (const health::FilePage *)(i + 32));
        *(_DWORD *)i = 0;
      }
    }
  }
  else
  {
    std::mutex::lock((std::mutex *)(v4 + 416));
    health::TransactionalCache<unsigned long long,health::FilePage>::discardEntriesForTransaction(v4 + 480, v31);
  }
  std::mutex::unlock((std::mutex *)(v4 + 416));
  return v22;
}

void sub_1B78D145C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34)
{
  __break(1u);
}

void sub_1B78D154C()
{
  std::mutex *v0;

  std::mutex::unlock(v0);
  __cxa_end_catch();
  JUMPOUT(0x1B78D1564);
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::target_type()
{
}

void health::TransactionalCache<unsigned long long,health::FilePage>::discardEntriesForTransaction(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;

  v2 = *(_QWORD **)(a1 + 64);
  if (v2)
  {
    v5 = (uint64_t *)(a1 + 16);
    do
    {
      v6 = (_QWORD *)v2[11];
      if (v2[1] == a2)
      {
        v7 = v2[3];
        *(_QWORD *)(a1 + 8) -= v2[2];
        v9 = v7;
        health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList(a1, (uint64_t)v2);
        v8 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v5, v7, &v9);
        health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(v8 + 3, (uint64_t)v2);
        if (v8[4] == v8[3])
          std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v5, v7);
      }
      v2 = v6;
    }
    while (v6);
  }
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E6CEC0F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEC0F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::operator()(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  std::unique_lock<std::mutex>::lock(*(std::unique_lock<std::mutex> **)(a1 + 8));
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*(_QWORD *)(v1 + 328), v1 + 352);
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 328) + 16))(*(_QWORD *)(v1 + 328));
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::target_type()
{
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CEC170;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CEC170;
  a2[1] = v2;
  return result;
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::operator()(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  __int128 v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t v32;

  v4 = *a2;
  v5 = *(_QWORD **)(a1 + 8);
  v6 = v5[41];
  v7 = *(_QWORD *)a3;
  v8 = *(_QWORD *)(a3 + 16);
  if (!v8)
    v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a3 + 32) + 16))(*(_QWORD *)(a3 + 32));
  (*(void (**)(uint64_t, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v6 + 24))(v6, v7, v8, *(_QWORD *)(a3 + 8));
  v9 = *(_QWORD *)a3;
  v10 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(v5 + 62, *(_QWORD *)a3);
  if (v10)
  {
    v11 = (uint64_t *)v10[3];
    v12 = (uint64_t *)v10[4];
    while (v11 != v12)
    {
      v13 = *v11++;
      v5[61] -= *(_QWORD *)(v13 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)(v5 + 60), v13);
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v5 + 62, v9);
    v9 = *(_QWORD *)a3;
  }
  v32 = v9;
  v27 = *(_OWORD *)a3;
  v14 = *(std::__shared_weak_count **)(a3 + 24);
  v28 = *(_QWORD *)(a3 + 16);
  v29 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v17 = *(_QWORD *)(a3 + 32);
  v18 = *(std::__shared_weak_count **)(a3 + 40);
  v30 = v17;
  v31 = v18;
  if (v18)
  {
    v19 = (unint64_t *)&v18->__shared_owners_;
    do
      v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
    v17 = *(_QWORD *)(a3 + 32);
  }
  if (v17)
    v21 = 48;
  else
    v21 = *(_QWORD *)(a3 + 8);
  health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(v5 + 60, v4, &v32, &v27, v21, 0);
  if (v18)
  {
    v22 = (unint64_t *)&v18->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v24 = v29;
  if (v29)
  {
    v25 = (unint64_t *)&v29->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
}

void sub_1B78D19A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  if (a12)
  {
    v16 = (unint64_t *)&a12->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::target_type()
{
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E6CEC1F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CEC1F0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::operator()(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*(_QWORD *)(v2 + 328), v2 + 352);
  (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 328) + 16))(*(_QWORD *)(v2 + 328));
  std::unique_lock<std::mutex>::unlock(*(std::unique_lock<std::mutex> **)(a1 + 16));
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::target_type()
{
}

void sub_1B78D2E0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  _Unwind_Resume(a1);
}

void sub_1B78D2F44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B78D3044(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B78D314C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B78D3238(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B78D3410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1B78D44B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,void *a27,void *a28,void *a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,_Unwind_Exception *exception_objecta,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  void *v48;

  _Block_object_dispose(&STACK[0x228], 8);
  v48 = (void *)STACK[0x258];
  if (STACK[0x258])
  {
    STACK[0x260] = (unint64_t)v48;
    operator delete(v48);
  }

  _Block_object_dispose(&a41, 8);
  std::__tree<long>::destroy((_QWORD *)a48);

  _Unwind_Resume(a1);
}

_QWORD *__Block_byref_object_copy__25(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[6] = a2[6];
  v2 = a2 + 7;
  v3 = a2[7];
  result[7] = v3;
  v4 = result + 7;
  v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[6] = v2;
    *v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__25(uint64_t a1)
{
  std::__tree<long>::destroy(*(_QWORD **)(a1 + 56));
}

void sub_1B78D4A10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78D4AA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78D4B88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78D4EC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__206_0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__207_0(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void std::__tree<long>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<long>::destroy(*a1);
    std::__tree<long>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t *std::__tree<long>::__emplace_unique_key_args<long,long const&>(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = result;
  v6 = (uint64_t **)(result + 1);
  v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (uint64_t **)(result + 1);
LABEL_9:
    v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = a3;
    *v9 = 0;
    v9[1] = 0;
    v9[2] = (uint64_t)v7;
    *v6 = v9;
    v10 = *(_QWORD *)*v4;
    if (v10)
    {
      *v4 = v10;
      v11 = *v6;
    }
    else
    {
      v11 = v9;
    }
    result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

uint64_t *HKIntervalMask<double>::_insertInterval(uint64_t *result, double a2, double a3)
{
  uint64_t *v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  double v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v13[2];

  v3 = result;
  v4 = 0;
  *(double *)v13 = a2;
  *(double *)&v13[1] = a3;
  v5 = (char *)*result;
  v6 = result[1];
  do
  {
    if ((char *)(v6 + v4) == v5)
    {
      v11 = std::vector<HKRawInterval<double>>::insert((uint64_t)result, v5, (char *)v13);
      return HKIntervalMask<double>::_compactIntervalsForwardFrom<std::__wrap_iter<HKRawInterval<double> *>>(v3, (uint64_t)v11);
    }
    v7 = *(double *)(v6 + v4 - 16);
    v4 -= 16;
  }
  while (v7 > a2);
  v8 = v6 + v4;
  v9 = *(double *)(v6 + v4 + 8);
  if (v9 >= a2)
  {
    if (a3 > v9)
    {
      *(double *)(v8 + 8) = a3;
      if (v4 != -16)
      {
        v10 = (char *)(v6 + v4);
        return HKIntervalMask<double>::_compactIntervalsForwardFrom<std::__wrap_iter<HKRawInterval<double> *>>(result, (uint64_t)v10);
      }
    }
  }
  else
  {
    v10 = (char *)(v8 + 16);
    if (v4 == -16 || a3 < *(double *)(v8 + 16))
      return (uint64_t *)std::vector<HKRawInterval<double>>::insert((uint64_t)result, v10, (char *)v13);
    *(double *)(v8 + 16) = a2;
    v12 = v6 + v4;
    if (a3 > *(double *)(v12 + 24))
    {
      *(double *)(v12 + 24) = a3;
      return HKIntervalMask<double>::_compactIntervalsForwardFrom<std::__wrap_iter<HKRawInterval<double> *>>(result, (uint64_t)v10);
    }
  }
  return result;
}

uint64_t *HKIntervalMask<double>::_compactIntervalsForwardFrom<std::__wrap_iter<HKRawInterval<double> *>>(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  double *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  double *v7;
  double v8;
  double *v9;
  double v10;
  double v11;
  double *v12;
  int64_t v13;

  v2 = *result;
  v3 = (double *)result[1];
  v4 = (a2 - *result) >> 4;
  v5 = v4 + 1;
  if (v4 + 1 < (unint64_t)(((uint64_t)v3 - *result) >> 4))
  {
    v6 = result;
    do
    {
      v7 = (double *)(v2 + 16 * v4);
      v8 = v7[1];
      v9 = (double *)(v2 + 16 * v5);
      if (v8 < *v9)
        break;
      v10 = *v7;
      if (v8 < v9[1])
        v8 = v9[1];
      if (v8 >= v10)
        v11 = *v7;
      else
        v11 = v8;
      if (v10 >= v8)
        v8 = *v7;
      *v7 = v11;
      v7[1] = v8;
      v12 = v7 + 2;
      v13 = (char *)v3 - (char *)(v7 + 4);
      if (v3 != v7 + 4)
      {
        result = (uint64_t *)memmove(v7 + 2, v7 + 4, (char *)v3 - (char *)(v7 + 4));
        v2 = *v6;
      }
      v3 = (double *)((char *)v12 + v13);
      v6[1] = (uint64_t)v12 + v13;
    }
    while (v5 < ((uint64_t)v12 + v13 - v2) >> 4);
  }
  return result;
}

char *std::vector<HKRawInterval<double>>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _OWORD *v11;
  __int128 v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 4) + 1;
    if (v14 >> 60)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v15 = __src - v13;
    v16 = (__src - v13) >> 4;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 3 > v14)
      v14 = v17 >> 3;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
      v18 = 0xFFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[16 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[16 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 3;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>(v8, v22);
        v20 = &v23[16 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[16 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 16 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_OWORD *)v20 = *(_OWORD *)v3;
    v28 = v20 + 16;
    v4 = (char *)std::vector<HKRawInterval<double>>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_OWORD *)__src = *(_OWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 16;
  }
  else
  {
    v9 = __src + 16;
    v10 = v6 - 16;
    v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_OWORD *)v10;
      v10 += 16;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-16 * ((v6 - v9) >> 4)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 16 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_OWORD *)v4 = *(_OWORD *)v3;
  }
  return v4;
}

void sub_1B78D5500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *std::vector<HKRawInterval<double>>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(void **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(void **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

void _HDMakeSleepIntervalAverageInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 <= 1)
    v3 = 1;
  *(_QWORD *)(a1 + 16) = 0;
  *(float64x2_t *)a1 = vrndmq_f64(vdivq_f64(*(float64x2_t *)(a2 + 16), (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v3), 0)));
  *(_QWORD *)(a1 + 16) = objc_msgSend(*(id *)(a2 + 32), "copy");

}

void sub_1B78D5698(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void sub_1B78D5E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34)
{

  _Unwind_Resume(a1);
}

void sub_1B78D61E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  uint64_t v32;
  void *v33;
  void *v34;

  _Unwind_Resume(a1);
}

void sub_1B78D65C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void sub_1B78D7F10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a64;
  char a70;
  uint64_t v70;

  _Block_object_dispose(&a58, 8);
  _Block_object_dispose(&a64, 8);
  _Block_object_dispose(&a70, 8);
  _Block_object_dispose((const void *)(v70 - 232), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__26(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__26(uint64_t a1)
{

}

void sub_1B78DC074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__27(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__27(uint64_t a1)
{

}

void sub_1B78DC864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__28(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__28(uint64_t a1)
{

}

void sub_1B78DCCB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78DE794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id *location, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23)
{
  objc_destroyWeak(location);
  objc_destroyWeak(&a23);
  _Unwind_Resume(a1);
}

BOOL HDCodableSharingAuthorizationReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
        break;
      if ((_DWORD)v17 == 2)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 16;
        goto LABEL_24;
      }
      if ((_DWORD)v17 == 1)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 8;
LABEL_24:
        v20 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_26:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    PBReaderReadString();
    v18 = objc_claimAutoreleasedReturnValue();
    v19 = 24;
    goto LABEL_24;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

BOOL HDCodableNotificationInstructionRequestReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  HDCodableNotificationInstructionMessage *v18;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(HDCodableNotificationInstructionMessage **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v17;
LABEL_24:

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_26:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v18 = objc_alloc_init(HDCodableNotificationInstructionMessage);
    objc_storeStrong((id *)(a1 + 8), v18);
    if (!PBReaderPlaceMark()
      || (HDCodableNotificationInstructionMessageReadFrom((uint64_t)v18, a2) & 1) == 0)
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_24;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

id getSOSUtilitiesClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)_MergedGlobals_199;
  v7 = _MergedGlobals_199;
  if (!_MergedGlobals_199)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getSOSUtilitiesClass_block_invoke;
    v3[3] = &unk_1E6CECDD0;
    v3[4] = &v4;
    __getSOSUtilitiesClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1B78E3F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getSOSUtilitiesClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;

  if (!qword_1ED552210)
    qword_1ED552210 = _sl_dlopen();
  if (!qword_1ED552210)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *SOSLibrary(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("HDMedicalIDDataManager.m"), 42, CFSTR("%s"), 0);

    goto LABEL_8;
  }
  result = objc_getClass("SOSUtilities");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getSOSUtilitiesClass(void)_block_invoke");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("HDMedicalIDDataManager.m"), 43, CFSTR("Unable to find class %s"), "SOSUtilities");

LABEL_8:
    __break(1u);
  }
  _MergedGlobals_199 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1B78E5F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B78E6BB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78E6EA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B78E722C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__29(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__29(uint64_t a1)
{

}

void sub_1B78E74BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  va_list va;

  va_start(va, a7);
  std::vector<std::tuple<long long,HKSample * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

void sub_1B78E75AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78E7640(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B78E7700(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B78E794C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1B78E7B24(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::tuple<long long,HKSample * {__strong}>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;

  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

char *std::vector<std::tuple<long long,HKSample * {__strong}>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void std::vector<std::tuple<long long,HKSample * {__strong}>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  id *v2;
  id *v4;
  void *v5;
  id *v6;

  v1 = *a1;
  v2 = (id *)**a1;
  if (v2)
  {
    v4 = (id *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 2;

        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::tuple<long long,HKSample * {__strong}>>::__vdeallocate(void **a1)
{
  id *v1;
  id *v3;
  void *v4;
  id *v5;

  v1 = (id *)*a1;
  if (*a1)
  {
    v3 = (id *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = v3 - 2;

        v3 = v5;
      }
      while (v5 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<std::tuple<long long,HKSample * {__strong}>>::__init_with_size[abi:ne180100]<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(_QWORD *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::tuple<long long,HKSample * {__strong}>>::__vallocate[abi:ne180100](result, a4);
    return std::vector<std::tuple<long long,HKSample * {__strong}>>::__construct_at_end<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(v6, a2, a3);
  }
  return result;
}

void sub_1B78E7DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::tuple<long long,HKSample * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::tuple<long long,HKSample * {__strong}>>::__construct_at_end<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(_QWORD *result, uint64_t *a2, uint64_t *a3)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t *v6;
  uint64_t v7;
  void *v8;

  v3 = result;
  v4 = (_QWORD *)result[1];
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      v7 = *v6;
      v8 = (void *)v6[1];
      v6 += 2;
      *v4 = v7;
      result = v8;
      v4[1] = result;
      v4 += 2;
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

_QWORD *std::vector<std::tuple<long long,HKDeletedObject * {__strong}>>::__init_with_size[abi:ne180100]<std::tuple<long long,HKDeletedObject * {__strong}>*,std::tuple<long long,HKDeletedObject * {__strong}>*>(_QWORD *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::tuple<long long,HKSample * {__strong}>>::__vallocate[abi:ne180100](result, a4);
    return std::vector<std::tuple<long long,HKSample * {__strong}>>::__construct_at_end<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(v6, a2, a3);
  }
  return result;
}

void sub_1B78E7E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::tuple<long long,HKSample * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t HDCloudSyncCodableSharedSummaryParticipantRecordReadFrom(_BYTE *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  int *v8;
  int *v9;
  char v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  BOOL v17;
  int v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  int *v23;
  int *v24;
  void *v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  char v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  char v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  void *v58;
  char v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char v64;
  uint64_t v65;
  uint64_t v66;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = &OBJC_IVAR___HDMedicalIDDataManager__profile;
    v8 = &OBJC_IVAR___HDMedicalIDDataManager__profile;
    v9 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      while (1)
      {
        v13 = *v3;
        v14 = *(_QWORD *)(a2 + v13);
        v15 = v14 + 1;
        if (v14 == -1 || v15 > *(_QWORD *)(a2 + *v4))
          break;
        v16 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v14);
        *(_QWORD *)(a2 + v13) = v15;
        v12 |= (unint64_t)(v16 & 0x7F) << v10;
        if ((v16 & 0x80) == 0)
          goto LABEL_12;
        v10 += 7;
        v17 = v11++ >= 9;
        if (v17)
        {
          v12 = 0;
          v18 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v18 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v12 = 0;
LABEL_14:
      if (v18 || (v12 & 7) == 4)
        break;
      switch((v12 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = v7[46];
          goto LABEL_70;
        case 2u:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = v8[47];
          goto LABEL_70;
        case 3u:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 80;
          goto LABEL_70;
        case 4u:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 88;
          goto LABEL_70;
        case 5u:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 112;
          goto LABEL_70;
        case 0xAu:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 104;
          goto LABEL_70;
        case 0xBu:
          PBReaderReadString();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 120;
          goto LABEL_70;
        case 0xCu:
          v23 = v8;
          v24 = v7;
          PBReaderReadString();
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          if (v25)
            objc_msgSend(a1, "addAllContactIdentifiers:", v25);

          v7 = v24;
          v8 = v23;
          continue;
        case 0x14u:
          v26 = 0;
          v27 = 0;
          v28 = 0;
          a1[152] |= 0x40u;
          while (2)
          {
            v29 = *v3;
            v30 = *(_QWORD *)(a2 + v29);
            v31 = v30 + 1;
            if (v30 == -1 || v31 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v32 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v30);
              *(_QWORD *)(a2 + v29) = v31;
              v28 |= (unint64_t)(v32 & 0x7F) << v26;
              if (v32 < 0)
              {
                v26 += 7;
                v17 = v27++ >= 9;
                if (v17)
                {
                  v28 = 0;
                  goto LABEL_81;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            v28 = 0;
LABEL_81:
          v65 = 56;
          goto LABEL_98;
        case 0x15u:
          v33 = 0;
          v34 = 0;
          v28 = 0;
          a1[152] |= 1u;
          while (2)
          {
            v35 = *v3;
            v36 = *(_QWORD *)(a2 + v35);
            v37 = v36 + 1;
            if (v36 == -1 || v37 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v38 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v36);
              *(_QWORD *)(a2 + v35) = v37;
              v28 |= (unint64_t)(v38 & 0x7F) << v33;
              if (v38 < 0)
              {
                v33 += 7;
                v17 = v34++ >= 9;
                if (v17)
                {
                  v28 = 0;
                  goto LABEL_85;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            v28 = 0;
LABEL_85:
          v65 = 8;
          goto LABEL_98;
        case 0x16u:
          v39 = 0;
          v40 = 0;
          v28 = 0;
          a1[152] |= 0x20u;
          while (2)
          {
            v41 = *v3;
            v42 = *(_QWORD *)(a2 + v41);
            v43 = v42 + 1;
            if (v42 == -1 || v43 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v44 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v42);
              *(_QWORD *)(a2 + v41) = v43;
              v28 |= (unint64_t)(v44 & 0x7F) << v39;
              if (v44 < 0)
              {
                v39 += 7;
                v17 = v40++ >= 9;
                if (v17)
                {
                  v28 = 0;
                  goto LABEL_89;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            v28 = 0;
LABEL_89:
          v65 = 48;
          goto LABEL_98;
        case 0x17u:
          v45 = 0;
          v46 = 0;
          v28 = 0;
          a1[152] |= 0x10u;
          while (2)
          {
            v47 = *v3;
            v48 = *(_QWORD *)(a2 + v47);
            v49 = v48 + 1;
            if (v48 == -1 || v49 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v50 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v48);
              *(_QWORD *)(a2 + v47) = v49;
              v28 |= (unint64_t)(v50 & 0x7F) << v45;
              if (v50 < 0)
              {
                v45 += 7;
                v17 = v46++ >= 9;
                if (v17)
                {
                  v28 = 0;
                  goto LABEL_93;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            v28 = 0;
LABEL_93:
          v65 = 40;
          goto LABEL_98;
        case 0x1Eu:
          a1[152] |= 8u;
          v51 = *v3;
          v52 = *(_QWORD *)(a2 + v51);
          if (v52 <= 0xFFFFFFFFFFFFFFF7 && v52 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v53 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v52);
            *(_QWORD *)(a2 + v51) = v52 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v53 = 0;
          }
          v66 = 32;
          goto LABEL_105;
        case 0x1Fu:
          a1[152] |= 4u;
          v54 = *v3;
          v55 = *(_QWORD *)(a2 + v54);
          if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v53 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v55);
            *(_QWORD *)(a2 + v54) = v55 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v53 = 0;
          }
          v66 = 24;
          goto LABEL_105;
        case 0x20u:
          a1[152] |= 2u;
          v56 = *v3;
          v57 = *(_QWORD *)(a2 + v56);
          if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v53 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v57);
            *(_QWORD *)(a2 + v56) = v57 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v53 = 0;
          }
          v66 = 16;
LABEL_105:
          *(_QWORD *)&a1[v66] = v53;
          continue;
        case 0x21u:
          PBReaderReadData();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 128;
          goto LABEL_70;
        case 0x28u:
          PBReaderReadData();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = 136;
LABEL_70:
          v58 = *(void **)&a1[v21];
          *(_QWORD *)&a1[v21] = v20;

          continue;
        case 0x29u:
          v59 = 0;
          v60 = 0;
          v28 = 0;
          a1[152] |= 0x80u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v61 = *v3;
        v62 = *(_QWORD *)(a2 + v61);
        v63 = v62 + 1;
        if (v62 == -1 || v63 > *(_QWORD *)(a2 + *v4))
          break;
        v64 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v62);
        *(_QWORD *)(a2 + v61) = v63;
        v28 |= (unint64_t)(v64 & 0x7F) << v59;
        if ((v64 & 0x80) == 0)
          goto LABEL_95;
        v59 += 7;
        v17 = v60++ >= 9;
        if (v17)
        {
          v28 = 0;
          goto LABEL_97;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_95:
      if (*(_BYTE *)(a2 + *v5))
        v28 = 0;
LABEL_97:
      v65 = 64;
LABEL_98:
      *(_QWORD *)&a1[v65] = v28;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B78EEF64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableVisionSampleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableSample *v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t result;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  void *v74;
  uint64_t v75;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v18 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 208), v18);
        if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2) & 1) != 0)
          goto LABEL_102;
        goto LABEL_154;
      case 2u:
        v19 = 0;
        v20 = 0;
        v21 = 0;
        *(_DWORD *)(a1 + 224) |= 0x800u;
        while (2)
        {
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          v24 = v23 + 1;
          if (v23 == -1 || v24 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v25 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
            *(_QWORD *)(a2 + v22) = v24;
            v21 |= (unint64_t)(v25 & 0x7F) << v19;
            if (v25 < 0)
            {
              v19 += 7;
              v15 = v20++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_106;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_106:
        *(_QWORD *)(a1 + 96) = v21;
        goto LABEL_152;
      case 3u:
        *(_DWORD *)(a1 + 224) |= 0x200u;
        v26 = *v3;
        v27 = *(_QWORD *)(a2 + v26);
        if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v27);
          *(_QWORD *)(a2 + v26) = v27 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 80;
        goto LABEL_151;
      case 4u:
        *(_DWORD *)(a1 + 224) |= 0x200000u;
        v29 = *v3;
        v30 = *(_QWORD *)(a2 + v29);
        if (v30 <= 0xFFFFFFFFFFFFFFF7 && v30 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v30);
          *(_QWORD *)(a2 + v29) = v30 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 176;
        goto LABEL_151;
      case 5u:
        *(_DWORD *)(a1 + 224) |= 0x10u;
        v31 = *v3;
        v32 = *(_QWORD *)(a2 + v31);
        if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v32);
          *(_QWORD *)(a2 + v31) = v32 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 40;
        goto LABEL_151;
      case 6u:
        *(_DWORD *)(a1 + 224) |= 0x10000u;
        v33 = *v3;
        v34 = *(_QWORD *)(a2 + v33);
        if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v34);
          *(_QWORD *)(a2 + v33) = v34 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 136;
        goto LABEL_151;
      case 7u:
        *(_DWORD *)(a1 + 224) |= 2u;
        v35 = *v3;
        v36 = *(_QWORD *)(a2 + v35);
        if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v36);
          *(_QWORD *)(a2 + v35) = v36 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 16;
        goto LABEL_151;
      case 8u:
        *(_DWORD *)(a1 + 224) |= 0x2000u;
        v37 = *v3;
        v38 = *(_QWORD *)(a2 + v37);
        if (v38 <= 0xFFFFFFFFFFFFFFF7 && v38 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v38);
          *(_QWORD *)(a2 + v37) = v38 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 112;
        goto LABEL_151;
      case 9u:
        *(_DWORD *)(a1 + 224) |= 1u;
        v39 = *v3;
        v40 = *(_QWORD *)(a2 + v39);
        if (v40 <= 0xFFFFFFFFFFFFFFF7 && v40 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v40);
          *(_QWORD *)(a2 + v39) = v40 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 8;
        goto LABEL_151;
      case 0xAu:
        *(_DWORD *)(a1 + 224) |= 0x1000u;
        v41 = *v3;
        v42 = *(_QWORD *)(a2 + v41);
        if (v42 <= 0xFFFFFFFFFFFFFFF7 && v42 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v42);
          *(_QWORD *)(a2 + v41) = v42 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 104;
        goto LABEL_151;
      case 0x1Eu:
        *(_DWORD *)(a1 + 224) |= 0x400u;
        v44 = *v3;
        v45 = *(_QWORD *)(a2 + v44);
        if (v45 <= 0xFFFFFFFFFFFFFFF7 && v45 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v45);
          *(_QWORD *)(a2 + v44) = v45 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 88;
        goto LABEL_151;
      case 0x1Fu:
        *(_DWORD *)(a1 + 224) |= 0x400000u;
        v46 = *v3;
        v47 = *(_QWORD *)(a2 + v46);
        if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v47);
          *(_QWORD *)(a2 + v46) = v47 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 184;
        goto LABEL_151;
      case 0x20u:
        *(_DWORD *)(a1 + 224) |= 0x80u;
        v48 = *v3;
        v49 = *(_QWORD *)(a2 + v48);
        if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v49);
          *(_QWORD *)(a2 + v48) = v49 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 64;
        goto LABEL_151;
      case 0x21u:
        *(_DWORD *)(a1 + 224) |= 0x80000u;
        v50 = *v3;
        v51 = *(_QWORD *)(a2 + v50);
        if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v51);
          *(_QWORD *)(a2 + v50) = v51 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 160;
        goto LABEL_151;
      case 0x22u:
        *(_DWORD *)(a1 + 224) |= 0x100u;
        v52 = *v3;
        v53 = *(_QWORD *)(a2 + v52);
        if (v53 <= 0xFFFFFFFFFFFFFFF7 && v53 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v53);
          *(_QWORD *)(a2 + v52) = v53 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 72;
        goto LABEL_151;
      case 0x23u:
        *(_DWORD *)(a1 + 224) |= 0x100000u;
        v54 = *v3;
        v55 = *(_QWORD *)(a2 + v54);
        if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v55);
          *(_QWORD *)(a2 + v54) = v55 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 168;
        goto LABEL_151;
      case 0x24u:
        *(_DWORD *)(a1 + 224) |= 0x20u;
        v56 = *v3;
        v57 = *(_QWORD *)(a2 + v56);
        if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v57);
          *(_QWORD *)(a2 + v56) = v57 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 48;
        goto LABEL_151;
      case 0x25u:
        *(_DWORD *)(a1 + 224) |= 0x20000u;
        v58 = *v3;
        v59 = *(_QWORD *)(a2 + v58);
        if (v59 <= 0xFFFFFFFFFFFFFFF7 && v59 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v59);
          *(_QWORD *)(a2 + v58) = v59 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 144;
        goto LABEL_151;
      case 0x26u:
        *(_DWORD *)(a1 + 224) |= 0x40u;
        v60 = *v3;
        v61 = *(_QWORD *)(a2 + v60);
        if (v61 <= 0xFFFFFFFFFFFFFFF7 && v61 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v61);
          *(_QWORD *)(a2 + v60) = v61 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 56;
        goto LABEL_151;
      case 0x27u:
        *(_DWORD *)(a1 + 224) |= 0x40000u;
        v62 = *v3;
        v63 = *(_QWORD *)(a2 + v62);
        if (v63 <= 0xFFFFFFFFFFFFFFF7 && v63 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v63);
          *(_QWORD *)(a2 + v62) = v63 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 152;
        goto LABEL_151;
      case 0x29u:
        PBReaderReadString();
        v64 = objc_claimAutoreleasedReturnValue();
        v65 = 200;
        goto LABEL_99;
      case 0x32u:
        *(_DWORD *)(a1 + 224) |= 4u;
        v66 = *v3;
        v67 = *(_QWORD *)(a2 + v66);
        if (v67 <= 0xFFFFFFFFFFFFFFF7 && v67 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v67);
          *(_QWORD *)(a2 + v66) = v67 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 24;
        goto LABEL_151;
      case 0x33u:
        *(_DWORD *)(a1 + 224) |= 0x4000u;
        v68 = *v3;
        v69 = *(_QWORD *)(a2 + v68);
        if (v69 <= 0xFFFFFFFFFFFFFFF7 && v69 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v69);
          *(_QWORD *)(a2 + v68) = v69 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 120;
        goto LABEL_151;
      case 0x34u:
        *(_DWORD *)(a1 + 224) |= 8u;
        v70 = *v3;
        v71 = *(_QWORD *)(a2 + v70);
        if (v71 <= 0xFFFFFFFFFFFFFFF7 && v71 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v71);
          *(_QWORD *)(a2 + v70) = v71 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 32;
        goto LABEL_151;
      case 0x35u:
        *(_DWORD *)(a1 + 224) |= 0x8000u;
        v72 = *v3;
        v73 = *(_QWORD *)(a2 + v72);
        if (v73 <= 0xFFFFFFFFFFFFFFF7 && v73 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v73);
          *(_QWORD *)(a2 + v72) = v73 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v75 = 128;
LABEL_151:
        *(_QWORD *)(a1 + v75) = v28;
        goto LABEL_152;
      case 0x36u:
        PBReaderReadString();
        v64 = objc_claimAutoreleasedReturnValue();
        v65 = 192;
LABEL_99:
        v74 = *(void **)(a1 + v65);
        *(_QWORD *)(a1 + v65) = v64;

        goto LABEL_152;
      case 0x37u:
        v18 = objc_alloc_init(HDCodableVerifiableData);
        objc_storeStrong((id *)(a1 + 216), v18);
        if (PBReaderPlaceMark() && (HDCodableVerifiableDataReadFrom((uint64_t)v18, a2) & 1) != 0)
        {
LABEL_102:
          PBReaderRecallMark();

LABEL_152:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_154:

        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_152;
    }
  }
}

void sub_1B78F404C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B78F4AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose(&a41, 8);
  _Unwind_Resume(a1);
}

void sub_1B78F5870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__30(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__30(uint64_t a1)
{

}

uint64_t HDCodableAuthorizationResponseMessageReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  char v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  void *v26;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 8;
          goto LABEL_32;
        case 2u:
          PBReaderReadData();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 32;
          goto LABEL_32;
        case 0xAu:
          v20 = 0;
          v21 = 0;
          v22 = 0;
          *(_BYTE *)(a1 + 44) |= 1u;
          break;
        case 0xBu:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 24;
          goto LABEL_32;
        case 0xCu:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
LABEL_32:
          v26 = *(void **)(a1 + v18);
          *(_QWORD *)(a1 + v18) = v17;

          continue;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v23 = *v3;
        v24 = *(_QWORD *)(a2 + v23);
        if (v24 == -1 || v24 >= *(_QWORD *)(a2 + *v4))
          break;
        v25 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v24);
        *(_QWORD *)(a2 + v23) = v24 + 1;
        v22 |= (unint64_t)(v25 & 0x7F) << v20;
        if ((v25 & 0x80) == 0)
          goto LABEL_34;
        v20 += 7;
        v14 = v21++ >= 9;
        if (v14)
        {
          v22 = 0;
          goto LABEL_36;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_34:
      if (*(_BYTE *)(a2 + *v5))
        v22 = 0;
LABEL_36:
      *(_BYTE *)(a1 + 40) = v22 != 0;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B78F8430(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1B78F9C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  id *v18;

  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B78FD04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_1B78FED8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void sub_1B78FF630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void sub_1B79006F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  id *v24;

  objc_destroyWeak(v24);
  objc_destroyWeak(location);
  objc_destroyWeak(&a24);
  _Unwind_Resume(a1);
}

void sub_1B7901830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  char a68;

  _Block_object_dispose(&a62, 8);
  _Block_object_dispose(&a68, 8);
  _Unwind_Resume(a1);
}

void sub_1B790341C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *location)
{
  uint64_t v11;

  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v11 - 184));
  _Unwind_Resume(a1);
}

id _StringFromSyncOptions(char a1)
{
  void *v2;
  void *v3;
  void *v4;

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  if ((a1 & 1) != 0)
  {
    objc_msgSend(v2, "addObject:", CFSTR("pull request"));
    if ((a1 & 2) == 0)
    {
LABEL_3:
      if ((a1 & 4) == 0)
        goto LABEL_4;
LABEL_9:
      objc_msgSend(v3, "addObject:", CFSTR("active only"));
      if ((a1 & 8) == 0)
        goto LABEL_6;
      goto LABEL_5;
    }
  }
  else if ((a1 & 2) == 0)
  {
    goto LABEL_3;
  }
  objc_msgSend(v3, "addObject:", CFSTR("last chance"));
  if ((a1 & 4) != 0)
    goto LABEL_9;
LABEL_4:
  if ((a1 & 8) != 0)
LABEL_5:
    objc_msgSend(v3, "addObject:", CFSTR("requested by remote"));
LABEL_6:
  objc_msgSend(v3, "componentsJoinedByString:", CFSTR(", "));
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_1B7903C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__31(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__31(uint64_t a1)
{

}

void sub_1B7905CC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

uint64_t HDAddStateHandler(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  uint64_t v6;
  id v8;
  id v9;

  v8 = a2;
  v9 = a3;
  v4 = v8;
  v5 = v9;
  v6 = os_state_add_handler();

  return v6;
}

void sub_1B790BF9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__32(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__32(uint64_t a1)
{

}

BOOL HDCloudSyncCodableMedicalIDReadFrom(id *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableMedicalIDData *v17;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableMedicalIDData);
        objc_storeStrong(a1 + 1, v17);
        if (!PBReaderPlaceMark() || !-[HDCodableMedicalIDData readFrom:](v17, "readFrom:", a2, 0, 0))
          goto LABEL_30;
LABEL_25:
        PBReaderRecallMark();

        goto LABEL_27;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_27:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v17 = objc_alloc_init(HDCloudSyncCodableLog);
    objc_msgSend(a1, "addMedicalIDLogs:", v17);
    if (!PBReaderPlaceMark() || (HDCloudSyncCodableLogReadFrom((uint64_t)v17, a2) & 1) == 0)
    {
LABEL_30:

      return 0;
    }
    goto LABEL_25;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B790E0DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__33(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__33(uint64_t a1)
{

}

void sub_1B790EB68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1B790F800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDWorkoutActivityEntityPredicateForActivityType(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:value:comparisonType:", CFSTR("activity_type"), v2, 1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

id HDWorkoutActivityEntityPredicateForDuration(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("duration"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDWorkoutActivityEntityPredicateForStartDate(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForDate();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("start_date"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDWorkoutActivityEntityPredicateForEndDate(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForDate();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("end_date"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_1B7911610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7913674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__34(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__34(uint64_t a1)
{

}

void sub_1B7913DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7913F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__35(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__35(uint64_t a1)
{

}

void sub_1B7914E2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1B79158E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_1B7915C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1B79171B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7918B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a38, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__36(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__36(uint64_t a1)
{

}

id QuantityCharacteristicTypes()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  _QWORD v5[4];

  v5[3] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB6978], "characteristicTypeForIdentifier:", *MEMORY[0x1E0CB7118]);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB6978], "characteristicTypeForIdentifier:", *MEMORY[0x1E0CB7130], v0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v5[1] = v1;
  objc_msgSend(MEMORY[0x1E0CB6978], "characteristicTypeForIdentifier:", *MEMORY[0x1E0CB7128]);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v5[2] = v2;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v5, 3);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1B791E710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

void sub_1B791F314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__37(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__37(uint64_t a1)
{

}

void sub_1B79202A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id location,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,id a38)
{
  id *v38;

  objc_destroyWeak(v38);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

BOOL HDCodableStartWorkoutAppRequestReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  HDCodableWorkoutConfiguration *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      if (v9++ >= 9)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 16;
        goto LABEL_27;
      case 2u:
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 8;
        goto LABEL_27;
      case 3u:
        v19 = objc_alloc_init(HDCodableWorkoutConfiguration);
        objc_storeStrong((id *)(a1 + 24), v19);
        if (PBReaderPlaceMark() && (HDCodableWorkoutConfigurationReadFrom((uint64_t)v19, a2) & 1) != 0)
        {
          PBReaderRecallMark();
LABEL_28:

LABEL_29:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      case 4u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 32;
LABEL_27:
        v19 = *(HDCodableWorkoutConfiguration **)(a1 + v18);
        *(_QWORD *)(a1 + v18) = v17;
        goto LABEL_28;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0)
          return 0;
        goto LABEL_29;
    }
  }
}

id HDAlarmEventEntityAllProperties()
{
  _QWORD v1[7];

  v1[6] = *MEMORY[0x1E0C80C00];
  v1[0] = CFSTR("client_identifier");
  v1[1] = CFSTR("event_identifier");
  v1[2] = CFSTR("due_date");
  v1[3] = CFSTR("due_date_components");
  v1[4] = CFSTR("event_options");
  v1[5] = CFSTR("client_options");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v1, 6);
  return (id)objc_claimAutoreleasedReturnValue();
}

void sub_1B79236EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__38(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__38(uint64_t a1)
{

}

void sub_1B79285DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7929500(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__39(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__39(uint64_t a1)
{

}

void sub_1B7929770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79299AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1B7929ED0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

id HDAuthorizationIdentifiersFromCodableSharingAuthorizations(void *a1)
{
  id v1;
  id v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[128];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v3 = v1;
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v11;
      do
      {
        for (i = 0; i != v5; ++i)
        {
          if (*(_QWORD *)v11 != v6)
            objc_enumerationMutation(v3);
          objc_msgSend(*(id *)(*((_QWORD *)&v10 + 1) + 8 * i), "authorizationIdentifier", (_QWORD)v10);
          v8 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v2, "addObject:", v8);

        }
        v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v14, 16);
      }
      while (v5);
    }

  }
  else
  {
    v2 = 0;
  }

  return v2;
}

id HDSharingAuthorizationsFromCodableSharingAuthorizations(void *a1)
{
  if (a1)
  {
    objc_msgSend(a1, "hk_map:", &__block_literal_global_47);
    a1 = (void *)objc_claimAutoreleasedReturnValue();
  }
  return a1;
}

id HDCodableSharingAuthorizationsFromSharingAuthorizations(void *a1)
{
  id v1;
  id v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  HDCodableSharingAuthorization *v9;
  HDCodableSharingAuthorization *v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v3 = v1;
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v13;
      do
      {
        for (i = 0; i != v5; ++i)
        {
          if (*(_QWORD *)v13 != v6)
            objc_enumerationMutation(v3);
          v8 = *(_QWORD *)(*((_QWORD *)&v12 + 1) + 8 * i);
          v9 = [HDCodableSharingAuthorization alloc];
          v10 = -[HDCodableSharingAuthorization initWithSharingAuthorization:](v9, "initWithSharingAuthorization:", v8, (_QWORD)v12);
          objc_msgSend(v2, "addObject:", v10);

        }
        v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      }
      while (v5);
    }

  }
  else
  {
    v2 = 0;
  }

  return v2;
}

id HDCodableSharingAuthorizationsFromAuthorizationIdentifiers(void *a1)
{
  id v1;
  id v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  HDCodableSharingAuthorization *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v3 = v1;
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v12;
      do
      {
        for (i = 0; i != v5; ++i)
        {
          if (*(_QWORD *)v12 != v6)
            objc_enumerationMutation(v3);
          v8 = *(_QWORD *)(*((_QWORD *)&v11 + 1) + 8 * i);
          v9 = objc_alloc_init(HDCodableSharingAuthorization);
          -[HDCodableSharingAuthorization setAuthorizationIdentifier:](v9, "setAuthorizationIdentifier:", v8, (_QWORD)v11);
          objc_msgSend(v2, "addObject:", v9);

        }
        v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
      }
      while (v5);
    }

  }
  else
  {
    v2 = 0;
  }

  return v2;
}

uint64_t HDCPSDefaultEnvironment()
{
  return objc_msgSend(MEMORY[0x1E0CB6F18], "isAppleInternalInstall");
}

const __CFString *HDCPSNameForEnvironment(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0xD)
    return CFSTR("Production");
  else
    return off_1E6CEF3E0[a1 - 1];
}

id HDHealthDaemonFrameworkBundle()
{
  void *v0;
  uint64_t v1;
  void *v2;

  v0 = (void *)HDHealthDaemonFrameworkBundle___ClassBundle;
  if (!HDHealthDaemonFrameworkBundle___ClassBundle)
  {
    objc_msgSend(MEMORY[0x1E0CB34D0], "bundleForClass:", objc_opt_class());
    v1 = objc_claimAutoreleasedReturnValue();
    v2 = (void *)HDHealthDaemonFrameworkBundle___ClassBundle;
    HDHealthDaemonFrameworkBundle___ClassBundle = v1;

    v0 = (void *)HDHealthDaemonFrameworkBundle___ClassBundle;
  }
  return v0;
}

__CFString *HDStringFromDatabaseJournalType(unint64_t a1)
{
  if (a1 < 3)
    return off_1E6CEF450[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%ld)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

void sub_1B792B57C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B792C76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__40(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__40(uint64_t a1)
{

}

void sub_1B792D7F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B792DD88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__41(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__41(uint64_t a1)
{

}

void sub_1B792F108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__42(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__42(uint64_t a1)
{

}

uint64_t HDCloudSyncCodableAttachmentManagementReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  void *v18;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(void **)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v17;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

BOOL HDCodableSourceAuthorizationReadFrom(id *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  HDCodableAuthorization *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      if (v9++ >= 9)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 4;
        goto LABEL_26;
      case 2u:
        v19 = objc_alloc_init(HDCodableAuthorization);
        objc_msgSend(a1, "addAuthorizations:", v19);
        if (!PBReaderPlaceMark() || (HDCodableAuthorizationReadFrom((uint64_t)v19, a2) & 1) == 0)
          goto LABEL_34;
        goto LABEL_29;
      case 3u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 2;
LABEL_26:
        v19 = (HDCodableAuthorization *)a1[v18];
        a1[v18] = (id)v17;
        goto LABEL_30;
      case 4u:
        v19 = objc_alloc_init(HDCodableSource);
        objc_storeStrong(a1 + 3, v19);
        if (PBReaderPlaceMark() && (HDCodableSourceReadFrom((uint64_t)v19, a2) & 1) != 0)
        {
LABEL_29:
          PBReaderRecallMark();
LABEL_30:

LABEL_31:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_34:

        return 0;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0)
          return 0;
        goto LABEL_31;
    }
  }
}

uint64_t HDSharingTypeFromCodableType(int a1)
{
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  if (a1 == 1)
    return 1;
  _HKInitializeLogging();
  v3 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_FAULT))
  {
    v4 = 134217984;
    v5 = a1;
    _os_log_fault_impl(&dword_1B7802000, v3, OS_LOG_TYPE_FAULT, "Unexpected codable type %ld", (uint8_t *)&v4, 0xCu);
  }
  return 0;
}

uint64_t HDSharingMessageDirectionFromCodableDirection(int a1)
{
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1 == 1)
    return 1;
  if (!a1)
    return 0;
  _HKInitializeLogging();
  v3 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_FAULT))
  {
    v4 = 134217984;
    v5 = a1;
    _os_log_fault_impl(&dword_1B7802000, v3, OS_LOG_TYPE_FAULT, "Unexpected codable direction %ld", (uint8_t *)&v4, 0xCu);
  }
  return 1;
}

uint64_t HDSharingStatusFromCodableStatus(uint64_t result)
{
  int v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  v5 = *MEMORY[0x1E0C80C00];
  if (result < 5)
    return result;
  _HKInitializeLogging();
  v2 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_FAULT))
  {
    v3 = 134217984;
    v4 = v1;
    _os_log_fault_impl(&dword_1B7802000, v2, OS_LOG_TYPE_FAULT, "Unexpected codable status %ld", (uint8_t *)&v3, 0xCu);
  }
  return 0;
}

unint64_t HDCodableSharingStatusFromStatus(unint64_t a1)
{
  unint64_t v1;
  NSObject *v2;
  int v4;
  unint64_t v5;
  uint64_t v6;

  v1 = a1;
  v6 = *MEMORY[0x1E0C80C00];
  if (a1 >= 5)
  {
    _HKInitializeLogging();
    v2 = *MEMORY[0x1E0CB5370];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_FAULT))
    {
      v4 = 134217984;
      v5 = v1;
      _os_log_fault_impl(&dword_1B7802000, v2, OS_LOG_TYPE_FAULT, "Unexpected status %ld", (uint8_t *)&v4, 0xCu);
    }
    return 0;
  }
  return v1;
}

uint64_t HDSharingNotificationStatusFromCodableStatus(uint64_t result)
{
  int v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  v5 = *MEMORY[0x1E0C80C00];
  if (result < 3)
    return result;
  _HKInitializeLogging();
  v2 = *MEMORY[0x1E0CB5370];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_FAULT))
  {
    v3 = 134217984;
    v4 = v1;
    _os_log_fault_impl(&dword_1B7802000, v2, OS_LOG_TYPE_FAULT, "Unexpected codable notification status %ld", (uint8_t *)&v3, 0xCu);
  }
  return 0;
}

unint64_t HDCodableSharingNotificationStatusFromStatus(unint64_t a1)
{
  unint64_t v1;
  NSObject *v2;
  int v4;
  unint64_t v5;
  uint64_t v6;

  v1 = a1;
  v6 = *MEMORY[0x1E0C80C00];
  if (a1 >= 3)
  {
    _HKInitializeLogging();
    v2 = *MEMORY[0x1E0CB5370];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB5370], OS_LOG_TYPE_FAULT))
    {
      v4 = 134217984;
      v5 = v1;
      _os_log_fault_impl(&dword_1B7802000, v2, OS_LOG_TYPE_FAULT, "Unexpected notification status %ld", (uint8_t *)&v4, 0xCu);
    }
    return 0;
  }
  return v1;
}

void sub_1B79353B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDOntologyShardRegistryPredicateForEntry(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  _QWORD v16[4];

  v16[3] = *MEMORY[0x1E0C80C00];
  v5 = (void *)MEMORY[0x1E0D29840];
  v6 = (void *)MEMORY[0x1E0D29838];
  v7 = a2;
  objc_msgSend(v6, "predicateWithProperty:equalToValue:", CFSTR("identifier"), a1);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("schema_type"), v7, v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  v16[1] = v9;
  v10 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a3);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "predicateWithProperty:equalToValue:", CFSTR("schema_version"), v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v16[2] = v12;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v16, 3);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "predicateMatchingAllPredicates:", v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  return v14;
}

uint64_t __Block_byref_object_copy__43(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__43(uint64_t a1)
{

}

void sub_1B7935D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1B79360DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7936F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7937260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79377F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

id HDOntologyShardRegistryPredicateForCurrentSchemaEntry(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v4;

  v1 = a1;
  HKOntologyShardSchemaTypeForShardIdentifier();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = HKCurrentSchemaVersionForShardIdentifier();
  HDOntologyShardRegistryPredicateForEntry((uint64_t)v1, v2, v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

uint64_t HDCloudSyncCodableStateReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  void *v18;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(void **)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v17;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7938EEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7939458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__44(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__44(uint64_t a1)
{

}

void sub_1B793C1B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  uint64_t v48;

  _Block_object_dispose((const void *)(v48 - 176), 8);
  _Block_object_dispose(&a48, 8);
  _Unwind_Resume(a1);
}

void sub_1B793C4C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1B793D420(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1B793D4C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B793D5F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B793D6B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double std::normal_distribution<double>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(uint64_t a1, unsigned int *a2, double *a3)
{
  double v5;
  double v7;
  double v8;
  double v9;
  double v10;

  if (*(_BYTE *)(a1 + 24))
  {
    *(_BYTE *)(a1 + 24) = 0;
    v5 = *(double *)(a1 + 16);
  }
  else
  {
    do
    {
      do
      {
        v7 = std::generate_canonical[abi:ne180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(a2)
           * 2.0
           + -1.0;
        v8 = std::generate_canonical[abi:ne180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(a2)
           * 2.0
           + -1.0;
        v9 = v8 * v8 + v7 * v7;
      }
      while (v9 > 1.0);
    }
    while (v9 == 0.0);
    v10 = sqrt(log(v8 * v8 + v7 * v7) * -2.0 / v9);
    *(double *)(a1 + 16) = v8 * v10;
    *(_BYTE *)(a1 + 24) = 1;
    v5 = v7 * v10;
  }
  return *a3 + v5 * a3[1];
}

double std::generate_canonical[abi:ne180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  BOOL v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;

  v1 = 48271 * (*a1 % 0xADC8);
  v2 = 3399 * (*a1 / 0xADC8);
  v3 = v1 >= v2;
  v4 = v1 - v2;
  if (v3)
    v5 = 0;
  else
    v5 = 0x7FFFFFFF;
  v6 = v5 + v4;
  v7 = v6 - 1;
  v8 = v6 / 0xADC8;
  v9 = 48271 * (v6 % 0xADC8);
  v8 *= 3399;
  v3 = v9 >= v8;
  v10 = v9 - v8;
  if (v3)
    v11 = 0;
  else
    v11 = 0x7FFFFFFF;
  v12 = v11 + v10;
  *a1 = v12;
  return ((double)v7 + (double)(v12 - 1) * 2147483650.0) / 4.61168601e18;
}

void sub_1B793E6A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__45(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__45(uint64_t a1)
{

}

void sub_1B793E968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B793EAC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _HDSourceEntityPredicateForNotDeletedWithPredicate(void *a1)
{
  void *v1;
  id v2;
  void *v3;
  void *v4;

  v1 = (void *)MEMORY[0x1E0D29838];
  v2 = a1;
  objc_msgSend(v1, "predicateWithProperty:notEqualToValue:", CFSTR("deleted"), MEMORY[0x1E0C9AAB0]);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v2, v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_1B793F160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1B793F3F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B793F8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B793FBE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1B7940870(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1B7940D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7941190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSourceEntityPredicateForLocalSourcesWithBundleIdentifier(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = (void *)MEMORY[0x1E0D29890];
  HDSourceEntityPredicateForSourceWithBundleIdentifier(a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("provenance"), &unk_1E6DFACA0);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "compoundPredicateWithPredicate:otherPredicate:", v2, v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDSourceEntityPredicateForSourceWithBundleIdentifier(uint64_t a1)
{
  void *v1;
  void *v2;

  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("logical_sources.bundle_id"), a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  _HDSourceEntityPredicateForNotDeletedWithPredicate(v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

id HDSourceEntityPredicateForSourcesWithUUIDs(void *a1)
{
  void *v1;
  void *v2;

  objc_msgSend(a1, "hk_map:", &__block_literal_global_448);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("uuid"), v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

uint64_t HDSourceEntityPredicateForSourcesWithBundleIdentifiers(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("logical_sources.bundle_id"), a1);
}

uint64_t HDSourceEntityPredicateForSourcesWithOwnerBundleIdentifiers(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("logical_sources.owner_bundle_id"), a1);
}

id HDSourceEntityPredicateForLocalSourcesWithLogicalSourceIDs(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("logical_source_id"), a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = (void *)MEMORY[0x1E0D29890];
  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("provenance"), &unk_1E6DFACA0);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "compoundPredicateWithPredicate:otherPredicate:", v1, v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

uint64_t HDSourceEntityPredicateForSourcesWithLogicalSourceIDs(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("logical_source_id"), a1);
}

void sub_1B79445A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  char a67;

  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a57, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__46(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__46(uint64_t a1)
{

}

void sub_1B7945CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v37;

  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 224), 8);
  _Block_object_dispose((const void *)(v37 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1B79460EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1B794668C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1B7947168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7947610(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1B7947DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7948A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7948D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B794932C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

HDAssociationEntityParentIDPredicate *HDAssociationEntityPredicateForChildObjectsAssociatedWithParentObject(uint64_t a1)
{
  return +[HDAssociationEntityParentIDPredicate predicateWithParentID:](HDAssociationEntityParentIDPredicate, "predicateWithParentID:", a1);
}

HDAssociationEntityParentIDExistsPredicate *HDAssociationEntityPredicateForChildObjectsWhereAssocationExistsWithParentObject(uint64_t a1, uint64_t a2)
{
  return +[HDAssociationEntityParentIDExistsPredicate predicateWithParentID:exists:](HDAssociationEntityParentIDExistsPredicate, "predicateWithParentID:exists:", a1, a2);
}

HDAssociationEntityIsAssociatedPredicate *HDAssociationEntityPredicateForAssociatedObjects(uint64_t a1)
{
  return +[HDAssociationEntityIsAssociatedPredicate predicateWithInvertedCondition:](HDAssociationEntityIsAssociatedPredicate, "predicateWithInvertedCondition:", a1);
}

uint64_t HDAssociationEntityPredicateForChildEndDate(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:value:comparisonType:", CFSTR("child_id_samples.end_date"), a2, a1);
}

id HDAssociationEntityPredicateForAssociationEntityWithType(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:equalToValue:", CFSTR("type"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

id HDAssociationEntityPredicateForAssociationEntityForNotType(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:notEqualToValue:", CFSTR("type"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

HDAssociationEntityParentIDForTypePredicate *HDAssociationEntityPredicateForChildObjectsAssociatedWithParentObjectForType(uint64_t a1, uint64_t a2)
{
  return +[HDAssociationEntityParentIDForTypePredicate predicateWithParentID:type:](HDAssociationEntityParentIDForTypePredicate, "predicateWithParentID:type:", a1, a2);
}

uint64_t *HDStatisticsTimeInterval::addSample(uint64_t *this, const HDRawQuantitySample *a2, int a3)
{
  uint64_t *v4;
  double var1;
  double var2;
  double v7;

  if (a2->var4 && !a2->var5)
  {
    if (a3)
      ++*this;
    v4 = this + 1;
    var1 = a2->var1;
    var2 = a2->var2;
    if (var2 >= var1)
      v7 = a2->var1;
    else
      v7 = a2->var2;
    if (var1 < var2)
      var1 = a2->var2;
    return HKIntervalMask<double>::_insertInterval(v4, v7, var1);
  }
  return this;
}

double HDStatisticsTimeInterval::totalDuration(HDStatisticsTimeInterval *this)
{
  double *v1;
  double v2;
  double v3;
  double v4;

  v1 = (double *)*((_QWORD *)this + 1);
  v2 = 0.0;
  while (v1 != *((double **)this + 2))
  {
    v4 = *v1;
    v3 = v1[1];
    v1 += 2;
    v2 = v2 + v3 - v4;
  }
  return v2 + *((double *)this + 4);
}

double HDStatisticsTimeInterval::didMergeTo(double **this, double a2)
{
  double result;

  result = HKIntervalMask<double>::removeIntervalsBefore(this + 1, a2) + *((double *)this + 4);
  *((double *)this + 4) = result;
  return result;
}

double HKIntervalMask<double>::removeIntervalsBefore(double **a1, double a2)
{
  double *v2;
  double *v3;
  double v5;
  double *v6;
  double v7;
  double v8;
  int64_t v9;

  v3 = *a1;
  v2 = a1[1];
  if (*a1 == v2)
    return 0.0;
  v5 = 0.0;
  v6 = *a1;
  while (1)
  {
    v7 = *v6;
    if (*v6 >= a2)
      break;
    v8 = v6[1];
    if (v8 >= a2)
    {
      v5 = v5 + a2 - v7;
      *v6 = a2;
      break;
    }
    v5 = v5 + v8 - v7;
    v6 += 2;
    if (v6 == v2)
    {
      v6 = a1[1];
      break;
    }
  }
  if (v3 != v6)
  {
    v9 = (char *)v2 - (char *)v6;
    if (v2 != v6)
      memmove(v3, v6, (char *)v2 - (char *)v6);
    a1[1] = (double *)((char *)v3 + v9);
  }
  return v5;
}

double HDStatisticsTimeInterval::unarchive@<D0>(HDStatisticsTimeInterval *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  double result;

  *(_OWORD *)(a2 + 8) = 0u;
  v5 = (uint64_t *)(a2 + 8);
  *(_OWORD *)(a2 + 24) = 0u;
  *(_QWORD *)a2 = *((_QWORD *)this + 3);
  v6 = *((_QWORD *)this + 8);
  v7 = *((_QWORD *)this + 9);
  while (v6 != v7)
  {
    v9 = *(double *)(*(_QWORD *)v6 + 8);
    v8 = *(double *)(*(_QWORD *)v6 + 16);
    if (v9 >= v8)
      v10 = *(double *)(*(_QWORD *)v6 + 16);
    else
      v10 = *(double *)(*(_QWORD *)v6 + 8);
    if (v8 < v9)
      v8 = *(double *)(*(_QWORD *)v6 + 8);
    HKIntervalMask<double>::_insertInterval(v5, v10, v8);
    v6 += 8;
  }
  result = *((double *)this + 7);
  *(double *)(a2 + 32) = result;
  return result;
}

void sub_1B7949F08(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void HDStatisticsTimeInterval::archive(HDStatisticsTimeInterval *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  int8x16_t *v4;
  int8x16_t *i;
  void (**v6)(statistics::Interval *__hidden);
  int8x16_t v7;
  int v8;

  v3 = *(_QWORD *)this;
  v4 = (int8x16_t *)*((_QWORD *)this + 1);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = v3;
  *(_DWORD *)(a2 + 204) = 17;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  *(_QWORD *)a2 = &off_1E6CEA528;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 56) = *((_QWORD *)this + 4);
  for (i = (int8x16_t *)*((_QWORD *)this + 2); v4 != i; ++v4)
  {
    v6 = &off_1E6D0A7D0;
    v8 = 3;
    v7 = vextq_s8(*v4, *v4, 8uLL);
    PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval&>((uint64_t **)(a2 + 64), (uint64_t)&v6);
    PB::Base::~Base((PB::Base *)&v6);
  }
}

void sub_1B7949FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  statistics::Statistics *v9;

  PB::Base::~Base((PB::Base *)&a9);
  statistics::Statistics::~Statistics(v9);
  _Unwind_Resume(a1);
}

uint64_t PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval&>(uint64_t **a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  int64x2_t v24;
  char *v25;
  uint64_t v26;
  int64x2_t v27;
  char *v28;
  _QWORD *v29;

  v4 = operator new();
  v5 = v4;
  *(_QWORD *)v4 = &off_1E6D0A7D0;
  *(_DWORD *)(v4 + 24) = 0;
  v6 = *(_BYTE *)(a2 + 24);
  if ((v6 & 2) != 0)
  {
    v8 = *(_QWORD *)(a2 + 16);
    *(_BYTE *)(v4 + 24) = 2;
    *(_QWORD *)(v4 + 16) = v8;
    v7 = 3;
    if ((v6 & 1) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = 1;
  if ((*(_BYTE *)(a2 + 24) & 1) != 0)
  {
LABEL_5:
    v9 = *(_QWORD *)(a2 + 8);
    *(_BYTE *)(v4 + 24) = v7;
    *(_QWORD *)(v4 + 8) = v9;
  }
LABEL_6:
  result = (uint64_t)(a1 + 2);
  v11 = (unint64_t)a1[2];
  v12 = a1[1];
  if ((unint64_t)v12 >= v11)
  {
    v14 = v12 - *a1;
    if ((unint64_t)(v14 + 1) >> 61)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v15 = v11 - (_QWORD)*a1;
    v16 = v15 >> 2;
    if (v15 >> 2 <= (unint64_t)(v14 + 1))
      v16 = v14 + 1;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    v29 = a1 + 2;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(result, v17);
    else
      v18 = 0;
    v19 = (uint64_t *)&v18[8 * v14];
    v20 = &v18[8 * v17];
    v28 = v20;
    *v19 = v5;
    v13 = v19 + 1;
    v27.i64[1] = (uint64_t)(v19 + 1);
    v22 = *a1;
    v21 = a1[1];
    if (v21 == *a1)
    {
      v24 = vdupq_n_s64((unint64_t)v21);
    }
    else
    {
      do
      {
        v23 = *--v21;
        *v21 = 0;
        *--v19 = v23;
      }
      while (v21 != v22);
      v24 = *(int64x2_t *)a1;
      v13 = (uint64_t *)v27.i64[1];
      v20 = v28;
    }
    *a1 = v19;
    a1[1] = v13;
    v27 = v24;
    v25 = (char *)a1[2];
    a1[2] = (uint64_t *)v20;
    v28 = v25;
    v26 = v24.i64[0];
    result = std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v26);
  }
  else
  {
    *v12 = v5;
    v13 = v12 + 1;
  }
  a1[1] = v13;
  return result;
}

void sub_1B794A17C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1B794B380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__47(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__47(uint64_t a1)
{

}

void sub_1B794B718(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void sub_1B794BE5C()
{
  JUMPOUT(0x1B794BC88);
}

void sub_1B794BE68()
{
  __cxa_end_catch();
  JUMPOUT(0x1B794BC88);
}

void sub_1B794BE74()
{
  __cxa_end_catch();
  JUMPOUT(0x1B794BC88);
}

void sub_1B794BE80(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c92_ZTSKZ79__HDQuantitySeriesHFDMigrationEntity_migrateDataToSQLFromStore_database_error__E3__0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[2];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a1[2] = result;
  return result;
}

void sub_1B794C0F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B794C64C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  void *v31;
  uint64_t v32;
  uint64_t v33;
  void *v36;
  void *v37;
  void *v38;
  uint64_t (*v39)(void *);
  NSObject *v40;
  uint64_t v41;
  NSObject *v42;

  if (a2)
  {

    v36 = __cxa_begin_catch(exception_object);
    if (a2 == 2)
    {
      v37 = v36;
      _HKInitializeLogging();
      v38 = (void *)*MEMORY[0x1E0CB52B0];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_DEFAULT))
      {
        v39 = *(uint64_t (**)(void *))(*(_QWORD *)v37 + 16);
        v40 = v38;
        v41 = v39(v37);
        *(_DWORD *)(v32 + 96) = 136315138;
        *(_QWORD *)(v32 + 100) = v41;
        _os_log_impl(&dword_1B7802000, v40, OS_LOG_TYPE_DEFAULT, "Caught std::exception during ignore block; ignoring: %s",
          (uint8_t *)(v33 - 160),
          0xCu);

      }
    }
    else
    {
      _HKInitializeLogging();
      v42 = *MEMORY[0x1E0CB52B0];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)(v32 + 96) = 0;
        _os_log_impl(&dword_1B7802000, v42, OS_LOG_TYPE_DEFAULT, "Caught unknown during ignore block; ignoring.",
          (uint8_t *)(v33 - 160),
          2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x1B794C564);
  }
  _Unwind_Resume(exception_object);
}

__n128 __copy_helper_block_ea8_32c112_ZTSKZ99__HDQuantitySeriesHFDMigrationEntity_migrateDataFromDataStore_to_database_recoveryAnalytics_error__E3__1(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 v10;
  _BYTE v11[24];
  _BYTE *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v6 = operator new(0x20uLL);
  *v6 = &unk_1E6CF07B8;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = &v10;
  v12 = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v11);
  v7 = v12;
  if (v12 == v11)
  {
    v8 = 4;
    v7 = v11;
    goto LABEL_5;
  }
  if (v12)
  {
    v8 = 5;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v10;
}

void sub_1B794CAB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &unk_1E6CF07B8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E6CF07B8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  _BYTE v5[88];
  uint64_t v6;

  memset(&v5[16], 0, 32);
  memset(&v5[56], 0, 32);
  v6 = a2;
  result = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)a1);
  if ((_DWORD)result)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
    if (!v4)
      std::__throw_bad_function_call[abi:ne180100]();
    result = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v4 + 48))(v4, v5);
    **(_BYTE **)(a1 + 16) = 1;
  }
  return result;
}

BOOL health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2)
{
  int v4;
  uint64_t *v5;
  uint64_t *v6;
  _BYTE v8[16];
  unsigned __int8 v9;

  health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 88), a2, (uint64_t)v8);
  v4 = v9;
  if (v9)
  {
    v5 = *(uint64_t **)(*(_QWORD *)(a1 + 88) + 24);
    v6 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v8);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v5, *v6, v6[1], (_QWORD *)a1);
    *(ObjectIdentifier *)(a1 + 72) = *a2;
    *(_OWORD *)(a1 + 56) = *(_OWORD *)health::Optional<health::BlockPointer>::get((uint64_t)v8);
  }
  return v4 != 0;
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E6CF0838;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEPNS0_6__baseISY_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E6CF0838;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEEclESX_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  id *v3;
  id obj;
  _QWORD v5[4];
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3321888768;
  v5[2] = ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke;
  v5[3] = &__block_descriptor_72_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E__e9_B16__0__8l;
  v2 = *(_QWORD *)(a1 + 8);
  v6 = *(_OWORD *)(a1 + 16);
  v7 = v2;
  v8 = a2;
  v3 = *(id **)(a1 + 40);
  v9 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    obj = *v3;
    hfd_catchExceptionsAsErrors(v5, (uint64_t)&obj, 0);
    objc_storeStrong(v3, obj);
  }
  else
  {
    hfd_catchExceptionsAsErrors(v5, 0, 0);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_;
}

BOOL ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  id v14;
  id v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  id v23;
  char v24;
  char v25;
  _BYTE v26[24];
  _BYTE *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v23 = 0;
  v4 = a1[4];
  v5 = a1[5];
  v7 = a1[6];
  v6 = a1[7];
  v8 = operator new(0x28uLL);
  *v8 = &off_1E6CF0968;
  v8[1] = v7;
  v8[2] = &v23;
  v8[3] = &v24;
  v8[4] = v6;
  v27 = v8;
  v25 = 1;
  v9 = operator new(0x20uLL);
  *v9 = &off_1E6CF08E8;
  v9[1] = v5;
  v9[2] = &v25;
  v9[3] = v26;
  v29 = v9;
  health::DataStore::performWriteTransactionWithLambda(v4, (uint64_t)v28);
  v10 = v29;
  if (v29 == v28)
  {
    v11 = 4;
    v10 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_6:
  v12 = v27;
  if (v27 == v26)
  {
    v13 = 4;
    v12 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_11;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_11:
  v14 = v23;
  if (v23)
  {
    v15 = v23;
    v16 = v15;
    if (a2)
      *a2 = objc_retainAutorelease(v15);
    else
      _HKLogDroppedError();

  }
  else
  {
    if (v24)
      goto LABEL_17;
    v17 = *(_QWORD *)(a1[8] + 24);
    if (!v17)
      std::__throw_bad_function_call[abi:ne180100]();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 48))(v17) & 1) == 0)
    {
LABEL_17:
      v18 = a1[4];
      v19 = a1[5];
      v28[0] = &off_1E6CF0AA8;
      v28[1] = v19;
      v29 = v28;
      health::DataStore::performWriteTransactionWithLambda(v18, (uint64_t)v28);
      v20 = v29;
      if (v29 == v28)
      {
        v21 = 4;
        v20 = v28;
      }
      else
      {
        if (!v29)
          goto LABEL_24;
        v21 = 5;
      }
      (*(void (**)(void))(*v20 + 8 * v21))();
    }
  }
LABEL_24:

  return v14 == 0;
}

void sub_1B794D030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E_(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CF08E8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF08E8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  double HistoryRoot;
  uint64_t v4;
  _BYTE v6[16];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v8 = 0u;
  v7 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = a2;
  v12 = a2;
  HistoryRoot = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v6, *(ObjectIdentifier **)(a1 + 8), **(unsigned __int8 **)(a1 + 16));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _BYTE *, double))(*(_QWORD *)v4 + 48))(v4, v6, HistoryRoot);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

double health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2, int a3)
{
  health::DataStore::ReadTransaction *v5;
  uint64_t *v6;
  uint64_t *v7;
  double result;
  std::runtime_error *exception;
  _BYTE v10[24];

  *(ObjectIdentifier *)(a1 + 72) = *a2;
  v5 = *(health::DataStore::ReadTransaction **)(a1 + 96);
  health::DataStore::ReadTransaction::_pointerForObject(v5, a2, (uint64_t)v10);
  if (v10[16])
  {
    v6 = (uint64_t *)*((_QWORD *)v5 + 3);
    v7 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v10);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v6, *v7, v7[1], (_QWORD *)a1);
  }
  else
  {
    if (!a3)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      _ZN6health15not_found_errorCI1St13runtime_errorEPKc(exception, "The requested sample history does not exist.");
    }
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)&result = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot(a1).n128_u64[0];
  }
  return result;
}

void sub_1B794D2E4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot(uint64_t a1)
{
  uint64_t v2;
  __n128 result;
  uint64_t v4;
  health::BlockAccessFile::WriteTransaction *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __n128 *v12;
  __n128 v13;
  _OWORD v14[2];
  char v15;
  __int128 v16;
  uint64_t v17;

  v2 = *(_QWORD *)(a1 + 96);
  if (*(_QWORD *)(a1 + 64) == 56)
  {
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>(v2 + 80, *(_QWORD *)(a1 + 56), 56, (_QWORD *)a1);
    return result;
  }
  v16 = *(_OWORD *)(v2 + 32);
  v17 = v2 + 48;
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v16, (_QWORD *)(a1 + 72), 0, v14);
  if (!v15)
  {
    v5 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
LABEL_8:
    v9 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v5, 56);
    v11 = v10;
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>((uint64_t)v5, v9, v10, (_QWORD *)a1);
    v13.n128_u64[0] = v9;
    v13.n128_u64[1] = v11;
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v16, (__n128 *)(a1 + 72), &v13);
    goto LABEL_9;
  }
  v4 = *(_QWORD *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v14)
                 + 24);
  v5 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
  v6 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v14);
  v7 = *(_QWORD *)(v6 + 16);
  v8 = *(_QWORD *)(v6 + 24);
  if (v4 != 56)
  {
    health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v5, v7, v8);
    goto LABEL_8;
  }
  health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>((uint64_t)v5, v7, v8, (_QWORD *)a1);
LABEL_9:
  health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 96), (ObjectIdentifier *)(a1 + 72), (uint64_t)v14);
  v12 = (__n128 *)health::Optional<health::BlockPointer>::get((uint64_t)v14);
  result = *v12;
  *(__n128 *)(a1 + 56) = *v12;
  return result;
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[2];
  _QWORD v11[3];
  _BYTE v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 56;
  v11[0] = v12;
  v11[1] = v12;
  v11[2] = 56;
  v10[0] = *a4;
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[1];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[2];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[3];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[4];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[5];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[6];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  if (v14 <= 0x3FF)
    v8 = v12;
  else
    v8 = v13;
  health::RawBuffer::RawBuffer(v10, v8, v14);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B794D598(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF0968;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEPNS0_6__baseIS14_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF0968;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEEclES13_(uint64_t a1, uint64_t a2)
{
  _BYTE *v3;
  uint64_t v4;
  char *v5;
  _QWORD *v6;
  uint64_t v7;
  __int128 v9;
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_BYTE **)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 8);
  v9 = *(_OWORD *)(a1 + 16);
  v5 = (char *)operator new(0x28uLL);
  *(_QWORD *)v5 = &off_1E6CF09E8;
  *((_QWORD *)v5 + 1) = v4;
  *((_QWORD *)v5 + 2) = a2;
  *(_OWORD *)(v5 + 24) = v9;
  v11 = v5;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(v3, (uint64_t)v10);
  v6 = v11;
  if (v11 == v10)
  {
    v7 = 4;
    v6 = v10;
    goto LABEL_5;
  }
  if (v11)
  {
    v7 = 5;
LABEL_5:
    (*(void (**)(void))(*v6 + 8 * v7))();
  }
  return 1;
}

void sub_1B794D714(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char *a16)
{
  char *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t (*v23)(void *);
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;

  if (!a2)
    _Unwind_Resume(a1);
  v18 = a16;
  if (a16 == &a13)
  {
    v19 = 4;
    v18 = &a13;
  }
  else
  {
    if (!a16)
      goto LABEL_7;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_7:
  v20 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    v21 = v20;
    _HKInitializeLogging();
    v22 = (void *)*MEMORY[0x1E0CB52B0];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_DEFAULT))
    {
      v23 = *(uint64_t (**)(void *))(*(_QWORD *)v21 + 16);
      v24 = v22;
      v25 = v23(v21);
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v25;
      _os_log_impl(&dword_1B7802000, v24, OS_LOG_TYPE_DEFAULT, "Caught std::exception during ignore block; ignoring: %s",
        (uint8_t *)&buf,
        0xCu);

    }
  }
  else
  {
    _HKInitializeLogging();
    v26 = *MEMORY[0x1E0CB52B0];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_1B7802000, v26, OS_LOG_TYPE_DEFAULT, "Caught unknown during ignore block; ignoring.",
        (uint8_t *)&buf,
        2u);
    }
  }
  __cxa_end_catch();
  JUMPOUT(0x1B794D6E0);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_;
}

_BYTE *health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(_BYTE *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  _QWORD *v7;
  _QWORD v8[3];
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)result + 6))
  {
    v2 = *(_QWORD *)(*((_QWORD *)result + 11) + 24);
    v8[0] = 0;
    v8[1] = 0;
    v8[2] = v2;
    v6 = *((_OWORD *)result + 1);
    v7 = v8;
    std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v9, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>((uint64_t *)&v6, (uint64_t)v9, 0);
    result = v10;
    if (v10 == v9)
    {
      v5 = 4;
      result = v9;
    }
    else
    {
      if (!v10)
        return result;
      v5 = 5;
    }
    return (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t))(*(_QWORD *)result + 8 * v5))(result, v3, v4);
  }
  return result;
}

void sub_1B794D974(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19)
{
  char *v20;
  uint64_t v21;

  v20 = a19;
  if (a19 == &a16)
  {
    v21 = 4;
    v20 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _OWORD v8[26];

  v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v14[17];
  __int16 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  if (*(_WORD *)(a3 + 408))
  {
    v7 = result;
    v8 = *(_WORD *)(a3 + 408) - 1;
    if (!(_DWORD)a5)
      v8 = 0;
    if (*(_BYTE *)(a3 + 410))
    {
      v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(_QWORD *)(v9 + 16);
      v12 = *(_QWORD *)(v7 + 16);
      memset(v14, 0, sizeof(v14));
      v15 = 0;
      v16 = 0u;
      v17 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      v18 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(int,health::bplustree::LeafNode<double,double,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,double const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v18, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

double *health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *result;
  double v16;
  void *v17;
  double v18;
  void *v19;
  std::string v20;
  void *v21[2];
  void *v22[2];
  void *v23[2];
  std::string v24;
  void *v25[2];
  void *v26[2];
  void *v27[2];
  std::string __p;
  void *v29[2];
  _QWORD v30[2];
  _QWORD v31[2];
  std::string v32;
  _QWORD v33[2];
  _QWORD v34[2];
  _QWORD v35[2];

  if (*(unsigned __int16 *)(a3 + 408) <= a4)
  {
    v9 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a2 >= 64)
  {
    v10 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
  v12 = *(_QWORD *)(v11 + 8);
  v13 = *(_QWORD *)(v11 + 16);
  v14 = *(_QWORD *)(a1 + 16);
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 208) = 0u;
  *(_OWORD *)(a5 + 224) = 0u;
  *(_OWORD *)(a5 + 240) = 0u;
  *(_OWORD *)(a5 + 256) = 0u;
  *(_OWORD *)(a5 + 272) = 0u;
  *(_OWORD *)(a5 + 288) = 0u;
  *(_OWORD *)(a5 + 304) = 0u;
  *(_OWORD *)(a5 + 320) = 0u;
  *(_OWORD *)(a5 + 336) = 0u;
  *(_OWORD *)(a5 + 352) = 0u;
  *(_OWORD *)(a5 + 368) = 0u;
  *(_OWORD *)(a5 + 384) = 0u;
  *(_OWORD *)(a5 + 395) = 0u;
  result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 16), v12, v13, a5);
  if (*(_WORD *)(a5 + 408))
  {
    v16 = *(double *)a5;
    result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    if (v16 < *result)
    {
      v17 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a3 + 408) - 1 > (int)a4)
    {
      v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, *(unsigned __int16 *)(a5 + 408) - 1);
      result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4 + 1);
      if (v18 >= *result)
      {
        v19 = (void *)*MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1B794DF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 306;
  health::RawBuffer::RawBuffer(v11, v12, 306);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 306;
  health::bplustree::LeafNode<double,double,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B794E184(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 16 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 16 * a2;
}

void sub_1B794E298(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::LeafNode<double,double,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  double *v5;
  __int16 v7;

  for (i = 0; i != 17; ++i)
  {
    v5 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry::deserialize(v5, a2);
  }
  v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v7);
  *(_WORD *)(a1 + 272) = v7;
  health::BlockPointer::deserialize((_QWORD *)(a1 + 280), a2);
  return health::BlockPointer::deserialize((_QWORD *)(a1 + 296), a2);
}

void sub_1B794E46C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

double health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry::deserialize(double *a1, uint64_t a2)
{
  double result;
  double v5;

  v5 = 0.0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *a1 = v5;
  v5 = 0.0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  result = v5;
  a1[1] = v5;
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(int,health::bplustree::LeafNode<double,double,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,double const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  void **v6;
  unint64_t v7;
  double v8;
  unint64_t *v9;
  uint64_t v10;
  __n128 v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  double v16;
  unint64_t *v17;
  uint64_t v18;
  __n128 v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  unint64_t i;
  double *v27;
  uint64_t v28;
  __n128 v29;
  void *v30;
  uint64_t v31;
  void **v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  unint64_t v37;
  double *v38;
  uint64_t v39;
  __n128 v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  std::string v44;
  void *v45[2];
  void *v46[2];
  void *v47[2];
  std::string v48;
  void *v49[2];
  void *v50[2];
  void *v51[2];
  std::string __p;
  void *v53[2];
  void *v54[2];
  void *v55[2];
  std::string v56;
  void *v57[2];
  void *v58[2];
  void *v59[2];
  std::string v60;
  void *v61[2];
  void *v62[2];
  void *v63[2];
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  unsigned __int16 v81;
  __int128 v82;
  __int128 v83;
  std::string v84;
  _QWORD v85[2];
  _QWORD v86[2];
  _QWORD v87[2];

  v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 272))
    {
      v14 = *(unsigned __int16 *)(a2 + 272) - 1;
      v15 = 1;
      v16 = 0.0;
      while (1)
      {
        v17 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        v18 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            v20 = (void *)*MEMORY[0x1E0CB52B0];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        v21 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v21)
          break;
        v16 = *(double *)v17;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0)
          return result;
        ++v15;
        if (--v14 == -1)
          goto LABEL_35;
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    v16 = 0.0;
LABEL_35:
    v32 = (void **)MEMORY[0x1E0CB52B0];
    v33 = *(_QWORD *)(a2 + 280);
    v34 = *(_QWORD *)(a2 + 288);
    while (1)
    {
      v35 = *(_QWORD *)(v43 + 16);
      if (v33 == *(_QWORD *)v35 && v34 == *(_QWORD *)(v35 + 8))
        break;
      v81 = 0;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v75 = 0u;
      v76 = 0u;
      v73 = 0u;
      v74 = 0u;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v64 = 0u;
      v82 = 0u;
      v83 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v33, v34, (uint64_t)&v64);
      if (!v81)
      {
        v36 = *v32;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      v37 = v81 - 1;
      do
      {
        v38 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, v37);
        v39 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, v37);
        if (*v38 >= v16)
        {
          v41 = *v32;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        v42 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v42)
          goto LABEL_48;
        v16 = *v38;
        v40.n128_f64[0] = *v38;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0)
          return result;
        --v37;
      }
      while (v37 != -1);
      v34 = *((_QWORD *)&v82 + 1);
      v33 = v82;
    }
  }
  else if (!a4)
  {
    v6 = (void **)MEMORY[0x1E0CB52B0];
    if (*(_WORD *)(a2 + 272))
    {
      v7 = 0;
      v8 = 0.0;
      while (1)
      {
        v9 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        v10 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v87, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v86, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v85, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v84);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v87, (uint64_t)v86, (uint64_t)v85, 382, (uint64_t)&v84);
          }
        }
        v13 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v13)
          goto LABEL_48;
        v8 = *(double *)v9;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0)
          return result;
        if (++v7 >= *(unsigned __int16 *)(a2 + 272))
          goto LABEL_22;
      }
    }
    v8 = 0.0;
LABEL_22:
    v22 = *(_QWORD *)(a2 + 296);
    v23 = *(_QWORD *)(a2 + 304);
    while (1)
    {
      v24 = *(_QWORD *)(v43 + 16);
      if (v22 == *(_QWORD *)v24 && v23 == *(_QWORD *)(v24 + 8))
        break;
      v81 = 0;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v75 = 0u;
      v76 = 0u;
      v73 = 0u;
      v74 = 0u;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v64 = 0u;
      v82 = 0u;
      v83 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)&v64);
      if (!v81)
      {
        v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      for (i = 0; i < v81; ++i)
      {
        v27 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, i);
        v28 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, i);
        if (*v27 <= v8)
        {
          v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        v31 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v31)
          goto LABEL_48;
        v8 = *v27;
        v29.n128_f64[0] = *v27;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0)
          return result;
      }
      v23 = *((_QWORD *)&v83 + 1);
      v22 = v83;
    }
  }
  return result;
}

void sub_1B794EC7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a28 < 0)
    operator delete(__p);
  if (a34 < 0)
    operator delete(a29);
  if (a40 < 0)
    operator delete(a35);
  if (a46 < 0)
    operator delete(a41);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF09E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE7__cloneEPNS0_6__baseIS1A_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF09E8;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EEclES19_S19_(_QWORD *a1, _QWORD *a2, void **a3)
{
  void *v4;
  uint64_t v5;
  double v7;
  id *v8;
  id *v9;
  uint64_t v10;
  _QWORD v12[7];
  id v13;

  v4 = *a3;
  v5 = *(_QWORD *)(a1[1] + 24);
  v12[0] = *a2;
  v13 = v4;
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  v7 = (*(double (**)(uint64_t, _QWORD *, id *))(*(_QWORD *)v5 + 48))(v5, v12, &v13);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clIddEEbSO_S12__block_invoke;
  v12[3] = &__block_descriptor_56_e9_B16__0__8l;
  v8 = (id *)a1[3];
  v12[4] = a1[2];
  v12[5] = a2;
  *(double *)&v12[6] = v7;
  if (v8)
    v9 = &v13;
  else
    v9 = 0;
  if (v8)
    v13 = *v8;
  v10 = hfd_catchExceptionsAsErrors(v12, (uint64_t)v9, 0);
  if (v8)
    objc_storeStrong(v8, v13);
  return v10;
}

void sub_1B794F070(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  **(_BYTE **)(v1 + 32) = 1;
  __cxa_end_catch();
  JUMPOUT(0x1B794F050);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE11target_typeEv()
{
  return &_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_;
}

uint64_t ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clIddEEbSO_S12__block_invoke(uint64_t a1)
{
  int64x2_t *v1;
  double *v2;
  uint64_t *v3;
  health::BlockAccessFile::WriteTransaction *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[27];
  _QWORD v36[4];

  v1 = *(int64x2_t **)(a1 + 32);
  v2 = *(double **)(a1 + 40);
  v3 = (uint64_t *)(a1 + 48);
  v4 = (health::BlockAccessFile::WriteTransaction *)(v1[6].i64[0] + 80);
  v36[0] = 0;
  v36[1] = 0;
  v36[2] = v4;
  v36[3] = v4;
  v6 = v1[1].i64[0];
  v5 = v1[1].i64[1];
  if (!v6)
  {
    if (v5)
    {
      v6 = 0;
    }
    else
    {
      v34 = 0u;
      memset(v35, 0, sizeof(v35));
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v14 = 0u;
      v15 = 0u;
      v12 = 0u;
      v13 = 0u;
      v11 = 0u;
      v6 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v4, 411);
      v5 = v7;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v4, v6, v7, (uint64_t)&v11);
      v1[1].i64[0] = v6;
      v1[1].i64[1] = v5;
    }
  }
  *(_QWORD *)&v11 = v6;
  *((_QWORD *)&v11 + 1) = v5;
  *(_QWORD *)&v12 = v36;
  v8 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::setValueForKey((uint64_t *)&v11, v2, v3);
  v9 = v1[3].i64[0];
  if (v9)
  {
    if (!v8)
      v1[3].i64[0] = v9 + 1;
  }
  else
  {
    v1[3].i64[0] = 1;
    *v1 = vdupq_n_s64(8uLL);
  }
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot((uint64_t)v1);
  return 1;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::setValueForKey(uint64_t *a1, double *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  health::BlockAccessFile::WriteTransaction *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[416];
  _OWORD __src[26];
  _OWORD v15[26];

  v6 = a1[2];
  memset(v15, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    v8 = a1[2];
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(v13, __src, sizeof(v13));
    v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 411);
    v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)v13);
    WORD4(__src[25]) = 1;
    *((_QWORD *)&__src[0] + 1) = v10;
    *(_QWORD *)&__src[1] = v12;
    BYTE10(__src[25]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t *a6)
{
  unsigned int v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  double v17;
  uint64_t v18;
  __int128 *v19;
  uint64_t v20;
  health::BlockAccessFile::WriteTransaction *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  double v32;
  int v33;
  uint64_t v34;
  health::BlockAccessFile::WriteTransaction *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  double v42;
  health::BlockAccessFile::WriteTransaction *v43;
  void *v44;
  uint64_t v45;
  std::string::size_type v46;
  std::string *p_p;
  __int128 *v48;
  void *v49;
  __int128 *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  health::BlockAccessFile::WriteTransaction *v55;
  void *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t *v60;
  __int128 *v61;
  __int128 v64;
  void *v65[2];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int16 v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85[3];
  std::string __p;
  void *v87[2];
  void *v88[2];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  _OWORD v106[9];
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  unsigned __int16 v124;
  __int128 v125;
  __int128 v126;
  unsigned __int16 v127;
  char v128;

  if (!*(_WORD *)(a4 + 408))
  {
    v123 = 0u;
    v122 = 0u;
    v121 = 0u;
    v120 = 0u;
    v119 = 0u;
    v118 = 0u;
    v116 = 0u;
    v117 = 0u;
    v114 = 0u;
    v115 = 0u;
    v112 = 0u;
    v113 = 0u;
    v110 = 0u;
    v111 = 0u;
    v108 = 0u;
    v109 = 0u;
    v19 = *(__int128 **)(a1 + 16);
    v125 = *v19;
    v126 = *v19;
    v124 = 1;
    v20 = *a6;
    *(double *)&v107 = *a5;
    *((_QWORD *)&v107 + 1) = v20;
    v21 = (health::BlockAccessFile::WriteTransaction *)*((_QWORD *)v19 + 3);
    v22 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v21, 306);
    v24 = v23;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t)v21, v22, v23, (uint64_t)&v107);
    *(double *)a4 = *a5;
    *(_QWORD *)(a4 + 8) = v22;
    *(_QWORD *)(a4 + 16) = v24;
    *(_WORD *)(a4 + 408) = 1;
    *(_BYTE *)(a4 + 410) = 1;
LABEL_8:
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
  if (*(_BYTE *)(a4 + 410))
  {
    v11 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
    *(_OWORD *)v85 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11)+ 8);
    v12 = *(_QWORD *)(a1 + 16);
    v107 = 0u;
    v108 = 0u;
    v109 = 0u;
    v110 = 0u;
    v111 = 0u;
    v112 = 0u;
    v113 = 0u;
    v114 = 0u;
    v115 = 0u;
    v116 = 0u;
    v117 = 0u;
    v118 = 0u;
    v119 = 0u;
    v120 = 0u;
    v121 = 0u;
    v122 = 0u;
    v123 = 0u;
    v124 = 0;
    v125 = 0u;
    v126 = 0u;
    v13 = *(_OWORD *)v85;
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v12 + 24), v85[0], v85[1], (uint64_t)&v107);
    v14 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v85, (uint64_t)&v107, a5, a6);
    v15 = v14;
    if (v14 <= 1)
    {
      v16 = *a5;
      if (v16 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11))
      {
        v17 = *a5;
        *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11) = v17;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      }
      return v15;
    }
    v33 = *(unsigned __int16 *)(a4 + 408);
    if (v33 == 17)
    {
      v18 = 2;
      if (v11 == 16)
      {
        if ((_DWORD)v14 == 4)
          return 4;
        else
          return 2;
      }
      else if (!v11)
      {
        if ((_DWORD)v14 == 3)
          return 3;
        else
          return 2;
      }
      return v18;
    }
    if ((_DWORD)v14 == 4 && v33 - 1 == v11)
    {
      v104 = 0u;
      v105 = 0u;
      v102 = 0u;
      v103 = 0u;
      v100 = 0u;
      v101 = 0u;
      v98 = 0u;
      v99 = 0u;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v92 = 0u;
      v93 = 0u;
      v90 = 0u;
      v91 = 0u;
      LOWORD(v106[0]) = 1;
      v34 = *a6;
      *(double *)&v89 = *a5;
      *((_QWORD *)&v89 + 1) = v34;
      *(_OWORD *)((char *)v106 + 8) = *(_OWORD *)v85;
      *(_OWORD *)((char *)&v106[1] + 8) = v126;
      v35 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v36 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v35, 306);
      v38 = v37;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t)v35, v36, v37, (uint64_t)&v89);
      *(_QWORD *)&v126 = v36;
      *((_QWORD *)&v126 + 1) = v38;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v13, *((uint64_t *)&v13 + 1), (uint64_t)&v107);
      v39 = *(_QWORD *)(a1 + 16);
      if (*(_OWORD *)((char *)&v106[1] + 8) != *(_OWORD *)v39)
      {
        v82 = 0;
        v80 = 0u;
        v81 = 0u;
        v78 = 0u;
        v79 = 0u;
        v76 = 0u;
        v77 = 0u;
        v74 = 0u;
        v75 = 0u;
        v72 = 0u;
        v73 = 0u;
        v70 = 0u;
        v71 = 0u;
        v68 = 0u;
        v69 = 0u;
        v66 = 0u;
        v67 = 0u;
        *(_OWORD *)v65 = 0u;
        v83 = 0u;
        v84 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v39 + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
        *(_QWORD *)&v83 = v36;
        *((_QWORD *)&v83 + 1) = v38;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
      }
      v40 = *(unsigned __int16 *)(a4 + 408);
      v41 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v40);
      *(_QWORD *)(v41 + 8) = v36;
      *(_QWORD *)(v41 + 16) = v38;
      v42 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v40) = v42;
      ++*(_WORD *)(a4 + 408);
      goto LABEL_8;
    }
    v64 = *(_OWORD *)v85;
    v104 = 0u;
    v105 = 0u;
    v102 = 0u;
    v103 = 0u;
    v100 = 0u;
    v101 = 0u;
    v98 = 0u;
    v99 = 0u;
    v97 = 0u;
    *(_OWORD *)((char *)v106 + 8) = *(_OWORD *)v85;
    *(_OWORD *)((char *)&v106[1] + 8) = v126;
    if (v124 >= 0x12uLL)
    {
      v49 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v65, "sourceIndex + elementCount <= Length");
      std::string::basic_string[abi:ne180100]<0>(v88, "copyElementsFromArrayToIndex");
      std::string::basic_string[abi:ne180100]<0>(v87, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Copy would overflow source.", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v49, (uint64_t)v65, (uint64_t)v88, (uint64_t)v87, 80, (uint64_t)&__p);
    }
    v50 = &v107 + v124 - 8;
    v51 = v50[5];
    v93 = v50[4];
    v94 = v51;
    v52 = v50[7];
    v95 = v50[6];
    v96 = v52;
    v53 = v50[1];
    v89 = *v50;
    v90 = v53;
    v54 = v50[3];
    v91 = v50[2];
    v92 = v54;
    v124 -= 8;
    strcpy((char *)v106, "\b");
    v55 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
    v56 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v55, 306);
    v58 = (void *)v57;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t)v55, (uint64_t)v56, v57, (uint64_t)&v89);
    v88[0] = v56;
    v88[1] = v58;
    v126 = *(_OWORD *)v88;
    v59 = *(_QWORD *)(a1 + 16);
    if (*(_OWORD *)((char *)&v106[1] + 8) != *(_OWORD *)v59)
    {
      v82 = 0;
      v80 = 0u;
      v81 = 0u;
      v78 = 0u;
      v79 = 0u;
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      *(_OWORD *)v65 = 0u;
      v83 = 0u;
      v84 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v59 + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
      v83 = *(_OWORD *)v88;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
    }
    v65[0] = (void *)v89;
    v65[1] = v56;
    *(_QWORD *)&v66 = v58;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)v65, v11 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v64, *((uint64_t *)&v64 + 1), (uint64_t)&v107);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)&v89)
    {
      v60 = (uint64_t *)&v64;
      v61 = &v107;
    }
    else
    {
      v60 = (uint64_t *)v88;
      v61 = &v89;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v60, (uint64_t)v61, a5, a6);
  }
  v26 = a2 + 1;
  v27 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  v28 = v27;
  *(_OWORD *)v88 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v27)+ 8);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)&v107, a1, v26, a4, v27);
  v29 = (a2 + 2);
  v30 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v29, v88, &v107, a5, a6);
  if (v30 > 1)
  {
    if (*(_WORD *)(a4 + 408) == 17)
      return 2;
    *(_OWORD *)v87 = *(_OWORD *)v88;
    memset(v106, 0, 139);
    v104 = 0u;
    v105 = 0u;
    v102 = 0u;
    v103 = 0u;
    v100 = 0u;
    v101 = 0u;
    v98 = 0u;
    v99 = 0u;
    v96 = 0u;
    v97 = 0u;
    v94 = 0u;
    v95 = 0u;
    v92 = 0u;
    v93 = 0u;
    v90 = 0u;
    v91 = 0u;
    BYTE10(v106[8]) = v128;
    v89 = 0u;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)&v89, 0, (uint64_t)&v107, v127 - 8, 8);
    v127 -= 8;
    WORD4(v106[8]) = 8;
    v43 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
    v44 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v43, 411);
    v46 = v45;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v43, (uint64_t)v44, v45, (uint64_t)&v89);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
    __p.__r_.__value_.__l.__size_ = v46;
    v65[0] = (void *)v89;
    v65[1] = v44;
    *(_QWORD *)&v66 = v46;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)v65, v28 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), (uint64_t)v87[0], (uint64_t)v87[1], (uint64_t)&v107);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)&v89)
    {
      p_p = (std::string *)v87;
      v48 = &v107;
    }
    else
    {
      p_p = &__p;
      v48 = &v89;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v29, p_p, v48, a5, a6);
  }
  v18 = v30;
  v31 = *a5;
  if (v31 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v27))
  {
    v32 = *a5;
    *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v27) = v32;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
  }
  return v18;
}

void sub_1B794FC14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62,void *a63)
{
  char a68;
  void *a70;
  char a72;

  if (a62 < 0)
    operator delete(__p);
  if (a68 < 0)
    operator delete(a63);
  if (a72 < 0)
    operator delete(a70);
  if (a16 < 0)
    operator delete(a11);
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  _QWORD *v9;
  unsigned __int8 *v10;
  uint64_t result;
  _QWORD v12[2];
  _QWORD v13[3];
  _BYTE v14[1024];
  unsigned __int8 *v15;
  unint64_t v16;
  uint64_t v17;

  v8 = 0;
  v17 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16 = 306;
  v13[0] = v14;
  v13[1] = v14;
  v13[2] = 306;
  do
  {
    v9 = (_QWORD *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a4, v8);
    v12[0] = *v9;
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    v12[0] = v9[1];
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    ++v8;
  }
  while (v8 != 17);
  LOWORD(v12[0]) = *(_WORD *)(a4 + 272);
  health::SerializationBuffer::appendRaw<unsigned short>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 280);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 288);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 296);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 304);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  if (v16 <= 0x3FF)
    v10 = v14;
  else
    v10 = v15;
  health::RawBuffer::RawBuffer(v12, v10, v16);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v12);
  result = (uint64_t)v15;
  v15 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B794FE00(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(uint64_t a1, uint64_t *a2, uint64_t a3, double *a4, uint64_t *a5)
{
  void *v10;
  unsigned int v11;
  uint64_t v12;
  double v13;
  double v14;
  double *v15;
  int v16;
  unint64_t v18;
  double v19;
  uint64_t v20;
  void *v21;
  double *v22;
  uint64_t v23;
  std::string __p;
  void *v25[2];
  void *v26[2];
  void *v27[2];

  if (!*(_WORD *)(a3 + 272))
  {
    v10 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v27, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v26, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 72, (uint64_t)&__p);
  }
  v11 = *(unsigned __int16 *)(a3 + 272) - 1;
  v12 = 1;
  while (1)
  {
    v13 = *a4;
    if (v13 > *(double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a3, v11))break;
    v14 = *a4;
    v15 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a3, v11);
    v16 = (unsigned __int16)v11;
    if (v14 == *v15)
    {
      v23 = *a5;
      *(_QWORD *)(health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a3, (unsigned __int16)v11)+ 8) = v23;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a2, a2[1], a3);
      return 1;
    }
    --v11;
    if (!v16)
    {
      v12 = 0;
      LOWORD(v11) = 0;
      break;
    }
  }
  if (*(_WORD *)(a3 + 272) == 17)
  {
    if (*a4 >= *(double *)a3)
    {
      if (*a4 <= *(double *)(a3 + 256))
        return 2;
      else
        return 4;
    }
    else
    {
      return 3;
    }
  }
  else
  {
    v18 = v12 + (unsigned __int16)v11;
    v19 = *a4;
    v20 = *a5;
    if (v18 >= 0x11)
    {
      v21 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v27, "index < Length");
      std::string::basic_string[abi:ne180100]<0>(v26, "insertElementAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Index out of bounds.", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v21, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 57, (uint64_t)&__p);
    }
    v22 = (double *)(a3 + 16 * v18);
    memmove(v22 + 2, v22, 256 - 16 * v18);
    *v22 = v19;
    *((_QWORD *)v22 + 1) = v20;
    ++*(_WORD *)(a3 + 272);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a2, a2[1], a3);
    return 0;
  }
}

void sub_1B7950100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

double *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5)
{
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *result;
  double v16;
  void *v17;
  double v18;
  void *v19;
  std::string v20;
  void *v21[2];
  void *v22[2];
  void *v23[2];
  std::string v24;
  void *v25[2];
  void *v26[2];
  void *v27[2];
  std::string __p;
  void *v29[2];
  _QWORD v30[2];
  _QWORD v31[2];
  std::string v32;
  _QWORD v33[2];
  _QWORD v34[2];
  _QWORD v35[2];

  if (*(unsigned __int16 *)(a4 + 408) <= a5)
  {
    v9 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a3 >= 64)
  {
    v10 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
  v12 = *(_QWORD *)(v11 + 8);
  v13 = *(_QWORD *)(v11 + 16);
  v14 = *(_QWORD *)(a2 + 16);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 395) = 0u;
  result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, a1);
  if (*(_WORD *)(a1 + 408))
  {
    v16 = *(double *)a1;
    result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
    if (v16 < *result)
    {
      v17 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a4 + 408) - 1 > (int)a5)
    {
      v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, *(unsigned __int16 *)(a1 + 408) - 1);
      result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5 + 1);
      if (v18 >= *result)
      {
        v19 = (void *)*MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1B7950544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

void std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CF0AA8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CF0AA8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, health::DataStore::WriteTransaction *a2)
{
  _BYTE v5[16];
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  health::DataStore::WriteTransaction *v11;
  health::DataStore::WriteTransaction *v12;
  __int128 v13;
  _QWORD *v14;
  _QWORD v15[4];
  _BYTE __dst[416];
  _OWORD __src[26];

  v6 = 0u;
  v7 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = a2;
  v12 = a2;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)(a1 + 8), 0);
  v15[0] = 0;
  v15[1] = 0;
  v15[2] = (char *)v12 + 80;
  v15[3] = (char *)v12 + 80;
  if (v6 != 0)
  {
    v13 = v6;
    v14 = v15;
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t *)v12 + 10, v6, *((uint64_t *)&v6 + 1), (uint64_t)__src);
    memcpy(__dst, __src, sizeof(__dst));
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::deleteAllSamples(void)::{lambda(double const&,double const&)#1}>((uint64_t)&v13, 0, (unint64_t *)&v13, (uint64_t)__dst);
  }
  v8 = 0;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot((uint64_t)v5);
  health::DataStore::WriteTransaction::removeObjectWithIdentifier(a2, *(ObjectIdentifier **)(a1 + 8));
  return 1;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::deleteAllSamples(void)::{lambda(double const&,double const&)#1}>(uint64_t a1, int a2, unint64_t *a3, uint64_t a4)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t i;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v16;
  _BYTE __dst[416];
  _OWORD __src[26];
  _OWORD v19[17];
  unsigned __int16 v20;
  __int128 v21;
  __int128 v22;

  if (*(_WORD *)(a4 + 408))
  {
    v7 = 0;
    v16 = a2 + 1;
    do
    {
      if (*(_BYTE *)(a4 + 410))
      {
        v8 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v7);
        v9 = *(_QWORD *)(a1 + 16);
        memset(v19, 0, sizeof(v19));
        v20 = 0;
        v21 = 0u;
        v22 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v9 + 24), *(_QWORD *)(v8 + 8), *(_QWORD *)(v8 + 16), (uint64_t)v19);
        if (v20)
        {
          for (i = 0;
                i < v20;
                health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v19, i++))
          {
            health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v19, i);
          }
        }
        v11 = *(unint64_t **)(a1 + 16);
        v12 = v22;
        if (v22 != *(_OWORD *)v11)
        {
          memset(__src, 0, 274);
          *(_OWORD *)((char *)&__src[17] + 8) = 0u;
          *(_OWORD *)((char *)&__src[18] + 8) = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t *)v11[3], v22, *((uint64_t *)&v22 + 1), (uint64_t)__src);
          *(_OWORD *)((char *)&__src[17] + 8) = v21;
          health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v22, *((uint64_t *)&v22 + 1), (uint64_t)__src);
          v11 = *(unint64_t **)(a1 + 16);
          v12 = *v11;
        }
        if (v21 != __PAIR128__(v11[1], v12))
        {
          memset(__src, 0, 274);
          *(_OWORD *)((char *)&__src[17] + 8) = 0u;
          *(_OWORD *)((char *)&__src[18] + 8) = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t *)v11[3], v21, *((uint64_t *)&v21 + 1), (uint64_t)__src);
          *(_OWORD *)((char *)&__src[18] + 8) = v22;
          health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v21, *((uint64_t *)&v21 + 1), (uint64_t)__src);
          v11 = *(unint64_t **)(a1 + 16);
        }
        health::BlockAccessFile::WriteTransaction::freeBlock(v11[3], *(_QWORD *)(v8 + 8), *(_QWORD *)(v8 + 16));
      }
      else
      {
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)__src, a1, a2, a4, (unsigned __int16)v7);
        v13 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v7)+ 8;
        memcpy(__dst, __src, sizeof(__dst));
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::deleteAllSamples(void)::{lambda(double const&,double const&)#1}>(a1, v16, v13, __dst);
      }
      ++v7;
    }
    while (v7 < *(unsigned __int16 *)(a4 + 408));
  }
  return health::BlockAccessFile::WriteTransaction::freeBlock(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1]);
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 v10;
  _BYTE v11[24];
  _BYTE *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v6 = operator new(0x20uLL);
  *v6 = &unk_1E6CF0C58;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = &v10;
  v12 = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v11);
  v7 = v12;
  if (v12 == v11)
  {
    v8 = 4;
    v7 = v11;
    goto LABEL_5;
  }
  if (v12)
  {
    v8 = 5;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v10;
}

void sub_1B7950F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &unk_1E6CF0C58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E6CF0C58;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E6CF0CD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEPNS0_6__baseISY_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E6CF0CD8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEEclESX_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  id *v3;
  id obj;
  _QWORD v5[4];
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3321888768;
  v5[2] = ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke;
  v5[3] = &__block_descriptor_72_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E__e9_B16__0__8l;
  v2 = *(_QWORD *)(a1 + 8);
  v6 = *(_OWORD *)(a1 + 16);
  v7 = v2;
  v8 = a2;
  v3 = *(id **)(a1 + 40);
  v9 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    obj = *v3;
    hfd_catchExceptionsAsErrors(v5, (uint64_t)&obj, 0);
    objc_storeStrong(v3, obj);
  }
  else
  {
    hfd_catchExceptionsAsErrors(v5, 0, 0);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_;
}

BOOL ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  id v14;
  id v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  id v23;
  char v24;
  char v25;
  _BYTE v26[24];
  _BYTE *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v23 = 0;
  v4 = a1[4];
  v5 = a1[5];
  v7 = a1[6];
  v6 = a1[7];
  v8 = operator new(0x28uLL);
  *v8 = &off_1E6CF0E08;
  v8[1] = v7;
  v8[2] = &v23;
  v8[3] = &v24;
  v8[4] = v6;
  v27 = v8;
  v25 = 1;
  v9 = operator new(0x20uLL);
  *v9 = &off_1E6CF0D88;
  v9[1] = v5;
  v9[2] = &v25;
  v9[3] = v26;
  v29 = v9;
  health::DataStore::performWriteTransactionWithLambda(v4, (uint64_t)v28);
  v10 = v29;
  if (v29 == v28)
  {
    v11 = 4;
    v10 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_6:
  v12 = v27;
  if (v27 == v26)
  {
    v13 = 4;
    v12 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_11;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_11:
  v14 = v23;
  if (v23)
  {
    v15 = v23;
    v16 = v15;
    if (a2)
      *a2 = objc_retainAutorelease(v15);
    else
      _HKLogDroppedError();

  }
  else
  {
    if (v24)
      goto LABEL_17;
    v17 = *(_QWORD *)(a1[8] + 24);
    if (!v17)
      std::__throw_bad_function_call[abi:ne180100]();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 48))(v17) & 1) == 0)
    {
LABEL_17:
      v18 = a1[4];
      v19 = a1[5];
      v28[0] = &off_1E6CF0F48;
      v28[1] = v19;
      v29 = v28;
      health::DataStore::performWriteTransactionWithLambda(v18, (uint64_t)v28);
      v20 = v29;
      if (v29 == v28)
      {
        v21 = 4;
        v20 = v28;
      }
      else
      {
        if (!v29)
          goto LABEL_24;
        v21 = 5;
      }
      (*(void (**)(void))(*v20 + 8 * v21))();
    }
  }
LABEL_24:

  return v14 == 0;
}

void sub_1B79513DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E_(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 32);
  v3 = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CF0D88;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF0D88;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  double HistoryRoot;
  uint64_t v4;
  _BYTE v6[16];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v8 = 0u;
  v7 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = a2;
  v12 = a2;
  HistoryRoot = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::loadHistoryRoot((uint64_t)v6, *(ObjectIdentifier **)(a1 + 8), **(unsigned __int8 **)(a1 + 16));
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _BYTE *, double))(*(_QWORD *)v4 + 48))(v4, v6, HistoryRoot);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

double health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2, int a3)
{
  health::DataStore::ReadTransaction *v5;
  uint64_t *v6;
  uint64_t *v7;
  double result;
  std::runtime_error *exception;
  _BYTE v10[24];

  *(ObjectIdentifier *)(a1 + 72) = *a2;
  v5 = *(health::DataStore::ReadTransaction **)(a1 + 96);
  health::DataStore::ReadTransaction::_pointerForObject(v5, a2, (uint64_t)v10);
  if (v10[16])
  {
    v6 = (uint64_t *)*((_QWORD *)v5 + 3);
    v7 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v10);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v6, *v7, v7[1], (_QWORD *)a1);
  }
  else
  {
    if (!a3)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      _ZN6health15not_found_errorCI1St13runtime_errorEPKc(exception, "The requested sample history does not exist.");
    }
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)&result = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot(a1).n128_u64[0];
  }
  return result;
}

void sub_1B7951690(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot(uint64_t a1)
{
  uint64_t v2;
  __n128 result;
  uint64_t v4;
  health::BlockAccessFile::WriteTransaction *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __n128 *v12;
  __n128 v13;
  _OWORD v14[2];
  char v15;
  __int128 v16;
  uint64_t v17;

  v2 = *(_QWORD *)(a1 + 96);
  if (*(_QWORD *)(a1 + 64) == 56)
  {
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>(v2 + 80, *(_QWORD *)(a1 + 56), 56, (_QWORD *)a1);
    return result;
  }
  v16 = *(_OWORD *)(v2 + 32);
  v17 = v2 + 48;
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v16, (_QWORD *)(a1 + 72), 0, v14);
  if (!v15)
  {
    v5 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
LABEL_8:
    v9 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v5, 56);
    v11 = v10;
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>((uint64_t)v5, v9, v10, (_QWORD *)a1);
    v13.n128_u64[0] = v9;
    v13.n128_u64[1] = v11;
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v16, (__n128 *)(a1 + 72), &v13);
    goto LABEL_9;
  }
  v4 = *(_QWORD *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v14)
                 + 24);
  v5 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
  v6 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v14);
  v7 = *(_QWORD *)(v6 + 16);
  v8 = *(_QWORD *)(v6 + 24);
  if (v4 != 56)
  {
    health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v5, v7, v8);
    goto LABEL_8;
  }
  health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>((uint64_t)v5, v7, v8, (_QWORD *)a1);
LABEL_9:
  health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 96), (ObjectIdentifier *)(a1 + 72), (uint64_t)v14);
  v12 = (__n128 *)health::Optional<health::BlockPointer>::get((uint64_t)v14);
  result = *v12;
  *(__n128 *)(a1 + 56) = *v12;
  return result;
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[2];
  _QWORD v11[3];
  _BYTE v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 56;
  v11[0] = v12;
  v11[1] = v12;
  v11[2] = 56;
  v10[0] = *a4;
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[1];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[2];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[3];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[4];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[5];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[6];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  if (v14 <= 0x3FF)
    v8 = v12;
  else
    v8 = v13;
  health::RawBuffer::RawBuffer(v10, v8, v14);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B7951944(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF0E08;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEPNS0_6__baseIS14_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF0E08;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEEclES13_(uint64_t a1, uint64_t a2)
{
  _BYTE *v3;
  uint64_t v4;
  char *v5;
  _QWORD *v6;
  uint64_t v7;
  __int128 v9;
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_BYTE **)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 8);
  v9 = *(_OWORD *)(a1 + 16);
  v5 = (char *)operator new(0x28uLL);
  *(_QWORD *)v5 = &off_1E6CF0E88;
  *((_QWORD *)v5 + 1) = v4;
  *((_QWORD *)v5 + 2) = a2;
  *(_OWORD *)(v5 + 24) = v9;
  v11 = v5;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(v3, (uint64_t)v10);
  v6 = v11;
  if (v11 == v10)
  {
    v7 = 4;
    v6 = v10;
    goto LABEL_5;
  }
  if (v11)
  {
    v7 = 5;
LABEL_5:
    (*(void (**)(void))(*v6 + 8 * v7))();
  }
  return 1;
}

void sub_1B7951AC0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char *a16)
{
  char *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t (*v23)(void *);
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;

  if (!a2)
    _Unwind_Resume(a1);
  v18 = a16;
  if (a16 == &a13)
  {
    v19 = 4;
    v18 = &a13;
  }
  else
  {
    if (!a16)
      goto LABEL_7;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_7:
  v20 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    v21 = v20;
    _HKInitializeLogging();
    v22 = (void *)*MEMORY[0x1E0CB52B0];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_DEFAULT))
    {
      v23 = *(uint64_t (**)(void *))(*(_QWORD *)v21 + 16);
      v24 = v22;
      v25 = v23(v21);
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v25;
      _os_log_impl(&dword_1B7802000, v24, OS_LOG_TYPE_DEFAULT, "Caught std::exception during ignore block; ignoring: %s",
        (uint8_t *)&buf,
        0xCu);

    }
  }
  else
  {
    _HKInitializeLogging();
    v26 = *MEMORY[0x1E0CB52B0];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_1B7802000, v26, OS_LOG_TYPE_DEFAULT, "Caught unknown during ignore block; ignoring.",
        (uint8_t *)&buf,
        2u);
    }
  }
  __cxa_end_catch();
  JUMPOUT(0x1B7951A8CLL);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_;
}

_BYTE *health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(_BYTE *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  _QWORD *v7;
  _QWORD v8[3];
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)result + 6))
  {
    v2 = *(_QWORD *)(*((_QWORD *)result + 11) + 24);
    v8[0] = 0;
    v8[1] = 0;
    v8[2] = v2;
    v6 = *((_OWORD *)result + 1);
    v7 = v8;
    std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v9, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>((uint64_t *)&v6, (uint64_t)v9, 0);
    result = v10;
    if (v10 == v9)
    {
      v5 = 4;
      result = v9;
    }
    else
    {
      if (!v10)
        return result;
      v5 = 5;
    }
    return (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t))(*(_QWORD *)result + 8 * v5))(result, v3, v4);
  }
  return result;
}

void sub_1B7951D20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19)
{
  char *v20;
  uint64_t v21;

  v20 = a19;
  if (a19 == &a16)
  {
    v21 = 4;
    v20 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _OWORD v8[26];

  v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v14[28];
  uint64_t v15;

  if (*(_WORD *)(a3 + 408))
  {
    v7 = result;
    v8 = *(_WORD *)(a3 + 408) - 1;
    if (!(_DWORD)a5)
      v8 = 0;
    if (*(_BYTE *)(a3 + 410))
    {
      v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(_QWORD *)(v9 + 16);
      v12 = *(_QWORD *)(v7 + 16);
      memset(v14, 0, 410);
      memset(&v14[26], 0, 32);
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      v15 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v15, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 374;
  health::RawBuffer::RawBuffer(v11, v12, 374);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 374;
  health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B7951FF8(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  _QWORD *v5;
  uint64_t v7;
  __int16 v8;

  for (i = 0; i != 17; ++i)
  {
    v5 = (_QWORD *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    v7 = 0;
    health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
    *v5 = v7;
    _HDRawQuantitySampleValueV1::deserialize((uint64_t)(v5 + 1), a2);
  }
  v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 408) = v8;
  health::BlockPointer::deserialize((_QWORD *)(a1 + 416), a2);
  return health::BlockPointer::deserialize((_QWORD *)(a1 + 432), a2);
}

float _HDRawQuantitySampleValueV1::deserialize(uint64_t a1, uint64_t a2)
{
  float result;
  uint64_t v5;
  float v6;

  v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *(_QWORD *)a1 = v5;
  v6 = 0.0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v6);
  result = v6;
  *(float *)(a1 + 8) = v6;
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  void **v6;
  unint64_t v7;
  double v8;
  unint64_t *v9;
  uint64_t v10;
  __n128 v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  double v16;
  unint64_t *v17;
  uint64_t v18;
  __n128 v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  unint64_t v26;
  double *v27;
  uint64_t v28;
  __n128 v29;
  void *v30;
  uint64_t v31;
  void **v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  unint64_t v37;
  double *v38;
  uint64_t v39;
  __n128 v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  std::string v44;
  void *v45[2];
  void *v46[2];
  void *v47[2];
  std::string v48;
  void *v49[2];
  void *v50[2];
  void *v51[2];
  std::string __p;
  void *v53[2];
  void *v54[2];
  void *v55[2];
  std::string v56;
  void *v57[2];
  void *v58[2];
  void *v59[2];
  std::string v60;
  void *v61[2];
  void *v62[2];
  void *v63[2];
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _OWORD v88[2];
  __int128 v89;
  __int128 v90;
  std::string v91;
  _QWORD v92[2];
  _QWORD v93[2];
  _QWORD v94[2];

  v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 408))
    {
      v14 = *(unsigned __int16 *)(a2 + 408) - 1;
      v15 = 1;
      v16 = 0.0;
      while (1)
      {
        v17 = (unint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v14);
        v18 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            v20 = (void *)*MEMORY[0x1E0CB52B0];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        v21 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v21)
          break;
        v16 = *(double *)v17;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0)
          return result;
        ++v15;
        if (--v14 == -1)
          goto LABEL_35;
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    v16 = 0.0;
LABEL_35:
    v32 = (void **)MEMORY[0x1E0CB52B0];
    v33 = *(_QWORD *)(a2 + 416);
    v34 = *(_QWORD *)(a2 + 424);
    while (1)
    {
      v35 = *(_QWORD *)(v43 + 16);
      if (v33 == *(_QWORD *)v35 && v34 == *(_QWORD *)(v35 + 8))
        break;
      v87 = 0u;
      memset(v88, 0, 26);
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v75 = 0u;
      v76 = 0u;
      v73 = 0u;
      v74 = 0u;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v64 = 0u;
      v89 = 0u;
      v90 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v33, v34, (uint64_t)&v64);
      if (!WORD4(v88[1]))
      {
        v36 = *v32;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      v37 = WORD4(v88[1]) - 1;
      do
      {
        v38 = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v37);
        v39 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v37);
        if (*v38 >= v16)
        {
          v41 = *v32;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        v42 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v42)
          goto LABEL_48;
        v16 = *v38;
        v40.n128_f64[0] = *v38;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0)
          return result;
        --v37;
      }
      while (v37 != -1);
      v34 = *((_QWORD *)&v89 + 1);
      v33 = v89;
    }
  }
  else if (!a4)
  {
    v6 = (void **)MEMORY[0x1E0CB52B0];
    if (*(_WORD *)(a2 + 408))
    {
      v7 = 0;
      v8 = 0.0;
      while (1)
      {
        v9 = (unint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v7);
        v10 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v94, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v93, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v92, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v91);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v94, (uint64_t)v93, (uint64_t)v92, 382, (uint64_t)&v91);
          }
        }
        v13 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v13)
          goto LABEL_48;
        v8 = *(double *)v9;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0)
          return result;
        if (++v7 >= *(unsigned __int16 *)(a2 + 408))
          goto LABEL_22;
      }
    }
    v8 = 0.0;
LABEL_22:
    v22 = *(_QWORD *)(a2 + 432);
    v23 = *(_QWORD *)(a2 + 440);
    while (1)
    {
      v24 = *(_QWORD *)(v43 + 16);
      if (v22 == *(_QWORD *)v24 && v23 == *(_QWORD *)(v24 + 8))
        break;
      v87 = 0u;
      memset(v88, 0, 26);
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v75 = 0u;
      v76 = 0u;
      v73 = 0u;
      v74 = 0u;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v64 = 0u;
      v89 = 0u;
      v90 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)&v64);
      if (!WORD4(v88[1]))
      {
        v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      v26 = 0;
      do
      {
        v27 = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v26);
        v28 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v26);
        if (*v27 <= v8)
        {
          v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        v31 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v31)
          goto LABEL_48;
        v8 = *v27;
        v29.n128_f64[0] = *v27;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0)
          return result;
        ++v26;
      }
      while (v26 < WORD4(v88[1]));
      v23 = *((_QWORD *)&v90 + 1);
      v22 = v90;
    }
  }
  return result;
}

void sub_1B79528B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a28 < 0)
    operator delete(__p);
  if (a34 < 0)
    operator delete(a29);
  if (a40 < 0)
    operator delete(a35);
  if (a46 < 0)
    operator delete(a41);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF0E88;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEPNS0_6__baseIS1D_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF0E88;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EEclES19_S1C_(_QWORD *a1, void **a2, __int128 *a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v7;
  id *v8;
  uint64_t v9;
  id *v10;
  uint64_t v11;
  __int128 v13;
  uint64_t (*v14)(uint64_t);
  void *v15;
  uint64_t v16;
  void **v17;
  uint64_t v18;
  uint64_t v19;
  id v20;

  v4 = *a2;
  v5 = *(_QWORD *)(a1[1] + 24);
  v13 = *a3;
  v20 = v4;
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  v7 = (*(uint64_t (**)(uint64_t, id *, __int128 *))(*(_QWORD *)v5 + 48))(v5, &v20, &v13);
  *(_QWORD *)&v13 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v13 + 1) = 3221225472;
  v14 = ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clId27_HDRawQuantitySampleValueV1EEbSO_S12__block_invoke;
  v15 = &__block_descriptor_64_e9_B16__0__8l;
  v8 = (id *)a1[3];
  v16 = a1[2];
  v17 = a2;
  v18 = v7;
  v19 = v9;
  if (v8)
    v10 = &v20;
  else
    v10 = 0;
  if (v8)
    v20 = *v8;
  v11 = hfd_catchExceptionsAsErrors(&v13, (uint64_t)v10, 0);
  if (v8)
    objc_storeStrong(v8, v20);
  return v11;
}

void sub_1B7952C40(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  **(_BYTE **)(v1 + 32) = 1;
  __cxa_end_catch();
  JUMPOUT(0x1B7952C20);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE11target_typeEv()
{
  return &_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_;
}

uint64_t ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clId27_HDRawQuantitySampleValueV1EEbSO_S12__block_invoke(uint64_t a1)
{
  uint64_t v1;
  double *v2;
  _OWORD *v3;
  health::BlockAccessFile::WriteTransaction *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[27];
  _QWORD v36[4];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(double **)(a1 + 40);
  v3 = (_OWORD *)(a1 + 48);
  v4 = (health::BlockAccessFile::WriteTransaction *)(*(_QWORD *)(v1 + 96) + 80);
  v36[0] = 0;
  v36[1] = 0;
  v36[2] = v4;
  v36[3] = v4;
  v6 = *(_QWORD *)(v1 + 16);
  v5 = *(_QWORD *)(v1 + 24);
  if (!v6)
  {
    if (v5)
    {
      v6 = 0;
    }
    else
    {
      v34 = 0u;
      memset(v35, 0, sizeof(v35));
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v14 = 0u;
      v15 = 0u;
      v12 = 0u;
      v13 = 0u;
      v11 = 0u;
      v6 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v4, 411);
      v5 = v7;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v4, v6, v7, (uint64_t)&v11);
      *(_QWORD *)(v1 + 16) = v6;
      *(_QWORD *)(v1 + 24) = v5;
    }
  }
  *(_QWORD *)&v11 = v6;
  *((_QWORD *)&v11 + 1) = v5;
  *(_QWORD *)&v12 = v36;
  v8 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::setValueForKey((uint64_t *)&v11, v2, v3);
  v9 = *(_QWORD *)(v1 + 48);
  if (v9)
  {
    if (!v8)
      *(_QWORD *)(v1 + 48) = v9 + 1;
  }
  else
  {
    *(_QWORD *)(v1 + 48) = 1;
    *(_OWORD *)v1 = xmmword_1B7F3B410;
  }
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot(v1);
  return 1;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::setValueForKey(uint64_t *a1, double *a2, _OWORD *a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  health::BlockAccessFile::WriteTransaction *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[416];
  _OWORD __src[26];
  _OWORD v15[26];

  v6 = a1[2];
  memset(v15, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    v8 = a1[2];
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(v13, __src, sizeof(v13));
    v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 411);
    v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)v13);
    WORD4(__src[25]) = 1;
    *((_QWORD *)&__src[0] + 1) = v10;
    *(_QWORD *)&__src[1] = v12;
    BYTE10(__src[25]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, _OWORD *a6)
{
  unsigned int v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  double v17;
  uint64_t v18;
  __int128 *v19;
  health::BlockAccessFile::WriteTransaction *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  double v30;
  double v31;
  int v32;
  health::BlockAccessFile::WriteTransaction *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  double v40;
  health::BlockAccessFile::WriteTransaction *v41;
  void *v42;
  uint64_t v43;
  std::string::size_type v44;
  std::string *v45;
  _BYTE *v46;
  void *v47;
  _OWORD *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  health::BlockAccessFile::WriteTransaction *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  _BYTE *v61;
  __int128 v64;
  void *__p[2];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  _BYTE v89[26];
  __int128 v90;
  __int128 v91;
  _OWORD v92[26];
  __int128 v93;
  __int128 v94;
  _BYTE v95[410];
  char v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99[3];
  std::string v100;
  __int128 v101;
  __int128 v102;

  if (!*(_WORD *)(a4 + 408))
  {
    memset(&v95[24], 0, 384);
    v19 = *(__int128 **)(a1 + 16);
    v97 = *v19;
    v98 = *v19;
    *(_WORD *)&v95[408] = 1;
    *(double *)v95 = *a5;
    *(_OWORD *)&v95[8] = *a6;
    v20 = (health::BlockAccessFile::WriteTransaction *)*((_QWORD *)v19 + 3);
    v21 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v20, 374);
    v23 = v22;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t)v20, v21, v22, (uint64_t)v95);
    *(double *)a4 = *a5;
    *(_QWORD *)(a4 + 8) = v21;
    *(_QWORD *)(a4 + 16) = v23;
    *(_WORD *)(a4 + 408) = 1;
    *(_BYTE *)(a4 + 410) = 1;
LABEL_8:
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
  if (*(_BYTE *)(a4 + 410))
  {
    v11 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
    *(_OWORD *)v99 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11)+ 8);
    v12 = *(_QWORD *)(a1 + 16);
    memset(v95, 0, sizeof(v95));
    v98 = 0u;
    v97 = 0u;
    v13 = *(_OWORD *)v99;
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v12 + 24), v99[0], v99[1], (uint64_t)v95);
    v14 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v99, (uint64_t)v95, a5, a6);
    v15 = v14;
    if (v14 <= 1)
    {
      v16 = *a5;
      if (v16 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11))
      {
        v17 = *a5;
        *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11) = v17;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
      }
      return v15;
    }
    v32 = *(unsigned __int16 *)(a4 + 408);
    if (v32 == 17)
    {
      v18 = 2;
      if (v11 == 16)
      {
        if ((_DWORD)v14 == 4)
          return 4;
        else
          return 2;
      }
      else if (!v11)
      {
        if ((_DWORD)v14 == 3)
          return 3;
        else
          return 2;
      }
      return v18;
    }
    if ((_DWORD)v14 == 4 && v32 - 1 == v11)
    {
      memset((char *)&v92[1] + 8, 0, 384);
      WORD4(v92[25]) = 1;
      *(double *)v92 = *a5;
      *(_OWORD *)((char *)v92 + 8) = *a6;
      v93 = *(_OWORD *)v99;
      v94 = v98;
      v33 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
      v34 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v33, 374);
      v36 = v35;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t)v33, v34, v35, (uint64_t)v92);
      *(_QWORD *)&v98 = v34;
      *((_QWORD *)&v98 + 1) = v36;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v13, *((uint64_t *)&v13 + 1), (uint64_t)v95);
      v37 = *(_QWORD *)(a1 + 16);
      if (v94 != *(_OWORD *)v37)
      {
        v87 = 0u;
        v88 = 0u;
        v85 = 0u;
        v86 = 0u;
        v83 = 0u;
        v84 = 0u;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v77 = 0u;
        v78 = 0u;
        v75 = 0u;
        v76 = 0u;
        v73 = 0u;
        v74 = 0u;
        v71 = 0u;
        v72 = 0u;
        v69 = 0u;
        v70 = 0u;
        v67 = 0u;
        v68 = 0u;
        *(_OWORD *)__p = 0u;
        v66 = 0u;
        v90 = 0u;
        v91 = 0u;
        memset(v89, 0, sizeof(v89));
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v37 + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
        *(_QWORD *)&v90 = v34;
        *((_QWORD *)&v90 + 1) = v36;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
      }
      v38 = *(unsigned __int16 *)(a4 + 408);
      v39 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v38);
      *(_QWORD *)(v39 + 8) = v34;
      *(_QWORD *)(v39 + 16) = v36;
      v40 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v38) = v40;
      ++*(_WORD *)(a4 + 408);
      goto LABEL_8;
    }
    v64 = *(_OWORD *)v99;
    memset(&v92[12], 0, 216);
    v93 = *(_OWORD *)v99;
    v94 = v98;
    if (*(unsigned __int16 *)&v95[408] >= 0x12uLL)
    {
      v47 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(__p, "sourceIndex + elementCount <= Length");
      std::string::basic_string[abi:ne180100]<0>(&v102, "copyElementsFromArrayToIndex");
      std::string::basic_string[abi:ne180100]<0>(&v101, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Copy would overflow source.", &v100);
      health::_HDAssertImplementation<std::out_of_range>(v47, (uint64_t)__p, (uint64_t)&v102, (uint64_t)&v101, 80, (uint64_t)&v100);
    }
    v48 = &v95[24 * *(unsigned __int16 *)&v95[408] - 192];
    v49 = v48[9];
    v92[8] = v48[8];
    v92[9] = v49;
    v50 = v48[11];
    v92[10] = v48[10];
    v92[11] = v50;
    v51 = v48[5];
    v92[4] = v48[4];
    v92[5] = v51;
    v52 = v48[7];
    v92[6] = v48[6];
    v92[7] = v52;
    v53 = v48[1];
    v92[0] = *v48;
    v92[1] = v53;
    v54 = v48[3];
    v92[2] = v48[2];
    v92[3] = v54;
    *(_WORD *)&v95[408] -= 8;
    WORD4(v92[25]) = 8;
    v55 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
    v56 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v55, 374);
    v58 = v57;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t)v55, (uint64_t)v56, v57, (uint64_t)v92);
    *(_QWORD *)&v102 = v56;
    *((_QWORD *)&v102 + 1) = v58;
    v98 = v102;
    v59 = *(_QWORD *)(a1 + 16);
    if (v94 != *(_OWORD *)v59)
    {
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v75 = 0u;
      v76 = 0u;
      v73 = 0u;
      v74 = 0u;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      *(_OWORD *)__p = 0u;
      v66 = 0u;
      v90 = 0u;
      v91 = 0u;
      memset(v89, 0, sizeof(v89));
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v59 + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
      v90 = v102;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
    }
    __p[0] = *(void **)&v92[0];
    __p[1] = v56;
    *(_QWORD *)&v66 = v58;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)__p, v11 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v64, *((uint64_t *)&v64 + 1), (uint64_t)v95);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)v92)
    {
      v60 = (uint64_t *)&v64;
      v61 = v95;
    }
    else
    {
      v60 = (uint64_t *)&v102;
      v61 = v92;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v60, (uint64_t)v61, a5, a6);
  }
  v25 = a2 + 1;
  v26 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  v27 = v26;
  v102 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v26)+ 8);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_interiorChildAtIndex((uint64_t)v95, a1, v25, a4, v26);
  v28 = (a2 + 2);
  v29 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v28, &v102, v95, a5, a6);
  if (v29 > 1)
  {
    if (*(_WORD *)(a4 + 408) == 17)
      return 2;
    v101 = v102;
    memset(&v92[1], 0, 395);
    BYTE10(v92[25]) = v96;
    v92[0] = 0u;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v92, 0, (uint64_t)v95, *(unsigned __int16 *)&v95[408] - 8, 8);
    *(_WORD *)&v95[408] -= 8;
    WORD4(v92[25]) = 8;
    v41 = *(health::BlockAccessFile::WriteTransaction **)(*(_QWORD *)(a1 + 16) + 24);
    v42 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v41, 411);
    v44 = v43;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v41, (uint64_t)v42, v43, (uint64_t)v92);
    v100.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
    v100.__r_.__value_.__l.__size_ = v44;
    __p[0] = *(void **)&v92[0];
    __p[1] = v42;
    *(_QWORD *)&v66 = v44;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)__p, v27 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v101, *((uint64_t *)&v101 + 1), (uint64_t)v95);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)v92)
    {
      v45 = (std::string *)&v101;
      v46 = v95;
    }
    else
    {
      v45 = &v100;
      v46 = v92;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v28, v45, v46, a5, a6);
  }
  v18 = v29;
  v30 = *a5;
  if (v30 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v26))
  {
    v31 = *a5;
    *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v26) = v31;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1], a4);
  }
  return v18;
}

void sub_1B7953888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v16;

  if (*(char *)(v16 - 177) < 0)
    operator delete(*(void **)(v16 - 200));
  if (*(char *)(v16 - 153) < 0)
    operator delete(*(void **)(v16 - 176));
  if (*(char *)(v16 - 121) < 0)
    operator delete(*(void **)(v16 - 144));
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t result;
  _QWORD v12[2];
  _QWORD v13[3];
  _BYTE v14[1024];
  unsigned __int8 *v15;
  unint64_t v16;
  uint64_t v17;

  v8 = 0;
  v17 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16 = 374;
  v13[0] = v14;
  v13[1] = v14;
  v13[2] = 374;
  do
  {
    v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v8);
    v12[0] = *(_QWORD *)v9;
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    v12[0] = *(_QWORD *)(v9 + 8);
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    LODWORD(v12[0]) = *(_DWORD *)(v9 + 16);
    health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v13, v12);
    ++v8;
  }
  while (v8 != 17);
  LOWORD(v12[0]) = *(_WORD *)(a4 + 408);
  health::SerializationBuffer::appendRaw<unsigned short>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 416);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 424);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 432);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(_QWORD *)(a4 + 440);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  if (v16 <= 0x3FF)
    v10 = v14;
  else
    v10 = v15;
  health::RawBuffer::RawBuffer(v12, v10, v16);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v12);
  result = (uint64_t)v15;
  v15 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B7953A88(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(uint64_t a1, uint64_t *a2, uint64_t a3, double *a4, _OWORD *a5)
{
  void *v10;
  unsigned int v11;
  uint64_t v12;
  double v13;
  double v14;
  double *v15;
  int v16;
  unint64_t v18;
  double v19;
  void *v20;
  double *v21;
  __int128 v22;
  std::string __p;
  void *v24[2];
  void *v25[2];
  void *v26[2];

  if (!*(_WORD *)(a3 + 408))
  {
    v10 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v26, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v25, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 72, (uint64_t)&__p);
  }
  v11 = *(unsigned __int16 *)(a3 + 408) - 1;
  v12 = 1;
  while (1)
  {
    v13 = *a4;
    if (v13 > *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v11))break;
    v14 = *a4;
    v15 = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v11);
    v16 = (unsigned __int16)v11;
    if (v14 == *v15)
    {
      *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, (unsigned __int16)v11)+ 8) = *a5;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a2, a2[1], a3);
      return 1;
    }
    --v11;
    if (!v16)
    {
      v12 = 0;
      LOWORD(v11) = 0;
      break;
    }
  }
  if (*(_WORD *)(a3 + 408) == 17)
  {
    if (*a4 >= *(double *)a3)
    {
      if (*a4 <= *(double *)(a3 + 384))
        return 2;
      else
        return 4;
    }
    else
    {
      return 3;
    }
  }
  else
  {
    v18 = v12 + (unsigned __int16)v11;
    v19 = *a4;
    v22 = *a5;
    if (v18 >= 0x11)
    {
      v20 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v26, "index < Length");
      std::string::basic_string[abi:ne180100]<0>(v25, "insertElementAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Index out of bounds.", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v20, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 57, (uint64_t)&__p);
    }
    v21 = (double *)(a3 + 24 * v18);
    memmove(v21 + 3, v21, 24 * (16 - v18));
    *v21 = v19;
    *(_OWORD *)(v21 + 1) = v22;
    ++*(_WORD *)(a3 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a2, a2[1], a3);
    return 0;
  }
}

void sub_1B7953DA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  if (a34 < 0)
    operator delete(a29);
  _Unwind_Resume(exception_object);
}

double *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_interiorChildAtIndex(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5)
{
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *result;
  double v16;
  void *v17;
  double v18;
  void *v19;
  std::string v20;
  void *v21[2];
  void *v22[2];
  void *v23[2];
  std::string v24;
  void *v25[2];
  void *v26[2];
  void *v27[2];
  std::string __p;
  void *v29[2];
  _QWORD v30[2];
  _QWORD v31[2];
  std::string v32;
  _QWORD v33[2];
  _QWORD v34[2];
  _QWORD v35[2];

  if (*(unsigned __int16 *)(a4 + 408) <= a5)
  {
    v9 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a3 >= 64)
  {
    v10 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
  v12 = *(_QWORD *)(v11 + 8);
  v13 = *(_QWORD *)(v11 + 16);
  v14 = *(_QWORD *)(a2 + 16);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 395) = 0u;
  result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, a1);
  if (*(_WORD *)(a1 + 408))
  {
    v16 = *(double *)a1;
    result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
    if (v16 < *result)
    {
      v17 = (void *)*MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a4 + 408) - 1 > (int)a5)
    {
      v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, *(unsigned __int16 *)(a1 + 408) - 1);
      result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5 + 1);
      if (v18 >= *result)
      {
        v19 = (void *)*MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1B79541E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

void std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CF0F48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CF0F48;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, health::DataStore::WriteTransaction *a2)
{
  _BYTE v5[16];
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  health::DataStore::WriteTransaction *v11;
  health::DataStore::WriteTransaction *v12;
  __int128 v13;
  _QWORD *v14;
  _QWORD v15[4];
  _BYTE __dst[416];
  _OWORD __src[26];

  v6 = 0u;
  v7 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = a2;
  v12 = a2;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)(a1 + 8), 0);
  v15[0] = 0;
  v15[1] = 0;
  v15[2] = (char *)v12 + 80;
  v15[3] = (char *)v12 + 80;
  if (v6 != 0)
  {
    v13 = v6;
    v14 = v15;
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t *)v12 + 10, v6, *((uint64_t *)&v6 + 1), (uint64_t)__src);
    memcpy(__dst, __src, sizeof(__dst));
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>((uint64_t)&v13, 0, (unint64_t *)&v13, (uint64_t)__dst);
  }
  v8 = 0;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot((uint64_t)v5);
  health::DataStore::WriteTransaction::removeObjectWithIdentifier(a2, *(ObjectIdentifier **)(a1 + 8));
  return 1;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t a1, int a2, unint64_t *a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE v13[416];
  _BYTE __src[416];

  if (*(_WORD *)(a4 + 408))
  {
    v8 = 0;
    v9 = (a2 + 1);
    do
    {
      if (*(_BYTE *)(a4 + 410))
      {
        v10 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v8);
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeLeaf<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(a1, (uint64_t *)(v10 + 8));
      }
      else
      {
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_interiorChildAtIndex((uint64_t)__src, a1, a2, a4, (unsigned __int16)v8);
        v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v8)+ 8;
        memcpy(v13, __src, sizeof(v13));
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(a1, v9, v11, v13);
      }
      ++v8;
    }
    while (v8 < *(unsigned __int16 *)(a4 + 408));
  }
  return health::BlockAccessFile::WriteTransaction::freeBlock(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), *a3, a3[1]);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeLeaf<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  _OWORD v9[26];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _BYTE v36[26];
  __int128 v37;
  __int128 v38;

  v4 = *(_QWORD *)(a1 + 16);
  memset(v9, 0, 410);
  v10 = 0u;
  v11 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v4 + 24), *a2, a2[1], (uint64_t)v9);
  if (WORD4(v9[25]))
  {
    v5 = 0;
    do
    {
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v9, v5);
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v9, v5++);
    }
    while (v5 < WORD4(v9[25]));
  }
  v6 = *(unint64_t **)(a1 + 16);
  v7 = v11;
  if (v11 != *(_OWORD *)v6)
  {
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v37 = 0u;
    v38 = 0u;
    memset(v36, 0, sizeof(v36));
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t *)v6[3], v11, *((uint64_t *)&v11 + 1), (uint64_t)&v12);
    v37 = v10;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v11, *((uint64_t *)&v11 + 1), (uint64_t)&v12);
    v6 = *(unint64_t **)(a1 + 16);
    v7 = *v6;
  }
  if (v10 != __PAIR128__(v6[1], v7))
  {
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v37 = 0u;
    v38 = 0u;
    memset(v36, 0, sizeof(v36));
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t *)v6[3], v10, *((uint64_t *)&v10 + 1), (uint64_t)&v12);
    v38 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 24), v10, *((uint64_t *)&v10 + 1), (uint64_t)&v12);
    v6 = *(unint64_t **)(a1 + 16);
  }
  return health::BlockAccessFile::WriteTransaction::freeBlock(v6[3], *a2, a2[1]);
}

void sub_1B7954A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1B7954D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1B79556B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7956318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__48(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__48(uint64_t a1)
{

}

void sub_1B79571EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__49(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__49(uint64_t a1)
{

}

void sub_1B7959320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v12 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1B79596A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCloudSyncCodableRegistryReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  HDCloudSyncCodableProfileIdentifier *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t result;
  char v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char v33;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 0x14u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 32;
        goto LABEL_27;
      case 0x15u:
        *(_BYTE *)(a1 + 76) |= 1u;
        v21 = *v3;
        v22 = *(_QWORD *)(a2 + v21);
        if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v22 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v23 = 0;
        }
        *(_QWORD *)(a1 + 8) = v23;
        goto LABEL_42;
      case 0x16u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 40;
LABEL_27:
        v24 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_42;
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
LABEL_33:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_42;
      case 0x1Eu:
        v20 = objc_alloc_init(HDCloudSyncCodableProfileIdentifier);
        v25 = 48;
        goto LABEL_30;
      case 0x1Fu:
        v20 = objc_alloc_init(HDCloudSyncCodableProfileIdentifier);
        v25 = 56;
LABEL_30:
        objc_storeStrong((id *)(a1 + v25), v20);
        if (PBReaderPlaceMark()
          && (HDCloudSyncCodableProfileIdentifierReadFrom((uint64_t)v20, a2) & 1) != 0)
        {
LABEL_40:
          PBReaderRecallMark();
LABEL_41:

LABEL_42:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_58:

        return 0;
      default:
        switch((v10 >> 3))
        {
          case 1u:
            PBReaderReadString();
            v20 = (HDCloudSyncCodableProfileIdentifier *)objc_claimAutoreleasedReturnValue();
            if (v20)
              objc_msgSend((id)a1, "addDisabledOwnerIdentifiers:", v20);
            goto LABEL_41;
          case 2u:
            v20 = objc_alloc_init(HDCloudSyncCodableRegisteredStore);
            objc_msgSend((id)a1, "addStores:", v20);
            if (!PBReaderPlaceMark() || !HDCloudSyncCodableRegisteredStoreReadFrom((uint64_t)v20, a2))
              goto LABEL_58;
            goto LABEL_40;
          case 3u:
            v20 = objc_alloc_init(HDCodableSyncIdentity);
            objc_msgSend((id)a1, "addDisabledSyncIdentities:", v20);
            if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v20, a2))
              goto LABEL_40;
            goto LABEL_58;
          case 0xAu:
            v27 = 0;
            v28 = 0;
            v29 = 0;
            *(_BYTE *)(a1 + 76) |= 2u;
            break;
          default:
            goto LABEL_33;
        }
        while (2)
        {
          v30 = *v3;
          v31 = *(_QWORD *)(a2 + v30);
          v32 = v31 + 1;
          if (v31 == -1 || v32 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v31);
            *(_QWORD *)(a2 + v30) = v32;
            v29 |= (unint64_t)(v33 & 0x7F) << v27;
            if (v33 < 0)
            {
              v27 += 7;
              v15 = v28++ >= 9;
              if (v15)
              {
                v29 = 0;
                goto LABEL_54;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v29 = 0;
LABEL_54:
        *(_BYTE *)(a1 + 72) = v29 != 0;
        goto LABEL_42;
    }
  }
}

BOOL HDCodableMedicalCodingReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
          goto LABEL_25;
        case 2u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 24;
          goto LABEL_25;
        case 3u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 8;
          goto LABEL_25;
        case 4u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 32;
LABEL_25:
          v19 = *(void **)(a1 + v18);
          *(_QWORD *)(a1 + v18) = v17;

          goto LABEL_26;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0)
            return 0;
LABEL_26:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          break;
      }
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCloudSyncCodableAttachmentManagementRecordReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  void *v18;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(void **)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v17;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7961DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__50(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__50(uint64_t a1)
{

}

void sub_1B7961F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableGeneratedObjectCollectionReadFrom(void *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableMedicationDoseEvent *v17;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 273)
      {
        v17 = objc_alloc_init(HDCodableMedicationDoseEvent);
        objc_msgSend(a1, "addMedicationDoseEvent:", v17);
        if (!PBReaderPlaceMark() || (HDCodableMedicationDoseEventReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7968D64(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableMedicalIDDataReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  unint64_t v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  HDCodableDateComponents *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char v55;
  uint64_t v56;
  unint64_t v57;
  char v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  char v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  char v100;
  unsigned int v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  char v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  char v110;
  unsigned int v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  char v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  char v120;
  unsigned int v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  char v125;
  uint64_t v126;
  unint64_t v127;
  void *v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t result;
  BOOL v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    v18 = v10 >> 3;
    if ((int)(v10 >> 3) <= 99)
    {
      switch((_DWORD)v18)
      {
        case 1:
          PBReaderReadData();
          v36 = objc_claimAutoreleasedReturnValue();
          v37 = 328;
LABEL_188:
          v128 = *(void **)(a1 + v37);
          *(_QWORD *)(a1 + v37) = v36;

          break;
        case 2:
          *(_QWORD *)(a1 + 404) |= 0x200uLL;
          v129 = *v3;
          v130 = *(_QWORD *)(a2 + v129);
          if (v130 <= 0xFFFFFFFFFFFFFFF7 && v130 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v130);
            *(_QWORD *)(a2 + v129) = v130 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v35 = 0;
          }
          v136 = 80;
LABEL_283:
          *(_QWORD *)(a1 + v136) = v35;
          break;
        case 3:
          v26 = 0;
          v27 = 0;
          v28 = 0;
          *(_QWORD *)(a1 + 404) |= 0x100000000uLL;
          while (1)
          {
            v29 = *v3;
            v30 = *(_QWORD *)(a2 + v29);
            v31 = v30 + 1;
            if (v30 == -1 || v31 > *(_QWORD *)(a2 + *v4))
              break;
            v32 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v30);
            *(_QWORD *)(a2 + v29) = v31;
            v28 |= (unint64_t)(v32 & 0x7F) << v26;
            if ((v32 & 0x80) == 0)
              goto LABEL_199;
            v26 += 7;
            v15 = v27++ >= 9;
            if (v15)
            {
              LODWORD(v28) = 0;
              goto LABEL_201;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_199:
          if (*(_BYTE *)(a2 + *v5))
            LODWORD(v28) = 0;
LABEL_201:
          v134 = 384;
LABEL_206:
          *(_DWORD *)(a1 + v134) = v28;
          break;
        default:
LABEL_192:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          break;
      }
      goto LABEL_284;
    }
    switch((int)v18)
    {
      case 100:
        v19 = 0;
        v20 = 0;
        v21 = 0;
        *(_QWORD *)(a1 + 404) |= 0x200000000uLL;
        while (2)
        {
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          v24 = v23 + 1;
          if (v23 == -1 || v24 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v25 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
            *(_QWORD *)(a2 + v22) = v24;
            v21 |= (unint64_t)(v25 & 0x7F) << v19;
            if (v25 < 0)
            {
              v19 += 7;
              v15 = v20++ >= 9;
              if (v15)
              {
                v21 = 0;
                goto LABEL_197;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_197:
        v132 = v21 != 0;
        v133 = 400;
        goto LABEL_215;
      case 101:
        *(_QWORD *)(a1 + 404) |= 0x2000uLL;
        v33 = *v3;
        v34 = *(_QWORD *)(a2 + v33);
        if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v34);
          *(_QWORD *)(a2 + v33) = v34 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 112;
        goto LABEL_283;
      case 102:
        PBReaderReadData();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = 368;
        goto LABEL_188;
      case 103:
        *(_QWORD *)(a1 + 404) |= 0x800000uLL;
        v38 = *v3;
        v39 = *(_QWORD *)(a2 + v38);
        if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v39);
          *(_QWORD *)(a2 + v38) = v39 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 192;
        goto LABEL_283;
      case 104:
        PBReaderReadString();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = 360;
        goto LABEL_188;
      case 105:
        *(_QWORD *)(a1 + 404) |= 0x400000uLL;
        v40 = *v3;
        v41 = *(_QWORD *)(a2 + v40);
        if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v41);
          *(_QWORD *)(a2 + v40) = v41 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 184;
        goto LABEL_283;
      case 106:
        v42 = objc_alloc_init(HDCodableDateComponents);
        objc_storeStrong((id *)(a1 + 304), v42);
        if (!PBReaderPlaceMark() || (HDCodableDateComponentsReadFrom((uint64_t)v42, a2) & 1) == 0)
          goto LABEL_286;
        goto LABEL_173;
      case 107:
        *(_QWORD *)(a1 + 404) |= 0x800uLL;
        v43 = *v3;
        v44 = *(_QWORD *)(a2 + v43);
        if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v44);
          *(_QWORD *)(a2 + v43) = v44 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 96;
        goto LABEL_283;
      case 108:
        v42 = objc_alloc_init(HDCodableQuantity);
        v45 = 312;
        goto LABEL_59;
      case 109:
        *(_QWORD *)(a1 + 404) |= 0x1000uLL;
        v46 = *v3;
        v47 = *(_QWORD *)(a2 + v46);
        if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v47);
          *(_QWORD *)(a2 + v46) = v47 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 104;
        goto LABEL_283;
      case 110:
        v42 = objc_alloc_init(HDCodableQuantity);
        v45 = 392;
LABEL_59:
        objc_storeStrong((id *)(a1 + v45), v42);
        if (!PBReaderPlaceMark() || (HDCodableQuantityReadFrom((uint64_t)v42, a2) & 1) == 0)
          goto LABEL_286;
        goto LABEL_173;
      case 111:
        *(_QWORD *)(a1 + 404) |= 0x40000000uLL;
        v48 = *v3;
        v49 = *(_QWORD *)(a2 + v48);
        if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v49);
          *(_QWORD *)(a2 + v48) = v49 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 248;
        goto LABEL_283;
      case 112:
        v50 = 0;
        v51 = 0;
        v28 = 0;
        *(_QWORD *)(a1 + 404) |= 0x80000000uLL;
        while (2)
        {
          v52 = *v3;
          v53 = *(_QWORD *)(a2 + v52);
          v54 = v53 + 1;
          if (v53 == -1 || v54 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v55 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v53);
            *(_QWORD *)(a2 + v52) = v54;
            v28 |= (unint64_t)(v55 & 0x7F) << v50;
            if (v55 < 0)
            {
              v50 += 7;
              v15 = v51++ >= 9;
              if (v15)
              {
                LODWORD(v28) = 0;
                goto LABEL_205;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v28) = 0;
LABEL_205:
        v134 = 272;
        goto LABEL_206;
      case 113:
        *(_QWORD *)(a1 + 404) |= 0x10uLL;
        v56 = *v3;
        v57 = *(_QWORD *)(a2 + v56);
        if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v57);
          *(_QWORD *)(a2 + v56) = v57 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 40;
        goto LABEL_283;
      case 114:
        v58 = 0;
        v59 = 0;
        v60 = 0;
        *(_QWORD *)(a1 + 404) |= 0x4000uLL;
        while (2)
        {
          v61 = *v3;
          v62 = *(_QWORD *)(a2 + v61);
          v63 = v62 + 1;
          if (v62 == -1 || v63 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v64 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v62);
            *(_QWORD *)(a2 + v61) = v63;
            v60 |= (unint64_t)(v64 & 0x7F) << v58;
            if (v64 < 0)
            {
              v58 += 7;
              v15 = v59++ >= 9;
              if (v15)
              {
                v60 = 0;
                goto LABEL_210;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v60 = 0;
LABEL_210:
        v135 = 120;
        goto LABEL_228;
      case 115:
        *(_QWORD *)(a1 + 404) |= 0x8000uLL;
        v65 = *v3;
        v66 = *(_QWORD *)(a2 + v65);
        if (v66 <= 0xFFFFFFFFFFFFFFF7 && v66 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v66);
          *(_QWORD *)(a2 + v65) = v66 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 128;
        goto LABEL_283;
      case 116:
        v42 = objc_alloc_init(HDCodableEmergencyContact);
        objc_msgSend((id)a1, "addEmergencyContacts:", v42);
        if (!PBReaderPlaceMark() || !HDCodableEmergencyContactReadFrom((uint64_t)v42, a2))
          goto LABEL_286;
        goto LABEL_173;
      case 117:
        *(_QWORD *)(a1 + 404) |= 0x400uLL;
        v67 = *v3;
        v68 = *(_QWORD *)(a2 + v67);
        if (v68 <= 0xFFFFFFFFFFFFFFF7 && v68 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v68);
          *(_QWORD *)(a2 + v67) = v68 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 88;
        goto LABEL_283;
      case 118:
        v42 = objc_alloc_init(HDCodableClinicalContact);
        objc_msgSend((id)a1, "addClinicalContacts:", v42);
        if (!PBReaderPlaceMark() || !HDCodableClinicalContactReadFrom((uint64_t)v42, a2))
          goto LABEL_286;
        goto LABEL_173;
      case 119:
        *(_QWORD *)(a1 + 404) |= 0x20uLL;
        v69 = *v3;
        v70 = *(_QWORD *)(a2 + v69);
        if (v70 <= 0xFFFFFFFFFFFFFFF7 && v70 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v70);
          *(_QWORD *)(a2 + v69) = v70 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 48;
        goto LABEL_283;
      case 120:
        PBReaderReadString();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = 320;
        goto LABEL_188;
      case 121:
        *(_QWORD *)(a1 + 404) |= 0x10000uLL;
        v71 = *v3;
        v72 = *(_QWORD *)(a2 + v71);
        if (v72 <= 0xFFFFFFFFFFFFFFF7 && v72 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v72);
          *(_QWORD *)(a2 + v71) = v72 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 136;
        goto LABEL_283;
      case 122:
        PBReaderReadString();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = 336;
        goto LABEL_188;
      case 123:
        *(_QWORD *)(a1 + 404) |= 0x20000uLL;
        v73 = *v3;
        v74 = *(_QWORD *)(a2 + v73);
        if (v74 <= 0xFFFFFFFFFFFFFFF7 && v74 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v74);
          *(_QWORD *)(a2 + v73) = v74 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 144;
        goto LABEL_283;
      case 124:
        PBReaderReadString();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = 264;
        goto LABEL_188;
      case 125:
        *(_QWORD *)(a1 + 404) |= 8uLL;
        v75 = *v3;
        v76 = *(_QWORD *)(a2 + v75);
        if (v76 <= 0xFFFFFFFFFFFFFFF7 && v76 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v76);
          *(_QWORD *)(a2 + v75) = v76 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 32;
        goto LABEL_283;
      case 126:
        PBReaderReadString();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = 344;
        goto LABEL_188;
      case 127:
        *(_QWORD *)(a1 + 404) |= 0x40000uLL;
        v77 = *v3;
        v78 = *(_QWORD *)(a2 + v77);
        if (v78 <= 0xFFFFFFFFFFFFFFF7 && v78 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v78);
          *(_QWORD *)(a2 + v77) = v78 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 152;
        goto LABEL_283;
      case 128:
        v79 = 0;
        v80 = 0;
        v81 = 0;
        *(_QWORD *)(a1 + 404) |= 0x400000000uLL;
        while (2)
        {
          v82 = *v3;
          v83 = *(_QWORD *)(a2 + v82);
          v84 = v83 + 1;
          if (v83 == -1 || v84 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v85 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v83);
            *(_QWORD *)(a2 + v82) = v84;
            v81 |= (unint64_t)(v85 & 0x7F) << v79;
            if (v85 < 0)
            {
              v79 += 7;
              v15 = v80++ >= 9;
              if (v15)
              {
                v81 = 0;
                goto LABEL_214;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v81 = 0;
LABEL_214:
        v132 = v81 != 0;
        v133 = 401;
LABEL_215:
        *(_BYTE *)(a1 + v133) = v132;
        goto LABEL_284;
      case 129:
        *(_QWORD *)(a1 + 404) |= 0x20000000uLL;
        v86 = *v3;
        v87 = *(_QWORD *)(a2 + v86);
        if (v87 <= 0xFFFFFFFFFFFFFFF7 && v87 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v87);
          *(_QWORD *)(a2 + v86) = v87 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 240;
        goto LABEL_283;
      case 130:
        PBReaderReadString();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = 376;
        goto LABEL_188;
      case 131:
        *(_QWORD *)(a1 + 404) |= 0x10000000uLL;
        v88 = *v3;
        v89 = *(_QWORD *)(a2 + v88);
        if (v89 <= 0xFFFFFFFFFFFFFFF7 && v89 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v89);
          *(_QWORD *)(a2 + v88) = v89 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 232;
        goto LABEL_283;
      case 132:
        *(_QWORD *)(a1 + 404) |= 0x4000000uLL;
        v90 = *v3;
        v91 = *(_QWORD *)(a2 + v90);
        if (v91 <= 0xFFFFFFFFFFFFFFF7 && v91 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v91);
          *(_QWORD *)(a2 + v90) = v91 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 216;
        goto LABEL_283;
      case 133:
        *(_QWORD *)(a1 + 404) |= 0x8000000uLL;
        v92 = *v3;
        v93 = *(_QWORD *)(a2 + v92);
        if (v93 <= 0xFFFFFFFFFFFFFFF7 && v93 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v93);
          *(_QWORD *)(a2 + v92) = v93 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 224;
        goto LABEL_283;
      case 136:
        *(_QWORD *)(a1 + 404) |= 0x1000000uLL;
        v94 = *v3;
        v95 = *(_QWORD *)(a2 + v94);
        if (v95 <= 0xFFFFFFFFFFFFFFF7 && v95 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v95);
          *(_QWORD *)(a2 + v94) = v95 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 200;
        goto LABEL_283;
      case 137:
        *(_QWORD *)(a1 + 404) |= 0x2000000uLL;
        v96 = *v3;
        v97 = *(_QWORD *)(a2 + v96);
        if (v97 <= 0xFFFFFFFFFFFFFFF7 && v97 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v97);
          *(_QWORD *)(a2 + v96) = v97 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 208;
        goto LABEL_283;
      case 138:
        v42 = objc_alloc_init(HDCodableMedicalIDMedication);
        objc_msgSend((id)a1, "addMedicationsList:", v42);
        if (!PBReaderPlaceMark() || (HDCodableMedicalIDMedicationReadFrom((uint64_t)v42, a2) & 1) == 0)
          goto LABEL_286;
        goto LABEL_173;
      case 139:
        *(_QWORD *)(a1 + 404) |= 0x80000uLL;
        v98 = *v3;
        v99 = *(_QWORD *)(a2 + v98);
        if (v99 <= 0xFFFFFFFFFFFFFFF7 && v99 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v99);
          *(_QWORD *)(a2 + v98) = v99 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 160;
        goto LABEL_283;
      case 140:
        v100 = 0;
        v101 = 0;
        v60 = 0;
        *(_QWORD *)(a1 + 404) |= 0x100000uLL;
        while (2)
        {
          v102 = *v3;
          v103 = *(_QWORD *)(a2 + v102);
          v104 = v103 + 1;
          if (v103 == -1 || v104 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v105 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v103);
            *(_QWORD *)(a2 + v102) = v104;
            v60 |= (unint64_t)(v105 & 0x7F) << v100;
            if (v105 < 0)
            {
              v100 += 7;
              v15 = v101++ >= 9;
              if (v15)
              {
                v60 = 0;
                goto LABEL_219;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v60 = 0;
LABEL_219:
        v135 = 168;
        goto LABEL_228;
      case 141:
        *(_QWORD *)(a1 + 404) |= 0x200000uLL;
        v106 = *v3;
        v107 = *(_QWORD *)(a2 + v106);
        if (v107 <= 0xFFFFFFFFFFFFFFF7 && v107 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v107);
          *(_QWORD *)(a2 + v106) = v107 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 176;
        goto LABEL_283;
      case 142:
        v42 = objc_alloc_init(HDCodableMedicalIDAllergy);
        objc_msgSend((id)a1, "addAllergiesList:", v42);
        if (!PBReaderPlaceMark() || (HDCodableMedicalIDAllergyReadFrom((uint64_t)v42, a2) & 1) == 0)
          goto LABEL_286;
        goto LABEL_173;
      case 143:
        *(_QWORD *)(a1 + 404) |= 1uLL;
        v108 = *v3;
        v109 = *(_QWORD *)(a2 + v108);
        if (v109 <= 0xFFFFFFFFFFFFFFF7 && v109 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v109);
          *(_QWORD *)(a2 + v108) = v109 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 8;
        goto LABEL_283;
      case 144:
        v110 = 0;
        v111 = 0;
        v60 = 0;
        *(_QWORD *)(a1 + 404) |= 2uLL;
        while (2)
        {
          v112 = *v3;
          v113 = *(_QWORD *)(a2 + v112);
          v114 = v113 + 1;
          if (v113 == -1 || v114 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v115 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v113);
            *(_QWORD *)(a2 + v112) = v114;
            v60 |= (unint64_t)(v115 & 0x7F) << v110;
            if (v115 < 0)
            {
              v110 += 7;
              v15 = v111++ >= 9;
              if (v15)
              {
                v60 = 0;
                goto LABEL_223;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v60 = 0;
LABEL_223:
        v135 = 16;
        goto LABEL_228;
      case 145:
        *(_QWORD *)(a1 + 404) |= 4uLL;
        v116 = *v3;
        v117 = *(_QWORD *)(a2 + v116);
        if (v117 <= 0xFFFFFFFFFFFFFFF7 && v117 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v117);
          *(_QWORD *)(a2 + v116) = v117 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 24;
        goto LABEL_283;
      case 146:
        v42 = objc_alloc_init(HDCodableMedicalIDCondition);
        objc_msgSend((id)a1, "addConditionsList:", v42);
        if (PBReaderPlaceMark() && (HDCodableMedicalIDConditionReadFrom((uint64_t)v42, a2) & 1) != 0)
        {
LABEL_173:
          PBReaderRecallMark();

LABEL_284:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_286:

        return 0;
      case 147:
        *(_QWORD *)(a1 + 404) |= 0x40uLL;
        v118 = *v3;
        v119 = *(_QWORD *)(a2 + v118);
        if (v119 <= 0xFFFFFFFFFFFFFFF7 && v119 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v119);
          *(_QWORD *)(a2 + v118) = v119 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 56;
        goto LABEL_283;
      case 148:
        v120 = 0;
        v121 = 0;
        v60 = 0;
        *(_QWORD *)(a1 + 404) |= 0x80uLL;
        while (2)
        {
          v122 = *v3;
          v123 = *(_QWORD *)(a2 + v122);
          v124 = v123 + 1;
          if (v123 == -1 || v124 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v125 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v123);
            *(_QWORD *)(a2 + v122) = v124;
            v60 |= (unint64_t)(v125 & 0x7F) << v120;
            if (v125 < 0)
            {
              v120 += 7;
              v15 = v121++ >= 9;
              if (v15)
              {
                v60 = 0;
                goto LABEL_227;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v60 = 0;
LABEL_227:
        v135 = 64;
LABEL_228:
        *(_QWORD *)(a1 + v135) = v60;
        goto LABEL_284;
      case 149:
        *(_QWORD *)(a1 + 404) |= 0x100uLL;
        v126 = *v3;
        v127 = *(_QWORD *)(a2 + v126);
        if (v127 <= 0xFFFFFFFFFFFFFFF7 && v127 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v127);
          *(_QWORD *)(a2 + v126) = v127 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v35 = 0;
        }
        v136 = 72;
        goto LABEL_283;
      default:
        goto LABEL_192;
    }
  }
}

uint64_t _HDAddFrozenAndExpectedSyncAnchorColumns(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8B58, a4) ^ 1;

  return v6;
}

uint64_t _HDAddSyncAnchorUpdateDateColumns(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8B70, a4) ^ 1;

  return v6;
}

uint64_t _HDAddUniqueConstraintToSessionControllersTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8B88, a4) ^ 1;

  return v6;
}

uint64_t _HDAddAlarmEventsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("CREATE TABLE IF NOT EXISTS alarm_events (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, client_identifier TEXT NOT NULL, due_date REAL, due_date_components BLOB, event_identifier TEXT NOT NULL, UNIQUE(client_identifier, event_identifier), CHECK((due_date IS NULL AND due_date_components IS NOT NULL) OR (due_date IS NOT NULL AND due_date_components IS NULL)))"), a4) ^ 1;

  return v6;
}

uint64_t _HDAddSourceOwnerBundleIdentifierAndDropSyncPrimary(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8BB8, a4) ^ 1;

  return v6;
}

uint64_t _HDAddSourceOrderModificationDate(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  _QWORD v10[6];

  v10[5] = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v10[0] = CFSTR("CREATE TABLE datatype_source_order_new (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, data_type INTEGER NOT NULL, source INTEGER NOT NULL REFERENCES sources (ROWID) ON DELETE CASCADE, user_preferred INTEGER NOT NULL, provenance INTEGER NOT NULL, modification_date REAL NOT NULL);");
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("INSERT INTO datatype_source_order_new (data_type, source, user_preferred, provenance, modification_date) SELECT data_type, source, user_preferred, provenance, %lf FROM datatype_source_order ORDER BY ROWID ASC"), CFAbsoluteTimeGetCurrent());
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v10[1] = v6;
  v10[2] = CFSTR("DROP TABLE datatype_source_order");
  v10[3] = CFSTR("ALTER TABLE datatype_source_order_new RENAME TO datatype_source_order");
  v10[4] = CFSTR("CREATE INDEX datatype_source_order_data_type ON datatype_source_order (data_type, ROWID)");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v10, 5);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v5, "unprotectedDatabase");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  LODWORD(a4) = objc_msgSend(v8, "executeSQLStatements:error:", v7, a4);
  return a4 ^ 1;
}

uint64_t _HDAddLatestActivityDateToWorkoutSessionsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8BD0, a4) ^ 1;

  return v6;
}

uint64_t _HDResetReceivedAnchorsForCategoryAndQuantitySamples(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6;
  void *v7;
  int v8;
  void *v9;
  uint64_t v10;

  v6 = a2;
  objc_msgSend(a1, "behavior");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v7, "isAppleWatch");

  if (v8)
  {
    objc_msgSend(v6, "unprotectedDatabase");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = objc_msgSend(v9, "executeSQLStatements:error:", &unk_1E6DF8BE8, a4) ^ 1;

  }
  else
  {
    v10 = 0;
  }

  return v10;
}

uint64_t _HDAddEventOptionsToAlarmEventsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8BA0, a4) ^ 1;

  return v6;
}

uint64_t _HDAddQuantitySampleStatisticsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8C00, a4) ^ 1;

  return v6;
}

uint64_t _HDAddMenstrualCycleDaySummaryTable()
{
  return 0;
}

uint64_t _HDUpdateActivityCacheTableForYukon(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8C18, a4) ^ 1;

  return v6;
}

uint64_t _HDAddConceptIndexTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8C30, a4) ^ 1;

  return v6;
}

uint64_t _HDRemoveDuplicatedHeartRateContextMetadata(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("DELETE FROM metadata_values WHERE key_id=(SELECT rowid FROM metadata_keys WHERE key='HKMetadataKeyHeartRateMotionContext') AND (EXISTS (SELECT * FROM metadata_values mvprivate WHERE mvprivate.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateHeartRateContext') AND mvprivate.object_id=metadata_values.object_id))"), a4) ^ 1;

  return v6;
}

uint64_t _HDAddLocaleToMedicalRecords(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE medical_records ADD COLUMN locale TEXT"), a4) ^ 1;

  return v6;
}

uint64_t _HDUpdateFitnessFriendActivitySnapshotsTableForYukon(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8C48, a4) ^ 1;

  return v6;
}

uint64_t _HDUpdateDiagnosticTestReportColumnNames(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE diagnostic_test_report_samples RENAME COLUMN status TO status_coding;"),
                       a4) ^ 1;

  return v6;
}

uint64_t _HDUpdateFitnessFriendWorkoutTableForYukon(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8C60, a4) ^ 1;

  return v6;
}

uint64_t _HDUpdateConceptIndexTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8C78, a4) ^ 1;

  return v6;
}

uint64_t _HDUpdateVaccinationRecordColumnNames(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE vaccination_record_samples RENAME COLUMN body_site_coding TO body_site_codings;"),
                       a4) ^ 1;

  return v6;
}

uint64_t _HDMoveClinicalCredentialsToKeychain(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  int v7;
  HDLegacyClinicalCredentialManager *v8;
  BOOL v9;
  id v10;
  NSObject *v11;
  void *v12;
  uint64_t v13;
  id v15;
  uint8_t buf[4];
  id v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "executeSQLStatements:error:", &unk_1E6DF8C90, a4);

  if (v7)
  {
    v8 = objc_alloc_init(HDLegacyClinicalCredentialManager);
    v15 = 0;
    v9 = -[HDLegacyClinicalCredentialManager deleteCredentialKeyFromKeychainWithError:](v8, "deleteCredentialKeyFromKeychainWithError:", &v15);
    v10 = v15;
    if (!v9)
    {
      _HKInitializeLogging();
      v11 = *MEMORY[0x1E0CB52B0];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v17 = v10;
        _os_log_error_impl(&dword_1B7802000, v11, OS_LOG_TYPE_ERROR, "Failed to delete credential key from keychain during migration: %{public}@", buf, 0xCu);
      }
    }
    objc_msgSend(v5, "protectedDatabase");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v12, "executeUncachedSQL:error:", CFSTR("DROP TABLE clinical_credentials_old"), a4) ^ 1;

  }
  else
  {
    v13 = 1;
  }

  return v13;
}

uint64_t _HDRemoveMenstrualCycleDaySummaryTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  int v10;
  const __CFString *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "dumpSchemaWithError:", a4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (v6)
  {
    if (objc_msgSend(MEMORY[0x1E0D29850], "databaseSchemas:containTable:", v6, CFSTR("menstrual_cycle_day_summary_samples")))
    {
      v7 = objc_msgSend(v5, "deleteDataEntitySubclassTable:intermediateTables:error:", CFSTR("menstrual_cycle_day_summary_samples"), &unk_1E6DF8CA8, a4) ^ 1;
    }
    else
    {
      _HKInitializeLogging();
      v8 = *MEMORY[0x1E0CB52B0];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_INFO))
      {
        v10 = 138412290;
        v11 = CFSTR("menstrual_cycle_day_summary_samples");
        _os_log_impl(&dword_1B7802000, v8, OS_LOG_TYPE_INFO, "Skipping deletion from nonexistent table \"%@\"", (uint8_t *)&v10, 0xCu);
      }
      v7 = 0;
    }
  }
  else
  {
    v7 = 1;
  }

  return v7;
}

uint64_t _HDAddAllergyIntoleranceStatus(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE allergy_record_samples ADD COLUMN status_coding BLOB"), a4) ^ 1;

  return v6;
}

uint64_t _HDResetClinicalAccountEntityLastSubmittedRow(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("UPDATE clinical_accounts SET last_submitted_rowid = NULL"), a4) ^ 1;

  return v6;
}

uint64_t _HDAddOntologyVersionToConceptIndex(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE concept_index ADD COLUMN ontology_version INTEGER NOT NULL DEFAULT 0"), a4) ^ 1;

  return v6;
}

uint64_t _HDAddDerivedFlagsToDataProvenances(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  int v7;
  void *v8;
  int v9;
  uint64_t v10;
  _QWORD v12[4];
  id v13;
  __CFString *v14;
  __CFString *v15;

  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "executeSQLStatements:error:", &unk_1E6DF8CC0, a4);

  if (v7)
  {
    objc_msgSend(v5, "protectedDatabase");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = ___HDAddDerivedFlagsToDataProvenances_block_invoke;
    v12[3] = &unk_1E6CF16E0;
    v13 = v5;
    v14 = CFSTR("SELECT (product_type LIKE 'Watch%%') FROM sources WHERE ROWID=? LIMIT 1");
    v15 = CFSTR("UPDATE data_provenances SET derived_flags=? WHERE ROWID=?");
    v9 = objc_msgSend(v8, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT ROWID, source_id FROM data_provenances"), a4, 0, v12);

    v10 = v9 ^ 1u;
  }
  else
  {
    v10 = 1;
  }

  return v10;
}

uint64_t _HDAddCountryToMedicalRecord(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8CD8, a4);

  return a4 ^ 1;
}

uint64_t _HDAddMedicalRecordState(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE medical_records ADD COLUMN state INTEGER NOT NULL DEFAULT 0"), a4) ^ 1;

  return v6;
}

uint64_t _HDWipeWorkoutAnchors(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("DELETE FROM sync_anchors WHERE schema = 'main' AND type = 5;"),
                       a4) ^ 1;

  return v6;
}

void sub_1B7973134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Block_object_dispose((const void *)(v15 - 96), 8);
  _Unwind_Resume(a1);
}

id HDSimpleGraphAttributeEntityPredicateForNodeID(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;

  v3 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "predicateWithProperty:value:comparisonType:", CFSTR("node_id"), v4, a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

uint64_t HDCodableUserDomainConceptLinkReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t v23;
  void *v24;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        PBReaderReadData();
        v23 = objc_claimAutoreleasedReturnValue();
        v24 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v23;

      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_31;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            v19 = 0;
            goto LABEL_33;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5))
          v19 = 0;
LABEL_33:
        *(_QWORD *)(a1 + 8) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7977CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

void sub_1B7979214(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__51(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__51(uint64_t a1)
{

}

uint64_t HDCodableRoutinePredictedLocationsResponseReadFrom(void *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableRoutinePredictedLocation *v17;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v17 = objc_alloc_init(HDCodableRoutinePredictedLocation);
        objc_msgSend(a1, "addPredictedLocationsOfInterest:", v17);
        if (!PBReaderPlaceMark()
          || (HDCodableRoutinePredictedLocationReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B797C5DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__52(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__52(uint64_t a1)
{

}

uint64_t HDCloudSyncCodableDeviceContextReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  BOOL v17;
  HDCodableSyncIdentity *v18;
  uint64_t result;
  char v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (2)
    {
      if (!*(_BYTE *)(a2 + *v5))
      {
        v8 = 0;
        v9 = 0;
        v10 = 0;
        while (1)
        {
          v11 = *v3;
          v12 = *(_QWORD *)(a2 + v11);
          v13 = v12 + 1;
          if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
            break;
          v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
          *(_QWORD *)(a2 + v11) = v13;
          v10 |= (unint64_t)(v14 & 0x7F) << v8;
          if ((v14 & 0x80) == 0)
            goto LABEL_12;
          v8 += 7;
          v15 = v9++ >= 9;
          if (v15)
          {
            v10 = 0;
            v16 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
        v16 = *(unsigned __int8 *)(a2 + *v5);
        if (*(_BYTE *)(a2 + *v5))
          v10 = 0;
LABEL_14:
        if (v16)
          v17 = 1;
        else
          v17 = (v10 & 7) == 4;
        if (!v17)
        {
          switch((v10 >> 3))
          {
            case 1u:
              v18 = objc_alloc_init(HDCodableSyncIdentity);
              objc_storeStrong((id *)(a1 + 48), v18);
              if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v18, a2))
              {
                PBReaderRecallMark();

                goto LABEL_44;
              }

              return 0;
            case 2u:
              v20 = 0;
              v21 = 0;
              v22 = 0;
              *(_BYTE *)(a1 + 56) |= 2u;
              break;
            case 3u:
              PBReaderReadString();
              v27 = objc_claimAutoreleasedReturnValue();
              v28 = 24;
              goto LABEL_34;
            case 4u:
              PBReaderReadString();
              v27 = objc_claimAutoreleasedReturnValue();
              v28 = 32;
              goto LABEL_34;
            case 5u:
              PBReaderReadString();
              v27 = objc_claimAutoreleasedReturnValue();
              v28 = 40;
LABEL_34:
              v29 = *(void **)(a1 + v28);
              *(_QWORD *)(a1 + v28) = v27;

              goto LABEL_44;
            case 6u:
              *(_BYTE *)(a1 + 56) |= 1u;
              v30 = *v3;
              v31 = *(_QWORD *)(a2 + v30);
              if (v31 <= 0xFFFFFFFFFFFFFFF7 && v31 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v32 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v31);
                *(_QWORD *)(a2 + v30) = v31 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v32 = 0;
              }
              *(_QWORD *)(a1 + 8) = v32;
              goto LABEL_44;
            default:
              result = PBReaderSkipValueWithTag();
              if (!(_DWORD)result)
                return result;
LABEL_44:
              if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
                return *(_BYTE *)(a2 + *v5) == 0;
              continue;
          }
          while (1)
          {
            v23 = *v3;
            v24 = *(_QWORD *)(a2 + v23);
            v25 = v24 + 1;
            if (v24 == -1 || v25 > *(_QWORD *)(a2 + *v4))
              break;
            v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v24);
            *(_QWORD *)(a2 + v23) = v25;
            v22 |= (unint64_t)(v26 & 0x7F) << v20;
            if ((v26 & 0x80) == 0)
              goto LABEL_39;
            v20 += 7;
            v15 = v21++ >= 9;
            if (v15)
            {
              v22 = 0;
              goto LABEL_41;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_39:
          if (*(_BYTE *)(a2 + *v5))
            v22 = 0;
LABEL_41:
          *(_QWORD *)(a1 + 16) = v22;
          goto LABEL_44;
        }
      }
      break;
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B797E4C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B797F394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__53(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__53(uint64_t a1)
{

}

void sub_1B797FC68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__54(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__54(uint64_t a1)
{

}

void sub_1B797FFBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  uint64_t v14;
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1B798434C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__55(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__55(uint64_t a1)
{

}

void sub_1B7984574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL HDCodableEmergencyContactReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 8;
          goto LABEL_27;
        case 2u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
          goto LABEL_27;
        case 3u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 24;
          goto LABEL_27;
        case 4u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 32;
          goto LABEL_27;
        case 5u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 40;
          goto LABEL_27;
        case 6u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 48;
LABEL_27:
          v19 = *(void **)(a1 + v18);
          *(_QWORD *)(a1 + v18) = v17;

          goto LABEL_28;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0)
            return 0;
LABEL_28:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          break;
      }
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

id _EntityClasses()
{
  _QWORD v1[113];

  v1[112] = *MEMORY[0x1E0C80C00];
  v1[0] = objc_opt_class();
  v1[1] = objc_opt_class();
  v1[2] = objc_opt_class();
  v1[3] = objc_opt_class();
  v1[4] = objc_opt_class();
  v1[5] = objc_opt_class();
  v1[6] = objc_opt_class();
  v1[7] = objc_opt_class();
  v1[8] = objc_opt_class();
  v1[9] = objc_opt_class();
  v1[10] = objc_opt_class();
  v1[11] = objc_opt_class();
  v1[12] = objc_opt_class();
  v1[13] = objc_opt_class();
  v1[14] = objc_opt_class();
  v1[15] = objc_opt_class();
  v1[16] = objc_opt_class();
  v1[17] = objc_opt_class();
  v1[18] = objc_opt_class();
  v1[19] = objc_opt_class();
  v1[20] = objc_opt_class();
  v1[21] = objc_opt_class();
  v1[22] = objc_opt_class();
  v1[23] = objc_opt_class();
  v1[24] = objc_opt_class();
  v1[25] = objc_opt_class();
  v1[26] = objc_opt_class();
  v1[27] = objc_opt_class();
  v1[28] = objc_opt_class();
  v1[29] = objc_opt_class();
  v1[30] = objc_opt_class();
  v1[31] = objc_opt_class();
  v1[32] = objc_opt_class();
  v1[33] = objc_opt_class();
  v1[34] = objc_opt_class();
  v1[35] = objc_opt_class();
  v1[36] = objc_opt_class();
  v1[37] = objc_opt_class();
  v1[38] = objc_opt_class();
  v1[39] = objc_opt_class();
  v1[40] = objc_opt_class();
  v1[41] = objc_opt_class();
  v1[42] = objc_opt_class();
  v1[43] = objc_opt_class();
  v1[44] = objc_opt_class();
  v1[45] = objc_opt_class();
  v1[46] = objc_opt_class();
  v1[47] = objc_opt_class();
  v1[48] = objc_opt_class();
  v1[49] = objc_opt_class();
  v1[50] = objc_opt_class();
  v1[51] = objc_opt_class();
  v1[52] = objc_opt_class();
  v1[53] = objc_opt_class();
  v1[54] = objc_opt_class();
  v1[55] = objc_opt_class();
  v1[56] = objc_opt_class();
  v1[57] = objc_opt_class();
  v1[58] = objc_opt_class();
  v1[59] = objc_opt_class();
  v1[60] = objc_opt_class();
  v1[61] = objc_opt_class();
  v1[62] = objc_opt_class();
  v1[63] = objc_opt_class();
  v1[64] = objc_opt_class();
  v1[65] = objc_opt_class();
  v1[66] = objc_opt_class();
  v1[67] = objc_opt_class();
  v1[68] = objc_opt_class();
  v1[69] = objc_opt_class();
  v1[70] = objc_opt_class();
  v1[71] = objc_opt_class();
  v1[72] = objc_opt_class();
  v1[73] = objc_opt_class();
  v1[74] = objc_opt_class();
  v1[75] = objc_opt_class();
  v1[76] = objc_opt_class();
  v1[77] = objc_opt_class();
  v1[78] = objc_opt_class();
  v1[79] = objc_opt_class();
  v1[80] = objc_opt_class();
  v1[81] = objc_opt_class();
  v1[82] = objc_opt_class();
  v1[83] = objc_opt_class();
  v1[84] = objc_opt_class();
  v1[85] = objc_opt_class();
  v1[86] = objc_opt_class();
  v1[87] = objc_opt_class();
  v1[88] = objc_opt_class();
  v1[89] = objc_opt_class();
  v1[90] = objc_opt_class();
  v1[91] = objc_opt_class();
  v1[92] = objc_opt_class();
  v1[93] = objc_opt_class();
  v1[94] = objc_opt_class();
  v1[95] = objc_opt_class();
  v1[96] = objc_opt_class();
  v1[97] = objc_opt_class();
  v1[98] = objc_opt_class();
  v1[99] = objc_opt_class();
  v1[100] = objc_opt_class();
  v1[101] = objc_opt_class();
  v1[102] = objc_opt_class();
  v1[103] = objc_opt_class();
  v1[104] = objc_opt_class();
  v1[105] = objc_opt_class();
  v1[106] = objc_opt_class();
  v1[107] = objc_opt_class();
  v1[108] = objc_opt_class();
  v1[109] = objc_opt_class();
  v1[110] = objc_opt_class();
  v1[111] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v1, 112);
  return (id)objc_claimAutoreleasedReturnValue();
}

id _FutureEntityClasses()
{
  _QWORD v1[2];

  v1[1] = *MEMORY[0x1E0C80C00];
  v1[0] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v1, 1);
  return (id)objc_claimAutoreleasedReturnValue();
}

uint64_t health::_PageForEntry@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, health::FilePage *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  std::string v18;
  void *v19[2];
  void *v20[2];
  void *v21[2];
  std::string __p;
  void *v23[2];
  void *v24[2];
  _QWORD v25[2];
  _BYTE v26[8];
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;

  v27 = 0;
  v28 = 0;
  v30 = 0;
  v29 = 0;
  v8 = a3[1];
  v9 = health::VirtualFile::read<health::WriteAheadLog::LogEntryHeader>(*a1, v8, (uint64_t)v26);
  v10 = a3[2];
  *(_QWORD *)a4 = a2;
  *((_QWORD *)a4 + 1) = v10;
  v11 = operator new[]();
  std::shared_ptr<unsigned char>::shared_ptr[abi:ne180100]<unsigned char,std::default_delete<unsigned char []>,void>((_QWORD *)a4 + 2, v11);
  *((_QWORD *)a4 + 4) = 0;
  *((_QWORD *)a4 + 5) = 0;
  bzero(*((void **)a4 + 2), v10);
  v12 = *a1;
  v13 = *((_QWORD *)a4 + 2);
  if (!v13)
    v13 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a4 + 4) + 16))(*((_QWORD *)a4 + 4));
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v12 + 32))(v12, v9 + v8, v13, *((_QWORD *)a4 + 1));
  v14 = v30;
  result = health::FilePage::checksum(a4);
  if (v14 != (_DWORD)result)
  {
    v16 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v25, "entryHeader.pageChecksum == page.checksum()");
    std::string::basic_string[abi:ne180100]<0>(v24, "_PageForEntry");
    std::string::basic_string[abi:ne180100]<0>(v23, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Page failed checksum validation.", &__p);
    health::_HDAssertImplementation<health::data_corruption_error>(v16, (uint64_t)v25, (uint64_t)v24, (uint64_t)v23, 26, (uint64_t)&__p);
  }
  if (v27 != *a3)
  {
    v17 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v21, "entryHeader.transactionIdentifier == entry.transactionIdentifier");
    std::string::basic_string[abi:ne180100]<0>(v20, "_PageForEntry");
    std::string::basic_string[abi:ne180100]<0>(v19, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Page has unexpected transaction identifier.", &v18);
    health::_HDAssertImplementation<health::data_corruption_error>(v17, (uint64_t)v21, (uint64_t)v20, (uint64_t)v19, 27, (uint64_t)&v18);
  }
  return result;
}

void sub_1B79896E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  uint64_t v51;
  uint64_t v52;

  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v52);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v51);
  _Unwind_Resume(a1);
}

uint64_t health::FilePage::checksum(health::FilePage *this)
{
  health *v2;

  v2 = (health *)*((_QWORD *)this + 2);
  if (!v2)
    v2 = (health *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
  return health::FletcherChecksum(v2, *((char **)this + 1));
}

void health::_HDAssertImplementation<health::data_corruption_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  char **v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  std::runtime_error *exception;
  char **v34;
  std::string *v35;
  std::string::size_type size;
  _QWORD *v37;
  void *__p[2];
  char v39;
  std::string v40;
  uint64_t v41;
  uint64_t v42;
  void *v43[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)v43 = 0u;
  v44 = 0u;
  LODWORD(v10) = backtrace(v43, 20);
  v11 = backtrace_symbols(v43, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v41);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Critical Error: ", 16);
  v13 = *(char *)(a6 + 23);
  if (v13 >= 0)
    v14 = a6;
  else
    v14 = *(_QWORD *)a6;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a6 + 23);
  else
    v15 = *(_QWORD *)(a6 + 8);
  v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)"Failed assertion '", 18);
  v18 = *(char *)(a2 + 23);
  if (v18 >= 0)
    v19 = a2;
  else
    v19 = *(_QWORD *)a2;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(a2 + 23);
  else
    v20 = *(_QWORD *)(a2 + 8);
  v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  v23 = *(char *)(a3 + 23);
  if (v23 >= 0)
    v24 = a3;
  else
    v24 = *(_QWORD *)a3;
  if (v23 >= 0)
    v25 = *(unsigned __int8 *)(a3 + 23);
  else
    v25 = *(_QWORD *)(a3 + 8);
  v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  v28 = *(char *)(a4 + 23);
  if (v28 >= 0)
    v29 = a4;
  else
    v29 = *(_QWORD *)a4;
  if (v28 >= 0)
    v30 = *(unsigned __int8 *)(a4 + 23);
  else
    v30 = *(_QWORD *)(a4 + 8);
  v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  v32 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  v10 = (int)v10;
  if ((_DWORD)v10)
  {
    v34 = v11;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, *v34);
      health::HDDemangleBacktraceLine((uint64_t)__p, (unint64_t)&v40);
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v35 = &v40;
      else
        v35 = (std::string *)v40.__r_.__value_.__r.__words[0];
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v40.__r_.__value_.__r.__words[2]);
      else
        size = v40.__r_.__value_.__l.__size_;
      v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v41, (uint64_t)v35, size);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v40.__r_.__value_.__l.__data_);
      if (v39 < 0)
        operator delete(__p[0]);
      ++v34;
      --v10;
    }
    while (v10);
  }
  free(v11);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v42, &v40);
  std::runtime_error::runtime_error(exception, &v40);
  exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC2E8;
}

void sub_1B7989A54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0)
    operator delete(__p);
  a21 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a21 + *(_QWORD *)(a21 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a22 = MEMORY[0x1E0DE4FB8] + 16;
  if (a35 < 0)
    operator delete(a30);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&a38);
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::WriteAheadLog(uint64_t a1, __int128 *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD v8[2];

  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6D0A388;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6D0A2A8;
  v8[0] = v4 + 1;
  v8[1] = v4;
  health::WriteAheadLog::WriteAheadLog(a1, a2, v8);
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD v8[2];

  v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6D0A388;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6D0A2A8;
  v8[0] = v4 + 1;
  v8[1] = v4;
  health::WriteAheadLog::WriteAheadLog(a1, a2, v8);
  do
    v6 = __ldaxr(p_shared_owners);
  while (__stlxr(v6 - 1, p_shared_owners));
  if (!v6)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_1B7989BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::WriteAheadLog(uint64_t a1, __int128 *a2, _QWORD *a3)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::string *v7;
  __int128 v8;

  *(_QWORD *)a1 = 850045863;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 1018212795;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = 0;
  v4 = a3[1];
  *(_QWORD *)(a1 + 112) = *a3;
  *(_QWORD *)(a1 + 120) = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::string *)(a1 + 128);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v8 = *a2;
    *(_QWORD *)(a1 + 144) = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 1;
  *(_BYTE *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 1065353216;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 264) = a1 + 272;
  return a1;
}

void sub_1B7989CE8(_Unwind_Exception *a1)
{
  std::mutex *v1;
  std::condition_variable *v2;
  uint64_t v3;

  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v3);
  std::condition_variable::~condition_variable(v2);
  std::mutex::~mutex(v1);
  _Unwind_Resume(a1);
}

void sub_1B7989DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::~WriteAheadLog(health::WriteAheadLog *this)
{
  void **v2;

  health::WriteAheadLog::reset((std::mutex *)this);
  std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy((uint64_t)this + 264, *((_QWORD **)this + 34));
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 224);
  v2 = (void **)((char *)this + 200);
  std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::__destroy_vector::operator()[abi:ne180100](&v2);
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)this + 152);
  if (*((char *)this + 151) < 0)
    operator delete(*((void **)this + 16));
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)this + 112);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 64));
  std::mutex::~mutex((std::mutex *)this);
}

void health::WriteAheadLog::reset(std::mutex *this)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t j;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *k;
  char *opaque;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _QWORD *v20;
  __int128 v21;
  std::string __p;
  void *v23[2];
  void *v24[2];
  _QWORD v25[2];

  std::mutex::lock(this);
  if (*(_QWORD *)&this[3].__m_.__opaque[8] != *(_QWORD *)this[3].__m_.__opaque)
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v25, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v24, "reset");
    std::string::basic_string[abi:ne180100]<0>(v23, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to discard the log while a write transaction is open.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v2, (uint64_t)v25, (uint64_t)v24, (uint64_t)v23, 60, (uint64_t)&__p);
  }
  v4 = *(_QWORD *)this[3].__m_.__opaque;
  for (i = *(_QWORD *)&this[3].__m_.__opaque[8];
        i != v4;
  *(_QWORD *)&this[3].__m_.__opaque[8] = v4;
  v5 = *(_QWORD *)&this[3].__m_.__opaque[32];
  if (v5)
  {
    for (j = 0; j != v5; ++j)
      *(_QWORD *)(*(_QWORD *)&this[3].__m_.__opaque[24] + 8 * j) = 0;
    v7 = *(_QWORD **)&this[3].__m_.__opaque[40];
    *(_QWORD *)&this[3].__m_.__opaque[40] = 0;
    *(_QWORD *)&this[3].__m_.__opaque[48] = 0;
    if (v7)
    {
      do
      {
        v8 = (_QWORD *)*v7;
        operator delete(v7);
        v7 = v8;
      }
      while (v8);
    }
  }
  if (*(_QWORD *)&this[4].__m_.__opaque[16])
  {
    v9 = *(_QWORD **)this[4].__m_.__opaque;
    v10 = *(_QWORD *)&this[4].__m_.__opaque[8];
    *(_QWORD *)this[4].__m_.__opaque = (char *)this + 272;
    *(_QWORD *)(v10 + 16) = 0;
    *(_QWORD *)&this[4].__m_.__opaque[8] = 0;
    *(_QWORD *)&this[4].__m_.__opaque[16] = 0;
    if (v9[1])
      v11 = (_QWORD *)v9[1];
    else
      v11 = v9;
    if (v11 && (v12 = (_QWORD *)v11[2]) != 0)
    {
      v13 = (_QWORD *)*v12;
      if ((_QWORD *)*v12 == v11)
      {
        *v12 = 0;
        while (1)
        {
          v20 = (_QWORD *)v12[1];
          if (!v20)
            break;
          do
          {
            v12 = v20;
            v20 = (_QWORD *)*v20;
          }
          while (v20);
        }
      }
      else
      {
        for (v12[1] = 0; v13; v13 = (_QWORD *)v12[1])
        {
          do
          {
            v12 = v13;
            v13 = (_QWORD *)*v13;
          }
          while (v13);
        }
      }
      std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy((uint64_t)this[4].__m_.__opaque, v11);
      for (k = (_QWORD *)v12[2]; k; k = (_QWORD *)k[2])
        v12 = k;
      opaque = this[4].__m_.__opaque;
      v11 = v12;
    }
    else
    {
      opaque = this[4].__m_.__opaque;
    }
    std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy((uint64_t)opaque, v11);
  }
  v16 = *(_QWORD *)&this[2].__m_.__opaque[16];
  if (v16)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 64))(v16);
    v21 = 0uLL;
    std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100]((uint64_t)&this[2].__m_.__opaque[16], &v21);
    v17 = (std::__shared_weak_count *)*((_QWORD *)&v21 + 1);
    if (*((_QWORD *)&v21 + 1))
    {
      v18 = (unint64_t *)(*((_QWORD *)&v21 + 1) + 8);
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  std::mutex::unlock(this);
}

void sub_1B798A0A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  std::mutex *v28;
  uint64_t v29;

  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  if (*(char *)(v29 - 33) < 0)
    operator delete(*(void **)(v29 - 56));
  std::mutex::unlock(v28);
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::open(std::mutex *this, uint64_t a2)
{
  std::mutex::lock(this);
  health::WriteAheadLog::_walLock_openLogForFileIdentifier(&this->__m_.__sig, a2);
  std::mutex::unlock(this);
}

void sub_1B798A150(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t *health::WriteAheadLog::_walLock_openLogForFileIdentifier(uint64_t *this, uint64_t a2)
{
  health::WriteAheadLog *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  std::string v17;
  void *v18[2];
  void *v19[2];
  void *v20[2];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  std::string v25;
  void *v26[2];
  void *v27[2];
  void *v28[2];
  std::string __p;
  void *v30[2];
  void *v31[2];
  void *v32[2];
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v2 = (health::WriteAheadLog *)this;
  v43 = *MEMORY[0x1E0C80C00];
  v33 = a2;
  if (this[26] != this[25])
  {
    v3 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v32, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v31, "_walLock_openLogForFileIdentifier");
    std::string::basic_string[abi:ne180100]<0>(v30, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to open the log while transactions are active.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v3, (uint64_t)v32, (uint64_t)v31, (uint64_t)v30, 241, (uint64_t)&__p);
  }
  v5 = this + 19;
  v4 = this[19];
  if (!v4)
  {
    v6 = 0;
    v7 = this[14];
    v35 = 0x200000001;
    LODWORD(v36) = 0;
    do
    {
      v8 = *(_DWORD *)((char *)&v35 + v4);
      if (v8 >= 4)
        std::__throw_out_of_range[abi:ne180100]("bitset set argument out of range");
      v6 |= 1 << v8;
      v4 += 4;
    }
    while (v4 != 12);
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v7 + 16))(&v38);
    std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100]((uint64_t)v2 + 152, &v38);
    v9 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
    if (*((_QWORD *)&v38 + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    if (!*v5)
    {
      v12 = *MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v28, "_walFile");
      std::string::basic_string[abi:ne180100]<0>(v27, "_walLock_openLogForFileIdentifier");
      std::string::basic_string[abi:ne180100]<0>(v26, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
      health::FormatString<>((std::string *)"Failed to open WAL file.", &v25);
      health::_HDAssertImplementation<health::transaction_error>(v12, (uint64_t)v28, (uint64_t)v27, (uint64_t)v26, 249, (uint64_t)&v25);
    }
    v22 = 0x24857414CLL;
    v23 = 0;
    v24 = 0;
    v21 = 0;
    v13 = *v5;
    v41 = 0;
    v42 = 24;
    v35 = (uint64_t)&v38;
    v36 = &v38;
    v37 = 24;
    v14 = (*(uint64_t (**)(uint64_t, _QWORD, __int128 *, uint64_t))(*(_QWORD *)v13 + 32))(v13, 0, &v38, 24);
    LODWORD(v34) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v35, &v34);
    LODWORD(v22) = v34;
    LODWORD(v34) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v35, &v34);
    HIDWORD(v22) = v34;
    v34 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v35, &v34);
    v23 = v34;
    v34 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v35, &v34);
    v24 = v34;
    v15 = v41;
    v41 = 0;
    if (v15)
      MEMORY[0x1BCCAC47C](v15, 0x1000C8077774924);
    v21 = v14;
    if (v14 < 1)
    {
      if (!v14)
      {
        *(_QWORD *)&v38 = 0x24857414CLL;
        *((_QWORD *)&v38 + 1) = v33;
        v39 = 0;
        return (uint64_t *)health::VirtualFile::write<health::WriteAheadLog::LogHeader>(*v5, 0, (uint64_t)&v38);
      }
    }
    else if ((_DWORD)v22 == 1213677900 && HIDWORD(v22) <= 2)
    {
      if (v23 != v33)
      {
        v16 = *MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v20, "header.fileIdentifier == fileIdentifier");
        std::string::basic_string[abi:ne180100]<0>(v19, "_walLock_openLogForFileIdentifier");
        std::string::basic_string[abi:ne180100]<0>(v18, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
        v35 = 24;
        *(_QWORD *)&v38 = &v33;
        *((_QWORD *)&v38 + 1) = &v23;
        v39 = &v35;
        v40 = &v21;
        memset(&v17, 0, sizeof(v17));
        health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>((std::string *)"WAL file identifier does not match transactional file identifier; ignoring WAL file. (offset %l"
                         "d, header size %ld, header identifier %ld, file identifier %ld",
          &v17,
          0,
          (uint64_t)&v38);
        health::_HDAssertImplementation<health::data_corruption_error>(v16, (uint64_t)v20, (uint64_t)v19, (uint64_t)v18, 256, (uint64_t)&v17);
      }
      return (uint64_t *)health::WriteAheadLog::_walLock_loadExistingEntriesStartingAtOffset(v2, v21, HIDWORD(v22) == 1);
    }
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)*v5 + 56))(*v5, 0);
    *(_QWORD *)&v38 = 0x24857414CLL;
    *((_QWORD *)&v38 + 1) = v33;
    v39 = 0;
    return (uint64_t *)health::VirtualFile::write<health::WriteAheadLog::LogHeader>(*v5, 0, (uint64_t)&v38);
  }
  return this;
}

void sub_1B798A644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::maximumCommittedSizeForTransaction(std::mutex *this, unint64_t a2)
{
  char *v4;
  health::WriteAheadLog *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  health::WriteAheadLog *v16;
  uint64_t v17;
  char *v18;

  std::mutex::lock(this);
  v4 = &this[4].__m_.__opaque[8];
  v5 = *(health::WriteAheadLog **)this[4].__m_.__opaque;
  if (&this[4].__m_.__opaque[8] != (char *)v5)
  {
    do
    {
      v6 = *(char **)v4;
      v7 = *(char **)v4;
      v8 = v4;
      if (*(_QWORD *)v4)
      {
        do
        {
          v9 = v7;
          v7 = (char *)*((_QWORD *)v7 + 1);
        }
        while (v7);
      }
      else
      {
        do
        {
          v9 = (char *)*((_QWORD *)v8 + 2);
          v10 = *(_QWORD *)v9 == (_QWORD)v8;
          v8 = v9;
        }
        while (v10);
      }
      v11 = *((_QWORD *)v9 + 6);
      while (1)
      {
        v12 = v11;
        v13 = *(char **)v4;
        v14 = v4;
        if (v6)
        {
          do
          {
            v15 = v13;
            v13 = (char *)*((_QWORD *)v13 + 1);
          }
          while (v13);
        }
        else
        {
          do
          {
            v15 = (char *)*((_QWORD *)v14 + 2);
            v10 = *(_QWORD *)v15 == (_QWORD)v14;
            v14 = v15;
          }
          while (v10);
        }
        if (v12 == *((_QWORD *)v15 + 5))
          break;
        v11 = v12 - 24;
        if (*(_QWORD *)(v12 - 24) <= a2)
        {
          if (v6)
          {
            do
            {
              v18 = v6;
              v6 = (char *)*((_QWORD *)v6 + 1);
            }
            while (v6);
          }
          else
          {
            do
            {
              v18 = (char *)*((_QWORD *)v4 + 2);
              v10 = *(_QWORD *)v18 == (_QWORD)v4;
              v4 = v18;
            }
            while (v10);
          }
          v17 = *(_QWORD *)(v12 - 8) + *((_QWORD *)v18 + 4);
          goto LABEL_25;
        }
      }
      if (v6)
      {
        do
        {
          v16 = (health::WriteAheadLog *)v6;
          v6 = (char *)*((_QWORD *)v6 + 1);
        }
        while (v6);
      }
      else
      {
        do
        {
          v16 = (health::WriteAheadLog *)*((_QWORD *)v4 + 2);
          v10 = *(_QWORD *)v16 == (_QWORD)v4;
          v4 = (char *)v16;
        }
        while (v10);
      }
      v4 = (char *)v16;
    }
    while (v16 != v5);
  }
  v17 = 0;
LABEL_25:
  std::mutex::unlock(this);
  return v17;
}

void health::WriteAheadLog::discardLog(std::mutex *this)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v7;
  std::string __p;
  void *v9[2];
  void *v10[2];
  _QWORD v11[2];

  std::mutex::lock(this);
  if (*(_QWORD *)&this[3].__m_.__opaque[8] != *(_QWORD *)this[3].__m_.__opaque)
  {
    v2 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v11, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v10, "discardLog");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to discard the log while a write transaction is open.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v2, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 91, (uint64_t)&__p);
  }
  v3 = *(_QWORD *)&this[2].__m_.__opaque[16];
  if (v3)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 56))(v3, 0);
    v7 = 0uLL;
    std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100]((uint64_t)&this[2].__m_.__opaque[16], &v7);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v7 + 1);
    if (*((_QWORD *)&v7 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v7 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  std::mutex::unlock(this);
}

void sub_1B798AA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  std::mutex *v28;
  uint64_t v29;

  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  if (a28 < 0)
    operator delete(a23);
  if (*(char *)(v29 - 17) < 0)
    operator delete(*(void **)(v29 - 40));
  std::mutex::unlock(v28);
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::_walLock_checkpointWhenIdle(uint64_t a1, std::unique_lock<std::mutex> *__lk, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::condition_variable *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _BYTE v17[24];
  _BYTE *v18;
  _BYTE v19[24];
  _BYTE *v20;
  _BYTE v21[24];
  _BYTE *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 192) = 1;
  v10 = (std::condition_variable *)(a1 + 64);
  while (*(_QWORD *)(a1 + 208) != *(_QWORD *)(a1 + 200) || *(_QWORD *)(a1 + 248))
    std::condition_variable::wait(v10, __lk);
  if (!*(_BYTE *)(a1 + 192))
    return;
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v21, a3);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v19, a4);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v17, a5);
  health::WriteAheadLog::_walLock_checkpoint(a1, (uint64_t)v21, (uint64_t)v19, (uint64_t)v17);
  v11 = v18;
  if (v18 == v17)
  {
    v12 = 4;
    v11 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_11;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_11:
  v13 = v20;
  if (v20 == v19)
  {
    v14 = 4;
    v13 = v19;
    goto LABEL_15;
  }
  if (v20)
  {
    v14 = 5;
LABEL_15:
    (*(void (**)(void))(*v13 + 8 * v14))();
  }
  v15 = v22;
  if (v22 == v21)
  {
    v16 = 4;
    v15 = v21;
  }
  else
  {
    if (!v22)
      return;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
}

void sub_1B798AC70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20,char *a21)
{
  uint64_t v21;
  std::condition_variable *v22;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  if (!a2)
    _Unwind_Resume(exception_object);
  v24 = a13;
  if (a13 == &a10)
  {
    v25 = 4;
    v24 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_7;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_7:
  v26 = a17;
  if (a17 == &a14)
  {
    v27 = 4;
    v26 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_12;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_12:
  v28 = a21;
  if (a21 == &a18)
  {
    v29 = 4;
    v28 = &a18;
  }
  else
  {
    if (!a21)
      goto LABEL_17;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_17:
  __cxa_begin_catch(exception_object);
  *(_BYTE *)(v21 + 192) = 0;
  std::condition_variable::notify_all(v22);
  __cxa_rethrow();
}

void health::WriteAheadLog::_walLock_waitOnTransactionIdle(_QWORD *a1, std::unique_lock<std::mutex> *__lk)
{
  std::condition_variable *v4;

  v4 = (std::condition_variable *)(a1 + 8);
  while (a1[26] != a1[25] || a1[31])
    std::condition_variable::wait(v4, __lk);
}

void health::WriteAheadLog::_walLock_checkpoint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  BOOL v25;
  uint64_t v26;
  _QWORD v27[3];
  std::__shared_weak_count *v28;
  std::__shared_weak_count *v29;
  std::string v30;
  void *v31[2];
  void *v32[2];
  void *v33[2];
  std::string __p;
  _QWORD v35[2];
  _QWORD v36[2];
  _QWORD v37[2];
  uint64_t v38;

  if (*(_QWORD *)(a1 + 208) != *(_QWORD *)(a1 + 200))
  {
    v8 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v37, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v36, "_walLock_checkpoint");
    std::string::basic_string[abi:ne180100]<0>(v35, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to checkpoint the WAL while a write transaction is active", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v8, (uint64_t)v37, (uint64_t)v36, (uint64_t)v35, 457, (uint64_t)&__p);
  }
  if (*(_QWORD *)(a1 + 248))
  {
    v9 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v33, "_readTransactionIdentifiers.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v32, "_walLock_checkpoint");
    std::string::basic_string[abi:ne180100]<0>(v31, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to checkpoint the WAL while a read transaction is active", &v30);
    health::_HDAssertImplementation<health::transaction_error>(v9, (uint64_t)v33, (uint64_t)v32, (uint64_t)v31, 458, (uint64_t)&v30);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 152) + 16))(*(_QWORD *)(a1 + 152));
  v10 = *(_QWORD **)(a1 + 264);
  v11 = (_QWORD *)(a1 + 272);
  if (v10 != (_QWORD *)(a1 + 272))
  {
    v12 = 0;
    do
    {
      v13 = v10[6];
      if (v13 != v10[5])
      {
        if ((v12 & 1) == 0)
        {
          v27[0] = *(_QWORD *)(a1 + 176);
          v14 = *(_QWORD *)(a2 + 24);
          if (!v14)
            goto LABEL_34;
          (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v14 + 48))(v14, v27);
          v13 = v10[6];
        }
        v15 = *(_QWORD *)(a1 + 176);
        health::_PageForEntry((uint64_t *)(a1 + 152), v10[4], (_QWORD *)(v13 - 24), (health::FilePage *)v27);
        v38 = v15;
        v16 = *(_QWORD *)(a3 + 24);
        if (!v16)
          std::__throw_bad_function_call[abi:ne180100]();
        (*(void (**)(uint64_t, uint64_t *, _QWORD *))(*(_QWORD *)v16 + 48))(v16, &v38, v27);
        v17 = v29;
        if (v29)
        {
          p_shared_owners = (unint64_t *)&v29->__shared_owners_;
          do
            v19 = __ldaxr(p_shared_owners);
          while (__stlxr(v19 - 1, p_shared_owners));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
        v20 = v28;
        if (v28)
        {
          v21 = (unint64_t *)&v28->__shared_owners_;
          do
            v22 = __ldaxr(v21);
          while (__stlxr(v22 - 1, v21));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        v12 = 1;
      }
      v23 = (_QWORD *)v10[1];
      if (v23)
      {
        do
        {
          v24 = v23;
          v23 = (_QWORD *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          v24 = (_QWORD *)v10[2];
          v25 = *v24 == (_QWORD)v10;
          v10 = v24;
        }
        while (!v25);
      }
      v10 = v24;
    }
    while (v24 != v11);
    if ((v12 & 1) != 0)
    {
      v27[0] = *(_QWORD *)(a1 + 176);
      v26 = *(_QWORD *)(a4 + 24);
      if (!v26)
LABEL_34:
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v26 + 48))(v26, v27);
    }
  }
  *(_QWORD *)(a1 + 184) = 0;
  std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(a1 + 264, *(_QWORD **)(a1 + 272));
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 264) = v11;
  *(_BYTE *)(a1 + 192) = 0;
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 152) + 56))(*(_QWORD *)(a1 + 152), 0);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 64));
}

void sub_1B798B110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  if (a39 < 0)
    operator delete(a34);
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::checkpoint(std::mutex *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  std::unique_lock<std::mutex> __lk;
  _BYTE v17[24];
  _BYTE *v18;
  _BYTE v19[24];
  _BYTE *v20;
  _BYTE v21[24];
  _BYTE *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  __lk.__m_ = a1;
  __lk.__owns_ = 1;
  std::mutex::lock(a1);
  health::WriteAheadLog::_walLock_openLogForFileIdentifier(&a1->__m_.__sig, a2);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v21, a3);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v19, a4);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v17, a5);
  health::WriteAheadLog::_walLock_checkpointWhenIdle((uint64_t)a1, &__lk, (uint64_t)v21, (uint64_t)v19, (uint64_t)v17);
  v10 = v18;
  if (v18 == v17)
  {
    v11 = 4;
    v10 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_6;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_6:
  v12 = v20;
  if (v20 == v19)
  {
    v13 = 4;
    v12 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_11;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_11:
  v14 = v22;
  if (v22 == v21)
  {
    v15 = 4;
    v14 = v21;
  }
  else
  {
    if (!v22)
      goto LABEL_16;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_16:
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
}

void sub_1B798B358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, __int16 *a18, char a19, uint64_t a20,uint64_t a21,char *a22,char a23,uint64_t a24,uint64_t a25,char *a26)
{
  __int16 *v26;
  __int16 *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;

  v28 = a18;
  if (a18 == v26)
  {
    v29 = 4;
    v28 = &a13;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_6:
  v30 = a22;
  if (a22 == &a19)
  {
    v31 = 4;
    v30 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_11;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_11:
  v32 = a26;
  if (a26 == &a23)
  {
    v33 = 4;
    v32 = &a23;
  }
  else
  {
    if (!a26)
      goto LABEL_16;
    v33 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v32 + 8 * v33))();
LABEL_16:
  if (a11)
    std::mutex::unlock(a10);
  _Unwind_Resume(exception_object);
}

unint64_t health::WriteAheadLog::_prepareReadTransaction(health::WriteAheadLog *this)
{
  unint64_t v2;
  unint64_t v4;
  std::unique_lock<std::mutex> __lk;

  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)this;
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)this);
  while (*((_BYTE *)this + 192))
    std::condition_variable::wait((std::condition_variable *)((char *)this + 64), &__lk);
  v4 = *((_QWORD *)this + 22);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_multi<unsigned long long const&>((_QWORD *)this + 28, &v4);
  v2 = v4;
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
  return v2;
}

void sub_1B798B498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  if (a12)
    std::mutex::unlock(a11);
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::_walLock_waitOnCheckpointCompletion(uint64_t a1, std::unique_lock<std::mutex> *__lk)
{
  std::condition_variable *v4;

  if (*(_BYTE *)(a1 + 192))
  {
    v4 = (std::condition_variable *)(a1 + 64);
    do
      std::condition_variable::wait(v4, __lk);
    while (*(_BYTE *)(a1 + 192));
  }
}

void health::WriteAheadLog::runReadTransaction(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  unint64_t Transaction;
  unint64_t v7;

  Transaction = health::WriteAheadLog::_prepareReadTransaction((health::WriteAheadLog *)a1);
  v7 = Transaction;
  v4 = *(_QWORD *)(a2 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, unint64_t *))(*(_QWORD *)v4 + 48))(v4, &v7);
  std::mutex::lock((std::mutex *)a1);
  v5 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((_QWORD *)(a1 + 224), &Transaction);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase((_QWORD *)(a1 + 224), v5);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 64));
  std::mutex::unlock((std::mutex *)a1);
}

void sub_1B798B57C()
{
  __break(1u);
}

void sub_1B798B5D0()
{
  std::mutex *v0;

  std::mutex::unlock(v0);
  __cxa_end_catch();
  JUMPOUT(0x1B798B5E8);
}

uint64_t health::WriteAheadLog::_prepareWriteTransaction(health::WriteAheadLog *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  std::unique_lock<std::mutex> __lk;
  _QWORD v8[3];

  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)this;
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)this);
  v4 = *((_QWORD *)this + 21);
  *((_QWORD *)this + 21) = v4 + 1;
  while (*((_BYTE *)this + 192))
    std::condition_variable::wait((std::condition_variable *)((char *)this + 64), &__lk);
  health::WriteAheadLog::_walLock_openLogForFileIdentifier((uint64_t *)this, a2);
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 48))(*((_QWORD *)this + 19));
  if (!v5)
  {
    v8[0] = 0x24857414CLL;
    v8[1] = a2;
    v8[2] = 0;
    health::VirtualFile::write<health::WriteAheadLog::LogHeader>(*((_QWORD *)this + 19), 0, (uint64_t)v8);
  }
  health::WriteAheadLog::_walLock_startTransaction(this, v4, v5, 0);
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
  return v4;
}

void sub_1B798B6CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11)
{
  if (a11)
    std::mutex::unlock(a10);
  _Unwind_Resume(exception_object);
}

unint64_t health::WriteAheadLog::_walLock_writeHeaderForIdentifier(health::WriteAheadLog *this, uint64_t a2)
{
  _QWORD v3[3];

  v3[0] = 0x24857414CLL;
  v3[1] = a2;
  v3[2] = 0;
  return health::VirtualFile::write<health::WriteAheadLog::LogHeader>(*((_QWORD *)this + 19), 0, (uint64_t)v3);
}

void health::WriteAheadLog::_walLock_startTransaction(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD **i;
  uint64_t v9;
  _QWORD *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  char *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  unint64_t v24;
  _QWORD *v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  unint64_t v33;
  char *v34;
  __int128 v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  char *v45;
  std::__shared_weak_count *v46;
  std::string __p;
  void *v48[2];
  void *v49[2];
  _QWORD v50[2];

  for (i = (_QWORD **)a1[25]; i != (_QWORD **)a1[26]; i += 2)
  {
    if (**i == a2)
    {
      v9 = *MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v50, "_walLock_transactionForIdentifier(transactionIdentifier) == nullptr");
      std::string::basic_string[abi:ne180100]<0>(v49, "_walLock_startTransaction");
      std::string::basic_string[abi:ne180100]<0>(v48, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
      health::FormatString<>((std::string *)"Attempt to start a transaction which is already active.", &__p);
      health::_HDAssertImplementation<health::transaction_error>(v9, (uint64_t)v50, (uint64_t)v49, (uint64_t)v48, 353, (uint64_t)&__p);
    }
  }
  v10 = operator new(0x58uLL);
  v11 = (std::__shared_weak_count *)v10;
  v10[1] = 0;
  v12 = v10 + 1;
  v10[2] = 0;
  *v10 = &off_1E6CF23F0;
  v13 = (char *)(v10 + 3);
  v14 = a1[19];
  v15 = (std::__shared_weak_count *)a1[20];
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
    v10[3] = a2;
    v10[4] = v14;
    v10[5] = v15;
    do
      v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
    v10[8] = 0;
    v10[9] = 0;
    v10[6] = a3;
    v10[7] = v10 + 8;
    *((_DWORD *)v10 + 20) = 0;
    *((_DWORD *)v10 + 21) = a4;
    do
      v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  else
  {
    v10[8] = 0;
    v10[3] = a2;
    v10[4] = v14;
    v10[5] = 0;
    v10[6] = a3;
    v10[9] = 0;
    v10[7] = v10 + 8;
    *((_DWORD *)v10 + 20) = 0;
    *((_DWORD *)v10 + 21) = a4;
  }
  v45 = v13;
  v46 = v11;
  if (a4 != 1)
  {
    v40 = 0;
    v42 = 0;
    v43 = 0;
    v41 = a2;
    v44 = 0;
    v20 = a1[19];
    v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 48))(v20);
    health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(v20, v21, (uint64_t)&v40);
  }
  v23 = (char *)a1[26];
  v22 = a1[27];
  if ((unint64_t)v23 >= v22)
  {
    v26 = (char *)a1[25];
    v27 = (v23 - v26) >> 4;
    v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 60)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v29 = v22 - (_QWORD)v26;
    if (v29 >> 3 > v28)
      v28 = v29 >> 3;
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0)
      v30 = 0xFFFFFFFFFFFFFFFLL;
    else
      v30 = v28;
    if (v30 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v31 = (char *)operator new(16 * v30);
    v32 = &v31[16 * v27];
    *(_QWORD *)v32 = v13;
    *((_QWORD *)v32 + 1) = v11;
    do
      v33 = __ldxr(v12);
    while (__stxr(v33 + 1, v12));
    if (v23 == v26)
    {
      v25 = v32 + 16;
      a1[25] = v32;
      a1[26] = v32 + 16;
      a1[27] = &v31[16 * v30];
    }
    else
    {
      v34 = &v31[16 * v27];
      do
      {
        v35 = *((_OWORD *)v23 - 1);
        v23 -= 16;
        *((_OWORD *)v34 - 1) = v35;
        v34 -= 16;
        *(_QWORD *)v23 = 0;
        *((_QWORD *)v23 + 1) = 0;
      }
      while (v23 != v26);
      v23 = (char *)a1[25];
      v36 = a1[26];
      v25 = v32 + 16;
      a1[25] = v34;
      a1[26] = v32 + 16;
      a1[27] = &v31[16 * v30];
      while ((char *)v36 != v23)
      {
        v36 -= 16;
        std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v36);
      }
    }
    if (v23)
      operator delete(v23);
  }
  else
  {
    *(_QWORD *)v23 = v13;
    *((_QWORD *)v23 + 1) = v11;
    do
      v24 = __ldxr(v12);
    while (__stxr(v24 + 1, v12));
    v25 = v23 + 16;
  }
  a1[26] = v25;
  ++a1[23];
  v37 = v46;
  if (v46)
  {
    v38 = (unint64_t *)&v46->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
}

void sub_1B798BA78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  uint64_t v34;

  if (a22 < 0)
    operator delete(__p);
  if (a28 < 0)
    operator delete(a23);
  if (a34 < 0)
    operator delete(a29);
  if (*(char *)(v34 - 65) < 0)
    operator delete(*(void **)(v34 - 88));
  _Unwind_Resume(exception_object);
}

uint64_t health::WriteAheadLog::runWriteTransaction(health::WriteAheadLog *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  _QWORD v13[8];
  uint64_t v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v16 = a3;
  v15 = 0;
  v13[7] = a7;
  v14 = health::WriteAheadLog::_prepareWriteTransaction(a1, a2);
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v14;
  v13[3] = (char *)&v15 + 1;
  v13[4] = &v16;
  v13[5] = a5;
  v13[6] = a6;
  v17 = v14;
  v11 = *(_QWORD *)(a4 + 24);
  if (!v11)
    std::__throw_bad_function_call[abi:ne180100]();
  LOBYTE(v15) = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v11 + 48))(v11, &v17);
  health::WriteAheadLog::runWriteTransaction(unsigned long long,health::WriteAheadLog::CommitMode,std::function<BOOL ()(unsigned long long)>,std::function<void ()(unsigned long long)>,std::function<void ()(unsigned long long,health::FilePage const&)>,std::function<void ()(unsigned long long)>)::$_1::operator()((uint64_t)v13);
  return HIBYTE(v15);
}

void sub_1B798BB94()
{
  __break(1u);
}

void sub_1B798BBAC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::pageAtOffset(std::mutex *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, health::FilePage *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  std::string __p;
  void *v14[2];
  void *v15[2];
  void *v16[2];

  std::mutex::lock(this);
  if (*(_QWORD *)&this[3].__m_.__opaque[8] == *(_QWORD *)this[3].__m_.__opaque
    && !*(_QWORD *)&this[3].__m_.__opaque[48])
  {
    v8 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v16, "(_transactionStack.size() > 0) || (_readTransactionIdentifiers.size() > 0)");
    std::string::basic_string[abi:ne180100]<0>(v15, "pageAtOffset");
    std::string::basic_string[abi:ne180100]<0>(v14, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to retrieve a page while no transaction is active.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v8, (uint64_t)v16, (uint64_t)v15, (uint64_t)v14, 198, (uint64_t)&__p);
  }
  v9 = *(_QWORD *)this[3].__m_.__opaque;
  v10 = *(_QWORD *)&this[3].__m_.__opaque[8];
  while (v10 != v9)
  {
    v12 = *(unint64_t **)(v10 - 16);
    v10 -= 16;
    v11 = (uint64_t)v12;
    if (*v12 <= a2)
    {
      health::WriteAheadLog::Transaction::pageAtOffset(v11, a3, a4);
      if (*((_QWORD *)a4 + 2) | *((_QWORD *)a4 + 4))
        goto LABEL_10;
      std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)a4 + 32);
      std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)a4 + 16);
      v9 = *(_QWORD *)this[3].__m_.__opaque;
    }
  }
  health::WriteAheadLog::_walLock_committedPageAtOffsetForTransaction((uint64_t)this, a2, a3, a4);
LABEL_10:
  std::mutex::unlock(this);
}

void sub_1B798BD40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  std::mutex *v32;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  std::mutex::unlock(v32);
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::_walLock_committedPageAtOffsetForTransaction@<X0>(uint64_t this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, health::FilePage *a4@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;

  v4 = *(_QWORD **)(this + 272);
  if (v4)
  {
    v5 = (_QWORD *)(this + 272);
    do
    {
      v6 = v4[4];
      v7 = v6 >= a3;
      if (v6 >= a3)
        v8 = v4;
      else
        v8 = v4 + 1;
      if (v7)
        v5 = v4;
      v4 = (_QWORD *)*v8;
    }
    while (*v8);
    if (v5 != (_QWORD *)(this + 272) && v5[4] <= a3)
    {
      v11 = v5 + 5;
      v10 = (_QWORD *)v5[5];
      v9 = (_QWORD *)v11[1];
      while (v9 != v10)
      {
        v12 = *(v9 - 3);
        v9 -= 3;
        if (v12 <= a2)
          return health::_PageForEntry((uint64_t *)(this + 152), a3, v9, a4);
      }
    }
  }
  *((_OWORD *)a4 + 1) = 0u;
  *((_OWORD *)a4 + 2) = 0u;
  *(_OWORD *)a4 = 0u;
  return this;
}

void health::WriteAheadLog::updatedPage(std::mutex *this, unint64_t a2, const health::FilePage *a3)
{
  uint64_t v5;
  uint64_t v6;
  health::WriteAheadLog::Transaction *v7;
  health::WriteAheadLog::Transaction *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::string v12;
  void *v13[2];
  void *v14[2];
  void *v15[2];
  std::string __p;
  void *v17[2];
  void *v18[2];
  _QWORD v19[2];
  std::string v20;
  _QWORD v21[2];
  _QWORD v22[2];
  _QWORD v23[2];
  unint64_t v24;

  v24 = a2;
  std::mutex::lock(this);
  if (*(_QWORD *)&this[3].__m_.__opaque[8] == *(_QWORD *)this[3].__m_.__opaque)
  {
    v5 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v23, "_transactionStack.size() > 0");
    std::string::basic_string[abi:ne180100]<0>(v22, "updatedPage");
    std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to store an updated page while no transaction is active.", &v20);
    health::_HDAssertImplementation<health::transaction_error>(v5, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 218, (uint64_t)&v20);
  }
  v6 = *(_QWORD *)&this[3].__m_.__opaque[8];
  do
  {
    if (v6 == *(_QWORD *)this[3].__m_.__opaque)
    {
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(&this[3].__m_.__opaque[24], &v24))
      {
        v9 = *MEMORY[0x1E0CB52B0];
        std::string::basic_string[abi:ne180100]<0>(v19, "_readTransactionIdentifiers.find(transactionIdentifier) == _readTransactionIdentifiers.end()");
        std::string::basic_string[abi:ne180100]<0>(v18, "updatedPage");
        std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
        health::FormatString<>((std::string *)"Attempt to update a page from a read transaction.", &__p);
        health::_HDAssertImplementation<health::transaction_error>(v9, (uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 228, (uint64_t)&__p);
      }
      v10 = *MEMORY[0x1E0CB52B0];
      std::string::basic_string[abi:ne180100]<0>(v15, "false");
      std::string::basic_string[abi:ne180100]<0>(v14, "updatedPage");
      std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
      v11 = **(_QWORD **)(*(_QWORD *)&this[3].__m_.__opaque[8] - 16);
      health::FormatString<unsigned long long &,unsigned long long>(&v12, (std::string *)"Attempt to record updated page for inactive transaction {0}; current transaction is {1}.",
        (uint64_t)&v24,
        (uint64_t)&v11);
      health::_HDAssertImplementation<health::transaction_error>(v10, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 229, (uint64_t)&v12);
    }
    v8 = *(health::WriteAheadLog::Transaction **)(v6 - 16);
    v6 -= 16;
    v7 = v8;
  }
  while (*(_QWORD *)v8 != v24);
  health::WriteAheadLog::Transaction::updatedPage(v7, a3);
  std::mutex::unlock(this);
}

void sub_1B798C0C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  std::mutex *v51;
  uint64_t v52;

  if (a39 < 0)
    operator delete(__p);
  if (a45 < 0)
    operator delete(a40);
  if (a51 < 0)
    operator delete(a46);
  if (*(char *)(v52 - 137) < 0)
    operator delete(*(void **)(v52 - 160));
  std::mutex::unlock(v51);
  _Unwind_Resume(a1);
}

void health::FormatString<unsigned long long &,unsigned long long>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[2];

  v4[0] = a4;
  v4[1] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned long long &,unsigned long long>(a2, a1, 0, (uint64_t)v4);
}

void sub_1B798C234(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t health::WriteAheadLog::_walLock_loadExistingEntriesStartingAtOffset(health::WriteAheadLog *this, uint64_t a2, int a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD **v12;
  _QWORD **v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t **v17;
  uint64_t **v18;
  uint64_t v19;
  std::runtime_error *exception;
  std::runtime_error *v22;
  int v23;
  std::string v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t *v28;
  int v29;
  _OWORD v30[2];
  int v31;

  memset(v30, 0, sizeof(v30));
  v31 = 1065353216;
  v25 = 99;
  v27 = 0;
  v28 = 0;
  v26 = 0;
  v29 = 0;
  while (a2 < (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 48))(*((_QWORD *)this + 19)))
  {
    v6 = health::VirtualFile::read<health::WriteAheadLog::LogEntryHeader>(*((_QWORD *)this + 19), a2, (uint64_t)&v25);
    v7 = v25;
    v8 = v6 + a2;
    switch(v25)
    {
      case 0:
        v9 = v26;
        health::WriteAheadLog::_walLock_startTransaction(this, v26, a2, 1);
        if (v9 + 1 > *((_QWORD *)this + 21))
          v10 = v9 + 1;
        else
          v10 = *((_QWORD *)this + 21);
        *((_QWORD *)this + 21) = v10;
        a2 = v8;
        continue;
      case 1:
        v15 = v26;
        if (!a3)
          goto LABEL_20;
        a2 += v6;
        if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(*(uint64_t *)&v30[0], *((unint64_t *)&v30[0] + 1), v26))
        {
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((float *)v30, v15, v15);
LABEL_20:
          health::WriteAheadLog::_walLock_commitTransaction(this, v15);
          a2 = v8;
        }
        break;
      case 2:
        v11 = v26;
        if (!a3)
          goto LABEL_11;
        a2 += v6;
        if (!std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(*(uint64_t *)&v30[0], *((unint64_t *)&v30[0] + 1), v26))
        {
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((float *)v30, v11, v11);
LABEL_11:
          health::WriteAheadLog::_walLock_rollbackTransaction(this, v11);
          a2 = v8;
        }
        break;
      case 3:
        v12 = (_QWORD **)*((_QWORD *)this + 25);
        v13 = (_QWORD **)*((_QWORD *)this + 26);
        if (v12 == v13)
          goto LABEL_25;
        v14 = v26;
        while (**v12 != v26)
        {
          v12 += 2;
          if (v12 == v13)
          {
LABEL_25:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Invalid WAL entry: found a page update for a transaction that is not active.");
            exception->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC2E8;
          }
        }
        v16 = v28;
        v17 = (uint64_t **)(*v12 + 4);
        v24.__r_.__value_.__r.__words[0] = v27;
        v18 = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v17, v27, (uint64_t **)&v24);
        v18[5] = (uint64_t *)v14;
        v18[6] = (uint64_t *)a2;
        a2 = (uint64_t)v16 + v8;
        v18[7] = v16;
        break;
      default:
        v22 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        v23 = v7;
        health::FormatString<int>((std::string *)"Invalid WAL entry type {0}.", &v23, &v24);
        std::runtime_error::runtime_error(v22, &v24);
        v22->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC2E8;
    }
  }
  while (1)
  {
    v19 = *((_QWORD *)this + 26);
    if (v19 == *((_QWORD *)this + 25))
      break;
    health::WriteAheadLog::_walLock_rollbackTransaction(this, **(_QWORD **)(v19 - 16));
  }
  return std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v30);
}

void sub_1B798C4DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  void *v22;
  int v23;

  if (a16 < 0)
  {
    operator delete(__p);
    if ((v23 & 1) == 0)
    {
LABEL_6:
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&a22);
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v22);
  goto LABEL_6;
}

uint64_t std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::erase(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2 != a3)
  {
    v3 = a2;
    v4 = result;
    result = a3;
    v5 = *(_QWORD *)(v4 + 8);
    if (a3 != v5)
    {
      v6 = 16 * ((a3 - a2) >> 4);
      do
      {
        std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100](v3, (__int128 *)(v3 + v6));
        v3 += 16;
      }
      while (v3 + v6 != v5);
      result = *(_QWORD *)(v4 + 8);
    }
    while (result != v3)
      result = std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](result - 16);
    *(_QWORD *)(v4 + 8) = v3;
  }
  return result;
}

void health::Print<char const*>(std::string *a1, const char **a2)
{
  std::string *p_p;
  std::string::size_type size;
  _QWORD *v4;
  std::string __p;

  health::FormatString<char const*>(a1, a2, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)p_p, size);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\n", 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1B798C62C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::_walLock_commitTransaction(health::WriteAheadLog *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  unint64_t *v7;
  unint64_t v8;
  health::WriteAheadLog::Transaction *v9;
  uint64_t v10;
  uint64_t v11;
  __int128 *v12;
  __int128 *v13;
  __int128 *v14;
  __int128 *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::string v21;
  void *v22[2];
  void *v23[2];
  void *v24[2];
  __int128 v25;
  std::string __p;
  void *v27[2];
  _QWORD v28[2];
  _QWORD v29[2];
  uint64_t v30;
  _QWORD v31[3];
  _QWORD *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v30 = a2;
  if (*((_QWORD *)this + 26) == *((_QWORD *)this + 25))
  {
    v3 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v29, "_transactionStack.size() > 0");
    std::string::basic_string[abi:ne180100]<0>(v28, "_walLock_commitTransaction");
    std::string::basic_string[abi:ne180100]<0>(v27, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<unsigned long long &>(&__p, (std::string *)"Attempt to commit transaction {0} when no transaction is active.", (uint64_t)&v30);
    health::_HDAssertImplementation<health::transaction_error>(v3, (uint64_t)v29, (uint64_t)v28, (uint64_t)v27, 367, (uint64_t)&__p);
  }
  v4 = *((_QWORD *)this + 25);
  v5 = (*((_QWORD *)this + 26) - v4) >> 4;
  v6 = *(_OWORD *)(v4 + 16 * (v5 - 1));
  v25 = v6;
  if (*((_QWORD *)&v6 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = (health::WriteAheadLog::Transaction *)v6;
  if (*(_QWORD *)v6 != v30)
  {
    v10 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v24, "transaction->identifier() == transactionIdentifier");
    std::string::basic_string[abi:ne180100]<0>(v23, "_walLock_commitTransaction");
    std::string::basic_string[abi:ne180100]<0>(v22, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    v20 = *(_QWORD *)v9;
    health::FormatString<unsigned long long &,unsigned long long>(&v21, (std::string *)"Attempt to commit transaction ({0}) which is not the innermost transaction ({1}).", (uint64_t)&v30, (uint64_t)&v20);
    health::_HDAssertImplementation<health::transaction_error>(v10, (uint64_t)v24, (uint64_t)v23, (uint64_t)v22, 370, (uint64_t)&v21);
  }
  v11 = *((_QWORD *)this + 25);
  v12 = (__int128 *)*((_QWORD *)this + 26);
  v13 = (__int128 *)(v11 + 16 * (v5 - 1));
  v14 = (__int128 *)(v11 + 16 * v5);
  if (v14 != v12)
  {
    do
    {
      std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100]((uint64_t)(v14 - 1), v14);
      ++v14;
      ++v13;
    }
    while (v14 != v12);
    v14 = (__int128 *)*((_QWORD *)this + 26);
  }
  if (v14 != v13)
  {
    do
      std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)--v14);
    while (v14 != v13);
    v9 = (health::WriteAheadLog::Transaction *)v25;
  }
  *((_QWORD *)this + 26) = v13;
  v15 = (__int128 *)*((_QWORD *)this + 25);
  if (v13 != v15)
  {
    health::WriteAheadLog::Transaction::commitAndMerge(v9, *(health::WriteAheadLog::Transaction **)&v15[v5 - 2]);
    goto LABEL_22;
  }
  v31[0] = &off_1E6CF2440;
  v31[1] = this;
  v31[2] = &v30;
  v32 = v31;
  health::WriteAheadLog::Transaction::commit((unint64_t)v9, (uint64_t)v31);
  v16 = v32;
  if (v32 == v31)
  {
    v17 = 4;
    v16 = v31;
    goto LABEL_20;
  }
  if (v32)
  {
    v17 = 5;
LABEL_20:
    (*(void (**)(void))(*v16 + 8 * v17))();
  }
  *((_QWORD *)this + 22) = v30;
LABEL_22:
  if (*((_QWORD *)&v25 + 1))
  {
    v18 = (unint64_t *)(*((_QWORD *)&v25 + 1) + 8);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v25 + 1) + 16))(*((_QWORD *)&v25 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v25 + 1));
    }
  }
}

void sub_1B798C974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  _QWORD *v48;
  uint64_t v49;
  _QWORD *v51;
  uint64_t v52;

  v51 = *(_QWORD **)(v49 - 80);
  if (v51 == v48)
  {
    v52 = 4;
    v51 = (_QWORD *)(v49 - 104);
  }
  else
  {
    if (!v51)
      goto LABEL_6;
    v52 = 5;
  }
  (*(void (**)(void))(*v51 + 8 * v52))();
LABEL_6:
  std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)&a35);
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::_walLock_rollbackTransaction(health::WriteAheadLog *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  __int128 *v12;
  __int128 *v13;
  __int128 *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::string v18;
  void *v19[2];
  void *v20[2];
  void *v21[2];
  __int128 v22;
  std::string __p;
  _QWORD v24[2];
  _QWORD v25[2];
  _QWORD v26[2];
  uint64_t v27;

  v27 = a2;
  if (*((_QWORD *)this + 26) == *((_QWORD *)this + 25))
  {
    v3 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v26, "_transactionStack.size() > 0");
    std::string::basic_string[abi:ne180100]<0>(v25, "_walLock_rollbackTransaction");
    std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<unsigned long long &>(&__p, (std::string *)"Attempt to roll back transaction {0} when no transaction is active.", (uint64_t)&v27);
    health::_HDAssertImplementation<health::transaction_error>(v3, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 394, (uint64_t)&__p);
  }
  v4 = *((_QWORD *)this + 25);
  v5 = (*((_QWORD *)this + 26) - v4) >> 4;
  v6 = *(_OWORD *)(v4 + 16 * (v5 - 1));
  v22 = v6;
  if (*((_QWORD *)&v6 + 1))
  {
    v7 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = (uint64_t *)v6;
  if (*(_QWORD *)v6 != v27)
  {
    v10 = *MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v21, "transaction->identifier() == transactionIdentifier");
    std::string::basic_string[abi:ne180100]<0>(v20, "_walLock_rollbackTransaction");
    std::string::basic_string[abi:ne180100]<0>(v19, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    v17 = *v9;
    health::FormatString<unsigned long long &,unsigned long long>(&v18, (std::string *)"Attempt to roll back transaction ({0}) which is not the innermost transaction ({1}).", (uint64_t)&v27, (uint64_t)&v17);
    health::_HDAssertImplementation<health::transaction_error>(v10, (uint64_t)v21, (uint64_t)v20, (uint64_t)v19, 397, (uint64_t)&v18);
  }
  v11 = *((_QWORD *)this + 25);
  v12 = (__int128 *)*((_QWORD *)this + 26);
  v13 = (__int128 *)(v11 + 16 * (v5 - 1));
  v14 = (__int128 *)(v11 + 16 * v5);
  if (v14 != v12)
  {
    do
    {
      std::shared_ptr<health::VirtualFile>::operator=[abi:ne180100]((uint64_t)(v14 - 1), v14);
      ++v14;
      ++v13;
    }
    while (v14 != v12);
    v14 = (__int128 *)*((_QWORD *)this + 26);
  }
  if (v14 != v13)
  {
    do
      std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100]((uint64_t)--v14);
    while (v14 != v13);
    v9 = (uint64_t *)v22;
  }
  *((_QWORD *)this + 26) = v13;
  health::WriteAheadLog::Transaction::_writeCompletionEntryOfType((unint64_t)v9, 2);
  if (*((_QWORD *)&v22 + 1))
  {
    v15 = (unint64_t *)(*((_QWORD *)&v22 + 1) + 8);
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      (*(void (**)(_QWORD))(**((_QWORD **)&v22 + 1) + 16))(*((_QWORD *)&v22 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v22 + 1));
    }
  }
}

void sub_1B798CD18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  uint64_t v43;

  if (a43 < 0)
    operator delete(__p);
  if (*(char *)(v43 - 121) < 0)
    operator delete(*(void **)(v43 - 144));
  if (*(char *)(v43 - 97) < 0)
    operator delete(*(void **)(v43 - 120));
  if (*(char *)(v43 - 73) < 0)
    operator delete(*(void **)(v43 - 96));
  _Unwind_Resume(exception_object);
}

_QWORD *health::WriteAheadLog::_walLock_transactionForIdentifier(health::WriteAheadLog *this, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *result;

  v2 = (uint64_t *)*((_QWORD *)this + 25);
  v3 = (uint64_t *)*((_QWORD *)this + 26);
  while (v2 != v3)
  {
    result = (_QWORD *)*v2;
    if (*(_QWORD *)*v2 == a2)
      return result;
    v2 += 2;
  }
  return 0;
}

{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *result;

  v2 = (uint64_t *)*((_QWORD *)this + 25);
  v3 = (uint64_t *)*((_QWORD *)this + 26);
  while (v2 != v3)
  {
    result = (_QWORD *)*v2;
    if (*(_QWORD *)*v2 == a2)
      return result;
    v2 += 2;
  }
  return 0;
}

std::runtime_error *_ZN6health21data_corruption_errorCI1St13runtime_errorEPKc(std::runtime_error *a1, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1E6CEC2E8;
  return result;
}

uint64_t **health::WriteAheadLog::Transaction::storePageEntry(uint64_t **this, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *v6;
  uint64_t **result;
  uint64_t *v8;

  v6 = *this;
  v8 = a2;
  result = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(this + 4, (unint64_t)a2, &v8);
  result[5] = v6;
  result[6] = a3;
  result[7] = a4;
  return result;
}

void health::FormatString<int>(std::string *a1@<X0>, int *a2@<X1>, std::string *a3@<X8>)
{
  int *v3;

  v3 = a2;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<int>(a1, a3, 0, &v3);
}

void sub_1B798CEC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::FormatString<unsigned long long &>(std::string *a1, std::string *a2, uint64_t a3)
{
  uint64_t v3;

  v3 = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned long long &>(a2, a1, 0, &v3);
}

void sub_1B798CF24(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

unint64_t health::WriteAheadLog::Transaction::commit(unint64_t a1, uint64_t a2)
{
  unint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  result = health::WriteAheadLog::Transaction::_writeCompletionEntryOfType(a1, 1);
  v5 = *(_QWORD **)(a1 + 32);
  v6 = (_QWORD *)(a1 + 40);
  if (v5 != v6)
  {
    do
    {
      v7 = v5[4];
      v12 = *(_OWORD *)(v5 + 5);
      v13 = v5[7];
      v14 = v7;
      v8 = *(_QWORD *)(a2 + 24);
      if (!v8)
        std::__throw_bad_function_call[abi:ne180100]();
      result = (*(uint64_t (**)(uint64_t, uint64_t *, __int128 *))(*(_QWORD *)v8 + 48))(v8, &v14, &v12);
      v9 = (_QWORD *)v5[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v5[2];
          v11 = *v10 == (_QWORD)v5;
          v5 = v10;
        }
        while (!v11);
      }
      v5 = v10;
    }
    while (v10 != v6);
  }
  return result;
}

_QWORD *health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction *this, health::WriteAheadLog::Transaction *a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &off_1E6CF24D0;
  v4[1] = a2;
  v5 = v4;
  health::WriteAheadLog::Transaction::commit((unint64_t)this, (uint64_t)v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1B798D088(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t health::WriteAheadLog::Transaction::rollback(health::WriteAheadLog::Transaction *this)
{
  return health::WriteAheadLog::Transaction::_writeCompletionEntryOfType((unint64_t)this, 2);
}

uint64_t health::WriteAheadLog::_walLock_shouldCheckpoint(health::WriteAheadLog *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 19);
  if (result)
    return *((uint64_t *)this + 23) > 9
        || (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result) >= 0x200000;
  return result;
}

BOOL health::WriteAheadLog::_walLock_shouldCheckpointForMode(uint64_t a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 == 2)
    return 1;
  if (a2 != 1)
    return 0;
  v2 = *(_QWORD *)(a1 + 152);
  if (!v2)
    return 0;
  if (*(uint64_t *)(a1 + 184) <= 9)
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)v2 + 48))(*(_QWORD *)(a1 + 152)) >= 0x200000;
  return 1;
}

_QWORD *health::WriteAheadLog::_walLock_pruneCommittedPages(_QWORD *this)
{
  unint64_t v1;
  _QWORD *i;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  BOOL v12;

  v1 = this[22];
  for (i = (_QWORD *)this[30]; i; i = (_QWORD *)*i)
  {
    if (i[2] < v1)
      v1 = i[2];
  }
  v3 = (_QWORD *)this[33];
  v4 = this + 34;
  if (v3 != this + 34)
  {
    do
    {
      v6 = v3[5];
      v5 = v3[6];
      if (0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 3) >= 2)
      {
        v7 = 0;
        while (v5 + v7 != v6)
        {
          v8 = *(_QWORD *)(v5 + v7 - 24);
          v7 -= 24;
          if (v8 <= v1)
          {
            if (v5 + v7 != v6)
            {
              v9 = -v7;
              if (v7)
                this = memmove((void *)v3[5], (const void *)(v5 + v7), -v7);
              v3[6] = v6 + v9;
            }
            break;
          }
        }
      }
      v10 = (_QWORD *)v3[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (_QWORD *)v3[2];
          v12 = *v11 == (_QWORD)v3;
          v3 = v11;
        }
        while (!v12);
      }
      v3 = v11;
    }
    while (v11 != v4);
  }
  return this;
}

uint64_t health::WriteAheadLog::Transaction::Transaction(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v6 = *a3;
  v5 = a3[1];
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = v6;
  *(_QWORD *)(result + 16) = v5;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 24) = a4;
  *(_QWORD *)(result + 32) = result + 40;
  *(_DWORD *)(result + 56) = 0;
  *(_DWORD *)(result + 60) = a5;
  return result;
}

{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v6 = *a3;
  v5 = a3[1];
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = v6;
  *(_QWORD *)(result + 16) = v5;
  if (v5)
  {
    v7 = (unint64_t *)(v5 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 24) = a4;
  *(_QWORD *)(result + 32) = result + 40;
  *(_DWORD *)(result + 56) = 0;
  *(_DWORD *)(result + 60) = a5;
  return result;
}

void health::FormatString<std::string,unsigned long long &>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4[2];

  v4[0] = a4;
  v4[1] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<std::string,unsigned long long &>(a2, a1, 0, v4);
}

void sub_1B798D360(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::EntryTypeToString(std::string *a1, int a2)
{
  char *v2;
  int v3;
  unsigned int *v4;

  switch(a2)
  {
    case 0:
      v2 = "Start";
      goto LABEL_8;
    case 1:
      v2 = "Commit";
      goto LABEL_8;
    case 2:
      v2 = "Rollback";
      goto LABEL_8;
    case 3:
      v2 = "PageUpdate";
      goto LABEL_8;
    default:
      if (a2 == 99)
      {
        v2 = "Unknown";
LABEL_8:
        std::string::basic_string[abi:ne180100]<0>(a1, v2);
      }
      else
      {
        v3 = a2;
        v4 = (unsigned int *)&v3;
        a1->__r_.__value_.__l.__size_ = 0;
        a1->__r_.__value_.__r.__words[2] = 0;
        a1->__r_.__value_.__r.__words[0] = 0;
        health::FormatImplementation<unsigned int>((std::string *)"Invalid({0})", a1, 0, &v4);
      }
      return;
  }
}

void sub_1B798D444(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<unsigned char>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void health::FormatImplementation<unsigned int>(std::string *a1, std::string *a2, std::string::size_type a3, unsigned int **a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  std::runtime_error *exception;
  std::runtime_error *v23;
  char v24[8];
  uint64_t v25;
  char v26;
  unint64_t v27;
  char *v28;
  uint64_t v29[6];
  char v30;
  uint64_t v31;

  v8 = 0;
  v9 = 0;
  v31 = *MEMORY[0x1E0C80C00];
  for (i = (char *)a1; ; ++i)
  {
    v28 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v28 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v28 = i + 2;
    v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v19 = 0;
      v20 = i + 3;
      do
      {
        v28 = v20;
        v19 = (v18 - 48) + 10 * v19;
        v21 = *v20++;
        v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      v28 = v20;
      if (*(v20 - 1) == 125)
        health::FormatterParameters<0ul,unsigned int>::formatOptionsAtIndex<unsigned int>(v19);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v24, (const char **)&v28);
  if (v25)
  {
    v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v23, "Parameter index out of bounds.");
    __cxa_throw(v23, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  v12 = v28;
  health::TypeFormatter<unsigned int,void>::TypeFormatter((uint64_t)v29, **a4, (uint64_t)v24);
  if (v30 && !*(_BYTE *)(v29[0] + 48))
    v13 = 32;
  else
    v13 = 33;
  v14 = v13 - v29[5];
  if (*(_BYTE *)(v29[0] + 50) && v14 <= *(_QWORD *)(v29[0] + 24))
    v14 = *(_QWORD *)(v29[0] + 24);
  v15 = v27;
  if (v27 <= v14)
    v15 = v14;
  if (v26)
    v16 = v15;
  else
    v16 = v14;
  health::FormatImplementation<unsigned int>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = (char *)a2;
  else
    v17 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned int>(v24, &v17[a3 - v8], v29);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B798D7A0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned int>::formatOptionsAtIndex<unsigned int>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  v3 = exception;
  if (a1)
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  else
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(v3, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B798D820(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned int>(char *result, char *a2, uint64_t *a3)
{
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  char *v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;

  v3 = a2;
  v4 = result;
  v5 = *a3;
  if (*((_BYTE *)a3 + 48) && !*(_BYTE *)(v5 + 48))
    v6 = 32;
  else
    v6 = 33;
  v7 = v6 - a3[5];
  if (*(_BYTE *)(v5 + 50))
  {
    v8 = *(_QWORD *)(v5 + 24);
    if (v7 <= v8)
      v7 = v8;
  }
  if (!result[16])
    return health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
  v9 = *((_QWORD *)result + 3);
  v10 = v9 - v7;
  if (v9 <= v7)
    return health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
  v11 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v11 != 1)
    {
      if (v11 != 2)
        return result;
      if (v9 != v7)
      {
        v12 = a2;
        v3 = &a2[v9 - v7];
        do
        {
          *v12++ = result[52];
          --v10;
        }
        while (v10);
      }
      return health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
    }
    v14 = v10 >> 1;
    if (v10 >= 2)
    {
      if (v14 <= 1)
        v15 = 1;
      else
        v15 = v10 >> 1;
      do
      {
        *v3++ = result[52];
        --v15;
      }
      while (v15);
    }
    result = health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
    if (v10 != v14)
    {
      v16 = v10 - (v10 >> 1);
      v17 = &v3[v7];
      if (v16 <= 1)
        v16 = 1;
      v18 = -(uint64_t)v16;
      do
        *v17++ = v4[52];
      while (!__CFADD__(v18++, 1));
    }
  }
  else
  {
    result = health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, a2);
    if (v9 != v7)
    {
      v13 = &v3[v7];
      do
      {
        *v13++ = v4[52];
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

uint64_t health::TypeFormatter<unsigned int,void>::TypeFormatter(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;
  _BYTE *v5;

  *(_QWORD *)result = a3;
  *(_QWORD *)(result + 40) = 0;
  *(_BYTE *)(result + 48) = 1;
  switch(*(_DWORD *)(a3 + 4))
  {
    case 0:
      v3 = 39;
      do
      {
        *(_BYTE *)(result + v3--) = (a2 % 0xA) | 0x30;
        v4 = a2 >= 0xA;
        a2 /= 0xAu;
      }
      while (v4);
      goto LABEL_16;
    case 1:
      v3 = 39;
      do
      {
        *(_BYTE *)(result + v3--) = a2 & 7 | 0x30;
        v4 = a2 >= 8;
        a2 >>= 3;
      }
      while (v4);
      goto LABEL_16;
    case 2:
      if (*(_BYTE *)(a3 + 51))
        v5 = &health::TypeFormatterUpperHexMapping;
      else
        v5 = &health::TypeFormatterLowerHexMapping;
      v3 = 39;
      do
      {
        *(_BYTE *)(result + v3--) = v5[a2 & 0xF];
        v4 = a2 >= 0x10;
        a2 >>= 4;
      }
      while (v4);
      goto LABEL_16;
    case 3:
      v3 = 39;
      do
      {
        *(_BYTE *)(result + v3--) = a2 & 1 | 0x30;
        v4 = a2 >= 2;
        a2 >>= 1;
      }
      while (v4);
LABEL_16:
      *(_QWORD *)(result + 40) = v3 - 7;
      break;
    default:
      return result;
  }
  return result;
}

char *health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>(char *result, char *a2)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  unint64_t v7;
  char *v8;

  v3 = result + 40;
  v2 = *((_QWORD *)result + 5);
  if (result[48])
  {
    v4 = *(_QWORD *)result;
    if (!*(_BYTE *)(*(_QWORD *)result + 48))
    {
      v6 = 0;
      goto LABEL_7;
    }
    v5 = *(_BYTE *)(v4 + 49);
  }
  else
  {
    v5 = 45;
  }
  *a2++ = v5;
  v4 = *(_QWORD *)result;
  v6 = 1;
LABEL_7:
  if (*(_BYTE *)(v4 + 16))
  {
    if (*(_BYTE *)(v4 + 50))
    {
      v7 = v6 - v2 + 32;
      if (v7 < *(_QWORD *)(v4 + 24))
      {
        do
        {
          *a2++ = 48;
          ++v7;
        }
        while (v7 < *(_QWORD *)(*(_QWORD *)result + 24));
      }
    }
  }
  v8 = &result[*((_QWORD *)result + 5) + 8];
  if (v3 != v8)
    return (char *)memmove(a2, v8, v3 - v8);
  return result;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](a1 + 112);
  return a1;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  void *v4;

  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(a1, a2[1]);
    v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v6;
  float v7;
  float v8;
  _BOOL8 v9;
  unint64_t v10;
  unint64_t v11;
  int8x8_t prime;
  void *v13;
  void *v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  uint8x8_t v18;
  unint64_t v19;
  uint8x8_t v20;
  uint64_t v21;
  _QWORD *i;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint8x8_t v26;
  unint64_t v27;
  _QWORD *v28;
  int v29;
  _QWORD *result;
  unint64_t v31;
  unint64_t v32;
  _BOOL4 v33;
  int v34;
  void *v35;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    v9 = 1;
    if (v6 >= 3)
      v9 = (v6 & (v6 - 1)) != 0;
    v10 = v9 | (2 * v6);
    v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11)
      prime = (int8x8_t)v11;
    else
      prime = (int8x8_t)v10;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v6 = *(_QWORD *)(a1 + 8);
    }
    if (*(_QWORD *)&prime > v6)
      goto LABEL_74;
    if (*(_QWORD *)&prime >= v6)
      goto LABEL_43;
    v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v6 < 3 || (v20 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
    {
      v19 = std::__next_prime(v19);
    }
    else
    {
      v21 = 1 << -(char)__clz(v19 - 1);
      if (v19 >= 2)
        v19 = v21;
    }
    if (*(_QWORD *)&prime <= v19)
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime >= v6)
    {
      v6 = *(_QWORD *)(a1 + 8);
      goto LABEL_43;
    }
    if (prime)
    {
LABEL_74:
      if (*(_QWORD *)&prime >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v13 = operator new(8 * *(_QWORD *)&prime);
      v14 = *(void **)a1;
      *(_QWORD *)a1 = v13;
      if (v14)
        operator delete(v14);
      v15 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v15++) = 0;
      while (*(_QWORD *)&prime != v15);
      v16 = *(_QWORD **)(a1 + 16);
      if (v16)
      {
        v17 = v16[1];
        v18 = (uint8x8_t)vcnt_s8(prime);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          if (v17 >= *(_QWORD *)&prime)
            v17 %= *(_QWORD *)&prime;
        }
        else
        {
          v17 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v17) = a1 + 16;
        for (i = (_QWORD *)*v16; *v16; i = (_QWORD *)*v16)
        {
          v23 = i[1];
          if (v18.u32[0] > 1uLL)
          {
            if (v23 >= *(_QWORD *)&prime)
              v23 %= *(_QWORD *)&prime;
          }
          else
          {
            v23 &= *(_QWORD *)&prime - 1;
          }
          if (v23 == v17)
          {
            v16 = i;
          }
          else
          {
            v24 = i;
            if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v23))
            {
              do
              {
                v25 = v24;
                v24 = (_QWORD *)*v24;
              }
              while (v24 && i[2] == v24[2]);
              *v16 = v24;
              *v25 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v23);
              **(_QWORD **)(*(_QWORD *)a1 + 8 * v23) = i;
            }
            else
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v16;
              v16 = i;
              v17 = v23;
            }
          }
        }
      }
      v6 = (unint64_t)prime;
    }
    else
    {
      v35 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v35)
        operator delete(v35);
      v6 = 0;
      *(_QWORD *)(a1 + 8) = 0;
    }
  }
LABEL_43:
  v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v26.i16[0] = vaddlv_u8(v26);
  if (v26.u32[0] > 1uLL)
  {
    v27 = a2;
    if (v6 <= a2)
      v27 = a2 % v6;
  }
  else
  {
    v27 = (v6 - 1) & a2;
  }
  v28 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v27);
  if (!v28)
    return 0;
  v29 = 0;
  do
  {
    result = v28;
    v28 = (_QWORD *)*v28;
    if (!v28)
      break;
    v31 = v28[1];
    if (v26.u32[0] > 1uLL)
    {
      v32 = v28[1];
      if (v31 >= v6)
        v32 = v31 % v6;
    }
    else
    {
      v32 = v31 & (v6 - 1);
    }
    if (v32 != v27)
      break;
    v33 = v31 == a2 && v28[2] == *a3;
    v34 = v29 & !v33;
    v29 |= v33;
  }
  while (v34 != 1);
  return result;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(_QWORD *)(*result + 8 * v4) = result + 2;
    if (!*a2)
      goto LABEL_19;
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
LABEL_18:
    *(_QWORD *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
    if (v6 != v4)
      goto LABEL_18;
  }
LABEL_19:
  ++result[3];
  return result;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_multi<unsigned long long const&>(_QWORD *a1, unint64_t *a2)
{
  _QWORD *v4;
  unint64_t v5;
  _QWORD *inserted;

  v4 = operator new(0x18uLL);
  v5 = *a2;
  v4[2] = *a2;
  *v4 = 0;
  v4[1] = v5;
  inserted = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare((uint64_t)a1, v5, v4 + 2);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(a1, v4, inserted);
  return v4;
}

void sub_1B798E0F0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  void *__p;

  v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    operator delete(v3);
  return v2;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void health::WriteAheadLog::runWriteTransaction(unsigned long long,health::WriteAheadLog::CommitMode,std::function<BOOL ()(unsigned long long)>,std::function<void ()(unsigned long long)>,std::function<void ()(unsigned long long,health::FilePage const&)>,std::function<void ()(unsigned long long)>)::$_1::operator()(uint64_t a1)
{
  std::mutex *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  std::unique_lock<std::mutex> __lk;
  _BYTE v11[24];
  _BYTE *v12;
  _BYTE v13[24];
  _BYTE *v14;
  _BYTE v15[24];
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *(std::mutex **)a1;
  __lk.__m_ = v2;
  __lk.__owns_ = 1;
  std::mutex::lock(v2);
  v3 = **(_QWORD **)(a1 + 16);
  if (**(_BYTE **)(a1 + 8))
  {
    health::WriteAheadLog::_walLock_commitTransaction((health::WriteAheadLog *)v2, v3);
    **(_BYTE **)(a1 + 24) = 1;
  }
  else
  {
    health::WriteAheadLog::_walLock_rollbackTransaction((health::WriteAheadLog *)v2, v3);
  }
  if (!health::WriteAheadLog::_walLock_shouldCheckpointForMode((uint64_t)v2, **(_DWORD **)(a1 + 32)))
    goto LABEL_20;
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v15, *(_QWORD *)(a1 + 40));
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v13, *(_QWORD *)(a1 + 48));
  std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v11, *(_QWORD *)(a1 + 56));
  health::WriteAheadLog::_walLock_checkpointWhenIdle((uint64_t)v2, &__lk, (uint64_t)v15, (uint64_t)v13, (uint64_t)v11);
  v4 = v12;
  if (v12 == v11)
  {
    v5 = 4;
    v4 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_10;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  v6 = v14;
  if (v14 == v13)
  {
    v7 = 4;
    v6 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_15;
    v7 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
  v8 = v16;
  if (v16 == v15)
  {
    v9 = 4;
    v8 = v15;
  }
  else
  {
    if (!v16)
      goto LABEL_20;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_20:
  health::WriteAheadLog::_walLock_pruneCommittedPages(v2);
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
}

void sub_1B798E4BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, __int16 *a18, char a19, uint64_t a20,uint64_t a21,char *a22)
{
  __int16 *v22;
  uint64_t v23;
  __int16 *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;

  v25 = a18;
  if (a18 == v22)
  {
    v26 = 4;
    v25 = &a13;
  }
  else
  {
    if (!a18)
      goto LABEL_6;
    v26 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v25 + 8 * v26))();
LABEL_6:
  v27 = a22;
  if (a22 == &a19)
  {
    v28 = 4;
    v27 = &a19;
  }
  else
  {
    if (!a22)
      goto LABEL_11;
    v28 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v27 + 8 * v28))();
LABEL_11:
  v29 = *(_QWORD **)(v23 - 32);
  if (v29 == (_QWORD *)(v23 - 56))
  {
    v30 = 4;
    v29 = (_QWORD *)(v23 - 56);
  }
  else
  {
    if (!v29)
      goto LABEL_16;
    v30 = 5;
  }
  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_16:
  if (a11)
    std::mutex::unlock(a10);
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<unsigned long long &,unsigned long long>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t a4)
{
  uint64_t v8;
  char v9;
  char *v10;
  std::string::size_type i;
  int v12;
  char *v13;
  unint64_t v14;
  _DWORD *v15;
  int v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  std::string *v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  std::string::size_type v28;
  uint64_t v29;
  char *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  std::string::size_type v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  char *v44;
  int v45;
  std::runtime_error *exception;
  std::runtime_error *v47;
  _DWORD v49[2];
  uint64_t v50;
  char v51;
  unint64_t v52;
  char v53;
  char v54;
  char *v55;
  void *__p[2];
  unsigned __int8 v57;
  uint64_t v58;
  unsigned __int8 v59;
  uint64_t v60;

  v8 = 0;
  v9 = 0;
  v60 = *MEMORY[0x1E0C80C00];
  v10 = (char *)a1;
  for (i = a3; ; ++i)
  {
    v55 = v10;
    if (*v10 == 123)
      break;
    if (!*v10)
    {
      std::string::resize(a2, i, 0);
      if (i != a3)
        health::CopyFormatSectionToResult(a1, a2, a3, i - a3, v9 & 1);
      return;
    }
LABEL_7:
    ++v10;
    ++v8;
  }
  v12 = v10[1];
  if (v12 == 123)
  {
    v55 = v10 + 1;
    v9 = 1;
    ++v10;
    goto LABEL_7;
  }
  if (v12 == 42)
  {
    v55 = v10 + 2;
    v42 = v10[2];
    if ((v42 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v43 = 0;
      v44 = v10 + 3;
      do
      {
        v55 = v44;
        v43 = (v42 - 48) + 10 * v43;
        v45 = *v44++;
        v42 = v45;
      }
      while ((v45 - 58) >= 0xFFFFFFF6);
      v55 = v44;
      if (*(v44 - 1) == 125)
        health::FormatterParameters<0ul,unsigned long long &,unsigned long long>::formatOptionsAtIndex<unsigned long long &,unsigned long long>(v43);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v49, (const char **)&v55);
  v13 = v55;
  if (v50)
  {
    if (v50 != 1)
    {
      v47 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v47, "Parameter index out of bounds.");
      __cxa_throw(v47, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v14 = **(_QWORD **)a4;
    v15 = v49;
    __p[0] = v49;
    v58 = 0;
    v16 = 1;
    v59 = 1;
    switch(v49[1])
    {
      case 0:
        v17 = 71;
        do
        {
          *((_BYTE *)__p + v17--) = (v14 % 0xA) | 0x30;
          v18 = v14 >= 0xA;
          v14 /= 0xAuLL;
        }
        while (v18);
        goto LABEL_38;
      case 1:
        v17 = 71;
        do
        {
          *((_BYTE *)__p + v17--) = v14 & 7 | 0x30;
          v18 = v14 >= 8;
          v14 >>= 3;
        }
        while (v18);
        goto LABEL_38;
      case 2:
        v23 = &health::TypeFormatterUpperHexMapping;
        if (!v53)
          v23 = &health::TypeFormatterLowerHexMapping;
        v17 = 71;
        do
        {
          *((_BYTE *)__p + v17--) = v23[v14 & 0xF];
          v18 = v14 >= 0x10;
          v14 >>= 4;
        }
        while (v18);
        goto LABEL_38;
      case 3:
        v17 = 71;
        do
        {
          *((_BYTE *)__p + v17--) = v14 & 1 | 0x30;
          v18 = v14 >= 2;
          v14 >>= 1;
        }
        while (v18);
LABEL_38:
        v24 = v17 - 7;
        v58 = v17 - 7;
        v16 = v59;
        v15 = __p[0];
        if (!v59)
          goto LABEL_42;
        goto LABEL_41;
      default:
        v24 = 0;
LABEL_41:
        if (*((_BYTE *)v15 + 48))
LABEL_42:
          v25 = 65;
        else
          v25 = 64;
        v26 = v25 - v24;
        if (*((_BYTE *)v15 + 50) && v26 <= *((_QWORD *)v15 + 3))
          v26 = *((_QWORD *)v15 + 3);
        v27 = v52;
        if (v52 <= v26)
          v27 = v26;
        if (v51)
          v26 = v27;
        health::FormatImplementation<unsigned long long &,unsigned long long>(v13, a2, v26 + i, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v28 = (std::string::size_type)a2;
        else
          v28 = a2->__r_.__value_.__r.__words[0];
        if (v16 && !*((_BYTE *)v15 + 48))
          v29 = 64;
        else
          v29 = 65;
        v30 = (char *)(v28 + i);
        v31 = v29 - v24;
        if (*((_BYTE *)v15 + 50) && v31 <= *((_QWORD *)v15 + 3))
          v31 = *((_QWORD *)v15 + 3);
        if (!v51)
          goto LABEL_70;
        v32 = v52;
        v33 = v52 - v31;
        if (v52 <= v31)
          goto LABEL_70;
        if (v49[0])
        {
          if (v49[0] == 1)
          {
            v35 = v33 >> 1;
            if (v33 >= 2)
            {
              if (v35 <= 1)
                v38 = 1;
              else
                v38 = v33 >> 1;
              v36 = (char *)(v28 + v8 + a3 + v38);
              do
              {
                *v30++ = v54;
                --v38;
              }
              while (v38);
            }
            else
            {
              v36 = (char *)(v28 + i);
            }
            health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)__p, v36);
            if (v33 != v35)
            {
              v39 = v33 - (v33 >> 1);
              v40 = &v30[v31];
              if (v39 <= 1)
                v39 = 1;
              v41 = -(uint64_t)v39;
              do
              {
                *v40++ = v54;
                v18 = __CFADD__(v41++, 1);
              }
              while (!v18);
            }
          }
          else if (v49[0] == 2)
          {
            if (v52 != v31)
            {
              v34 = -(uint64_t)v28;
              do
              {
                *(_BYTE *)(v28 + i) = v54;
                ++v28;
                --v34;
                --v33;
              }
              while (v33);
              v30 = (char *)(i - v34);
            }
LABEL_70:
            health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)__p, v30);
          }
        }
        else
        {
          health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)__p, (char *)(v28 + i));
          if (v32 != v31)
          {
            v37 = v28 + v31;
            do
            {
              *(_BYTE *)(v37 + i) = v54;
              ++v37;
              --v33;
            }
            while (v33);
          }
        }
        v22 = a1;
        break;
    }
  }
  else
  {
    health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)__p, *(_QWORD *)(a4 + 8), (uint64_t)v49);
    v19 = v57;
    if ((v57 & 0x80u) != 0)
      v19 = (unint64_t)__p[1];
    v20 = v52;
    if (v52 <= v19)
      v20 = v19;
    if (v51)
      v19 = v20;
    health::FormatImplementation<unsigned long long &,unsigned long long>(v13, a2, v19 + i, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = (char *)a2;
    else
      v21 = (char *)a2->__r_.__value_.__r.__words[0];
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v49, &v21[i], (const void **)__p);
    v22 = a1;
    if ((char)v57 < 0)
      operator delete(__p[0]);
  }
  if (i != a3)
    health::CopyFormatSectionToResult(v22, a2, a3, i - a3, v9 & 1);
}

void sub_1B798EB24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long &,unsigned long long>::formatOptionsAtIndex<unsigned long long &,unsigned long long>(uint64_t a1)
{
  std::runtime_error *v1;
  std::runtime_error *exception;

  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v1 = exception;
    if (a1 == 1)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B798EBE4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_BYTE *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(_BYTE *result, char *__dst, const void **a3)
{
  size_t v4;
  char v5;
  size_t v6;
  size_t v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  const void *v12;
  void *v13;
  size_t v14;
  const void *v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  const void *v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;

  v4 = *((unsigned __int8 *)a3 + 23);
  v5 = v4;
  v6 = (size_t)a3[1];
  if ((v4 & 0x80u) == 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (!result[16] || (v8 = result, v9 = *((_QWORD *)result + 3), v10 = v9 - v7, v9 <= v7))
  {
    if (!v7)
      return result;
    if ((v4 & 0x80u) == 0)
      v12 = a3;
    else
      v12 = *a3;
    v13 = __dst;
    v14 = v7;
    return memmove(v13, v12, v14);
  }
  v11 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v11 == 1)
    {
      v17 = v10 >> 1;
      if (v10 >= 2)
      {
        if (v17 <= 1)
          v18 = 1;
        else
          v18 = v10 >> 1;
        do
        {
          *__dst++ = result[52];
          --v18;
        }
        while (v18);
        v4 = *((unsigned __int8 *)a3 + 23);
        v6 = (size_t)a3[1];
        v5 = *((_BYTE *)a3 + 23);
      }
      if (v5 < 0)
        v4 = v6;
      if (v4)
      {
        if (v5 >= 0)
          v19 = a3;
        else
          v19 = *a3;
        result = memmove(__dst, v19, v4);
      }
      if (v10 != v17)
      {
        v20 = v10 - (v10 >> 1);
        v21 = &__dst[v7];
        if (v20 <= 1)
          v20 = 1;
        v22 = -(uint64_t)v20;
        do
          *v21++ = v8[52];
        while (!__CFADD__(v22++, 1));
      }
    }
    else if (v11 == 2)
    {
      if (v9 != v7)
      {
        do
        {
          *__dst++ = result[52];
          --v10;
        }
        while (v10);
        v4 = *((unsigned __int8 *)a3 + 23);
        v6 = (size_t)a3[1];
        v5 = *((_BYTE *)a3 + 23);
      }
      if (v5 < 0)
        v4 = v6;
      if (v4)
      {
        if (v5 >= 0)
          v12 = a3;
        else
          v12 = *a3;
        v13 = __dst;
        v14 = v4;
        return memmove(v13, v12, v14);
      }
    }
  }
  else
  {
    if (v7)
    {
      if ((v4 & 0x80u) == 0)
        v15 = a3;
      else
        v15 = *a3;
      result = memmove(__dst, v15, v7);
    }
    if (v9 != v7)
    {
      v16 = &__dst[v7];
      do
      {
        *v16++ = v8[52];
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

char *health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>(char *result, char *a2)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  unint64_t v7;
  char *v8;

  v3 = result + 72;
  v2 = *((_QWORD *)result + 9);
  if (result[80])
  {
    v4 = *(_QWORD *)result;
    if (!*(_BYTE *)(*(_QWORD *)result + 48))
    {
      v6 = 0;
      goto LABEL_7;
    }
    v5 = *(_BYTE *)(v4 + 49);
  }
  else
  {
    v5 = 45;
  }
  *a2++ = v5;
  v4 = *(_QWORD *)result;
  v6 = 1;
LABEL_7:
  if (*(_BYTE *)(v4 + 16))
  {
    if (*(_BYTE *)(v4 + 50))
    {
      v7 = v6 - v2 + 64;
      if (v7 < *(_QWORD *)(v4 + 24))
      {
        do
        {
          *a2++ = 48;
          ++v7;
        }
        while (v7 < *(_QWORD *)(*(_QWORD *)result + 24));
      }
    }
  }
  v8 = &result[*((_QWORD *)result + 9) + 8];
  if (v3 != v8)
    return (char *)memmove(a2, v8, v3 - v8);
  return result;
}

uint64_t health::TypeFormatter<unsigned long long &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B798EFC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::LogHeader::serialize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;

  LODWORD(v5) = *(_DWORD *)a1;
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *(_DWORD *)(a1 + 4);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  v5 = *(_QWORD *)(a1 + 8);
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  v5 = *(_QWORD *)(a1 + 16);
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
}

void health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  int v25;
  uint64_t v26;
  char *v27;
  int v28;
  std::runtime_error *exception;
  std::runtime_error *v30;
  char v31[8];
  uint64_t v32;
  char v33;
  unint64_t v34;
  char *v35;
  void *__p;
  unint64_t v37;
  unsigned __int8 v38;
  uint64_t v39;
  char v40;
  uint64_t v41;

  v8 = 0;
  v9 = 0;
  v41 = *MEMORY[0x1E0C80C00];
  for (i = (char *)a1; ; ++i)
  {
    v35 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v35 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v35 = i + 2;
    v25 = i[2];
    if ((v25 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v26 = 0;
      v27 = i + 3;
      do
      {
        v35 = v27;
        v26 = (v25 - 48) + 10 * v26;
        v28 = *v27++;
        v25 = v28;
      }
      while ((v28 - 58) >= 0xFFFFFFF6);
      v35 = v27;
      if (*(v27 - 1) == 125)
        health::FormatterParameters<0ul,long long &,unsigned long,unsigned long long &,unsigned long long &>::formatOptionsAtIndex<long long &,unsigned long,unsigned long long &,unsigned long long &>(v26);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v31, (const char **)&v35);
  v12 = v35;
  switch(v32)
  {
    case 0:
      health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, *(_QWORD *)(a4 + 24), (uint64_t)v31);
      v13 = v38;
      if ((v38 & 0x80u) != 0)
        v13 = v37;
      v14 = v34;
      if (v34 <= v13)
        v14 = v13;
      if (v33)
        v13 = v14;
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_39;
    case 1:
      health::TypeFormatter<unsigned long,void>::TypeFormatter((uint64_t)&__p, **(_QWORD **)(a4 + 16), (uint64_t)v31);
      if (v40 && !*((_BYTE *)__p + 48))
        v20 = 64;
      else
        v20 = 65;
      v21 = v20 - v39;
      if (*((_BYTE *)__p + 50) && v21 <= *((_QWORD *)__p + 3))
        v21 = *((_QWORD *)__p + 3);
      v22 = v34;
      if (v34 <= v21)
        v22 = v21;
      if (v33)
        v23 = v22;
      else
        v23 = v21;
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v23 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v24 = (char *)a2;
      else
        v24 = (char *)a2->__r_.__value_.__r.__words[0];
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long>(v31, &v24[a3 + v8], (uint64_t *)&__p);
      goto LABEL_57;
    case 2:
      health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *(_QWORD *)(a4 + 8), (uint64_t)v31);
      v16 = v38;
      if ((v38 & 0x80u) != 0)
        v16 = v37;
      v17 = v34;
      if (v34 <= v16)
        v17 = v16;
      if (v33)
        v16 = v17;
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v16 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_39;
    case 3:
      health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *(_QWORD *)a4, (uint64_t)v31);
      v18 = v38;
      if ((v38 & 0x80u) != 0)
        v18 = v37;
      v19 = v34;
      if (v34 <= v18)
        v19 = v18;
      if (v33)
        v18 = v19;
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v18 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_39:
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v31, &v15[a3 + v8], (const void **)&__p);
      if ((char)v38 < 0)
        operator delete(__p);
LABEL_57:
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      break;
    default:
      v30 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v30, "Parameter index out of bounds.");
      __cxa_throw(v30, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
}

void sub_1B798F4E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,unsigned long,unsigned long long &,unsigned long long &>::formatOptionsAtIndex<long long &,unsigned long,unsigned long long &,unsigned long long &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3)
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B798F5F0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long>(char *result, char *a2, uint64_t *a3)
{
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  char *v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;

  v3 = a2;
  v4 = result;
  v5 = *a3;
  if (*((_BYTE *)a3 + 80) && !*(_BYTE *)(v5 + 48))
    v6 = 64;
  else
    v6 = 65;
  v7 = v6 - a3[9];
  if (*(_BYTE *)(v5 + 50))
  {
    v8 = *(_QWORD *)(v5 + 24);
    if (v7 <= v8)
      v7 = v8;
  }
  if (!result[16])
    return health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
  v9 = *((_QWORD *)result + 3);
  v10 = v9 - v7;
  if (v9 <= v7)
    return health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
  v11 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v11 != 1)
    {
      if (v11 != 2)
        return result;
      if (v9 != v7)
      {
        v12 = a2;
        v3 = &a2[v9 - v7];
        do
        {
          *v12++ = result[52];
          --v10;
        }
        while (v10);
      }
      return health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
    }
    v14 = v10 >> 1;
    if (v10 >= 2)
    {
      if (v14 <= 1)
        v15 = 1;
      else
        v15 = v10 >> 1;
      do
      {
        *v3++ = result[52];
        --v15;
      }
      while (v15);
    }
    result = health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
    if (v10 != v14)
    {
      v16 = v10 - (v10 >> 1);
      v17 = &v3[v7];
      if (v16 <= 1)
        v16 = 1;
      v18 = -(uint64_t)v16;
      do
        *v17++ = v4[52];
      while (!__CFADD__(v18++, 1));
    }
  }
  else
  {
    result = health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, a2);
    if (v9 != v7)
    {
      v13 = &v3[v7];
      do
      {
        *v13++ = v4[52];
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

uint64_t health::TypeFormatter<unsigned long,void>::TypeFormatter(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;
  _BYTE *v5;

  *(_QWORD *)result = a3;
  *(_QWORD *)(result + 72) = 0;
  *(_BYTE *)(result + 80) = 1;
  switch(*(_DWORD *)(a3 + 4))
  {
    case 0:
      v3 = 71;
      do
      {
        *(_BYTE *)(result + v3--) = (a2 % 0xA) | 0x30;
        v4 = a2 >= 0xA;
        a2 /= 0xAuLL;
      }
      while (v4);
      goto LABEL_16;
    case 1:
      v3 = 71;
      do
      {
        *(_BYTE *)(result + v3--) = a2 & 7 | 0x30;
        v4 = a2 >= 8;
        a2 >>= 3;
      }
      while (v4);
      goto LABEL_16;
    case 2:
      if (*(_BYTE *)(a3 + 51))
        v5 = &health::TypeFormatterUpperHexMapping;
      else
        v5 = &health::TypeFormatterLowerHexMapping;
      v3 = 71;
      do
      {
        *(_BYTE *)(result + v3--) = v5[a2 & 0xF];
        v4 = a2 >= 0x10;
        a2 >>= 4;
      }
      while (v4);
      goto LABEL_16;
    case 3:
      v3 = 71;
      do
      {
        *(_BYTE *)(result + v3--) = a2 & 1 | 0x30;
        v4 = a2 >= 2;
        a2 >>= 1;
      }
      while (v4);
LABEL_16:
      *(_QWORD *)(result + 72) = v3 - 7;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t health::TypeFormatter<long long &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B798F9FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

void health::FormatString<char const*>(std::string *a1@<X0>, const char **a2@<X1>, std::string *a3@<X8>)
{
  const char **v3;

  v3 = a2;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<char const*>(a1, a3, 0, &v3);
}

void sub_1B798FA7C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<char const*>(std::string *a1, std::string *this, std::string::size_type a3, const char ***a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  int v12;
  uint64_t v13;
  char *v14;
  int v15;
  std::runtime_error *exception;
  __int128 v17[3];
  char *v18;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v18 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v18 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v18 = i + 2;
    v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v13 = 0;
      v14 = i + 3;
      do
      {
        v18 = v14;
        v13 = (v12 - 48) + 10 * v13;
        v15 = *v14++;
        v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      v18 = v14;
      if (*(v14 - 1) == 125)
        health::FormatterParameters<0ul,char const*>::formatOptionsAtIndex<char const*>((uint64_t)a4, (uint64_t)a4, v13);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v18);
  health::FormatterParameters<0ul,char const*>::formatParameterAtIndex<char const*>(a4, (int)a4, *((uint64_t *)&v17[0] + 1), v17, this, a3 - v8, (int)v18);
  if (v8)
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
}

void sub_1B798FC8C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,char const*>::formatOptionsAtIndex<char const*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::runtime_error *exception;

  if (a3)
    health::FormatterParameters<1ul>::formatOptionsAtIndex<char const*>();
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B798FCF0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_BYTE *health::FormatterParameters<0ul,char const*>::formatParameterAtIndex<char const*>(const char ***a1, int a2, uint64_t a3, __int128 *a4, std::string *this, uint64_t a6, int a7)
{
  const char *v11;
  __int128 v12;
  std::string *v13;
  _QWORD v15[2];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  if (a3)
    health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,char const*>>();
  v11 = **a1;
  v15[0] = v11;
  if (v11)
    v11 = (const char *)strlen(v11);
  v15[1] = v11;
  v12 = a4[1];
  v16 = *a4;
  v17 = v12;
  v18 = a4[2];
  v19 = *((_QWORD *)a4 + 6);
  health::FormatImplementation<char const*>(a7, this);
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = this;
  else
    v13 = (std::string *)this->__r_.__value_.__r.__words[0];
  return health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(a4, (_BYTE *)v13 + a6, (uint64_t)v15);
}

void health::FormatterParameters<1ul>::formatOptionsAtIndex<char const*>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B798FE34(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,char const*>>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B798FE84(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_BYTE *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(_BYTE *result, _BYTE *__dst, uint64_t a3)
{
  _BYTE *v3;
  size_t v4;
  size_t v5;
  _BYTE *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  _BYTE *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _BYTE *v14;
  uint64_t v15;

  v3 = __dst;
  v4 = *(_QWORD *)(a3 + 8);
  v5 = v4;
  if (!result[16] || (v6 = result, v7 = *((_QWORD *)result + 3), v8 = v7 - v4, v7 <= v4))
  {
LABEL_9:
    if (v5)
      return memmove(v3, *(const void **)a3, v5);
    return result;
  }
  v9 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v9 != 1)
    {
      if (v9 != 2)
        return result;
      if (v7 != v4)
      {
        do
        {
          *v3++ = result[52];
          --v8;
        }
        while (v8);
        v5 = *(_QWORD *)(a3 + 8);
      }
      goto LABEL_9;
    }
    v11 = v8 >> 1;
    if (v8 >= 2)
    {
      if (v11 <= 1)
        v12 = 1;
      else
        v12 = v8 >> 1;
      do
      {
        *v3++ = result[52];
        --v12;
      }
      while (v12);
      v5 = *(_QWORD *)(a3 + 8);
    }
    if (v5)
      result = memmove(v3, *(const void **)a3, v5);
    if (v8 != v11)
    {
      v13 = v8 - (v8 >> 1);
      v14 = &v3[v4];
      if (v13 <= 1)
        v13 = 1;
      v15 = -(uint64_t)v13;
      do
        *v14++ = v6[52];
      while (!__CFADD__(v15++, 1));
    }
  }
  else
  {
    if (v4)
      result = memmove(__dst, *(const void **)a3, *(_QWORD *)(a3 + 8));
    if (v7 != v4)
    {
      v10 = &v3[v4];
      do
      {
        *v10++ = v6[52];
        --v8;
      }
      while (v8);
    }
  }
  return result;
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *result;
  unint64_t v7;

  if (!a2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a3;
    if (a3 >= a2)
      v4 = a3 % a2;
  }
  else
  {
    v4 = (a2 - 1) & a3;
  }
  v5 = *(_QWORD **)(a1 + 8 * v4);
  if (!v5)
    return 0;
  result = (_QWORD *)*v5;
  if (*v5)
  {
    do
    {
      v7 = result[1];
      if (v7 == a3)
      {
        if (result[2] == a3)
          return result;
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= a2)
            v7 %= a2;
        }
        else
        {
          v7 &= a2 - 1;
        }
        if (v7 != v4)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(float *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  _QWORD *v33;

  v5 = a2;
  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = (_QWORD *)*v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = operator new(0x18uLL);
  *v12 = 0;
  v12[1] = v5;
  v12[2] = a3;
  v13 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v15 = 1;
  if (v7 >= 3)
    v15 = (v7 & (v7 - 1)) != 0;
  v16 = v15 | (2 * v7);
  v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17)
    prime = (int8x8_t)v17;
  else
    prime = (int8x8_t)v16;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = *((_QWORD *)a1 + 1);
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      v25 = std::__next_prime(v25);
    }
    else
    {
      v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2)
        v25 = v27;
    }
    if (*(_QWORD *)&prime <= v25)
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = *((_QWORD *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v33 = *(_QWORD **)a1;
      *(_QWORD *)a1 = 0;
      if (v33)
        operator delete(v33);
      v7 = 0;
      *((_QWORD *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v19 = operator new(8 * *(_QWORD *)&prime);
  v20 = *(_QWORD **)a1;
  *(_QWORD *)a1 = v19;
  if (v20)
    operator delete(v20);
  v21 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v21++) = 0;
  while (*(_QWORD *)&prime != v21);
  v22 = (_QWORD *)*((_QWORD *)a1 + 2);
  if (v22)
  {
    v23 = v22[1];
    v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&prime)
        v23 %= *(_QWORD *)&prime;
    }
    else
    {
      v23 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = a1 + 4;
    v28 = (_QWORD *)*v22;
    if (*v22)
    {
      do
      {
        v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(_QWORD *)&prime)
            v29 %= *(_QWORD *)&prime;
        }
        else
        {
          v29 &= *(_QWORD *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v29))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *v22 = *v28;
          *v28 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v29);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v29) = v28;
          v28 = v22;
        }
        v29 = v23;
LABEL_56:
        v22 = v28;
        v28 = (_QWORD *)*v28;
        v23 = v29;
      }
      while (v28);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v30 = *(_QWORD **)a1;
  v31 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
  if (v31)
  {
    *v12 = *v31;
LABEL_72:
    *v31 = v12;
    goto LABEL_73;
  }
  *v12 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v12;
  v30[v5] = a1 + 4;
  if (*v12)
  {
    v32 = *(_QWORD *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*(_QWORD *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
}

void sub_1B799044C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<int>(std::string *a1, std::string *this, std::string::size_type a3, int **a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  int v12;
  uint64_t v13;
  char *v14;
  int v15;
  std::runtime_error *exception;
  char v17[8];
  uint64_t v18;
  char *v19;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v19 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v19 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v19 = i + 2;
    v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v13 = 0;
      v14 = i + 3;
      do
      {
        v19 = v14;
        v13 = (v12 - 48) + 10 * v13;
        v15 = *v14++;
        v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      v19 = v14;
      if (*(v14 - 1) == 125)
        health::FormatterParameters<0ul,int>::formatOptionsAtIndex<int>((uint64_t)a4, (uint64_t)a4, v13);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v19);
  health::FormatterParameters<0ul,int>::formatParameterAtIndex<int>(a4, (uint64_t)a4, v18, v17, this, a3 - v8, (int)v19);
  if (v8)
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
}

void sub_1B7990654(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,int>::formatOptionsAtIndex<int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::runtime_error *exception;

  if (a3)
    health::FormatterParameters<1ul>::formatOptionsAtIndex<int>();
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B79906B8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *health::FormatterParameters<0ul,int>::formatParameterAtIndex<int>(int **a1, uint64_t a2, uint64_t a3, char *a4, std::string *a5, uint64_t a6, int a7)
{
  char *v11;
  uint64_t v13[8];

  v13[7] = *MEMORY[0x1E0C80C00];
  if (a3)
    health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,int>>();
  health::TypeFormatter<int,void>::TypeFormatter((uint64_t)v13, **a1, (uint64_t)a4);
  health::FormatImplementation<int>(a7, a5);
  if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = (char *)a5;
  else
    v11 = (char *)a5->__r_.__value_.__r.__words[0];
  return health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned int>(a4, &v11[a6], v13);
}

void health::FormatterParameters<1ul>::formatOptionsAtIndex<int>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7990860(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,int>>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B79908B0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<int,void>::TypeFormatter(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;
  unsigned int v5;
  _BYTE *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  unsigned int v12;

  *(_QWORD *)result = a3;
  *(_QWORD *)(result + 40) = 0;
  *(_BYTE *)(result + 48) = a2 >= 0;
  switch(*(_DWORD *)(a3 + 4))
  {
    case 0:
      v3 = 39;
      if (a2 < 0)
      {
        do
        {
          v11 = -a2;
          v12 = a2 + 9;
          a2 /= 10;
          *(_BYTE *)(result + v3--) = v11 + 10 * a2 + 48;
        }
        while (v12 >= 0x13);
      }
      else
      {
        do
        {
          *(_BYTE *)(result + v3--) = (a2 % 0xAu) | 0x30;
          v4 = a2 >= 0xA;
          a2 /= 0xAu;
        }
        while (v4);
      }
      goto LABEL_26;
    case 1:
      if (a2 >= 0)
        v5 = a2;
      else
        v5 = -a2;
      v3 = 39;
      do
      {
        *(_BYTE *)(result + v3--) = v5 & 7 | 0x30;
        v4 = v5 >= 8;
        v5 >>= 3;
      }
      while (v4);
      goto LABEL_26;
    case 2:
      v6 = &health::TypeFormatterUpperHexMapping;
      if (!*(_BYTE *)(a3 + 51))
        v6 = &health::TypeFormatterLowerHexMapping;
      if (a2 >= 0)
        v7 = a2;
      else
        v7 = -a2;
      v8 = 39;
      do
      {
        *(_BYTE *)(result + v8--) = v6[v7 & 0xF];
        v4 = v7 >= 0x10;
        v7 >>= 4;
      }
      while (v4);
      v9 = v8 - 7;
      goto LABEL_27;
    case 3:
      if (a2 >= 0)
        v10 = a2;
      else
        v10 = -a2;
      v3 = 39;
      do
      {
        *(_BYTE *)(result + v3--) = v10 & 1 | 0x30;
        v4 = v10 >= 2;
        v10 >>= 1;
      }
      while (v4);
LABEL_26:
      v9 = v3 - 7;
LABEL_27:
      *(_QWORD *)(result + 40) = v9;
      break;
    default:
      return result;
  }
  return result;
}

void std::__shared_ptr_emplace<health::WriteAheadLog::Transaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6CF23F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<health::WriteAheadLog::Transaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6CF23F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCAC494);
}

void health::FormatImplementation<unsigned long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  char *v18;
  int v19;
  std::runtime_error *exception;
  char v21[8];
  uint64_t v22;
  char v23;
  unint64_t v24;
  char *v25;
  void *__p[2];
  unsigned __int8 v27;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v25 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v25 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v25 = i + 2;
    v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v17 = 0;
      v18 = i + 3;
      do
      {
        v25 = v18;
        v17 = (v16 - 48) + 10 * v17;
        v19 = *v18++;
        v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      v25 = v18;
      if (*(v18 - 1) == 125)
        health::FormatterParameters<0ul,unsigned long long &>::formatOptionsAtIndex<unsigned long long &>(v17);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_33:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_33;
  }
  v12 = v25;
  health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  v13 = v27;
  if ((v27 & 0x80u) != 0)
    v13 = (unint64_t)__p[1];
  v14 = v24;
  if (v24 <= v13)
    v14 = v13;
  if (v23)
    v13 = v14;
  health::FormatImplementation<unsigned long long &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = (char *)a2;
  else
    v15 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0)
    operator delete(__p[0]);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7990CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long &>::formatOptionsAtIndex<unsigned long long &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  v3 = exception;
  if (a1)
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  else
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(v3, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7990D5C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E6CF2440;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF2440;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::operator()(uint64_t a1, uint64_t **a2, __int128 *a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  __int128 v19;
  uint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  char *v31;
  char *v32;
  uint64_t *v33;
  __int128 v34;
  unint64_t v35;
  unint64_t v36;
  __int128 v37;
  char *v38;
  uint64_t *v39;
  __int128 v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  __int128 v47;
  __int128 v48;
  char *v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  __int128 v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  __int128 v60;
  char *v61;
  int64_t v62;
  uint64_t *v63;
  __int128 v64;
  uint64_t v65;

  v4 = *a2;
  v64 = *a3;
  v65 = *((_QWORD *)a3 + 2);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(uint64_t **)(v5 + 272);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v6;
        v8 = v6[4];
        if (v8 <= (unint64_t)v4)
          break;
        v6 = *v7;
        v9 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= (unint64_t)v4)
        break;
      v6 = v7[1];
      if (!v6)
      {
        v9 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v9 = (uint64_t **)(v5 + 272);
    v7 = (uint64_t **)(v5 + 272);
LABEL_9:
    v10 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x40uLL);
    v7[4] = v4;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v10;
    *v9 = (uint64_t *)v7;
    v11 = **(_QWORD **)(v5 + 264);
    v12 = (uint64_t *)v7;
    if (v11)
    {
      *(_QWORD *)(v5 + 264) = v11;
      v12 = *v9;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 272), v12);
    ++*(_QWORD *)(v5 + 280);
  }
  v14 = (char *)v7[5];
  v13 = (char *)v7[6];
  if (v14 == v13)
  {
LABEL_17:
    v18 = (unint64_t)v7[7];
    if ((unint64_t)v13 >= v18)
    {
      v21 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v14) >> 3);
      v22 = v21 + 1;
      if (v21 + 1 > 0xAAAAAAAAAAAAAAALL)
        goto LABEL_73;
      v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - (_QWORD)v14) >> 3);
      if (2 * v23 > v22)
        v22 = 2 * v23;
      if (v23 >= 0x555555555555555)
        v24 = 0xAAAAAAAAAAAAAAALL;
      else
        v24 = v22;
      if (v24)
        v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(v24);
      else
        v25 = 0;
      v35 = v24 + 24 * v21;
      v36 = v24 + 24 * v25;
      v37 = v64;
      *(_QWORD *)(v35 + 16) = v65;
      *(_OWORD *)v35 = v37;
      v20 = (uint64_t *)(v35 + 24);
      v39 = v7[5];
      v38 = (char *)v7[6];
      if (v38 != (char *)v39)
      {
        do
        {
          v40 = *(_OWORD *)(v38 - 24);
          *(_QWORD *)(v35 - 8) = *((_QWORD *)v38 - 1);
          *(_OWORD *)(v35 - 24) = v40;
          v35 -= 24;
          v38 -= 24;
        }
        while (v38 != (char *)v39);
        v38 = (char *)v7[5];
      }
      v7[5] = (uint64_t *)v35;
      v7[6] = v20;
      v7[7] = (uint64_t *)v36;
      if (v38)
        operator delete(v38);
    }
    else
    {
      v19 = v64;
      *((_QWORD *)v13 + 2) = v65;
      *(_OWORD *)v13 = v19;
      v20 = (uint64_t *)(v13 + 24);
    }
    v7[6] = v20;
    return;
  }
  v15 = 0;
  v16 = **(_QWORD **)(a1 + 16);
  while (1)
  {
    v17 = *(_QWORD *)&v14[v15];
    if (v17 == v16)
    {
      v26 = &v14[v15];
      v27 = v64;
      *((_QWORD *)v26 + 2) = v65;
      *(_OWORD *)v26 = v27;
      return;
    }
    if (v17 > v16)
      break;
    v15 += 24;
    if (&v14[v15] == v13)
      goto LABEL_17;
  }
  v28 = v15 / 24;
  v29 = &v14[24 * (v15 / 24)];
  v30 = (unint64_t)v7[7];
  if ((unint64_t)v13 < v30)
  {
    if (v29 == v13)
    {
      v48 = v64;
      *((_QWORD *)v13 + 2) = v65;
      *(_OWORD *)v13 = v48;
      v7[6] = (uint64_t *)(v13 + 24);
    }
    else
    {
      v31 = v29 + 24;
      v32 = v13 - 24;
      v33 = v7[6];
      while (v32 < v13)
      {
        v34 = *(_OWORD *)v32;
        v33[2] = *((_QWORD *)v32 + 2);
        *(_OWORD *)v33 = v34;
        v33 += 3;
        v32 += 24;
      }
      v7[6] = v33;
      if (v13 != v31)
        memmove(v29 + 24, v29, v13 - v31);
      v46 = (char *)&v64;
      if (v29 <= (char *)&v64)
        v46 = (char *)&v64 + 24 * (v7[6] > (uint64_t *)&v64);
      v47 = *(_OWORD *)v46;
      *((_QWORD *)v29 + 2) = *((_QWORD *)v46 + 2);
      *(_OWORD *)v29 = v47;
    }
    return;
  }
  v41 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v14) >> 3) + 1;
  if (v41 > 0xAAAAAAAAAAAAAAALL)
LABEL_73:
    std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
  v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - (_QWORD)v14) >> 3);
  if (2 * v42 > v41)
    v41 = 2 * v42;
  if (v42 >= 0x555555555555555)
    v43 = 0xAAAAAAAAAAAAAAALL;
  else
    v43 = v41;
  if (v43)
  {
    v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(v43);
  }
  else
  {
    v45 = 0;
    v44 = 0;
  }
  v49 = &v45[24 * v28];
  v50 = &v45[24 * v44];
  if (v28 == v44)
  {
    if (v15 < 1)
    {
      if (v15)
        v52 = 2 * v28;
      else
        v52 = 1;
      v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(v52);
      v49 = &v53[24 * (v52 >> 2)];
      v50 = &v53[24 * v54];
      if (v45)
        operator delete(v45);
    }
    else
    {
      v51 = v28 + 2;
      if (v28 >= -1)
        v51 = v28 + 1;
      v49 -= 24 * (v51 >> 1);
    }
  }
  v55 = v64;
  *((_QWORD *)v49 + 2) = v65;
  *(_OWORD *)v49 = v55;
  v56 = (char *)v7[5];
  v57 = v49;
  if (v56 != v29)
  {
    v58 = v29;
    v59 = v49;
    do
    {
      v60 = *(_OWORD *)(v58 - 24);
      v57 = v59 - 24;
      *((_QWORD *)v59 - 1) = *((_QWORD *)v58 - 1);
      *(_OWORD *)(v59 - 24) = v60;
      v58 -= 24;
      v59 -= 24;
    }
    while (v58 != v56);
  }
  v61 = (char *)v7[6];
  v62 = v61 - v29;
  if (v61 != v29)
    memmove(v49 + 24, v29, v61 - v29);
  v63 = v7[5];
  v7[5] = (uint64_t *)v57;
  v7[6] = (uint64_t *)&v49[v62 + 24];
  v7[7] = (uint64_t *)v50;
  if (v63)
    operator delete(v63);
}

void sub_1B7991248(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target_type()
{
}

uint64_t **std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x40uLL);
    v7[4] = *a3;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

_QWORD *std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E6CF24D0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E6CF24D0;
  a2[1] = v2;
  return result;
}

__n128 std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::operator()(uint64_t a1, uint64_t **a2, __n128 *a3)
{
  uint64_t **v4;
  uint64_t **v5;
  uint64_t *v6;
  __n128 result;
  uint64_t *v8;

  v4 = (uint64_t **)(*(_QWORD *)(a1 + 8) + 32);
  v8 = *a2;
  v5 = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v4, (unint64_t)v8, &v8);
  v6 = (uint64_t *)a3[1].n128_u64[0];
  result = *a3;
  *(__n128 *)(v5 + 5) = *a3;
  v5[7] = v6;
  return result;
}

uint64_t std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target_type()
{
}

void health::FormatImplementation<std::string,unsigned long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  std::runtime_error *exception;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  char *v30;
  void *__p;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v30 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v30 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v30 = i + 2;
    v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v21 = 0;
      v22 = i + 3;
      do
      {
        v30 = v22;
        v21 = (v20 - 48) + 10 * v21;
        v23 = *v22++;
        v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      v30 = v22;
      if (*(v22 - 1) == 125)
        health::FormatterParameters<0ul,std::string,unsigned long long &>::formatOptionsAtIndex<std::string,unsigned long long &>(v21);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_45;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v25, (const char **)&v30);
  v12 = v30;
  if (v26)
  {
    if (v26 == 1)
    {
      health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)&v25);
      v13 = HIBYTE(v32);
      if (v32 < 0)
        v13 = v32;
      v14 = *((_QWORD *)&v27 + 1);
      if (*((_QWORD *)&v27 + 1) <= v13)
        v14 = v13;
      if ((_BYTE)v27)
        v13 = v14;
      health::FormatImplementation<std::string,unsigned long long &>(v12, a2, v13 + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v25, &v15[a3 - v8], (const void **)&__p);
      if (SHIBYTE(v32) < 0)
        operator delete(__p);
      goto LABEL_35;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_45:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  v16 = a4[1];
  __p = (void *)v16;
  v32 = v25;
  v33 = v27;
  v34 = v28;
  v35 = v29;
  if (*(char *)(v16 + 23) < 0)
    v17 = *(_QWORD *)(v16 + 8);
  else
    v17 = *(unsigned __int8 *)(v16 + 23);
  v18 = *((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1) <= v17)
    v18 = v17;
  if ((_BYTE)v27)
    v17 = v18;
  health::FormatImplementation<std::string,unsigned long long &>(v30, a2, v17 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = (char *)a2;
  else
    v19 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v25, &v19[a3 - v8], (uint64_t)&__p);
LABEL_35:
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7991760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string,unsigned long long &>::formatOptionsAtIndex<std::string,unsigned long long &>(uint64_t a1)
{
  std::runtime_error *v1;
  std::runtime_error *exception;

  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v1 = exception;
    if (a1 == 1)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7991818(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_DWORD *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(_DWORD *result, char *__dst, uint64_t a3)
{
  _BYTE *v4;
  _QWORD *v5;
  int v6;
  size_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  size_t v12;
  void *v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  size_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  _QWORD *v22;
  _QWORD *v23;

  v4 = result;
  v5 = *(_QWORD **)a3;
  v6 = *(char *)(*(_QWORD *)a3 + 23);
  v7 = *(unsigned __int8 *)(*(_QWORD *)a3 + 23);
  if (v6 < 0)
    v8 = v5[1];
  else
    v8 = *(unsigned __int8 *)(*(_QWORD *)a3 + 23);
  if (!*((_BYTE *)result + 16) || (v9 = *((_QWORD *)result + 3), v10 = v9 - v8, v9 <= v8))
  {
    if (v6 < 0)
    {
      v5 = (_QWORD *)*v5;
      v7 = *(_QWORD *)(*(_QWORD *)a3 + 8);
      if (!v7)
        return result;
    }
    else if (!*(_BYTE *)(*(_QWORD *)a3 + 23))
    {
      return result;
    }
    v13 = __dst;
    v12 = v7;
    return memmove(v13, v5, v12);
  }
  v11 = *result;
  if (!*result)
  {
    if (v6 < 0)
    {
      v5 = (_QWORD *)*v5;
      v7 = *(_QWORD *)(*(_QWORD *)a3 + 8);
    }
    if (v7)
      result = memmove(__dst, v5, v7);
    if (v9 != v8)
    {
      v14 = &__dst[v8];
      do
      {
        *v14++ = v4[52];
        --v10;
      }
      while (v10);
    }
    return result;
  }
  if (v11 == 1)
  {
    v15 = v10 >> 1;
    if (v10 >= 2)
    {
      if (v15 <= 1)
        v16 = 1;
      else
        v16 = v10 >> 1;
      do
      {
        *__dst++ = *((_BYTE *)result + 52);
        --v16;
      }
      while (v16);
      v5 = *(_QWORD **)a3;
      LOBYTE(v6) = *(_BYTE *)(*(_QWORD *)a3 + 23);
    }
    if ((v6 & 0x80) != 0)
    {
      v22 = v5;
      v5 = (_QWORD *)*v5;
      v17 = v22[1];
      if (!v17)
      {
LABEL_38:
        if (v10 != v15)
        {
          v18 = v10 - (v10 >> 1);
          v19 = &__dst[v8];
          if (v18 <= 1)
            v18 = 1;
          v20 = -(uint64_t)v18;
          do
            *v19++ = v4[52];
          while (!__CFADD__(v20++, 1));
        }
        return result;
      }
    }
    else
    {
      v17 = v6;
      if (!(_BYTE)v6)
        goto LABEL_38;
    }
    result = memmove(__dst, v5, v17);
    goto LABEL_38;
  }
  if (v11 == 2)
  {
    if (v9 != v8)
    {
      do
      {
        *__dst++ = *((_BYTE *)result + 52);
        --v10;
      }
      while (v10);
      v5 = *(_QWORD **)a3;
      LOBYTE(v6) = *(_BYTE *)(*(_QWORD *)a3 + 23);
    }
    if ((v6 & 0x80) == 0)
    {
      v12 = v6;
      if (!(_BYTE)v6)
        return result;
      goto LABEL_48;
    }
    v23 = v5;
    v5 = (_QWORD *)*v5;
    v12 = v23[1];
    if (v12)
    {
LABEL_48:
      v13 = __dst;
      return memmove(v13, v5, v12);
    }
  }
  return result;
}

void sub_1B7992534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__56(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__56(uint64_t a1)
{

}

uint64_t HDCloudSyncCodableProfileIdentifierReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  uint64_t v17;
  void *v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v19 = 0;
        v20 = 0;
        v21 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          if (v23 == -1 || v23 >= *(_QWORD *)(a2 + *v4))
            break;
          v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
          *(_QWORD *)(a2 + v22) = v23 + 1;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0)
            goto LABEL_31;
          v19 += 7;
          v14 = v20++ >= 9;
          if (v14)
          {
            v21 = 0;
            goto LABEL_33;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_33:
        *(_QWORD *)(a1 + 8) = v21;
      }
      else if ((v10 >> 3) == 1)
      {
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v17;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7993370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1B7993854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__57(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__57(uint64_t a1)
{

}

uint64_t HDCodableScoredAssessmentReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  HDCodableSample *v17;
  uint64_t result;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t v25;
  void *v26;
  char v27;
  unsigned int v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  uint64_t v32;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v17 = objc_alloc_init(HDCodableSample);
          objc_storeStrong((id *)(a1 + 32), v17);
          if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v17, a2) & 1) != 0)
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          v19 = 0;
          v20 = 0;
          v21 = 0;
          *(_BYTE *)(a1 + 40) |= 2u;
          while (1)
          {
            v22 = *v3;
            v23 = *(_QWORD *)(a2 + v22);
            if (v23 == -1 || v23 >= *(_QWORD *)(a2 + *v4))
              break;
            v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
            *(_QWORD *)(a2 + v22) = v23 + 1;
            v21 |= (unint64_t)(v24 & 0x7F) << v19;
            if ((v24 & 0x80) == 0)
              goto LABEL_40;
            v19 += 7;
            v14 = v20++ >= 9;
            if (v14)
            {
              v21 = 0;
              goto LABEL_42;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_40:
          if (*(_BYTE *)(a2 + *v5))
            v21 = 0;
LABEL_42:
          v32 = 16;
          goto LABEL_47;
        case 3u:
          PBReaderReadData();
          v25 = objc_claimAutoreleasedReturnValue();
          v26 = *(void **)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v25;

          continue;
        case 4u:
          v27 = 0;
          v28 = 0;
          v21 = 0;
          *(_BYTE *)(a1 + 40) |= 1u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v29 = *v3;
        v30 = *(_QWORD *)(a2 + v29);
        if (v30 == -1 || v30 >= *(_QWORD *)(a2 + *v4))
          break;
        v31 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v30);
        *(_QWORD *)(a2 + v29) = v30 + 1;
        v21 |= (unint64_t)(v31 & 0x7F) << v27;
        if ((v31 & 0x80) == 0)
          goto LABEL_44;
        v27 += 7;
        v14 = v28++ >= 9;
        if (v14)
        {
          v21 = 0;
          goto LABEL_46;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_44:
      if (*(_BYTE *)(a2 + *v5))
        v21 = 0;
LABEL_46:
      v32 = 8;
LABEL_47:
      *(_QWORD *)(a1 + v32) = v21;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t getgetSleepFeatureAvailabilityProvidingSymbolLoc()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = qword_1ED552230;
  v6 = qword_1ED552230;
  if (!qword_1ED552230)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __getgetSleepFeatureAvailabilityProvidingSymbolLoc_block_invoke;
    v2[3] = &unk_1E6CECDD0;
    v2[4] = &v3;
    __getgetSleepFeatureAvailabilityProvidingSymbolLoc_block_invoke(v2);
    v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1B7994B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__getgetSleepFeatureAvailabilityProvidingSymbolLoc_block_invoke(_QWORD *a1)
{
  void *v2;
  void *result;
  void *v4;

  if (!_MergedGlobals_201)
    _MergedGlobals_201 = _sl_dlopen();
  v2 = (void *)_MergedGlobals_201;
  if (!_MergedGlobals_201)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    a1 = (_QWORD *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *SleepLibrary(void)");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(a1, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("HDProfile+HKFeatureAvailabilityHealthDataSource.m"), 25, CFSTR("%s"), 0);

    __break(1u);
    free(v4);
  }
  result = dlsym(v2, "getSleepFeatureAvailabilityProviding");
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  qword_1ED552230 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  return result;
}

BOOL HDCloudSyncCodableSharedSummaryAuthorizationRecordReadFrom(_QWORD *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  void *v18;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = (void *)a1[2];
        a1[2] = v17;
LABEL_23:

        goto LABEL_25;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_25:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    PBReaderReadString();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    if (v18)
      objc_msgSend(a1, "addAuthorizationCategories:", v18);
    goto LABEL_23;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7995734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__58(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__58(uint64_t a1)
{

}

void sub_1B79958EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7995C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL HDCodableWorkoutSessionConfigurationReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableWorkoutConfiguration *v17;
  uint64_t v18;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableWorkoutConfiguration);
        objc_storeStrong((id *)(a1 + 16), v17);
        if (!PBReaderPlaceMark() || (HDCodableWorkoutConfigurationReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_26:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    PBReaderReadString();
    v18 = objc_claimAutoreleasedReturnValue();
    v17 = *(HDCodableWorkoutConfiguration **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v18;
LABEL_24:

    goto LABEL_26;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B799773C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  _Block_object_dispose((const void *)(v28 - 240), 8);
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__59(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__59(uint64_t a1)
{

}

__CFString *HDBKSApplicationStateString(unsigned int a1)
{
  if (a1 > 8)
    return 0;
  else
    return off_1E6CF2808[a1];
}

BOOL HDBKSApplicationStateIsForeground(int a1)
{
  return a1 == 8;
}

BOOL HDBKSApplicationStateIsBackgroundRunning(int a1)
{
  return a1 == 4;
}

BOOL HDBKSApplicationStateIsSuspended(int a1)
{
  return a1 == 2;
}

BOOL HDBKSApplicationStateIsTerminated(unsigned int a1)
{
  return a1 < 2;
}

void sub_1B799B940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  id *v19;

  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t HDCodableOriginalSignedClinicalDataRecordReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  HDCodableMessageVersion *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  void *v34;
  uint64_t v35;
  unint64_t v36;
  char v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v18 = objc_alloc_init(HDCodableMessageVersion);
        objc_storeStrong((id *)(a1 + 72), v18);
        if (PBReaderPlaceMark() && HDCodableMessageVersionReadFrom((uint64_t)v18, a2))
          goto LABEL_70;
        goto LABEL_94;
      case 2u:
        PBReaderReadData();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 112;
        goto LABEL_50;
      case 3u:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 56;
        goto LABEL_50;
      case 4u:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 64;
        goto LABEL_50;
      case 5u:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 104;
        goto LABEL_50;
      case 6u:
        PBReaderReadData();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 88;
        goto LABEL_50;
      case 7u:
        PBReaderReadString();
        v18 = (HDCodableMessageVersion *)objc_claimAutoreleasedReturnValue();
        if (v18)
          objc_msgSend((id)a1, "addType:", v18);
        goto LABEL_71;
      case 8u:
        v18 = objc_alloc_init(HDCodableMetadataDictionary);
        objc_storeStrong((id *)(a1 + 80), v18);
        if (!PBReaderPlaceMark() || (HDCodableMetadataDictionaryReadFrom(v18, a2) & 1) == 0)
          goto LABEL_94;
        goto LABEL_70;
      case 9u:
        *(_BYTE *)(a1 + 148) |= 4u;
        v22 = *v3;
        v23 = *(_QWORD *)(a2 + v22);
        if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v24 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v23);
          *(_QWORD *)(a2 + v22) = v23 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v24 = 0;
        }
        v51 = 24;
        goto LABEL_91;
      case 0xAu:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 96;
        goto LABEL_50;
      case 0xBu:
        *(_BYTE *)(a1 + 148) |= 1u;
        v25 = *v3;
        v26 = *(_QWORD *)(a2 + v25);
        if (v26 <= 0xFFFFFFFFFFFFFFF7 && v26 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v24 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v26);
          *(_QWORD *)(a2 + v25) = v26 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v24 = 0;
        }
        v51 = 8;
        goto LABEL_91;
      case 0xCu:
        PBReaderReadString();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 48;
        goto LABEL_50;
      case 0xDu:
        v27 = 0;
        v28 = 0;
        v29 = 0;
        *(_BYTE *)(a1 + 148) |= 8u;
        while (2)
        {
          v30 = *v3;
          v31 = *(_QWORD *)(a2 + v30);
          v32 = v31 + 1;
          if (v31 == -1 || v32 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v31);
            *(_QWORD *)(a2 + v30) = v32;
            v29 |= (unint64_t)(v33 & 0x7F) << v27;
            if (v33 < 0)
            {
              v27 += 7;
              v15 = v28++ >= 9;
              if (v15)
              {
                v29 = 0;
                goto LABEL_75;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v29 = 0;
LABEL_75:
        v50 = 32;
        goto LABEL_84;
      case 0xEu:
        PBReaderReadData();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = 136;
LABEL_50:
        v34 = *(void **)(a1 + v21);
        *(_QWORD *)(a1 + v21) = v20;

        goto LABEL_92;
      case 0xFu:
        *(_BYTE *)(a1 + 148) |= 2u;
        v35 = *v3;
        v36 = *(_QWORD *)(a2 + v35);
        if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v24 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v36);
          *(_QWORD *)(a2 + v35) = v36 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v24 = 0;
        }
        v51 = 16;
LABEL_91:
        *(_QWORD *)(a1 + v51) = v24;
        goto LABEL_92;
      case 0x10u:
        v37 = 0;
        v38 = 0;
        v39 = 0;
        *(_BYTE *)(a1 + 148) |= 0x20u;
        while (2)
        {
          v40 = *v3;
          v41 = *(_QWORD *)(a2 + v40);
          v42 = v41 + 1;
          if (v41 == -1 || v42 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v43 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v41);
            *(_QWORD *)(a2 + v40) = v42;
            v39 |= (unint64_t)(v43 & 0x7F) << v37;
            if (v43 < 0)
            {
              v37 += 7;
              v15 = v38++ >= 9;
              if (v15)
              {
                v39 = 0;
                goto LABEL_79;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v39 = 0;
LABEL_79:
        *(_BYTE *)(a1 + 144) = v39 != 0;
        goto LABEL_92;
      case 0x11u:
        v44 = 0;
        v45 = 0;
        v29 = 0;
        *(_BYTE *)(a1 + 148) |= 0x10u;
        while (2)
        {
          v46 = *v3;
          v47 = *(_QWORD *)(a2 + v46);
          v48 = v47 + 1;
          if (v47 == -1 || v48 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v49 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v47);
            *(_QWORD *)(a2 + v46) = v48;
            v29 |= (unint64_t)(v49 & 0x7F) << v44;
            if (v49 < 0)
            {
              v44 += 7;
              v15 = v45++ >= 9;
              if (v15)
              {
                v29 = 0;
                goto LABEL_83;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v29 = 0;
LABEL_83:
        v50 = 40;
LABEL_84:
        *(_QWORD *)(a1 + v50) = v29;
        goto LABEL_92;
      case 0x12u:
        v18 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 120), v18);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v18, a2))
        {
LABEL_70:
          PBReaderRecallMark();
LABEL_71:

LABEL_92:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_94:

        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_92;
    }
  }
}

void sub_1B79A1E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,id location)
{
  id *v39;

  objc_destroyWeak(v39);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__60(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__60(uint64_t a1)
{

}

id HDSampleEntityOrderingTermsForRecentness()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  _QWORD v5[4];

  v5[3] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0D29888], "orderingTermWithProperty:entityClass:ascending:", CFSTR("start_date"), objc_opt_class(), 0);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29888], "orderingTermWithProperty:entityClass:ascending:", CFSTR("end_date"), objc_opt_class(), 0, v0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v5[1] = v1;
  objc_msgSend(MEMORY[0x1E0D29888], "orderingTermWithProperty:entityClass:ascending:", CFSTR("creation_date"), objc_opt_class(), 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v5[2] = v2;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v5, 3);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

id HDSampleEntityOrderingTermsForOldness()
{
  void *v0;
  void *v1;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0D29888], "orderingTermWithProperty:entityClass:ascending:", CFSTR("creation_date"), objc_opt_class(), 1);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v3[0] = v0;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v3, 1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  return v1;
}

void sub_1B79A5DD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  uint64_t v34;

  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 232), 8);
  _Block_object_dispose((const void *)(v34 - 184), 8);
  _Block_object_dispose((const void *)(v34 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1B79A5FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSampleEntityPredicateForDateInterval(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  _QWORD v16[3];

  v16[2] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = a1;
  objc_msgSend(v4, "endDate");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForStartDate(3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v4, "startDate");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  HDSampleEntityPredicateForEndDate(6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v16[0] = v6;
  v16[1] = v8;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v16, 2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "startDate");
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v3, "_earliestAllowedStartDateForSampleOverlappingDate:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  if (v11)
  {
    HDSampleEntityPredicateForStartDate(6);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "arrayByAddingObject:", v12);
    v13 = objc_claimAutoreleasedReturnValue();

    v9 = (void *)v13;
  }
  objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v9);
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  return v14;
}

void sub_1B79A91C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79A93B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79AA310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_1B79AAA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79AAFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v8 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1B79AB4AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 136), 8);
  _Unwind_Resume(a1);
}

void _HDSQLiteNewSourceUUIDWithBundleIdentifierAndProductType(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  void *v10;
  void *v11;
  uint8_t buf[24];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    if (sqlite3_value_type(*a3) != 5 && sqlite3_value_type(a3[1]) != 5)
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", sqlite3_value_text(*a3));
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", sqlite3_value_text(a3[1]));
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      if (qword_1ED552298 != -1)
        dispatch_once(&qword_1ED552298, &__block_literal_global_459);
      if (objc_msgSend((id)_MergedGlobals_203, "containsObject:", v6)
        && objc_msgSend(v5, "hasPrefix:", CFSTR("com.apple.health.")))
      {
        objc_msgSend(v5, "stringByReplacingOccurrencesOfString:withString:", CFSTR("com.apple.health."), &stru_1E6D11BB8);
        v7 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(v7, "length"))
        {
          v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDString:", v7);
        }
        else
        {
          _HKInitializeLogging();
          v9 = *MEMORY[0x1E0CB52B0];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v5;
            _os_log_error_impl(&dword_1B7802000, v9, OS_LOG_TYPE_ERROR, "Failed to generate UUID from bundle identifier %{public}@", buf, 0xCu);
          }
          v8 = 0;
        }

        if (v8)
          goto LABEL_12;
      }
      else
      {

      }
    }
    objc_msgSend(MEMORY[0x1E0CB3A28], "UUID");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_12:
    *(_OWORD *)buf = 0uLL;
    objc_msgSend(v8, "getUUIDBytes:", buf);
    sqlite3_result_blob(a1, buf, 16, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);

    return;
  }
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void _HDSQLiteNewSourceUUIDWithBundleIdentifierAndProductType(sqlite3_context *, int, sqlite3_value **)");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, CFSTR("HDDatabaseMigrator+Monarch.m"), 895, CFSTR("Invalid parameter not satisfying: %@"), CFSTR("argc == 2"));

  sqlite3_result_error(a1, "Improper number of arguments.", 1);
}

void sub_1B79ABAD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__61(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__61(uint64_t a1)
{

}

void sub_1B79AC07C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1B79AC6A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1B79ADA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getIMServiceImplClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  IMCoreLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("IMServiceImpl");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    _MergedGlobals_204 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getIMServiceImplClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDContributorManager.m"), 32, CFSTR("Unable to find class %s"), "IMServiceImpl");

    __break(1u);
  }
}

void *IMCoreLibrary()
{
  void *v0;
  void *v2;
  void *v3;

  if (!qword_1ED5522A8)
    qword_1ED5522A8 = _sl_dlopen();
  v0 = (void *)qword_1ED5522A8;
  if (!qword_1ED5522A8)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *IMCoreLibrary(void)");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("HDContributorManager.m"), 31, CFSTR("%s"), 0);

    __break(1u);
    free(v3);
  }
  return v0;
}

void *getIMPreferredAccountForServiceSymbolLoc()
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getIMPreferredAccountForServiceSymbolLoc_ptr;
  v6 = getIMPreferredAccountForServiceSymbolLoc_ptr;
  if (!getIMPreferredAccountForServiceSymbolLoc_ptr)
  {
    v1 = IMCoreLibrary();
    v0 = dlsym(v1, "IMPreferredAccountForService");
    v4[3] = (uint64_t)v0;
    getIMPreferredAccountForServiceSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1B79ADCE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__62(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__62(uint64_t a1)
{

}

void sub_1B79AF0F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableAuthorizationReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t result;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  char v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  HDCodableSyncIdentity *v53;
  uint64_t v54;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v18 = 0;
        v19 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 64) |= 0x20u;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          v23 = v22 + 1;
          if (v22 == -1 || v23 > *(_QWORD *)(a2 + *v4))
            break;
          v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v23;
          v20 |= (unint64_t)(v24 & 0x7F) << v18;
          if ((v24 & 0x80) == 0)
            goto LABEL_63;
          v18 += 7;
          v15 = v19++ >= 9;
          if (v15)
          {
            v20 = 0;
            goto LABEL_65;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_63:
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_65:
        v54 = 48;
        goto LABEL_82;
      case 2u:
        v26 = 0;
        v27 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 64) |= 4u;
        while (2)
        {
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          v30 = v29 + 1;
          if (v29 == -1 || v30 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v31 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v29);
            *(_QWORD *)(a2 + v28) = v30;
            v20 |= (unint64_t)(v31 & 0x7F) << v26;
            if (v31 < 0)
            {
              v26 += 7;
              v15 = v27++ >= 9;
              if (v15)
              {
                v20 = 0;
                goto LABEL_69;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_69:
        v54 = 24;
        goto LABEL_82;
      case 3u:
        v32 = 0;
        v33 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 64) |= 2u;
        while (2)
        {
          v34 = *v3;
          v35 = *(_QWORD *)(a2 + v34);
          v36 = v35 + 1;
          if (v35 == -1 || v36 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v37 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v35);
            *(_QWORD *)(a2 + v34) = v36;
            v20 |= (unint64_t)(v37 & 0x7F) << v32;
            if (v37 < 0)
            {
              v32 += 7;
              v15 = v33++ >= 9;
              if (v15)
              {
                v20 = 0;
                goto LABEL_73;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_73:
        v54 = 16;
        goto LABEL_82;
      case 4u:
        *(_BYTE *)(a1 + 64) |= 8u;
        v38 = *v3;
        v39 = *(_QWORD *)(a2 + v38);
        if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v40 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v39);
          *(_QWORD *)(a2 + v38) = v39 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v40 = 0;
        }
        *(_QWORD *)(a1 + 32) = v40;
        goto LABEL_83;
      case 5u:
        v41 = 0;
        v42 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 64) |= 0x10u;
        while (2)
        {
          v43 = *v3;
          v44 = *(_QWORD *)(a2 + v43);
          v45 = v44 + 1;
          if (v44 == -1 || v45 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v46 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v44);
            *(_QWORD *)(a2 + v43) = v45;
            v20 |= (unint64_t)(v46 & 0x7F) << v41;
            if (v46 < 0)
            {
              v41 += 7;
              v15 = v42++ >= 9;
              if (v15)
              {
                v20 = 0;
                goto LABEL_77;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_77:
        v54 = 40;
        goto LABEL_82;
      case 6u:
        v47 = 0;
        v48 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 64) |= 1u;
        while (2)
        {
          v49 = *v3;
          v50 = *(_QWORD *)(a2 + v49);
          v51 = v50 + 1;
          if (v50 == -1 || v51 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v52 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v50);
            *(_QWORD *)(a2 + v49) = v51;
            v20 |= (unint64_t)(v52 & 0x7F) << v47;
            if (v52 < 0)
            {
              v47 += 7;
              v15 = v48++ >= 9;
              if (v15)
              {
                v20 = 0;
                goto LABEL_81;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_81:
        v54 = 8;
LABEL_82:
        *(_QWORD *)(a1 + v54) = v20;
        goto LABEL_83;
      case 7u:
        v53 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 56), v53);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v53, a2))
        {
          PBReaderRecallMark();

LABEL_83:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_83;
    }
  }
}

uint64_t HDCodableFHIRResourceReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char v36;
  char v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char v42;
  char v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char v48;
  HDCodableMessageVersion *v49;
  uint64_t v50;
  unint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 2u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 80;
        goto LABEL_72;
      case 3u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 120;
        goto LABEL_72;
      case 4u:
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 104;
        goto LABEL_72;
      case 5u:
        *(_BYTE *)(a1 + 160) |= 0x20u;
        v20 = *v3;
        v21 = *(_QWORD *)(a2 + v20);
        if (v21 <= 0xFFFFFFFFFFFFFFF7 && v21 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v54 = 48;
        goto LABEL_94;
      case 6u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 128;
        goto LABEL_72;
      case 7u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 64;
        goto LABEL_72;
      case 9u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 112;
        goto LABEL_72;
      case 0xAu:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 136;
        goto LABEL_72;
      case 0xBu:
        v24 = 0;
        v25 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 160) |= 1u;
        while (2)
        {
          v27 = *v3;
          v28 = *(_QWORD *)(a2 + v27);
          v29 = v28 + 1;
          if (v28 == -1 || v29 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
            *(_QWORD *)(a2 + v27) = v29;
            v26 |= (unint64_t)(v30 & 0x7F) << v24;
            if (v30 < 0)
            {
              v24 += 7;
              v15 = v25++ >= 9;
              if (v15)
              {
                v26 = 0;
                goto LABEL_76;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_76:
        v53 = 8;
        goto LABEL_89;
      case 0xCu:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 56;
        goto LABEL_72;
      case 0xDu:
        v31 = 0;
        v32 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 160) |= 4u;
        while (2)
        {
          v33 = *v3;
          v34 = *(_QWORD *)(a2 + v33);
          v35 = v34 + 1;
          if (v34 == -1 || v35 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v36 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v34);
            *(_QWORD *)(a2 + v33) = v35;
            v26 |= (unint64_t)(v36 & 0x7F) << v31;
            if (v36 < 0)
            {
              v31 += 7;
              v15 = v32++ >= 9;
              if (v15)
              {
                v26 = 0;
                goto LABEL_80;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_80:
        v53 = 24;
        goto LABEL_89;
      case 0xEu:
        v37 = 0;
        v38 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 160) |= 8u;
        while (2)
        {
          v39 = *v3;
          v40 = *(_QWORD *)(a2 + v39);
          v41 = v40 + 1;
          if (v40 == -1 || v41 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v42 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v40);
            *(_QWORD *)(a2 + v39) = v41;
            v26 |= (unint64_t)(v42 & 0x7F) << v37;
            if (v42 < 0)
            {
              v37 += 7;
              v15 = v38++ >= 9;
              if (v15)
              {
                v26 = 0;
                goto LABEL_84;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_84:
        v53 = 32;
        goto LABEL_89;
      case 0xFu:
        v43 = 0;
        v44 = 0;
        v26 = 0;
        *(_BYTE *)(a1 + 160) |= 0x10u;
        while (2)
        {
          v45 = *v3;
          v46 = *(_QWORD *)(a2 + v45);
          v47 = v46 + 1;
          if (v46 == -1 || v47 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v48 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v46);
            *(_QWORD *)(a2 + v45) = v47;
            v26 |= (unint64_t)(v48 & 0x7F) << v43;
            if (v48 < 0)
            {
              v43 += 7;
              v15 = v44++ >= 9;
              if (v15)
              {
                v26 = 0;
                goto LABEL_88;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v26 = 0;
LABEL_88:
        v53 = 40;
LABEL_89:
        *(_QWORD *)(a1 + v53) = v26;
        goto LABEL_95;
      case 0x10u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 96;
        goto LABEL_72;
      case 0x11u:
        v49 = objc_alloc_init(HDCodableMessageVersion);
        objc_storeStrong((id *)(a1 + 88), v49);
        if (!PBReaderPlaceMark() || !HDCodableMessageVersionReadFrom((uint64_t)v49, a2))
          goto LABEL_97;
        goto LABEL_70;
      case 0x12u:
        *(_BYTE *)(a1 + 160) |= 2u;
        v50 = *v3;
        v51 = *(_QWORD *)(a2 + v50);
        if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v22 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v51);
          *(_QWORD *)(a2 + v50) = v51 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v22 = 0;
        }
        v54 = 16;
LABEL_94:
        *(_QWORD *)(a1 + v54) = v22;
        goto LABEL_95;
      case 0x13u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 72;
        goto LABEL_72;
      case 0x14u:
        v49 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 144), v49);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v49, a2))
        {
LABEL_70:
          PBReaderRecallMark();

LABEL_95:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_97:

        return 0;
      case 0x15u:
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 152;
LABEL_72:
        v52 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_95;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_95;
    }
  }
}

void sub_1B79BB030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__63(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__63(uint64_t a1)
{

}

void sub_1B79BB1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79BCBB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79C4018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__64(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__64(uint64_t a1)
{

}

id _HDRatingOfExertionSamplesForWorkoutPID(uint64_t a1, void *a2, uint64_t a3, void *a4, _QWORD *a5)
{
  void *v9;
  uint64_t v10;
  id v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  id v19;
  id v20;
  void *v21;
  id v23;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  v9 = (void *)MEMORY[0x1E0CB6A70];
  v10 = *MEMORY[0x1E0CB5C88];
  v11 = a4;
  v12 = a2;
  objc_msgSend(v9, "quantityTypeForIdentifier:", v10);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v24[0] = v13;
  objc_msgSend(MEMORY[0x1E0CB6A70], "quantityTypeForIdentifier:", *MEMORY[0x1E0CB5DD8]);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v24[1] = v14;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v24, 2);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  HDReferenceForAssociatableObject(v12);
  v16 = (void *)objc_claimAutoreleasedReturnValue();

  v23 = 0;
  +[HDAssociationEntity objectsAssociatedWithObjectPID:subObjectReference:dataTypes:associationType:limit:sortDescending:profile:error:](HDAssociationEntity, "objectsAssociatedWithObjectPID:subObjectReference:dataTypes:associationType:limit:sortDescending:profile:error:", a1, v16, v15, 1, a3, a3 == 1, v11, &v23);
  v17 = (void *)objc_claimAutoreleasedReturnValue();

  v18 = v23;
  if (v17)
  {
    v19 = v17;
  }
  else
  {
    v20 = v18;
    v21 = v20;
    if (v20)
    {
      if (a5)
        *a5 = objc_retainAutorelease(v20);
      else
        _HKLogDroppedError();
    }

  }
  return v17;
}

void sub_1B79C4FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__65(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__65(uint64_t a1)
{

}

void sub_1B79C5480(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Unwind_Resume(a1);
}

void sub_1B79C5E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableMenstrualCyclesExperienceModelReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  uint64_t v17;
  void *v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v19 = 0;
        v20 = 0;
        v21 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          if (v23 == -1 || v23 >= *(_QWORD *)(a2 + *v4))
            break;
          v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v23);
          *(_QWORD *)(a2 + v22) = v23 + 1;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0)
            goto LABEL_31;
          v19 += 7;
          v14 = v20++ >= 9;
          if (v14)
          {
            v21 = 0;
            goto LABEL_33;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5))
          v21 = 0;
LABEL_33:
        *(_QWORD *)(a1 + 8) = v21;
      }
      else if ((v10 >> 3) == 1)
      {
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v17;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B79C887C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__66(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__66(uint64_t a1)
{

}

void sub_1B79C8CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79C9CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__67(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__67(uint64_t a1)
{

}

id HDConceptIndexEntityPredicateForConceptIdentifier(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  _QWORD v12[4];
  id v13;

  v3 = a1;
  v4 = a2;
  if (objc_msgSend(v4, "count"))
  {
    v5 = (void *)MEMORY[0x1E0D29838];
    objc_msgSend(v3, "numberRepresentation");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "predicateWithProperty:equalToValue:", CFSTR("concept_identifier"), v6);
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __HDConceptIndexEntityPredicateForConceptIdentifier_block_invoke;
    v12[3] = &unk_1E6CE7E50;
    v13 = v7;
    v8 = v7;
    objc_msgSend(v4, "hk_map:", v12);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAnyPredicates:", v9);
    v10 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    objc_msgSend(MEMORY[0x1E0D29890], "falsePredicate");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v10;
}

id HDConceptIndexEntityPredicateForConceptIdentifiers(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v6 = v3;
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v17;
    do
    {
      v10 = 0;
      do
      {
        if (*(_QWORD *)v17 != v9)
          objc_enumerationMutation(v6);
        objc_msgSend(*(id *)(*((_QWORD *)&v16 + 1) + 8 * v10), "numberRepresentation", (_QWORD)v16);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "addObject:", v11);

        ++v10;
      }
      while (v8 != v10);
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
    }
    while (v8);
  }

  objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("concept_identifier"), v5);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("key_path"), v4);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29840], "compoundPredicateWithPredicate:otherPredicate:", v13, v12);
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  return v14;
}

void sub_1B79CB6B4(_Unwind_Exception *a1)
{
  id *v1;

  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1B79CBB0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B79CC3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;
  id *v17;
  uint64_t v18;

  objc_destroyWeak(v17);
  objc_destroyWeak((id *)(v18 - 72));
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B79CC82C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79CD970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void sub_1B79CDB00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B79CDBDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

void sub_1B79CDC40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)HDDatabase;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B79CE044(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79CE2B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79CE3E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79CE4E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79CE56C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79CE608(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79CE6E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79CE854(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__CFString *HDStringFromHDDatabaseType(uint64_t a1)
{
  __CFString *v1;

  if (a1 == 1)
    return CFSTR("Protected Database");
  if (a1)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown Database Type (%ld)"), a1);
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v1 = CFSTR("Unprotected Database");
  }
  return v1;
}

void sub_1B79CEBE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1B79CFD84(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  int v19;

  if (a2)
  {

    objc_begin_catch(a1);
    if (!v19)
      JUMPOUT(0x1B79CF940);
    JUMPOUT(0x1B79CF7F4);
  }
  _Unwind_Resume(a1);
}

void sub_1B79D01E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D0260(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79D03E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28)
{
  void *v28;
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

void sub_1B79D05D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B79D06A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D0790(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D0820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B79D0964(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__68(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__68(uint64_t a1)
{

}

void sub_1B79D0AA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D0CD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79D0EAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79D10A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

__CFString *HDStringFromDatabaseComponentIdentifier(unint64_t a1)
{
  if (a1 < 4)
    return off_1E6CF4440[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown database component (%ld)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

void sub_1B79D1664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1B79D1808(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D18B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79D1934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B79D19B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79D1A0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D1D10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79D2274(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  void *v12;
  void *v13;
  void *v14;

  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1B79D2060);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B79D2638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1B79D2960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

void sub_1B79D2B64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v4;

  _Unwind_Resume(a1);
}

id HDDatabaseIdentifierDefaultKeyForProfileIdentifier(void *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(a1, "identifier");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "UUIDString");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "stringWithFormat:", CFSTR("DatabaseIdentifier-%@"), v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_1B79D2C3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79D2CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1B79D2EFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D3764(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79D3E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;

  if (!v23)
  {

    v23 = 0;
  }

  _Unwind_Resume(a1);
}

void sub_1B79D407C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79D413C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B79D43EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79D45F0(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1B79D49A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79D4B6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79D4D14(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D4E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1B79D4F6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D5024(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D50C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D5748(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D590C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D5A8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B79D5D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  void *v32;
  void *v33;
  uint64_t v34;

  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);

  _Block_object_dispose((const void *)(v34 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1B79D5F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B79D61DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  void *v28;
  void *v29;
  void *v30;

  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a23, 8);

  _Unwind_Resume(a1);
}

void sub_1B79D6328(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D64B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D650C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D657C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B79D65E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B79D69F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1B79D6B58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D6C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1B79D6D4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1B79D6DF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D6EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{

  _Unwind_Resume(a1);
}

void sub_1B79D71C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  if (!v3)
  {

    v3 = 0;
  }

  _Unwind_Resume(a1);
}

void sub_1B79D73E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79D7618(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D7AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1B79D7C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1B79D7D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1B79D7E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1B79D7E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B79D80F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D86C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1B79D8944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

void sub_1B79D89E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D8A44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D8BC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79D8C88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id HDDatabaseUserDefaultsKeyForProfileIdentifier(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v3 = a1;
  v4 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(a2, "identifier");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "UUIDString");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "stringWithFormat:", CFSTR("%@-%@"), v3, v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

void sub_1B79D8F50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79DC3F8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t HDCodableCompanionUserNotificationResponseReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  unint64_t v17;
  uint64_t v18;
  void *v19;
  HDCodableError *v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        v20 = objc_alloc_init(HDCodableError);
        objc_storeStrong((id *)(a1 + 8), v20);
        if (!PBReaderPlaceMark() || (HDCodableErrorReadFrom((uint64_t)v20, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else if ((_DWORD)v17 == 2)
      {
        v21 = 0;
        v22 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 28) |= 1u;
        while (1)
        {
          v24 = *v3;
          v25 = *(_QWORD *)(a2 + v24);
          if (v25 == -1 || v25 >= *(_QWORD *)(a2 + *v4))
            break;
          v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v25);
          *(_QWORD *)(a2 + v24) = v25 + 1;
          v23 |= (unint64_t)(v26 & 0x7F) << v21;
          if ((v26 & 0x80) == 0)
            goto LABEL_35;
          v21 += 7;
          v14 = v22++ >= 9;
          if (v14)
          {
            v23 = 0;
            goto LABEL_37;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_35:
        if (*(_BYTE *)(a2 + *v5))
          v23 = 0;
LABEL_37:
        *(_BYTE *)(a1 + 24) = v23 != 0;
      }
      else if ((_DWORD)v17 == 1)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v18;

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B79DF848(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B79DF928(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79DFA38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1B79DFC2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B79DFCFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E02D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1B79E059C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E06FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  void *v20;
  void *v21;
  void *v22;

  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__69(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__69(uint64_t a1)
{

}

void sub_1B79E07CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E0920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1B79E09E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E0AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1B79E0E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;
  void *v34;
  uint64_t v35;

  *(_QWORD *)(v35 - 248) = v33;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v35 - 248));

  _Block_object_dispose(&a33, 8);
  *(_QWORD *)(v35 - 248) = a10;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v35 - 248));

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__195(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__196(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{

}

_QWORD *std::vector<_HDWrappedSource>::reserve(_QWORD *result, unint64_t a2)
{
  char **v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  int64x2_t v11;
  char *v12;
  uint64_t v13;
  int64x2_t v14;
  char *v15;
  _QWORD *v16;

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL)
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    v2 = (char **)result;
    v3 = result[1] - *result;
    v16 = result + 2;
    v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(a2);
    v7 = *v2;
    v6 = (unint64_t)v2[1];
    if ((char *)v6 == *v2)
    {
      v11 = vdupq_n_s64(v6);
      v8 = &v4[v3];
    }
    else
    {
      v8 = &v4[v3];
      do
      {
        v9 = *(_QWORD *)(v6 - 24);
        v6 -= 24;
        *(_QWORD *)v6 = 0;
        *((_QWORD *)v8 - 3) = v9;
        v8 -= 24;
        v10 = *(_QWORD *)(v6 + 8);
        v8[16] = *(_BYTE *)(v6 + 16);
        *((_QWORD *)v8 + 1) = v10;
      }
      while ((char *)v6 != v7);
      v11 = *(int64x2_t *)v2;
    }
    *v2 = v8;
    v2[1] = &v4[v3];
    v14 = v11;
    v12 = v2[2];
    v2[2] = &v4[24 * v5];
    v15 = v12;
    v13 = v11.i64[0];
    return (_QWORD *)std::__split_buffer<_HDWrappedSource>::~__split_buffer((uint64_t)&v13);
  }
  return result;
}

void sub_1B79E11FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E13E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B79E1660(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E18DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B79E1CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,id a55,id a56,id a57)
{
  uint64_t v57;

  _Block_object_dispose(&a42, 8);
  *(_QWORD *)(v57 - 248) = a12;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v57 - 248));

  _Unwind_Resume(a1);
}

void sub_1B79E1F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B79E2174(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79E2258(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B79E2D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, id *a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void **a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,char a38)
{
  uint64_t v38;

  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a25);
  a17 = (void **)&a35;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a17);
  a17 = (void **)&a38;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a17);
  a17 = (void **)(v38 - 224);
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a17);

  std::pair<_HDCachedSourceOrder * {__strong},HDConcreteSyncIdentity * {__strong}>::~pair(a13);
  _Unwind_Resume(a1);
}

void sub_1B79E3670(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id *std::pair<_HDCachedSourceOrder * {__strong},HDConcreteSyncIdentity * {__strong}>::~pair(id *a1)
{

  return a1;
}

void sub_1B79E37B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1B79E3898(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79E3A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  v17 = v15;

  a13 = (void **)&a10;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a13);

  _Unwind_Resume(a1);
}

void sub_1B79E426C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void **a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void **a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a71;
  uint64_t v71;
  void *v72;
  uint64_t v73;

  *(_QWORD *)(v73 - 256) = v71;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v73 - 256));
  _Block_object_dispose(&a71, 8);
  *(_QWORD *)(v73 - 256) = a10;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v73 - 256));

  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a32, 8);
  std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::~__hash_table(a12);
  _Block_object_dispose(&a43, 8);
  a32 = a14;
  std::vector<HKSource * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a32);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__212(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__213(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<HKSource * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{

}

uint64_t __Block_byref_object_copy__215(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = a2[6];
  a2[6] = 0;
  *(_QWORD *)(result + 48) = v2;
  *(_QWORD *)(result + 56) = a2[7];
  a2[7] = 0;
  v5 = a2[8];
  v3 = a2 + 8;
  v4 = v5;
  *(_QWORD *)(result + 64) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 64;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__216(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::~__hash_table(a1 + 48);
}

void sub_1B79E4610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1B79E4840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

uint64_t _HDDefaultSourceOrderCompare(HKSource *a1, HKSource *a2)
{
  HKSource *v3;
  HKSource *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;

  v3 = a1;
  v4 = a2;
  ___ZL28_HDDefaultSourceOrderCompareP8HKSourceS0__block_invoke(v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  ___ZL28_HDDefaultSourceOrderCompareP8HKSourceS0__block_invoke(v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v5, "compare:", v6);

  if (!v7)
  {
    if (-[HKSource _isAppleDevice](v3, "_isAppleDevice")
      && -[HKSource _isAppleDevice](v4, "_isAppleDevice"))
    {
      -[HKSource bundleIdentifier](v3, "bundleIdentifier");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      -[HKSource bundleIdentifier](v4, "bundleIdentifier");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = objc_msgSend(v8, "compare:", v9);

    }
    else
    {
      v7 = 0;
    }
  }

  return v7;
}

void sub_1B79E4948(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B79E4B34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79E4C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1B79E58A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void **a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  void *v50;
  void *v51;

  std::__split_buffer<_HDWrappedSource>::~__split_buffer((uint64_t)&a50);

  a42 = (void **)&a45;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a42);

  _Unwind_Resume(a1);
}

void sub_1B79E5ABC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E5BE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B79E5CE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E5DA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B79E5E04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 3);
        v4 -= 24;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<_HDWrappedSource>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;

  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

char *std::vector<_HDWrappedSource>::__init_with_size[abi:ne180100]<_HDWrappedSource*,_HDWrappedSource*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  char v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<_HDWrappedSource>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      result = (char *)*(id *)a2;
      *(_QWORD *)v7 = result;
      v8 = *(_BYTE *)(a2 + 16);
      *(_QWORD *)(v7 + 8) = *(_QWORD *)(a2 + 8);
      *(_BYTE *)(v7 + 16) = v8;
      v7 += 24;
      a2 += 24;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B79E5F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<_HDWrappedSource>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void std::vector<HKSource * {__strong}>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 1);
        v4 -= 8;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<_HDWrappedSource>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;
  void *v5;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = (void *)*((_QWORD *)v3 - 3);
        v3 -= 24;

      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,_HDWrappedSource *,_HDWrappedSource *,_HDWrappedSource *,0>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *v5;
      *v5 = 0;
      v7 = *(void **)a3;
      *(_QWORD *)a3 = v6;

      v8 = v5[1];
      *(_BYTE *)(a3 + 16) = *((_BYTE *)v5 + 16);
      *(_QWORD *)(a3 + 8) = v8;
      a3 += 24;
      v5 += 3;
    }
    while (v5 != a2);
  }
  return a3;
}

id *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<_HDWrappedSource *,_HDWrappedSource *,_HDWrappedSource *>(uint64_t a1, uint64_t a2, id *location)
{
  uint64_t v5;
  void *v6;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      objc_storeStrong(location, *(id *)v5);
      v6 = *(void **)(v5 + 8);
      *((_BYTE *)location + 16) = *(_BYTE *)(v5 + 16);
      location[1] = v6;
      location += 3;
      v5 += 24;
    }
    while (v5 != a2);
  }
  return location;
}

void sub_1B79E626C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::~__hash_table(uint64_t a1)
{
  id *v2;
  id *v3;
  void *v4;

  v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void *std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::__emplace_unique_key_args<HKSource * {__strong},std::piecewise_construct_t const&,std::tuple<HKSource * const {__strong}&>,std::tuple<>>(uint64_t *a1, id *a2, id **a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  void *i;
  unint64_t v14;
  id v15;
  id v16;
  id v17;
  void *v18;
  char v19;
  _QWORD *v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  int8x8_t prime;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint8x8_t v32;
  unint64_t v33;
  uint8x8_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  void *v42;
  id **v43;

  v7 = objc_msgSend(*a2, "hash");
  v8 = v7;
  v9 = a1[1];
  if (v9)
  {
    v43 = a3;
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = *(void **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v8)
        {
          v15 = *a2;
          v16 = *((id *)i + 2);
          v17 = v15;
          if (v16 == v17)
          {

            return i;
          }
          v18 = v17;
          if (v17)
          {
            v19 = objc_msgSend(v16, "isEqual:", v17);

            if ((v19 & 1) != 0)
              return i;
          }
          else
          {

          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
    a3 = v43;
  }
  v20 = a1 + 2;
  i = operator new(0x30uLL);
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v8;
  *((_QWORD *)i + 2) = **a3;
  *((_QWORD *)i + 3) = 0;
  *((_QWORD *)i + 4) = 0;
  *((_QWORD *)i + 5) = 0;
  v21 = (float)(unint64_t)(a1[3] + 1);
  v22 = *((float *)a1 + 8);
  if (!v9 || (float)(v22 * (float)v9) < v21)
  {
    v23 = 1;
    if (v9 >= 3)
      v23 = (v9 & (v9 - 1)) != 0;
    v24 = v23 | (2 * v9);
    v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25)
      prime = (int8x8_t)v25;
    else
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v9 = a1[1];
    if (*(_QWORD *)&prime > v9)
      goto LABEL_35;
    if (*(_QWORD *)&prime < v9)
    {
      v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (v34 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        v33 = std::__next_prime(v33);
      }
      else
      {
        v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2)
          v33 = v35;
      }
      if (*(_QWORD *)&prime <= v33)
        prime = (int8x8_t)v33;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_35:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v27 = operator new(8 * *(_QWORD *)&prime);
          v28 = (void *)*a1;
          *a1 = (uint64_t)v27;
          if (v28)
            operator delete(v28);
          v29 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v29++) = 0;
          while (*(_QWORD *)&prime != v29);
          v30 = (_QWORD *)*v20;
          if (*v20)
          {
            v31 = v30[1];
            v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(_QWORD *)&prime)
                v31 %= *(_QWORD *)&prime;
            }
            else
            {
              v31 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v31) = v20;
            v36 = (_QWORD *)*v30;
            if (*v30)
            {
              do
              {
                v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(_QWORD *)&prime)
                    v37 %= *(_QWORD *)&prime;
                }
                else
                {
                  v37 &= *(_QWORD *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v37))
                  {
                    *(_QWORD *)(*a1 + 8 * v37) = v30;
                    goto LABEL_60;
                  }
                  *v30 = *v36;
                  *v36 = **(_QWORD **)(*a1 + 8 * v37);
                  **(_QWORD **)(*a1 + 8 * v37) = v36;
                  v36 = v30;
                }
                v37 = v31;
LABEL_60:
                v30 = v36;
                v36 = (_QWORD *)*v36;
                v31 = v37;
              }
              while (v36);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_64;
        }
        v42 = (void *)*a1;
        *a1 = 0;
        if (v42)
          operator delete(v42);
        v9 = 0;
        a1[1] = 0;
      }
    }
LABEL_64:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v38 = *a1;
  v39 = *(_QWORD **)(*a1 + 8 * v3);
  if (v39)
  {
    *(_QWORD *)i = *v39;
LABEL_77:
    *v39 = i;
    goto LABEL_78;
  }
  *(_QWORD *)i = *v20;
  *v20 = i;
  *(_QWORD *)(v38 + 8 * v3) = v20;
  if (*(_QWORD *)i)
  {
    v40 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v40 >= v9)
        v40 %= v9;
    }
    else
    {
      v40 &= v9 - 1;
    }
    v39 = (_QWORD *)(*a1 + 8 * v40);
    goto LABEL_77;
  }
LABEL_78:
  ++a1[3];
  return i;
}

void sub_1B79E6744(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,void *>>>::operator()[abi:ne180100](char a1, id *a2)
{
  if (a1)
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

void sub_1B79E6B14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B79E6DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;

  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B79E80C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  _Block_object_dispose(&a49, 8);
  _Unwind_Resume(a1);
}

void sub_1B79EA6F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79EAAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79EB974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__70(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__70(uint64_t a1)
{

}

void sub_1B79EC1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79EC688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79EC9A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79ED36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79EE91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  char a67;
  char a71;

  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableTimestampedKeyValuePairReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  uint64_t v34;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v18 = objc_claimAutoreleasedReturnValue();
          v19 = 40;
          goto LABEL_37;
        case 2u:
          *(_BYTE *)(a1 + 56) |= 4u;
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v22);
            *(_QWORD *)(a2 + v21) = v22 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v23 = 0;
          }
          v34 = 24;
          goto LABEL_46;
        case 3u:
          v24 = 0;
          v25 = 0;
          v26 = 0;
          *(_BYTE *)(a1 + 56) |= 2u;
          break;
        case 4u:
          *(_BYTE *)(a1 + 56) |= 1u;
          v31 = *v3;
          v32 = *(_QWORD *)(a2 + v31);
          if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v23 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v32);
            *(_QWORD *)(a2 + v31) = v32 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v23 = 0;
          }
          v34 = 8;
LABEL_46:
          *(_QWORD *)(a1 + v34) = v23;
          continue;
        case 5u:
          PBReaderReadString();
          v18 = objc_claimAutoreleasedReturnValue();
          v19 = 48;
          goto LABEL_37;
        case 6u:
          PBReaderReadData();
          v18 = objc_claimAutoreleasedReturnValue();
          v19 = 32;
LABEL_37:
          v33 = *(void **)(a1 + v19);
          *(_QWORD *)(a1 + v19) = v18;

          continue;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v27 = *v3;
        v28 = *(_QWORD *)(a2 + v27);
        v29 = v28 + 1;
        if (v28 == -1 || v29 > *(_QWORD *)(a2 + *v4))
          break;
        v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
        *(_QWORD *)(a2 + v27) = v29;
        v26 |= (unint64_t)(v30 & 0x7F) << v24;
        if ((v30 & 0x80) == 0)
          goto LABEL_39;
        v24 += 7;
        v15 = v25++ >= 9;
        if (v15)
        {
          v26 = 0;
          goto LABEL_41;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_39:
      if (*(_BYTE *)(a2 + *v5))
        v26 = 0;
LABEL_41:
      *(_QWORD *)(a1 + 16) = v26;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B79F16C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__71(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__71(uint64_t a1)
{

}

void sub_1B79F1824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79F223C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

id getSOSUtilitiesClass_0()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getSOSUtilitiesClass_softClass;
  v7 = getSOSUtilitiesClass_softClass;
  if (!getSOSUtilitiesClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getSOSUtilitiesClass_block_invoke_0;
    v3[3] = &unk_1E6CECDD0;
    v3[4] = &v4;
    __getSOSUtilitiesClass_block_invoke_0((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1B79F2F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B79F2FF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getSOSUtilitiesClass_block_invoke_0(uint64_t a1)
{
  void *v2;
  void *v3;

  SOSLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("SOSUtilities");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSOSUtilitiesClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getSOSUtilitiesClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDMedicalIDDataManager+EmergencyContactConsolidation.m"), 25, CFSTR("Unable to find class %s"), "SOSUtilities");

    __break(1u);
  }
}

void SOSLibrary()
{
  void *v0;
  void *v1;
  void *v2;

  if (!SOSLibraryCore_frameworkLibrary)
    SOSLibraryCore_frameworkLibrary = _sl_dlopen();
  if (!SOSLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *SOSLibrary(void)");
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v1, CFSTR("HDMedicalIDDataManager+EmergencyContactConsolidation.m"), 24, CFSTR("%s"), 0);

    __break(1u);
    free(v2);
  }
}

void __getSOSContactsManagerClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  SOSLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("SOSContactsManager");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSOSContactsManagerClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getSOSContactsManagerClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDMedicalIDDataManager+EmergencyContactConsolidation.m"), 27, CFSTR("Unable to find class %s"), "SOSContactsManager");

    __break(1u);
  }
}

void sub_1B79F61E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__72(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__72(uint64_t a1)
{

}

void sub_1B79F6AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableMedicationDoseEventReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  __objc2_class **v7;
  int *v8;
  int *v9;
  char v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  BOOL v17;
  int v18;
  int *v20;
  __objc2_class **v21;
  id v22;
  uint64_t result;
  char v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = off_1E6CE3000;
    v8 = &OBJC_IVAR___HDMedicalIDDataManager__profile;
    v9 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      while (1)
      {
        v13 = *v3;
        v14 = *(_QWORD *)(a2 + v13);
        v15 = v14 + 1;
        if (v14 == -1 || v15 > *(_QWORD *)(a2 + *v4))
          break;
        v16 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v14);
        *(_QWORD *)(a2 + v13) = v15;
        v12 |= (unint64_t)(v16 & 0x7F) << v10;
        if ((v16 & 0x80) == 0)
          goto LABEL_12;
        v10 += 7;
        v17 = v11++ >= 9;
        if (v17)
        {
          v12 = 0;
          v18 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v18 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v12 = 0;
LABEL_14:
      if (v18 || (v12 & 7) == 4)
        break;
      switch((v12 >> 3))
      {
        case 1u:
          v20 = v8;
          v21 = v7;
          v22 = objc_alloc_init(v7[87]);
          objc_storeStrong((id *)(a1 + 64), v22);
          if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v22, a2) & 1) != 0)
          {
            PBReaderRecallMark();

            v7 = v21;
            v8 = v20;
            continue;
          }

          return 0;
        case 2u:
          v24 = 0;
          v25 = 0;
          v26 = 0;
          *(_BYTE *)(a1 + v8[828]) |= 2u;
          while (1)
          {
            v27 = *v3;
            v28 = *(_QWORD *)(a2 + v27);
            v29 = v28 + 1;
            if (v28 == -1 || v29 > *(_QWORD *)(a2 + *v4))
              break;
            v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v28);
            *(_QWORD *)(a2 + v27) = v29;
            v26 |= (unint64_t)(v30 & 0x7F) << v24;
            if ((v30 & 0x80) == 0)
              goto LABEL_52;
            v24 += 7;
            v17 = v25++ >= 9;
            if (v17)
            {
              v26 = 0;
              goto LABEL_54;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_52:
          if (*(_BYTE *)(a2 + *v5))
            v26 = 0;
LABEL_54:
          v47 = 16;
          goto LABEL_59;
        case 3u:
          PBReaderReadString();
          v31 = objc_claimAutoreleasedReturnValue();
          v32 = 72;
          goto LABEL_50;
        case 4u:
          PBReaderReadString();
          v31 = objc_claimAutoreleasedReturnValue();
          v32 = 48;
          goto LABEL_50;
        case 5u:
          *(_BYTE *)(a1 + v8[828]) |= 8u;
          v33 = *v3;
          v34 = *(_QWORD *)(a2 + v33);
          if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v34);
            *(_QWORD *)(a2 + v33) = v34 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v35 = 0;
          }
          v48 = 32;
          goto LABEL_66;
        case 6u:
          *(_BYTE *)(a1 + v8[828]) |= 1u;
          v36 = *v3;
          v37 = *(_QWORD *)(a2 + v36);
          if (v37 <= 0xFFFFFFFFFFFFFFF7 && v37 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v37);
            *(_QWORD *)(a2 + v36) = v37 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v35 = 0;
          }
          v48 = 8;
          goto LABEL_66;
        case 7u:
          *(_BYTE *)(a1 + v8[828]) |= 4u;
          v38 = *v3;
          v39 = *(_QWORD *)(a2 + v38);
          if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v35 = *(_QWORD *)(*(_QWORD *)(a2 + *v9) + v39);
            *(_QWORD *)(a2 + v38) = v39 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v35 = 0;
          }
          v48 = 24;
LABEL_66:
          *(_QWORD *)(a1 + v48) = v35;
          continue;
        case 8u:
          v40 = 0;
          v41 = 0;
          v26 = 0;
          *(_BYTE *)(a1 + v8[828]) |= 0x10u;
          break;
        case 9u:
          PBReaderReadData();
          v31 = objc_claimAutoreleasedReturnValue();
          v32 = 56;
LABEL_50:
          v46 = *(void **)(a1 + v32);
          *(_QWORD *)(a1 + v32) = v31;

          continue;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v42 = *v3;
        v43 = *(_QWORD *)(a2 + v42);
        v44 = v43 + 1;
        if (v43 == -1 || v44 > *(_QWORD *)(a2 + *v4))
          break;
        v45 = *(_BYTE *)(*(_QWORD *)(a2 + *v9) + v43);
        *(_QWORD *)(a2 + v42) = v44;
        v26 |= (unint64_t)(v45 & 0x7F) << v40;
        if ((v45 & 0x80) == 0)
          goto LABEL_56;
        v40 += 7;
        v17 = v41++ >= 9;
        if (v17)
        {
          v26 = 0;
          goto LABEL_58;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_56:
      if (*(_BYTE *)(a2 + *v5))
        v26 = 0;
LABEL_58:
      v47 = 40;
LABEL_59:
      *(_QWORD *)(a1 + v47) = v26;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableMedicalCodingListReadFrom(void *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableMedicalCoding *v17;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        v17 = objc_alloc_init(HDCodableMedicalCoding);
        objc_msgSend(a1, "addItems:", v17);
        if (!PBReaderPlaceMark() || !HDCodableMedicalCodingReadFrom((uint64_t)v17, a2))
        {

          return 0;
        }
        PBReaderRecallMark();

      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

BOOL HDCloudSyncCodableSharedSummaryRecordReadFrom(char *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 56;
          goto LABEL_31;
        case 2u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 40;
          goto LABEL_31;
        case 3u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 24;
          goto LABEL_31;
        case 4u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 64;
          goto LABEL_31;
        case 5u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
          goto LABEL_31;
        case 6u:
          PBReaderReadString();
          v19 = (void *)objc_claimAutoreleasedReturnValue();
          if (v19)
            objc_msgSend(a1, "addObjectTypeIdentifiers:", v19);
          goto LABEL_32;
        case 7u:
          PBReaderReadString();
          v19 = (void *)objc_claimAutoreleasedReturnValue();
          if (v19)
            objc_msgSend(a1, "addAuthorizationCategories:", v19);
          goto LABEL_32;
        case 8u:
          PBReaderReadData();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 48;
LABEL_31:
          v19 = *(void **)&a1[v18];
          *(_QWORD *)&a1[v18] = v17;
LABEL_32:

          goto LABEL_33;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0)
            return 0;
LABEL_33:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          break;
      }
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCodableListUserDomainConceptReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t v23;
  void *v24;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 2)
      {
        PBReaderReadString();
        v23 = objc_claimAutoreleasedReturnValue();
        v24 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v23;

      }
      else if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 24) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_31;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            v19 = 0;
            goto LABEL_33;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_31:
        if (*(_BYTE *)(a2 + *v5))
          v19 = 0;
LABEL_33:
        *(_QWORD *)(a1 + 8) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

BOOL HDCodableCompanionUserNotificationRequestReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  HDCodableCompanionUserNotificationConfiguration *v18;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = *(HDCodableCompanionUserNotificationConfiguration **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v17;
LABEL_24:

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_26:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v18 = objc_alloc_init(HDCodableCompanionUserNotificationConfiguration);
    objc_storeStrong((id *)(a1 + 8), v18);
    if (!PBReaderPlaceMark()
      || (HDCodableCompanionUserNotificationConfigurationReadFrom((uint64_t)v18, a2) & 1) == 0)
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_24;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

double combineNoiseLevelDatums(double a1, double a2, double a3, double a4)
{
  HDQuantitySampleOverlapProcessor *v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v8 = -[HDQuantitySampleOverlapProcessor initWithOverlapFunction:]([HDQuantitySampleOverlapProcessor alloc], "initWithOverlapFunction:", 1);
  v9 = __exp10(a1 / 10.0);
  v10 = __exp10(a3 / 10.0);
  v11 = 0.0;
  if (a2 + a4 > 0.0)
  {
    v12 = a2 * v9 + a4 * v10;
    if (v12 > 0.0)
      v11 = log10(v12 / (a2 + a4)) * 10.0;
  }

  return v11;
}

void sub_1B7A041D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::addSampleValue(HDStatisticsNoiseLevel *this, double a2, double a3, int a4)
{
  double v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;

  v8 = __exp10(a2 / 10.0) * a3;
  v9 = *((_QWORD *)this + 4);
  if (!v9)
  {
    *(double *)this = v8;
    *((double *)this + 1) = a3;
    v13 = 1;
    *((double *)this + 2) = a2;
    *((double *)this + 3) = a2;
    goto LABEL_9;
  }
  v11 = *((double *)this + 2);
  v10 = *((double *)this + 3);
  if (v10 >= a2)
    v10 = a2;
  if (v11 <= a2)
    v11 = a2;
  *((double *)this + 2) = v11;
  *((double *)this + 3) = v10;
  v12 = *((double *)this + 1) + a3;
  *(double *)this = v8 + *(double *)this;
  *((double *)this + 1) = v12;
  if (a4)
  {
    v13 = v9 + 1;
LABEL_9:
    *((_QWORD *)this + 4) = v13;
  }
}

long double HDStatisticsNoiseLevel::mean(HDStatisticsNoiseLevel *this)
{
  double v1;
  long double result;

  v1 = *((double *)this + 1);
  result = 0.0;
  if (v1 > 0.0 && *(double *)this > 0.0)
    return log10(*(double *)this / v1) * 10.0;
  return result;
}

uint64_t *HDStatisticsNoiseLevel::splitSampleAtTime@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  double v3;
  double v4;
  uint64_t v5;
  char v6;
  double v7;
  char v8;
  BOOL v9;
  char v10;
  double v11;
  uint64_t v12;

  v3 = *((double *)result + 1);
  v4 = *((double *)result + 2);
  v5 = result[3];
  v6 = *((_BYTE *)result + 32);
  v7 = 0.0;
  v8 = *((_BYTE *)result + 33);
  if (v6)
  {
    if (v3 > a3)
    {
      v9 = 0;
      v6 = v4 > v3;
      a3 = *((double *)result + 2);
      v10 = *((_BYTE *)result + 33);
      v7 = *(double *)result;
      v11 = *((double *)result + 1);
LABEL_9:
      v12 = result[3];
      goto LABEL_10;
    }
    if (v4 >= a3)
    {
      v9 = v3 < a3;
      v6 = v4 > a3;
      v10 = *((_BYTE *)result + 33);
      v7 = *(double *)result;
      v11 = a3;
      goto LABEL_9;
    }
    v10 = 0;
    v12 = 0;
    v6 = 0;
    v9 = v4 > v3;
    a3 = *((double *)result + 2);
    v11 = 0.0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v12 = 0;
    v11 = 0.0;
    a3 = *((double *)result + 2);
  }
  v4 = 0.0;
LABEL_10:
  *(_QWORD *)a2 = *result;
  *(double *)(a2 + 8) = v3;
  *(double *)(a2 + 16) = a3;
  *(_QWORD *)(a2 + 24) = v5;
  *(_BYTE *)(a2 + 32) = v9;
  *(_BYTE *)(a2 + 33) = v8;
  *(_DWORD *)(a2 + 34) = *(_DWORD *)((char *)result + 34);
  *(_WORD *)(a2 + 38) = *((_WORD *)result + 19);
  *(double *)(a2 + 40) = v7;
  *(double *)(a2 + 48) = v11;
  *(double *)(a2 + 56) = v4;
  *(_QWORD *)(a2 + 64) = v12;
  *(_BYTE *)(a2 + 72) = v6;
  *(_BYTE *)(a2 + 73) = v10;
  return result;
}

__int128 *HDStatisticsNoiseLevel::splitSampleAtTime(__int128 *result, uint64_t a2, double a3)
{
  double v3;
  __int16 v4;
  __int128 v5;
  double v6;
  __int128 v7;
  __int128 v8;

  if (!*((_BYTE *)result + 32))
    goto LABEL_6;
  v3 = *((double *)result + 1);
  if (v3 > a3)
  {
    v4 = *((_WORD *)result + 16);
    v5 = result[1];
    *(_OWORD *)a2 = *result;
    *(_OWORD *)(a2 + 16) = v5;
    *(_WORD *)(a2 + 32) = v4;
    *(_BYTE *)(a2 + 32) = *(double *)(a2 + 16) > *(double *)(a2 + 8);
    *((_BYTE *)result + 32) = 0;
    return result;
  }
  v6 = *((double *)result + 2);
  if (v6 < a3)
  {
    *((_BYTE *)result + 32) = v6 > v3;
LABEL_6:
    *(_BYTE *)(a2 + 32) = 0;
    return result;
  }
  v7 = *result;
  v8 = result[1];
  *(_WORD *)(a2 + 32) = *((_WORD *)result + 16);
  *(_OWORD *)a2 = v7;
  *(_OWORD *)(a2 + 16) = v8;
  *((double *)result + 2) = a3;
  *(double *)(a2 + 8) = a3;
  *((_BYTE *)result + 32) = *((double *)result + 1) < a3;
  *(_BYTE *)(a2 + 32) = *(double *)(a2 + 16) > a3;
  return result;
}

uint64_t HDStatisticsNoiseLevel::applyMaskToSample(uint64_t result, _QWORD *a2)
{
  double *v2;
  double v3;
  double v4;
  double *v5;
  double v6;
  double v7;
  double *v8;
  double v9;
  double *v10;
  double *v11;
  double v12;
  BOOL v13;
  double v14;
  double v15;

  v2 = (double *)a2[1];
  if (v2 != (double *)*a2)
  {
    v3 = *(double *)(result + 16);
    v4 = *(double *)(result + 8);
    if (v3 - v4 <= 0.0)
      goto LABEL_19;
    v5 = (double *)(*a2 + 8);
    v6 = 0.0;
    v7 = *(double *)(result + 8);
    do
    {
      v8 = v5 - 1;
      if (*v5 > v7)
      {
        v9 = *v8;
        if (*v8 >= v3)
          break;
        if (v9 > v7)
        {
          if (v3 < v9)
            v8 = (double *)(result + 16);
          v6 = v6 + *v8 - v7;
        }
        if (*v5 >= v3)
          v10 = (double *)(result + 16);
        else
          v10 = v5;
        v7 = *v10;
      }
      v11 = v5 + 1;
      v5 += 2;
    }
    while (v11 != v2);
    v12 = v3 - v7;
    v13 = v7 < v3;
    v14 = -0.0;
    if (v13)
      v14 = v12;
    v15 = v6 + v14;
    if (v15 <= 0.0)
LABEL_19:
      *(_BYTE *)(result + 32) = 0;
    else
      *(double *)(result + 16) = v4 + v15;
  }
  return result;
}

void HDStatisticsNoiseLevel::configure(id *this, HDStatisticsNoiseLevelConfiguration *a2)
{
  HDStatisticsNoiseLevelConfiguration *v3;
  int v4;
  char v5;
  char v6;
  HDStatisticsNoiseLevelConfiguration *v7;

  v3 = a2;
  if (v3)
  {
    v4 = *((unsigned __int8 *)this + 89);
    v7 = v3;
    v5 = -[HDStatisticsNoiseLevelConfiguration enableOverlapProcessing](v3, "enableOverlapProcessing");
    if (v4)
      v6 = v5;
    else
      v6 = 1;
    if ((v6 & 1) == 0)
    {
      HDStatisticsNoiseLevel::finalizeSamples((HDStatisticsNoiseLevel *)this);
      *((_BYTE *)this + 88) = 1;
      objc_msgSend(this[10], "resetAnchorTime:", 0.0);
    }
    *((_BYTE *)this + 89) = -[HDStatisticsNoiseLevelConfiguration enableOverlapProcessing](v7, "enableOverlapProcessing");
    v3 = v7;
  }

}

void sub_1B7A04550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::finalizeSamples(HDStatisticsNoiseLevel *this)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  HDQuantitySampleOverlapProcessor *v4;
  HDQuantitySampleOverlapProcessor *v5;
  _QWORD v6[5];
  _BYTE __dst[5152];
  _BYTE v8[5152];

  v1 = MEMORY[0x1E0C80A78](this);
  if (*(_BYTE *)(v1 + 89))
  {
    v2 = v1;
    memset(v8, 0, 512);
    v3 = *(void **)(v1 + 80);
    if (v3)
      objc_msgSend(v3, "exportCurrentState");
    else
      bzero(v8, 0x1420uLL);
    v4 = [HDQuantitySampleOverlapProcessor alloc];
    memcpy(__dst, v8, sizeof(__dst));
    v5 = -[HDQuantitySampleOverlapProcessor initWithState:](v4, "initWithState:", __dst);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = ___ZN22HDStatisticsNoiseLevel15finalizeSamplesEv_block_invoke;
    v6[3] = &__block_descriptor_40_e24_B32__0q8____dddBq_16__24l;
    v6[4] = v2;
    -[HDQuantitySampleOverlapProcessor fetchFinalOverlapSamplesWithErrorOut:handler:](v5, "fetchFinalOverlapSamplesWithErrorOut:handler:", 0, v6);

  }
}

void sub_1B7A04698(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::addSample(HDStatisticsNoiseLevel *this, const HDRawQuantitySample *a2, char a3)
{
  double var0;
  int64_t var3;
  void *v6;
  uint64_t v7;
  _QWORD v8[5];
  __int128 v9;
  double v10;
  char v11;
  _BYTE v12[7];
  int64_t v13;

  if (*((_BYTE *)this + 89))
  {
    memset(v12, 0, sizeof(v12));
    var0 = a2->var0;
    var3 = a2->var3;
    v6 = (void *)*((_QWORD *)this + 10);
    v9 = *(_OWORD *)&a2->var1;
    v10 = var0;
    v11 = a3;
    v13 = var3;
    v7 = *((unsigned __int8 *)this + 88);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZN22HDStatisticsNoiseLevel9addSampleERK19HDRawQuantitySampleb_block_invoke;
    v8[3] = &__block_descriptor_40_e24_B32__0q8____dddBq_16__24l;
    v8[4] = this;
    objc_msgSend(v6, "fetchOverlapProcessSamplesFrom:setAnchorTime:errorOut:handler:", &v9, v7, 0, v8);
    if (*((_BYTE *)this + 88))
      *((_BYTE *)this + 88) = 0;
  }
  else
  {
    HDStatisticsNoiseLevel::addSampleValue(this, a2->var0, a2->var2 - a2->var1, a3);
  }
}

uint64_t ___ZN22HDStatisticsNoiseLevel9addSampleERK19HDRawQuantitySampleb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HDStatisticsNoiseLevel::addProcessedOverlapSampleValues(*(HDStatisticsNoiseLevel **)(a1 + 32), a2, a3);
  return 1;
}

void HDStatisticsNoiseLevel::addProcessedOverlapSampleValues(HDStatisticsNoiseLevel *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  double v6;
  double v7;
  double v8;
  uint64_t v9;

  if (a2 >= 1)
  {
    v3 = a2;
    v5 = a3 + 16;
    do
    {
      v6 = *(double *)(v5 - 16);
      v7 = *(double *)(v5 - 8);
      v8 = *(double *)v5;
      v9 = *(_QWORD *)(v5 + 16);
      HDStatisticsNoiseLevel::addSampleValue(this, *(double *)v5, v7 - v6, *(_BYTE *)(v5 + 8) & 1);
      if (v3 == 1 && (!*((_BYTE *)this + 72) || *((double *)this + 6) <= v6))
      {
        *((double *)this + 5) = v8;
        *((double *)this + 6) = v6;
        *((double *)this + 7) = v7;
        *((_QWORD *)this + 8) = v9;
        *((_WORD *)this + 36) = 1;
      }
      v5 += 40;
      --v3;
    }
    while (v3);
  }
}

uint64_t ___ZN22HDStatisticsNoiseLevel15finalizeSamplesEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  HDStatisticsNoiseLevel::addProcessedOverlapSampleValues(*(HDStatisticsNoiseLevel **)(a1 + 32), a2, a3);
  return 1;
}

__n128 HDStatisticsNoiseLevel::updateMostRecentSample(HDStatisticsNoiseLevel *this, const HDRawQuantitySample *a2)
{
  __n128 result;
  __int128 v3;

  if (!*((_BYTE *)this + 72) || (result.n128_u64[0] = *((_QWORD *)this + 6), result.n128_f64[0] <= a2->var1))
  {
    result = *(__n128 *)&a2->var0;
    v3 = *(_OWORD *)&a2->var2;
    *((_WORD *)this + 36) = *(_WORD *)&a2->var4;
    *(__n128 *)((char *)this + 40) = result;
    *(_OWORD *)((char *)this + 56) = v3;
  }
  return result;
}

void HDStatisticsNoiseLevel::unarchive(HDStatisticsNoiseLevel *this, const statistics::Statistics *a2)
{
  uint64_t v2;
  _OWORD *v3;
  _OWORD *v4;
  HDQuantitySampleOverlapProcessor *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  HDStatisticsNoiseLevel *v11;
  HDQuantitySampleOverlapProcessor *v12;
  _BYTE v13[5152];
  _OWORD v14[322];

  v2 = MEMORY[0x1E0C80A78](this);
  v4 = v3;
  *(_OWORD *)((char *)v3 + 58) = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  v5 = -[HDQuantitySampleOverlapProcessor initWithOverlapFunction:]([HDQuantitySampleOverlapProcessor alloc], "initWithOverlapFunction:", 1);
  *((_QWORD *)v4 + 10) = v5;
  *((_BYTE *)v4 + 89) = 1;
  *((_QWORD *)v4 + 4) = *(_QWORD *)(v2 + 24);
  v6 = *(_QWORD *)(v2 + 88);
  *v4 = vextq_s8(*(int8x16_t *)(v2 + 184), *(int8x16_t *)(v2 + 184), 8uLL);
  v7 = *(_QWORD *)(v2 + 104);
  *((_QWORD *)v4 + 2) = v6;
  *((_QWORD *)v4 + 3) = v7;
  *((_BYTE *)v4 + 88) = *(_BYTE *)(v2 + 201);
  v8 = *(_QWORD *)(v2 + 112);
  if (v8)
  {
    v9 = *(_QWORD *)(v8 + 8);
    v10 = *(_QWORD *)(v8 + 16);
    *(int8x16_t *)((char *)v4 + 40) = vextq_s8(*(int8x16_t *)(v8 + 24), *(int8x16_t *)(v8 + 24), 8uLL);
    *((_QWORD *)v4 + 7) = v9;
    *((_QWORD *)v4 + 8) = v10;
    *((_WORD *)v4 + 36) = 1;
  }
  *((_BYTE *)v4 + 89) = *(_BYTE *)(v2 + 200);
  v11 = *(HDStatisticsNoiseLevel **)(v2 + 120);
  if (v11)
  {
    memset(v14, 0, 512);
    HDStatisticsNoiseLevel::unarchiveOverlapProcessor(v11, v14);
    v12 = [HDQuantitySampleOverlapProcessor alloc];
    memcpy(v13, v14, sizeof(v13));
    *((_QWORD *)v4 + 10) = -[HDQuantitySampleOverlapProcessor initWithState:](v12, "initWithState:", v13);

  }
}

void sub_1B7A04A2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::unarchiveOverlapProcessor(HDStatisticsNoiseLevel *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  char v9;
  uint64_t v10;
  _BYTE v11[24];
  uint64_t v12;
  uint64_t v13;
  char v14;

  bzero(a2 + 3, 0x1408uLL);
  *a2 = *((_QWORD *)this + 1);
  v5 = *((_QWORD *)this + 3);
  a2[1] = *((_QWORD *)this + 2);
  a2[2] = v5;
  *((_BYTE *)a2 + 24) = (*((_BYTE *)this + 56) != 0) & (*((_BYTE *)this + 60) >> 3);
  if (v5 >= 1)
  {
    v6 = 0;
    if (v5 >= 128)
      v7 = 128;
    else
      v7 = v5;
    v8 = a2 + 8;
    do
    {
      statistics::QuantitySampleAttenuationEngineSample::QuantitySampleAttenuationEngineSample((uint64_t)v11, *(const statistics::QuantitySampleAttenuationEngineSample **)(*((_QWORD *)this + 4) + 8 * v6));
      v9 = v14;
      v10 = v12;
      *(v8 - 4) = v13;
      *(_OWORD *)(v8 - 3) = *(_OWORD *)&v11[8];
      *((_BYTE *)v8 - 8) = v9;
      *v8 = v10;
      v8 += 5;
      PB::Base::~Base((PB::Base *)v11);
      ++v6;
    }
    while (v7 != v6);
  }
}

void HDStatisticsNoiseLevel::archive(HDStatisticsNoiseLevel *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  _QWORD v7[3];
  int8x16_t v8;
  __int16 v9;
  char v10;
  int v11;
  void **v12;

  v4 = *((_QWORD *)this + 3);
  *(_QWORD *)(a2 + 88) = *((_QWORD *)this + 2);
  *(int8x16_t *)(a2 + 184) = vextq_s8(*(int8x16_t *)this, *(int8x16_t *)this, 8uLL);
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  *(_QWORD *)a2 = &off_1E6CEA528;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  v5 = *((_QWORD *)this + 4);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = v5;
  *(_QWORD *)(a2 + 104) = v4;
  LOBYTE(v5) = *((_BYTE *)this + 88);
  *(_DWORD *)(a2 + 204) = 90273;
  *(_BYTE *)(a2 + 201) = v5;
  statistics::Statistics::makeMostRecentDatum((_QWORD *)a2);
  v7[0] = &off_1E6CFF278;
  v11 = 127;
  v8 = vextq_s8(*(int8x16_t *)((char *)this + 40), *(int8x16_t *)((char *)this + 40), 8uLL);
  v7[1] = *((_QWORD *)this + 7);
  v7[2] = *((_QWORD *)this + 8);
  v9 = 0;
  v10 = 0;
  statistics::RawQuantitySample::operator=(*(_QWORD *)(a2 + 112), (uint64_t)v7);
  PB::Base::~Base((PB::Base *)v7);
  v6 = *((_BYTE *)this + 89);
  *(_DWORD *)(a2 + 204) |= 0x8000u;
  *(_BYTE *)(a2 + 200) = v6;
  statistics::Statistics::makeOverlapProcessorState((_QWORD *)a2);
  HDStatisticsNoiseLevel::archiveOverlapProcessor(this);
  statistics::QuantityOverlapProcessorState::operator=(*(_QWORD *)(a2 + 120), (uint64_t)v7);
  v7[0] = off_1E6D037C8;
  v12 = (void **)&v8.i64[1];
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v12);
  PB::Base::~Base((PB::Base *)v7);
}

void sub_1B7A04C40(_Unwind_Exception *a1)
{
  statistics::Statistics *v1;

  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::archiveOverlapProcessor(HDStatisticsNoiseLevel *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  int64x2_t *v9;
  uint64_t v10;
  char *v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  int64x2_t v28;
  char *v29;
  void (**v30)(statistics::QuantitySampleAttenuationEngineSample *__hidden);
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  int v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  int64x2_t v69;
  char *v70;
  uint64_t v71;

  v1 = MEMORY[0x1E0C80A78](this);
  v3 = v2;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v4 = *(void **)(v1 + 80);
  if (v4)
  {
    objc_msgSend(v4, "exportCurrentState");
    v6 = *((_QWORD *)&v36 + 1);
    v7 = v36;
    v5 = v37;
    v8 = BYTE8(v37);
  }
  else
  {
    bzero(&v36, 0x1420uLL);
    v8 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
  }
  *(_QWORD *)v3 = off_1E6D037C8;
  *(_QWORD *)(v3 + 32) = 0;
  v9 = (int64x2_t *)(v3 + 32);
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 60) = 15;
  *(_QWORD *)(v3 + 8) = v7;
  *(_QWORD *)(v3 + 16) = v6;
  *(_QWORD *)(v3 + 24) = v5;
  *(_BYTE *)(v3 + 56) = v8;
  if (v5 >= 1)
  {
    v10 = 0;
    do
    {
      v30 = &off_1E6D0D048;
      v35 = 31;
      v11 = (char *)&v36 + 40 * v10;
      v12 = v11[56];
      v13 = *((_QWORD *)v11 + 8);
      v33 = *((_QWORD *)v11 + 4);
      v31 = *(_OWORD *)(v11 + 40);
      v34 = v12 & 1;
      v32 = v13;
      v14 = operator new();
      statistics::QuantitySampleAttenuationEngineSample::QuantitySampleAttenuationEngineSample(v14, (const statistics::QuantitySampleAttenuationEngineSample *)&v30);
      v16 = *(uint64_t **)(v3 + 40);
      v15 = *(_QWORD *)(v3 + 48);
      if ((unint64_t)v16 >= v15)
      {
        v18 = ((uint64_t)v16 - v9->i64[0]) >> 3;
        if ((unint64_t)(v18 + 1) >> 61)
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        v19 = v15 - v9->i64[0];
        v20 = v19 >> 2;
        if (v19 >> 2 <= (unint64_t)(v18 + 1))
          v20 = v18 + 1;
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
          v21 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v21 = v20;
        v71 = v3 + 48;
        if (v21)
          v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(v3 + 48, v21);
        else
          v22 = 0;
        v23 = (uint64_t *)&v22[8 * v18];
        v24 = &v22[8 * v21];
        v70 = v24;
        *v23 = v14;
        v17 = v23 + 1;
        v69.i64[1] = (uint64_t)(v23 + 1);
        v26 = *(_QWORD **)(v3 + 32);
        v25 = *(_QWORD **)(v3 + 40);
        if (v25 == v26)
        {
          v28 = vdupq_n_s64((unint64_t)v25);
        }
        else
        {
          do
          {
            v27 = *--v25;
            *v25 = 0;
            *--v23 = v27;
          }
          while (v25 != v26);
          v28 = *v9;
          v17 = (_QWORD *)v69.i64[1];
          v24 = v70;
        }
        *(_QWORD *)(v3 + 32) = v23;
        *(_QWORD *)(v3 + 40) = v17;
        v69 = v28;
        v29 = *(char **)(v3 + 48);
        *(_QWORD *)(v3 + 48) = v24;
        v70 = v29;
        v68 = v28.i64[0];
        std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((uint64_t)&v68);
      }
      else
      {
        *v16 = v14;
        v17 = v16 + 1;
      }
      *(_QWORD *)(v3 + 40) = v17;
      PB::Base::~Base((PB::Base *)&v30);
      ++v10;
    }
    while (v10 < (uint64_t)v37);
  }
}

void sub_1B7A04ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  statistics::QuantityOverlapProcessorState *v9;
  uint64_t v10;

  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  PB::Base::~Base((PB::Base *)&a9);
  statistics::QuantityOverlapProcessorState::~QuantityOverlapProcessorState(v9);
  _Unwind_Resume(a1);
}

void sub_1B7A06680(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A06B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A08704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__73(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__73(uint64_t a1)
{

}

void sub_1B7A08F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  uint64_t v41;

  _Block_object_dispose(&a41, 8);
  _Block_object_dispose((const void *)(v41 - 256), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A0A2BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v32;

  _Block_object_dispose(&a32, 8);
  _Block_object_dispose((const void *)(v32 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A0AC38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A0ADF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A0B040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A0B49C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDDataEntityPredicateForSyncProvenance(uint64_t a1, char a2)
{
  void *v3;
  void *v4;
  void *v5;

  v3 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if ((a2 & 1) != 0)
    objc_msgSend(v3, "predicateWithProperty:equalToValue:", CFSTR("data_provenances.sync_provenance"), v4);
  else
    objc_msgSend(v3, "predicateWithProperty:notEqualToValue:", CFSTR("data_provenances.sync_provenance"), v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

id HDDataEntityPredicateForDataUUIDs(void *a1)
{
  id v1;
  id v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v12;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v12 != v6)
          objc_enumerationMutation(v3);
        _HDSQLiteValueForUUID();
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v2, "addObject:", v8, v11);

        ++v7;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v5);
  }

  objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("uuid"), v2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

uint64_t HDDataEntityPredicateForObjectsAfterAnchor(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:greaterThanValue:", CFSTR("data_id"), a1);
}

uint64_t HDDataEntityPredicateForRowIDs(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("data_id"), a1);
}

id HDDataEntityPredicateForObjectsFromAppleWatchSources(int a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v1 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("((%@ & %lld) != %d)"), CFSTR("data_provenances.derived_flags"), 1, a1 ^ 1u, 0);
  v2 = (void *)MEMORY[0x1E0D298B0];
  v6[0] = CFSTR("data_provenances.derived_flags");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v6, 1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithSQL:overProperties:values:", v1, v3, MEMORY[0x1E0C9AA60]);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDDataEntityPredicateForSourceRevisionsSet(uint64_t a1, void *a2, int a3)
{
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t j;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  void (**v24)(void *, void *, const __CFString *, void *);
  uint64_t i;
  void *v26;
  uint64_t v27;
  void *v28;
  __CFString *v29;
  __CFString *v30;
  uint64_t v31;
  void *v32;
  __CFString *v33;
  __CFString *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  char v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  id v47;
  id v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  id obj;
  id obja;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  _QWORD aBlock[5];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  _BYTE v65[128];
  _QWORD v66[2];
  _BYTE v67[128];
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v7 = v6;
  if ((unint64_t)(a1 - 1) >= 2)
  {
    if (a1 != 7)
    {
      v23 = 0;
      goto LABEL_45;
    }
    a1 = 1;
  }
  v47 = v5;
  if (!a3)
  {
    v49 = v6;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __HDDataEntityPredicateForSourceRevisionsSet_block_invoke;
    aBlock[3] = &__block_descriptor_40_e40_v32__0__NSMutableArray_8__NSString_16_24l;
    aBlock[4] = a1;
    v24 = (void (**)(void *, void *, const __CFString *, void *))_Block_copy(aBlock);
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    v59 = 0u;
    v48 = v5;
    v55 = objc_msgSend(v48, "countByEnumeratingWithState:objects:count:", &v56, v65, 16);
    if (!v55)
      goto LABEL_42;
    obja = *(id *)v57;
    v51 = *MEMORY[0x1E0CB5F50];
    v50 = *MEMORY[0x1E0CB5F48];
    while (1)
    {
      for (i = 0; i != v55; ++i)
      {
        if (*(id *)v57 != obja)
          objc_enumerationMutation(v48);
        v26 = *(void **)(*((_QWORD *)&v56 + 1) + 8 * i);
        objc_msgSend(v26, "version", v47);
        v27 = objc_claimAutoreleasedReturnValue();
        v28 = (void *)v27;
        v29 = &stru_1E6D11BB8;
        if (v27)
          v29 = (__CFString *)v27;
        v30 = v29;

        objc_msgSend(v26, "productType");
        v31 = objc_claimAutoreleasedReturnValue();
        v32 = (void *)v31;
        v33 = CFSTR("UnknownDevice");
        if (v31)
          v33 = (__CFString *)v31;
        v34 = v33;

        if (v26)
          objc_msgSend(v26, "operatingSystemVersion");
        objc_msgSend(MEMORY[0x1E0C99DE8], "array");
        v35 = (void *)objc_claimAutoreleasedReturnValue();
        v36 = (void *)MEMORY[0x1E0CB37E8];
        objc_msgSend(v26, "sourceEntity");
        v37 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v36, "numberWithLongLong:", objc_msgSend(v37, "persistentID"));
        v38 = (void *)objc_claimAutoreleasedReturnValue();
        v24[2](v24, v35, CFSTR("data_provenances.source_id"), v38);

        if ((-[__CFString isEqualToString:](v30, "isEqualToString:", v51) & 1) == 0)
          v24[2](v24, v35, CFSTR("data_provenances.source_version"), v30);
        objc_msgSend(v26, "productType");
        v39 = (void *)objc_claimAutoreleasedReturnValue();
        v40 = objc_msgSend(v39, "isEqualToString:", v50);

        if ((v40 & 1) == 0)
          v24[2](v24, v35, CFSTR("data_provenances.origin_product_type"), v34);
        if ((HKNSOperatingSystemVersionsEqual() & 1) == 0)
        {
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", 0);
          v41 = (void *)objc_claimAutoreleasedReturnValue();
          v24[2](v24, v35, CFSTR("data_provenances.origin_major_version"), v41);

          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", 0);
          v42 = (void *)objc_claimAutoreleasedReturnValue();
          v24[2](v24, v35, CFSTR("data_provenances.origin_minor_version"), v42);

          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", 0);
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          v24[2](v24, v35, CFSTR("data_provenances.origin_patch_version"), v43);

        }
        if (a1 != 7)
        {
          if (a1 == 2)
          {
            objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAnyPredicates:", v35);
            v44 = objc_claimAutoreleasedReturnValue();
            goto LABEL_39;
          }
          if (a1 != 1)
            goto LABEL_40;
        }
        objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v35);
        v44 = objc_claimAutoreleasedReturnValue();
LABEL_39:
        v45 = (void *)v44;
        objc_msgSend(v49, "addObject:", v44);

LABEL_40:
      }
      v55 = objc_msgSend(v48, "countByEnumeratingWithState:objects:count:", &v56, v65, 16);
      if (!v55)
      {
LABEL_42:

        v7 = v49;
        objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAnyPredicates:", v49);
        v23 = (void *)objc_claimAutoreleasedReturnValue();

        goto LABEL_43;
      }
    }
  }
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  obj = v5;
  v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v61, v67, 16);
  if (v8)
  {
    v9 = v8;
    v54 = *(_QWORD *)v62;
    do
    {
      for (j = 0; j != v9; ++j)
      {
        if (*(_QWORD *)v62 != v54)
          objc_enumerationMutation(obj);
        v11 = *(void **)(*((_QWORD *)&v61 + 1) + 8 * j);
        v12 = (void *)MEMORY[0x1E0D29838];
        v13 = (void *)MEMORY[0x1E0CB37E8];
        objc_msgSend(v11, "sourceEntity", v47);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "numberWithLongLong:", objc_msgSend(v14, "persistentID"));
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v12, "predicateWithProperty:value:comparisonType:", CFSTR("data_provenances.source_id"), v15, a1);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        v66[0] = v16;
        v17 = (void *)MEMORY[0x1E0D29838];
        objc_msgSend(v11, "version");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v17, "predicateWithProperty:value:comparisonType:", CFSTR("data_provenances.source_version"), v18, a1);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        v66[1] = v19;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v66, 2);
        v20 = (void *)objc_claimAutoreleasedReturnValue();

        if (a1 == 7 || a1 == 1)
        {
          objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v20);
          v21 = objc_claimAutoreleasedReturnValue();
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAnyPredicates:", v20);
          v21 = objc_claimAutoreleasedReturnValue();
        }
        v22 = (void *)v21;
        objc_msgSend(v7, "addObject:", v21);

      }
      v9 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v61, v67, 16);
    }
    while (v9);
  }

  objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAnyPredicates:", v7);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_43:
  v5 = v47;
LABEL_45:

  return v23;
}

id HDDataEntityPredicateForOriginBuildInRange(void *a1, void *a2)
{
  unint64_t v3;
  unint64_t v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v20;
  void *v21;
  unint64_t v22;
  const __CFString *v23;
  unint64_t v24;
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3 | v4)
  {
    v5 = (void *)objc_opt_new();
    objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:notEqualToValue:", CFSTR("data_provenances.origin_build"), CFSTR("UnknownBuild"));
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "addObject:", v6);

    v7 = (_QWORD *)MEMORY[0x1E0D29790];
    if (v3)
    {
      v8 = (void *)MEMORY[0x1E0D298B0];
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@(%@, ?) >= 0"), *MEMORY[0x1E0D29790], CFSTR("data_provenances.origin_build"));
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v25[0] = CFSTR("data_provenances.origin_build");
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v25, 1);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v24 = v3;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v24, 1);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "predicateWithSQL:overProperties:values:", v9, v10, v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "addObject:", v12);

      v7 = (_QWORD *)MEMORY[0x1E0D29790];
    }
    if (v4)
    {
      v13 = (void *)MEMORY[0x1E0D298B0];
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@(%@, ?) < 0"), *v7, CFSTR("data_provenances.origin_build"));
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      v23 = CFSTR("data_provenances.origin_build");
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v23, 1);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      v22 = v4;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v22, 1);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "predicateWithSQL:overProperties:values:", v14, v15, v16);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "addObject:", v17);

    }
    objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v5);
    v18 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "HDSQLitePredicate * _Nonnull HDDataEntityPredicateForOriginBuildInRange(NSString * _Nullable __strong, NSString * _Nullable __strong)");
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", v21, CFSTR("HDDataEntity.m"), 2312, CFSTR("Must specify at least one of minBuild and maxBuild."));

    v18 = 0;
  }

  return v18;
}

__CFString *HDDataEntityPredicateForOriginBuild(uint64_t a1, void *a2)
{
  id v3;
  __CFString *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = 0;
  switch(a1)
  {
    case 0:
    case 7:
    case 8:
      goto LABEL_9;
    case 1:
      v4 = CFSTR("== 0");
      goto LABEL_8;
    case 2:
      v4 = CFSTR("!= 0");
      goto LABEL_8;
    case 3:
      v4 = CFSTR("< 0");
      goto LABEL_8;
    case 4:
      v4 = CFSTR("<= 0");
      goto LABEL_8;
    case 5:
      v4 = CFSTR("> 0");
      goto LABEL_8;
    case 6:
      v4 = CFSTR(">= 0");
      goto LABEL_8;
    default:
LABEL_8:
      v5 = (void *)MEMORY[0x1E0D298B0];
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@(%@, ?) %@"), *MEMORY[0x1E0D29790], CFSTR("data_provenances.origin_build"), v4);
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v11[0] = CFSTR("data_provenances.origin_build");
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v11, 1);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = v3;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v10, 1);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "predicateWithSQL:overProperties:values:", v6, v7, v8);
      v4 = (__CFString *)objc_claimAutoreleasedReturnValue();

LABEL_9:
      return v4;
  }
}

id HDDataEntityPredicateForDeviceIdentifierSet(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;

  v3 = a2;
  if (a1 != 7)
  {
    if (a1 == 2)
    {
      objc_msgSend(MEMORY[0x1E0D29848], "doesNotContainPredicateWithProperty:values:", CFSTR("data_provenances.device_id"), v3);
      v4 = objc_claimAutoreleasedReturnValue();
      goto LABEL_6;
    }
    if (a1 != 1)
    {
      v5 = 0;
      goto LABEL_8;
    }
  }
  objc_msgSend(MEMORY[0x1E0D29848], "containsPredicateWithProperty:values:", CFSTR("data_provenances.device_id"), v3);
  v4 = objc_claimAutoreleasedReturnValue();
LABEL_6:
  v5 = (void *)v4;
LABEL_8:

  return v5;
}

id HDDataEntityPredicateForCreationDate(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  _HDSQLiteValueForDate();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("creation_date"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

uint64_t HDDataEntityPredicateForContributorIdentifier(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("data_provenances.contributor_id"), a1);
}

BOOL HDCodableTinkerOptInRequestReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 16;
LABEL_22:
        v19 = *(void **)(a1 + v18);
        *(_QWORD *)(a1 + v18) = v17;

        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_24:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    PBReaderReadString();
    v17 = objc_claimAutoreleasedReturnValue();
    v18 = 8;
    goto LABEL_22;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7A0FBDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7A112C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  uint64_t v34;

  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 216), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__74(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__74(uint64_t a1)
{

}

BOOL HDCodableStateSyncCollectionReadFrom(void *a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableObjectCollection *v17;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
      {
        v17 = objc_alloc_init(HDCodableObjectCollection);
        objc_msgSend(a1, "addDeletedSampleCollections:", v17);
      }
      else
      {
        if ((v10 >> 3) != 1)
        {
          if ((PBReaderSkipValueWithTag() & 1) == 0)
            return 0;
          continue;
        }
        v17 = objc_alloc_init(HDCodableObjectCollection);
        objc_msgSend(a1, "addSampleCollections:", v17);
      }
      if (!PBReaderPlaceMark() || !HDCodableObjectCollectionReadFrom((uint64_t)v17, a2))
      {

        return 0;
      }
      PBReaderRecallMark();

    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7A13A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;

  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__75(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__75(uint64_t a1)
{

}

uint64_t HDCodableCompanionUserNotificationConfigurationReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v14 = v9++ >= 9;
        if (v14)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 12) |= 1u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_29;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_31;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_29:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_31:
        *(_DWORD *)(a1 + 8) = v19;
      }
      else
      {
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
      }
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7A19290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__76(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__76(uint64_t a1)
{

}

uint64_t HDCodableSummarySharingEntryReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  HDCodableSharingSetupMetadata *v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char v27;
  char v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  void *v47;
  char v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char v53;
  uint64_t result;
  char v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char v60;
  uint64_t v61;
  uint64_t v62;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 144;
        goto LABEL_63;
      case 2u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 104;
        goto LABEL_63;
      case 3u:
        PBReaderReadString();
        v20 = (HDCodableSharingSetupMetadata *)objc_claimAutoreleasedReturnValue();
        if (v20)
          objc_msgSend((id)a1, "addAllContactIdentifiers:", v20);
        goto LABEL_76;
      case 4u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 64;
        goto LABEL_63;
      case 5u:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 80;
        goto LABEL_63;
      case 6u:
        v21 = 0;
        v22 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 152) |= 0x40u;
        while (2)
        {
          v24 = *v3;
          v25 = *(_QWORD *)(a2 + v24);
          v26 = v25 + 1;
          if (v25 == -1 || v26 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v27 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v25);
            *(_QWORD *)(a2 + v24) = v26;
            v23 |= (unint64_t)(v27 & 0x7F) << v21;
            if (v27 < 0)
            {
              v21 += 7;
              v15 = v22++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_87;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v23) = 0;
LABEL_87:
        v61 = 132;
        goto LABEL_104;
      case 7u:
        v28 = 0;
        v29 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 152) |= 8u;
        while (2)
        {
          v30 = *v3;
          v31 = *(_QWORD *)(a2 + v30);
          v32 = v31 + 1;
          if (v31 == -1 || v32 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v33 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v31);
            *(_QWORD *)(a2 + v30) = v32;
            v23 |= (unint64_t)(v33 & 0x7F) << v28;
            if (v33 < 0)
            {
              v28 += 7;
              v15 = v29++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_91;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v23) = 0;
LABEL_91:
        v61 = 56;
        goto LABEL_104;
      case 8u:
        v34 = 0;
        v35 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 152) |= 0x20u;
        while (2)
        {
          v36 = *v3;
          v37 = *(_QWORD *)(a2 + v36);
          v38 = v37 + 1;
          if (v37 == -1 || v38 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v39 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v37);
            *(_QWORD *)(a2 + v36) = v38;
            v23 |= (unint64_t)(v39 & 0x7F) << v34;
            if (v39 < 0)
            {
              v34 += 7;
              v15 = v35++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_95;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v23) = 0;
LABEL_95:
        v61 = 128;
        goto LABEL_104;
      case 9u:
        v20 = objc_alloc_init(HDCodableSharingSetupMetadata);
        objc_storeStrong((id *)(a1 + 120), v20);
        if (!PBReaderPlaceMark() || !HDCodableSharingSetupMetadataReadFrom((char *)v20, a2))
          goto LABEL_114;
        goto LABEL_75;
      case 0xAu:
        *(_BYTE *)(a1 + 152) |= 4u;
        v40 = *v3;
        v41 = *(_QWORD *)(a2 + v40);
        if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v42 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v41);
          *(_QWORD *)(a2 + v40) = v41 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v42 = 0;
        }
        v62 = 24;
        goto LABEL_111;
      case 0xBu:
        PBReaderReadString();
        v20 = (HDCodableSharingSetupMetadata *)objc_claimAutoreleasedReturnValue();
        if (v20)
          objc_msgSend((id)a1, "addAuthorizationCategories:", v20);
        goto LABEL_76;
      case 0xCu:
        *(_BYTE *)(a1 + 152) |= 1u;
        v43 = *v3;
        v44 = *(_QWORD *)(a2 + v43);
        if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v42 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v44);
          *(_QWORD *)(a2 + v43) = v44 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v42 = 0;
        }
        v62 = 8;
        goto LABEL_111;
      case 0xDu:
        *(_BYTE *)(a1 + 152) |= 2u;
        v45 = *v3;
        v46 = *(_QWORD *)(a2 + v45);
        if (v46 <= 0xFFFFFFFFFFFFFFF7 && v46 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v42 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v46);
          *(_QWORD *)(a2 + v45) = v46 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v42 = 0;
        }
        v62 = 16;
LABEL_111:
        *(_QWORD *)(a1 + v62) = v42;
        goto LABEL_112;
      case 0xEu:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 72;
        goto LABEL_63;
      case 0xFu:
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 48;
        goto LABEL_63;
      case 0x10u:
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 96;
LABEL_63:
        v47 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_112;
      case 0x11u:
        v48 = 0;
        v49 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 152) |= 0x10u;
        while (2)
        {
          v50 = *v3;
          v51 = *(_QWORD *)(a2 + v50);
          v52 = v51 + 1;
          if (v51 == -1 || v52 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v53 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v51);
            *(_QWORD *)(a2 + v50) = v52;
            v23 |= (unint64_t)(v53 & 0x7F) << v48;
            if (v53 < 0)
            {
              v48 += 7;
              v15 = v49++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_99;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v23) = 0;
LABEL_99:
        v61 = 88;
        goto LABEL_104;
      case 0x28u:
        v20 = objc_alloc_init(HDCodableSharingAuthorization);
        objc_msgSend((id)a1, "addSharingAuthorizations:", v20);
        if (PBReaderPlaceMark() && HDCodableSharingAuthorizationReadFrom((uint64_t)v20, a2))
        {
LABEL_75:
          PBReaderRecallMark();
LABEL_76:

LABEL_112:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_114:

        return 0;
      case 0x29u:
        v55 = 0;
        v56 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 152) |= 0x80u;
        while (2)
        {
          v57 = *v3;
          v58 = *(_QWORD *)(a2 + v57);
          v59 = v58 + 1;
          if (v58 == -1 || v59 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v60 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v58);
            *(_QWORD *)(a2 + v57) = v59;
            v23 |= (unint64_t)(v60 & 0x7F) << v55;
            if (v60 < 0)
            {
              v55 += 7;
              v15 = v56++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_103;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v23) = 0;
LABEL_103:
        v61 = 136;
LABEL_104:
        *(_DWORD *)(a1 + v61) = v23;
        goto LABEL_112;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_112;
    }
  }
}

uint64_t HDCodableWorkoutEventReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  uint64_t result;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  HDCodableMetadataDictionary *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v18 = 0;
        v19 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 48) |= 8u;
        while (1)
        {
          v21 = *v3;
          v22 = *(_QWORD *)(a2 + v21);
          v23 = v22 + 1;
          if (v22 == -1 || v23 > *(_QWORD *)(a2 + *v4))
            break;
          v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
          *(_QWORD *)(a2 + v21) = v23;
          v20 |= (unint64_t)(v24 & 0x7F) << v18;
          if ((v24 & 0x80) == 0)
            goto LABEL_45;
          v18 += 7;
          v15 = v19++ >= 9;
          if (v15)
          {
            v20 = 0;
            goto LABEL_47;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_45:
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_47:
        v38 = 32;
        goto LABEL_52;
      case 2u:
        *(_BYTE *)(a1 + 48) |= 1u;
        v26 = *v3;
        v27 = *(_QWORD *)(a2 + v26);
        if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v27);
          *(_QWORD *)(a2 + v26) = v27 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v39 = 8;
        goto LABEL_57;
      case 3u:
        v29 = 0;
        v30 = 0;
        v20 = 0;
        *(_BYTE *)(a1 + 48) |= 4u;
        while (2)
        {
          v31 = *v3;
          v32 = *(_QWORD *)(a2 + v31);
          v33 = v32 + 1;
          if (v32 == -1 || v33 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v34 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v32);
            *(_QWORD *)(a2 + v31) = v33;
            v20 |= (unint64_t)(v34 & 0x7F) << v29;
            if (v34 < 0)
            {
              v29 += 7;
              v15 = v30++ >= 9;
              if (v15)
              {
                v20 = 0;
                goto LABEL_51;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v20 = 0;
LABEL_51:
        v38 = 24;
LABEL_52:
        *(_QWORD *)(a1 + v38) = v20;
        goto LABEL_58;
      case 4u:
        v35 = objc_alloc_init(HDCodableMetadataDictionary);
        objc_storeStrong((id *)(a1 + 40), v35);
        if (PBReaderPlaceMark() && (HDCodableMetadataDictionaryReadFrom(v35, a2) & 1) != 0)
        {
          PBReaderRecallMark();

LABEL_58:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      case 5u:
        *(_BYTE *)(a1 + 48) |= 2u;
        v36 = *v3;
        v37 = *(_QWORD *)(a2 + v36);
        if (v37 <= 0xFFFFFFFFFFFFFFF7 && v37 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v28 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v37);
          *(_QWORD *)(a2 + v36) = v37 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v28 = 0;
        }
        v39 = 16;
LABEL_57:
        *(_QWORD *)(a1 + v39) = v28;
        goto LABEL_58;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_58;
    }
  }
}

id HDSummarySharingEntryPredicateForTypeStatusAndDirection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  _QWORD v17[4];

  v17[3] = *MEMORY[0x1E0C80C00];
  v5 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "predicateWithProperty:equalToValue:", CFSTR("type"), v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "predicateWithProperty:equalToValue:", CFSTR("status"), v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  v11 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a3);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "predicateWithProperty:equalToValue:", CFSTR("direction"), v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  v17[0] = v7;
  v17[1] = v10;
  v17[2] = v13;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v17, 3);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

id HDSummarySharingEntryPredicateForTypeAndStatus(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  _QWORD v12[3];

  v12[2] = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "predicateWithProperty:equalToValue:", CFSTR("type"), v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "predicateWithProperty:equalToValue:", CFSTR("status"), v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v12[0] = v5;
  v12[1] = v8;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v12, 2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  return v10;
}

id HDSummarySharingEntryPredicateForIdentifierTypeAndDirection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  _QWORD v15[4];

  v15[3] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("primary_contact_identifier"), a1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "predicateWithProperty:equalToValue:", CFSTR("type"), v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a3);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "predicateWithProperty:equalToValue:", CFSTR("direction"), v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  v15[0] = v5;
  v15[1] = v8;
  v15[2] = v11;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v15, 3);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  return v13;
}

uint64_t HDSummarySharingEntryPredicateForUUID(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("uuid"), a1);
}

uint64_t HDSummarySharingEntryPredicateForInvitationUUID(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("invitation_uuid"), a1);
}

id HDSummarySharingEntryPredicateForCloudKitIdentifierTypeStatusAndDirection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  _QWORD v20[5];

  v20[4] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("cloudkit_identifier"), a1);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "predicateWithProperty:equalToValue:", CFSTR("type"), v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  v11 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a3);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "predicateWithProperty:equalToValue:", CFSTR("status"), v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  v14 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a4);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v14, "predicateWithProperty:equalToValue:", CFSTR("direction"), v15);
  v16 = (void *)objc_claimAutoreleasedReturnValue();

  v20[0] = v7;
  v20[1] = v10;
  v20[2] = v13;
  v20[3] = v16;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v20, 4);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();

  return v18;
}

id HDUserDomainConceptEducationContentEntityPredicateForEducationContent(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)MEMORY[0x1E0D29838];
  +[HDSQLiteSchemaEntity disambiguatedSQLForProperty:](HDUserDomainConceptEducationContentEntity, "disambiguatedSQLForProperty:", CFSTR("deleted"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:equalToValue:", v3, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

void sub_1B7A23AA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A2498C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__77(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__77(uint64_t a1)
{

}

void sub_1B7A24C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A25320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A261E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v37;

  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A26AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  uint64_t v37;

  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 224), 8);
  _Block_object_dispose((const void *)(v37 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A27634(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A27D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__78(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__78(uint64_t a1)
{

}

void sub_1B7A28430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A2ABF8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_1B7A2AF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A2B25C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__79(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__79(uint64_t a1)
{

}

void sub_1B7A2B84C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B7A2C210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  uint64_t v36;

  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose((const void *)(v36 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A2C468(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__80(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__80(uint64_t a1)
{

}

void sub_1B7A2E0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__81(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__81(uint64_t a1)
{

}

void sub_1B7A3077C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A30BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A36CC0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  void *v37;
  uint64_t v38;
  id v41;
  NSObject *v42;

  _Block_object_dispose(&a37, 8);
  if (a2 == 1)
  {
    v41 = objc_begin_catch(a1);
    _HKInitializeLogging();
    v42 = *MEMORY[0x1E0CB52C8];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52C8], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)(v38 - 256) = 138412290;
      *(_QWORD *)(v38 - 252) = v41;
      _os_log_error_impl(&dword_1B7802000, v42, OS_LOG_TYPE_ERROR, "Exception creating demo workout: %@", (uint8_t *)(v38 - 256), 0xCu);
    }

    objc_end_catch();
    JUMPOUT(0x1B7A36A18);
  }
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__82(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__82(uint64_t a1)
{

}

id HDNotificationInstructionPredicateForIsValid(int a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a1 ^ 1u);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:equalToValue:", CFSTR("is_invalid"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1B7A3F118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A3F51C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B7A415A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  _Block_object_dispose((const void *)(v29 - 176), 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__83(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__83(uint64_t a1)
{

}

void sub_1B7A419F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A429BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7A43920(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A43B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A43F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A441B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A45AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A45EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

id HDOnboardingCompletionEntityAllProperties()
{
  void *v0;
  void *v1;
  void *v2;
  _QWORD v4[3];
  _QWORD v5[8];

  v5[7] = *MEMORY[0x1E0C80C00];
  v5[0] = CFSTR("uuid");
  v5[1] = CFSTR("feature_identifier");
  v5[2] = CFSTR("version");
  v5[3] = CFSTR("completion_date");
  v5[4] = CFSTR("country_code");
  v5[5] = CFSTR("country_code_provenance");
  v5[6] = CFSTR("mod_date");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v5, 7);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = CFSTR("deleted");
  v4[1] = CFSTR("sync_provenance");
  v4[2] = CFSTR("sync_identity");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v4, 3);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "arrayByAddingObjectsFromArray:", v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

id _OnboardingCompletionFromRow(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;

  if ((HDSQLiteColumnWithNameAsBoolean() & 1) != 0)
  {
    v3 = 0;
  }
  else
  {
    HDSQLiteColumnWithNameAsUUID();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    HDSQLiteColumnWithNameAsString();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = HDSQLiteColumnWithNameAsInt64();
    HDSQLiteColumnWithNameAsDate();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    HDSQLiteColumnWithNameAsString();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = HDSQLiteColumnWithNameAsInt64();
    if (v4 && v5 && v7)
    {
      v3 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB6990]), "initWithFeatureIdentifier:version:completionDate:countryCode:countryCodeProvenance:UUID:", v5, v6, v7, v8, v9, v4);
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB35C8], "hk_assignError:code:format:", a2, 100, CFSTR("Unexpectedly found missing values: UUID(%@) featureIdentifier(%@) completionDate(%@)"), v4, v5, v7);
      v3 = 0;
    }

  }
  return v3;
}

void sub_1B7A48090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__84(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__84(uint64_t a1)
{

}

void sub_1B7A484F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A49CE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A4A28C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__85(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__85(uint64_t a1)
{

}

id HDWorkoutEntityOrderingTermsForCondenserDate()
{
  void *v0;
  void *v1;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0D29888], "orderingTermWithProperty:entityClass:ascending:", CFSTR("condenser_date"), objc_opt_class(), 1);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v3[0] = v0;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v3, 1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  return v1;
}

void sub_1B7A4AD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A4AF40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_1B7A4C0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

id HDWorkoutEntityPredicateForDuration(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateWithProperty:value:comparisonType:", CFSTR("activities.duration"), v3, a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id HDWorkoutEntityPredicateForTotalDistance(uint64_t a1, void *a2)
{
  void *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  double v8;
  double v9;
  void *v10;
  void *v11;

  v3 = (void *)MEMORY[0x1E0D29838];
  v4 = a2;
  +[HDDataEntity disambiguatedSQLForProperty:](HDWorkoutEntity, "disambiguatedSQLForProperty:", CFSTR("total_distance"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = (void *)MEMORY[0x1E0CB37E8];
  _HKWorkoutCanonicalDistanceUnit();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "doubleValueForUnit:", v7);
  v9 = v8;

  objc_msgSend(v6, "numberWithDouble:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "predicateWithProperty:value:comparisonType:", v5, v10, a1);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

id HDWorkoutEntityPredicateForTotalEnergyBurned(uint64_t a1, void *a2)
{
  void *v3;
  uint64_t v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  double v10;
  double v11;
  void *v12;
  void *v13;

  v3 = (void *)MEMORY[0x1E0CB6A70];
  v4 = *MEMORY[0x1E0CB5A48];
  v5 = a2;
  objc_msgSend(v3, "quantityTypeForIdentifier:", v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "canonicalUnit");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (void *)MEMORY[0x1E0D29838];
  v9 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend(v5, "doubleValueForUnit:", v7);
  v11 = v10;

  objc_msgSend(v9, "numberWithDouble:", v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "predicateWithProperty:value:comparisonType:", CFSTR("active_energy.quantity"), v12, a1);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  return v13;
}

id HDWorkoutEntityPredicateForTotalSwimmingStrokeCount(uint64_t a1, void *a2)
{
  void *v3;
  uint64_t v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  double v10;
  double v11;
  void *v12;
  void *v13;

  v3 = (void *)MEMORY[0x1E0CB6A70];
  v4 = *MEMORY[0x1E0CB5D80];
  v5 = a2;
  objc_msgSend(v3, "quantityTypeForIdentifier:", v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "canonicalUnit");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (void *)MEMORY[0x1E0D29838];
  v9 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend(v5, "doubleValueForUnit:", v7);
  v11 = v10;

  objc_msgSend(v9, "numberWithDouble:", v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "predicateWithProperty:value:comparisonType:", CFSTR("swimming_strokes.quantity"), v12, a1);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  return v13;
}

id HDWorkoutEntityPredicateForTotalFlightsClimbed(uint64_t a1, void *a2)
{
  void *v3;
  uint64_t v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  double v10;
  double v11;
  void *v12;
  void *v13;

  v3 = (void *)MEMORY[0x1E0CB6A70];
  v4 = *MEMORY[0x1E0CB5C90];
  v5 = a2;
  objc_msgSend(v3, "quantityTypeForIdentifier:", v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "canonicalUnit");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (void *)MEMORY[0x1E0D29838];
  v9 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend(v5, "doubleValueForUnit:", v7);
  v11 = v10;

  objc_msgSend(v9, "numberWithDouble:", v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "predicateWithProperty:value:comparisonType:", CFSTR("flights_climbed.quantity"), v12, a1);
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  return v13;
}

id HDWorkoutEntityPredicateForWorkoutGoalType(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v4 = (void *)MEMORY[0x1E0D29838];
  +[HDDataEntity disambiguatedSQLForProperty:](HDWorkoutEntity, "disambiguatedSQLForProperty:", CFSTR("goal_type"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "predicateWithProperty:value:comparisonType:", v5, v6, a1);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

id HDWorkoutEntityPredicateForWorkoutGoal(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v5 = a3;
  if (v5)
  {
    v6 = (void *)MEMORY[0x1E0CB37E8];
    _HKWorkoutCanonicalUnitForGoalType();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "doubleValueForUnit:", v7);
    objc_msgSend(v6, "numberWithDouble:");
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    v9 = (void *)MEMORY[0x1E0D29838];
    +[HDDataEntity disambiguatedSQLForProperty:](HDWorkoutEntity, "disambiguatedSQLForProperty:", CFSTR("goal"));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "predicateWithProperty:value:comparisonType:", v10, v8, a1);
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    HDWorkoutEntityPredicateForWorkoutGoalType(1, a2);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v13 = (void *)MEMORY[0x1E0D29880];
    +[HDDataEntity disambiguatedSQLForProperty:](HDWorkoutEntity, "disambiguatedSQLForProperty:", CFSTR("goal"));
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    if (a1 == 1)
      objc_msgSend(v13, "isNullPredicateWithProperty:", v14);
    else
      objc_msgSend(v13, "isNotNullPredicateWithProperty:", v14);
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    v12 = 0;
    v8 = 0;
  }
  objc_msgSend(MEMORY[0x1E0D29890], "compoundPredicateWithPredicate:otherPredicate:", v11, v12);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

id HDWorkoutEntityPredicateForWorkoutCondenserVersionLessThan(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  _QWORD v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  v2 = (void *)MEMORY[0x1E0D29840];
  objc_msgSend(MEMORY[0x1E0D29880], "isNullPredicateWithProperty:", CFSTR("condenser_version"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v10[0] = v3;
  v4 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "predicateWithProperty:lessThanValue:", CFSTR("condenser_version"), v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v10[1] = v6;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v10, 2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "predicateMatchingAnyPredicates:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  return v8;
}

id HDWorkoutEntityPredicateForWorkoutCondenserVersionEqualTo(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:equalToValue:", CFSTR("condenser_version"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

BOOL HDCodableWorkoutSessionSyncTransactionReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  HDCodableWorkoutSessionConfiguration *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      if (v9++ >= 9)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 32;
        goto LABEL_29;
      case 2u:
        v19 = objc_alloc_init(HDCodableWorkoutSessionConfiguration);
        objc_storeStrong((id *)(a1 + 16), v19);
        if (!PBReaderPlaceMark() || !HDCodableWorkoutSessionConfigurationReadFrom((uint64_t)v19, a2))
          goto LABEL_34;
        goto LABEL_27;
      case 3u:
        v19 = objc_alloc_init(HDCodableWorkoutSessionGlobalState);
        objc_storeStrong((id *)(a1 + 24), v19);
        if (PBReaderPlaceMark()
          && (HDCodableWorkoutSessionGlobalStateReadFrom((uint64_t)v19, a2) & 1) != 0)
        {
LABEL_27:
          PBReaderRecallMark();
LABEL_30:

LABEL_31:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_34:

        return 0;
      case 4u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 8;
LABEL_29:
        v19 = *(HDCodableWorkoutSessionConfiguration **)(a1 + v18);
        *(_QWORD *)(a1 + v18) = v17;
        goto LABEL_30;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0)
          return 0;
        goto LABEL_31;
    }
  }
}

void sub_1B7A4E59C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id a25)
{
  objc_destroyWeak(location);
  objc_destroyWeak(&a25);
  _Unwind_Resume(a1);
}

void sub_1B7A5106C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t HDCodableTypedObjectAssociationReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  HDCodableSyncIdentity *v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  void *v39;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      v13 = v12 + 1;
      if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
        break;
      v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v15 = v9++ >= 9;
      if (v15)
      {
        v10 = 0;
        v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v16 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 24;
        goto LABEL_44;
      case 2u:
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 32;
        goto LABEL_44;
      case 3u:
        v21 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 48), v21);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v21, a2))
        {
          PBReaderRecallMark();

LABEL_55:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      case 4u:
        v22 = 0;
        v23 = 0;
        v24 = 0;
        *(_BYTE *)(a1 + 60) |= 2u;
        while (2)
        {
          v25 = *v3;
          v26 = *(_QWORD *)(a2 + v25);
          v27 = v26 + 1;
          if (v26 == -1 || v27 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v26);
            *(_QWORD *)(a2 + v25) = v27;
            v24 |= (unint64_t)(v28 & 0x7F) << v22;
            if (v28 < 0)
            {
              v22 += 7;
              v15 = v23++ >= 9;
              if (v15)
              {
                v24 = 0;
                goto LABEL_48;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v24 = 0;
LABEL_48:
        *(_QWORD *)(a1 + 16) = v24;
        goto LABEL_55;
      case 5u:
        v29 = 0;
        v30 = 0;
        v31 = 0;
        *(_BYTE *)(a1 + 60) |= 4u;
        while (2)
        {
          v32 = *v3;
          v33 = *(_QWORD *)(a2 + v32);
          v34 = v33 + 1;
          if (v33 == -1 || v34 > *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v35 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v33);
            *(_QWORD *)(a2 + v32) = v34;
            v31 |= (unint64_t)(v35 & 0x7F) << v29;
            if (v35 < 0)
            {
              v29 += 7;
              v15 = v30++ >= 9;
              if (v15)
              {
                v31 = 0;
                goto LABEL_52;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v31 = 0;
LABEL_52:
        *(_BYTE *)(a1 + 56) = v31 != 0;
        goto LABEL_55;
      case 6u:
        *(_BYTE *)(a1 + 60) |= 1u;
        v36 = *v3;
        v37 = *(_QWORD *)(a2 + v36);
        if (v37 <= 0xFFFFFFFFFFFFFFF7 && v37 + 8 <= *(_QWORD *)(a2 + *v4))
        {
          v38 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v37);
          *(_QWORD *)(a2 + v36) = v37 + 8;
        }
        else
        {
          *(_BYTE *)(a2 + *v5) = 1;
          v38 = 0;
        }
        *(_QWORD *)(a1 + 8) = v38;
        goto LABEL_55;
      case 7u:
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 40;
LABEL_44:
        v39 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_55;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_55;
    }
  }
}

BOOL HDCodableBinarySampleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  HDCodableSample *v17;
  uint64_t v18;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 16), v17);
        if (!PBReaderPlaceMark() || (HDCodableSampleReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_26:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    PBReaderReadData();
    v18 = objc_claimAutoreleasedReturnValue();
    v17 = *(HDCodableSample **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v18;
LABEL_24:

    goto LABEL_26;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7A5A374(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__86(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__86(uint64_t a1)
{

}

id HDPredicateForMetadataValue(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  const __CFString *v13;
  _QWORD v15[5];

  v15[4] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!v3 && a2 == 2)
  {
    objc_msgSend(MEMORY[0x1E0D29880], "isNotNullPredicateWithProperty:", CFSTR("numerical_value"));
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0D29880], "isNotNullPredicateWithProperty:", CFSTR("date_value"));
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0D29880], "isNotNullPredicateWithProperty:", CFSTR("string_value"));
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0D29880], "isNotNullPredicateWithProperty:", CFSTR("data_value"));
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = (void *)MEMORY[0x1E0D29840];
    v15[0] = v4;
    v15[1] = v5;
    v15[2] = v6;
    v15[3] = v7;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v15, 4);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "predicateMatchingAnyPredicates:", v9);
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    goto LABEL_15;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v11 = (void *)MEMORY[0x1E0D29838];
    _HDSQLiteValueForString();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = CFSTR("string_value");
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v11 = (void *)MEMORY[0x1E0D29838];
      _HDSQLiteValueForNumber();
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v13 = CFSTR("numerical_value");
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v11 = (void *)MEMORY[0x1E0D29838];
        _HDSQLiteValueForDate();
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v13 = CFSTR("date_value");
      }
      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          _HDMetadataQuantityComparisonPredicate(a2, v3);
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          goto LABEL_15;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
LABEL_16:
          objc_msgSend(MEMORY[0x1E0D29890], "falsePredicate");
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          goto LABEL_17;
        }
        v11 = (void *)MEMORY[0x1E0D29838];
        _HDSQLiteValueForData();
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v13 = CFSTR("data_value");
      }
    }
  }
  objc_msgSend(v11, "predicateWithProperty:value:comparisonType:", v13, v12, a2);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

LABEL_15:
  if (!v10)
    goto LABEL_16;
LABEL_17:

  return v10;
}

id _HDMetadataQuantityComparisonPredicate(uint64_t a1, void *a2)
{
  id v3;
  const __CFString *v4;
  char v5;
  const __CFString *v6;
  char v7;
  const __CFString *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  _QWORD v28[2];
  _QWORD v29[2];
  _QWORD v30[4];
  _QWORD v31[2];
  _QWORD v32[6];
  _QWORD v33[4];

  v33[2] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = 0;
  v5 = 0;
  v6 = CFSTR("=  0");
  v7 = 1;
  v8 = CFSTR("= -1");
  switch(a1)
  {
    case 1:
      v4 = 0;
      v6 = 0;
      v5 = 1;
      v8 = CFSTR("=  0");
      break;
    case 2:
      v7 = 0;
      v5 = 0;
      v6 = CFSTR("=  1");
      v4 = CFSTR("=  2");
      break;
    case 3:
      v4 = 0;
      v6 = 0;
      goto LABEL_6;
    case 4:
      break;
    case 5:
      v4 = 0;
      v6 = 0;
      v5 = 1;
      goto LABEL_9;
    case 6:
      v4 = 0;
      v5 = 0;
LABEL_9:
      v8 = CFSTR("=  1");
      break;
    default:
      objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "HDSQLitePredicate * _Nonnull _HDMetadataQuantityComparisonPredicate(HDSQLiteComparisonType, HKQuantity * _Nonnull __strong)");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "handleFailureInFunction:file:lineNumber:description:", v10, CFSTR("HDMetadataValueEntity.m"), 668, CFSTR("Unsupported comparison type for HKQuantity metadata values!"));

      v8 = 0;
      v4 = 0;
      v6 = 0;
      v7 = 1;
LABEL_6:
      v5 = 1;
      break;
  }
  v11 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend(v3, "_unit");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "doubleValueForUnit:", v12);
  objc_msgSend(v11, "numberWithDouble:");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  _HDSQLiteValueForNumber();
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v3, "_unit");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v15, "unitString");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  _HDSQLiteValueForString();
  v17 = (void *)objc_claimAutoreleasedReturnValue();

  v18 = (void *)MEMORY[0x1E0D298B0];
  v19 = *MEMORY[0x1E0D29798];
  if ((v7 & 1) != 0)
  {
    if ((v5 & 1) != 0)
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@(%@, %@, ?, ?) %@"), v19, CFSTR("numerical_value"), CFSTR("string_value"), v8);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      v29[0] = CFSTR("numerical_value");
      v29[1] = CFSTR("string_value");
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v29, 2);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v28[0] = v14;
      v28[1] = v17;
      v22 = (void *)MEMORY[0x1E0C99D20];
      v23 = v28;
      v24 = 2;
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@(%@, %@, ?, ?) %@ OR %@(%@, %@, ?, ?) %@"), v19, CFSTR("numerical_value"), CFSTR("string_value"), v8, v19, CFSTR("numerical_value"), CFSTR("string_value"), v6);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      v31[0] = CFSTR("numerical_value");
      v31[1] = CFSTR("string_value");
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v31, 2);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v30[0] = v14;
      v30[1] = v17;
      v30[2] = v14;
      v30[3] = v17;
      v22 = (void *)MEMORY[0x1E0C99D20];
      v23 = v30;
      v24 = 4;
    }
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@(%@, %@, ?, ?) %@ OR %@(%@, %@, ?, ?) %@ OR %@(%@, %@, ?, ?) %@"), v19, CFSTR("numerical_value"), CFSTR("string_value"), v8, v19, CFSTR("numerical_value"), CFSTR("string_value"), v6, v19, CFSTR("numerical_value"), CFSTR("string_value"), v4);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v33[0] = CFSTR("numerical_value");
    v33[1] = CFSTR("string_value");
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v33, 2);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v32[0] = v14;
    v32[1] = v17;
    v32[2] = v14;
    v32[3] = v17;
    v32[4] = v14;
    v32[5] = v17;
    v22 = (void *)MEMORY[0x1E0C99D20];
    v23 = v32;
    v24 = 6;
  }
  objc_msgSend(v22, "arrayWithObjects:count:", v23, v24);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "predicateWithSQL:overProperties:values:", v20, v21, v25);
  v26 = (void *)objc_claimAutoreleasedReturnValue();

  return v26;
}

uint64_t __Block_byref_object_copy__87(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__87(uint64_t a1)
{

}

void sub_1B7A5F1DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _significantTimeChange(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_handleSignificantTimeChangeNotification:", 0);
}

void sub_1B7A6054C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__88(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__88(uint64_t a1)
{

}

void sub_1B7A60A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A60D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A61514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A615C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A61C34(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B7A61E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,void *a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,id a33)
{
  void *v33;
  void *v34;
  void *v35;

  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__89(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__89(uint64_t a1)
{

}

void sub_1B7A6229C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B7A62448(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B7A6261C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, id);

  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);

  _Unwind_Resume(a1);
}

void sub_1B7A62778(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B7A6285C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B7A62B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSeriesSamplePredicateForSamplesToAutoFreezeExcludingSamples(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  _QWORD v13[3];

  v13[2] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("frozen"), &unk_1E6DFC3F8);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", +[HDSeriesSampleEntity _insertionEra]());
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "predicateWithProperty:notEqualToValue:", CFSTR("insertion_era"), v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = objc_alloc(MEMORY[0x1E0C99DE8]);
  v13[0] = v2;
  v13[1] = v5;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v13, 2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = (void *)objc_msgSend(v6, "initWithArray:", v7);

  if (objc_msgSend(v1, "count"))
  {
    objc_msgSend(v1, "hk_map:", &__block_literal_global_369);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0D29848], "doesNotContainPredicateWithProperty:values:", CFSTR("uuid"), v9);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "addObject:", v10);

  }
  objc_msgSend(MEMORY[0x1E0D29840], "predicateMatchingAllPredicates:", v8);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

void sub_1B7A62D0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v5;

  _Unwind_Resume(a1);
}

id HDSeriesSamplePredicateForSeriesIdentifier(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0D29838];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "predicateWithProperty:equalToValue:", CFSTR("hfd_key"), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1B7A62DF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __cxx_global_array_dtor_0()
{
  uint64_t i;

  for (i = 0; i != -18; i -= 3)
  {

  }
}

void _assertMetadataIsSame(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  char v15;
  void *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(v1, "firstObject");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "metadata");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v4 = v1;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v18;
    do
    {
      v8 = 0;
      v9 = v3;
      do
      {
        if (*(_QWORD *)v18 != v7)
          objc_enumerationMutation(v4);
        v10 = *(void **)(*((_QWORD *)&v17 + 1) + 8 * v8);
        objc_msgSend(v10, "metadata", (_QWORD)v17);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v12 = v9;
        if (v11 == v9)
          goto LABEL_12;
        v13 = v11;
        if (!v9)
        {

LABEL_11:
          objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
          v12 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void _assertMetadataIsSame(NSArray<HDQuantityDatum *> * _Nonnull __strong)");
          v16 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v12, "handleFailureInFunction:file:lineNumber:description:", v16, CFSTR("HDQuantityDatum.m"), 262, CFSTR("Cannot merge an array of datums with different metadata"));

LABEL_12:
          goto LABEL_13;
        }
        objc_msgSend(v10, "metadata");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        v15 = objc_msgSend(v14, "isEqual:", v9);

        if ((v15 & 1) == 0)
          goto LABEL_11;
LABEL_13:
        objc_msgSend(v10, "metadata");
        v3 = (void *)objc_claimAutoreleasedReturnValue();

        ++v8;
        v9 = v3;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v17, v21, 16);
    }
    while (v6);
  }

}

id _HDCombineQuantitySensorData(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  NSObject *v22;
  void *v23;
  NSObject *v24;
  void *v25;
  int v26;
  void *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (objc_msgSend(v5, "count"))
  {
    _assertMetadataIsSame(v5);
    objc_msgSend(v5, "firstObject");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "dateInterval");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "startDate");
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    if (v10)
    {
      objc_msgSend(v5, "lastObject");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "dateInterval");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "endDate");
      v13 = (void *)objc_claimAutoreleasedReturnValue();

      if (v13)
      {
        _HDCombinedQuantityForData(v5, v6);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "firstObject");
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "metadata");
        v16 = (id)objc_claimAutoreleasedReturnValue();

        if (v16)
        {
          if (v7)
          {
            objc_msgSend(v16, "hk_dictionaryByAddingEntriesFromDictionary:", v7);
            v17 = objc_claimAutoreleasedReturnValue();

            v16 = (id)v17;
          }
        }
        else
        {
          v16 = v7;
        }
        objc_msgSend(MEMORY[0x1E0CB6A40], "_quantitySamplesEnforcingDurationWithType:quantity:startDate:endDate:device:metadata:", v6, v14, v10, v13, 0, v16);
        v18 = (void *)objc_claimAutoreleasedReturnValue();

      }
      else
      {
        _HKInitializeLogging();
        v20 = (void *)*MEMORY[0x1E0CB52A8];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_FAULT))
        {
          v24 = v20;
          objc_msgSend(v5, "lastObject");
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          v26 = 138412290;
          v27 = v25;
          _os_log_fault_impl(&dword_1B7802000, v24, OS_LOG_TYPE_FAULT, "Sensor datum missing end date: %@", (uint8_t *)&v26, 0xCu);

        }
        v18 = 0;
      }

    }
    else
    {
      _HKInitializeLogging();
      v19 = (void *)*MEMORY[0x1E0CB52A8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_FAULT))
      {
        v22 = v19;
        objc_msgSend(v5, "firstObject");
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        v26 = 138412290;
        v27 = v23;
        _os_log_fault_impl(&dword_1B7802000, v22, OS_LOG_TYPE_FAULT, "Sensor datum missing start date: %@", (uint8_t *)&v26, 0xCu);

      }
      v18 = 0;
    }

  }
  else
  {
    v18 = 0;
  }

  return v18;
}

id _HDCombinedQuantityForData(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t k;
  void *v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  void *v18;
  void *v19;
  void *v20;
  double v21;
  double v22;
  void *v23;
  void *v24;
  double v25;
  double v26;
  void *v27;
  void *v28;
  double v29;
  char v30;
  id v31;
  NSObject *v32;
  void *v33;
  id v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  uint64_t j;
  void *v40;
  double v41;
  void *v42;
  void *v43;
  double v44;
  void *v45;
  id v47;
  id v48;
  id obj;
  uint64_t v50;
  void *v51;
  id v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint8_t buf[4];
  id v66;
  __int16 v67;
  id v68;
  _BYTE v69[128];
  _BYTE v70[128];
  _BYTE v71[128];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  objc_msgSend(v4, "canonicalUnit");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v4, "aggregationStyle");
  if ((unint64_t)(v6 - 2) < 2)
  {
    v48 = v4;
    +[HDStatisticsCollectionCalculator calculatorForQuantityType:intervalCollection:options:mergeStrategy:](HDStatisticsCollectionCalculator, "calculatorForQuantityType:intervalCollection:options:mergeStrategy:", v4, 0, 2, 1);
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    v53 = 0u;
    v54 = 0u;
    v55 = 0u;
    v56 = 0u;
    v47 = v3;
    obj = v3;
    v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v53, v69, 16);
    if (v15)
    {
      v16 = v15;
      v50 = *(_QWORD *)v54;
      do
      {
        for (i = 0; i != v16; ++i)
        {
          if (*(_QWORD *)v54 != v50)
            objc_enumerationMutation(obj);
          v18 = *(void **)(*((_QWORD *)&v53 + 1) + 8 * i);
          objc_msgSend(v18, "quantity");
          v19 = (void *)objc_claimAutoreleasedReturnValue();
          v20 = v5;
          objc_msgSend(v19, "doubleValueForUnit:", v5);
          v22 = v21;
          objc_msgSend(v18, "dateInterval");
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v23, "startDate");
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v24, "timeIntervalSinceReferenceDate");
          v26 = v25;
          objc_msgSend(v18, "dateInterval");
          v27 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v27, "endDate");
          v28 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v28, "timeIntervalSinceReferenceDate");
          v52 = 0;
          v30 = objc_msgSend(v51, "addSampleValue:startTime:endTime:sourceID:error:", 0, &v52, v22, v26, v29);
          v31 = v52;

          if ((v30 & 1) == 0)
          {
            _HKInitializeLogging();
            v32 = *MEMORY[0x1E0CB52A8];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138543618;
              v66 = v48;
              v67 = 2114;
              v68 = v31;
              _os_log_error_impl(&dword_1B7802000, v32, OS_LOG_TYPE_ERROR, "Failed to add datum to calculator during merge calculation for type %{public}@: %{public}@", buf, 0x16u);
            }
          }

          v5 = v20;
        }
        v16 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v53, v69, 16);
      }
      while (v16);
    }

    objc_msgSend(v51, "currentStatistics");
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v33, "averageQuantity");
    a2 = (void *)objc_claimAutoreleasedReturnValue();

    v3 = v47;
    v4 = v48;
  }
  else
  {
    if (v6 == 1)
    {
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v34 = v3;
      v35 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v57, v70, 16);
      if (v35)
      {
        v36 = v35;
        v37 = *(_QWORD *)v58;
        v38 = 0.0;
        do
        {
          for (j = 0; j != v36; ++j)
          {
            if (*(_QWORD *)v58 != v37)
              objc_enumerationMutation(v34);
            objc_msgSend(*(id *)(*((_QWORD *)&v57 + 1) + 8 * j), "quantity");
            v40 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v40, "doubleValueForUnit:", v5);
            v38 = v38 + v41;

          }
          v36 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v57, v70, 16);
        }
        while (v36);
      }
      else
      {
        v38 = 0.0;
      }

      v45 = (void *)MEMORY[0x1E0CB6A28];
      v44 = v38 / (double)(unint64_t)objc_msgSend(v34, "count");
      v42 = v45;
      v43 = v5;
      goto LABEL_35;
    }
    if (!v6)
    {
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v7 = v3;
      v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v61, v71, 16);
      if (v8)
      {
        v9 = v8;
        v10 = *(_QWORD *)v62;
        v11 = 0.0;
        do
        {
          for (k = 0; k != v9; ++k)
          {
            if (*(_QWORD *)v62 != v10)
              objc_enumerationMutation(v7);
            objc_msgSend(*(id *)(*((_QWORD *)&v61 + 1) + 8 * k), "quantity");
            v13 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v13, "doubleValueForUnit:", v5);
            v11 = v11 + v14;

          }
          v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v61, v71, 16);
        }
        while (v9);
      }
      else
      {
        v11 = 0.0;
      }

      v42 = (void *)MEMORY[0x1E0CB6A28];
      v43 = v5;
      v44 = v11;
LABEL_35:
      objc_msgSend(v42, "quantityWithUnit:doubleValue:", v43, v44);
      a2 = (void *)objc_claimAutoreleasedReturnValue();
    }
  }

  return a2;
}

HDQuantityDatum *HDMergedQuantitySensorData(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  uint64_t i;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  HDQuantityDatum *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  NSObject *v33;
  void *v34;
  NSObject *v35;
  void *v36;
  void *v37;
  HDQuantityDatum *v38;
  id v39;
  void *v40;
  void *v41;
  _QWORD aBlock[4];
  id v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint8_t v48[128];
  uint8_t buf[4];
  void *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (objc_msgSend(v3, "count"))
  {
    _assertMetadataIsSame(v3);
    objc_msgSend(v3, "firstObject");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "dateInterval");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "startDate");
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    if (v7)
    {
      objc_msgSend(v3, "lastObject");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "dateInterval");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "endDate");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      if (v10)
      {
        v40 = v10;
        v41 = v7;
        v46 = 0u;
        v47 = 0u;
        v44 = 0u;
        v45 = 0u;
        v11 = v3;
        v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v44, v48, 16);
        if (v12)
        {
          v13 = v12;
          v14 = 0;
          v15 = *(_QWORD *)v45;
          do
          {
            for (i = 0; i != v13; ++i)
            {
              if (*(_QWORD *)v45 != v15)
                objc_enumerationMutation(v11);
              v17 = *(void **)(*((_QWORD *)&v44 + 1) + 8 * i);
              objc_msgSend(v17, "saveCompletion");
              v18 = (void *)objc_claimAutoreleasedReturnValue();

              if (v18)
              {
                if (!v14)
                  v14 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
                objc_msgSend(v17, "saveCompletion");
                v19 = (void *)objc_claimAutoreleasedReturnValue();
                v20 = _Block_copy(v19);
                objc_msgSend(v14, "addObject:", v20);

              }
            }
            v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v44, v48, 16);
          }
          while (v13);
        }
        else
        {
          v14 = 0;
        }

        v39 = v4;
        _HDCombinedQuantityForData(v11, v4);
        v24 = (void *)objc_claimAutoreleasedReturnValue();
        v38 = [HDQuantityDatum alloc];
        objc_msgSend(v11, "lastObject");
        v37 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v37, "datumIdentifier");
        v25 = (void *)objc_claimAutoreleasedReturnValue();
        v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3588]), "initWithStartDate:endDate:", v7, v40);
        objc_msgSend(v11, "lastObject");
        v27 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v27, "metadata");
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v11, "lastObject");
        v29 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v29, "resumeContextProvider");
        v30 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = -[HDQuantityDatum initWithIdentifier:dateInterval:quantity:metadata:resumeContextProvider:](v38, "initWithIdentifier:dateInterval:quantity:metadata:resumeContextProvider:", v25, v26, v24, v28, v30);

        if (v14)
        {
          aBlock[0] = MEMORY[0x1E0C809B0];
          aBlock[1] = 3221225472;
          aBlock[2] = __HDMergedQuantitySensorData_block_invoke;
          aBlock[3] = &unk_1E6CE77C8;
          v43 = v14;
          v31 = _Block_copy(aBlock);
          -[HDQuantityDatum setSaveCompletion:](v21, "setSaveCompletion:", v31);

        }
        v4 = v39;
        v10 = v40;
        v7 = v41;
      }
      else
      {
        _HKInitializeLogging();
        v23 = (void *)*MEMORY[0x1E0CB52A8];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_FAULT))
        {
          v35 = v23;
          objc_msgSend(v3, "lastObject");
          v36 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138412290;
          v50 = v36;
          _os_log_fault_impl(&dword_1B7802000, v35, OS_LOG_TYPE_FAULT, "Sensor datum missing end date: %@", buf, 0xCu);

        }
        v21 = 0;
      }

    }
    else
    {
      _HKInitializeLogging();
      v22 = (void *)*MEMORY[0x1E0CB52A8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_FAULT))
      {
        v33 = v22;
        objc_msgSend(v3, "firstObject");
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412290;
        v50 = v34;
        _os_log_fault_impl(&dword_1B7802000, v33, OS_LOG_TYPE_FAULT, "Sensor datum missing start date: %@", buf, 0xCu);

      }
      v21 = 0;
    }

  }
  else
  {
    v21 = 0;
  }

  return v21;
}

id HDAggregateQuantitySensorData(void *a1, void *a2, void *a3, void *a4, double a5)
{
  void *v9;
  id v10;
  id v11;
  id v12;
  id v13;
  void *v14;
  void *v15;

  v9 = (void *)MEMORY[0x1E0C99D68];
  v10 = a4;
  v11 = a3;
  v12 = a2;
  v13 = a1;
  objc_msgSend(v9, "distantPast");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  HDAggregateQuantitySensorDataThroughDate(v13, v12, v11, v14, 0, v10, a5);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

HDQuantityAggregationResult *HDAggregateQuantitySensorDataThroughDate(void *a1, void *a2, void *a3, void *a4, int a5, void *a6, double a7)
{
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  HDQuantityAggregationResult *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  unsigned int v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  double v38;
  double v39;
  void *v40;
  double v41;
  double v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  NSObject *v49;
  uint64_t v50;
  id v51;
  id v52;
  unint64_t v53;
  void *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  unint64_t v58;
  double v59;
  void *v60;
  void *v61;
  void *v62;
  NSObject *v63;
  uint64_t v64;
  id v65;
  id v66;
  unint64_t v67;
  unint64_t v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  id v75;
  unint64_t v76;
  void *v77;
  void *v78;
  void *v79;
  NSObject *v80;
  uint64_t v81;
  id v82;
  id v83;
  id v84;
  void *v85;
  HDQuantityAggregationResult *v86;
  void *v87;
  void *v88;
  void *v90;
  id v91;
  void *v92;
  void *v93;
  void *v94;
  id v95;
  id v97;
  void *v98;
  id v99;
  void *v100;
  unint64_t v101;
  unint64_t v102;
  uint8_t buf[4];
  id v104;
  __int16 v105;
  uint64_t v106;
  __int16 v107;
  void *v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v99 = a2;
  v13 = a3;
  v14 = a4;
  v95 = a6;
  v15 = objc_msgSend(v12, "count");
  if (v15)
  {
    v16 = v15;
    v91 = v14;
    v92 = v13;
    objc_msgSend(v12, "firstObject");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "metadata");
    v18 = objc_claimAutoreleasedReturnValue();

    objc_msgSend(v12, "firstObject");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "dateInterval");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v20, "startDate");
    v21 = objc_claimAutoreleasedReturnValue();

    v94 = (void *)v21;
    objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeInterval:sinceDate:", v21, a7);
    v22 = objc_claimAutoreleasedReturnValue();
    v100 = v12;
    v102 = v16;
    if (v16 == 1)
    {
      v101 = 0;
      v97 = 0;
      v98 = 0;
      v23 = (void *)v18;
      v24 = (void *)v22;
    }
    else
    {
      v97 = 0;
      v98 = 0;
      v101 = 0;
      v26 = 1;
      v23 = (void *)v18;
      v24 = (void *)v22;
      do
      {
        objc_msgSend(v12, "objectAtIndexedSubscript:", v26);
        v27 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v27, "dateInterval");
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v28, "endDate");
        v29 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v27, "metadata");
        v30 = (void *)objc_claimAutoreleasedReturnValue();
        if (v23 == v30)
        {
          v33 = 1;
        }
        else
        {
          objc_msgSend(v27, "metadata");
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          if (v31)
          {
            objc_msgSend(v27, "metadata");
            v32 = (void *)objc_claimAutoreleasedReturnValue();
            v33 = objc_msgSend(v23, "isEqual:", v32);

          }
          else
          {
            v33 = 0;
          }

        }
        if (!objc_msgSend(v29, "hk_isBeforeDate:", v24) || (v33 & 1) == 0)
        {
          objc_msgSend(v27, "dateInterval");
          v34 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v34, "startDate");
          v35 = (void *)objc_claimAutoreleasedReturnValue();
          v36 = v12;
          v37 = v24;
          objc_msgSend(v24, "timeIntervalSinceDate:", v35);
          v39 = v38;

          objc_msgSend(v27, "dateInterval");
          v40 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v40, "duration");
          v42 = v41;

          if (v39 + v39 >= v42)
            v43 = v33;
          else
            v43 = 0;
          v44 = v43 - 1;
          objc_msgSend(v36, "subarrayWithRange:", v39 + v39);
          v45 = (void *)objc_claimAutoreleasedReturnValue();
          _HDCombineQuantitySensorData(v45, v99, v95);
          v46 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v46)
            goto LABEL_26;
          v47 = v23;
          _HKInitializeLogging();
          v48 = (void *)*MEMORY[0x1E0CB52A8];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_INFO))
          {
            v49 = v48;
            v50 = objc_msgSend(v45, "count");
            *(_DWORD *)buf = 138543874;
            v104 = v99;
            v105 = 2048;
            v106 = v50;
            v107 = 2112;
            v108 = v46;
            _os_log_impl(&dword_1B7802000, v49, OS_LOG_TYPE_INFO, "%{public}@: Aggregating %ld sensor datums produced %@", buf, 0x20u);

          }
          v51 = v97;
          if (!v97)
            v51 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          v97 = v51;
          objc_msgSend(v51, "addObjectsFromArray:", v46);
          v23 = v47;
          v52 = v98;
          if (!v98)
            v52 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          v98 = v52;
          objc_msgSend(v52, "addObjectsFromArray:", v45);
          v53 = v26 + v44 + 1;
          v101 = v53;
          if (v53 < objc_msgSend(v100, "count"))
          {
            objc_msgSend(v100, "objectAtIndexedSubscript:", v53);
            v54 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v54, "metadata");
            v55 = objc_claimAutoreleasedReturnValue();

            objc_msgSend(v54, "dateInterval");
            v56 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v56, "startDate");
            v57 = objc_claimAutoreleasedReturnValue();

            objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeInterval:sinceDate:", v57, a7);
            v24 = (void *)objc_claimAutoreleasedReturnValue();

            v94 = (void *)v57;
            v23 = (void *)v55;
          }
          else
          {
LABEL_26:
            v24 = v37;
          }

          v12 = v100;
        }

        ++v26;
        v16 = v102;
      }
      while (v102 != v26);
    }
    v93 = v24;
    v58 = v101;
    v90 = v23;
    if (v16 <= v101)
    {
      v14 = v91;
      v13 = v92;
    }
    else
    {
      v13 = v92;
      objc_msgSend(v92, "timeIntervalSinceDate:", v94);
      v14 = v91;
      if (v59 >= a7)
      {
        objc_msgSend(v12, "subarrayWithRange:", v101, v16 - v101);
        v60 = (void *)objc_claimAutoreleasedReturnValue();
        _HDCombineQuantitySensorData(v60, v99, v95);
        v61 = (void *)objc_claimAutoreleasedReturnValue();
        if (v61)
        {
          _HKInitializeLogging();
          v62 = (void *)*MEMORY[0x1E0CB52A8];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_INFO))
          {
            v63 = v62;
            v64 = objc_msgSend(v60, "count");
            *(_DWORD *)buf = 138543874;
            v104 = v99;
            v105 = 2048;
            v106 = v64;
            v107 = 2112;
            v108 = v61;
            _os_log_impl(&dword_1B7802000, v63, OS_LOG_TYPE_INFO, "%{public}@: Aggregating %ld sensor datums produced %@", buf, 0x20u);

          }
          v65 = v97;
          if (!v97)
            v65 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          v97 = v65;
          objc_msgSend(v65, "addObjectsFromArray:", v61);
          v66 = v98;
          if (!v98)
            v66 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          v98 = v66;
          objc_msgSend(v66, "addObjectsFromArray:", v60);
          v58 = v16;
        }
        v101 = v58;

      }
    }
    v67 = v16;
    while (1)
    {
      v68 = v67 - 1;
      objc_msgSend(v12, "objectAtIndexedSubscript:", v67 - 1);
      v69 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v69, "dateInterval");
      v70 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v70, "startDate");
      v71 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v69, "dateInterval");
      v72 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v72, "endDate");
      v73 = (void *)objc_claimAutoreleasedReturnValue();

      if ((objc_msgSend(v71, "hk_isAfterDate:", v14) & 1) == 0
        && (!objc_msgSend(v73, "hk_isAfterOrEqualToDate:", v14) || a5))
      {
        break;
      }

      --v67;
      if (!v68)
      {
        v74 = v93;
        v75 = v97;
        v76 = v101;
        goto LABEL_60;
      }
    }
    v76 = v101;
    if (v68 >= v101)
    {
      objc_msgSend(v12, "subarrayWithRange:", v101, v67 - v101);
      v77 = (void *)objc_claimAutoreleasedReturnValue();
      _HDCombineQuantitySensorData(v77, v99, v95);
      v78 = (void *)objc_claimAutoreleasedReturnValue();
      if (v78)
      {
        _HKInitializeLogging();
        v79 = (void *)*MEMORY[0x1E0CB52A8];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52A8], OS_LOG_TYPE_INFO))
        {
          v80 = v79;
          v81 = objc_msgSend(v77, "count");
          *(_DWORD *)buf = 138543874;
          v104 = v99;
          v105 = 2048;
          v106 = v81;
          v107 = 2112;
          v108 = v78;
          _os_log_impl(&dword_1B7802000, v80, OS_LOG_TYPE_INFO, "%{public}@: Aggregating %ld sensor datums produced %@", buf, 0x20u);

        }
        v75 = v97;
        if (!v97)
          v75 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        objc_msgSend(v75, "addObjectsFromArray:", v78);
        v82 = v98;
        if (!v98)
          v82 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v98 = v82;
        objc_msgSend(v82, "addObjectsFromArray:", v77);
        v76 = v67;
        v74 = v93;
      }
      else
      {
        v74 = v93;
        v75 = v97;
      }

      v14 = v91;
      v13 = v92;
    }
    else
    {
      v74 = v93;
      v75 = v97;
    }

LABEL_60:
    if (v75)
    {
      v83 = v75;
      if (v102 <= v76)
      {
        v84 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
      }
      else
      {
        objc_msgSend(v100, "hk_mutableSubarrayWithRange:", v76, v102 - v76);
        v84 = (id)objc_claimAutoreleasedReturnValue();
      }
      v85 = v84;
      v25 = -[HDQuantityAggregationResult initWithAggregatedSamples:consumedData:remainingData:]([HDQuantityAggregationResult alloc], "initWithAggregatedSamples:consumedData:remainingData:", v83, v98, v84);
    }
    else
    {
      if ((unint64_t)objc_msgSend(v100, "count") < 2)
      {
        v25 = 0;
        v88 = v90;
        goto LABEL_68;
      }
      v83 = 0;
      HDMergedQuantitySensorData(v100, v99);
      v85 = (void *)objc_claimAutoreleasedReturnValue();
      v86 = [HDQuantityAggregationResult alloc];
      v87 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithObjects:", v85, 0);
      v25 = -[HDQuantityAggregationResult initWithAggregatedSamples:consumedData:remainingData:](v86, "initWithAggregatedSamples:consumedData:remainingData:", 0, 0, v87);

      v74 = v93;
    }

    v88 = v90;
    v75 = v83;
LABEL_68:

    v12 = v100;
    goto LABEL_69;
  }
  v25 = 0;
LABEL_69:

  return v25;
}

void sub_1B7A666CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

uint64_t HDCodableRoutePointDatumReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char v36;
  uint64_t v37;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          *(_BYTE *)(a1 + 52) |= 0x10u;
          v18 = *v3;
          v19 = *(_QWORD *)(a2 + v18);
          if (v19 <= 0xFFFFFFFFFFFFFFF7 && v19 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v20 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v19);
            *(_QWORD *)(a2 + v18) = v19 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v20 = 0;
          }
          v37 = 40;
          goto LABEL_57;
        case 2u:
          *(_BYTE *)(a1 + 52) |= 2u;
          v22 = *v3;
          v23 = *(_QWORD *)(a2 + v22);
          if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v20 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v23);
            *(_QWORD *)(a2 + v22) = v23 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v20 = 0;
          }
          v37 = 16;
          goto LABEL_57;
        case 3u:
          *(_BYTE *)(a1 + 52) |= 4u;
          v24 = *v3;
          v25 = *(_QWORD *)(a2 + v24);
          if (v25 <= 0xFFFFFFFFFFFFFFF7 && v25 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v20 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v25);
            *(_QWORD *)(a2 + v24) = v25 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v20 = 0;
          }
          v37 = 24;
          goto LABEL_57;
        case 4u:
          *(_BYTE *)(a1 + 52) |= 1u;
          v26 = *v3;
          v27 = *(_QWORD *)(a2 + v26);
          if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v20 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v27);
            *(_QWORD *)(a2 + v26) = v27 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v20 = 0;
          }
          v37 = 8;
          goto LABEL_57;
        case 5u:
          *(_BYTE *)(a1 + 52) |= 8u;
          v28 = *v3;
          v29 = *(_QWORD *)(a2 + v28);
          if (v29 <= 0xFFFFFFFFFFFFFFF7 && v29 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v20 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v29);
            *(_QWORD *)(a2 + v28) = v29 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v20 = 0;
          }
          v37 = 32;
LABEL_57:
          *(_QWORD *)(a1 + v37) = v20;
          continue;
        case 6u:
          v30 = 0;
          v31 = 0;
          v32 = 0;
          *(_BYTE *)(a1 + 52) |= 0x20u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v33 = *v3;
        v34 = *(_QWORD *)(a2 + v33);
        v35 = v34 + 1;
        if (v34 == -1 || v35 > *(_QWORD *)(a2 + *v4))
          break;
        v36 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v34);
        *(_QWORD *)(a2 + v33) = v35;
        v32 |= (unint64_t)(v36 & 0x7F) << v30;
        if ((v36 & 0x80) == 0)
          goto LABEL_44;
        v30 += 7;
        v15 = v31++ >= 9;
        if (v15)
        {
          LODWORD(v32) = 0;
          goto LABEL_46;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_44:
      if (*(_BYTE *)(a2 + *v5))
        LODWORD(v32) = 0;
LABEL_46:
      *(_DWORD *)(a1 + 48) = v32;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t __Block_byref_object_copy__90(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__90(uint64_t a1)
{

}

void sub_1B7A68D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A69320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A69908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A6AB18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A6AEEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A6B890(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1B7A6CB3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

_QWORD *health::DataStoreInspector::DataStoreInspector(_QWORD *this, DataStore *a2)
{
  *this = a2;
  return this;
}

{
  *this = a2;
  return this;
}

void health::DataStoreInspector::enumerateStoreForPrinting(uint64_t *a1, uint64_t a2, int a3, __int128 **a4)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  std::string __p;
  int v18;
  void *v19;
  void *v20;
  uint64_t v21;
  int v22;
  int *v23;
  _BYTE v24[24];
  _BYTE *v25;
  _BYTE v26[24];
  _BYTE *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v22 = a3;
  if (a3 == 1)
  {
    v7 = *a1;
    v28[0] = &off_1E6CF7FF8;
    v28[1] = a1;
    v28[2] = a2;
    v29 = v28;
    health::DataStore::checkIntegrityForInspecting(v7, (uint64_t)v28);
    v8 = v29;
    if (v29 == v28)
    {
      v9 = 4;
      v8 = v28;
    }
    else
    {
      if (!v29)
        goto LABEL_7;
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
  }
LABEL_7:
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v18 = 0;
  v10 = *a1;
  v11 = operator new(0x30uLL);
  *v11 = &off_1E6CF85C8;
  v11[1] = &v18;
  v11[2] = a1;
  v11[3] = &v22;
  v11[4] = a2;
  v11[5] = &v19;
  v27 = v11;
  health::DataStore::enumerateObjectTreeForInspecting(v10, (uint64_t)v26);
  v12 = v27;
  if (v27 == v26)
  {
    v13 = 4;
    v12 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_12;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_12:
  if (v22)
  {
    if (!a4 || v22 != 1)
      goto LABEL_23;
    std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v24, a2);
    health::DataStoreInspector::_crossReferenceWithSQLiteEntries((uint64_t)a1, (__int128 **)&v19, a4, (uint64_t)v24);
    v14 = v25;
    if (v25 == v24)
    {
      v15 = 4;
      v14 = v24;
    }
    else
    {
      if (!v25)
        goto LABEL_23;
      v15 = 5;
    }
    (*(void (**)(void))(*v14 + 8 * v15))();
  }
  else
  {
    v23 = &v18;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<int &>((std::string *)"\nTotal # of objects = {0}", &__p, 0, (uint64_t *)&v23);
    v16 = *(_QWORD *)(a2 + 24);
    if (!v16)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v16 + 48))(v16, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_23:
  if (v19)
  {
    v20 = v19;
    operator delete(v19);
  }
}

void sub_1B7A6D8A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char *a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  char *v28;
  char *v30;
  uint64_t v31;

  v30 = a24;
  if (a24 == v28)
  {
    v31 = 4;
    v30 = &a21;
  }
  else
  {
    if (!a24)
      goto LABEL_6;
    v31 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v30 + 8 * v31))();
LABEL_6:
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_crossReferenceWithSQLiteEntries(uint64_t a1, __int128 **a2, __int128 **a3, uint64_t a4)
{
  __int128 *v7;
  __int128 *v8;
  BOOL v9;
  unint64_t v10;
  uint64_t **v11;
  uint64_t *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 *v16;
  __int128 *v17;
  BOOL v18;
  unint64_t v19;
  uint64_t **v20;
  uint64_t *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  std::string::size_type v31[3];
  uint64_t *v32[3];
  std::string::size_type v33[3];
  uint64_t *v34[3];
  std::string::size_type v35[3];
  uint64_t *v36[3];
  std::string::size_type v37[3];
  uint64_t *v38[3];
  __int128 v39;
  _QWORD **v40;
  _QWORD *v41[2];
  uint64_t *v42;
  _QWORD *v43[2];
  _QWORD **v44;
  _QWORD *v45[2];
  __int128 v46;
  uint64_t v47;
  _QWORD **v48;
  _QWORD *v49[2];
  uint64_t *v50;
  _QWORD *v51[2];
  _QWORD **v52;
  _QWORD *v53[2];
  uint64_t *v54;
  _QWORD *v55[2];
  _BYTE v56[24];
  _BYTE *v57;
  _BYTE v58[24];
  _BYTE *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v55[0] = 0;
  v55[1] = 0;
  v53[1] = 0;
  v54 = (uint64_t *)v55;
  v52 = v53;
  v53[0] = 0;
  v51[0] = 0;
  v51[1] = 0;
  v49[1] = 0;
  v50 = (uint64_t *)v51;
  v48 = v49;
  v49[0] = 0;
  v7 = *a2;
  v8 = a2[1];
  if (*a2 != v8)
  {
    do
    {
      v46 = *v7;
      v9 = (_QWORD)v46 == 3 || (_QWORD)v46 == 0;
      v10 = *((_QWORD *)&v46 + 1);
      if (v9)
      {
        v11 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(&v54, *((unint64_t *)&v46 + 1), (_QWORD *)&v46 + 1);
        v12 = (uint64_t *)&v52;
      }
      else
      {
        v11 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(&v50, *((unint64_t *)&v46 + 1), (_QWORD *)&v46 + 1);
        v12 = (uint64_t *)&v48;
      }
      v13 = *v7;
      v14 = v7[1];
      v15 = v7[2];
      v11[11] = (uint64_t *)*((_QWORD *)v7 + 6);
      *(_OWORD *)(v11 + 9) = v15;
      *(_OWORD *)(v11 + 7) = v14;
      *(_OWORD *)(v11 + 5) = v13;
      std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(v12, v10, v10);
      v7 = (__int128 *)((char *)v7 + 56);
    }
    while (v7 != v8);
    v7 = *a2;
  }
  a2[1] = v7;
  *((_QWORD *)&v46 + 1) = 0;
  v47 = 0;
  *(_QWORD *)&v46 = (char *)&v46 + 8;
  v45[0] = 0;
  v45[1] = 0;
  v43[1] = 0;
  v44 = v45;
  v42 = (uint64_t *)v43;
  v43[0] = 0;
  v41[0] = 0;
  v41[1] = 0;
  v40 = v41;
  v16 = *a3;
  v17 = a3[1];
  if (*a3 != v17)
  {
    do
    {
      v39 = *v16;
      v18 = (_QWORD)v39 == 3 || (_QWORD)v39 == 0;
      v19 = *((_QWORD *)&v39 + 1);
      if (v18)
      {
        v20 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)&v46, *((unint64_t *)&v39 + 1), (_QWORD *)&v39 + 1);
        v21 = (uint64_t *)&v44;
      }
      else
      {
        v20 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(&v42, *((unint64_t *)&v39 + 1), (_QWORD *)&v39 + 1);
        v21 = (uint64_t *)&v40;
      }
      v22 = *v16;
      v23 = v16[1];
      v24 = v16[2];
      v20[11] = (uint64_t *)*((_QWORD *)v16 + 6);
      *(_OWORD *)(v20 + 9) = v24;
      *(_OWORD *)(v20 + 7) = v23;
      *(_OWORD *)(v20 + 5) = v22;
      std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(v21, v19, v19);
      v16 = (__int128 *)((char *)v16 + 56);
    }
    while (v16 != v17);
    v16 = *a3;
  }
  a3[1] = v16;
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v38, &v54);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v37, &v52);
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v36, &v46);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v35, &v44);
  v25 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v58, a4);
  health::DataStoreInspector::_crossReferenceWithSQLiteKeys(v25, v38, v37, v36, v35, (uint64_t)v58);
  v26 = v59;
  if (v59 == v58)
  {
    v27 = 4;
    v26 = v58;
  }
  else
  {
    if (!v59)
      goto LABEL_24;
    v27 = 5;
  }
  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_24:
  std::__tree<long>::destroy((_QWORD *)v35[1]);
  std::__tree<long>::destroy(v36[1]);
  std::__tree<long>::destroy((_QWORD *)v37[1]);
  std::__tree<long>::destroy(v38[1]);
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v34, &v50);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v33, &v48);
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v32, &v42);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v31, &v40);
  v28 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v56, a4);
  health::DataStoreInspector::_crossReferenceWithSQLiteKeys(v28, v34, v33, v32, v31, (uint64_t)v56);
  v29 = v57;
  if (v57 == v56)
  {
    v30 = 4;
    v29 = v56;
    goto LABEL_28;
  }
  if (v57)
  {
    v30 = 5;
LABEL_28:
    (*(void (**)(void))(*v29 + 8 * v30))();
  }
  std::__tree<long>::destroy((_QWORD *)v31[1]);
  std::__tree<long>::destroy(v32[1]);
  std::__tree<long>::destroy((_QWORD *)v33[1]);
  std::__tree<long>::destroy(v34[1]);
  std::__tree<long>::destroy(v41[0]);
  std::__tree<long>::destroy(v43[0]);
  std::__tree<long>::destroy(v45[0]);
  std::__tree<long>::destroy(*((_QWORD **)&v46 + 1));
  std::__tree<long>::destroy(v49[0]);
  std::__tree<long>::destroy(v51[0]);
  std::__tree<long>::destroy(v53[0]);
  std::__tree<long>::destroy(v55[0]);
}

void sub_1B7A6DD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10, uint64_t a11, uint64_t a12, _QWORD *a13, uint64_t a14, uint64_t a15, _QWORD *a16, uint64_t a17, uint64_t a18, _QWORD *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,_QWORD *a37,uint64_t a38,uint64_t a39,_QWORD *a40,uint64_t a41,uint64_t a42,_QWORD *a43)
{
  _QWORD *v43;
  uint64_t v44;
  _QWORD *v46;
  uint64_t v47;

  v46 = *(_QWORD **)(v44 - 112);
  if (v46 == v43)
  {
    v47 = 4;
    v46 = (_QWORD *)(v44 - 136);
  }
  else
  {
    if (!v46)
      goto LABEL_6;
    v47 = 5;
  }
  (*(void (**)(void))(*v46 + 8 * v47))();
LABEL_6:
  std::__tree<long>::destroy(a10);
  std::__tree<long>::destroy(a13);
  std::__tree<long>::destroy(a16);
  std::__tree<long>::destroy(a19);
  std::__tree<long>::destroy(a37);
  std::__tree<long>::destroy(a40);
  std::__tree<long>::destroy(a43);
  std::__tree<long>::destroy(*(_QWORD **)(v44 - 248));
  std::__tree<long>::destroy(*(_QWORD **)(v44 - 224));
  std::__tree<long>::destroy(*(_QWORD **)(v44 - 200));
  std::__tree<long>::destroy(*(_QWORD **)(v44 - 176));
  std::__tree<long>::destroy(*(_QWORD **)(v44 - 152));
  _Unwind_Resume(a1);
}

_BYTE *health::DataStoreInspector::enumerateSampleHistoryForPrinting(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  _BYTE *result;
  uint64_t v12;
  std::logic_error *exception;
  _BYTE v14[88];
  _BYTE v15[24];
  _BYTE *v16;
  _BYTE v17[24];
  _BYTE *v18;
  _BYTE v19[24];
  _BYTE *v20;
  _BYTE v21[24];
  _BYTE *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  switch(a2)
  {
    case 0:
      std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v21, a4);
      health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>((uint64_t)v14, a1, a2, a3, (uint64_t)v21, a5, a6);
      result = v22;
      if (v22 != v21)
        goto LABEL_9;
      v12 = 4;
      result = v21;
      return (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v12))();
    case 1:
      std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v17, a4);
      health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>((uint64_t)v14, a1, a2, a3, (uint64_t)v17, a5, a6);
      result = v18;
      if (v18 != v17)
        goto LABEL_9;
      v12 = 4;
      result = v17;
      return (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v12))();
    case 2:
      std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v15, a4);
      health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>((uint64_t)v14, a1, a2, a3, (uint64_t)v15, a5, a6);
      result = v16;
      if (v16 != v15)
        goto LABEL_9;
      v12 = 4;
      result = v15;
      return (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v12))();
    case 3:
      std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v19, a4);
      health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>((uint64_t)v14, a1, a2, a3, (uint64_t)v19, a5, a6);
      result = v20;
      if (v20 == v19)
      {
        v12 = 4;
        result = v19;
      }
      else
      {
LABEL_9:
        if (!result)
          return result;
        v12 = 5;
      }
      return (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v12))();
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Unexpected object type");
      __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
}

void sub_1B7A6E048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;

  if (a2 != 1)
    _Unwind_Resume(exception_object);
  v30 = __cxa_begin_catch(exception_object);
  v31 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)&a16, v29);
  health::DataStoreInspector::_unknownBehaviorHandler(v31, v28, v27, (uint64_t)v30, (uint64_t)&a16);
  v32 = a19;
  if (a19 == &a16)
  {
    v33 = 4;
    v32 = &a16;
  }
  else
  {
    if (!a19)
    {
LABEL_7:
      __cxa_end_catch();
      JUMPOUT(0x1B7A6DFD0);
    }
    v33 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v32 + 8 * v33))();
  goto LABEL_7;
}

void health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  uint64_t v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  std::string __p;
  uint64_t v23;
  char v24;
  int v25;
  __int128 v26;
  _BYTE v27[24];
  _BYTE *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v26 = a3;
  *((_QWORD *)&v26 + 1) = a4;
  v25 = a6;
  v24 = a7;
  *(_OWORD *)a1 = v26;
  *(_OWORD *)(a1 + 16) = xmmword_1B7F3A670;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(_QWORD *)(a1 + 48) = 0xBFF0000000000000;
  v23 = 0;
  v15 = *a2;
  v16 = operator new(0x40uLL);
  *v16 = &off_1E6CF8108;
  v16[1] = a1;
  v16[2] = &v25;
  v16[3] = &v26;
  v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v24;
  v16[7] = &v23;
  v28 = v16;
  v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(v15, (uint64_t)&v26, (uint64_t)v27);
  v18 = v28;
  if (v28 == v27)
  {
    v19 = 4;
    v18 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  if (v25 == 1)
    v20 = 1;
  else
    v20 = v17;
  if ((v20 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v26);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
    goto LABEL_15;
  }
  if (!v25 && v23 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v23);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
LABEL_15:
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v21 + 48))(v21, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A6E378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  uint64_t v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  std::string __p;
  uint64_t v23;
  char v24;
  int v25;
  __int128 v26;
  _BYTE v27[24];
  _BYTE *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v26 = a3;
  *((_QWORD *)&v26 + 1) = a4;
  v25 = a6;
  v24 = a7;
  *(_OWORD *)a1 = v26;
  *(_OWORD *)(a1 + 16) = xmmword_1B7F3A670;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(_QWORD *)(a1 + 48) = 0xBFF0000000000000;
  v23 = 0;
  v15 = *a2;
  v16 = operator new(0x40uLL);
  *v16 = &off_1E6CF82A8;
  v16[1] = a1;
  v16[2] = &v25;
  v16[3] = &v26;
  v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v24;
  v16[7] = &v23;
  v28 = v16;
  v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(v15, (uint64_t)&v26, (uint64_t)v27);
  v18 = v28;
  if (v28 == v27)
  {
    v19 = 4;
    v18 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  if (v25 == 1)
    v20 = 1;
  else
    v20 = v17;
  if ((v20 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v26);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
    goto LABEL_15;
  }
  if (!v25 && v23 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v23);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
LABEL_15:
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v21 + 48))(v21, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A6E574(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  uint64_t v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  std::string __p;
  uint64_t v23;
  char v24;
  int v25;
  __int128 v26;
  _BYTE v27[24];
  _BYTE *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v26 = a3;
  *((_QWORD *)&v26 + 1) = a4;
  v25 = a6;
  v24 = a7;
  *(_OWORD *)a1 = v26;
  *(_OWORD *)(a1 + 16) = xmmword_1B7F3A670;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(_QWORD *)(a1 + 48) = 0xBFF0000000000000;
  v23 = 0;
  v15 = *a2;
  v16 = operator new(0x40uLL);
  *v16 = &off_1E6CF83C8;
  v16[1] = a1;
  v16[2] = &v25;
  v16[3] = &v26;
  v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v24;
  v16[7] = &v23;
  v28 = v16;
  v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(v15, (uint64_t)&v26, (uint64_t)v27);
  v18 = v28;
  if (v28 == v27)
  {
    v19 = 4;
    v18 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  if (v25 == 1)
    v20 = 1;
  else
    v20 = v17;
  if ((v20 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v26);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
    goto LABEL_15;
  }
  if (!v25 && v23 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v23);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
LABEL_15:
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v21 + 48))(v21, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A6E770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  uint64_t v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  std::string __p;
  uint64_t v23;
  char v24;
  int v25;
  __int128 v26;
  _BYTE v27[24];
  _BYTE *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v26 = a3;
  *((_QWORD *)&v26 + 1) = a4;
  v25 = a6;
  v24 = a7;
  *(_OWORD *)a1 = v26;
  *(_OWORD *)(a1 + 16) = xmmword_1B7F3A670;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(_QWORD *)(a1 + 48) = 0xBFF0000000000000;
  v23 = 0;
  v15 = *a2;
  v16 = operator new(0x40uLL);
  *v16 = &off_1E6CF84C8;
  v16[1] = a1;
  v16[2] = &v25;
  v16[3] = &v26;
  v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v24;
  v16[7] = &v23;
  v28 = v16;
  v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(v15, (uint64_t)&v26, (uint64_t)v27);
  v18 = v28;
  if (v28 == v27)
  {
    v19 = 4;
    v18 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  if (v25 == 1)
    v20 = 1;
  else
    v20 = v17;
  if ((v20 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v26);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
    goto LABEL_15;
  }
  if (!v25 && v23 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v23);
    v21 = *(_QWORD *)(a5 + 24);
    if (!v21)
      std::__throw_bad_function_call[abi:ne180100]();
LABEL_15:
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v21 + 48))(v21, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A6E96C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_unknownBehaviorHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  std::string __p;
  _QWORD v11[2];
  char **v12[2];
  _BYTE v13[24];
  _BYTE *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v11[0] = a2;
  v11[1] = a3;
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  memset(&__p, 0, sizeof(__p));
  v12[0] = (char **)&v9;
  v12[1] = (char **)v11;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>((std::string *)"HFD sample history [ID: {0}] has unknown behavior - {1}", &__p, 0, v12);
  v6 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v13, a5);
  health::DataStoreInspector::_errorHandler(v6, 2, 0, 0, (std::string::size_type)&__p, (uint64_t)v13);
  v7 = v14;
  if (v14 == v13)
  {
    v8 = 4;
    v7 = v13;
  }
  else
  {
    if (!v14)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1B7A6EABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v16;
  _QWORD *v18;
  uint64_t v19;

  v18 = *(_QWORD **)(v16 - 32);
  if (v18 == (_QWORD *)(v16 - 56))
  {
    v19 = 4;
    v18 = (_QWORD *)(v16 - 56);
  }
  else
  {
    if (!v18)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL health::DataStoreInspector::_isLocationSeriesKey(health::DataStoreInspector *this, ObjectIdentifier a2)
{
  return !a2.objectType || a2.objectType == 3;
}

void health::DataStoreInspector::_crossReferenceWithSQLiteKeys(uint64_t a1, uint64_t **a2, std::string::size_type *a3, uint64_t **a4, std::string::size_type *a5, uint64_t a6)
{
  std::string::size_type *v10;
  std::string::size_type *v11;
  std::string::size_type v12;
  _QWORD *v13;
  BOOL v14;
  std::string::size_type *v15;
  unint64_t v17;
  unint64_t v18;
  std::string::size_type *v19;
  std::string::size_type *v20;
  std::string::size_type *v21;
  std::string::size_type *v22;
  _QWORD *v23;
  _QWORD *v24;
  std::string::size_type v25;
  _QWORD *v26;
  uint64_t **v27;
  __int128 v28;
  uint64_t **v29;
  __int128 v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD **v41;
  _QWORD *v42;
  uint64_t **v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD **v50;
  _QWORD *v51;
  uint64_t **v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  _QWORD *v58;
  _QWORD **v59;
  std::string v61;
  std::string v62;
  void *v63[2];
  char v64;
  std::string __p;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t *v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  uint64_t *v73;
  _QWORD **v74;
  _QWORD *v75[2];
  _QWORD **v76;
  _QWORD *v77[2];
  _QWORD **v78;
  _QWORD *v79[2];
  _BYTE v80[24];
  _BYTE *v81;
  _BYTE v82[24];
  _BYTE *v83;
  _BYTE v84[24];
  _BYTE *v85;
  _BYTE v86[24];
  _BYTE *v87;
  _BYTE v88[24];
  _BYTE *v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v79[0] = 0;
  v79[1] = 0;
  v78 = v79;
  v11 = a5 + 1;
  v10 = (std::string::size_type *)*a5;
  v12 = (std::string::size_type)(a3 + 1);
  v13 = (_QWORD *)*a3;
  *(_QWORD *)&v70 = &v78;
  *((_QWORD *)&v70 + 1) = v79;
  v14 = v10 == a5 + 1 || v13 == (_QWORD *)v12;
  if (v14)
  {
    v15 = a5;
  }
  else
  {
    do
    {
      v17 = v10[4];
      v18 = v13[4];
      if (v17 >= v18)
      {
        if (v18 >= v17)
        {
          std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]((uint64_t)&v70, v17);
          v22 = (std::string::size_type *)v10[1];
          if (v22)
          {
            do
            {
              v21 = v22;
              v22 = (std::string::size_type *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              v21 = (std::string::size_type *)v10[2];
              v14 = *v21 == (_QWORD)v10;
              v10 = v21;
            }
            while (!v14);
          }
        }
        else
        {
          v21 = v10;
        }
        v23 = (_QWORD *)v13[1];
        if (v23)
        {
          do
          {
            v13 = v23;
            v23 = (_QWORD *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            v24 = v13;
            v13 = (_QWORD *)v13[2];
          }
          while ((_QWORD *)*v13 != v24);
        }
        v10 = v21;
      }
      else
      {
        v19 = (std::string::size_type *)v10[1];
        if (v19)
        {
          do
          {
            v10 = v19;
            v19 = (std::string::size_type *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            v20 = v10;
            v10 = (std::string::size_type *)v10[2];
          }
          while ((std::string::size_type *)*v10 != v20);
        }
      }
    }
    while (v10 != v11 && v13 != (_QWORD *)v12);
    v13 = (_QWORD *)*a3;
    v15 = a5;
    v10 = (std::string::size_type *)*a5;
  }
  v77[0] = 0;
  v77[1] = 0;
  v76 = v77;
  v74 = (_QWORD **)v13;
  __p.__r_.__value_.__r.__words[0] = v12;
  v63[0] = v10;
  v62.__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
  *(_QWORD *)&v66 = &v76;
  *((_QWORD *)&v66 + 1) = v77;
  std::__set_difference[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::insert_iterator<std::set<unsigned long long>> &>((uint64_t)&v70, (uint64_t)&v74, &__p, (uint64_t)v63, &v62, &v66);
  v75[0] = 0;
  v75[1] = 0;
  v74 = v75;
  v25 = *a3;
  __p.__r_.__value_.__r.__words[0] = *v15;
  v63[0] = v11;
  v62.__r_.__value_.__r.__words[0] = v25;
  v61.__r_.__value_.__r.__words[0] = v12;
  *(_QWORD *)&v66 = &v74;
  *((_QWORD *)&v66 + 1) = v75;
  std::__set_difference[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::insert_iterator<std::set<unsigned long long>> &>((uint64_t)&v70, (uint64_t)&__p, v63, (uint64_t)&v62, &v61, &v66);
  v26 = v78;
  if (v78 != v79)
  {
    do
    {
      v27 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a2, v26[4], v26 + 4);
      v28 = *(_OWORD *)(v27 + 7);
      v70 = *(_OWORD *)(v27 + 5);
      v71 = v28;
      v72 = *(_OWORD *)(v27 + 9);
      v73 = v27[11];
      v29 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a4, v26[4], v26 + 4);
      v30 = *(_OWORD *)(v29 + 7);
      v66 = *(_OWORD *)(v29 + 5);
      v67 = v30;
      v68 = *(_OWORD *)(v29 + 9);
      v69 = v29[11];
      if (!(_QWORD)v30 || *((_QWORD *)&v67 + 1) == *((_QWORD *)&v71 + 1))
        goto LABEL_38;
      health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its SQLite row ({2})", (uint64_t)&v70, (uint64_t)&v71 + 8, (uint64_t)&v67 + 8);
      v31 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v88, a6);
      health::DataStoreInspector::_errorHandler(v31, 4, 0, 0, (std::string::size_type)&__p, (uint64_t)v88);
      v32 = v89;
      if (v89 == v88)
      {
        v32 = v88;
        v33 = 4;
      }
      else
      {
        if (!v89)
          goto LABEL_36;
        v33 = 5;
      }
      (*(void (**)(void))(*v32 + 8 * v33))();
LABEL_36:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
LABEL_38:
      if (vabdd_f64(*((double *)&v68 + 1), *((double *)&v72 + 1)) <= 1800.0)
        goto LABEL_50;
      health::timestampToDate(*((double *)&v72 + 1), &__p);
      health::timestampToDate(*((double *)&v68 + 1), v63);
      health::FormatString<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(&v62, (std::string *)"HFD sample history [ID: {0}] has an actual start date ({1}) that does not match its SQLite row ({2})", (uint64_t)&v70, (uint64_t)&__p, (uint64_t)v63);
      v34 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v86, a6);
      health::DataStoreInspector::_errorHandler(v34, 4, 0, 0, (std::string::size_type)&v62, (uint64_t)v86);
      v35 = v87;
      if (v87 == v86)
      {
        v35 = v86;
        v36 = 4;
        goto LABEL_43;
      }
      if (v87)
      {
        v36 = 5;
LABEL_43:
        (*(void (**)(void))(*v35 + 8 * v36))();
      }
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v62.__r_.__value_.__l.__data_);
      if (v64 < 0)
        operator delete(v63[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
LABEL_50:
      if (vabdd_f64(*(double *)&v69, *(double *)&v73) > 1800.0)
      {
        health::timestampToDate(*(double *)&v73, &__p);
        health::timestampToDate(*(double *)&v69, v63);
        health::FormatString<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(&v62, (std::string *)"HFD sample history [ID: {0}] has an actual end date ({1}) that does not match its SQLite row ({2})", (uint64_t)&v70, (uint64_t)&__p, (uint64_t)v63);
        v37 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v84, a6);
        health::DataStoreInspector::_errorHandler(v37, 4, 0, 0, (std::string::size_type)&v62, (uint64_t)v84);
        v38 = v85;
        if (v85 == v84)
        {
          v38 = v84;
          v39 = 4;
LABEL_55:
          (*(void (**)(void))(*v38 + 8 * v39))();
        }
        else if (v85)
        {
          v39 = 5;
          goto LABEL_55;
        }
        if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v62.__r_.__value_.__l.__data_);
        if (v64 < 0)
          operator delete(v63[0]);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      v40 = (_QWORD *)v26[1];
      if (v40)
      {
        do
        {
          v41 = (_QWORD **)v40;
          v40 = (_QWORD *)*v40;
        }
        while (v40);
      }
      else
      {
        do
        {
          v41 = (_QWORD **)v26[2];
          v14 = *v41 == v26;
          v26 = v41;
        }
        while (!v14);
      }
      v26 = v41;
    }
    while (v41 != v79);
  }
  v42 = v76;
  if (v76 != v77)
  {
    while (1)
    {
      v43 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a2, v42[4], v42 + 4);
      v44 = *(_OWORD *)(v43 + 9);
      v45 = *(_OWORD *)(v43 + 7);
      v70 = *(_OWORD *)(v43 + 5);
      v71 = v45;
      v72 = v44;
      v73 = v43[11];
      health::timestampToDate(*((double *)&v44 + 1), &__p);
      health::timestampToDate(*(double *)&v73, v63);
      *(_QWORD *)&v66 = v63;
      *((_QWORD *)&v66 + 1) = &__p;
      *(_QWORD *)&v67 = (char *)&v71 + 8;
      *((_QWORD *)&v67 + 1) = &v70;
      memset(&v62, 0, sizeof(v62));
      health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>((std::string *)"[ID: {0} | Count: {1} | {2} to {3}]", &v62, 0, (uint64_t *)&v66);
      v46 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v82, a6);
      health::DataStoreInspector::_errorHandler(v46, 5, 0, 0, (std::string::size_type)&v62, (uint64_t)v82);
      v47 = v83;
      if (v83 == v82)
        break;
      if (v83)
      {
        v48 = 5;
LABEL_73:
        (*(void (**)(void))(*v47 + 8 * v48))();
      }
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v62.__r_.__value_.__l.__data_);
      if (v64 < 0)
        operator delete(v63[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v49 = (_QWORD *)v42[1];
      if (v49)
      {
        do
        {
          v50 = (_QWORD **)v49;
          v49 = (_QWORD *)*v49;
        }
        while (v49);
      }
      else
      {
        do
        {
          v50 = (_QWORD **)v42[2];
          v14 = *v50 == v42;
          v42 = v50;
        }
        while (!v14);
      }
      v42 = v50;
      if (v50 == v77)
        goto LABEL_86;
    }
    v47 = v82;
    v48 = 4;
    goto LABEL_73;
  }
LABEL_86:
  v51 = v74;
  if (v74 != v75)
  {
    while (1)
    {
      v52 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a4, v51[4], v51 + 4);
      v53 = *(_OWORD *)(v52 + 9);
      v54 = *(_OWORD *)(v52 + 7);
      v70 = *(_OWORD *)(v52 + 5);
      v71 = v54;
      v72 = v53;
      v73 = v52[11];
      health::timestampToDate(*((double *)&v53 + 1), &__p);
      health::timestampToDate(*(double *)&v73, v63);
      health::timestampToDate(*(double *)&v72, &v62);
      *(_QWORD *)&v66 = &v71;
      *((_QWORD *)&v66 + 1) = &v62;
      *(_QWORD *)&v67 = v63;
      *((_QWORD *)&v67 + 1) = &__p;
      *(_QWORD *)&v68 = (char *)&v71 + 8;
      *((_QWORD *)&v68 + 1) = &v70;
      memset(&v61, 0, sizeof(v61));
      health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>((std::string *)"[ID: {0} | Count: {1} | {2} to {3} | Insertion Era: {4} | Frozen: {5}]", &v61, 0, (uint64_t *)&v66);
      v55 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v80, a6);
      health::DataStoreInspector::_errorHandler(v55, 6, 0, 0, (std::string::size_type)&v61, (uint64_t)v80);
      v56 = v81;
      if (v81 == v80)
        break;
      if (v81)
      {
        v57 = 5;
LABEL_91:
        (*(void (**)(void))(*v56 + 8 * v57))();
      }
      if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v61.__r_.__value_.__l.__data_);
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v62.__r_.__value_.__l.__data_);
      if (v64 < 0)
        operator delete(v63[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v58 = (_QWORD *)v51[1];
      if (v58)
      {
        do
        {
          v59 = (_QWORD **)v58;
          v58 = (_QWORD *)*v58;
        }
        while (v58);
      }
      else
      {
        do
        {
          v59 = (_QWORD **)v51[2];
          v14 = *v59 == v51;
          v51 = v59;
        }
        while (!v14);
      }
      v51 = v59;
      if (v59 == v75)
        goto LABEL_106;
    }
    v56 = v80;
    v57 = 4;
    goto LABEL_91;
  }
LABEL_106:
  std::__tree<long>::destroy(v75[0]);
  std::__tree<long>::destroy(v77[0]);
  std::__tree<long>::destroy(v79[0]);
}

void sub_1B7A6F300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,_QWORD *a51,uint64_t a52,uint64_t a53,_QWORD *a54,uint64_t a55,uint64_t a56,_QWORD *a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62)
{
  std::__tree<long>::destroy(a51);
  std::__tree<long>::destroy(a54);
  std::__tree<long>::destroy(a57);
  _Unwind_Resume(a1);
}

void health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5[3];

  v5[0] = a5;
  v5[1] = a4;
  v5[2] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(a2, a1, 0, v5);
}

void sub_1B7A6F510(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_errorHandler(uint64_t a1, int a2, uint64_t a3, uint64_t a4, std::string::size_type a5, uint64_t a6)
{
  const std::string::value_type *v11;
  std::string::size_type v12;
  std::string::value_type *v13;
  std::string *v14;
  std::string *v15;
  std::string *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  std::string __p;
  std::string v21;
  _QWORD v22[2];
  std::string v23;

  v22[0] = a3;
  v22[1] = a4;
  std::string::basic_string[abi:ne180100]<0>(&v21, "Unknown Error");
  v11 = "Unable to Traverse History";
  v12 = 26;
  switch(a2)
  {
    case 0:
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      {
        v21.__r_.__value_.__l.__size_ = 15;
        v14 = (std::string *)v21.__r_.__value_.__r.__words[0];
        v13 = (std::string::value_type *)(v21.__r_.__value_.__r.__words[0] + 15);
      }
      else
      {
        v13 = &v21.__r_.__value_.__s.__data_[15];
        *((_BYTE *)&v21.__r_.__value_.__s + 23) = 15;
        v14 = &v21;
      }
      qmemcpy(v14, "File Corruption", 15);
      goto LABEL_18;
    case 1:
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      {
        v21.__r_.__value_.__l.__size_ = 22;
        v16 = (std::string *)v21.__r_.__value_.__r.__words[0];
        v13 = (std::string::value_type *)(v21.__r_.__value_.__r.__words[0] + 22);
      }
      else
      {
        v13 = &v21.__r_.__value_.__s.__data_[22];
        *((_BYTE *)&v21.__r_.__value_.__s + 23) = 22;
        v16 = &v21;
      }
      qmemcpy(v16, "Unexpected Object Type", 22);
      goto LABEL_18;
    case 2:
      goto LABEL_11;
    case 3:
      v11 = "Sample History Root Mismatch";
      v12 = 28;
      goto LABEL_11;
    case 4:
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      {
        v21.__r_.__value_.__l.__size_ = 19;
        v15 = (std::string *)v21.__r_.__value_.__r.__words[0];
        v13 = (std::string::value_type *)(v21.__r_.__value_.__r.__words[0] + 19);
      }
      else
      {
        v13 = &v21.__r_.__value_.__s.__data_[19];
        *((_BYTE *)&v21.__r_.__value_.__s + 23) = 19;
        v15 = &v21;
      }
      *(_DWORD *)((char *)&v15->__r_.__value_.__r.__words[1] + 7) = 1751348321;
      *(_OWORD *)&v15->__r_.__value_.__l.__data_ = *(_OWORD *)"SQLite Row Mismatch";
LABEL_18:
      *v13 = 0;
      break;
    case 5:
      v11 = "Orphaned HFD Object (no reference in SQLite)";
      v12 = 44;
      goto LABEL_11;
    case 6:
      v11 = "Orphaned SQLite Row (no matching object in HFD)";
      v12 = 47;
LABEL_11:
      std::string::__assign_external(&v21, v11, v12);
      break;
    default:
      break;
  }
  if (a3 | a4)
  {
    v23.__r_.__value_.__r.__words[0] = a5;
    v23.__r_.__value_.__l.__size_ = (std::string::size_type)v22;
    v23.__r_.__value_.__r.__words[2] = (std::string::size_type)&v21;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>((std::string *)"{0}: [{1}] {2}", &__p, 0, (uint64_t *)&v23);
    v19 = *(_QWORD *)(a6 + 24);
    if (!v19)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v19 + 48))(v19, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      v18 = (void *)__p.__r_.__value_.__r.__words[0];
      goto LABEL_26;
    }
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = a5;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)&v21;
    memset(&v23, 0, sizeof(v23));
    health::FormatImplementation<std::string &,std::string const&>((std::string *)"{0}: {1}", &v23, 0, (uint64_t *)&__p);
    v17 = *(_QWORD *)(a6 + 24);
    if (!v17)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v17 + 48))(v17, &v23);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      v18 = (void *)v23.__r_.__value_.__r.__words[0];
LABEL_26:
      operator delete(v18);
    }
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
}

void sub_1B7A6F79C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void health::timestampToDate(double a1@<D0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  id v5;
  id v6;

  if (a1 <= 0.0)
  {
    v4 = 0;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeIntervalSinceReferenceDate:");
    v4 = objc_claimAutoreleasedReturnValue();
  }
  v6 = (id)v4;
  HKDiagnosticStringFromDate();
  v5 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)objc_msgSend(v5, "UTF8String"));

}

void sub_1B7A6F85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void health::FormatString<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5[3];

  v5[0] = a5;
  v5[1] = a4;
  v5[2] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(a2, a1, 0, v5);
}

void sub_1B7A6F8C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t health::doubleToString@<X0>(health *this@<X0>, _QWORD *a2@<X8>)
{
  int v3;
  uint64_t v6;
  _QWORD v7[10];
  char v8;
  uint64_t v9;

  v3 = (int)this;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
  *(_QWORD *)((char *)&v7[1] + *(_QWORD *)(v6 - 24)) = v3;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v7, a2);
  v6 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v7[-1] + *(_QWORD *)(v6 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v7[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v8 < 0)
    operator delete((void *)v7[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BCCAC458](&v9);
}

void sub_1B7A6F9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  BOOL v6;

  v3 = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(*(uint64_t ***)a1, *(uint64_t **)(a1 + 8), a2, a2);
  *(_QWORD *)(a1 + 8) = v3;
  v4 = (uint64_t *)v3[1];
  if (v4)
  {
    do
    {
      v5 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  else
  {
    do
    {
      v5 = (uint64_t *)v3[2];
      v6 = *v5 == (_QWORD)v3;
      v3 = v5;
    }
    while (!v6);
  }
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

uint64_t *std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t **v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t *v15;
  BOOL v16;
  uint64_t *v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t **v20;
  uint64_t *v21;
  unint64_t v22;
  uint64_t *v23;

  v5 = a2;
  v7 = a1 + 1;
  if (a1 + 1 != (uint64_t **)a2)
  {
    v8 = a2[4];
    if (v8 <= a3)
    {
      if (v8 < a3)
      {
        v13 = (uint64_t **)(a2 + 1);
        v12 = (uint64_t *)a2[1];
        if (v12)
        {
          do
          {
            v13 = (uint64_t **)v12;
            v12 = (uint64_t *)*v12;
            v5 = (uint64_t *)v13;
            v14 = v13;
          }
          while (v12);
        }
        else
        {
          v14 = (uint64_t **)a2;
          do
          {
            v20 = v14;
            v14 = (uint64_t **)v14[2];
          }
          while (*v14 != (uint64_t *)v20);
        }
        if (v14 == v7)
          goto LABEL_42;
        if ((unint64_t)v14[4] > a3)
          goto LABEL_42;
        v21 = *v7;
        v13 = a1 + 1;
        v5 = (uint64_t *)(a1 + 1);
        if (!*v7)
          goto LABEL_42;
        while (1)
        {
          while (1)
          {
            v5 = v21;
            v22 = v21[4];
            if (v22 <= a3)
              break;
            v21 = (uint64_t *)*v21;
            v13 = (uint64_t **)v5;
            if (!*v5)
              goto LABEL_42;
          }
          if (v22 >= a3)
            break;
          v21 = (uint64_t *)v21[1];
          if (!v21)
          {
LABEL_30:
            v13 = (uint64_t **)(v5 + 1);
            goto LABEL_42;
          }
        }
      }
      return v5;
    }
  }
  v9 = *a2;
  if (*a1 == a2)
  {
    v11 = a2;
  }
  else
  {
    if (v9)
    {
      v10 = (uint64_t *)*a2;
      do
      {
        v11 = v10;
        v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      v15 = a2;
      do
      {
        v11 = (uint64_t *)v15[2];
        v16 = *v11 == (_QWORD)v15;
        v15 = v11;
      }
      while (v16);
    }
    if (v11[4] >= a3)
    {
      v18 = *v7;
      v13 = a1 + 1;
      v5 = (uint64_t *)(a1 + 1);
      if (!*v7)
        goto LABEL_42;
      while (1)
      {
        while (1)
        {
          v5 = v18;
          v19 = v18[4];
          if (v19 <= a3)
            break;
          v18 = (uint64_t *)*v18;
          v13 = (uint64_t **)v5;
          if (!*v5)
            goto LABEL_42;
        }
        if (v19 >= a3)
          return v5;
        v18 = (uint64_t *)v18[1];
        if (!v18)
          goto LABEL_30;
      }
    }
  }
  if (v9)
    v17 = v11;
  else
    v17 = a2;
  if (v9)
    v13 = (uint64_t **)(v11 + 1);
  else
    v13 = (uint64_t **)a2;
  v5 = *v13;
  if (!*v13)
  {
    v5 = v17;
LABEL_42:
    v23 = (uint64_t *)operator new(0x28uLL);
    v23[4] = a4;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v5, v13, v23);
    return v23;
  }
  return v5;
}

uint64_t *std::__tree<unsigned long long>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t std::__set_difference[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::insert_iterator<std::set<unsigned long long>> &>(uint64_t result, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, __int128 *a6)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *i;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  __int128 v27;
  _QWORD *v28;
  _QWORD *v29;
  __int128 v30;

  v7 = result;
  v8 = *(_QWORD **)a2;
  v9 = (_QWORD *)*a3;
  if (*(_QWORD *)a2 == *a3)
  {
LABEL_38:
    v27 = *a6;
    v9 = v8;
    goto LABEL_39;
  }
  for (i = *(_QWORD **)a4; *(_QWORD *)a4 != *a5; i = *(_QWORD **)a4)
  {
    v15 = v8[4];
    v16 = i[4];
    if (v15 >= v16)
    {
      if (v16 >= v15)
      {
        v23 = (_QWORD *)v8[1];
        if (v23)
        {
          do
          {
            v24 = v23;
            v23 = (_QWORD *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            v24 = (_QWORD *)v8[2];
            v20 = *v24 == (_QWORD)v8;
            v8 = v24;
          }
          while (!v20);
        }
        *(_QWORD *)a2 = v24;
        v25 = *(_QWORD **)a4;
        v26 = *(_QWORD **)(*(_QWORD *)a4 + 8);
        if (v26)
        {
          do
          {
            v22 = v26;
            v26 = (_QWORD *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            v22 = (_QWORD *)v25[2];
            v20 = *v22 == (_QWORD)v25;
            v25 = v22;
          }
          while (!v20);
        }
      }
      else
      {
        v21 = (_QWORD *)i[1];
        if (v21)
        {
          do
          {
            v22 = v21;
            v21 = (_QWORD *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            v22 = (_QWORD *)i[2];
            v20 = *v22 == (_QWORD)i;
            i = v22;
          }
          while (!v20);
        }
      }
      *(_QWORD *)a4 = v22;
    }
    else
    {
      result = std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]((uint64_t)a6, v15);
      v17 = *(_QWORD **)a2;
      v18 = *(_QWORD **)(*(_QWORD *)a2 + 8);
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v17[2];
          v20 = *v19 == (_QWORD)v17;
          v17 = v19;
        }
        while (!v20);
      }
      *(_QWORD *)a2 = v19;
    }
    v8 = *(_QWORD **)a2;
    v9 = (_QWORD *)*a3;
    if (*(_QWORD *)a2 == *a3)
      goto LABEL_38;
  }
  v27 = *a6;
  v30 = *a6;
  if (v8 != v9)
  {
    do
    {
      result = std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]((uint64_t)&v30, v8[4]);
      v28 = (_QWORD *)v8[1];
      if (v28)
      {
        do
        {
          v29 = v28;
          v28 = (_QWORD *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          v29 = (_QWORD *)v8[2];
          v20 = *v29 == (_QWORD)v8;
          v8 = v29;
        }
        while (!v20);
      }
      v8 = v29;
    }
    while (v29 != v9);
    v27 = v30;
  }
LABEL_39:
  *(_QWORD *)v7 = v9;
  *(_OWORD *)(v7 + 8) = v27;
  return result;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  std::string::size_type size;
  std::string::size_type v7;
  std::string::size_type v9;

  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v7 = 22;
LABEL_5:
    std::string::__grow_by_and_replace(this, v7, __n - v7, size, 0, size, __n, __s);
    return this;
  }
  v7 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v7 < __n)
  {
    size = this->__r_.__value_.__l.__size_;
    goto LABEL_5;
  }
  v9 = this->__r_.__value_.__r.__words[0];
  memmove(this->__r_.__value_.__l.__data_, __s, __n);
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  *(_BYTE *)(v9 + __n) = 0;
  return this;
}

void std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E6CF7FF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF7FF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3, std::string::size_type a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _BYTE v11[24];
  _BYTE *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  v6 = a3[1];
  v7 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v11, *(_QWORD *)(a1 + 16));
  health::DataStoreInspector::_errorHandler(v7, 0, v5, v6, a4, (uint64_t)v11);
  v8 = v12;
  if (v12 == v11)
  {
    v9 = 4;
    v8 = v11;
    goto LABEL_5;
  }
  if (v12)
  {
    v9 = 5;
LABEL_5:
    (*(void (**)(void))(*v8 + 8 * v9))();
  }
  return 1;
}

void sub_1B7A70004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::target_type()
{
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 v10;
  _BYTE v11[24];
  _BYTE *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v6 = operator new(0x20uLL);
  *v6 = &unk_1E6CF8088;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = &v10;
  v12 = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v11);
  v7 = v12;
  if (v12 == v11)
  {
    v8 = 4;
    v7 = v11;
    goto LABEL_5;
  }
  if (v12)
  {
    v8 = 5;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v10;
}

void sub_1B7A70154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void health::FormatString<health::DataStore::ObjectIdentifier &>(std::string *a1, std::string *a2, uint64_t a3)
{
  uint64_t v3;

  v3 = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &>(a2, a1, 0, &v3);
}

void sub_1B7A701D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::FormatString<long long &>(std::string *a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<long long &>((std::string *)"\nTotal # of samples = {0}", a1, 0, &v2);
}

void sub_1B7A70234(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &unk_1E6CF8088;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E6CF8088;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x40uLL);
  *(_QWORD *)v2 = &off_1E6CF8108;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((_QWORD *)v2 + 7) = *(_QWORD *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a2 = &off_1E6CF8108;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  v4 = *(_OWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string *v21;
  std::string *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  void **v26;
  uint64_t v27;
  std::string __p;
  uint64_t v29;
  void *v30[2];
  char v31;
  void **v32;
  std::string v33;
  std::string *v34;
  _QWORD v35[2];
  char v36;
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = a2[4];
  v5 = a2[5];
  v6 = a2[6];
  v29 = v6;
  if (v6 >= 1)
  {
    *(double *)(*(_QWORD *)(a1 + 8) + 40) = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::firstSampleKey(a2);
    *(double *)(*(_QWORD *)(a1 + 8) + 48) = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::lastSampleKey(a2);
    v7 = **(_DWORD **)(a1 + 16);
    goto LABEL_7;
  }
  v7 = **(_DWORD **)(a1 + 16);
  if (v6)
    v8 = 0;
  else
    v8 = v7 == 1;
  if (v8)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&v33, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(_QWORD *)(a1 + 24));
    v14 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v35, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v33, (uint64_t)v35);
    v15 = v37;
    if (v37 == v35)
    {
      v16 = 4;
      v15 = v35;
    }
    else
    {
      if (!v37)
      {
LABEL_26:
        if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_29;
        v13 = (void *)v33.__r_.__value_.__r.__words[0];
        goto LABEL_28;
      }
      v16 = 5;
    }
    (*(void (**)(void))(*v15 + 8 * v16))();
    goto LABEL_26;
  }
LABEL_7:
  if (v7 == 2)
  {
    if (!**(_BYTE **)(a1 + 48))
      goto LABEL_29;
    v11 = *(_QWORD *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v35, "object_id \t sample_number \t timestamp \t data");
    v12 = *(_QWORD *)(v11 + 24);
    if (!v12)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v12 + 48))(v12, v35);
  }
  else
  {
    if (v7)
      goto LABEL_29;
    _HDSampleHistoryDescriptionForObjectType(**(_QWORD **)(a1 + 24), v35);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 40), &v33);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 48), v30);
    v9 = *(_QWORD *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v35, *(_QWORD *)(a1 + 24), (uint64_t)&v29, (uint64_t)&v33, (uint64_t)v30);
    v10 = *(_QWORD *)(v9 + 24);
    if (!v10)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v31 < 0)
      operator delete(v30[0]);
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (v36 < 0)
  {
    v13 = (void *)v35[0];
LABEL_28:
    operator delete(v13);
  }
LABEL_29:
  v17 = *(_QWORD *)(a1 + 56);
  v18 = *(_QWORD *)(a1 + 40);
  v20 = *(_QWORD *)(a1 + 16);
  v19 = *(_QWORD *)(a1 + 24);
  v21 = (std::string *)operator new(0x28uLL);
  v21->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E6CF8188;
  v21->__r_.__value_.__l.__size_ = v17;
  v21->__r_.__value_.__r.__words[2] = v20;
  v21[1].__r_.__value_.__r.__words[0] = v18;
  v21[1].__r_.__value_.__l.__size_ = v19;
  v34 = v21;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(a2, (uint64_t)&v33);
  v22 = v34;
  if (v34 == &v33)
  {
    v23 = 4;
    v22 = &v33;
    goto LABEL_33;
  }
  if (v34)
  {
    v23 = 5;
LABEL_33:
    (*(void (**)(void))(v22->__r_.__value_.__r.__words[0] + 8 * v23))();
  }
  v24 = *(_QWORD **)(a1 + 56);
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24) = *v24;
  if (**(_DWORD **)(a1 + 16) == 1 && *v24 != v29)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(_QWORD *)(a1 + 24), (uint64_t)v24, (uint64_t)&v29);
    v25 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v30, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v25, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v30);
    v26 = v32;
    if (v32 == v30)
    {
      v27 = 4;
      v26 = v30;
    }
    else
    {
      if (!v32)
        goto LABEL_41;
      v27 = 5;
    }
    (*((void (**)(void))*v26 + v27))();
LABEL_41:
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A70718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t *a37)
{
  uint64_t *v37;
  uint64_t *v39;
  uint64_t v40;

  v39 = a37;
  if (a37 == v37)
  {
    v40 = 4;
    v39 = &a31;
  }
  else
  {
    if (!a37)
      goto LABEL_6;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_6:
  if (a29 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::firstSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  std::logic_error *exception;
  _OWORD v6[26];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v2 = a1[2];
  v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  return *(double *)v6;
}

void sub_1B7A70978(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::lastSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t **v4;
  int v5;
  uint64_t v6;
  std::logic_error *exception;
  uint64_t v9[2];
  _QWORD *v10;
  _QWORD v11[2];
  uint64_t *v12;
  _BYTE __src[816];
  unsigned __int16 v14;
  __int128 v15;
  __int128 v16;
  _WORD __dst[208];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  v12 = v1;
  v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  v3 = __dst[204];
  if (!__dst[204])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!LOBYTE(__dst[205]))
  {
    v5 = 0;
    while (__dst[204])
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(__dst[204] - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (LOBYTE(__dst[205]))
      {
        v3 = __dst[204];
        v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  v4 = &v12;
LABEL_9:
  v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  bzero(__src, 0x332uLL);
  v15 = 0u;
  v16 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*v4, *(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__src, v14 - 1);
}

void sub_1B7A70B54(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6[5];

  v6[0] = a6;
  v6[1] = a5;
  v6[2] = a4;
  v6[3] = a3;
  v6[4] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>((std::string *)"'{0}' [ID: {1} | Count: {2} | {3} to {4}]\n", a1, 0, v6);
}

void sub_1B7A70BC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

_BYTE *health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(_BYTE *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  _QWORD *v7;
  _QWORD v8[3];
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)result + 6))
  {
    v2 = *(_QWORD *)(*((_QWORD *)result + 11) + 24);
    v8[0] = 0;
    v8[1] = 0;
    v8[2] = v2;
    v6 = *((_OWORD *)result + 1);
    v7 = v8;
    std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v9, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>((uint64_t *)&v6, (uint64_t)v9, 0);
    result = v10;
    if (v10 == v9)
    {
      v5 = 4;
      result = v9;
    }
    else
    {
      if (!v10)
        return result;
      v5 = 5;
    }
    return (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t))(*(_QWORD *)result + 8 * v5))(result, v3, v4);
  }
  return result;
}

void sub_1B7A70C98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19)
{
  char *v20;
  uint64_t v21;

  v20 = a19;
  if (a19 == &a16)
  {
    v21 = 4;
    v20 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  std::runtime_error *exception;
  _BYTE v29[8];
  uint64_t v30;
  char v31;
  unint64_t v32;
  char *v33;
  void *__p;
  unint64_t v35;
  unsigned __int8 v36;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v33 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v29, (const char **)&v33);
        v12 = v33;
        switch(v30)
        {
          case 0:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v29);
            v13 = v36;
            if ((v36 & 0x80u) != 0)
              v13 = v35;
            v14 = v32;
            if (v32 <= v13)
              v14 = v13;
            if (v31)
              v13 = v14;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 1:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v29);
            v16 = v36;
            if ((v36 & 0x80u) != 0)
              v16 = v35;
            v17 = v32;
            if (v32 <= v16)
              v17 = v16;
            if (v31)
              v16 = v17;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 2:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v29);
            v18 = v36;
            if ((v36 & 0x80u) != 0)
              v18 = v35;
            v19 = v32;
            if (v32 <= v18)
              v19 = v18;
            if (v31)
              v18 = v19;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v29);
            v20 = v36;
            if ((v36 & 0x80u) != 0)
              v20 = v35;
            v21 = v32;
            if (v32 <= v20)
              v21 = v20;
            if (v31)
              v20 = v21;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 4:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v29);
            v22 = v36;
            if ((v36 & 0x80u) != 0)
              v22 = v35;
            v23 = v32;
            if (v32 <= v22)
              v23 = v22;
            if (v31)
              v22 = v23;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v22 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_57:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v29, &v15[a3 + v8], (const void **)&__p);
            if ((char)v36 < 0)
              operator delete(__p);
            if (v8)
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_69;
        }
      }
      v33 = i + 2;
      v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v25 = 0;
        v26 = i + 3;
        do
        {
          v33 = v26;
          v25 = (v24 - 48) + 10 * v25;
          v27 = *v26++;
          v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        v33 = v26;
        if (*(v26 - 1) == 125)
          health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v25);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_69:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v33 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7112C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 4)
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      else
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A71270(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  health::operator<<(&v12);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B7A71418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<std::string &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  const std::ios_base *v7;
  std::ios_base::fmtflags v8;
  const std::locale::facet *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  std::locale v14[2];
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[10];
  char v18;
  uint64_t v19;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v16);
  v6 = v16;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v17[2] + *(_QWORD *)(v16 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v17[1] + *(_QWORD *)(v6 - 24)) = *(_QWORD *)(a3 + 40);
  v7 = (const std::ios_base *)((char *)&v17[-1] + *(_QWORD *)(v6 - 24));
  v8 = *(char *)(a3 + 52);
  if (v7[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v7);
    v9 = std::locale::use_facet(v14, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 32);
    std::locale::~locale(v14);
  }
  v7[1].__fmtflags_ = v8;
  v10 = *(char *)(a2 + 23);
  if (v10 >= 0)
    v11 = a2;
  else
    v11 = *(_QWORD *)a2;
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a2 + 23);
  else
    v12 = *(_QWORD *)(a2 + 8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, v11, v12);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v17, v14);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v14[0].__locale_;
  *(_QWORD *)(a1 + 16) = v15;
  v16 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v17[-1] + *(_QWORD *)(v16 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v17[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v18 < 0)
    operator delete((void *)v17[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v19);
  return a1;
}

void sub_1B7A715EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _OWORD v8[26];

  v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v14[840];
  __int128 v15;
  uint64_t v16;

  if (*(_WORD *)(a3 + 408))
  {
    v7 = result;
    v8 = *(_WORD *)(a3 + 408) - 1;
    if (!(_DWORD)a5)
      v8 = 0;
    if (*(_BYTE *)(a3 + 410))
    {
      v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(_QWORD *)(v9 + 16);
      v12 = *(_QWORD *)(v7 + 16);
      bzero(v14, 0x332uLL);
      *(_OWORD *)&v14[824] = 0u;
      v15 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      v16 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v16, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  void **v6;
  unint64_t v7;
  double v8;
  unint64_t *v9;
  uint64_t v10;
  __n128 v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  double v16;
  unint64_t *v17;
  uint64_t v18;
  __n128 v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  unint64_t i;
  double *v27;
  uint64_t v28;
  __n128 v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void **v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  unint64_t v37;
  double *v38;
  uint64_t v39;
  __n128 v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  std::string v44;
  void *v45[2];
  void *v46[2];
  void *v47[2];
  std::string v48;
  void *v49[2];
  void *v50[2];
  void *v51[2];
  std::string __p;
  void *v53[2];
  void *v54[2];
  void *v55[2];
  std::string v56;
  void *v57[2];
  void *v58[2];
  void *v59[2];
  std::string v60;
  void *v61[2];
  void *v62[2];
  void *v63[2];
  _BYTE v64[816];
  unsigned __int16 v65;
  __int128 v66;
  __int128 v67;
  std::string v68;
  _QWORD v69[2];
  _QWORD v70[2];
  _QWORD v71[2];

  v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 816))
    {
      v14 = *(unsigned __int16 *)(a2 + 816) - 1;
      v15 = 1;
      v16 = 0.0;
      while (1)
      {
        v17 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        v18 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            v20 = (void *)*MEMORY[0x1E0CB52B0];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        v21 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v21)
          break;
        v16 = *(double *)v17;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0)
          return result;
        ++v15;
        if (--v14 == -1)
          goto LABEL_35;
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    v16 = 0.0;
LABEL_35:
    v32 = *(_QWORD *)(a2 + 824);
    v33 = (void **)MEMORY[0x1E0CB52B0];
    v34 = *(_QWORD *)(a2 + 832);
    while (1)
    {
      v35 = *(_QWORD *)(v43 + 16);
      if (v32 == *(_QWORD *)v35 && v34 == *(_QWORD *)(v35 + 8))
        break;
      bzero(v64, 0x332uLL);
      v66 = 0u;
      v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v32, v34, (uint64_t)v64);
      if (!v65)
      {
        v36 = *v33;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      v37 = v65 - 1;
      do
      {
        v38 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        v39 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        if (*v38 >= v16)
        {
          v41 = *v33;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        v42 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v42)
          goto LABEL_48;
        v16 = *v38;
        v40.n128_f64[0] = *v38;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0)
          return result;
        --v37;
      }
      while (v37 != -1);
      v34 = *((_QWORD *)&v66 + 1);
      v32 = v66;
    }
  }
  else if (!a4)
  {
    v6 = (void **)MEMORY[0x1E0CB52B0];
    if (*(_WORD *)(a2 + 816))
    {
      v7 = 0;
      v8 = 0.0;
      while (1)
      {
        v9 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        v10 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v71, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v70, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v69, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v68);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v71, (uint64_t)v70, (uint64_t)v69, 382, (uint64_t)&v68);
          }
        }
        v13 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v13)
          goto LABEL_48;
        v8 = *(double *)v9;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0)
          return result;
        if (++v7 >= *(unsigned __int16 *)(a2 + 816))
          goto LABEL_22;
      }
    }
    v8 = 0.0;
LABEL_22:
    v22 = *(_QWORD *)(a2 + 840);
    v23 = *(_QWORD *)(a2 + 848);
    while (1)
    {
      v24 = *(_QWORD *)(v43 + 16);
      if (v22 == *(_QWORD *)v24 && v23 == *(_QWORD *)(v24 + 8))
        break;
      bzero(v64, 0x332uLL);
      v66 = 0u;
      v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)v64);
      if (!v65)
      {
        v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      for (i = 0; i < v65; ++i)
      {
        v27 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        v28 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        if (*v27 <= v8)
        {
          v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        v31 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v31)
          goto LABEL_48;
        v8 = *v27;
        v29.n128_f64[0] = *v27;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0)
          return result;
      }
      v23 = *((_QWORD *)&v67 + 1);
      v22 = v67;
    }
  }
  return result;
}

void sub_1B7A71EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a28 < 0)
    operator delete(__p);
  if (a34 < 0)
    operator delete(a29);
  if (a40 < 0)
    operator delete(a35);
  if (a46 < 0)
    operator delete(a41);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF8188;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE7__cloneEPNS0_6__baseIS11_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF8188;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EEclESX_S10_(uint64_t a1, double *a2, uint64_t a3)
{
  __int128 v3;
  double v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v12[2];
  uint64_t v13;
  void *v14[2];
  char v15;
  std::string __p;
  _OWORD *v17;
  void **v18;
  _QWORD *v19;
  uint64_t v20;

  v3 = *(_OWORD *)(a3 + 16);
  v12[0] = *(_OWORD *)a3;
  v12[1] = v3;
  v13 = *(_QWORD *)(a3 + 32);
  v4 = *a2;
  v5 = *(_QWORD **)(a1 + 8);
  ++*v5;
  v6 = **(_DWORD **)(a1 + 16);
  if (v6 == 2)
  {
    v9 = *(_QWORD *)(a1 + 24);
    v10 = *(_QWORD *)(a1 + 32);
    health::doubleToString((health *)9, v14);
    v17 = v12;
    v18 = v14;
    v19 = v5;
    v20 = v10;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v17);
    v8 = *(_QWORD *)(v9 + 24);
    if (!v8)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  else
  {
    if (v6)
      return 1;
    v7 = *(_QWORD *)(a1 + 24);
    health::timestampToDate(v4, v14);
    v17 = v12;
    v18 = v14;
    v19 = v5;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v17);
    v8 = *(_QWORD *)(v7 + 24);
    if (!v8)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v8 + 48))(v8, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v15 < 0)
    operator delete(v14[0]);
  return 1;
}

void sub_1B7A722E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  std::string::size_type v13;
  std::string::size_type v14;
  char *v15;
  std::string::size_type size;
  std::string::size_type v17;
  std::string::size_type v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  char *v24;
  int v25;
  std::runtime_error *exception;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  char *v31;
  std::string __p;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v31 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v31 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v31 = i + 2;
    v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v23 = 0;
      v24 = i + 3;
      do
      {
        v31 = v24;
        v23 = (v22 - 48) + 10 * v23;
        v25 = *v24++;
        v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      v31 = v24;
      if (*(v24 - 1) == 125)
        health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV1 &>(v23);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_56;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  v12 = v31;
  if (!*((_QWORD *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __p.__r_.__value_.__l.__size_;
    v17 = *((_QWORD *)&v28 + 1);
    if (*((_QWORD *)&v28 + 1) <= size)
      v17 = size;
    if ((_BYTE)v28)
      size = v17;
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, size + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_32:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (!v8)
      return;
LABEL_35:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((_QWORD *)&v27 + 1) != 1)
  {
    if (*((_QWORD *)&v27 + 1) == 2)
    {
      health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32);
      v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v13 = __p.__r_.__value_.__l.__size_;
      v14 = *((_QWORD *)&v28 + 1);
      if (*((_QWORD *)&v28 + 1) <= v13)
        v14 = v13;
      if ((_BYTE)v28)
        v13 = v14;
      health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_32;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_56:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  v18 = a4[1];
  __p.__r_.__value_.__r.__words[0] = v18;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v27;
  v33 = v28;
  v34 = v29;
  v35 = v30;
  if (*(char *)(v18 + 23) < 0)
    v19 = *(_QWORD *)(v18 + 8);
  else
    v19 = *(unsigned __int8 *)(v18 + 23);
  v20 = *((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1) <= v19)
    v20 = v19;
  if ((_BYTE)v28)
    v19 = v20;
  health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = (char *)a2;
  else
    v21 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8)
    goto LABEL_35;
}

void sub_1B7A726E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV1 &>(uint64_t a1)
{
  std::runtime_error *v2;
  std::runtime_error *exception;

  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v2 = exception;
    if (a1 == 2)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A727C4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8[7];

  v8[0] = a8;
  v8[1] = a7;
  v8[2] = a6;
  v8[3] = a5;
  v8[4] = a4;
  v8[5] = a3;
  v8[6] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>((std::string *)"(Lat: {0}, Lon: {1}, Alt: {2}, Speed: {3}, Course: {4}, HAcc: {5}, VAcc: {6})", a1, 0, v8);
}

void sub_1B7A72838(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  std::string::size_type v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  std::runtime_error *exception;
  _BYTE v29[8];
  uint64_t v30;
  char v31;
  unint64_t v32;
  char *v33;
  void *__p;
  unint64_t v35;
  unsigned __int8 v36;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v33 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v33 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v33 = i + 2;
    v24 = i[2];
    if ((v24 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v25 = 0;
      v26 = i + 3;
      do
      {
        v33 = v26;
        v25 = (v24 - 48) + 10 * v25;
        v27 = *v26++;
        v24 = v27;
      }
      while ((v27 - 58) >= 0xFFFFFFF6);
      v33 = v26;
      if (*(v26 - 1) == 125)
        health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(v25);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v29, (const char **)&v33);
  v12 = v33;
  switch(v30)
  {
    case 0:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&__p, a4[6], (uint64_t)v29);
      v13 = v36;
      if ((v36 & 0x80u) != 0)
        v13 = v35;
      v14 = v32;
      if (v32 <= v13)
        v14 = v13;
      if (v31)
        v13 = v14;
      goto LABEL_25;
    case 1:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&__p, a4[5], (uint64_t)v29);
      v13 = v36;
      if ((v36 & 0x80u) != 0)
        v13 = v35;
      v15 = v32;
      if (v32 <= v13)
        v15 = v13;
      if (v31)
        v13 = v15;
LABEL_25:
      v16 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v17 = (char *)a2;
      else
        v17 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_65;
    case 2:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v29);
      v18 = v36;
      if ((v36 & 0x80u) != 0)
        v18 = v35;
      v19 = v32;
      if (v32 <= v18)
        v19 = v18;
      if (v31)
        v18 = v19;
      goto LABEL_62;
    case 3:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v29);
      v18 = v36;
      if ((v36 & 0x80u) != 0)
        v18 = v35;
      v20 = v32;
      if (v32 <= v18)
        v20 = v18;
      if (v31)
        v18 = v20;
      goto LABEL_62;
    case 4:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v29);
      v18 = v36;
      if ((v36 & 0x80u) != 0)
        v18 = v35;
      v21 = v32;
      if (v32 <= v18)
        v21 = v18;
      if (v31)
        v18 = v21;
      goto LABEL_62;
    case 5:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v29);
      v18 = v36;
      if ((v36 & 0x80u) != 0)
        v18 = v35;
      v22 = v32;
      if (v32 <= v18)
        v22 = v18;
      if (v31)
        v18 = v22;
      goto LABEL_62;
    case 6:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v29);
      v18 = v36;
      if ((v36 & 0x80u) != 0)
        v18 = v35;
      v23 = v32;
      if (v32 <= v18)
        v23 = v18;
      if (v31)
        v18 = v23;
LABEL_62:
      v16 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(v12, a2, v18 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v17 = (char *)a2;
      else
        v17 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_65:
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v29, &v17[v16], (const void **)&__p);
      if ((char)v36 < 0)
        operator delete(__p);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      break;
    default:
      health::FormatterParameters<7ul>::formatParameterAtIndex<health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>>();
  }
}

void sub_1B7A72CDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 6)
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      else
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A72E4C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<7ul>::formatParameterAtIndex<health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A72EB8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<float const&,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B7A7304C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<double const&,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B7A7320C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  std::string::size_type size;
  std::string::size_type v14;
  char *v15;
  std::string::size_type v16;
  unint64_t v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string::size_type v21;
  unint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  std::runtime_error *exception;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  std::string __p;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v33 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        v12 = v33;
        switch(*((_QWORD *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = __p.__r_.__value_.__l.__size_;
            v14 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= size)
              v14 = size;
            if ((_BYTE)v30)
              size = v14;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, size + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v18 = __p.__r_.__value_.__l.__size_;
            v19 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v18)
              v19 = v18;
            if ((_BYTE)v30)
              v18 = v19;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 2:
            v16 = a4[1];
            __p.__r_.__value_.__r.__words[0] = v16;
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v29;
            v35 = v30;
            v36 = v31;
            v37 = v32;
            if (*(char *)(v16 + 23) < 0)
              v17 = *(_QWORD *)(v16 + 8);
            else
              v17 = *(unsigned __int8 *)(v16 + 23);
            v22 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v17)
              v22 = v17;
            if ((_BYTE)v30)
              v17 = v22;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v23 = (char *)a2;
            else
              v23 = (char *)a2->__r_.__value_.__r.__words[0];
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8)
              return;
            goto LABEL_44;
          case 3:
            health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32);
            v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v20 = __p.__r_.__value_.__l.__size_;
            v21 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v20)
              v21 = v20;
            if ((_BYTE)v30)
              v20 = v21;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_41:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            if (v8)
LABEL_44:
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_63;
        }
      }
      v33 = i + 2;
      v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v25 = 0;
        v26 = i + 3;
        do
        {
          v33 = v26;
          v25 = (v24 - 48) + 10 * v25;
          v27 = *v26++;
          v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        v33 = v26;
        if (*(v26 - 1) == 125)
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v25);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_63:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v33 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A73650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3)
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A73750(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  char *v18;
  int v19;
  std::runtime_error *exception;
  char v21[8];
  uint64_t v22;
  char v23;
  unint64_t v24;
  char *v25;
  void *__p[2];
  unsigned __int8 v27;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v25 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v25 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v25 = i + 2;
    v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v17 = 0;
      v18 = i + 3;
      do
      {
        v25 = v18;
        v17 = (v16 - 48) + 10 * v17;
        v19 = *v18++;
        v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      v25 = v18;
      if (*(v18 - 1) == 125)
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &>(v17);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_33:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_33;
  }
  v12 = v25;
  health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  v13 = v27;
  if ((v27 & 0x80u) != 0)
    v13 = (unint64_t)__p[1];
  v14 = v24;
  if (v24 <= v13)
    v14 = v13;
  if (v23)
    v13 = v14;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = (char *)a2;
  else
    v15 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0)
    operator delete(__p[0]);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7A739CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  v3 = exception;
  if (a1)
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  else
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(v3, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A73A5C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  char *v18;
  int v19;
  std::runtime_error *exception;
  char v21[8];
  uint64_t v22;
  char v23;
  unint64_t v24;
  char *v25;
  void *__p[2];
  unsigned __int8 v27;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v25 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v25 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v25 = i + 2;
    v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v17 = 0;
      v18 = i + 3;
      do
      {
        v25 = v18;
        v17 = (v16 - 48) + 10 * v17;
        v19 = *v18++;
        v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      v25 = v18;
      if (*(v18 - 1) == 125)
        health::FormatterParameters<0ul,long long &>::formatOptionsAtIndex<long long &>(v17);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_33:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_33;
  }
  v12 = v25;
  health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  v13 = v27;
  if ((v27 & 0x80u) != 0)
    v13 = (unint64_t)__p[1];
  v14 = v24;
  if (v24 <= v13)
    v14 = v13;
  if (v23)
    v13 = v14;
  health::FormatImplementation<long long &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = (char *)a2;
  else
    v15 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0)
    operator delete(__p[0]);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7A73CCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &>::formatOptionsAtIndex<long long &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  v3 = exception;
  if (a1)
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  else
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(v3, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A73D60(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 v10;
  _BYTE v11[24];
  _BYTE *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v6 = operator new(0x20uLL);
  *v6 = &unk_1E6CF8228;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = &v10;
  v12 = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v11);
  v7 = v12;
  if (v12 == v11)
  {
    v8 = 4;
    v7 = v11;
    goto LABEL_5;
  }
  if (v12)
  {
    v8 = 5;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v10;
}

void sub_1B7A73E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &unk_1E6CF8228;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E6CF8228;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x40uLL);
  *(_QWORD *)v2 = &off_1E6CF82A8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((_QWORD *)v2 + 7) = *(_QWORD *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a2 = &off_1E6CF82A8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  v4 = *(_OWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string *v21;
  std::string *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  void **v26;
  uint64_t v27;
  std::string __p;
  uint64_t v29;
  void *v30[2];
  char v31;
  void **v32;
  std::string v33;
  std::string *v34;
  _QWORD v35[2];
  char v36;
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = a2[4];
  v5 = a2[5];
  v6 = a2[6];
  v29 = v6;
  if (v6 >= 1)
  {
    *(double *)(*(_QWORD *)(a1 + 8) + 40) = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::firstSampleKey(a2);
    *(double *)(*(_QWORD *)(a1 + 8) + 48) = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::lastSampleKey(a2);
    v7 = **(_DWORD **)(a1 + 16);
    goto LABEL_7;
  }
  v7 = **(_DWORD **)(a1 + 16);
  if (v6)
    v8 = 0;
  else
    v8 = v7 == 1;
  if (v8)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&v33, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(_QWORD *)(a1 + 24));
    v14 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v35, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v33, (uint64_t)v35);
    v15 = v37;
    if (v37 == v35)
    {
      v16 = 4;
      v15 = v35;
    }
    else
    {
      if (!v37)
      {
LABEL_26:
        if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_29;
        v13 = (void *)v33.__r_.__value_.__r.__words[0];
        goto LABEL_28;
      }
      v16 = 5;
    }
    (*(void (**)(void))(*v15 + 8 * v16))();
    goto LABEL_26;
  }
LABEL_7:
  if (v7 == 2)
  {
    if (!**(_BYTE **)(a1 + 48))
      goto LABEL_29;
    v11 = *(_QWORD *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v35, "object_id \t sample_number \t timestamp \t data");
    v12 = *(_QWORD *)(v11 + 24);
    if (!v12)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v12 + 48))(v12, v35);
  }
  else
  {
    if (v7)
      goto LABEL_29;
    _HDSampleHistoryDescriptionForObjectType(**(_QWORD **)(a1 + 24), v35);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 40), &v33);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 48), v30);
    v9 = *(_QWORD *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v35, *(_QWORD *)(a1 + 24), (uint64_t)&v29, (uint64_t)&v33, (uint64_t)v30);
    v10 = *(_QWORD *)(v9 + 24);
    if (!v10)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v31 < 0)
      operator delete(v30[0]);
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (v36 < 0)
  {
    v13 = (void *)v35[0];
LABEL_28:
    operator delete(v13);
  }
LABEL_29:
  v17 = *(_QWORD *)(a1 + 56);
  v18 = *(_QWORD *)(a1 + 40);
  v20 = *(_QWORD *)(a1 + 16);
  v19 = *(_QWORD *)(a1 + 24);
  v21 = (std::string *)operator new(0x28uLL);
  v21->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E6CF8328;
  v21->__r_.__value_.__l.__size_ = v17;
  v21->__r_.__value_.__r.__words[2] = v20;
  v21[1].__r_.__value_.__r.__words[0] = v18;
  v21[1].__r_.__value_.__l.__size_ = v19;
  v34 = v21;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(a2, (uint64_t)&v33);
  v22 = v34;
  if (v34 == &v33)
  {
    v23 = 4;
    v22 = &v33;
    goto LABEL_33;
  }
  if (v34)
  {
    v23 = 5;
LABEL_33:
    (*(void (**)(void))(v22->__r_.__value_.__r.__words[0] + 8 * v23))();
  }
  v24 = *(_QWORD **)(a1 + 56);
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24) = *v24;
  if (**(_DWORD **)(a1 + 16) == 1 && *v24 != v29)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(_QWORD *)(a1 + 24), (uint64_t)v24, (uint64_t)&v29);
    v25 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v30, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v25, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v30);
    v26 = v32;
    if (v32 == v30)
    {
      v27 = 4;
      v26 = v30;
    }
    else
    {
      if (!v32)
        goto LABEL_41;
      v27 = 5;
    }
    (*((void (**)(void))*v26 + v27))();
LABEL_41:
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A74340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t *a37)
{
  uint64_t *v37;
  uint64_t *v39;
  uint64_t v40;

  v39 = a37;
  if (a37 == v37)
  {
    v40 = 4;
    v39 = &a31;
  }
  else
  {
    if (!a37)
      goto LABEL_6;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_6:
  if (a29 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::firstSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  std::logic_error *exception;
  _OWORD v6[26];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v2 = a1[2];
  v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  return *(double *)v6;
}

void sub_1B7A745A0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::lastSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t **v4;
  int v5;
  uint64_t v6;
  std::logic_error *exception;
  uint64_t v9[2];
  _QWORD *v10;
  _QWORD v11[2];
  uint64_t *v12;
  _BYTE __src[952];
  unsigned __int16 v14;
  __int128 v15;
  __int128 v16;
  _OWORD __dst[26];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  v12 = v1;
  v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  v3 = WORD4(__dst[25]);
  if (!WORD4(__dst[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!BYTE10(__dst[25]))
  {
    v5 = 0;
    while (WORD4(__dst[25]))
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(WORD4(__dst[25]) - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (BYTE10(__dst[25]))
      {
        v3 = WORD4(__dst[25]);
        v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  v4 = &v12;
LABEL_9:
  v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  bzero(__src, 0x3BAuLL);
  v15 = 0u;
  v16 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*v4, *(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__src, v14 - 1);
}

void sub_1B7A747A4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_BYTE *health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(_BYTE *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  _QWORD *v7;
  _QWORD v8[3];
  _BYTE v9[24];
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)result + 6))
  {
    v2 = *(_QWORD *)(*((_QWORD *)result + 11) + 24);
    v8[0] = 0;
    v8[1] = 0;
    v8[2] = v2;
    v6 = *((_OWORD *)result + 1);
    v7 = v8;
    std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v9, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>((uint64_t *)&v6, (uint64_t)v9, 0);
    result = v10;
    if (v10 == v9)
    {
      v5 = 4;
      result = v9;
    }
    else
    {
      if (!v10)
        return result;
      v5 = 5;
    }
    return (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t))(*(_QWORD *)result + 8 * v5))(result, v3, v4);
  }
  return result;
}

void sub_1B7A7487C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19)
{
  char *v20;
  uint64_t v21;

  v20 = a19;
  if (a19 == &a16)
  {
    v21 = 4;
    v20 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 56 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  _QWORD v7[2];

  if (a2 >= 0x11)
  {
    v2 = (void *)*MEMORY[0x1E0CB52B0];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 56 * a2;
}

void sub_1B7A749A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v8;
  uint64_t result;
  _QWORD v10[3];
  _QWORD v11[2];
  unsigned __int8 v12[1024];
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 935;
  health::RawBuffer::RawBuffer(v11, v12, 935);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  v8 = v12;
  if (v14 > 0x3FF)
    v8 = v13;
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 935;
  health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  result = (uint64_t)v13;
  v13 = 0;
  if (result)
    return MEMORY[0x1BCCAC47C](result, 0x1000C8077774924);
  return result;
}

void sub_1B7A74AF4(_Unwind_Exception *a1)
{
  unint64_t v2;

  v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2)
    MEMORY[0x1BCCAC47C](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_1B7A74C0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a26 < 0)
    operator delete(a21);
  if (*(char *)(v26 - 33) < 0)
    operator delete(*(void **)(v26 - 56));
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  unint64_t i;
  uint64_t v5;
  __int16 v7;

  for (i = 0; i != 17; ++i)
  {
    v5 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry::deserialize(v5, a2);
  }
  v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v7);
  *(_WORD *)(a1 + 952) = v7;
  health::BlockPointer::deserialize((_QWORD *)(a1 + 960), a2);
  return health::BlockPointer::deserialize((_QWORD *)(a1 + 976), a2);
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry::deserialize(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v6;

  v4 = (_QWORD *)(a1 + 8);
  v6 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v6);
  *(_QWORD *)a1 = v6;
  return health::DeserializeValues<double,double,float,float,float,float,float,float,float,unsigned char>(a2, v4, (_QWORD *)(a1 + 16), (_DWORD *)(a1 + 24), (_DWORD *)(a1 + 28), (_DWORD *)(a1 + 32), (_DWORD *)(a1 + 36), (_DWORD *)(a1 + 40), (_DWORD *)(a1 + 44), (_DWORD *)(a1 + 48), (_BYTE *)(a1 + 52));
}

uint64_t health::DeserializeValues<double,double,float,float,float,float,float,float,float,unsigned char>(uint64_t a1, _QWORD *a2, _QWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, _BYTE *a11)
{
  uint64_t v20;

  v20 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a1, &v20);
  *a2 = v20;
  v20 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a1, &v20);
  *a3 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a4 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a5 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a6 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a7 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a8 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a9 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a10 = v20;
  return health::DeserializationBuffer::extractRaw<unsigned char>(a1, a11);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _OWORD v8[26];

  v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v14[705];
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  if (*(_WORD *)(a3 + 408))
  {
    v7 = result;
    v8 = *(_WORD *)(a3 + 408) - 1;
    if (!(_DWORD)a5)
      v8 = 0;
    if (*(_BYTE *)(a3 + 410))
    {
      v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      v10 = *(_QWORD *)(v9 + 8);
      v11 = *(_QWORD *)(v9 + 16);
      v12 = *(_QWORD *)(v7 + 16);
      bzero(v14, 0x3BAuLL);
      v16 = 0u;
      v15 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      v17 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v17, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  void **v6;
  unint64_t v7;
  double v8;
  unint64_t *v9;
  uint64_t v10;
  __n128 v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  double v16;
  unint64_t *v17;
  uint64_t v18;
  __n128 v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  unint64_t i;
  double *v27;
  uint64_t v28;
  __n128 v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  void **v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  unint64_t v37;
  double *v38;
  uint64_t v39;
  __n128 v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  std::string v44;
  void *v45[2];
  void *v46[2];
  void *v47[2];
  std::string v48;
  void *v49[2];
  void *v50[2];
  void *v51[2];
  std::string __p;
  void *v53[2];
  void *v54[2];
  void *v55[2];
  std::string v56;
  void *v57[2];
  void *v58[2];
  void *v59[2];
  std::string v60;
  void *v61[2];
  void *v62[2];
  void *v63[2];
  _BYTE v64[952];
  unsigned __int16 v65;
  __int128 v66;
  __int128 v67;
  std::string v68;
  _QWORD v69[2];
  _QWORD v70[2];
  _QWORD v71[2];

  v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 952))
    {
      v14 = *(unsigned __int16 *)(a2 + 952) - 1;
      v15 = 1;
      v16 = 0.0;
      while (1)
      {
        v17 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        v18 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            v20 = (void *)*MEMORY[0x1E0CB52B0];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        v21 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v21)
          break;
        v16 = *(double *)v17;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0)
          return result;
        ++v15;
        if (--v14 == -1)
          goto LABEL_35;
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    v16 = 0.0;
LABEL_35:
    v32 = *(_QWORD *)(a2 + 960);
    v33 = (void **)MEMORY[0x1E0CB52B0];
    v34 = *(_QWORD *)(a2 + 968);
    while (1)
    {
      v35 = *(_QWORD *)(v43 + 16);
      if (v32 == *(_QWORD *)v35 && v34 == *(_QWORD *)(v35 + 8))
        break;
      bzero(v64, 0x3BAuLL);
      v66 = 0u;
      v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v32, v34, (uint64_t)v64);
      if (!v65)
      {
        v36 = *v33;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      v37 = v65 - 1;
      do
      {
        v38 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        v39 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        if (*v38 >= v16)
        {
          v41 = *v33;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        v42 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v42)
          goto LABEL_48;
        v16 = *v38;
        v40.n128_f64[0] = *v38;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0)
          return result;
        --v37;
      }
      while (v37 != -1);
      v34 = *((_QWORD *)&v66 + 1);
      v32 = v66;
    }
  }
  else if (!a4)
  {
    v6 = (void **)MEMORY[0x1E0CB52B0];
    if (*(_WORD *)(a2 + 952))
    {
      v7 = 0;
      v8 = 0.0;
      while (1)
      {
        v9 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        v10 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v71, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v70, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v69, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v68);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v71, (uint64_t)v70, (uint64_t)v69, 382, (uint64_t)&v68);
          }
        }
        v13 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v13)
          goto LABEL_48;
        v8 = *(double *)v9;
        result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(_QWORD *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0)
          return result;
        if (++v7 >= *(unsigned __int16 *)(a2 + 952))
          goto LABEL_22;
      }
    }
    v8 = 0.0;
LABEL_22:
    v22 = *(_QWORD *)(a2 + 976);
    v23 = *(_QWORD *)(a2 + 984);
    while (1)
    {
      v24 = *(_QWORD *)(v43 + 16);
      if (v22 == *(_QWORD *)v24 && v23 == *(_QWORD *)(v24 + 8))
        break;
      bzero(v64, 0x3BAuLL);
      v66 = 0u;
      v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)v64);
      if (!v65)
      {
        v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      for (i = 0; i < v65; ++i)
      {
        v27 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        v28 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        if (*v27 <= v8)
        {
          v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        v31 = *(_QWORD *)(*(_QWORD *)a3 + 24);
        if (!v31)
          goto LABEL_48;
        v8 = *v27;
        v29.n128_f64[0] = *v27;
        result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(_QWORD *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0)
          return result;
      }
      v23 = *((_QWORD *)&v67 + 1);
      v22 = v67;
    }
  }
  return result;
}

void sub_1B7A75794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a29 < 0)
    operator delete(__p);
  if (a35 < 0)
    operator delete(a30);
  if (a41 < 0)
    operator delete(a36);
  if (a47 < 0)
    operator delete(a42);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF8328;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE7__cloneEPNS0_6__baseIS11_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF8328;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EEclESX_S10_(uint64_t a1, double *a2, _OWORD *a3)
{
  __int128 v3;
  double v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v12[3];
  void *v13[2];
  char v14;
  std::string __p;
  _OWORD *v16;
  void **v17;
  _QWORD *v18;
  uint64_t v19;

  v3 = a3[1];
  v12[0] = *a3;
  v12[1] = v3;
  v12[2] = a3[2];
  v4 = *a2;
  v5 = *(_QWORD **)(a1 + 8);
  ++*v5;
  v6 = **(_DWORD **)(a1 + 16);
  if (v6 == 2)
  {
    v9 = *(_QWORD *)(a1 + 24);
    v10 = *(_QWORD *)(a1 + 32);
    health::doubleToString((health *)9, v13);
    v16 = v12;
    v17 = v13;
    v18 = v5;
    v19 = v10;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v16);
    v8 = *(_QWORD *)(v9 + 24);
    if (!v8)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  else
  {
    if (v6)
      return 1;
    v7 = *(_QWORD *)(a1 + 24);
    health::timestampToDate(v4, v13);
    v16 = v12;
    v17 = v13;
    v18 = v5;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v16);
    v8 = *(_QWORD *)(v7 + 24);
    if (!v8)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v8 + 48))(v8, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v14 < 0)
    operator delete(v13[0]);
  return 1;
}

void sub_1B7A75B8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  std::string::size_type v13;
  std::string::size_type v14;
  char *v15;
  std::string::size_type size;
  std::string::size_type v17;
  std::string::size_type v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  char *v24;
  int v25;
  std::runtime_error *exception;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  char *v31;
  std::string __p;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v31 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v31 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v31 = i + 2;
    v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v23 = 0;
      v24 = i + 3;
      do
      {
        v31 = v24;
        v23 = (v22 - 48) + 10 * v23;
        v25 = *v24++;
        v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      v31 = v24;
      if (*(v24 - 1) == 125)
        health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV2 &>(v23);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_56;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  v12 = v31;
  if (!*((_QWORD *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __p.__r_.__value_.__l.__size_;
    v17 = *((_QWORD *)&v28 + 1);
    if (*((_QWORD *)&v28 + 1) <= size)
      v17 = size;
    if ((_BYTE)v28)
      size = v17;
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, size + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_32:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (!v8)
      return;
LABEL_35:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((_QWORD *)&v27 + 1) != 1)
  {
    if (*((_QWORD *)&v27 + 1) == 2)
    {
      health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32, *a4 + 36, *a4 + 40, *a4 + 44);
      v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v13 = __p.__r_.__value_.__l.__size_;
      v14 = *((_QWORD *)&v28 + 1);
      if (*((_QWORD *)&v28 + 1) <= v13)
        v14 = v13;
      if ((_BYTE)v28)
        v13 = v14;
      health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_32;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_56:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  v18 = a4[1];
  __p.__r_.__value_.__r.__words[0] = v18;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v27;
  v33 = v28;
  v34 = v29;
  v35 = v30;
  if (*(char *)(v18 + 23) < 0)
    v19 = *(_QWORD *)(v18 + 8);
  else
    v19 = *(unsigned __int8 *)(v18 + 23);
  v20 = *((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1) <= v19)
    v20 = v19;
  if ((_BYTE)v28)
    v19 = v20;
  health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = (char *)a2;
  else
    v21 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8)
    goto LABEL_35;
}

void sub_1B7A75FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  void *v26;

  __cxa_free_exception(v26);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV2 &>(uint64_t a1)
{
  std::runtime_error *v2;
  std::runtime_error *exception;

  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v2 = exception;
    if (a1 == 2)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7607C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  _QWORD v11[10];

  v11[0] = a11;
  v11[1] = a10;
  v11[2] = a9;
  v11[3] = a8;
  v11[4] = a7;
  v11[5] = a6;
  v11[6] = a5;
  v11[7] = a4;
  v11[8] = a3;
  v11[9] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>((std::string *)"(Lat: {0}, Lon: {1}, Alt: {2}, Speed: {3}, Course: {4}, HAcc: {5}, VAcc: {6}, SAcc: {7}, CAcc:{8}, Signal: {9})", a1, 0, (uint64_t)v11);
}

void sub_1B7A760FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  _BYTE *v17;
  _QWORD *v18;
  const std::ios_base *v19;
  std::ios_base::fmtflags v20;
  const std::locale::facet *v21;
  size_t v22;
  size_t v23;
  size_t v24;
  std::string *v25;
  _BYTE *v26;
  size_t v27;
  unint64_t v28;
  __int128 *v29;
  void *v30;
  size_t v31;
  std::string::size_type v32;
  char *v33;
  size_t v34;
  size_t v35;
  size_t v36;
  size_t v37;
  size_t v38;
  size_t v39;
  __int128 *v40;
  size_t v41;
  unint64_t v42;
  uint64_t v43;
  __int128 *v44;
  unint64_t v45;
  _BYTE *v46;
  uint64_t v47;
  int v49;
  uint64_t v50;
  char *v51;
  int v52;
  std::runtime_error *exception;
  int v54;
  int v55;
  uint64_t v56;
  char v57;
  size_t v58;
  char v59;
  uint64_t v60;
  char v61;
  char *v62;
  __int128 v63;
  uint64_t v64;
  std::locale v65[2];
  uint64_t v66;
  void *v67;
  _BYTE v68[15];
  unsigned __int8 v69;
  _BYTE v70[48];
  void *__p;
  char v72;
  uint64_t v73;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v62 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v62 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v62 = i + 2;
    v49 = i[2];
    if ((v49 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v50 = 0;
      v51 = i + 3;
      do
      {
        v62 = v51;
        v50 = (v49 - 48) + 10 * v50;
        v52 = *v51++;
        v49 = v52;
      }
      while ((v52 - 58) >= 0xFFFFFFF6);
      v62 = v51;
      if (*(v51 - 1) == 125)
        health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v50);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_151:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)&v55, (const char **)&v62);
  v12 = v62;
  switch(v56)
  {
    case 0:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 72), (uint64_t)&v55);
      v13 = v69;
      if ((v69 & 0x80u) != 0)
        v13 = *(_QWORD *)v68;
      v14 = v58;
      if (v58 <= v13)
        v14 = v13;
      if (v57)
        v13 = v14;
      goto LABEL_65;
    case 1:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 64), (uint64_t)&v55);
      v13 = v69;
      if ((v69 & 0x80u) != 0)
        v13 = *(_QWORD *)v68;
      v31 = v58;
      if (v58 <= v13)
        v31 = v13;
      if (v57)
        v13 = v31;
LABEL_65:
      v32 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v33 = (char *)a2;
      else
        v33 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_112;
    case 2:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 56), (uint64_t)&v55);
      v15 = v69;
      if ((v69 & 0x80u) != 0)
        v15 = *(_QWORD *)v68;
      v34 = v58;
      if (v58 <= v15)
        v34 = v15;
      if (v57)
        v15 = v34;
      goto LABEL_109;
    case 3:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 48), (uint64_t)&v55);
      v15 = v69;
      if ((v69 & 0x80u) != 0)
        v15 = *(_QWORD *)v68;
      v35 = v58;
      if (v58 <= v15)
        v35 = v15;
      if (v57)
        v15 = v35;
      goto LABEL_109;
    case 4:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 40), (uint64_t)&v55);
      v15 = v69;
      if ((v69 & 0x80u) != 0)
        v15 = *(_QWORD *)v68;
      v16 = v58;
      if (v58 <= v15)
        v16 = v15;
      if (v57)
        v15 = v16;
      goto LABEL_109;
    case 5:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 32), (uint64_t)&v55);
      v15 = v69;
      if ((v69 & 0x80u) != 0)
        v15 = *(_QWORD *)v68;
      v36 = v58;
      if (v58 <= v15)
        v36 = v15;
      if (v57)
        v15 = v36;
      goto LABEL_109;
    case 6:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 24), (uint64_t)&v55);
      v15 = v69;
      if ((v69 & 0x80u) != 0)
        v15 = *(_QWORD *)v68;
      v37 = v58;
      if (v58 <= v15)
        v37 = v15;
      if (v57)
        v15 = v37;
      goto LABEL_109;
    case 7:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 16), (uint64_t)&v55);
      v15 = v69;
      if ((v69 & 0x80u) != 0)
        v15 = *(_QWORD *)v68;
      v38 = v58;
      if (v58 <= v15)
        v38 = v15;
      if (v57)
        v15 = v38;
      goto LABEL_109;
    case 8:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(_QWORD *)(a4 + 8), (uint64_t)&v55);
      v15 = v69;
      if ((v69 & 0x80u) != 0)
        v15 = *(_QWORD *)v68;
      v39 = v58;
      if (v58 <= v15)
        v39 = v15;
      if (v57)
        v15 = v39;
LABEL_109:
      v32 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v12, a2, v15 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v33 = (char *)a2;
      else
        v33 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_112:
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v55, &v33[v32], (const void **)&v67);
      if (((char)v69 & 0x80000000) == 0)
        goto LABEL_115;
      v30 = v67;
      goto LABEL_114;
    case 9:
      v17 = *(_BYTE **)a4;
      v64 = 0;
      v63 = 0uLL;
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v67);
      v18 = v67;
      if (v57)
        *(_QWORD *)&v70[*((_QWORD *)v67 - 3)] = v58;
      if (v59)
        *(_QWORD *)&v68[*(v18 - 3) + 8] = v60;
      v19 = (const std::ios_base *)&v68[*(v18 - 3) - 8];
      v20 = v61;
      if (v19[1].__fmtflags_ == -1)
      {
        std::ios_base::getloc(v19);
        v21 = std::locale::use_facet(v65, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 32);
        std::locale::~locale(v65);
      }
      v19[1].__fmtflags_ = v20;
      LOBYTE(v65[0].__locale_) = *v17;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v67, (uint64_t)v65, 1);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v68, v65);
      v63 = *(_OWORD *)&v65[0].__locale_;
      v67 = (void *)*MEMORY[0x1E0DE4F60];
      *(_QWORD *)&v68[*((_QWORD *)v67 - 3) - 8] = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
      v64 = v66;
      *(_QWORD *)v68 = MEMORY[0x1E0DE4FB8] + 16;
      if (v72 < 0)
        operator delete(__p);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1BCCAC458](&v73);
      v54 = SHIBYTE(v64);
      if (v64 >= 0)
        v22 = HIBYTE(v64);
      else
        v22 = *((_QWORD *)&v63 + 1);
      v23 = v58;
      if (v58 <= v22)
        v23 = v22;
      if (v57)
        v24 = v23;
      else
        v24 = v22;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v12, a2, v24 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v25 = a2;
      else
        v25 = (std::string *)a2->__r_.__value_.__r.__words[0];
      v26 = (char *)v25 + a3 + v8;
      if (!v57)
        goto LABEL_52;
      v27 = v58;
      v28 = v58 - v22;
      if (v58 <= v22)
        goto LABEL_52;
      if (v55)
      {
        if (v55 == 1)
        {
          v42 = v28 >> 1;
          if (v28 >= 2)
          {
            if (v42 <= 1)
              v43 = 1;
            else
              v43 = v28 >> 1;
            do
            {
              *v26++ = v61;
              --v43;
            }
            while (v43);
          }
          if (v22)
          {
            if (v54 >= 0)
              v44 = &v63;
            else
              v44 = (__int128 *)v63;
            memmove(v26, v44, v22);
          }
          if (v28 != v42)
          {
            v45 = v28 - (v28 >> 1);
            v46 = &v26[v22];
            if (v45 <= 1)
              v45 = 1;
            v47 = -(uint64_t)v45;
            do
              *v46++ = v61;
            while (!__CFADD__(v47++, 1));
          }
        }
        else if (v55 == 2)
        {
          if (v58 != v22)
          {
            do
            {
              *v26++ = v61;
              --v28;
            }
            while (v28);
          }
LABEL_52:
          if (v22)
          {
            if (v54 >= 0)
              v29 = &v63;
            else
              v29 = (__int128 *)v63;
            memmove(v26, v29, v22);
          }
        }
      }
      else
      {
        if (v22)
        {
          if (v54 >= 0)
            v40 = &v63;
          else
            v40 = (__int128 *)v63;
          memmove((char *)v25 + a3 + v8, v40, v22);
        }
        if (v27 != v22)
        {
          v41 = (size_t)v25 + v22;
          do
          {
            *(_BYTE *)(v41 + a3 + v8) = v61;
            ++v41;
            --v28;
          }
          while (v28);
        }
      }
      if ((SHIBYTE(v64) & 0x80000000) == 0)
        goto LABEL_115;
      v30 = (void *)v63;
LABEL_114:
      operator delete(v30);
LABEL_115:
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
      goto LABEL_151;
  }
}

void sub_1B7A7694C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,std::locale a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  void *v32;

  __cxa_free_exception(v32);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 9)
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      else
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A76B5C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  std::string::size_type size;
  std::string::size_type v14;
  char *v15;
  std::string::size_type v16;
  unint64_t v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string::size_type v21;
  unint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  std::runtime_error *exception;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  std::string __p;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v33 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        v12 = v33;
        switch(*((_QWORD *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = __p.__r_.__value_.__l.__size_;
            v14 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= size)
              v14 = size;
            if ((_BYTE)v30)
              size = v14;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, size + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v18 = __p.__r_.__value_.__l.__size_;
            v19 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v18)
              v19 = v18;
            if ((_BYTE)v30)
              v18 = v19;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 2:
            v16 = a4[1];
            __p.__r_.__value_.__r.__words[0] = v16;
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v29;
            v35 = v30;
            v36 = v31;
            v37 = v32;
            if (*(char *)(v16 + 23) < 0)
              v17 = *(_QWORD *)(v16 + 8);
            else
              v17 = *(unsigned __int8 *)(v16 + 23);
            v22 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v17)
              v22 = v17;
            if ((_BYTE)v30)
              v17 = v22;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v23 = (char *)a2;
            else
              v23 = (char *)a2->__r_.__value_.__r.__words[0];
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8)
              return;
            goto LABEL_44;
          case 3:
            health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32, *a4 + 36, *a4 + 40, *a4 + 44);
            v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v20 = __p.__r_.__value_.__l.__size_;
            v21 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v20)
              v21 = v20;
            if ((_BYTE)v30)
              v20 = v21;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_41:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            if (v8)
LABEL_44:
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_63;
        }
      }
      v33 = i + 2;
      v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v25 = 0;
        v26 = i + 3;
        do
        {
          v33 = v26;
          v25 = (v24 - 48) + 10 * v25;
          v27 = *v26++;
          v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        v33 = v26;
        if (*(v26 - 1) == 125)
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v25);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_63:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v33 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A76FB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  void *v26;

  __cxa_free_exception(v26);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3)
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A770B0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x40uLL);
  *(_QWORD *)v2 = &off_1E6CF83C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((_QWORD *)v2 + 7) = *(_QWORD *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a2 = &off_1E6CF83C8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  v4 = *(_OWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string *v21;
  std::string *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  void **v26;
  uint64_t v27;
  std::string __p;
  uint64_t v29;
  void *v30[2];
  char v31;
  void **v32;
  std::string v33;
  std::string *v34;
  _QWORD v35[2];
  char v36;
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = a2[4];
  v5 = a2[5];
  v6 = a2[6];
  v29 = v6;
  if (v6 >= 1)
  {
    *(double *)(*(_QWORD *)(a1 + 8) + 40) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::firstSampleKey(a2);
    *(double *)(*(_QWORD *)(a1 + 8) + 48) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::lastSampleKey(a2);
    v7 = **(_DWORD **)(a1 + 16);
    goto LABEL_7;
  }
  v7 = **(_DWORD **)(a1 + 16);
  if (v6)
    v8 = 0;
  else
    v8 = v7 == 1;
  if (v8)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&v33, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(_QWORD *)(a1 + 24));
    v14 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v35, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v33, (uint64_t)v35);
    v15 = v37;
    if (v37 == v35)
    {
      v16 = 4;
      v15 = v35;
    }
    else
    {
      if (!v37)
      {
LABEL_26:
        if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_29;
        v13 = (void *)v33.__r_.__value_.__r.__words[0];
        goto LABEL_28;
      }
      v16 = 5;
    }
    (*(void (**)(void))(*v15 + 8 * v16))();
    goto LABEL_26;
  }
LABEL_7:
  if (v7 == 2)
  {
    if (!**(_BYTE **)(a1 + 48))
      goto LABEL_29;
    v11 = *(_QWORD *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v35, "object_id \t sample_number \t timestamp \t data");
    v12 = *(_QWORD *)(v11 + 24);
    if (!v12)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v12 + 48))(v12, v35);
  }
  else
  {
    if (v7)
      goto LABEL_29;
    _HDSampleHistoryDescriptionForObjectType(**(_QWORD **)(a1 + 24), v35);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 40), &v33);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 48), v30);
    v9 = *(_QWORD *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v35, *(_QWORD *)(a1 + 24), (uint64_t)&v29, (uint64_t)&v33, (uint64_t)v30);
    v10 = *(_QWORD *)(v9 + 24);
    if (!v10)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v31 < 0)
      operator delete(v30[0]);
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (v36 < 0)
  {
    v13 = (void *)v35[0];
LABEL_28:
    operator delete(v13);
  }
LABEL_29:
  v17 = *(_QWORD *)(a1 + 56);
  v18 = *(_QWORD *)(a1 + 40);
  v20 = *(_QWORD *)(a1 + 16);
  v19 = *(_QWORD *)(a1 + 24);
  v21 = (std::string *)operator new(0x28uLL);
  v21->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E6CF8438;
  v21->__r_.__value_.__l.__size_ = v17;
  v21->__r_.__value_.__r.__words[2] = v20;
  v21[1].__r_.__value_.__r.__words[0] = v18;
  v21[1].__r_.__value_.__l.__size_ = v19;
  v34 = v21;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(a2, (uint64_t)&v33);
  v22 = v34;
  if (v34 == &v33)
  {
    v23 = 4;
    v22 = &v33;
    goto LABEL_33;
  }
  if (v34)
  {
    v23 = 5;
LABEL_33:
    (*(void (**)(void))(v22->__r_.__value_.__r.__words[0] + 8 * v23))();
  }
  v24 = *(_QWORD **)(a1 + 56);
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24) = *v24;
  if (**(_DWORD **)(a1 + 16) == 1 && *v24 != v29)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(_QWORD *)(a1 + 24), (uint64_t)v24, (uint64_t)&v29);
    v25 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v30, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v25, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v30);
    v26 = v32;
    if (v32 == v30)
    {
      v27 = 4;
      v26 = v30;
    }
    else
    {
      if (!v32)
        goto LABEL_41;
      v27 = 5;
    }
    (*((void (**)(void))*v26 + v27))();
LABEL_41:
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A774C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t *a37)
{
  uint64_t *v37;
  uint64_t *v39;
  uint64_t v40;

  v39 = a37;
  if (a37 == v37)
  {
    v40 = 4;
    v39 = &a31;
  }
  else
  {
    if (!a37)
      goto LABEL_6;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_6:
  if (a29 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::firstSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  std::logic_error *exception;
  _OWORD v6[26];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v2 = a1[2];
  v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  return *(double *)v6;
}

void sub_1B7A77724(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::lastSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t **v4;
  int v5;
  uint64_t v6;
  std::logic_error *exception;
  uint64_t v9[2];
  _QWORD *v10;
  _QWORD v11[2];
  uint64_t *v12;
  _OWORD __src[26];
  _OWORD __dst[26];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  v12 = v1;
  v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  v3 = WORD4(__dst[25]);
  if (!WORD4(__dst[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!BYTE10(__dst[25]))
  {
    v5 = 0;
    while (WORD4(__dst[25]))
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(WORD4(__dst[25]) - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (BYTE10(__dst[25]))
      {
        v3 = WORD4(__dst[25]);
        v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  v4 = &v12;
LABEL_9:
  v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  memset(__src, 0, 274);
  *(_OWORD *)((char *)&__src[17] + 8) = 0u;
  *(_OWORD *)((char *)&__src[18] + 8) = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*v4, *(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__src, LOWORD(__src[17]) - 1);
}

void sub_1B7A7791C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF8438;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE7__cloneEPNS0_6__baseISY_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF8438;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EEclESX_SX_(uint64_t a1, double *a2, uint64_t *a3)
{
  double v3;
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v11[2];
  char v12;
  std::string __p;
  uint64_t v14;
  uint64_t *v15;
  void **v16;
  _QWORD *v17;
  uint64_t v18;

  v3 = *a2;
  v14 = *a3;
  v4 = *(_QWORD **)(a1 + 8);
  ++*v4;
  v5 = **(_DWORD **)(a1 + 16);
  if (v5 == 2)
  {
    v8 = *(_QWORD *)(a1 + 24);
    v9 = *(_QWORD *)(a1 + 32);
    health::doubleToString((health *)9, v11);
    v15 = &v14;
    v16 = v11;
    v17 = v4;
    v18 = v9;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v15);
    v7 = *(_QWORD *)(v8 + 24);
    if (!v7)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  else
  {
    if (v5)
      return 1;
    v6 = *(_QWORD *)(a1 + 24);
    health::timestampToDate(v3, v11);
    v15 = &v14;
    v16 = v11;
    v17 = v4;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,double &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v15);
    v7 = *(_QWORD *)(v6 + 24);
    if (!v7)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v7 + 48))(v7, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v12 < 0)
    operator delete(v11[0]);
  return 1;
}

void sub_1B7A77AF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,double &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  char *v24;
  int v25;
  std::runtime_error *exception;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  char *v31;
  void *__p;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v31 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v31 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v31 = i + 2;
    v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v23 = 0;
      v24 = i + 3;
      do
      {
        v31 = v24;
        v23 = (v22 - 48) + 10 * v23;
        v25 = *v24++;
        v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      v31 = v24;
      if (*(v24 - 1) == 125)
        health::FormatterParameters<0ul,long long &,std::string,double &>::formatOptionsAtIndex<long long &,std::string,double &>(v23);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_56;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  v12 = v31;
  if (!*((_QWORD *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    v16 = HIBYTE(v33);
    if (v33 < 0)
      v16 = v33;
    v17 = *((_QWORD *)&v28 + 1);
    if (*((_QWORD *)&v28 + 1) <= v16)
      v17 = v16;
    if ((_BYTE)v28)
      v16 = v17;
    health::FormatImplementation<long long &,std::string,double &>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_32:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p);
    if (SHIBYTE(v33) < 0)
      operator delete(__p);
    if (!v8)
      return;
LABEL_35:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((_QWORD *)&v27 + 1) != 1)
  {
    if (*((_QWORD *)&v27 + 1) == 2)
    {
      health::TypeFormatter<double &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)&v27);
      v13 = HIBYTE(v33);
      if (v33 < 0)
        v13 = v33;
      v14 = *((_QWORD *)&v28 + 1);
      if (*((_QWORD *)&v28 + 1) <= v13)
        v14 = v13;
      if ((_BYTE)v28)
        v13 = v14;
      health::FormatImplementation<long long &,std::string,double &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_32;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_56:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  v18 = a4[1];
  __p = (void *)v18;
  v33 = v27;
  v34 = v28;
  v35 = v29;
  v36 = v30;
  if (*(char *)(v18 + 23) < 0)
    v19 = *(_QWORD *)(v18 + 8);
  else
    v19 = *(unsigned __int8 *)(v18 + 23);
  v20 = *((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1) <= v19)
    v20 = v19;
  if ((_BYTE)v28)
    v19 = v20;
  health::FormatImplementation<long long &,std::string,double &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = (char *)a2;
  else
    v21 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8)
    goto LABEL_35;
}

void sub_1B7A77EE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,double &>::formatOptionsAtIndex<long long &,std::string,double &>(uint64_t a1)
{
  std::runtime_error *v2;
  std::runtime_error *exception;

  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v2 = exception;
    if (a1 == 2)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A77FBC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<double &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B7A7815C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  std::runtime_error *exception;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  void *__p;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v33 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        v12 = v33;
        switch(*((_QWORD *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            v13 = HIBYTE(v35);
            if (v35 < 0)
              v13 = v35;
            v14 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v13)
              v14 = v13;
            if ((_BYTE)v30)
              v13 = v14;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            v18 = HIBYTE(v35);
            if (v35 < 0)
              v18 = v35;
            v19 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v18)
              v19 = v18;
            if ((_BYTE)v30)
              v18 = v19;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 2:
            v16 = a4[1];
            __p = (void *)v16;
            v35 = v29;
            v36 = v30;
            v37 = v31;
            v38 = v32;
            if (*(char *)(v16 + 23) < 0)
              v17 = *(_QWORD *)(v16 + 8);
            else
              v17 = *(unsigned __int8 *)(v16 + 23);
            v22 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v17)
              v22 = v17;
            if ((_BYTE)v30)
              v17 = v22;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v23 = (char *)a2;
            else
              v23 = (char *)a2->__r_.__value_.__r.__words[0];
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8)
              return;
            goto LABEL_44;
          case 3:
            health::TypeFormatter<double &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)&v29);
            v20 = HIBYTE(v35);
            if (v35 < 0)
              v20 = v35;
            v21 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v20)
              v21 = v20;
            if ((_BYTE)v30)
              v20 = v21;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_41:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p);
            if (SHIBYTE(v35) < 0)
              operator delete(__p);
            if (v8)
LABEL_44:
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_63;
        }
      }
      v33 = i + 2;
      v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v25 = 0;
        v26 = i + 3;
        do
        {
          v33 = v26;
          v25 = (v24 - 48) + 10 * v25;
          v27 = *v26++;
          v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        v33 = v26;
        if (*(v26 - 1) == 125)
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,double &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v25);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_63:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v33 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7858C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,double &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3)
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7868C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x40uLL);
  *(_QWORD *)v2 = &off_1E6CF84C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((_QWORD *)v2 + 7) = *(_QWORD *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a2 = &off_1E6CF84C8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  v4 = *(_OWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string *v21;
  std::string *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  void **v26;
  uint64_t v27;
  std::string __p;
  uint64_t v29;
  void *v30[2];
  char v31;
  void **v32;
  std::string v33;
  std::string *v34;
  _QWORD v35[2];
  char v36;
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = a2[4];
  v5 = a2[5];
  v6 = a2[6];
  v29 = v6;
  if (v6 >= 1)
  {
    *(double *)(*(_QWORD *)(a1 + 8) + 40) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::firstSampleKey(a2);
    *(double *)(*(_QWORD *)(a1 + 8) + 48) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::lastSampleKey(a2);
    v7 = **(_DWORD **)(a1 + 16);
    goto LABEL_7;
  }
  v7 = **(_DWORD **)(a1 + 16);
  if (v6)
    v8 = 0;
  else
    v8 = v7 == 1;
  if (v8)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&v33, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(_QWORD *)(a1 + 24));
    v14 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v35, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v33, (uint64_t)v35);
    v15 = v37;
    if (v37 == v35)
    {
      v16 = 4;
      v15 = v35;
    }
    else
    {
      if (!v37)
      {
LABEL_26:
        if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_29;
        v13 = (void *)v33.__r_.__value_.__r.__words[0];
        goto LABEL_28;
      }
      v16 = 5;
    }
    (*(void (**)(void))(*v15 + 8 * v16))();
    goto LABEL_26;
  }
LABEL_7:
  if (v7 == 2)
  {
    if (!**(_BYTE **)(a1 + 48))
      goto LABEL_29;
    v11 = *(_QWORD *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v35, "object_id \t sample_number \t timestamp \t data");
    v12 = *(_QWORD *)(v11 + 24);
    if (!v12)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v12 + 48))(v12, v35);
  }
  else
  {
    if (v7)
      goto LABEL_29;
    _HDSampleHistoryDescriptionForObjectType(**(_QWORD **)(a1 + 24), v35);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 40), &v33);
    health::timestampToDate(*(double *)(*(_QWORD *)(a1 + 8) + 48), v30);
    v9 = *(_QWORD *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v35, *(_QWORD *)(a1 + 24), (uint64_t)&v29, (uint64_t)&v33, (uint64_t)v30);
    v10 = *(_QWORD *)(v9 + 24);
    if (!v10)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (v31 < 0)
      operator delete(v30[0]);
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (v36 < 0)
  {
    v13 = (void *)v35[0];
LABEL_28:
    operator delete(v13);
  }
LABEL_29:
  v17 = *(_QWORD *)(a1 + 56);
  v18 = *(_QWORD *)(a1 + 40);
  v20 = *(_QWORD *)(a1 + 16);
  v19 = *(_QWORD *)(a1 + 24);
  v21 = (std::string *)operator new(0x28uLL);
  v21->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E6CF8538;
  v21->__r_.__value_.__l.__size_ = v17;
  v21->__r_.__value_.__r.__words[2] = v20;
  v21[1].__r_.__value_.__r.__words[0] = v18;
  v21[1].__r_.__value_.__l.__size_ = v19;
  v34 = v21;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(a2, (uint64_t)&v33);
  v22 = v34;
  if (v34 == &v33)
  {
    v23 = 4;
    v22 = &v33;
    goto LABEL_33;
  }
  if (v34)
  {
    v23 = 5;
LABEL_33:
    (*(void (**)(void))(v22->__r_.__value_.__r.__words[0] + 8 * v23))();
  }
  v24 = *(_QWORD **)(a1 + 56);
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24) = *v24;
  if (**(_DWORD **)(a1 + 16) == 1 && *v24 != v29)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(_QWORD *)(a1 + 24), (uint64_t)v24, (uint64_t)&v29);
    v25 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v30, *(_QWORD *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v25, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v30);
    v26 = v32;
    if (v32 == v30)
    {
      v27 = 4;
      v26 = v30;
    }
    else
    {
      if (!v32)
        goto LABEL_41;
      v27 = 5;
    }
    (*((void (**)(void))*v26 + v27))();
LABEL_41:
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1B7A78AA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t *a37)
{
  uint64_t *v37;
  uint64_t *v39;
  uint64_t v40;

  v39 = a37;
  if (a37 == v37)
  {
    v40 = 4;
    v39 = &a31;
  }
  else
  {
    if (!a37)
      goto LABEL_6;
    v40 = 5;
  }
  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_6:
  if (a29 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::firstSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  std::logic_error *exception;
  _OWORD v6[26];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v2 = a1[2];
  v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  return *(double *)v6;
}

void sub_1B7A78D00(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::lastSampleKey(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t **v4;
  int v5;
  uint64_t v6;
  std::logic_error *exception;
  uint64_t v9[2];
  _QWORD *v10;
  _QWORD v11[2];
  uint64_t *v12;
  _OWORD __src[28];
  _OWORD __dst[26];

  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  v12 = v1;
  v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  v3 = WORD4(__dst[25]);
  if (!WORD4(__dst[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!BYTE10(__dst[25]))
  {
    v5 = 0;
    while (WORD4(__dst[25]))
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(WORD4(__dst[25]) - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (BYTE10(__dst[25]))
      {
        v3 = WORD4(__dst[25]);
        v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E6CE6210, MEMORY[0x1E0DE42E0]);
  }
  v4 = &v12;
LABEL_9:
  v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  memset(__src, 0, 410);
  memset(&__src[26], 0, 32);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*v4, *(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__src, WORD4(__src[25]) - 1);
}

void sub_1B7A78F08(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EED0Ev()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEv(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E6CF8538;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEPNS0_6__baseIS11_EE(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF8538;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EEclESX_S10_(uint64_t a1, double *a2, __int128 *a3)
{
  double v3;
  _QWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v11[2];
  char v12;
  std::string __p;
  __int128 v14;
  __int128 *v15;
  void **v16;
  _QWORD *v17;
  uint64_t v18;

  v3 = *a2;
  v14 = *a3;
  v4 = *(_QWORD **)(a1 + 8);
  ++*v4;
  v5 = **(_DWORD **)(a1 + 16);
  if (v5 == 2)
  {
    v8 = *(_QWORD *)(a1 + 24);
    v9 = *(_QWORD *)(a1 + 32);
    health::doubleToString((health *)9, v11);
    v15 = &v14;
    v16 = v11;
    v17 = v4;
    v18 = v9;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v15);
    v7 = *(_QWORD *)(v8 + 24);
    if (!v7)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  else
  {
    if (v5)
      return 1;
    v6 = *(_QWORD *)(a1 + 24);
    health::timestampToDate(v3, v11);
    v15 = &v14;
    v16 = v11;
    v17 = v4;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v15);
    v7 = *(_QWORD *)(v6 + 24);
    if (!v7)
      std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v7 + 48))(v7, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v12 < 0)
    operator delete(v11[0]);
  return 1;
}

void sub_1B7A790E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  std::string::size_type v13;
  std::string::size_type v14;
  char *v15;
  std::string::size_type size;
  std::string::size_type v17;
  std::string::size_type v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  char *v24;
  int v25;
  std::runtime_error *exception;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  char *v31;
  std::string __p;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v31 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v31 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v31 = i + 2;
    v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v23 = 0;
      v24 = i + 3;
      do
      {
        v31 = v24;
        v23 = (v22 - 48) + 10 * v23;
        v25 = *v24++;
        v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      v31 = v24;
      if (*(v24 - 1) == 125)
        health::FormatterParameters<0ul,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v23);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_56;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  v12 = v31;
  if (!*((_QWORD *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __p.__r_.__value_.__l.__size_;
    v17 = *((_QWORD *)&v28 + 1);
    if (*((_QWORD *)&v28 + 1) <= size)
      v17 = size;
    if ((_BYTE)v28)
      size = v17;
    health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, size + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_32:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (!v8)
      return;
LABEL_35:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((_QWORD *)&v27 + 1) != 1)
  {
    if (*((_QWORD *)&v27 + 1) == 2)
    {
      health::FormatString<double const&,float const&>(&__p, *a4, *a4 + 8);
      v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v13 = __p.__r_.__value_.__l.__size_;
      v14 = *((_QWORD *)&v28 + 1);
      if (*((_QWORD *)&v28 + 1) <= v13)
        v14 = v13;
      if ((_BYTE)v28)
        v13 = v14;
      health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_32;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_56:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  v18 = a4[1];
  __p.__r_.__value_.__r.__words[0] = v18;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v27;
  v33 = v28;
  v34 = v29;
  v35 = v30;
  if (*(char *)(v18 + 23) < 0)
    v19 = *(_QWORD *)(v18 + 8);
  else
    v19 = *(unsigned __int8 *)(v18 + 23);
  v20 = *((_QWORD *)&v28 + 1);
  if (*((_QWORD *)&v28 + 1) <= v19)
    v20 = v19;
  if ((_BYTE)v28)
    v19 = v20;
  health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = (char *)a2;
  else
    v21 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8)
    goto LABEL_35;
}

void sub_1B7A794CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawQuantitySampleValueV1 &>(uint64_t a1)
{
  std::runtime_error *v2;
  std::runtime_error *exception;

  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v2 = exception;
    if (a1 == 2)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A795A8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<double const&,float const&>(std::string *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3[2];

  v3[0] = a3;
  v3[1] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<double const&,float const&>((std::string *)"(Value: {0}, Duration: {1})", a1, 0, v3);
}

void sub_1B7A79610(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<double const&,float const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  std::runtime_error *exception;
  _BYTE v23[8];
  uint64_t v24;
  char v25;
  unint64_t v26;
  char *v27;
  void *__p;
  unint64_t v29;
  unsigned __int8 v30;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v27 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v27 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v27 = i + 2;
    v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v19 = 0;
      v20 = i + 3;
      do
      {
        v27 = v20;
        v19 = (v18 - 48) + 10 * v19;
        v21 = *v20++;
        v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      v27 = v20;
      if (*(v20 - 1) == 125)
        health::FormatterParameters<0ul,double const&,float const&>::formatOptionsAtIndex<double const&,float const&>(v19);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_43;
  }
  health::FormatOptions::FormatOptions((uint64_t)v23, (const char **)&v27);
  v12 = v27;
  if (v24)
  {
    if (v24 == 1)
    {
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v23);
      v13 = v30;
      if ((v30 & 0x80u) != 0)
        v13 = v29;
      v14 = v26;
      if (v26 <= v13)
        v14 = v13;
      if (v25)
        v13 = v14;
      health::FormatImplementation<double const&,float const&>(v12, a2, v13 + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_31;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_43:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v23);
  v16 = v30;
  if ((v30 & 0x80u) != 0)
    v16 = v29;
  v17 = v26;
  if (v26 <= v16)
    v17 = v16;
  if (v25)
    v16 = v17;
  health::FormatImplementation<double const&,float const&>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = (char *)a2;
  else
    v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_31:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v23, &v15[a3 - v8], (const void **)&__p);
  if ((char)v30 < 0)
    operator delete(__p);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7A79908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,double const&,float const&>::formatOptionsAtIndex<double const&,float const&>(uint64_t a1)
{
  std::runtime_error *v1;
  std::runtime_error *exception;

  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v1 = exception;
    if (a1 == 1)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A799C0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  std::string::size_type size;
  std::string::size_type v14;
  char *v15;
  std::string::size_type v16;
  unint64_t v17;
  std::string::size_type v18;
  std::string::size_type v19;
  std::string::size_type v20;
  std::string::size_type v21;
  unint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  std::runtime_error *exception;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  std::string __p;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v33 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        v12 = v33;
        switch(*((_QWORD *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = __p.__r_.__value_.__l.__size_;
            v14 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= size)
              v14 = size;
            if ((_BYTE)v30)
              size = v14;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, size + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v18 = __p.__r_.__value_.__l.__size_;
            v19 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v18)
              v19 = v18;
            if ((_BYTE)v30)
              v18 = v19;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_41;
          case 2:
            v16 = a4[1];
            __p.__r_.__value_.__r.__words[0] = v16;
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v29;
            v35 = v30;
            v36 = v31;
            v37 = v32;
            if (*(char *)(v16 + 23) < 0)
              v17 = *(_QWORD *)(v16 + 8);
            else
              v17 = *(unsigned __int8 *)(v16 + 23);
            v22 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v17)
              v22 = v17;
            if ((_BYTE)v30)
              v17 = v22;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v23 = (char *)a2;
            else
              v23 = (char *)a2->__r_.__value_.__r.__words[0];
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8)
              return;
            goto LABEL_44;
          case 3:
            health::FormatString<double const&,float const&>(&__p, *a4, *a4 + 8);
            v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v20 = __p.__r_.__value_.__l.__size_;
            v21 = *((_QWORD *)&v30 + 1);
            if (*((_QWORD *)&v30 + 1) <= v20)
              v21 = v20;
            if ((_BYTE)v30)
              v20 = v21;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_41:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            if (v8)
LABEL_44:
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_63;
        }
      }
      v33 = i + 2;
      v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v25 = 0;
        v26 = i + 3;
        do
        {
          v33 = v26;
          v25 = (v24 - 48) + 10 * v25;
          v27 = *v26++;
          v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        v33 = v26;
        if (*(v26 - 1) == 125)
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v25);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_63:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v33 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A79DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3)
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A79ECC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &off_1E6CF85C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &off_1E6CF85C8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  std::string::size_type v3;
  std::string::size_type v4;
  void **v5;
  uint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  void **v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  std::string *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void **v41;
  uint64_t v42;
  std::string **v43;
  unint64_t v44;
  std::string *v45;
  std::string *v46;
  std::string *v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  std::string *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  std::logic_error *exception;
  std::string __p;
  std::string v59;
  uint64_t v60;
  double v61;
  double v62;
  uint64_t v63;
  uint64_t v64;
  void *v65[2];
  char v66;
  void **v67;
  std::string v68;
  std::string *v69;
  void **v70;
  std::string::size_type v71;
  std::string::size_type v72;
  void *v73[2];
  char v74;
  void **v75;
  _BYTE v76[24];
  _BYTE *v77;
  uint64_t v78;

  v6 = a2;
  v78 = *MEMORY[0x1E0C80C00];
  v8 = *a3;
  v9 = a3[1];
  v10 = *(uint64_t **)(a1 + 16);
  ++**(_DWORD **)(a1 + 8);
  v61 = -1.0;
  v62 = -1.0;
  v60 = -1;
  switch(*a2)
  {
    case 0:
      v11 = a2[1];
      v12 = *v10;
      v63 = 0;
      v64 = v11;
      v13 = operator new(0x20uLL);
      *v13 = &off_1E6CF8648;
      v13[1] = &v60;
      v13[2] = &v62;
      v13[3] = &v61;
      v77 = v13;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(v12, (uint64_t)&v63, (uint64_t)v76);
      break;
    case 1:
      v20 = a2[1];
      v21 = *v10;
      v63 = 1;
      v64 = v20;
      v22 = operator new(0x20uLL);
      *v22 = &off_1E6CF8748;
      v22[1] = &v60;
      v22[2] = &v62;
      v22[3] = &v61;
      v77 = v22;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(v21, (uint64_t)&v63, (uint64_t)v76);
      break;
    case 2:
      v14 = a2[1];
      v15 = *v10;
      v63 = 2;
      v64 = v14;
      v16 = operator new(0x20uLL);
      *v16 = &off_1E6CF87C8;
      v16[1] = &v60;
      v16[2] = &v62;
      v16[3] = &v61;
      v77 = v16;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(v15, (uint64_t)&v63, (uint64_t)v76);
      break;
    case 3:
      v17 = a2[1];
      v18 = *v10;
      v63 = 3;
      v64 = v17;
      v19 = operator new(0x20uLL);
      *v19 = &off_1E6CF86C8;
      v19[1] = &v60;
      v19[2] = &v62;
      v19[3] = &v61;
      v77 = v19;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(v18, (uint64_t)&v63, (uint64_t)v76);
      break;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Unexpected object type");
      __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
  v23 = v77;
  if (v77 == v76)
  {
    v24 = 4;
    v23 = v76;
  }
  else
  {
    if (!v77)
      goto LABEL_11;
    v24 = 5;
  }
  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_11:
  v25 = **(_DWORD **)(a1 + 24);
  if (v25)
  {
    if (v25 == 2)
    {
      v30 = **(_DWORD **)(a1 + 8) == 1;
      v32 = *v6;
      v31 = v6[1];
      std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)&v68, *(_QWORD *)(a1 + 32));
      health::DataStoreInspector::enumerateSampleHistoryForPrinting(v10, v32, v31, (uint64_t)&v68, **(_DWORD **)(a1 + 24), v30);
      v33 = v69;
      if (v69 == &v68)
      {
        v34 = 4;
        v33 = &v68;
      }
      else
      {
        if (!v69)
          return;
        v34 = 5;
      }
      (*(void (**)(void))(v33->__r_.__value_.__r.__words[0] + 8 * v34))();
      return;
    }
    if (v25 != 1)
      return;
    v26 = *v6;
    if ((unint64_t)*v6 < 4)
      goto LABEL_37;
    health::FormatString<health::DataStore::ObjectIdentifier const&>((std::string *)"HFD object [ID: {0}] type is not expected", (uint64_t)v6, &v68);
    v27 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v73, *(_QWORD *)(a1 + 32));
    health::DataStoreInspector::_errorHandler(v27, 1, v8, v9, (std::string::size_type)&v68, (uint64_t)v73);
    v28 = v75;
    if (v75 == v73)
    {
      v29 = 4;
      v28 = v73;
    }
    else
    {
      if (!v75)
      {
LABEL_34:
        if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v68.__r_.__value_.__l.__data_);
        v26 = *v6;
LABEL_37:
        *(_OWORD *)&v59.__r_.__value_.__l.__data_ = 0uLL;
        switch(v26)
        {
          case 0:
            v37 = v6[1];
            std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v65, *(_QWORD *)(a1 + 32));
            health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>((uint64_t)&v68, v10, 0, v37, (uint64_t)v65, **(_DWORD **)(a1 + 24), 1);
            goto LABEL_42;
          case 1:
            v40 = v6[1];
            std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v65, *(_QWORD *)(a1 + 32));
            health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>((uint64_t)&v68, v10, 1, v40, (uint64_t)v65, **(_DWORD **)(a1 + 24), 1);
            goto LABEL_42;
          case 2:
            v38 = v6[1];
            std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v65, *(_QWORD *)(a1 + 32));
            health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>((uint64_t)&v68, v10, 2, v38, (uint64_t)v65, **(_DWORD **)(a1 + 24), 1);
            goto LABEL_42;
          case 3:
            v39 = v6[1];
            std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v65, *(_QWORD *)(a1 + 32));
            health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>((uint64_t)&v68, v10, 3, v39, (uint64_t)v65, **(_DWORD **)(a1 + 24), 1);
LABEL_42:
            v59 = v68;
            v6 = (uint64_t *)v69;
            v5 = v70;
            v3 = v71;
            v4 = v72;
            v41 = v67;
            if (v67 == v65)
            {
              v42 = 4;
              v41 = v65;
            }
            else
            {
              if (!v67)
                goto LABEL_47;
              v42 = 5;
            }
            (*((void (**)(void))*v41 + v42))();
LABEL_47:
            v43 = *(std::string ***)(a1 + 40);
            v45 = v43[1];
            v44 = (unint64_t)v43[2];
            if ((unint64_t)v45 >= v44)
            {
              v47 = *v43;
              v48 = 0x6DB6DB6DB6DB6DB7 * (((char *)v45 - (char *)*v43) >> 3);
              v49 = v48 + 1;
              if ((unint64_t)(v48 + 1) > 0x492492492492492)
                std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
              v50 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v44 - (_QWORD)v47) >> 3);
              if (2 * v50 > v49)
                v49 = 2 * v50;
              if (v50 >= 0x249249249249249)
                v51 = 0x492492492492492;
              else
                v51 = v49;
              if (v51)
              {
                if (v51 > 0x492492492492492)
                  std::__throw_bad_array_new_length[abi:ne180100]();
                v52 = (char *)operator new(56 * v51);
              }
              else
              {
                v52 = 0;
              }
              v53 = (std::string *)&v52[56 * v48];
              *v53 = v59;
              v53[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
              v53[1].__r_.__value_.__l.__size_ = (std::string::size_type)v5;
              v53[1].__r_.__value_.__r.__words[2] = v3;
              v53[2].__r_.__value_.__r.__words[0] = v4;
              v46 = (std::string *)((char *)v53 + 56);
              if (v45 != v47)
              {
                do
                {
                  v54 = *(_OWORD *)&v45[-3].__r_.__value_.__r.__words[2];
                  v55 = *(_OWORD *)&v45[-2].__r_.__value_.__r.__words[1];
                  v56 = *(_OWORD *)&v45[-1].__r_.__value_.__l.__data_;
                  v53[-1].__r_.__value_.__r.__words[2] = v45[-1].__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v53[-1].__r_.__value_.__l.__data_ = v56;
                  *(_OWORD *)&v53[-2].__r_.__value_.__r.__words[1] = v55;
                  *(_OWORD *)&v53[-3].__r_.__value_.__r.__words[2] = v54;
                  v53 = (std::string *)((char *)v53 - 56);
                  v45 = (std::string *)((char *)v45 - 56);
                }
                while (v45 != v47);
                v45 = *v43;
              }
              *v43 = v53;
              v43[1] = v46;
              v43[2] = (std::string *)&v52[56 * v51];
              if (v45)
                operator delete(v45);
            }
            else
            {
              *v45 = v59;
              v45[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
              v45[1].__r_.__value_.__l.__size_ = (std::string::size_type)v5;
              v45[1].__r_.__value_.__r.__words[2] = v3;
              v45[2].__r_.__value_.__r.__words[0] = v4;
              v46 = (std::string *)((char *)v45 + 56);
            }
            v43[1] = v46;
            break;
          default:
            goto LABEL_47;
        }
        return;
      }
      v29 = 5;
    }
    (*((void (**)(void))*v28 + v29))();
    goto LABEL_34;
  }
  _HDSampleHistoryDescriptionForObjectType(*v6, v73);
  health::timestampToDate(v62, v65);
  health::timestampToDate(v61, &v59);
  v35 = *(_QWORD *)(a1 + 32);
  v68.__r_.__value_.__r.__words[0] = (std::string::size_type)&v59;
  v68.__r_.__value_.__l.__size_ = (std::string::size_type)v65;
  v68.__r_.__value_.__r.__words[2] = (std::string::size_type)&v60;
  v69 = (std::string *)v6;
  v70 = v73;
  memset(&__p, 0, sizeof(__p));
  health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>((std::string *)"'{0}' [ID: {1} | Count: {2} | {3} to {4}]", &__p, 0, (uint64_t *)&v68);
  v36 = *(_QWORD *)(v35 + 24);
  if (!v36)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v36 + 48))(v36, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v59.__r_.__value_.__l.__data_);
  if (v66 < 0)
    operator delete(v65[0]);
  if (v74 < 0)
    operator delete(v73[0]);
}

void sub_1B7A7A660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void **a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void **a40)
{
  uint64_t v40;
  uint64_t *v41;
  void **v42;
  void **v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void **p_p;
  uint64_t v52;

  v45 = a33;
  if (a33 == v42)
  {
    v46 = 4;
    v45 = &a27;
  }
  else
  {
    if (!a33)
      goto LABEL_6;
    v46 = 5;
  }
  (*((void (**)(void))*v45 + v46))();
LABEL_6:
  if (a2 != 2)
    _Unwind_Resume(exception_object);
  v47 = __cxa_begin_catch(exception_object);
  v48 = *v41;
  v49 = v41[1];
  v50 = std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)&__p, *(_QWORD *)(v40 + 32));
  health::DataStoreInspector::_unknownBehaviorHandler(v50, v48, v49, (uint64_t)v47, (uint64_t)&__p);
  p_p = a40;
  if (a40 == &__p)
  {
    v52 = 4;
    p_p = &__p;
  }
  else
  {
    if (!a40)
    {
LABEL_12:
      __cxa_end_catch();
      JUMPOUT(0x1B7A7A498);
    }
    v52 = 5;
  }
  (*((void (**)(void))*p_p + v52))();
  goto LABEL_12;
}

uint64_t std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::target_type()
{
}

void health::FormatString<health::DataStore::ObjectIdentifier const&>(std::string *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v3;

  v3 = a2;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier const&>(a1, a3, 0, &v3);
}

void sub_1B7A7A968(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CF8648;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF8648;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  double SampleKey;
  uint64_t v6;
  double v7;

  v3 = a2[6];
  **(_QWORD **)(a1 + 8) = v3;
  if (v3 <= 0)
  {
    **(_QWORD **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  SampleKey = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::firstSampleKey(a2);
  v6 = **(_QWORD **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    v7 = 0.0;
    goto LABEL_6;
  }
  v7 = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target_type()
{
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CF86C8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF86C8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  double SampleKey;
  uint64_t v6;
  double v7;

  v3 = a2[6];
  **(_QWORD **)(a1 + 8) = v3;
  if (v3 <= 0)
  {
    **(_QWORD **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  SampleKey = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::firstSampleKey(a2);
  v6 = **(_QWORD **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    v7 = 0.0;
    goto LABEL_6;
  }
  v7 = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target_type()
{
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CF8748;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF8748;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  double SampleKey;
  uint64_t v6;
  double v7;

  v3 = a2[6];
  **(_QWORD **)(a1 + 8) = v3;
  if (v3 <= 0)
  {
    **(_QWORD **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  SampleKey = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::firstSampleKey(a2);
  v6 = **(_QWORD **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    v7 = 0.0;
    goto LABEL_6;
  }
  v7 = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target_type()
{
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::~__func()
{
  JUMPOUT(0x1BCCAC494);
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E6CF87C8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E6CF87C8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  double SampleKey;
  uint64_t v6;
  double v7;

  v3 = a2[6];
  **(_QWORD **)(a1 + 8) = v3;
  if (v3 <= 0)
  {
    **(_QWORD **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  SampleKey = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::firstSampleKey(a2);
  v6 = **(_QWORD **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    v7 = 0.0;
    goto LABEL_6;
  }
  v7 = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target_type()
{
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier const&>(std::string *a1, std::string *this, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  int v12;
  uint64_t v13;
  char *v14;
  int v15;
  std::runtime_error *exception;
  _BYTE v17[8];
  uint64_t v18;
  char *v19;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v19 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v19 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v19 = i + 2;
    v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v13 = 0;
      v14 = i + 3;
      do
      {
        v19 = v14;
        v13 = (v12 - 48) + 10 * v13;
        v15 = *v14++;
        v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      v19 = v14;
      if (*(v14 - 1) == 125)
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>((uint64_t)a4, (uint64_t)a4, v13);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v19);
  health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatParameterAtIndex<health::DataStore::ObjectIdentifier const&>(a4, (uint64_t)a4, v18, v17, this, a3 - v8, (int)v19);
  if (v8)
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
}

void sub_1B7A7B058(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::runtime_error *exception;

  if (a3)
    health::FormatterParameters<1ul>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>();
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7B0BC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatParameterAtIndex<health::DataStore::ObjectIdentifier const&>(uint64_t *a1, uint64_t a2, uint64_t a3, _BYTE *a4, std::string *a5, uint64_t a6, int a7)
{
  char *v11;
  void *__p;
  char v13;

  if (a3)
    health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>>();
  health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter((uint64_t)&__p, *a1, (uint64_t)a4);
  health::FormatImplementation<health::DataStore::ObjectIdentifier const&>(a7, a5);
  if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = (char *)a5;
  else
    v11 = (char *)a5->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(a4, &v11[a6], (const void **)&__p);
  if (v13 < 0)
    operator delete(__p);
}

void sub_1B7A7B1C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<1ul>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7B220(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7B270(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  health::operator<<(&v12);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B7A7B404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  char *v26;
  int v27;
  std::runtime_error *exception;
  _BYTE v29[8];
  uint64_t v30;
  char v31;
  unint64_t v32;
  char *v33;
  void *__p;
  unint64_t v35;
  unsigned __int8 v36;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v33 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v29, (const char **)&v33);
        v12 = v33;
        switch(v30)
        {
          case 0:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v29);
            v13 = v36;
            if ((v36 & 0x80u) != 0)
              v13 = v35;
            v14 = v32;
            if (v32 <= v13)
              v14 = v13;
            if (v31)
              v13 = v14;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 1:
            health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v29);
            v16 = v36;
            if ((v36 & 0x80u) != 0)
              v16 = v35;
            v17 = v32;
            if (v32 <= v16)
              v17 = v16;
            if (v31)
              v16 = v17;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 2:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v29);
            v18 = v36;
            if ((v36 & 0x80u) != 0)
              v18 = v35;
            v19 = v32;
            if (v32 <= v18)
              v19 = v18;
            if (v31)
              v18 = v19;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v29);
            v20 = v36;
            if ((v36 & 0x80u) != 0)
              v20 = v35;
            v21 = v32;
            if (v32 <= v20)
              v21 = v20;
            if (v31)
              v20 = v21;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_57;
          case 4:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v29);
            v22 = v36;
            if ((v36 & 0x80u) != 0)
              v22 = v35;
            v23 = v32;
            if (v32 <= v22)
              v23 = v22;
            if (v31)
              v22 = v23;
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v22 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_57:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v29, &v15[a3 + v8], (const void **)&__p);
            if ((char)v36 < 0)
              operator delete(__p);
            if (v8)
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_69;
        }
      }
      v33 = i + 2;
      v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v25 = 0;
        v26 = i + 3;
        do
        {
          v33 = v26;
          v25 = (v24 - 48) + 10 * v25;
          v27 = *v26++;
          v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        v33 = v26;
        if (*(v26 - 1) == 125)
          health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v25);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_69:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v33 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7B894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 4)
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      else
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7B9DC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<int &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  char *v18;
  int v19;
  std::runtime_error *exception;
  char v21[8];
  uint64_t v22;
  char v23;
  unint64_t v24;
  char *v25;
  void *__p[2];
  unsigned __int8 v27;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v25 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v25 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v25 = i + 2;
    v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v17 = 0;
      v18 = i + 3;
      do
      {
        v25 = v18;
        v17 = (v16 - 48) + 10 * v17;
        v19 = *v18++;
        v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      v25 = v18;
      if (*(v18 - 1) == 125)
        health::FormatterParameters<0ul,int &>::formatOptionsAtIndex<int &>(v17);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_33:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_33;
  }
  v12 = v25;
  health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  v13 = v27;
  if ((v27 & 0x80u) != 0)
    v13 = (unint64_t)__p[1];
  v14 = v24;
  if (v24 <= v13)
    v14 = v13;
  if (v23)
    v13 = v14;
  health::FormatImplementation<int &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = (char *)a2;
  else
    v15 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0)
    operator delete(__p[0]);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7A7BC5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,int &>::formatOptionsAtIndex<int &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  v3 = exception;
  if (a1)
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  else
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(v3, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7BCF0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<int &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const std::ios_base *v6;
  std::ios_base::fmtflags v7;
  const std::locale::facet *v8;
  std::locale v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[10];
  char v14;
  uint64_t v15;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  v5 = v12;
  if (*(_BYTE *)(a3 + 16))
    *(_QWORD *)((char *)&v13[2] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(a3 + 24);
  if (*(_BYTE *)(a3 + 32))
    *(_QWORD *)((char *)&v13[1] + *(_QWORD *)(v5 - 24)) = *(_QWORD *)(a3 + 40);
  v6 = (const std::ios_base *)((char *)&v13[-1] + *(_QWORD *)(v5 - 24));
  v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    v8 = std::locale::use_facet(v10, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(_QWORD *)(a1 + 16) = v11;
  v12 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v13[-1] + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v13[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v14 < 0)
    operator delete((void *)v13[8]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BCCAC458](&v15);
  return a1;
}

void sub_1B7A7BE88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0)
    operator delete(*(void **)v13);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, _QWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  char *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (char *)operator new(0x60uLL);
    *((_QWORD *)v9 + 4) = *a3;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 72) = 0u;
    *((_QWORD *)v9 + 11) = 0;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t *result, unint64_t a2, uint64_t a3)
{
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;

  v4 = (uint64_t **)result;
  v6 = (uint64_t **)(result + 1);
  v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (uint64_t **)(result + 1);
LABEL_9:
    v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = a3;
    return std::__tree<unsigned long long>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

uint64_t std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = v5[4];
      v7 = *(_QWORD *)(a1 + 8);
      v8 = v3;
      if (*(_QWORD **)a1 == v3)
        goto LABEL_8;
      v9 = *(_QWORD **)(a1 + 8);
      v10 = v3;
      if (v7)
      {
        do
        {
          v8 = v9;
          v9 = (_QWORD *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v10[2];
          v11 = *v8 == (_QWORD)v10;
          v10 = v8;
        }
        while (v11);
      }
      if (v8[4] < v6)
      {
LABEL_8:
        if (v7)
          v12 = (uint64_t **)v8;
        else
          v12 = (uint64_t **)v3;
        if (v7)
          v13 = (uint64_t **)(v8 + 1);
        else
          v13 = (uint64_t **)v3;
        if (*v13)
          goto LABEL_25;
      }
      else
      {
        v13 = (uint64_t **)v3;
        v12 = (uint64_t **)v3;
        if (v7)
        {
          v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v14;
              v15 = v14[4];
              if (v15 <= v6)
                break;
              v14 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_24;
            }
            if (v15 >= v6)
              goto LABEL_25;
            v14 = v12[1];
            if (!v14)
            {
              v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      v16 = (uint64_t *)operator new(0x60uLL);
      v17 = *((_OWORD *)v5 + 2);
      v18 = *((_OWORD *)v5 + 3);
      v19 = *((_OWORD *)v5 + 5);
      *((_OWORD *)v16 + 4) = *((_OWORD *)v5 + 4);
      *((_OWORD *)v16 + 5) = v19;
      *((_OWORD *)v16 + 2) = v17;
      *((_OWORD *)v16 + 3) = v18;
      std::__tree<unsigned long long>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, v16);
LABEL_25:
      v20 = (_QWORD *)v5[1];
      if (v20)
      {
        do
        {
          v21 = v20;
          v20 = (_QWORD *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          v21 = (_QWORD *)v5[2];
          v11 = *v21 == (_QWORD)v5;
          v5 = v21;
        }
        while (!v11);
      }
      v5 = v21;
    }
    while (v21 != v4);
  }
  return a1;
}

void sub_1B7A7C190(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__tree<long>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t std::set<unsigned long long>::set[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t **)a1, v3, v5[4], v5[4]);
      v6 = (_QWORD *)v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v5[2];
          v8 = *v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

void sub_1B7A7C238(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__tree<long>::destroy(*v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  std::runtime_error *exception;
  _BYTE v25[8];
  uint64_t v26;
  char v27;
  unint64_t v28;
  char *v29;
  void *__p;
  unint64_t v31;
  unsigned __int8 v32;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v29 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v29 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v29 = i + 2;
    v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v21 = 0;
      v22 = i + 3;
      do
      {
        v29 = v22;
        v21 = (v20 - 48) + 10 * v21;
        v23 = *v22++;
        v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      v29 = v22;
      if (*(v22 - 1) == 125)
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,long long &>(v21);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_53;
  }
  health::FormatOptions::FormatOptions((uint64_t)v25, (const char **)&v29);
  v12 = v29;
  if (v26)
  {
    if (v26 != 1)
    {
      if (v26 == 2)
      {
        health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v25);
        v13 = v32;
        if ((v32 & 0x80u) != 0)
          v13 = v31;
        v14 = v28;
        if (v28 <= v13)
          v14 = v13;
        if (v27)
          v13 = v14;
        health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(v12, a2, v13 + a3 + v8, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v15 = (char *)a2;
        else
          v15 = (char *)a2->__r_.__value_.__r.__words[0];
        goto LABEL_41;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_53:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v25);
    v18 = v32;
    if ((v32 & 0x80u) != 0)
      v18 = v31;
    v19 = v28;
    if (v28 <= v18)
      v19 = v18;
    if (v27)
      v18 = v19;
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(v12, a2, v18 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  else
  {
    health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v25);
    v16 = v32;
    if ((v32 & 0x80u) != 0)
      v16 = v31;
    v17 = v28;
    if (v28 <= v16)
      v17 = v16;
    if (v27)
      v16 = v17;
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
LABEL_41:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v25, &v15[a3 + v8], (const void **)&__p);
  if ((char)v32 < 0)
    operator delete(__p);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7C5A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,long long &>(uint64_t a1)
{
  std::runtime_error *v2;
  std::runtime_error *exception;

  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v2 = exception;
    if (a1 == 2)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7C684(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  std::runtime_error *exception;
  _BYTE v25[8];
  uint64_t v26;
  char v27;
  unint64_t v28;
  char *v29;
  void *__p;
  unint64_t v31;
  unsigned __int8 v32;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v29 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v29 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v29 = i + 2;
    v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v21 = 0;
      v22 = i + 3;
      do
      {
        v29 = v22;
        v21 = (v20 - 48) + 10 * v21;
        v23 = *v22++;
        v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      v29 = v22;
      if (*(v22 - 1) == 125)
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v21);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_53;
  }
  health::FormatOptions::FormatOptions((uint64_t)v25, (const char **)&v29);
  v12 = v29;
  if (v26)
  {
    if (v26 != 1)
    {
      if (v26 == 2)
      {
        health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v25);
        v13 = v32;
        if ((v32 & 0x80u) != 0)
          v13 = v31;
        v14 = v28;
        if (v28 <= v13)
          v14 = v13;
        if (v27)
          v13 = v14;
        health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v15 = (char *)a2;
        else
          v15 = (char *)a2->__r_.__value_.__r.__words[0];
        goto LABEL_41;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_53:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v25);
    v18 = v32;
    if ((v32 & 0x80u) != 0)
      v18 = v31;
    v19 = v28;
    if (v28 <= v18)
      v19 = v18;
    if (v27)
      v18 = v19;
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  else
  {
    health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v25);
    v16 = v32;
    if ((v32 & 0x80u) != 0)
      v16 = v31;
    v17 = v28;
    if (v28 <= v16)
      v17 = v16;
    if (v27)
      v16 = v17;
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
LABEL_41:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v25, &v15[a3 + v8], (const void **)&__p);
  if ((char)v32 < 0)
    operator delete(__p);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7C9F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(uint64_t a1)
{
  std::runtime_error *v2;
  std::runtime_error *exception;

  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v2 = exception;
    if (a1 == 2)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7CADC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  char *v24;
  int v25;
  std::runtime_error *exception;
  _BYTE v27[8];
  uint64_t v28;
  char v29;
  unint64_t v30;
  char *v31;
  void *__p;
  unint64_t v33;
  unsigned __int8 v34;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v31 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v27, (const char **)&v31);
        v12 = v31;
        switch(v28)
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v27);
            v13 = v34;
            if ((v34 & 0x80u) != 0)
              v13 = v33;
            v14 = v30;
            if (v30 <= v13)
              v14 = v13;
            if (v29)
              v13 = v14;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_48;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v27);
            v18 = v34;
            if ((v34 & 0x80u) != 0)
              v18 = v33;
            v19 = v30;
            if (v30 <= v18)
              v19 = v18;
            if (v29)
              v18 = v19;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_48;
          case 2:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v27);
            v16 = v34;
            if ((v34 & 0x80u) != 0)
              v16 = v33;
            v17 = v30;
            if (v30 <= v16)
              v17 = v16;
            if (v29)
              v16 = v17;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_48;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v27);
            v20 = v34;
            if ((v34 & 0x80u) != 0)
              v20 = v33;
            v21 = v30;
            if (v30 <= v20)
              v21 = v20;
            if (v29)
              v20 = v21;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_48:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v27, &v15[a3 + v8], (const void **)&__p);
            if ((char)v34 < 0)
              operator delete(__p);
            if (v8)
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_60;
        }
      }
      v31 = i + 2;
      v22 = i[2];
      if ((v22 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v23 = 0;
        v24 = i + 3;
        do
        {
          v31 = v24;
          v23 = (v22 - 48) + 10 * v23;
          v25 = *v24++;
          v22 = v25;
        }
        while ((v25 - 58) >= 0xFFFFFFF6);
        v31 = v24;
        if (*(v24 - 1) == 125)
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v23);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_60:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v31 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7CED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3)
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7CFE0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  char *v28;
  int v29;
  std::runtime_error *exception;
  _BYTE v31[8];
  uint64_t v32;
  char v33;
  unint64_t v34;
  char *v35;
  void *__p;
  unint64_t v37;
  unsigned __int8 v38;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v35 = i;
    if (*i != 123)
      break;
    v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v31, (const char **)&v35);
        v12 = v35;
        switch(v32)
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[5], (uint64_t)v31);
            v13 = v38;
            if ((v38 & 0x80u) != 0)
              v13 = v37;
            v14 = v34;
            if (v34 <= v13)
              v14 = v13;
            if (v33)
              v13 = v14;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_66;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v31);
            v16 = v38;
            if ((v38 & 0x80u) != 0)
              v16 = v37;
            v17 = v34;
            if (v34 <= v16)
              v17 = v16;
            if (v33)
              v16 = v17;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_66;
          case 2:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v31);
            v18 = v38;
            if ((v38 & 0x80u) != 0)
              v18 = v37;
            v19 = v34;
            if (v34 <= v18)
              v19 = v18;
            if (v33)
              v18 = v19;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_66;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v31);
            v20 = v38;
            if ((v38 & 0x80u) != 0)
              v20 = v37;
            v21 = v34;
            if (v34 <= v20)
              v21 = v20;
            if (v33)
              v20 = v21;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_66;
          case 4:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v31);
            v22 = v38;
            if ((v38 & 0x80u) != 0)
              v22 = v37;
            v23 = v34;
            if (v34 <= v22)
              v23 = v22;
            if (v33)
              v22 = v23;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v22 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
            goto LABEL_66;
          case 5:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v31);
            v24 = v38;
            if ((v38 & 0x80u) != 0)
              v24 = v37;
            v25 = v34;
            if (v34 <= v24)
              v25 = v24;
            if (v33)
              v24 = v25;
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v24 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v15 = (char *)a2;
            else
              v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_66:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v31, &v15[a3 + v8], (const void **)&__p);
            if ((char)v38 < 0)
              operator delete(__p);
            if (v8)
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_78;
        }
      }
      v35 = i + 2;
      v26 = i[2];
      if ((v26 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        v27 = 0;
        v28 = i + 3;
        do
        {
          v35 = v28;
          v27 = (v26 - 48) + 10 * v27;
          v29 = *v28++;
          v26 = v29;
        }
        while ((v29 - 58) >= 0xFFFFFFF6);
        v35 = v28;
        if (*(v28 - 1) == 125)
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v27);
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_78:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    v35 = i + 1;
    v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i)
    goto LABEL_7;
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7D4CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(uint64_t a1)
{
  std::runtime_error *exception;
  std::runtime_error *v3;

  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 5)
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      else
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7D634(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>(std::string *a1, std::string *a2, std::string::size_type a3, char ***a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  std::string *v16;
  char *v17;
  char *v18;
  char *v19;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  std::runtime_error *exception;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  char *v29;
  void *__p;
  char *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v29 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v29 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v29 = i + 2;
    v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v21 = 0;
      v22 = i + 3;
      do
      {
        v29 = v22;
        v21 = (v20 - 48) + 10 * v21;
        v23 = *v22++;
        v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      v29 = v22;
      if (*(v22 - 1) == 125)
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,char const*>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,char const*>(v21);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_45;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v25, (const char **)&v29);
  v12 = v29;
  if (*((_QWORD *)&v25 + 1))
  {
    if (*((_QWORD *)&v25 + 1) == 1)
    {
      v13 = **a4;
      __p = v13;
      if (v13)
        v13 = (char *)strlen(v13);
      v31 = v13;
      v32 = v25;
      v33 = v26;
      v34 = v27;
      v35 = v28;
      v14 = (char *)*((_QWORD *)&v26 + 1);
      if (*((_QWORD *)&v26 + 1) <= (unint64_t)v13)
        v14 = v13;
      if ((_BYTE)v26)
        v15 = v14;
      else
        v15 = v13;
      health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>(v29, a2, &v15[a3 - v8], a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v16 = a2;
      else
        v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v25, (_BYTE *)v16 + a3 - v8, (uint64_t)&__p);
      goto LABEL_35;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_45:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[1], (uint64_t)&v25);
  v17 = (char *)BYTE7(v32);
  if (SBYTE7(v32) < 0)
    v17 = v31;
  v18 = (char *)*((_QWORD *)&v26 + 1);
  if (*((_QWORD *)&v26 + 1) <= (unint64_t)v17)
    v18 = v17;
  if ((_BYTE)v26)
    v17 = v18;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>(v12, a2, &v17[a3 - v8], a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = (char *)a2;
  else
    v19 = (char *)a2->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v25, &v19[a3 - v8], (const void **)&__p);
  if (SBYTE7(v32) < 0)
    operator delete(__p);
LABEL_35:
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7A7D950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,char const*>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,char const*>(uint64_t a1)
{
  std::runtime_error *v1;
  std::runtime_error *exception;

  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v1 = exception;
    if (a1 == 1)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7DA04(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &,std::string const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  std::runtime_error *exception;
  _BYTE v23[8];
  uint64_t v24;
  char v25;
  unint64_t v26;
  char *v27;
  void *__p;
  unint64_t v29;
  unsigned __int8 v30;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v27 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v27 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v27 = i + 2;
    v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v19 = 0;
      v20 = i + 3;
      do
      {
        v27 = v20;
        v19 = (v18 - 48) + 10 * v19;
        v21 = *v20++;
        v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      v27 = v20;
      if (*(v20 - 1) == 125)
        health::FormatterParameters<0ul,std::string &,std::string const&>::formatOptionsAtIndex<std::string &,std::string const&>(v19);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_43;
  }
  health::FormatOptions::FormatOptions((uint64_t)v23, (const char **)&v27);
  v12 = v27;
  if (v24)
  {
    if (v24 == 1)
    {
      health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v23);
      v13 = v30;
      if ((v30 & 0x80u) != 0)
        v13 = v29;
      v14 = v26;
      if (v26 <= v13)
        v14 = v13;
      if (v25)
        v13 = v14;
      health::FormatImplementation<std::string &,std::string const&>(v12, a2, v13 + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = (char *)a2;
      else
        v15 = (char *)a2->__r_.__value_.__r.__words[0];
      goto LABEL_31;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_43:
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v23);
  v16 = v30;
  if ((v30 & 0x80u) != 0)
    v16 = v29;
  v17 = v26;
  if (v26 <= v16)
    v17 = v16;
  if (v25)
    v16 = v17;
  health::FormatImplementation<std::string &,std::string const&>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = (char *)a2;
  else
    v15 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_31:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v23, &v15[a3 - v8], (const void **)&__p);
  if ((char)v30 < 0)
    operator delete(__p);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
}

void sub_1B7A7DCFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,std::string const&>::formatOptionsAtIndex<std::string &,std::string const&>(uint64_t a1)
{
  std::runtime_error *v1;
  std::runtime_error *exception;

  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v1 = exception;
    if (a1 == 1)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7DDBC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8;
  char v9;
  char *i;
  int v11;
  char *v12;
  std::string::size_type size;
  std::string::size_type v14;
  char *v15;
  std::string::size_type v16;
  std::string::size_type v17;
  std::string::size_type v18;
  std::string::size_type v19;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  std::runtime_error *exception;
  _BYTE v25[8];
  uint64_t v26;
  char v27;
  std::string::size_type v28;
  char *v29;
  std::string __p;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v29 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      return;
    }
LABEL_7:
    ++v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v29 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v29 = i + 2;
    v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v21 = 0;
      v22 = i + 3;
      do
      {
        v29 = v22;
        v21 = (v20 - 48) + 10 * v21;
        v23 = *v22++;
        v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      v29 = v22;
      if (*(v22 - 1) == 125)
        health::FormatterParameters<0ul,std::string &,health::BlockPointer &,std::string const&>::formatOptionsAtIndex<std::string &,health::BlockPointer &,std::string const&>(v21);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_53;
  }
  health::FormatOptions::FormatOptions((uint64_t)v25, (const char **)&v29);
  v12 = v29;
  if (v26)
  {
    if (v26 != 1)
    {
      if (v26 == 2)
      {
        health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v25);
        size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          size = __p.__r_.__value_.__l.__size_;
        v14 = v28;
        if (v28 <= size)
          v14 = size;
        if (v27)
          size = v14;
        health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(v12, a2, size + a3 + v8, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v15 = (char *)a2;
        else
          v15 = (char *)a2->__r_.__value_.__r.__words[0];
        goto LABEL_41;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_53:
      __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
    }
    health::FormatString<unsigned long long const&,unsigned long long const&>((std::string *)"({0}: {1})", a4[1], a4[1] + 8, &__p);
    v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v18 = __p.__r_.__value_.__l.__size_;
    v19 = v28;
    if (v28 <= v18)
      v19 = v18;
    if (v27)
      v18 = v19;
    health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(v12, a2, v18 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  else
  {
    health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v25);
    v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v16 = __p.__r_.__value_.__l.__size_;
    v17 = v28;
    if (v28 <= v16)
      v17 = v16;
    if (v27)
      v16 = v17;
    health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = (char *)a2;
    else
      v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
LABEL_41:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v25, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v8)
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
}

void sub_1B7A7E134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,health::BlockPointer &,std::string const&>::formatOptionsAtIndex<std::string &,health::BlockPointer &,std::string const&>(uint64_t a1)
{
  std::runtime_error *v2;
  std::runtime_error *exception;

  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v2 = exception;
    if (a1 == 2)
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    else
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else
  {
    v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7E21C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<unsigned long long const&,unsigned long long const&>(std::string *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  uint64_t v4[2];

  v4[0] = a3;
  v4[1] = a2;
  a4->__r_.__value_.__l.__size_ = 0;
  a4->__r_.__value_.__r.__words[2] = 0;
  a4->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned long long const&,unsigned long long const&>(a1, a4, 0, v4);
}

void sub_1B7A7E27C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<unsigned long long const&,unsigned long long const&>(std::string *a1, std::string *this, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8;
  char v9;
  char *i;
  int v11;
  int v12;
  uint64_t v13;
  char *v14;
  int v15;
  std::runtime_error *exception;
  _BYTE v17[8];
  uint64_t v18;
  char *v19;

  v8 = 0;
  v9 = 0;
  for (i = (char *)a1; ; ++i)
  {
    v19 = i;
    if (*i == 123)
      break;
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      return;
    }
LABEL_7:
    --v8;
  }
  v11 = i[1];
  if (v11 == 123)
  {
    v19 = i + 1;
    v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    v19 = i + 2;
    v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      v13 = 0;
      v14 = i + 3;
      do
      {
        v19 = v14;
        v13 = (v12 - 48) + 10 * v13;
        v15 = *v14++;
        v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      v19 = v14;
      if (*(v14 - 1) == 125)
        health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>((uint64_t)a4, (uint64_t)a4, v13);
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v19);
  health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(a4, (uint64_t)a4, v18, v17, this, a3 - v8, (int)v19);
  if (v8)
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
}

void sub_1B7A7E48C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::runtime_error *exception;

  if (a3)
    health::FormatterParameters<1ul,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>(a1, a2, a3);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7E4F0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t *a1, uint64_t a2, uint64_t a3, _BYTE *a4, std::string *a5, uint64_t a6, int a7)
{
  char *v11;
  void *__p;
  char v13;

  if (a3)
  {
    health::FormatterParameters<1ul,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, a1[1], (uint64_t)a4);
    health::FormatImplementation<unsigned long long const&,unsigned long long const&>(a7, a5);
    if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v11 = (char *)a5;
    else
      v11 = (char *)a5->__r_.__value_.__r.__words[0];
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(a4, &v11[a6], (const void **)&__p);
    if (v13 < 0)
      operator delete(__p);
  }
}

void sub_1B7A7E5F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<1ul,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::runtime_error *exception;

  if (a3 != 1)
    health::FormatterParameters<2ul>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>();
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7E668(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<2ul>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7E6B8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t *a1, uint64_t a2, uint64_t a3, _BYTE *a4, std::string *a5, uint64_t a6, int a7)
{
  char *v11;
  void *__p;
  char v13;

  if (a3 != 1)
    health::FormatterParameters<2ul>::formatParameterAtIndex<health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>>();
  health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *a1, (uint64_t)a4);
  health::FormatImplementation<unsigned long long const&,unsigned long long const&>(a7, a5);
  if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = (char *)a5;
  else
    v11 = (char *)a5->__r_.__value_.__r.__words[0];
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(a4, &v11[a6], (const void **)&__p);
  if (v13 < 0)
    operator delete(__p);
}

void sub_1B7A7E7C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<2ul>::formatParameterAtIndex<health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>>()
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
}

void sub_1B7A7E820(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t HDCodableUserDomainConceptLocalizedStringPropertyReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char v14;
  BOOL v15;
  int v16;
  char v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t result;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  char v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  uint64_t v45;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        break;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        v13 = v12 + 1;
        if (v12 == -1 || v13 > *(_QWORD *)(a2 + *v4))
          break;
        v14 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        v15 = v9++ >= 9;
        if (v15)
        {
          v10 = 0;
          v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v16 || (v10 & 7) == 4)
        break;
      switch((v10 >> 3))
      {
        case 1u:
          v18 = 0;
          v19 = 0;
          v20 = 0;
          *(_BYTE *)(a1 + 52) |= 2u;
          while (1)
          {
            v21 = *v3;
            v22 = *(_QWORD *)(a2 + v21);
            v23 = v22 + 1;
            if (v22 == -1 || v23 > *(_QWORD *)(a2 + *v4))
              break;
            v24 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v22);
            *(_QWORD *)(a2 + v21) = v23;
            v20 |= (unint64_t)(v24 & 0x7F) << v18;
            if ((v24 & 0x80) == 0)
              goto LABEL_49;
            v18 += 7;
            v15 = v19++ >= 9;
            if (v15)
            {
              v20 = 0;
              goto LABEL_51;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_49:
          if (*(_BYTE *)(a2 + *v5))
            v20 = 0;
LABEL_51:
          v45 = 16;
          goto LABEL_56;
        case 2u:
          v25 = 0;
          v26 = 0;
          v20 = 0;
          *(_BYTE *)(a1 + 52) |= 4u;
          while (2)
          {
            v27 = *v3;
            v28 = *(_QWORD *)(a2 + v27);
            v29 = v28 + 1;
            if (v28 == -1 || v29 > *(_QWORD *)(a2 + *v4))
            {
              *(_BYTE *)(a2 + *v5) = 1;
            }
            else
            {
              v30 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
              *(_QWORD *)(a2 + v27) = v29;
              v20 |= (unint64_t)(v30 & 0x7F) << v25;
              if (v30 < 0)
              {
                v25 += 7;
                v15 = v26++ >= 9;
                if (v15)
                {
                  v20 = 0;
                  goto LABEL_55;
                }
                continue;
              }
            }
            break;
          }
          if (*(_BYTE *)(a2 + *v5))
            v20 = 0;
LABEL_55:
          v45 = 24;
LABEL_56:
          *(_QWORD *)(a1 + v45) = v20;
          continue;
        case 3u:
          *(_BYTE *)(a1 + 52) |= 1u;
          v31 = *v3;
          v32 = *(_QWORD *)(a2 + v31);
          if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(_QWORD *)(a2 + *v4))
          {
            v33 = *(_QWORD *)(*(_QWORD *)(a2 + *v7) + v32);
            *(_QWORD *)(a2 + v31) = v32 + 8;
          }
          else
          {
            *(_BYTE *)(a2 + *v5) = 1;
            v33 = 0;
          }
          *(_QWORD *)(a1 + 8) = v33;
          continue;
        case 5u:
          PBReaderReadString();
          v35 = objc_claimAutoreleasedReturnValue();
          v36 = 40;
          goto LABEL_40;
        case 6u:
          PBReaderReadString();
          v35 = objc_claimAutoreleasedReturnValue();
          v36 = 32;
LABEL_40:
          v37 = *(void **)(a1 + v36);
          *(_QWORD *)(a1 + v36) = v35;

          continue;
        case 7u:
          v38 = 0;
          v39 = 0;
          v40 = 0;
          *(_BYTE *)(a1 + 52) |= 8u;
          break;
        default:
          result = PBReaderSkipValueWithTag();
          if (!(_DWORD)result)
            return result;
          continue;
      }
      while (1)
      {
        v41 = *v3;
        v42 = *(_QWORD *)(a2 + v41);
        v43 = v42 + 1;
        if (v42 == -1 || v43 > *(_QWORD *)(a2 + *v4))
          break;
        v44 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v42);
        *(_QWORD *)(a2 + v41) = v43;
        v40 |= (unint64_t)(v44 & 0x7F) << v38;
        if ((v44 & 0x80) == 0)
          goto LABEL_58;
        v38 += 7;
        v15 = v39++ >= 9;
        if (v15)
        {
          v40 = 0;
          goto LABEL_60;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_58:
      if (*(_BYTE *)(a2 + *v5))
        v40 = 0;
LABEL_60:
      *(_BYTE *)(a1 + 48) = v40 != 0;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCloudSyncCodableSequenceReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  HDCodableSyncIdentity *v35;
  uint64_t result;
  char v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  char v41;
  uint64_t v42;
  char v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  char v47;
  char v48;
  unsigned int v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  uint64_t v53;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 100) |= 0x10u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
            break;
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            goto LABEL_79;
          v17 += 7;
          v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_81;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_79:
        if (*(_BYTE *)(a2 + *v5))
          LODWORD(v19) = 0;
LABEL_81:
        *(_DWORD *)(a1 + 80) = v19;
        goto LABEL_103;
      case 2u:
        v23 = 0;
        v24 = 0;
        v25 = 0;
        *(_BYTE *)(a1 + 100) |= 0x20u;
        while (2)
        {
          v26 = *v3;
          v27 = *(_QWORD *)(a2 + v26);
          if (v27 == -1 || v27 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v28 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v27);
            *(_QWORD *)(a2 + v26) = v27 + 1;
            v25 |= (unint64_t)(v28 & 0x7F) << v23;
            if (v28 < 0)
            {
              v23 += 7;
              v14 = v24++ >= 9;
              if (v14)
              {
                v25 = 0;
                goto LABEL_85;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v25 = 0;
LABEL_85:
        *(_BYTE *)(a1 + 96) = v25 != 0;
        goto LABEL_103;
      case 3u:
        v29 = 0;
        v30 = 0;
        v31 = 0;
        *(_BYTE *)(a1 + 100) |= 4u;
        while (2)
        {
          v32 = *v3;
          v33 = *(_QWORD *)(a2 + v32);
          if (v33 == -1 || v33 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v34 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v33);
            *(_QWORD *)(a2 + v32) = v33 + 1;
            v31 |= (unint64_t)(v34 & 0x7F) << v29;
            if (v34 < 0)
            {
              v29 += 7;
              v14 = v30++ >= 9;
              if (v14)
              {
                v31 = 0;
                goto LABEL_89;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v31 = 0;
LABEL_89:
        v53 = 24;
        goto LABEL_102;
      case 4u:
        PBReaderReadData();
        v35 = (HDCodableSyncIdentity *)objc_claimAutoreleasedReturnValue();
        if (v35)
          objc_msgSend((id)a1, "addIncludedStoreIdentifiers:", v35);
        goto LABEL_61;
      case 5u:
        v35 = objc_alloc_init(HDCodableSyncIdentity);
        objc_msgSend((id)a1, "addIncludedSyncIdentities:", v35);
        goto LABEL_44;
      case 6u:
        v35 = objc_alloc_init(HDCodableSyncIdentity);
        objc_msgSend((id)a1, "addIncludedChildSyncIdentities:", v35);
LABEL_44:
        if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v35, a2))
          goto LABEL_105;
        goto LABEL_60;
      case 0xAu:
        v37 = 0;
        v38 = 0;
        v31 = 0;
        *(_BYTE *)(a1 + 100) |= 8u;
        while (2)
        {
          v39 = *v3;
          v40 = *(_QWORD *)(a2 + v39);
          if (v40 == -1 || v40 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v41 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v40);
            *(_QWORD *)(a2 + v39) = v40 + 1;
            v31 |= (unint64_t)(v41 & 0x7F) << v37;
            if (v41 < 0)
            {
              v37 += 7;
              v14 = v38++ >= 9;
              if (v14)
              {
                v31 = 0;
                goto LABEL_93;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v31 = 0;
LABEL_93:
        v53 = 32;
        goto LABEL_102;
      case 0xBu:
        v35 = objc_alloc_init(HDCodableSyncAnchorRangeMap);
        v42 = 40;
        goto LABEL_58;
      case 0xCu:
        v35 = objc_alloc_init(HDCodableSyncAnchorRangeMap);
        v42 = 48;
LABEL_58:
        objc_storeStrong((id *)(a1 + v42), v35);
        if (PBReaderPlaceMark() && -[HDCodableSyncIdentity readFrom:](v35, "readFrom:", a2, 0, 0))
        {
LABEL_60:
          PBReaderRecallMark();
LABEL_61:

LABEL_103:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }
LABEL_105:

        return 0;
      case 0x14u:
        v43 = 0;
        v44 = 0;
        v31 = 0;
        *(_BYTE *)(a1 + 100) |= 1u;
        while (2)
        {
          v45 = *v3;
          v46 = *(_QWORD *)(a2 + v45);
          if (v46 == -1 || v46 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v47 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v46);
            *(_QWORD *)(a2 + v45) = v46 + 1;
            v31 |= (unint64_t)(v47 & 0x7F) << v43;
            if (v47 < 0)
            {
              v43 += 7;
              v14 = v44++ >= 9;
              if (v14)
              {
                v31 = 0;
                goto LABEL_97;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v31 = 0;
LABEL_97:
        v53 = 8;
        goto LABEL_102;
      case 0x15u:
        v48 = 0;
        v49 = 0;
        v31 = 0;
        *(_BYTE *)(a1 + 100) |= 2u;
        while (2)
        {
          v50 = *v3;
          v51 = *(_QWORD *)(a2 + v50);
          if (v51 == -1 || v51 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v52 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v51);
            *(_QWORD *)(a2 + v50) = v51 + 1;
            v31 |= (unint64_t)(v52 & 0x7F) << v48;
            if (v52 < 0)
            {
              v48 += 7;
              v14 = v49++ >= 9;
              if (v14)
              {
                v31 = 0;
                goto LABEL_101;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v31 = 0;
LABEL_101:
        v53 = 16;
LABEL_102:
        *(_QWORD *)(a1 + v53) = v31;
        goto LABEL_103;
      case 0x1Eu:
        PBReaderReadString();
        v35 = (HDCodableSyncIdentity *)objc_claimAutoreleasedReturnValue();
        if (v35)
          objc_msgSend((id)a1, "addUnfrozenChangeRecordNames:", v35);
        goto LABEL_61;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_103;
    }
  }
}

id HDHeartDailyAnalyticsProcessingIntervalForCurrentDateAndCalendar(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v3 = a2;
  objc_msgSend(v3, "startOfDayForDate:", a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "dateByAddingUnit:value:toDate:options:", 16, -1, v4, 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "dateByAddingUnit:value:toDate:options:", 16, -1, v5, 0);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3588]), "initWithStartDate:endDate:", v6, v5);
  return v7;
}

void sub_1B7A89ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__91(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__91(uint64_t a1)
{

}

void sub_1B7A8A098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A8A240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A8A3E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A8A55C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A8AD7C(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1B7A8C30C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__92(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__92(uint64_t a1)
{

}

void sub_1B7A8D4B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,id location)
{
  id *v27;
  id *v28;

  objc_destroyWeak(v28);
  objc_destroyWeak(v27);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7A8E87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__93(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__93(uint64_t a1)
{

}

__CFString *NSStringFromHKBiologicalSex(unint64_t a1)
{
  void *v2;
  void *v3;

  if (a1 < 4)
    return off_1E6CF8CA0[a1];
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *NSStringFromHKBiologicalSex(HKBiologicalSex)");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDDemoDataDefines.m"), 26, CFSTR("Invalid biological sex"));

  return 0;
}

__CFString *NSStringFromHDDemoDataFoodType(uint64_t a1)
{
  void *v2;
  void *v3;

  if ((unint64_t)(a1 - 1) < 6)
    return off_1E6CF8CC0[a1 - 1];
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *NSStringFromHDDemoDataFoodType(HDDemoDataFoodType)");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDDemoDataDefines.m"), 46, CFSTR("Invalid demo data food type"));

  return 0;
}

const __CFString *NSStringFromHDDemoDataGenerationPeriod(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  void *v7;

  if (a1 > 59)
  {
    if (a1 > 179)
    {
      if (a1 == 180)
        return CFSTR("6 Months");
      if (a1 == 365)
        return CFSTR("1 Year");
    }
    else
    {
      if (a1 == 60)
        return CFSTR("2 Months");
      if (a1 == 90)
        return CFSTR("3 Months");
    }
  }
  else if (a1 > 6)
  {
    if (a1 == 7)
      return CFSTR("1 Week");
    if (a1 == 30)
      return CFSTR("1 Month");
  }
  else
  {
    if (a1 == -1)
      return CFSTR("Year to Date");
    if (a1 == 1)
      return CFSTR("1 Day");
  }
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler", v2, v1, v3, v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *NSStringFromHDDemoDataGenerationPeriod(HDDemoDataGenerationPeriod)");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "handleFailureInFunction:file:lineNumber:description:", v7, CFSTR("HDDemoDataDefines.m"), 70, CFSTR("Invalid demo data generation period"));

  return 0;
}

uint64_t HDDemoDataIsValidGenerationPeriod(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  unint64_t v7;
  void *v8;
  void *v9;

  result = 1;
  if (a1 <= 89)
  {
    v7 = a1 + 1;
    if (v7 <= 0x3D && ((1 << v7) & 0x2000000080000105) != 0)
      return result;
LABEL_8:
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler", v2, v1, v3, v4);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "BOOL HDDemoDataIsValidGenerationPeriod(HDDemoDataGenerationPeriod)");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "handleFailureInFunction:file:lineNumber:description:", v9, CFSTR("HDDemoDataDefines.m"), 87, CFSTR("Invalid demo data initial generation period"));

    return 0;
  }
  if (a1 != 90 && a1 != 180 && a1 != 365)
    goto LABEL_8;
  return result;
}

__CFString *DisplayNameForHDDemoDataProfileType(uint64_t a1)
{
  void *v2;
  void *v3;

  if ((unint64_t)(a1 - 1) < 4)
    return off_1E6CF8CF0[a1 - 1];
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *DisplayNameForHDDemoDataProfileType(HDDemoDataProfileType)");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDDemoDataDefines.m"), 103, CFSTR("Invalid demo data profile type"));

  return 0;
}

__CFString *DirectoryPathForHDDemoDataProfileType(uint64_t a1)
{
  void *v2;
  void *v3;

  if ((unint64_t)(a1 - 1) < 4)
    return off_1E6CF8D10[a1 - 1];
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *DirectoryPathForHDDemoDataProfileType(HDDemoDataProfileType)");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDDemoDataDefines.m"), 119, CFSTR("Invalid demo data profile type"));

  return 0;
}

const __CFString *NSStringFromHDDemoDataSampleTrackingType(uint64_t a1)
{
  void *v2;
  void *v3;

  if (a1 == 1)
    return CFSTR("Typical");
  if (a1 == 2)
    return CFSTR("Inclusive");
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *NSStringFromHDDemoDataSampleTrackingType(HDDemoDataSampleTrackingType)");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("HDDemoDataDefines.m"), 131, CFSTR("Invalid demo data sample tracking type"));

  return 0;
}

void sub_1B7A9128C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__94(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__94(uint64_t a1)
{

}

void sub_1B7A91E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A9556C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 240), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__95(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__95(uint64_t a1)
{

}

BOOL HDCodableAuthorizationCompleteMessageReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 10)
        break;
      if ((_DWORD)v17 == 2)
      {
        PBReaderReadData();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 24;
        goto LABEL_24;
      }
      if ((_DWORD)v17 == 1)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 8;
LABEL_24:
        v20 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_26:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    PBReaderReadString();
    v18 = objc_claimAutoreleasedReturnValue();
    v19 = 16;
    goto LABEL_24;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7A98860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  id *v37;
  uint64_t v38;

  objc_destroyWeak(v37);
  objc_destroyWeak((id *)(v38 - 192));
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__96(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__96(uint64_t a1)
{

}

void sub_1B7A9C240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__97(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__97(uint64_t a1)
{

}

void sub_1B7A9C41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A9C544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDAttachmentPredicateForAttachmentIdentifier(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0D29838], "predicateWithProperty:equalToValue:", CFSTR("identifier"), a1);
}

void sub_1B7A9D344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__98(uint64_t a1, uint64_t a2)
{
  void *result;

  result = _Block_copy(*(const void **)(a2 + 40));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__98(uint64_t a1)
{

}

void sub_1B7A9D864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A9EA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v9 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va2, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__213(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__214(uint64_t a1)
{

}

void sub_1B7A9F6D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1B7A9F8DC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf)
{
  uint64_t v11;
  id v12;
  NSObject *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;

  if (a2 == 1)
  {
    v12 = objc_begin_catch(a1);
    _HKInitializeLogging();
    v13 = (id)*MEMORY[0x1E0CB5370];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      v16 = *(_QWORD *)(v11 + 40);
      objc_msgSend(v12, "reason");
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf) = 138543618;
      *(_QWORD *)((char *)&buf + 4) = v16;
      WORD6(buf) = 2114;
      *(_QWORD *)((char *)&buf + 14) = v17;
      _os_log_fault_impl(&dword_1B7802000, v13, OS_LOG_TYPE_FAULT, "%{public}@: Error unarchiving change objects: %{public}@", (uint8_t *)&buf, 0x16u);

    }
    v14 = *(_QWORD *)(*(_QWORD *)(v11 + 56) + 8);
    v15 = *(void **)(v14 + 40);
    *(_QWORD *)(v14 + 40) = 0;

    objc_end_catch();
    JUMPOUT(0x1B7A9F818);
  }
  _Unwind_Resume(a1);
}

void sub_1B7AA0B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, id *a10, id *a11, id *a12, id *a13, id *a14, id *a15, id *a16, id *a17, id *a18, id *location)
{
  objc_destroyWeak(location);
  objc_destroyWeak(a18);
  objc_destroyWeak(a15);
  objc_destroyWeak(a12);
  objc_destroyWeak(a10);
  objc_destroyWeak(a11);
  objc_destroyWeak(a13);
  objc_destroyWeak(a14);
  objc_destroyWeak(a16);
  objc_destroyWeak(a17);
  objc_destroyWeak((id *)&STACK[0x268]);
  _Unwind_Resume(a1);
}

void sub_1B7AA5090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7AA60EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7AA6410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _HDAddWorkoutBuilderTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8FD8, a4) ^ 1;

  return v6;
}

uint64_t _HDAddWorkoutSessionControllerTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("CREATE TABLE IF NOT EXISTS workout_session_controllers (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, workout_session_id INTEGER NOT NULL REFERENCES workout_sessions(ROWID) ON DELETE CASCADE, recovery_identifier TEXT NOT NULL, archived_state BLOB)"), a4) ^ 1;

  return v6;
}

uint64_t _HDAddClientBundleIdentifierToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = CFSTR("ALTER TABLE workout_sessions ADD COLUMN client_bundle_id TEXT;");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", v6, a4);

  return a4 ^ 1;
}

uint64_t _HDAddAuthorizationMode(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF8FF0, a4) ^ 1;

  return v6;
}

uint64_t _HDAddClientApplicationIdentifierToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = CFSTR("ALTER TABLE workout_sessions ADD COLUMN client_application_id TEXT;");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", v6, a4);

  return a4 ^ 1;
}

uint64_t _HDRemoveExistingWorkoutBuildersAndSessions(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9008, a4) ^ 1;

  return v6;
}

uint64_t _HDSplitAuthorizationAnchors(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9020, a4) ^ 1;

  return v6;
}

uint64_t _HDAddSyncProtocolVersionToCloudSyncStore(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9038, a4) ^ 1;

  return v6;
}

uint64_t _HDMakeStatisticsColumnNullable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9050, a4) ^ 1;

  return v6;
}

uint64_t _HDAddRequestedTargetStateToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = CFSTR("ALTER TABLE workout_sessions ADD COLUMN requested_target_state INTEGER NOT NULL DEFAULT 1;");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", v6, a4);

  return a4 ^ 1;
}

uint64_t _HDAddHasFailedToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = CFSTR("ALTER TABLE workout_sessions ADD COLUMN has_failed INTEGER NOT NULL DEFAULT 0;");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", v6, a4);

  return a4 ^ 1;
}

uint64_t _HDAddWorkoutEventForeignKey(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9068, a4) ^ 1;

  return v6;
}

uint64_t _CreateQuantitySampleSeriesEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("CREATE TABLE IF NOT EXISTS quantity_sample_series (data_id INTEGER PRIMARY KEY REFERENCES samples (data_id) ON DELETE CASCADE, count INTEGER NOT NULL DEFAULT 0, insertion_era INTEGER, hfd_key INTEGER NOT NULL, min REAL, max REAL, most_recent REAL, most_recent_date REAL)"), a4) ^ 1;

  return v6;
}

uint64_t _AddCondenserVersionToWorkoutEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE workouts ADD condenser_version INTEGER"), a4) ^ 1;

  return v6;
}

uint64_t _AddTemplateUniqueNameToFitnessFriendAchievements(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  _QWORD v8[3];

  v8[2] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = CFSTR("DROP TABLE fitness_friend_achievements");
  v8[1] = CFSTR("CREATE TABLE fitness_friend_achievements (data_id INTEGER PRIMARY KEY, friend_uuid BLOB, template_unique_name TEXT, completed_date REAL, value)");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", v6, a4);

  return a4 ^ 1;
}

uint64_t _AddiOSVersionToFHIRResources(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  _QWORD v8[7];

  v8[6] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = CFSTR("CREATE TABLE original_fhir_resources (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, type TEXT NOT NULL, account_id INTEGER NOT NULL REFERENCES clinical_accounts (ROWID) ON DELETE CASCADE, id TEXT NOT NULL, sync_provenance INTEGER NOT NULL, raw_content BLOB NOT NULL, received_date REAL NOT NULL, received_date_timezone TEXT NOT NULL, fhir_version TEXT NOT NULL, source_url TEXT, extraction_hints INTEGER, origin_major_version INTEGER NOT NULL, origin_minor_version INTEGER NOT NULL, origin_patch_version INTEGER NOT NULL, origin_build TEXT NOT NULL, UNIQUE(type, account_id, id))");
  v8[1] = CFSTR("CREATE TABLE IF NOT EXISTS original_fhir_resources_last_seen (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, resource_id INTEGER NOT NULL REFERENCES original_fhir_resources(ROWID) ON DELETE CASCADE, last_seen_date REAL NOT NULL)");
  v8[2] = CFSTR("INSERT INTO original_fhir_resources (rowid, type, account_id, id, sync_provenance, raw_content, received_date, received_date_timezone, fhir_version, source_url, extraction_hints, origin_major_version, origin_minor_version, origin_patch_version, origin_build) SELECT rowid, type, account_id, id, sync_provenance, raw_content, received_date, received_date_timezone, fhir_version, source_url, extraction_hints, 11, 3, 0, '15E216' FROM fhir_resources");
  v8[3] = CFSTR("INSERT INTO original_fhir_resources_last_seen (rowid, resource_id, last_seen_date) SELECT rowid, resource_id, last_seen_date FROM fhir_resources_last_seen");
  v8[4] = CFSTR("DROP TABLE fhir_resources");
  v8[5] = CFSTR("DROP TABLE fhir_resources_last_seen");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 6);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", v6, a4);

  return a4 ^ 1;
}

uint64_t _AddCondenserDateToWorkoutEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("ALTER TABLE workouts ADD condenser_date REAL"), a4) ^ 1;

  return v6;
}

uint64_t _AddHFDKeyToSeriesSampleEntityTable(uint64_t a1, void *a2, uint64_t a3, _QWORD *a4)
{
  id v5;
  void *v6;
  char v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  int v12;
  id v14;

  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = 0;
  v7 = objc_msgSend(v6, "table:hasColumnWithName:error:", CFSTR("data_series"), CFSTR("count"), &v14);
  v8 = v14;

  if ((v7 & 1) != 0)
    goto LABEL_2;
  if (v8)
  {
    if (a4)
      *a4 = objc_retainAutorelease(v8);
    else
      _HKLogDroppedError();
    goto LABEL_9;
  }
  objc_msgSend(v5, "protectedDatabase");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = objc_msgSend(v11, "executeUncachedSQL:error:", CFSTR("ALTER TABLE data_series ADD COLUMN count INTEGER NOT NULL DEFAULT 0"), a4);

  if (!v12)
  {
LABEL_9:
    v10 = 1;
    goto LABEL_10;
  }
LABEL_2:
  objc_msgSend(v5, "protectedDatabase");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = objc_msgSend(v9, "executeSQLStatements:error:", &unk_1E6DF9080, a4) ^ 1;

LABEL_10:
  return v10;
}

uint64_t _CreateClinicalRecordEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("CREATE TABLE IF NOT EXISTS clinical_record_samples (data_id INTEGER PRIMARY KEY, display_name TEXT NOT NULL, fhir_resource_resource_type TEXT, fhir_resource_identifier TEXT, fhir_resource_data BLOB, fhir_resource_source_url TEXT, fhir_resource_last_updated_date REAL)"), a4) ^ 1;

  return v6;
}

uint64_t _MakeQuantitySampleSeriesEntityHFDKeyUnique(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9098, a4) ^ 1;

  return v6;
}

uint64_t _CreateQuantitySampleSeriesUnfrozenIndex(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF90B0, a4) ^ 1;

  return v6;
}

uint64_t _RemoveLegacyAchievements(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF90C8, a4) ^ 1;

  return v6;
}

uint64_t _HDMigrateClinicalSources(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6;
  id v7;
  void *v8;
  int v9;
  void *v10;
  uint64_t v11;
  id v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  int v17;
  void *v18;
  int v19;
  void *v20;
  int v21;
  void *v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  NSObject *v29;
  void *v30;
  uint64_t v31;
  __int128 v33;
  id v34;
  _QWORD v35[5];
  _QWORD v36[4];
  id v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint8_t buf[4];
  uint64_t v43;
  _BYTE v44[128];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v6 = a1;
  v7 = a2;
  objc_msgSend(v7, "unprotectedDatabase");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = objc_msgSend(v8, "executeSQLStatements:error:", &unk_1E6DF90E0, a4);

  if (v9)
  {
    objc_msgSend(v7, "unprotectedDatabase");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = MEMORY[0x1E0C809B0];
    v36[0] = MEMORY[0x1E0C809B0];
    v36[1] = 3221225472;
    v36[2] = ___HDMigrateClinicalSources_block_invoke;
    v36[3] = &unk_1E6CE8CF8;
    v12 = v7;
    v37 = v12;
    v13 = objc_msgSend(v10, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT account_id FROM public_clinical_sources"), a4, 0, v36);

    if (!v13)
      goto LABEL_22;
    v14 = objc_msgSend(v6, "fetchLegacySyncIdentity:error:", v12, a4);
    if (v14 == -1)
      goto LABEL_22;
    v15 = v14;
    objc_msgSend(v12, "unprotectedDatabase");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v16, "executeSQLStatements:error:", &unk_1E6DF90F8, a4);

    if (!v17)
      goto LABEL_22;
    objc_msgSend(v12, "unprotectedDatabase");
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v35[0] = v11;
    v35[1] = 3221225472;
    v35[2] = ___HDMigrateClinicalSources_block_invoke_5;
    v35[3] = &__block_descriptor_40_e23_v16__0__sqlite3_stmt__8l;
    v35[4] = v15;
    v19 = objc_msgSend(v18, "executeSQL:error:bindingHandler:enumerationHandler:", CFSTR("INSERT INTO sources (uuid, logical_source_id, name, source_options, local_device, product_type, mod_date, provenance, sync_anchor, deleted, sync_identity)                                             SELECT RANDOMBLOB(16), l.ROWID, name, source_options, local_device, product_type, mod_date, 0, COALESCE((SELECT MAX(sync_anchor) + 1 FROM sources), 1) + p.ROWID, 0, ?                                             FROM public_clinical_sources p JOIN logical_sources l WHERE p.stable_bundle_id = l.bundle_id"), a4, v35, 0);

    if (!v19)
      goto LABEL_22;
    objc_msgSend(v12, "unprotectedDatabase");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = objc_msgSend(v20, "executeSQLStatements:error:", &unk_1E6DF9110, a4);

    if (v21)
    {
      objc_msgSend(v12, "protectedDatabase");
      v34 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v34, "dumpSchemaWithError:", a4);
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      if (v22)
      {
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        v23 = objc_msgSend(&unk_1E6DF9128, "countByEnumeratingWithState:objects:count:", &v38, v44, 16);
        if (v23)
        {
          v25 = v23;
          v26 = *(_QWORD *)v39;
          *(_QWORD *)&v24 = 138412290;
          v33 = v24;
          do
          {
            for (i = 0; i != v25; ++i)
            {
              if (*(_QWORD *)v39 != v26)
                objc_enumerationMutation(&unk_1E6DF9128);
              v28 = *(_QWORD *)(*((_QWORD *)&v38 + 1) + 8 * i);
              if ((objc_msgSend(MEMORY[0x1E0D29850], "databaseSchemas:containTable:", v22, v28, v33) & 1) != 0)
              {
                if (!objc_msgSend(v34, "deleteRowsFromDataEntitySubclassTable:intermediateTables:error:", v28, &unk_1E6DF9140, a4))goto LABEL_25;
              }
              else
              {
                _HKInitializeLogging();
                v29 = *MEMORY[0x1E0CB52B0];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E0CB52B0], OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)buf = v33;
                  v43 = v28;
                  _os_log_impl(&dword_1B7802000, v29, OS_LOG_TYPE_INFO, "Skipping deletion from nonexistent table \"%@\"", buf, 0xCu);
                }
              }
            }
            v25 = objc_msgSend(&unk_1E6DF9128, "countByEnumeratingWithState:objects:count:", &v38, v44, 16);
          }
          while (v25);
        }

        v30 = v34;
        v31 = 0;
      }
      else
      {
LABEL_25:

        v30 = v34;
        v31 = 1;
      }

    }
    else
    {
LABEL_22:
      v31 = 1;
    }

  }
  else
  {
    v31 = 1;
  }

  return v31;
}

uint64_t _MakeSeriesSampleEntityHFDKeyUnique(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9158, a4) ^ 1;

  return v6;
}

uint64_t _HDAddHealthRecordsAccountCount(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  char v11;
  uint64_t v12;
  void *v13;
  int v14;
  uint64_t v15;
  _QWORD v17[6];
  _QWORD aBlock[5];
  _QWORD v19[4];

  v6 = a1;
  v7 = a2;
  v19[0] = 0;
  v19[1] = v19;
  v19[2] = 0x2020000000;
  v8 = MEMORY[0x1E0C809B0];
  v19[3] = 0;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = ___HDAddHealthRecordsAccountCount_block_invoke;
  aBlock[3] = &unk_1E6CE8540;
  aBlock[4] = v19;
  v9 = _Block_copy(aBlock);
  objc_msgSend(v7, "protectedDatabase");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = objc_msgSend(v10, "executeSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT COUNT(*) FROM clinical_accounts"), a4, 0, v9);

  if ((v11 & 1) == 0 || (v12 = objc_msgSend(v6, "fetchLegacySyncIdentity:error:", v7, a4), v12 == -1))
  {
    v15 = 1;
  }
  else
  {
    objc_msgSend(v7, "unprotectedDatabase");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v17[0] = v8;
    v17[1] = 3221225472;
    v17[2] = ___HDAddHealthRecordsAccountCount_block_invoke_2;
    v17[3] = &unk_1E6CF2EE0;
    v17[4] = v19;
    v17[5] = v12;
    v14 = objc_msgSend(v13, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("INSERT OR REPLACE INTO key_value (domain, key, value, mod_date, category, provenance, sync_identity) VALUES (?, ?, ?, ?, ?, ?, ?);"),
            a4,
            v17,
            0);

    v15 = v14 ^ 1u;
  }

  _Block_object_dispose(v19, 8);
  return v15;
}

void sub_1B7AA79F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL HDCloudSyncCodableRegisteredStoreReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  HDCodableSyncIdentity *v20;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
        break;
      if ((_DWORD)v17 == 2)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 16;
LABEL_26:
        v20 = *(HDCodableSyncIdentity **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;
LABEL_27:

        goto LABEL_29;
      }
      if ((_DWORD)v17 == 1)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 8;
        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_29:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v20 = objc_alloc_init(HDCodableSyncIdentity);
    objc_storeStrong((id *)(a1 + 24), v20);
    if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v20, a2))
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_27;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_1B7AB00E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1B7AB0F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  _Block_object_dispose(&a47, 8);
  _Unwind_Resume(a1);
}

void sub_1B7AB120C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7AB201C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7AB284C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

__CFString *HDStringFromJournalProcessingResult(unsigned int a1)
{
  if (a1 < 5)
    return off_1E6CF9988[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Unknown (%ld)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

BOOL HDJournalProcessingSuccessIndicatedWithResult(int a1)
{
  return (a1 - 3) < 2;
}

void sub_1B7AB3F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7AB42D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t HDCodableActivityGoalScheduleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  __objc2_class **v7;
  int *v8;
  int *v9;
  int *v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  int v19;
  BOOL v20;
  int *v21;
  int *v22;
  __objc2_class **v23;
  id v24;
  uint64_t result;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = off_1E6CE3000;
    v8 = &OBJC_IVAR___HDDemoDataPerson__rehabLogarithmicConstant;
    v9 = &OBJC_IVAR___HDDemoDataPerson__rehabLogarithmicConstant;
    v10 = (int *)MEMORY[0x1E0D82BB8];
    while (2)
    {
      if (!*(_BYTE *)(a2 + *v5))
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        while (1)
        {
          v14 = *v3;
          v15 = *(_QWORD *)(a2 + v14);
          v16 = v15 + 1;
          if (v15 == -1 || v16 > *(_QWORD *)(a2 + *v4))
            break;
          v17 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v15);
          *(_QWORD *)(a2 + v14) = v16;
          v13 |= (unint64_t)(v17 & 0x7F) << v11;
          if ((v17 & 0x80) == 0)
            goto LABEL_12;
          v11 += 7;
          v18 = v12++ >= 9;
          if (v18)
          {
            v13 = 0;
            v19 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
        v19 = *(unsigned __int8 *)(a2 + *v5);
        if (*(_BYTE *)(a2 + *v5))
          v13 = 0;
LABEL_14:
        if (v19)
          v20 = 1;
        else
          v20 = (v13 & 7) == 4;
        if (!v20)
        {
          switch((v13 >> 3))
          {
            case 1u:
              v21 = v9;
              v22 = v8;
              v23 = v7;
              v24 = objc_alloc_init(v7[87]);
              objc_storeStrong((id *)(a1 + 72), v24);
              if (PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v24, a2) & 1) != 0)
              {
                PBReaderRecallMark();

                v7 = v23;
                v8 = v22;
                v9 = v21;
                goto LABEL_72;
              }

              return 0;
            case 2u:
              v26 = 0;
              v27 = 0;
              v28 = 0;
              *(_BYTE *)(a1 + v8[552]) |= 2u;
              break;
            case 3u:
              PBReaderReadString();
              v33 = objc_claimAutoreleasedReturnValue();
              v34 = *(void **)(a1 + 80);
              *(_QWORD *)(a1 + 80) = v33;

              goto LABEL_72;
            case 4u:
              *(_BYTE *)(a1 + v8[552]) |= 4u;
              v35 = *v3;
              v36 = *(_QWORD *)(a2 + v35);
              if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v37 = *(_QWORD *)(*(_QWORD *)(a2 + *v10) + v36);
                *(_QWORD *)(a2 + v35) = v36 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v37 = 0;
              }
              v50 = 24;
              goto LABEL_71;
            case 5u:
              *(_BYTE *)(a1 + v8[552]) |= 0x40u;
              v38 = *v3;
              v39 = *(_QWORD *)(a2 + v38);
              if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v37 = *(_QWORD *)(*(_QWORD *)(a2 + *v10) + v39);
                *(_QWORD *)(a2 + v38) = v39 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v37 = 0;
              }
              v50 = 56;
              goto LABEL_71;
            case 6u:
              *(_BYTE *)(a1 + v8[552]) |= 0x80u;
              v40 = *v3;
              v41 = *(_QWORD *)(a2 + v40);
              if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v37 = *(_QWORD *)(*(_QWORD *)(a2 + *v10) + v41);
                *(_QWORD *)(a2 + v40) = v41 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v37 = 0;
              }
              v50 = 64;
              goto LABEL_71;
            case 7u:
              *(_BYTE *)(a1 + v8[552]) |= 0x20u;
              v42 = *v3;
              v43 = *(_QWORD *)(a2 + v42);
              if (v43 <= 0xFFFFFFFFFFFFFFF7 && v43 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v37 = *(_QWORD *)(*(_QWORD *)(a2 + *v10) + v43);
                *(_QWORD *)(a2 + v42) = v43 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v37 = 0;
              }
              v50 = 48;
              goto LABEL_71;
            case 8u:
              *(_BYTE *)(a1 + v8[552]) |= 1u;
              v44 = *v3;
              v45 = *(_QWORD *)(a2 + v44);
              if (v45 <= 0xFFFFFFFFFFFFFFF7 && v45 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v37 = *(_QWORD *)(*(_QWORD *)(a2 + *v10) + v45);
                *(_QWORD *)(a2 + v44) = v45 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v37 = 0;
              }
              v50 = 8;
              goto LABEL_71;
            case 9u:
              *(_BYTE *)(a1 + v8[552]) |= 8u;
              v46 = *v3;
              v47 = *(_QWORD *)(a2 + v46);
              if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v37 = *(_QWORD *)(*(_QWORD *)(a2 + *v10) + v47);
                *(_QWORD *)(a2 + v46) = v47 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v37 = 0;
              }
              v50 = 32;
              goto LABEL_71;
            case 0xAu:
              *(_BYTE *)(a1 + v8[552]) |= 0x10u;
              v48 = *v3;
              v49 = *(_QWORD *)(a2 + v48);
              if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(_QWORD *)(a2 + *v4))
              {
                v37 = *(_QWORD *)(*(_QWORD *)(a2 + *v10) + v49);
                *(_QWORD *)(a2 + v48) = v49 + 8;
              }
              else
              {
                *(_BYTE *)(a2 + *v5) = 1;
                v37 = 0;
              }
              v50 = 40;
LABEL_71:
              *(_QWORD *)(a1 + v50) = v37;
              goto LABEL_72;
            default:
              result = PBReaderSkipValueWithTag();
              if (!(_DWORD)result)
                return result;
LABEL_72:
              if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
                return *(_BYTE *)(a2 + *v5) == 0;
              continue;
          }
          while (1)
          {
            v29 = *v3;
            v30 = *(_QWORD *)(a2 + v29);
            v31 = v30 + 1;
            if (v30 == -1 || v31 > *(_QWORD *)(a2 + *v4))
              break;
            v32 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v30);
            *(_QWORD *)(a2 + v29) = v31;
            v28 |= (unint64_t)(v32 & 0x7F) << v26;
            if ((v32 & 0x80) == 0)
              goto LABEL_54;
            v26 += 7;
            v18 = v27++ >= 9;
            if (v18)
            {
              v28 = 0;
              goto LABEL_56;
            }
          }
          *(_BYTE *)(a2 + *v5) = 1;
LABEL_54:
          if (*(_BYTE *)(a2 + *v5))
            v28 = 0;
LABEL_56:
          *(_QWORD *)(a1 + v9[553]) = v28;
          goto LABEL_72;
        }
      }
      break;
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t HDCheckAutomaticAppUpdatesAllowed()
{
  void *v0;
  uint64_t v1;

  objc_msgSend(MEMORY[0x1E0D47230], "sharedConnection");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = objc_msgSend(v0, "isAutomaticAppUpdatesAllowed");

  return v1;
}

uint64_t _HDUpdateClientSideDataCollectionLastCollectedDatum(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF91A0, a4) ^ 1;

  return v6;
}

uint64_t _HDAddShouldCollectEventsColumnToWorkoutBuildersTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF91B8, a4) ^ 1;

  return v6;
}

uint64_t _HDAddOnboardingCompletionTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("CREATE TABLE IF NOT EXISTS onboarding_completions (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, uuid BLOB NOT NULL UNIQUE, feature_identifier TEXT NOT NULL, version INTEGER NOT NULL, completion_date REAL NOT NULL, country_code TEXT, mod_date REAL NOT NULL, deleted INTEGER NOT NULL DEFAULT 0, sync_provenance INTEGER NOT NULL)"), a4) ^ 1;

  return v6;
}

uint64_t _HDResetAnchorsForCloudSyncStoresWithGaps(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "unprotectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("DELETE FROM sync_anchors WHERE store IN (SELECT ROWID FROM sync_stores INNER JOIN cloud_sync_stores on (sync_stores.ROWID=cloud_sync_stores.sync_store) WHERE has_gap)"), a4) ^ 1;

  return v6;
}

uint64_t _HDResetReceivedNanoSyncAnchorsForCategoryAndQuantitySamples(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6;
  void *v7;
  int v8;
  void *v9;
  uint64_t v10;

  v6 = a2;
  objc_msgSend(a1, "behavior");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v7, "isAppleWatch");

  if (v8)
  {
    objc_msgSend(v6, "unprotectedDatabase");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = objc_msgSend(v9, "executeSQLStatements:error:", &unk_1E6DF91D0, a4) ^ 1;

  }
  else
  {
    v10 = 0;
  }

  return v10;
}

uint64_t _HDAddSleepScheduleTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_class *v5;
  id v6;
  id v7;
  void *v8;
  uint64_t v9;

  v5 = (objc_class *)MEMORY[0x1E0C99DE8];
  v6 = a2;
  v7 = objc_alloc_init(v5);
  objc_msgSend(v7, "addObject:", CFSTR("CREATE TABLE IF NOT EXISTS sleep_schedule_samples (data_id INTEGER PRIMARY KEY, monday INTEGER NOT NULL, tuesday INTEGER NOT NULL, wednesday INTEGER NOT NULL, thursday INTEGER NOT NULL, friday INTEGER NOT NULL, saturday INTEGER NOT NULL, sunday INTEGER NOT NULL, wake_hour INTEGER, wake_minute INTEGER, bed_hour INTEGER, bed_minute INTEGER, wind_down_seconds REAL)"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_monday ON sleep_schedule_samples (monday) WHERE monday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_tuesday ON sleep_schedule_samples (tuesday) WHERE tuesday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_wednesday ON sleep_schedule_samples (wednesday) WHERE wednesday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_thursday ON sleep_schedule_samples (thursday) WHERE thursday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_friday ON sleep_schedule_samples (friday) WHERE friday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_saturday ON sleep_schedule_samples (saturday) WHERE saturday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_sunday ON sleep_schedule_samples (sunday) WHERE sunday = 1;"));
  objc_msgSend(v6, "protectedDatabase");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = objc_msgSend(v8, "executeSQLStatements:error:", v7, a4) ^ 1;
  return v9;
}

uint64_t _HDAddECGSampleTable()
{
  return 0;
}

uint64_t _HDAddContributorsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  void *v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = CFSTR("CREATE TABLE IF NOT EXISTS contributors (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, uuid BLOB UNIQUE NOT NULL, payload BLOB, deleted INTEGER NOT NULL, placeholder INTEGER NOT NULL, mod_date REAL NOT NULL, sync_anchor INTEGER UNIQUE NOT NULL)");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(a4) = objc_msgSend(v5, "executeSQLStatements:error:", v6, a4);

  return a4 ^ 1;
}

uint64_t _HDAddDeviceRecordSamplesTable()
{
  return 0;
}

uint64_t _HDAddProtectedOnboardingCompletionTable()
{
  return 0;
}

uint64_t _HDAddFHIRVersionToClinicalRecordSamplesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF91E8, a4) ^ 1;

  return v6;
}

uint64_t _HDAddContributorsColumnToProvenance(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_class *v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  _QWORD v12[6];

  v12[5] = *MEMORY[0x1E0C80C00];
  v5 = (objc_class *)MEMORY[0x1E0CB3940];
  v6 = a2;
  v7 = [v5 alloc];
  v8 = (void *)objc_msgSend(v7, "initWithFormat:", CFSTR("INSERT INTO contributors (ROWID, uuid, payload, deleted, placeholder, mod_date, sync_anchor) VALUES (1, %@('00000000-0000-0000-0000-000000000000'), NULL, 0, 0, %lf, 0)"), *MEMORY[0x1E0D297B0], CFAbsoluteTimeGetCurrent());
  v12[0] = v8;
  v12[1] = CFSTR("CREATE TABLE IF NOT EXISTS data_provenances_new (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, sync_provenance INTEGER NOT NULL, origin_product_type TEXT NOT NULL, origin_build TEXT NOT NULL, local_product_type TEXT NOT NULL, local_build TEXT NOT NULL, source_id INTEGER NOT NULL, device_id INTEGER NOT NULL, contributor_id INTEGER NOT NULL, source_version TEXT NOT NULL, tz_name TEXT NOT NULL, origin_major_version INTEGER NOT NULL, origin_minor_version INTEGER NOT NULL, origin_patch_version INTEGER NOT NULL, derived_flags INTEGER NOT NULL, UNIQUE(sync_provenance, origin_product_type, origin_build, local_product_type, local_build, source_id, device_id, contributor_id, source_version, tz_name, origin_major_version, origin_minor_version, origin_patch_version))");
  v12[2] = CFSTR("INSERT INTO data_provenances_new (ROWID, sync_provenance, origin_product_type, origin_build, local_product_type, local_build, source_id, device_id, contributor_id, source_version, tz_name, origin_major_version, origin_minor_version, origin_patch_version, derived_flags) SELECT ROWID, sync_provenance, origin_product_type, origin_build, local_product_type, local_build, source_id, device_id, 1, source_version, tz_name, origin_major_version, origin_minor_version, origin_patch_version, derived_flags FROM data_provenances");
  v12[3] = CFSTR("DROP TABLE IF EXISTS data_provenances");
  v12[4] = CFSTR("ALTER TABLE data_provenances_new RENAME TO data_provenances");
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v12, 5);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "protectedDatabase");
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  LODWORD(a4) = objc_msgSend(v10, "executeSQLStatements:error:", v9, a4);
  return a4 ^ 1;
}

uint64_t _HDCreatePartialIndexForDeletedObjects(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9200, a4) ^ 1;

  return v6;
}

uint64_t _HDAddAppleIDAndCallerIDToContributorsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9218, a4) ^ 1;

  return v6;
}

uint64_t _HDAddECGSymptomsColumnToECGSamplesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9230, a4) ^ 1;

  return v6;
}

uint64_t _HDMigrateECGClassificationAverageHRAndPayload(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  id v7;
  _QWORD v9[4];
  id v10;
  __CFString *v11;
  __CFString *v12;
  __CFString *v13;

  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___HDMigrateECGClassificationAverageHRAndPayload_block_invoke;
  v9[3] = &unk_1E6CF9A28;
  v10 = v5;
  v11 = CFSTR("DELETE FROM binary_samples WHERE data_id=?");
  v12 = CFSTR("INSERT INTO ecg_samples (data_id, voltage_payload, private_classification, average_heart_rate, symptoms_status) VALUES (?, ?, ?, ?, ?)");
  v13 = CFSTR("DELETE FROM metadata_values WHERE key_id IN (SELECT rowid FROM metadata_keys WHERE key LIKE '_HKPrivateMetadataKeyClassification' OR key LIKE '_HKPrivateMetadataKeyElectrocardiogramHeartRate') AND object_id=?");
  v7 = v5;
  LODWORD(a4) = objc_msgSend(v6, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT samples.data_id, uuid, creation_date, provenance, start_date, end_date, binary_samples.payload, a.numerical_value, b.numerical_value, c.numerical_value                                     FROM objects                                     INNER JOIN samples USING (data_id)                                     INNER JOIN binary_samples USING (data_id)                                     LEFT JOIN metadata_values a ON ((a.object_id = samples.data_id) AND (a.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyClassification')))                                     LEFT JOIN metadata_values b ON ((b.object_id = samples.data_id) AND (b.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramHeartRate')))                                     LEFT JOIN metadata_values c ON ((c.object_id = samples.data_id) AND (c.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramSymptoms')))                                     WHERE data_type = 144"), a4, 0, v9);

  return a4 ^ 1;
}

uint64_t _HDRemovePlaceholderAndAddSyncProvenanceToContributorsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9260, a4) ^ 1;

  return v6;
}

uint64_t _HDAddFirstSeenDateToOriginalFHIRResourcesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9290, a4) ^ 1;

  return v6;
}

uint64_t _HDAddCoverageRecordSamplesTable()
{
  return 0;
}

uint64_t _HDAddSCWIColumnToFriendWorkoutTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF92A8, a4) ^ 1;

  return v6;
}

uint64_t _HDAddRequestedScopeToClinicalCredentialsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9278, a4) ^ 1;

  return v6;
}

uint64_t _HDFixInvalidContributorInDataProvenancesTable(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  char v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  char v26;
  uint64_t v27;
  id v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t (*v32)(uint64_t, uint64_t, uint64_t);
  void *v33;
  id v34;
  id v35;
  id v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  _QWORD v43[2];

  v43[1] = *MEMORY[0x1E0C80C00];
  v29 = a1;
  v6 = a2;
  v38 = 0;
  v39 = &v38;
  v40 = 0x2020000000;
  v41 = -1;
  v7 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v8 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("SELECT * FROM data_provenances WHERE contributor_id NOT IN (%@)"), CFSTR("SELECT ROWID from contributors"));
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "protectedDatabase");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = MEMORY[0x1E0C809B0];
  v31 = 3221225472;
  v32 = ___HDFixInvalidContributorInDataProvenancesTable_block_invoke;
  v33 = &unk_1E6CF9A78;
  v37 = &v38;
  v11 = v6;
  v34 = v11;
  v12 = v7;
  v35 = v12;
  v13 = v8;
  v36 = v13;
  v14 = objc_msgSend(v10, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", v9, a4, 0, &v30);

  if ((v14 & 1) == 0)
    goto LABEL_7;
  if (objc_msgSend(v13, "count"))
  {
    v15 = (void *)MEMORY[0x1E0CB3940];
    v16 = v39[3];
    objc_msgSend(v13, "componentsJoinedByString:", CFSTR(","));
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "stringWithFormat:", CFSTR("UPDATE data_provenances SET contributor_id = %lld WHERE ROWID IN (%@)"), v16, v17, v29, v30, v31, v32, v33, v34, v35);
    v18 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v11, "protectedDatabase");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v43[0] = v18;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v43, 1);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    LOBYTE(v16) = objc_msgSend(v19, "executeSQLStatements:error:", v20, a4);

    if ((v16 & 1) == 0)
      goto LABEL_7;
  }
  if (!objc_msgSend(v12, "count"))
    goto LABEL_6;
  v21 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(v12, "componentsJoinedByString:", CFSTR(","));
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v21, "stringWithFormat:", CFSTR("DELETE FROM data_provenances WHERE ROWID IN (%@)"), v22);
  v23 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v11, "protectedDatabase");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v42 = v23;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v42, 1);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = objc_msgSend(v24, "executeSQLStatements:error:", v25, a4);

  if ((v26 & 1) != 0)
LABEL_6:
    v27 = 0;
  else
LABEL_7:
    v27 = 1;

  _Block_object_dispose(&v38, 8);
  return v27;
}

void sub_1B7AB7844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _HDAddOverrideDayIndexRemoveWindDownFromSleepScheduleTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_class *v5;
  id v6;
  id v7;
  void *v8;
  uint64_t v9;

  v5 = (objc_class *)MEMORY[0x1E0C99DE8];
  v6 = a2;
  v7 = objc_alloc_init(v5);
  objc_msgSend(v7, "addObject:", CFSTR("ALTER TABLE sleep_schedule_samples RENAME TO sleep_schedule_samples_old;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE TABLE IF NOT EXISTS sleep_schedule_samples (data_id INTEGER PRIMARY KEY, monday INTEGER NOT NULL, tuesday INTEGER NOT NULL, wednesday INTEGER NOT NULL, thursday INTEGER NOT NULL, friday INTEGER NOT NULL, saturday INTEGER NOT NULL, sunday INTEGER NOT NULL, wake_hour INTEGER, wake_minute INTEGER, bed_hour INTEGER, bed_minute INTEGER, override_day_index INTEGER)"));
  objc_msgSend(v7, "addObject:", CFSTR("INSERT INTO sleep_schedule_samples (data_id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, wake_hour, wake_minute, bed_hour, bed_minute) SELECT data_id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, wake_hour, wake_minute, bed_hour, bed_minute FROM sleep_schedule_samples_old;"));
  objc_msgSend(v7, "addObject:", CFSTR("DROP TABLE sleep_schedule_samples_old;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_monday ON sleep_schedule_samples (monday) WHERE monday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_tuesday ON sleep_schedule_samples (tuesday) WHERE tuesday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_wednesday ON sleep_schedule_samples (wednesday) WHERE wednesday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_thursday ON sleep_schedule_samples (thursday) WHERE thursday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_friday ON sleep_schedule_samples (friday) WHERE friday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_saturday ON sleep_schedule_samples (saturday) WHERE saturday = 1;"));
  objc_msgSend(v7, "addObject:", CFSTR("CREATE INDEX IF NOT EXISTS sleep_schedule_samples_sunday ON sleep_schedule_samples (sunday) WHERE sunday = 1;"));
  objc_msgSend(v6, "protectedDatabase");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = objc_msgSend(v8, "executeSQLStatements:error:", v7, a4) ^ 1;
  return v9;
}

uint64_t _HDUpdateMedicalRecordsCoverageDiagnosticreportProcedureTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  int v7;
  void *v8;
  uint64_t v9;

  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "deleteDataEntitySubclassTablesIfExist:intermediateTables:error:", &unk_1E6DF92C0, &unk_1E6DF92D8, a4);

  if (v7)
  {
    objc_msgSend(v5, "protectedDatabase");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = objc_msgSend(v8, "executeSQLStatements:error:", &unk_1E6DF92F0, a4) ^ 1;

  }
  else
  {
    v9 = 1;
  }

  return v9;
}

uint64_t _HDRepairECGSymptomsStatus(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  id v7;
  _QWORD v9[4];
  id v10;
  __CFString *v11;

  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___HDRepairECGSymptomsStatus_block_invoke;
  v9[3] = &unk_1E6CE8D20;
  v10 = v5;
  v11 = CFSTR("UPDATE ecg_samples SET symptoms_status = ? WHERE data_id = ?;");
  v7 = v5;
  LODWORD(a4) = objc_msgSend(v6, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT objects.data_id, a.numerical_value                                     FROM objects                                     INNER JOIN ecg_samples USING (data_id)                                     LEFT JOIN metadata_values a ON ((a.object_id = objects.data_id) AND (a.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramSymptoms')));"),
                  a4,
                  0,
                  v9);

  return a4 ^ 1;
}

uint64_t _HDMigrateAndDeleteProtectedOnboardingCompletionTable(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6;
  id v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  id v13;
  void *v14;
  int v15;
  void *v16;
  uint64_t v17;
  _QWORD v19[4];
  id v20;
  __CFString *v21;
  uint64_t v22;

  v6 = a1;
  v7 = a2;
  objc_msgSend(v7, "protectedDatabase");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "dumpSchemaWithError:", a4);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v9)
    goto LABEL_7;
  if (!objc_msgSend(MEMORY[0x1E0D29850], "databaseSchemas:containTable:", v9, CFSTR("onboarding_completions")))
  {
    v17 = 0;
    goto LABEL_11;
  }
  v10 = objc_msgSend(v6, "fetchLegacySyncIdentity:error:", v7, a4);
  if (v10 == -1)
  {
LABEL_7:
    v17 = 1;
  }
  else
  {
    v11 = v10;
    objc_msgSend(v7, "protectedDatabase");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v19[2] = ___HDMigrateAndDeleteProtectedOnboardingCompletionTable_block_invoke;
    v19[3] = &unk_1E6CF04C0;
    v13 = v7;
    v20 = v13;
    v21 = CFSTR("INSERT OR REPLACE INTO onboarding_completions (uuid, feature_identifier, version, completion_date, country_code, mod_date, deleted, sync_provenance, sync_identity) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)");
    v22 = v11;
    LODWORD(v11) = objc_msgSend(v12, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT uuid, feature_identifier, version, completion_date, country_code, mod_date, deleted, sync_provenance FROM onboarding_completions"), a4, 0, v19);

    if ((_DWORD)v11
      && (objc_msgSend(v13, "unprotectedDatabase"),
          v14 = (void *)objc_claimAutoreleasedReturnValue(),
          v15 = objc_msgSend(v14, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("DELETE FROM sync_anchors WHERE schema='main' and type=?"), a4, &__block_literal_global_107, 0), v14, v15))
    {
      objc_msgSend(v13, "protectedDatabase");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      v17 = objc_msgSend(v16, "executeUncachedSQL:error:", CFSTR("DROP TABLE IF EXISTS onboarding_completions"), a4) ^ 1;

    }
    else
    {
      v17 = 1;
    }

  }
LABEL_11:

  return v17;
}

uint64_t _HDRecreateCHRConditionsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  int v7;
  void *v8;
  void *v9;
  uint64_t v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "deleteDataEntitySubclassTablesIfExist:intermediateTables:error:", &unk_1E6DF9308, &unk_1E6DF9320, a4);

  if (v7)
  {
    objc_msgSend(v5, "protectedDatabase");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v12[0] = CFSTR("CREATE TABLE condition_record_samples (data_id INTEGER PRIMARY KEY, condition_coding_collection BLOB NOT NULL, categories_coding_collections BLOB NOT NULL, asserter TEXT, abatement BLOB, onset BLOB, recorded_date BLOB, clinical_status_coding BLOB, verification_status_coding BLOB, severity_coding_collection BLOB, body_sites_coding_collections BLOB)");
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v12, 1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = objc_msgSend(v8, "executeSQLStatements:error:", v9, a4) ^ 1;

  }
  else
  {
    v10 = 1;
  }

  return v10;
}

uint64_t _HDUpdateSleepAndAppetiteChangesCategoryValues(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;
  id v7;
  void *v8;
  void *v9;
  uint64_t v10;

  v5 = (void *)MEMORY[0x1E0CB3940];
  v6 = *MEMORY[0x1E0D29790];
  v7 = a2;
  objc_msgSend(v5, "stringWithFormat:", CFSTR("UPDATE category_samples SET value = 0 WHERE data_id IN (SELECT objects.data_id FROM objects INNER JOIN samples USING (data_id) INNER JOIN data_provenances ON (objects.provenance = data_provenances.rowid) WHERE (data_type=164 OR data_type=169 OR data_type=170) AND NOT (%@(origin_build, '17G41') > 0 AND %@(origin_build, '18A1') < 0));"),
    v6,
    v6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "protectedDatabase");
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  v10 = objc_msgSend(v9, "executeUncachedSQL:error:", v8, a4) ^ 1;
  return v10;
}

uint64_t _HDRepairECGSymptomsStatusForNilSymptomsMetadata(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5;
  void *v6;
  id v7;
  _QWORD v9[4];
  id v10;
  __CFString *v11;

  v5 = a2;
  objc_msgSend(v5, "protectedDatabase");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = ___HDRepairECGSymptomsStatusForNilSymptomsMetadata_block_invoke;
  v9[3] = &unk_1E6CE8D20;
  v10 = v5;
  v11 = CFSTR("UPDATE ecg_samples SET symptoms_status = ? WHERE data_id = ?;");
  v7 = v5;
  LODWORD(a4) = objc_msgSend(v6, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", CFSTR("SELECT objects.data_id, a.numerical_value                                     FROM objects                                     INNER JOIN ecg_samples USING (data_id)                                     LEFT JOIN metadata_values a ON ((a.object_id = objects.data_id) AND (a.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramSymptoms')));"),
                  a4,
                  0,
                  v9);

  return a4 ^ 1;
}

uint64_t _HDUpdateNullTypeValesInObjectsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeUncachedSQL:error:", CFSTR("UPDATE objects SET type=1 WHERE type IS NULL"), a4) ^ 1;

  return v6;
}

uint64_t _HDRenameSCWIAndAddSeymourMediaTypeColumnToFriendWorkoutTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9338, a4) ^ 1;

  return v6;
}

uint64_t _HDUpdateCoverageAddIdentifierColumnsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  uint64_t v6;

  objc_msgSend(a2, "protectedDatabase");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "executeSQLStatements:error:", &unk_1E6DF9350, a4) ^ 1;

  return v6;
}

void sub_1B7AB8A68(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x228], 8);
  _Unwind_Resume(a1);
}

void sub_1B7AB8FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDSyncAnchorRangeDescription(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("(%lld, %lld)"), a1, a2);
}

uint64_t HDSyncVersionRangeToString(unint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("[%d, %d]"), a1, HIDWORD(a1));
}

void sub_1B7ABA0CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__99(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__99(uint64_t a1)
{

}

void sub_1B7ABA480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_1B7ABA768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

void sub_1B7ABB238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__100(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__100(uint64_t a1)
{

}

void sub_1B7ABC0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_1B7ABCB90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B7ABDC0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7ABF348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B7AC0C14(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Block_object_dispose((const void *)(v1 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_1B7AC46D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__101(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__101(uint64_t a1)
{

}

void sub_1B7AC7178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

