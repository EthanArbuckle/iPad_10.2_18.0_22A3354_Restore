uint64_t aj_get_rowptrs(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _BYTE *buffer;
  uint64_t result;

  v4 = *(_DWORD *)(a1 + 6464);
  if (v4 < 1)
  {
LABEL_9:
    result = 0;
    *(_BYTE *)(a2 + 560) = 1;
  }
  else
  {
    v7 = 0;
    while (1)
    {
      v8 = *(int *)(a1 + 4 * v7 + 6684);
      if ((_DWORD)v8)
        break;
LABEL_8:
      ++v7;
      a3 += 16;
      if (v7 >= v4)
        goto LABEL_9;
    }
    v9 = *(_QWORD *)(a1 + 16 * v7 + 6712);
    v10 = a3;
    while (1)
    {
      buffer = aj_rowbuffer_get_buffer((unsigned int *)(a2 + 152), v9);
      *v10 = buffer;
      if (!buffer)
        return 1;
      ++v10;
      if (!--v8)
      {
        v4 = *(_DWORD *)(a1 + 6464);
        goto LABEL_8;
      }
    }
  }
  return result;
}

_BYTE *aj_rowbuffer_get_buffer(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  _BYTE **v6;
  _BYTE *v7;

  v2 = *a1;
  if ((int)v2 < 1)
  {
LABEL_9:
    aj_log_error(0, "No buffers available of length: %d", a2);
    return 0;
  }
  else
  {
    v3 = 0;
    v4 = a1 + 2;
    while (1)
    {
      if (*(_QWORD *)&a1[10 * v3 + 4] == a2)
      {
        v5 = *(_QWORD *)&v4[10 * v3];
        if (v5)
          break;
      }
LABEL_8:
      if (++v3 == v2)
        goto LABEL_9;
    }
    v6 = *(_BYTE ***)&v4[10 * v3 + 4];
    while (1)
    {
      v7 = *v6;
      if (!**v6)
        break;
      ++v6;
      if (!--v5)
        goto LABEL_8;
    }
    *v7 = 1;
    return v7 + 16;
  }
}

uint64_t applejpeg_decode_open_file(uint64_t a1, unint64_t a2, unsigned __int8 a3)
{
  return decode_open(a1, a2, 0, a3, 0);
}

void applejpeg_decode_destroy(_QWORD *a1)
{
  NSObject *os_log_object;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(_QWORD *, uint64_t);
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;

  os_log_object = aj_get_os_log_object();
  if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_DEBUG))
  {
    applejpeg_decode_destroy_cold_1((uint64_t)a1, os_log_object, v3, v4, v5, v6, v7, v8);
    if (!a1)
      return;
  }
  else if (!a1)
  {
    return;
  }
  v10 = (void (*)(_QWORD *, uint64_t))a1[1];
  v9 = a1[2];
  dec_free_allocations((uint64_t)(a1 + 524), (uint64_t)a1, (uint64_t)(a1 + 1625), (uint64_t)(a1 + 1396));
  v11 = 0;
  v12 = 1;
  do
  {
    v13 = 0;
    v14 = v12;
    v15 = (uint64_t)&a1[v11 + 469];
    do
    {
      if (!aj_huffman_decode_is_static_table(*(char **)(v15 + v13)))
      {
        v16 = *(_QWORD **)(v15 + v13);
        if (v16)
        {
          v10(v16, v9);
          *(_QWORD *)(v15 + v13) = 0;
        }
      }
      v13 += 16;
    }
    while (v13 != 64);
    v12 = 0;
    v11 = 1;
  }
  while ((v14 & 1) != 0);
  v17 = (_QWORD *)a1[1632];
  if (v17)
  {
    v10(v17, v9);
    a1[1632] = 0;
  }
  v18 = (_QWORD *)a1[1633];
  if (v18)
  {
    v10(v18, v9);
    a1[1633] = 0;
  }
  v19 = (_QWORD *)a1[1634];
  if (v19)
  {
    v10(v19, v9);
    a1[1634] = 0;
  }
  v20 = (_QWORD *)a1[1635];
  if (v20)
  {
    v10(v20, v9);
    a1[1635] = 0;
  }
  v21 = (_QWORD *)a1[1636];
  if (v21)
  {
    v10(v21, v9);
    a1[1636] = 0;
  }
  v22 = (_QWORD *)a1[1637];
  if (v22)
  {
    v10(v22, v9);
    a1[1637] = 0;
  }
  v23 = (_QWORD *)a1[1638];
  if (v23)
  {
    v10(v23, v9);
    a1[1638] = 0;
  }
  v10(a1, v9);
}

BOOL aj_huffman_decode_is_static_table(char *a1)
{
  uint64_t v1;
  char v2;
  _BOOL8 v4;

  v1 = 0;
  v2 = 1;
  do
  {
    v4 = (char *)&std_huffman_luma + 4500 * v1 == a1 || (char *)&std_huffman_chroma + 4500 * v1 == a1;
    if ((v2 & 1) == 0)
      break;
    v2 = 0;
    v1 = 1;
  }
  while (!v4);
  return v4;
}

uint64_t dec_free_allocations(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  unint64_t v11;
  uint64_t *v12;

  if (*(_BYTE *)(result + 16))
  {
    v7 = result;
    aj_bufferprocessor_free_chain(result, a4, a2);
    aj_rowbuffer_destroy((int *)(a4 + 152), a2);
    v8 = *(_QWORD *)(v7 + 6952);
    if (v8 && *(int *)(v7 + 6948) >= 2)
    {
      v9 = 0;
      v10 = (int *)(v8 + 168);
      do
      {
        aj_bufferprocessor_free_chain(v7, (uint64_t)(v10 - 38), a2);
        aj_rowbuffer_destroy(v10, a2);
        ++v9;
        v10 += 418;
      }
      while (v9 < *(int *)(v7 + 6948) - 1);
    }
    v11 = a3 + 40;
    v12 = (uint64_t *)(a3 + 16);
    do
    {
      result = *v12;
      if (*v12)
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 8))(result, *(_QWORD *)(a2 + 16));
        *v12 = 0;
      }
      ++v12;
    }
    while ((unint64_t)v12 < v11);
    *(_BYTE *)(v7 + 16) = 0;
  }
  return result;
}

uint64_t aj_rowbuffer_destroy(int *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;
  uint64_t v7;
  BOOL v8;

  result = 8;
  if (a1 && a2)
  {
    v5 = *a1;
    if (*a1 >= 1)
    {
      do
      {
        v6 = v5 - 1;
        v7 = *(_QWORD *)&a1[10 * (v5 - 1) + 8];
        if (v7)
        {
          (*(void (**)(uint64_t, _QWORD))(a2 + 8))(v7, *(_QWORD *)(a2 + 16));
          v5 = *a1;
          v6 = *a1 - 1;
          *(_QWORD *)&a1[10 * v6 + 8] = 0;
        }
        *a1 = v6;
        v8 = v5 <= 1;
        v5 = v6;
      }
      while (!v8);
    }
    return 0;
  }
  return result;
}

uint64_t aj_bufferprocessor_free_chain(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);

  v3 = *(_QWORD *)(a2 + 1488);
  *(_QWORD *)(a2 + 1488) = 0;
  if (v3)
  {
    v6 = result;
    do
    {
      v7 = *(_QWORD *)(v3 + 80);
      v8 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v3 + 24);
      if (v8)
        v8(v3, v6, a2, a3);
      result = (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 8))(v3, *(_QWORD *)(a3 + 16));
      v3 = v7;
    }
    while (v7);
  }
  return result;
}

_OWORD *applejpeg_decode_create(_QWORD *a1)
{
  _OWORD *v2;
  _OWORD *v3;
  NSObject *os_log_object;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  if (!a1 || !*a1 || !a1[1])
    return 0;
  v2 = (_OWORD *)((uint64_t (*)(uint64_t, _QWORD))*a1)(13120, a1[2]);
  v3 = v2;
  if (v2)
  {
    bzero(v2, 0x3340uLL);
    bzero(v3, 0x3340uLL);
    os_log_object = aj_get_os_log_object();
    if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_DEBUG))
      applejpeg_decode_create_cold_1((uint64_t)v3, os_log_object, v5, v6, v7, v8, v9, v10);
    v11 = *(_OWORD *)a1;
    *((_QWORD *)v3 + 2) = a1[2];
    *v3 = v11;
    *((_QWORD *)v3 + 1625) = v3;
    *((_QWORD *)v3 + 1631) = v3;
    *((_QWORD *)v3 + 448) = 0x100000001;
    *((_DWORD *)v3 + 898) = 0;
    *(_QWORD *)((char *)v3 + 3596) = -1;
    *(_QWORD *)((char *)v3 + 3604) = -1;
    *((_DWORD *)v3 + 903) = 0;
    *((_QWORD *)v3 + 452) = 0;
    *((_QWORD *)v3 + 459) = 0;
    *((_QWORD *)v3 + 458) = 0;
    *((_QWORD *)v3 + 457) = 0x1FF000000;
    v3[230] = xmmword_20627C5A0;
    *(_OWORD *)((char *)v3 + 3624) = 0u;
    *(_OWORD *)((char *)v3 + 3640) = 0u;
    *((_DWORD *)v3 + 924) = 0;
    *((_DWORD *)v3 + 931) = 0;
    *((_QWORD *)v3 + 464) = 0;
    *((_QWORD *)v3 + 463) = 0;
    *((_BYTE *)v3 + 3720) = 0;
    *((_BYTE *)v3 + 3728) = 1;
    *((_BYTE *)v3 + 12697) = 0;
    *((_DWORD *)v3 + 3232) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Could not allocate memory for session object");
  }
  return v3;
}

uint64_t aj_read_exif (uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  int pos;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = 0;
  result = aj_istream_read_bytes_be(a2, (int *)&v11 + 1, 2);
  if (!(_DWORD)result)
  {
    pos = aj_istream_get_pos(a2);
    v9 = HIDWORD(v11);
    v10 = (pos + HIDWORD(v11) - 2);
    *(_DWORD *)(a4 + 32) = v10;
    if (v9 <= 0xB)
    {
LABEL_3:
      *(_QWORD *)(a2 + 104) = 0;
      LODWORD(result) = aj_istream_move_to_position(a2, v10);
      if ((_DWORD)result)
        return result;
      else
        return 11;
    }
    result = aj_istream_read_bytes_be(a2, (int *)&v11 + 1, 4);
    if (!(_DWORD)result)
    {
      result = aj_istream_read_bytes_be(a2, (int *)&v11, 2);
      if (!(_DWORD)result)
      {
        if (v11 == 0x4578696600000000)
        {
          result = read_tiff(a2, a3, v10, a4);
          if ((_DWORD)result == -2)
            return result;
          if (!(_DWORD)result)
          {
            *(_QWORD *)(a2 + 104) = 0;
            return aj_istream_move_to_position(a2, v10);
          }
        }
        goto LABEL_3;
      }
    }
  }
  return result;
}

uint64_t read_tiff(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int pos;
  uint64_t v9;
  int v10;
  uint64_t (*v12)(uint64_t, _WORD *);
  uint64_t (*v13)(uint64_t, _DWORD *);
  uint64_t v14;
  int v15;
  __int16 v16;
  int v17;

  pos = aj_istream_get_pos(a1);
  if (pos + 8 > a3)
  {
    aj_log_error((uint64_t)"Read", "Not enough data in Exif segment");
    return 4;
  }
  v10 = pos;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v9 = aj_istream_read_bytes_be(a1, &v17, 2);
  if ((_DWORD)v9)
    return v9;
  if (v17 == 18761)
  {
    v12 = geth_little;
    v13 = getw_little;
  }
  else
  {
    if (v17 != 19789)
    {
      aj_log_error((uint64_t)"Read", "Byte order not specified correctly in Exif->TIFF header");
      return 4;
    }
    v12 = geth_big;
    v13 = getw_big;
  }
  *(_QWORD *)(a4 + 40) = v13;
  *(_QWORD *)(a4 + 48) = v12;
  v9 = v12(a1, &v16);
  if ((_DWORD)v9)
    return v9;
  if (v16 != 42)
  {
    aj_log_error((uint64_t)"Read", "Byte order is wrong in Exif->TIFF header");
    return 4;
  }
  v9 = (*(uint64_t (**)(uint64_t, int *))(a4 + 40))(a1, &v15);
  if ((_DWORD)v9)
    return v9;
  if (v15 > (v10 ^ 0x7FFFFFFF))
  {
    aj_log_error((uint64_t)"Read", "Too large IFD offset: %d");
    return 4;
  }
  v14 = read_IFD(a1, (v15 + v10), &v15, *(uint64_t (**)(uint64_t, int *))(a4 + 40), *(uint64_t (**)(uint64_t, __int16 *))(a4 + 48), (_DWORD *)(a2 + 3416), a3);
  v9 = v14;
  if ((_DWORD)v14 != -2 && (_DWORD)v14)
    aj_log_error((uint64_t)"Read", "Unknown error while reading IFD");
  return v9;
}

uint64_t read_IFD(uint64_t a1, uint64_t a2, int *a3, uint64_t (*a4)(uint64_t, int *), uint64_t (*a5)(uint64_t, __int16 *), _DWORD *a6, int a7)
{
  uint64_t result;
  int pos;
  int v16;
  int v17;
  int i;
  uint64_t v19;
  int v20;
  __int16 v21;
  __int16 v22;
  unsigned __int16 v23;
  int v24;
  int v25;

  if (a7 - 2 < (int)a2)
    goto LABEL_2;
  if ((a2 & 0x80000000) != 0)
  {
    aj_log_error((uint64_t)"Read", "Corrupt IFD position: %d", a2);
    return 11;
  }
  pos = aj_istream_get_pos(a1);
  if (pos != (_DWORD)a2)
  {
    if (*(_QWORD *)(a1 + 104))
    {
      if (pos >= (int)a2)
      {
        aj_log_error((uint64_t)"Read", "Exif segment with offsets that move backwards not supported with suspension");
        return 3;
      }
      v16 = aj_istream_get_pos(a1);
      result = aj_istream_skip_bytes(a1, (int)a2 - v16);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      result = aj_istream_move_to_position(a1, a2);
      if ((_DWORD)result)
        return result;
    }
  }
  v22 = 0;
  v21 = 0;
  result = a5(a1, &v22);
  if (!(_DWORD)result)
  {
    v17 = aj_istream_get_pos(a1);
    if (v17 + 12 * v22 + 4 > a7)
    {
LABEL_2:
      aj_log_error((uint64_t)"Read", "Exif segment ended abruply");
      return 4;
    }
    if (v22 >= 1)
    {
      for (i = 0; i < v22; ++i)
      {
        result = a5(a1, &v21);
        if ((_DWORD)result)
          return result;
        if (v21 != 274)
        {
          result = aj_istream_skip_bytes(a1, 10);
          goto LABEL_25;
        }
        v24 = 0;
        v23 = 0;
        result = a5(a1, (__int16 *)&v23);
        if (!(_DWORD)result)
        {
          if (v23 - 13 <= 0xFFFFFFF3)
          {
            aj_log_error((uint64_t)"Read", "erroneous data format");
LABEL_24:
            result = 4;
            goto LABEL_25;
          }
          if (v23 == 10 || v23 == 5)
          {
            aj_log_error((uint64_t)"Read", "Rationale data format not supported");
            goto LABEL_24;
          }
          if (v23 - 11 <= 1)
          {
            aj_log_error((uint64_t)"Read", "Floating point format not supported");
            goto LABEL_24;
          }
          result = a4(a1, &v24);
          if ((_DWORD)result)
            goto LABEL_25;
          if (v24 != 1)
          {
            aj_log_error((uint64_t)"Read", "Multiple data not supported");
            goto LABEL_24;
          }
          *a6 = 0;
          if (((0xC6uLL >> v23) & 1) != 0)
          {
            v25 = 0;
            result = aj_istream_read_bytes_be(a1, &v25, 1);
            if ((_DWORD)result)
              goto LABEL_25;
            *(_BYTE *)a6 = v25;
            v19 = a1;
            v20 = 3;
LABEL_40:
            result = aj_istream_skip_bytes(v19, v20);
            if (!(_DWORD)result)
              goto LABEL_45;
            goto LABEL_25;
          }
          if (v23 == 8 || v23 == 3)
          {
            result = a5(a1, (__int16 *)&v23);
            if ((_DWORD)result)
              goto LABEL_25;
            *(_WORD *)a6 = v23;
            v19 = a1;
            v20 = 2;
            goto LABEL_40;
          }
          if (((0xA10uLL >> v23) & 1) == 0)
            goto LABEL_45;
          result = a4(a1, &v24);
          if (!(_DWORD)result)
          {
            *a6 = v24;
LABEL_45:
            result = 0;
          }
        }
LABEL_25:
        if ((_DWORD)result)
          return result;
      }
    }
    return a4(a1, a3);
  }
  return result;
}

uint64_t geth_big(uint64_t a1, _WORD *a2)
{
  uint64_t result;
  int v4;

  v4 = 0;
  result = aj_istream_read_bytes_be(a1, &v4, 2);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t decode_open(uint64_t a1, unint64_t a2, uint64_t *a3, int a4, int a5)
{
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  int v20;
  uint64_t v21;
  _BOOL4 v22;
  int v23;
  void *v24;

  if (!a1)
    return 8;
  if (!a2 || !a3)
  {
    if (!(a2 | (unint64_t)a3))
    {
      aj_log_error((uint64_t)"Decode", "Input cannot be NULL");
      return 8;
    }
    if (a2)
    {
      if (!*(_QWORD *)a2 || !*(_QWORD *)(a2 + 16))
      {
        aj_log_error((uint64_t)"Decode", "Read/Skip callbacks not set");
        return 8;
      }
      v10 = *(_QWORD *)(a2 + 40);
      if (v10)
      {
        if (v10 <= 0xFFF)
        {
          aj_log_error((uint64_t)"Decode", "The read buffer size must be larger than %d");
          return 8;
        }
        if (v10 >> 31)
        {
          aj_log_error((uint64_t)"Decode", "The read buffer size can't be larger than %d");
          return 8;
        }
      }
      if (*(_QWORD *)(a2 + 48) >> 31)
      {
        aj_log_error((uint64_t)"Decode", "The file size can't be larger than %d");
        return 8;
      }
    }
    else
    {
      if (!*a3 || (v11 = a3[1]) == 0)
      {
        aj_log_error((uint64_t)"Decode", "NULL fields in the memory input struct not allowed");
        return 8;
      }
      if (v11 >> 31)
      {
        aj_log_error((uint64_t)"Decode", "The input buffer size can't be larger than %d");
        return 8;
      }
    }
    v14 = *(_DWORD *)(a1 + 12928);
    if (v14 == 1)
    {
      v22 = 0;
      v20 = 0;
    }
    else
    {
      if (v14)
        goto LABEL_55;
      v12 = aj_istream_move_to_position(a1 + 24, 0);
      if ((_DWORD)v12)
        return v12;
      v15 = *(_QWORD *)(a1 + 3576);
      if (v15)
        (*(void (**)(uint64_t, _QWORD))(a1 + 8))(v15, *(_QWORD *)(a1 + 16));
      v16 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a1)(800, *(_QWORD *)(a1 + 16));
      *(_QWORD *)(a1 + 13056) = v16;
      *(_QWORD *)(a1 + 3576) = v16;
      if (!v16 || (bzero(v16, 0x320uLL), !*(_QWORD *)(a1 + 3576)))
      {
        aj_log_error((uint64_t)"Decode", "Could not allocate segment info buffer");
        return 6;
      }
      *(_DWORD *)(a1 + 3568) = 50;
      if (a2)
      {
        *(_DWORD *)(a1 + 12996) = a4;
        v17 = *(_QWORD *)(a2 + 40);
        v18 = *(_QWORD *)(a2 + 48);
        if (!v17)
          LODWORD(v17) = 4096;
        if (v18 >= (int)v17 || v18 == 0)
          v20 = v17;
        else
          v20 = *(_QWORD *)(a2 + 48);
        v21 = *(_QWORD *)(a1 + 13064);
        if (!v21)
        {
          v24 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a1)(v20, *(_QWORD *)(a1 + 16));
          *(_QWORD *)(a1 + 13064) = v24;
          if (!v24 || (bzero(v24, v20), (v21 = *(_QWORD *)(a1 + 13064)) == 0))
          {
            aj_log_error((uint64_t)"Decode", "Could not allocate read buffer for file input");
            v12 = 6;
            goto LABEL_61;
          }
        }
        *(_DWORD *)(a1 + 12992) = 1;
        aj_istream_init_file(a1 + 24, (_QWORD *)a2, v21, v20, a4, 0);
        *(_DWORD *)(a1 + 12928) = 1;
        v22 = v20 > 6144;
        if (v20 >= 6145 && *(_DWORD *)(a1 + 12992))
        {
          *(_DWORD *)(a1 + 60) = 6144;
          v22 = 1;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 12996) = 0;
        aj_istream_init_mem(a1 + 24, a3, 0, 0);
        v22 = 0;
        v20 = 0;
        *(_DWORD *)(a1 + 12928) = 1;
      }
    }
    kdebug_trace();
    v12 = aj_parse_jpeg((_QWORD *)(a1 + 13048), a1 + 24, a1 + 144, (_DWORD *)(a1 + 12936), (int *)(a1 + 3568), 0, *(_DWORD *)(a1 + 12996), a5, *(_BYTE *)(a1 + 12696));
    kdebug_trace();
    if (v22 && *(_DWORD *)(a1 + 12992))
      *(_DWORD *)(a1 + 60) = v20;
    if ((_DWORD)v12)
    {
      if ((_DWORD)v12 == -2 && *(_DWORD *)(a1 + 12996))
        return 4294967294;
      aj_log_error((uint64_t)"Decode", "Parse returned error code %d", v12);
LABEL_56:
      if ((_DWORD)v12 == -2)
        return 4294967294;
LABEL_61:
      dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
      return v12;
    }
    v23 = *(_DWORD *)(a1 + 176);
    if (*(int *)(a1 + 160) > 2 || v23 >= 3)
    {
      aj_log_error((uint64_t)"Decode", "Unsupported subsampling %dx%d", *(_DWORD *)(a1 + 160), v23);
      v12 = 3;
      goto LABEL_61;
    }
LABEL_55:
    v12 = aj_imageinfo_init((unsigned int *)(a1 + 144), a1 + 3744, a1);
    if (!(_DWORD)v12)
    {
      *(_DWORD *)(a1 + 12928) = 2;
      return v12;
    }
    goto LABEL_56;
  }
  aj_log_error((uint64_t)"Decode", "Cannot have both file input AND memory input");
  return 8;
}

uint64_t aj_istream_move_to_position(uint64_t a1, uint64_t a2)
{
  int v4;
  unsigned int v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(_QWORD);
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  BOOL v18;
  int v19;
  int v20;
  int v21;

  if ((a2 & 0x80000000) != 0)
  {
    aj_log_error((uint64_t)"Istream", "Attempting to move to %d which is < 0");
    return 8;
  }
  if (!*(_QWORD *)(a1 + 80))
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 40) + a2;
    v7 = *(_DWORD *)(a1 + 52) - a2;
    goto LABEL_8;
  }
  v4 = *(_DWORD *)(a1 + 32);
  v5 = a2 - (*(_DWORD *)(a1 + 48) - v4);
  if (!v5)
    return 0;
  if ((v5 & 0x80000000) != 0)
  {
    v11 = (*(_DWORD *)(a1 + 48) - v4 - a2);
    v12 = *(_QWORD *)(a1 + 8);
    if (v12 - *(_QWORD *)(a1 + 40) < v11)
    {
      v13 = *(uint64_t (**)(_QWORD))(a1 + 88);
      if (v13)
      {
        result = v13(*(_QWORD *)(a1 + 64));
        if ((_DWORD)result)
          return result;
        *(_DWORD *)(a1 + 56) = 0;
        *(_DWORD *)(a1 + 48) = 0;
        result = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 72))(a2, *(_QWORD *)(a1 + 64));
        if ((_DWORD)result)
          return result;
        *(_DWORD *)(a1 + 48) += a2;
        v21 = 0;
        result = read_bytes_with_callback(a1, *(_QWORD *)(a1 + 40), *(_DWORD *)(a1 + 36), &v21);
        if ((_DWORD)result)
          return result;
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 40);
        v7 = v21;
        goto LABEL_8;
      }
      aj_log_error((uint64_t)"Istream", "No rewind or skip function provided");
      return 8;
    }
    *(_QWORD *)(a1 + 8) = v12 - v11;
    v7 = v4 - v5;
LABEL_8:
    *(_DWORD *)(a1 + 32) = v7;
    goto LABEL_9;
  }
  if (v4 >= (int)v5)
  {
    *(_QWORD *)(a1 + 8) += v5;
    v14 = v4 - v5;
    *(_DWORD *)(a1 + 32) = v14;
    if (!v14)
    {
      result = aj_istream_move_forward(a1);
      if ((_DWORD)result)
        return result;
    }
LABEL_9:
    result = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_DWORD *)a1 = 0;
    *(_QWORD *)(a1 + 24) = 0x1FFFFFFF7;
    return result;
  }
  v8 = (a2 - *(_DWORD *)(a1 + 48));
  result = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 72))(v8, *(_QWORD *)(a1 + 64));
  if (!(_DWORD)result)
  {
    v9 = *(_DWORD *)(a1 + 48) + v8;
    *(_DWORD *)(a1 + 48) = v9;
    if (*(_DWORD *)(a1 + 56) == 2)
    {
      v10 = 0;
LABEL_44:
      *(_DWORD *)(a1 + 32) = v10;
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 40);
      goto LABEL_9;
    }
    v10 = 0;
    v15 = *(_QWORD *)(a1 + 40);
    v16 = *(_DWORD *)(a1 + 36);
    while (1)
    {
      v17 = *(_DWORD *)(a1 + 52);
      if (v17)
        v18 = v9 < v17;
      else
        v18 = 1;
      if (!v18)
      {
        *(_DWORD *)(a1 + 56) = 2;
LABEL_37:
        if ((v9 & 0x80000000) == 0)
          goto LABEL_44;
        aj_log_error((uint64_t)"Istream", "File is larger than %d bytes, aborting");
        return 9;
      }
      if (*(_DWORD *)(a1 + 56) == 1)
        *(_DWORD *)(a1 + 56) = 0;
      v19 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 80))(v15 + v10, (v16 - v10), *(_QWORD *)(a1 + 64));
      if (v19 <= 0)
        break;
      v9 = *(_DWORD *)(a1 + 48) + v19;
      *(_DWORD *)(a1 + 48) = v9;
      v10 += v19;
      if (v10 >= 8)
        goto LABEL_37;
    }
    if (!v19)
    {
      v20 = 1;
      goto LABEL_43;
    }
    if (v19 == -1)
    {
      v20 = 2;
LABEL_43:
      *(_DWORD *)(a1 + 56) = v20;
      goto LABEL_44;
    }
    aj_log_error((uint64_t)"Istream", "File read error");
    return 9;
  }
  return result;
}

uint64_t aj_init_huffman(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  char v7;
  uint64_t v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  unsigned int *v12;
  _BOOL4 v13;
  uint64_t v14;
  char **v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  int v21;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int *v26;
  unsigned __int8 v27;

  if (!*((_BYTE *)a1 + 84))
  {
    v6 = 0;
    v24 = a1 + 839;
    v23 = a1 + 843;
    v7 = 1;
    while (2)
    {
      v8 = 0;
      v10 = v7 & 1;
      v9 = v10 == 0;
      v27 = v10;
      if (v10)
        v11 = 839;
      else
        v11 = 843;
      v12 = v24;
      if (v9)
        v12 = v23;
      v26 = v12;
      do
      {
        v13 = v8 == a1[v11];
        if (*((_BYTE *)a1 + 2 * v8 + v6 + 3320))
        {
          v14 = a2 + 16 * v8 + 8 * v6;
          v16 = *(_QWORD *)(v14 + 8);
          v15 = (char **)(v14 + 8);
          if (!v16)
          {
            if (aj_huffman_is_standard_table(&a1[8 * v8 + 286 + 4 * v6], &a1[128 * v8 + 318 + 64 * v6], v13, v27))
            {
              *v15 = aj_huffman_decode_get_standard_table(v13, v27);
            }
            else
            {
              if (*v15)
                (*(void (**)(char *, _QWORD))(a3 + 8))(*v15, *(_QWORD *)(a3 + 16));
              v17 = (char *)(*(uint64_t (**)(uint64_t, _QWORD))a3)(4500, *(_QWORD *)(a3 + 16));
              *v15 = v17;
              if (!v17 || (bzero(v17, 0x1194uLL), !*v15))
              {
                aj_log_error((uint64_t)"DecodeInit", "Could not allocate memory for huffman table");
                return 6;
              }
              v18 = aj_huffman_decode_init();
              if ((_DWORD)v18)
              {
                v3 = v18;
                aj_log_error((uint64_t)"DecodeInit", "Make tables returned error code %d", v18);
                return v3;
              }
              v19 = *a1;
              v20 = (int *)v26;
              if ((int)v19 >= 1)
              {
                while (1)
                {
                  v21 = *v20++;
                  if (v8 == v21)
                    break;
                  if (!--v19)
                    goto LABEL_15;
                }
                if (!*((_WORD *)*v15 + 2248))
                {
                  aj_log_error((uint64_t)"DecodeInit", "Huffman table (class %d, ind %d) is being used but contains no symbols", v6, v8);
                  return 4;
                }
              }
            }
          }
        }
LABEL_15:
        ++v8;
      }
      while (v8 != 4);
      v7 = 0;
      v6 = 1;
      if ((v27 & 1) != 0)
        continue;
      break;
    }
  }
  return 0;
}

BOOL aj_huffman_is_standard_table(_QWORD *a1, const void *a2, int a3, int a4)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  size_t v9;
  _BOOL8 result;

  v4 = (char *)&std_huffman_luma;
  if (!a3)
    v4 = (char *)&std_huffman_chroma;
  v5 = &v4[4500 * (a4 == 0)];
  v7 = *(_QWORD *)v5;
  v6 = *((_QWORD *)v5 + 1);
  v8 = v7 == *a1 && v6 == a1[1];
  result = 0;
  if (v8)
  {
    v9 = a4 ? 16 : 256;
    if (!memcmp(&v4[4500 * (a4 == 0) + 16], a2, v9))
      return 1;
  }
  return result;
}

char *aj_huffman_decode_get_standard_table(int a1, int a2)
{
  char *v2;

  v2 = (char *)&std_huffman_luma;
  if (!a1)
    v2 = (char *)&std_huffman_chroma;
  return &v2[4500 * (a2 == 0)];
}

uint64_t aj_imageinfo_init(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  int v4;
  signed int v5;
  unsigned int *v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;

  *(_QWORD *)(a2 + 72) = 0;
  v3 = *a1;
  if ((int)*a1 < 1)
  {
    v4 = 0;
    v5 = 0;
  }
  else
  {
    v4 = 0;
    v5 = 0;
    v6 = a1 + 8;
    v7 = *a1;
    do
    {
      if (v5 <= (int)*(v6 - 4))
        v5 = *(v6 - 4);
      *(_DWORD *)(a2 + 72) = v5;
      v9 = *v6++;
      v8 = v9;
      if (v4 <= v9)
        v4 = v8;
      *(_DWORD *)(a2 + 76) = v4;
      --v7;
    }
    while (v7);
  }
  if (!*((_BYTE *)a1 + 86))
  {
    v5 *= 8;
    v4 *= 8;
    *(_DWORD *)(a2 + 72) = v5;
    *(_DWORD *)(a2 + 76) = v4;
  }
  v10 = a1[4] * a1[8];
  *(_DWORD *)(a2 + 88) = v10;
  *(_DWORD *)(a2 + 92) = v3 + v10 - 1;
  v11 = (int)(v4 + a1[3] - 1) / v4;
  *(_DWORD *)(a2 + 80) = (int)(v5 + a1[2] - 1) / v5;
  *(_DWORD *)(a2 + 84) = v11;
  return aj_init_huffman(a1, a2, a3);
}

uint64_t aj_istream_skip_bytes(uint64_t a1, int a2)
{
  int v2;
  uint64_t result;
  int v5;
  int v6;
  BOOL v7;

  v2 = a2;
  if (!*(_BYTE *)(a1 + 112) || !*(_QWORD *)(a1 + 104) || *(_DWORD *)(a1 + 32) >= a2)
    return aj_istream_move_to_position(a1, (*(_DWORD *)(a1 + 48) + a2 - *(_DWORD *)(a1 + 32)));
  if (a2 < 1)
    return 0;
  while (1)
  {
    result = aj_istream_move_forward(a1);
    if ((_DWORD)result)
      break;
    v5 = *(_DWORD *)(a1 + 32);
    if (!v5)
    {
      result = 7;
      if (*(_BYTE *)(a1 + 112))
      {
        if (*(_DWORD *)(a1 + 56) == 1)
          return 4294967294;
        else
          return 7;
      }
      return result;
    }
    if (v5 >= v2)
      v6 = v2;
    else
      v6 = *(_DWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 8) += v6;
    *(_DWORD *)(a1 + 32) = v5 - v6;
    v7 = __OFSUB__(v2, v6);
    v2 -= v6;
    if ((v2 < 0) ^ v7 | (v2 == 0))
      return 0;
  }
  return result;
}

uint64_t aj_huffman_decode_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char v3;
  char v4;
  int v5;
  int v6;
  const void *v7;
  const void *v8;
  _OWORD *v9;
  uint64_t v10;
  unsigned __int16 v11;
  int v12;
  uint64_t i;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  _DWORD *v21;
  int *v22;
  int v23;
  int v24;
  BOOL v25;
  _BOOL4 v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t j;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  unsigned __int8 *v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  int *v52;
  int v53;
  int *v54;
  int v55;
  uint64_t v56;
  uint64_t k;
  int v58;
  int v59;
  int v60;
  _DWORD *v61;
  int v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  unsigned int v68;
  int v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  _DWORD v77[512];
  _DWORD v78[256];
  _DWORD v79[256];
  uint64_t v80;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = (_OWORD *)v0;
  v80 = *MEMORY[0x24BDAC8D0];
  bzero(v79, 0x400uLL);
  bzero(v78, 0x400uLL);
  bzero(v77, 0x800uLL);
  v10 = 0;
  v11 = 0;
  *(_BYTE *)(v2 + 4498) = v4;
  *(_OWORD *)v2 = *v9;
  *(_WORD *)(v2 + 4496) = 0;
  do
  {
    v11 += *(unsigned __int8 *)(v2 + v10);
    *(_WORD *)(v2 + 4496) = v11;
    ++v10;
  }
  while (v10 != 16);
  if ((unsigned __int16)(v11 - 256) < 0xFF01u)
  {
    aj_log_error((uint64_t)"Huff", "Illegal number of symbols in huffman table. nsyms = %d");
    return 7;
  }
  memcpy((void *)(v2 + 16), v8, v11);
  v12 = 0;
  for (i = 1; i != 17; ++i)
  {
    v14 = *(unsigned __int8 *)(i + v2 - 1);
    if (*(_BYTE *)(i + v2 - 1))
    {
      v15 = &v79[v12];
      v12 += v14;
      do
      {
        *v15++ = i;
        --v14;
      }
      while (v14);
    }
  }
  v16 = v79[0];
  if (v79[0])
  {
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = v79[0];
    while (1)
    {
      if (v20 == v18)
      {
        v21 = &v78[v17];
        v22 = &v79[v17 + 1];
        do
        {
          *v21++ = v19++;
          v24 = *v22++;
          v23 = v24;
          ++v17;
        }
        while (v24 == v20);
        v20 = v23;
      }
      if (v19 > 1 << v18)
      {
        aj_log_error((uint64_t)"Huff", "Illegal huffmann code: too large for length (0x%08x > 0x%08x)");
        return 7;
      }
      if (v19 == 1 << v18)
      {
        v25 = v17 >= 256 || v20 == 0;
        v26 = !v25;
        if (!v6 || v26)
          break;
      }
      v19 *= 2;
      ++v18;
      v20 = v79[v17];
      if (!v20)
        goto LABEL_27;
    }
    aj_log_error((uint64_t)"Huff", "Illegal huffmann code: may not be all ones");
    return 7;
  }
LABEL_27:
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 30;
  do
  {
    v31 = v2 + 4 * v27;
    *(_DWORD *)(v31 + 336) = v29;
    v32 = *(unsigned __int8 *)(v2 + v27);
    v29 += v32;
    v28 += v32 << v30;
    *(_DWORD *)(v31 + 272) = v28;
    ++v27;
    --v30;
  }
  while (v27 != 16);
  v33 = 0;
  do
  {
    v34 = v33 - 1;
    if (v33 == -15)
      break;
  }
  while (!*(unsigned __int8 *)(v2 + v33-- + 15));
  if (v34 != -1)
  {
    v36 = v2 + v34;
    do
      *(_DWORD *)(v2 + 404 + 4 * v34++) += *(unsigned __int8 *)(v36 + 16);
    while (v34 != -1);
  }
  *(_DWORD *)(v2 + 332) = 0x80000000;
  memset_pattern16((void *)(v2 + 400), &unk_20627B3C0, 0x800uLL);
  for (j = 0; j != 2048; j += 16)
  {
    v38 = (_QWORD *)(v2 + 2448 + j);
    *v38 = 0;
    v38[1] = 0;
  }
  v39 = 0;
  v40 = v2 + 400;
  v41 = *(unsigned __int8 *)(v2 + 4498);
  do
  {
    v42 = v79[v39];
    if (!v42)
      break;
    v43 = (unsigned __int8 *)(v2 + v39 + 16);
    v44 = *v43;
    if (!v41 || v44 <= 0xF)
    {
      if (v42 > 9)
        break;
      v45 = v44 & 0xF;
      v46 = v42 + v45;
      v47 = v78[v39] << (9 - v42);
      if (v42 + v45 > 9)
      {
        if (v42 != -22)
        {
          v54 = (int *)(v40 + 4 * v47);
          v55 = (1 << (9 - v42)) + 1;
          do
          {
            *v54++ = (v42 << 8) | (*v43 << 18) | (*v43 >> 4) | 0x20000;
            --v55;
          }
          while (v55 > 1);
        }
      }
      else
      {
        v48 = 0;
        do
        {
          if (v46 != -22)
          {
            if (v48 >> (v45 - 1))
              v49 = 0;
            else
              v49 = (0x7FFFFFFF << v45) | 1;
            v50 = (v49 + v48) << 18;
            if (!v45)
              v50 = 0;
            v51 = v50 | (v46 << 8);
            v52 = (int *)(v40 + 4 * (int)((v48 << (9 - v46)) + v47));
            v53 = (1 << (9 - v46)) + 1;
            do
            {
              *v52++ = v51 | (*v43 >> 4);
              --v53;
            }
            while (v53 > 1);
          }
          ++v48;
        }
        while (!(v48 >> v45));
      }
    }
    ++v39;
  }
  while (v39 != 256);
  if (!v41)
  {
    LODWORD(v56) = 0;
    for (k = 1; k != 10; ++k)
    {
      v58 = *(unsigned __int8 *)(k + v2 - 1);
      if (*(_BYTE *)(k + v2 - 1))
      {
        v59 = 0;
        v56 = (int)v56;
        do
        {
          v60 = k + (*(unsigned __int8 *)(v2 + v56 + 16) << 8);
          v61 = &v77[v78[v56] << (9 - k)];
          v62 = (1 << (9 - k)) + 1;
          do
          {
            *v61++ = v60;
            --v62;
          }
          while (v62 > 1);
          ++v59;
          ++v56;
        }
        while (v59 != v58);
      }
    }
    v63 = 0;
    do
    {
      if (v16 <= 9)
      {
        v64 = 0;
        v65 = 0;
        v68 = v63 << 23;
        v67 = 9;
        while (1)
        {
          v69 = v77[v68 >> 23];
          if (v69 - 1 >= v67)
          {
            LOBYTE(v67) = 0;
LABEL_75:
            v66 = 0;
            goto LABEL_77;
          }
          if (v69 <= 0xFF)
            break;
          v70 = ((v69 >> 8) & 0xF) + v69;
          v64 += (v69 >> 12) + 1;
          v67 = (v67 - v70) & ~((v67 - v70) >> 31);
          v68 <<= v70;
          v65 += v70;
          if (v67 < v16)
            goto LABEL_75;
        }
        v67 = (v67 - v69) & ~((v67 - v69) >> 31);
        v65 += v69;
        v66 = 0x10000;
      }
      else
      {
        v64 = 0;
        v65 = 0;
        v66 = 0;
        LOBYTE(v67) = 9;
      }
LABEL_77:
      v71 = 0;
      v72 = v64 + (v65 << 8) + v66;
      v73 = v63;
      v74 = v2 + 2448 + 4 * v63;
      do
      {
        v75 = v73 + v71;
        *(_DWORD *)(v74 + 4 * v71++) = v72;
      }
      while (v75 <= 0x1FE && !(v71 >> v67));
      v63 = v73 + v71;
    }
    while ((v73 + v71) <= 0x1FF);
  }
  return 0;
}

uint64_t aj_parse_jpeg(_QWORD *a1, uint64_t a2, uint64_t a3, _DWORD *a4, int *a5, int a6, int a7, int a8, char a9)
{
  unsigned int *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t segment_id_and_length;
  int v21;
  uint64_t dri;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  uint64_t jfif;
  uint64_t exif;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v42;
  int v44;
  uint64_t v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = 0;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v16 = a4 + 8;
  v46 = 0u;
  while (!a4[3])
  {
    v45 = 0;
    v44 = 0;
    if (a7)
      *(_QWORD *)(a2 + 104) = *(_QWORD *)(a2 + 8);
    v17 = *(_OWORD *)(a2 + 80);
    v50 = *(_OWORD *)(a2 + 64);
    v51 = v17;
    v52 = *(_OWORD *)(a2 + 96);
    v53 = *(_QWORD *)(a2 + 112);
    v18 = *(_OWORD *)(a2 + 16);
    v46 = *(_OWORD *)a2;
    v47 = v18;
    v19 = *(_OWORD *)(a2 + 48);
    v48 = *(_OWORD *)(a2 + 32);
    v49 = v19;
    segment_id_and_length = aj_get_segment_id_and_length((uint64_t)&v46, (unsigned int *)&v45 + 1, &v45, &v44, v16, a6);
    if ((_DWORD)segment_id_and_length == -2)
      segment_id_and_length = handle_suspension(a1, a7, a2, (uint64_t)&v46, a5, v44, v45, SHIDWORD(v45), *v16);
    if ((_DWORD)segment_id_and_length)
      return segment_id_and_length;
    v21 = v44;
    if (!(*a4 | a6) && v44 != 216)
    {
      aj_log_error((uint64_t)"Parse", "File does not begin with SOI, first segment is 0x%02X");
      return 4;
    }
    switch(v44)
    {
      case 192:
      case 193:
      case 194:
      case 195:
        if (a9 && a4[4])
        {
          aj_log_error((uint64_t)"Parse", "Found multiple SOF segments. Ignoring any segment after the first.");
          goto LABEL_12;
        }
        segment_id_and_length = aj_read_sof((uint64_t)&v46, (unsigned int *)a3, v44);
        if ((_DWORD)segment_id_and_length)
          goto LABEL_14;
        a4[4] = 1;
        goto LABEL_46;
      case 196:
        segment_id_and_length = aj_read_dht((uint64_t)&v46, a3);
        if ((_DWORD)segment_id_and_length)
          goto LABEL_14;
        a4[6] = 1;
        goto LABEL_46;
      case 197:
      case 198:
      case 199:
      case 201:
      case 202:
      case 203:
      case 205:
      case 206:
      case 207:
        a4[7] = 1;
        goto LABEL_12;
      case 200:
      case 204:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
      case 217:
      case 220:
      case 222:
      case 223:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
        goto LABEL_12;
      case 216:
        HIDWORD(v45) = 0;
        a4[8] = aj_istream_get_pos((uint64_t)&v46);
        *a4 = 1;
        goto LABEL_46;
      case 218:
        if (!a4[4])
        {
          aj_log_error((uint64_t)"Parse", "No supported SOF segment found.");
          if (a4[7])
            return 3;
          else
            return 4;
        }
        segment_id_and_length = aj_read_sos((uint64_t)&v46, (int *)a3);
        if (!(_DWORD)segment_id_and_length)
        {
          a4[3] = 1;
LABEL_46:
          segment_id_and_length = 0;
          v35 = v52;
          *(_OWORD *)(a2 + 80) = v51;
          *(_OWORD *)(a2 + 96) = v35;
          v36 = v50;
          v37 = v53;
          v38 = v47;
          *(_OWORD *)a2 = v46;
          *(_OWORD *)(a2 + 16) = v38;
          v39 = v49;
          *(_OWORD *)(a2 + 32) = v48;
          *(_OWORD *)(a2 + 48) = v39;
          *(_OWORD *)(a2 + 64) = v36;
          *(_QWORD *)(a2 + 104) = 0;
          *(_QWORD *)(a2 + 112) = v37;
LABEL_47:
          v40 = add_segment_info(a1, a5, v21, v45, SHIDWORD(v45));
          if ((_DWORD)v40)
            return v40;
          goto LABEL_48;
        }
LABEL_14:
        if ((_DWORD)segment_id_and_length == -2)
        {
          segment_id_and_length = handle_suspension(a1, a7, a2, (uint64_t)&v46, a5, v21, v45, SHIDWORD(v45), *v16);
          goto LABEL_48;
        }
        v23 = v52;
        *(_OWORD *)(a2 + 80) = v51;
        *(_OWORD *)(a2 + 96) = v23;
        v24 = v50;
        v25 = v53;
        v26 = v47;
        *(_OWORD *)a2 = v46;
        *(_OWORD *)(a2 + 16) = v26;
        v27 = v49;
        *(_OWORD *)(a2 + 32) = v48;
        *(_OWORD *)(a2 + 48) = v27;
        *(_OWORD *)(a2 + 64) = v24;
        *(_QWORD *)(a2 + 104) = 0;
        *(_QWORD *)(a2 + 112) = v25;
        if (v21 != 255)
          goto LABEL_47;
        goto LABEL_48;
      case 219:
        segment_id_and_length = aj_read_dqt((uint64_t)&v46, a3);
        if ((_DWORD)segment_id_and_length)
          goto LABEL_14;
        a4[5] = 1;
        goto LABEL_46;
      case 221:
        dri = aj_read_dri((uint64_t)&v46, a3);
        goto LABEL_13;
      case 224:
        jfif = aj_read_jfif ((uint64_t)&v46);
        if ((_DWORD)jfif != 11)
        {
          segment_id_and_length = jfif;
          if ((_DWORD)jfif)
            goto LABEL_14;
        }
        a4[1] = 1;
        goto LABEL_46;
      case 225:
        if (a4[2])
          goto LABEL_12;
        exif = aj_read_exif ((uint64_t)a1, (uint64_t)&v46, a3, (uint64_t)a4);
        if ((_DWORD)exif != 11)
        {
          segment_id_and_length = exif;
          if ((_DWORD)exif)
            goto LABEL_14;
        }
        a4[2] = 1;
        goto LABEL_46;
      case 238:
        segment_id_and_length = aj_read_app14((uint64_t)&v46, a3);
        if ((_DWORD)segment_id_and_length == 11)
          goto LABEL_46;
        goto LABEL_14;
      default:
        if (v44 == 254)
        {
          dri = aj_read_com((uint64_t)&v46);
          goto LABEL_13;
        }
        if (v44 != 255)
        {
LABEL_12:
          dri = aj_read_unknown_segment((uint64_t)&v46);
LABEL_13:
          segment_id_and_length = dri;
          goto LABEL_14;
        }
        segment_id_and_length = 0;
        v28 = v52;
        *(_OWORD *)(a2 + 80) = v51;
        *(_OWORD *)(a2 + 96) = v28;
        v29 = v50;
        v30 = v53;
        v31 = v47;
        *(_OWORD *)a2 = v46;
        *(_OWORD *)(a2 + 16) = v31;
        v32 = v49;
        *(_OWORD *)(a2 + 32) = v48;
        *(_OWORD *)(a2 + 48) = v32;
        *(_OWORD *)(a2 + 64) = v29;
        *(_QWORD *)(a2 + 104) = 0;
        *(_QWORD *)(a2 + 112) = v30;
LABEL_48:
        if ((_DWORD)segment_id_and_length)
          return segment_id_and_length;
        break;
    }
  }
  if (!a4[6])
  {
    if (!a8)
    {
      aj_log_error((uint64_t)"Parse", "JPEG headers incomplete, no DHT segments found.", v42);
      return 4;
    }
    *(_WORD *)(a3 + 3324) = 257;
    *(_DWORD *)(a3 + 3320) = 16843009;
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1144), (void *)(a3 + 1272), 1, 1);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1176), (void *)(a3 + 1784), 0, 1);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1208), (void *)(a3 + 2296), 0, 1);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1160), (void *)(a3 + 1528), 1, 0);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1192), (void *)(a3 + 2040), 0, 0);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1224), (void *)(a3 + 2552), 0, 0);
    a4[6] = 1;
  }
  if (!a4[5] && !*(_BYTE *)(a3 + 86))
  {
    aj_log_error((uint64_t)"Parse", "JPEG headers incomplete.");
    return 4;
  }
  segment_id_and_length = aj_check_components_and_decimation((int *)a3);
  if (!(_DWORD)segment_id_and_length)
    return aj_check_huffman_tables(a3);
  return segment_id_and_length;
}

uint64_t add_segment_info(_QWORD *a1, int *a2, int a3, int a4, int a5)
{
  int v9;
  char *v10;
  uint64_t result;
  int v12;
  char *v14;
  uint64_t v15;
  char *v16;

  if (!a2)
    return 0;
  v9 = a2[1];
  if (v9 < *a2)
  {
    v10 = (char *)*((_QWORD *)a2 + 1);
LABEL_14:
    result = 0;
    v16 = &v10[16 * v9];
    *((_QWORD *)v16 + 1) = a4;
    *(_DWORD *)v16 = a3;
    *((_DWORD *)v16 + 1) = a5;
    a2[1] = v9 + 1;
    return result;
  }
  if (2 * *a2 >= 2000)
    v12 = 2000;
  else
    v12 = 2 * *a2;
  if (v9 < 2000)
  {
    v14 = (char *)(*(uint64_t (**)(uint64_t, _QWORD))*a1)(16 * v12, *(_QWORD *)(*a1 + 16));
    if (v14)
    {
      v10 = v14;
      bzero(v14, 16 * v12);
      memcpy(v10, *((const void **)a2 + 1), 16 * *a2);
      v15 = *((_QWORD *)a2 + 1);
      if (v15)
        (*(void (**)(uint64_t, _QWORD))(*a1 + 8))(v15, *(_QWORD *)(*a1 + 16));
      *((_QWORD *)a2 + 1) = v10;
      a1[1] = v10;
      *a2 = v12;
      v9 = a2[1];
      goto LABEL_14;
    }
    aj_log_error((uint64_t)"Parse", "Could not allocate memory for segment %d");
  }
  else
  {
    aj_log_error((uint64_t)"Parse", "Number of segments exceed the maximum allowable number (%d)");
  }
  return 6;
}

uint64_t aj_get_segment_id_and_length(uint64_t a1, unsigned int *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int a6)
{
  uint64_t result;
  int pos;
  int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  int v17;

  v17 = 0;
  v16 = 0;
  *a3 = aj_istream_get_pos(a1);
  v15 = 0;
  result = aj_istream_peek_short(a1, &v15);
  if (!(_DWORD)result)
  {
    result = aj_istream_read_bytes_be(a1, &v17, 1);
    if (!(_DWORD)result)
    {
      if (v17 == 255 && v15 != 0xFFFF)
        goto LABEL_6;
      if (a6)
      {
        aj_log_error((uint64_t)"Parse", "Not a valid segment marker: 0x%02X%02X", v17, HIBYTE(v15));
        return 4;
      }
      if ((v15 & 0xFF00) == 0xD800)
      {
LABEL_6:
        result = aj_istream_read_bytes_be(a1, &v17, 1);
        if (!(_DWORD)result)
        {
          *a4 = v17;
          result = aj_istream_peek_short(a1, &v16);
          if (!(_DWORD)result)
          {
            *a2 = bswap32(v16) >> 16;
            pos = aj_istream_get_pos(a1);
            result = 0;
            *a5 = *a2 + pos;
          }
        }
      }
      else
      {
        v14 = aj_istream_get_pos(a1);
        result = 0;
        *a3 = v14;
        *a4 = 255;
      }
    }
  }
  return result;
}

uint64_t aj_istream_get_pos(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 32));
}

uint64_t aj_istream_peek_short(uint64_t a1, _WORD *a2)
{
  uint64_t result;

  if (*(int *)(a1 + 32) > 1)
    goto LABEL_8;
  result = aj_istream_move_forward(a1);
  if ((_DWORD)result)
    return result;
  if (*(int *)(a1 + 32) > 1)
  {
LABEL_8:
    result = 0;
    *a2 = **(_WORD **)(a1 + 8);
  }
  else
  {
    result = 7;
    if (*(_BYTE *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t aj_read_dqt(uint64_t a1, uint64_t a2)
{
  uint64_t bytes_be;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  signed int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v18;

  v18 = 0;
  bytes_be = aj_istream_read_bytes_be(a1, (int *)&v18, 2);
  if (!(_DWORD)bytes_be)
  {
    if ((int)v18 < 3)
    {
      return 0;
    }
    else
    {
      v5 = v18 - 2;
      v6 = a2 + 88;
LABEL_4:
      v7 = aj_istream_read_bytes_be(a1, (int *)&v18, 1);
      if (!(_DWORD)v7)
      {
        v8 = v18 & 0xF;
        if (v8 >= 4)
        {
          bytes_be = 3;
          aj_log_error((uint64_t)"Read", "Index of quantization table is %d. Only indices 0..%d are allowed.", v18 & 0xF, 3);
          return bytes_be;
        }
        v9 = v18 >> 4;
        if (v18 >= 0x10 && v9 != 1)
        {
          aj_log_error((uint64_t)"Read", "Bad precision value (%d), only 0 and 1 are defined.");
          return 4;
        }
        v11 = v5 - 1;
        if (v18 <= 0xF)
          v12 = 1;
        else
          v12 = 2;
        v13 = v12 << 6;
        if (v5 <= v12 << 6)
        {
          aj_log_error((uint64_t)"Read", "Not enough bytes left in header for quantization table. %d bytes remaining, requires >= %d.");
          return 4;
        }
        v14 = 0;
        v15 = v6 + (v8 << 8);
        while (1)
        {
          v7 = aj_istream_read_bytes_be(a1, (int *)&v18, v12);
          if ((_DWORD)v7)
            break;
          *(_DWORD *)(v15 + v14) = v18;
          v14 += 4;
          if (v14 == 256)
          {
            bytes_be = 0;
            v16 = a2 + 4 * v8;
            *(_DWORD *)(v16 + 1112) = 1;
            *(_DWORD *)(v16 + 1128) = v9;
            v5 = v11 - v13;
            v6 = a2 + 88;
            if (v11 > v13)
              goto LABEL_4;
            return bytes_be;
          }
        }
      }
      return v7;
    }
  }
  return bytes_be;
}

uint64_t aj_read_dht(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char v17;
  char *v18;
  uint64_t v19;
  unsigned int v20;
  _OWORD v21[2];
  _QWORD v22[2];

  v22[1] = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  v22[0] = 0;
  memset(v21, 0, sizeof(v21));
  result = aj_istream_read_bytes_be(a1, (int *)&v20, 2);
  if ((_DWORD)result)
    return result;
  if ((int)v20 < 3)
  {
LABEL_20:
    v14 = 0;
    v15 = 1;
    do
    {
      v16 = 0;
      v17 = v15;
      *(_DWORD *)(a2 + 4 * v14 + 3328) += *((_DWORD *)v22 + v14);
      v18 = (char *)v21 + 4 * v14;
      v19 = a2 + 3320 + v14;
      do
      {
        if (*(_DWORD *)&v18[4 * v16])
          *(_BYTE *)(v19 + v16) = 1;
        v16 += 2;
      }
      while (v16 != 8);
      v15 = 0;
      v14 = 1;
    }
    while ((v17 & 1) != 0);
    return 0;
  }
  v5 = v20 - 2;
LABEL_4:
  result = aj_istream_read_bytes_be(a1, (int *)&v20, 1);
  if (!(_DWORD)result)
  {
    if (v5 <= 0x10)
    {
      aj_log_error((uint64_t)"Read", "Not enough bytes in header for Huffman table. %d bytes remaining, requires >= 17.");
    }
    else
    {
      v6 = (unint64_t)v20 >> 4;
      if (v20 < 0x20)
      {
        v7 = v20 & 0xF;
        if (v7 >= 4)
        {
          aj_log_error((uint64_t)"Read", "Huffman table index is %d, only values 0 to 3 are allowed.", v7);
          return 3;
        }
        else
        {
          if (!*(_BYTE *)(a2 + 2 * v7 + v6 + 3320) && !*((_DWORD *)v21 + 2 * v7 + v6))
            ++*((_DWORD *)v22 + v6);
          v8 = 0;
          LODWORD(v9) = 0;
          v10 = a2 + 32 * v7 + 16 * v6 + 1144;
          v11 = (_BYTE *)(a2 + (v7 << 9) + (v6 << 8) + 1272);
          *((_DWORD *)v21 + 2 * v7 + v6) = 1;
          while (1)
          {
            result = aj_istream_read_bytes_be(a1, (int *)&v20, 1);
            if ((_DWORD)result)
              break;
            v12 = v20;
            *(_BYTE *)(v10 + v8) = v20;
            v9 = v12 + v9;
            if (++v8 == 16)
            {
              v13 = v5 - 17;
              v5 = v5 - 17 - v9;
              if (v13 < (int)v9)
              {
                aj_log_error((uint64_t)"Read", "Too few bytes in Huffman header. %d bytes left, requires %d bytes.");
                return 4;
              }
              if ((int)v9 > 256)
              {
                aj_log_error((uint64_t)"Read", "Too many codes in Huffman table: %d codes.");
                return 4;
              }
              if ((int)v9 >= 1)
              {
                do
                {
                  result = aj_istream_read_bytes_be(a1, (int *)&v20, 1);
                  if ((_DWORD)result)
                    return result;
                  *v11++ = v20;
                }
                while (--v9);
              }
              if (v5 > 0)
                goto LABEL_4;
              goto LABEL_20;
            }
          }
        }
        return result;
      }
      aj_log_error((uint64_t)"Read", "Huffman table class is %d, only values 0 and 1 are allowed.");
    }
    return 4;
  }
  return result;
}

uint64_t aj_istream_read_bytes_be(uint64_t a1, int *a2, int a3)
{
  int v3;
  int v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  int v10;

  v3 = a3;
  v6 = *(_DWORD *)(a1 + 32);
  if (v6 < a3)
  {
    result = aj_istream_move_forward(a1);
    if ((_DWORD)result)
      return result;
    v6 = *(_DWORD *)(a1 + 32);
  }
  if (v6 >= v3)
  {
    v8 = 0;
    if (v3)
    {
      v9 = *(_QWORD *)(a1 + 8) + 1;
      v10 = v6 - 1;
      do
      {
        *(_DWORD *)(a1 + 32) = v10;
        *(_QWORD *)(a1 + 8) = v9;
        v8 = *(unsigned __int8 *)(v9++ - 1) | (v8 << 8);
        --v10;
        --v3;
      }
      while (v3);
    }
    result = 0;
    *a2 = v8;
  }
  else
  {
    result = 7;
    if (*(_BYTE *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t aj_istream_move_forward(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  uint64_t result;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;

  if (!*(_QWORD *)(a1 + 80))
    return 0;
  v2 = *(_QWORD *)(a1 + 104);
  v3 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v4 = *(const void **)(a1 + 104);
  }
  else
  {
    v4 = *(const void **)(a1 + 16);
    if (!v3)
      v4 = *(const void **)(a1 + 8);
  }
  v6 = *(void **)(a1 + 40);
  v7 = *(int *)(a1 + 32);
  v8 = *(_QWORD *)(a1 + 8);
  v9 = v7 + (int)v8 - (int)v4;
  *(_QWORD *)(a1 + 8) = v8 - ((int)v4 - (int)v6);
  if (v3)
    *(_QWORD *)(a1 + 16) = v3 - ((int)v4 - (int)v6);
  if (v2)
    *(_QWORD *)(a1 + 104) = v2 - ((int)v4 - (int)v6);
  memmove(v6, v4, v7 + (int)v8 - (int)v4);
  if (*(_DWORD *)(a1 + 56) == 2)
  {
    v10 = 0;
LABEL_29:
    result = 0;
    *(_DWORD *)(a1 + 32) += v10;
    return result;
  }
  v10 = 0;
  v11 = *(_QWORD *)(a1 + 40) + v9;
  v12 = *(_DWORD *)(a1 + 36);
  while (1)
  {
    v13 = *(_DWORD *)(a1 + 52);
    if (v13)
    {
      v14 = *(_DWORD *)(a1 + 48);
      if (v14 >= v13)
      {
        *(_DWORD *)(a1 + 56) = 2;
        if ((v14 & 0x80000000) == 0)
          goto LABEL_29;
        goto LABEL_26;
      }
    }
    if (*(_DWORD *)(a1 + 56) == 1)
      *(_DWORD *)(a1 + 56) = 0;
    v15 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 80))(v11 + v10, (v12 - (v9 + v10)), *(_QWORD *)(a1 + 64));
    if (v15 <= 0)
      break;
    v16 = *(_DWORD *)(a1 + 48) + v15;
    *(_DWORD *)(a1 + 48) = v16;
    v10 += v15;
    if (v10 >= 8)
    {
      if ((v16 & 0x80000000) == 0)
        goto LABEL_29;
LABEL_26:
      aj_log_error((uint64_t)"Istream", "File is larger than %d bytes, aborting");
      return 9;
    }
  }
  if (!v15)
  {
    v17 = 1;
    goto LABEL_28;
  }
  if (v15 == -1)
  {
    v17 = 2;
LABEL_28:
    *(_DWORD *)(a1 + 56) = v17;
    goto LABEL_29;
  }
  aj_log_error((uint64_t)"Istream", "File read error");
  return 9;
}

uint64_t aj_check_components_and_decimation(int *a1)
{
  int v2;
  int v3;
  unsigned int *v4;
  uint64_t v5;
  int *v6;
  int v7;
  _BOOL4 v8;
  _BOOL8 v9;
  int v11;
  uint64_t result;
  char v13;
  uint64_t i;
  unsigned int *v15;
  uint64_t j;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  v2 = *a1;
  if (*a1 < 1)
  {
    LOBYTE(v9) = 0;
  }
  else
  {
    v3 = 0;
    v4 = (unsigned int *)(a1 + 8);
    v5 = *a1;
    v6 = a1 + 8;
    do
    {
      v7 = *v6++;
      v8 = v7 > 1 || (int)*(v4 - 4) > 1;
      v3 |= v8;
      v4 = (unsigned int *)v6;
      --v5;
    }
    while (v5);
    v9 = v3 != 0;
    if (v3 && v2 > 3)
    {
      aj_log_error((uint64_t)"Parse", "Images with 4 components and decimation not supported");
      return 3;
    }
  }
  if ((v2 - 5) <= 0xFFFFFFFB && a1[1] >= 9)
  {
    aj_log_error((uint64_t)"Parse", "Only 1-4 component 12-bit jpegs are supported");
    return 3;
  }
  if (a1[852])
  {
    v11 = a1[853];
    if (v11)
    {
      if (v11 >= 3)
      {
        aj_log_error((uint64_t)"Parse", "Unknown/unsupported APP14 transform");
        return 3;
      }
    }
    else
    {
      v13 = !v9;
      if (v2 == 1)
        v13 = 1;
      if ((v13 & 1) == 0)
      {
        aj_log_error((uint64_t)"Parse", "Unsupported decimation with APP14 transform");
        return 3;
      }
    }
  }
  if (*((_BYTE *)a1 + 86))
  {
    if (v2 >= 1)
    {
      for (i = 0; i < v2; ++i)
      {
        v15 = (unsigned int *)&a1[i];
        if (v15[12])
        {
          aj_log_error((uint64_t)"Parse", "Quantization table index %d for component %d is out of bounds for lossless JPEG, setting to 0", v15[12], i);
          v15[12] = 0;
          v2 = *a1;
        }
      }
    }
  }
  else if (v2 >= 1)
  {
    for (j = 0; j < v2; ++j)
    {
      v17 = a1[j + 12];
      if (v17 >= 4)
      {
        aj_log_error((uint64_t)"Parse", "Quantization table index for component %d is out of bounds: %d");
        return 4;
      }
      if (!a1[v17 + 278])
      {
        aj_log_error((uint64_t)"Parse", "Trying to use quantization table that is uninitialized");
        return 4;
      }
      if (a1[20] == 192 && a1[v17 + 282])
      {
        aj_log_error((uint64_t)"Parse", "16-bit quantization tables not allowed for Baseline DCT JPEG (SOF0). Attempting to decode anyway.");
        v2 = *a1;
      }
    }
  }
  v18 = a1[834];
  if ((int)v18 < 1)
  {
LABEL_55:
    if (v2 != 1 || a1[4] <= 1 && a1[8] < 2)
      return 0;
    result = 0;
    a1[8] = 1;
    a1[4] = 1;
    return result;
  }
  v19 = a1 + 835;
  while (1)
  {
    v21 = *v19++;
    v20 = v21;
    if (*((_BYTE *)a1 + 85)
      || (v22 = *((unsigned __int8 *)a1 + 84), *((_BYTE *)a1 + 84)) && !a1[847]
      || *((_BYTE *)a1 + 86))
    {
      v23 = a1[v20 + 839];
      if (v23 >= 4)
      {
        aj_log_error((uint64_t)"Parse", "Huffman DC index for component %d is out of bounds: %d");
        return 4;
      }
      if (!*((_BYTE *)a1 + 2 * v23 + 3320))
      {
        aj_log_error((uint64_t)"Parse", "Trying to use DC huffman table #%d that is uninitialized");
        return 4;
      }
      if (*((_BYTE *)a1 + 85))
        goto LABEL_52;
      v22 = *((unsigned __int8 *)a1 + 84);
    }
    if (!v22 || a1[847] < 1)
      goto LABEL_54;
LABEL_52:
    v24 = a1[v20 + 843];
    if (v24 >= 4)
    {
      aj_log_error((uint64_t)"Parse", "Huffman AC index for component %d is out of bounds: %d");
      return 4;
    }
    if (!*((_BYTE *)a1 + 2 * v24 + 3321))
      break;
LABEL_54:
    if (!--v18)
      goto LABEL_55;
  }
  aj_log_error((uint64_t)"Parse", "Trying to use AC huffman table #%d that is uninitialized");
  return 4;
}

uint64_t aj_read_sos(uint64_t a1, int *a2)
{
  uint64_t result;
  unsigned int v5;
  unint64_t v6;
  int v7;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int *v24;
  unsigned int v25;
  unsigned int pos;
  unsigned int v27;

  v27 = 0;
  result = aj_istream_read_bytes_be(a1, (int *)&v27, 2);
  if (!(_DWORD)result)
  {
    v5 = v27;
    result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
    if (!(_DWORD)result)
    {
      v6 = v27;
      a2[834] = v27;
      v7 = *a2;
      if ((int)v6 < 1 || (int)v6 > v7)
      {
        aj_log_error((uint64_t)"Read", "Component count is %d, only 1 to %d supported.");
        return 3;
      }
      if (v5 == 2 * (_DWORD)v6 + 6)
      {
        if (v7 == (_DWORD)v6)
        {
          if (!*((_BYTE *)a2 + 84))
            goto LABEL_19;
        }
        else
        {
          *((_BYTE *)a2 + 84) = 1;
        }
        if (*((_BYTE *)a2 + 86))
        {
          aj_log_error((uint64_t)"Read", "Lossless multiscan images are not supported");
          return 3;
        }
LABEL_19:
        v9 = 0;
        v10 = 1;
        while (1)
        {
          result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
          if ((_DWORD)result)
            return result;
          v11 = *a2;
          if ((int)v11 < 1)
            break;
          v12 = 0;
          while (a2[v12 + 16] != v27)
          {
            if (v11 == ++v12)
              goto LABEL_33;
          }
          a2[v9 + 835] = v12;
          result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
          if ((_DWORD)result)
            goto LABEL_31;
          v13 = v27;
          v14 = (unsigned int *)&a2[v12];
          v14[839] = v27 >> 4;
          v14[843] = v13 & 0xF;
          if (v13 > 0x3F || (v13 & 0xF) >= 4)
          {
            aj_log_error((uint64_t)"Read", "Corrupt scan, invalid huffman table indices. DC: %d, AC: %d");
            goto LABEL_34;
          }
          v10 = ++v9 < v6;
          if (v9 == v6)
          {
            result = 0;
LABEL_31:
            if (v10)
              return result;
            goto LABEL_35;
          }
        }
LABEL_33:
        aj_log_error((uint64_t)"Read", "Component ID %d not found among declared components");
LABEL_34:
        if (v10)
          return 4;
LABEL_35:
        if ((int)v6 >= 2)
        {
          v15 = 0;
          while (1)
          {
            v16 = v15 + 1;
            if (v15 + 1 < v6)
              break;
LABEL_41:
            ++v15;
            if (v16 == (_DWORD)v6 - 1)
              goto LABEL_42;
          }
          v17 = v15;
          while (a2[v15 + 835] != a2[v17 + 836])
          {
            if (v6 - 1 == ++v17)
              goto LABEL_41;
          }
          aj_log_error((uint64_t)"Read", "SOS components IDs are not unique. id[%d] == id[%d] == %d");
          return 4;
        }
LABEL_42:
        result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
        if (!(_DWORD)result)
        {
          a2[847] = v27;
          result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
          if (!(_DWORD)result)
          {
            a2[848] = v27;
            result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
            if (!(_DWORD)result)
            {
              v18 = v27;
              v19 = v27 >> 4;
              a2[850] = v19;
              v20 = v18 & 0xF;
              a2[849] = v20;
              v21 = a2[20];
              if (v21 == 194)
              {
                v22 = a2[847];
                v23 = a2[848];
                if (!v22 && v23 || v22 > v23 || v23 >= 64)
                {
                  aj_log_error((uint64_t)"Read", "Bad spectral selection. Ss = %d, Se = %d.");
                  return 4;
                }
                if (v20 > 0xD || v19 && v19 != v20 + 1)
                {
                  aj_log_error((uint64_t)"Read", "Bad successive approximation. Ah = %d, Al = %d.");
                  return 4;
                }
              }
              else
              {
                v24 = a2 + 847;
                if (*((_BYTE *)a2 + 84))
                {
                  v25 = a2[848];
                  if (a2[847] || v25 != 63)
                  {
                    aj_log_error((uint64_t)"Read", "Bad spectral selection for baseline multiscan image. Ss = %d, Se = %d. Assuming Ss = 0, Se = 63.", a2[847], v25);
                    *(_QWORD *)v24 = 0x3F00000000;
                    v20 = a2[849];
                    v19 = a2[850];
                  }
                  if (v20 | v19)
                    aj_log_error((uint64_t)"Read", "Bad successive approximation for baseline multiscan image. Al = %d, Ah = %d. Assuming Al = 0, Ah = 63.", v20, v19);
                }
                else if (v21 == 195 && *v24 >= 8)
                {
                  aj_log_error((uint64_t)"Read", "Bad lossless JPEG predictor %d.");
                  return 4;
                }
              }
              pos = aj_istream_get_pos(a1);
              result = 0;
              a2[855] = pos;
            }
          }
        }
        return result;
      }
      aj_log_error((uint64_t)"Read", "Illegal length of SOS segment.");
      return 4;
    }
  }
  return result;
}

uint64_t aj_read_sof(uint64_t a1, unsigned int *a2, int a3)
{
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  int *v11;
  char v12;
  unsigned int v13;

  if ((a3 - 196) <= 0xFFFFFFFB)
  {
    aj_log_error((uint64_t)"Read", "Unsupported SOFn type");
    return 3;
  }
  v13 = 0;
  a2[20] = a3;
  result = aj_istream_read_bytes_be(a1, (int *)&v13, 2);
  if (!(_DWORD)result)
  {
    v7 = v13;
    *((_BYTE *)a2 + 84) = a3 == 194;
    *((_BYTE *)a2 + 85) = (a3 & 0xFFFFFFFE) == 192;
    *((_BYTE *)a2 + 86) = a3 == 195;
    result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
    if (!(_DWORD)result)
    {
      v8 = v13;
      a2[1] = v13;
      if ((v8 | 4) != 0xC && (v8 - 2 > 0xE || !*((_BYTE *)a2 + 86)))
      {
        aj_log_error((uint64_t)"Read", "Precision is %d bits, only 8- and 12-bit input is supported.");
        return 3;
      }
      result = aj_istream_read_bytes_be(a1, (int *)&v13, 2);
      if (!(_DWORD)result)
      {
        a2[3] = v13;
        result = aj_istream_read_bytes_be(a1, (int *)&v13, 2);
        if (!(_DWORD)result)
        {
          a2[2] = v13;
          result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
          if (!(_DWORD)result)
          {
            v9 = v13;
            *a2 = v13;
            if ((int)a2[2] < 1 || (int)a2[3] <= 0)
            {
              aj_log_error((uint64_t)"Read", "Width or height is <= 0 : %dx%d");
              return 3;
            }
            if (v9 - 3 >= 2 && v9 != 1)
            {
              if (v9 != 2)
              {
                aj_log_error((uint64_t)"Read", "Component count is %d, only 1, 3 or 4 supported.");
                return 3;
              }
              if (a2[20] != 195)
              {
                aj_log_error((uint64_t)"Read", "Component count 2 only supported for lossless JPEG.");
                return 3;
              }
            }
            if (v7 == 3 * v9 + 8)
            {
              v10 = 0;
              v11 = (int *)(a2 + 8);
              do
              {
                result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
                if ((_DWORD)result)
                  break;
                v11[8] = v13;
                result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
                if ((_DWORD)result)
                  break;
                v12 = v13;
                *(v11 - 4) = v13 >> 4;
                *v11 = v12 & 0xF;
                result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
                if ((_DWORD)result)
                  break;
                v11[4] = v13;
                if (v10)
                {
                  if (*v11 != 1 || *(v11 - 4) != 1)
                  {
                    aj_log_error((uint64_t)"Read", "Unsupported subsampling. Y must be undecimated");
                    return 3;
                  }
                }
                else if ((*(v11 - 4) - 1) > 1 || (*v11 - 1) >= 2)
                {
                  aj_log_error((uint64_t)"Read", "Unsupported subsampling");
                  return 3;
                }
                result = 0;
                ++v10;
                ++v11;
              }
              while (v10 < (int)*a2);
            }
            else
            {
              aj_log_error((uint64_t)"Read", "Illegal length of SOF-segment.");
              return 4;
            }
          }
        }
      }
    }
  }
  return result;
}

double aj_istream_init_file(uint64_t a1, _QWORD *a2, uint64_t a3, int a4, char a5, int a6)
{
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = a4;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 24) = -9;
  v7 = a2[2];
  v8 = a2[3];
  *(_QWORD *)(a1 + 80) = *a2;
  *(_QWORD *)(a1 + 88) = v8;
  *(_QWORD *)(a1 + 64) = a2[4];
  *(_QWORD *)(a1 + 72) = v7;
  *(_DWORD *)(a1 + 56) = a6;
  v9 = a2[6];
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = v9;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 112) = a5;
  return result;
}

uint64_t aj_check_huffman_tables(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t result;

  v2 = 0;
LABEL_2:
  v3 = 0;
  v4 = 1;
  while (1)
  {
    v5 = v4;
    if (*(_BYTE *)(a1 + 2 * v2 + v3 + 3320))
    {
      result = aj_check_single_huffman_table((uint8x16_t *)(a1 + 32 * v2 + 16 * v3 + 1144), (char *)(a1 + (v2 << 9) + (v3 << 8) + 1272), v3, a1);
      if ((_DWORD)result)
        return result;
    }
    v4 = 0;
    v3 = 1;
    if ((v5 & 1) == 0)
    {
      if (++v2 != 4)
        goto LABEL_2;
      return 0;
    }
  }
}

uint64_t aj_check_single_huffman_table(uint8x16_t *a1, char *a2, int a3, uint64_t a4)
{
  int v4;
  uint16x8_t v5;
  uint16x8_t v6;
  uint64_t v7;
  unsigned int v8;
  char v9;
  int v10;
  int v11;
  int v12;

  v4 = *(_DWORD *)(a4 + 4);
  v5 = vmovl_high_u8(*a1);
  v6 = vmovl_u8(*(uint8x8_t *)a1->i8);
  v7 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v6.i8, *(uint16x4_t *)v5.i8), (int32x4_t)vaddl_high_u16(v6, v5)));
  if (!a3)
  {
    if (v4 == 8)
      v10 = 11;
    else
      v10 = 15;
    if (*(_BYTE *)(a4 + 86))
      v11 = v4 + 1;
    else
      v11 = v10;
    if ((_DWORD)v7)
    {
      while (1)
      {
        v12 = *a2++;
        if (v11 < v12)
          break;
        if (!--v7)
          return 0;
      }
      aj_log_error((uint64_t)"Parse", "Bogus huffman table. 0x%02X is not a legal symbol for %d-bit DC.");
      return 4;
    }
    return 0;
  }
  if (v4 == 8)
    v8 = 10;
  else
    v8 = 14;
  if (!(_DWORD)v7)
    return 0;
  while (1)
  {
    v9 = *a2++;
    if ((v9 & 0xFu) > v8)
      break;
    if (!--v7)
      return 0;
  }
  aj_log_error((uint64_t)"Parse", "Bogus huffman table. 0x%02X is not a legal symbol for %d-bit AC.");
  return 4;
}

uint64_t aj_read_jfif (uint64_t a1)
{
  uint64_t result;
  unsigned int v3;
  unsigned int v4;

  v4 = 0;
  result = aj_istream_read_bytes_be(a1, (int *)&v4, 2);
  if (!(_DWORD)result)
  {
    v3 = v4;
    if (v4 <= 0xF)
      aj_log_error((uint64_t)"Read", "Illegal JFIF header. Length of header is %u, must be >= 16.", v4);
    return aj_istream_skip_bytes(a1, v3 - 2);
  }
  return result;
}

uint64_t getw_big(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int v4;

  v4 = 0;
  result = aj_istream_read_bytes_be(a1, &v4, 4);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t aj_read_dri(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;

  v5 = 0;
  result = aj_istream_read_bytes_be(a1, &v5, 2);
  if (!(_DWORD)result)
  {
    if (v5 == 4)
    {
      result = aj_istream_read_bytes_be(a1, &v5, 2);
      if (!(_DWORD)result)
        *(_DWORD *)(a2 + 3404) = v5;
    }
    else
    {
      aj_log_error((uint64_t)"Read", "Illegal DRI segment length.");
      return 4;
    }
  }
  return result;
}

uint64_t aj_read_unknown_segment(uint64_t a1)
{
  uint64_t result;
  int v3;
  int pos;
  int v5;

  v5 = 0;
  result = aj_istream_read_bytes_be(a1, &v5, 2);
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a1 + 104) = 0;
    v3 = v5;
    if (v5 < 3)
      return 0;
    pos = aj_istream_get_pos(a1);
    result = aj_istream_move_to_position(a1, (v3 + pos - 2));
    if (!(_DWORD)result)
      return 0;
  }
  return result;
}

uint64_t aj_read_app14(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  v8 = 0;
  result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
  if (!(_DWORD)result)
  {
    v5 = HIDWORD(v8);
    v6 = v5 + aj_istream_get_pos(a1) - 2;
    if (v5 <= 13)
      goto LABEL_3;
    result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 4);
    if (!(_DWORD)result)
    {
      result = aj_istream_read_bytes_be(a1, (int *)&v8, 1);
      if (!(_DWORD)result)
      {
        if (v8 != 0x41646F6200000065)
        {
LABEL_3:
          aj_log_error((uint64_t)"Read", "Unknown APP14 marker");
          LODWORD(result) = aj_istream_move_to_position(a1, v6);
          if ((_DWORD)result)
            return result;
          else
            return 11;
        }
        result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
        if (!(_DWORD)result)
        {
          result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
          if (!(_DWORD)result)
          {
            result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
            if (!(_DWORD)result)
            {
              result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 1);
              if (!(_DWORD)result)
              {
                v7 = HIDWORD(v8);
                if (HIDWORD(v8) < 3)
                {
                  *(_DWORD *)(a2 + 3408) = 1;
                  *(_DWORD *)(a2 + 3412) = v7;
                  return aj_istream_move_to_position(a1, v6);
                }
                else
                {
                  aj_log_error((uint64_t)"Read", "Illegal APP14 transform");
                  return 11;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fill_coeff_buffer(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;

  if (*(_DWORD *)(a1 + 6580) == 14)
  {
    v6 = *(_DWORD *)(a2 + 24);
    v7 = *a3 - v6;
    if (*a3 > v6)
    {
      if (*(_BYTE *)(a1 + 17))
      {
        *(_DWORD *)(a2 + 96) = 0;
        *(_QWORD *)(a2 + 88) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 88) = v7 * *(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 172);
        *(_DWORD *)(a2 + 92) = v7 * *(_DWORD *)(a1 + 104) * (*(_DWORD *)(a1 + 172) / *(_DWORD *)(a1 + 48));
        *(_DWORD *)(a2 + 96) = v7 * *(_DWORD *)(a1 + 112) * (*(_DWORD *)(a1 + 172) / *(_DWORD *)(a1 + 48));
      }
    }
    goto LABEL_12;
  }
  if (*(_BYTE *)(a2 + 560))
    goto LABEL_12;
  if (*(int *)(a1 + 6464) >= 1)
  {
    v8 = 0;
    do
      *(_DWORD *)(a2 + 88 + 4 * v8++) = 0;
    while (v8 < *(int *)(a1 + 6464));
  }
  result = aj_get_rowptrs(a1, a2, (_QWORD *)(a2 + 568));
  if (!(_DWORD)result)
  {
LABEL_12:
    v10 = *(unsigned int *)(a2 + 84);
    v11 = *(_DWORD *)(a2 + 1088);
    if (v11)
    {
      if (v11 == 1)
      {
        result = do_error_recovery(a1, a2, *(_DWORD *)(a2 + 84), *(unsigned int *)(a2 + 1084));
        if ((_DWORD)result)
          return result;
      }
      if (*a3 != *(_DWORD *)(a2 + 1092))
      {
LABEL_32:
        fill_mcu_row_with_gray((int *)a1, a2, *(_DWORD *)(a1 + 6848));
        goto LABEL_33;
      }
      if (*(_DWORD *)(a2 + 1096) >= *(_DWORD *)(a1 + 6848))
        v12 = *(_DWORD *)(a1 + 6848);
      else
        v12 = *(_DWORD *)(a2 + 1096);
      fill_mcu_row_with_gray((int *)a1, a2, v12);
      *(_DWORD *)(a2 + 1088) = 0;
      v10 = *(unsigned int *)(a2 + 1096);
    }
    for (; (int)v10 < *(_DWORD *)(a1 + 6848); v10 = (v10 + 1))
    {
      *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 6844);
      v13 = move_to_mcu((int **)a1, a2, a2 + 112, *a3, v10);
      if (!(_DWORD)v13)
      {
        v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(a1 + 160))(a1, a2, a2 + 112, *a3, v10, a2 + 568, a2 + 88);
        if (!(_DWORD)v13)
          continue;
      }
      if ((_DWORD)v13 == -2)
      {
        *(_DWORD *)(a2 + 80) = *a3;
        *(_DWORD *)(a2 + 84) = v10;
        return 4294967294;
      }
      *(_DWORD *)(a2 + 1084) = v13;
      result = do_error_recovery(a1, a2, v10, v13);
      if ((_DWORD)result)
      {
        if ((_DWORD)result == -2)
        {
          *(_DWORD *)(a2 + 80) = *a3;
          *(_DWORD *)(a2 + 84) = v10;
        }
        return result;
      }
      if (*a3 != *(_DWORD *)(a2 + 1092))
        goto LABEL_32;
      if (*(_DWORD *)(a2 + 1096) >= *(_DWORD *)(a1 + 6848))
        v14 = *(_DWORD *)(a1 + 6848);
      else
        v14 = *(_DWORD *)(a2 + 1096);
      fill_mcu_row_with_gray((int *)a1, a2, v14);
      LODWORD(v10) = *(_DWORD *)(a2 + 1096) - 1;
      *(_DWORD *)(a2 + 1088) = 0;
    }
LABEL_33:
    result = 0;
    ++*a3;
  }
  return result;
}

uint64_t move_to_mcu(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  int v6;
  int v8;
  _BOOL4 v10;
  uint64_t v12;
  int *v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  BOOL v24;
  unsigned __int16 *v25;
  int v26;
  int *v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v36;
  int *v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  BOOL v43;
  int v44;
  int v45;
  void *v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  BOOL v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned __int8 *v56;
  int v57;
  BOOL v58;
  uint64_t v60;
  unsigned __int8 *v61;
  int v62;
  uint64_t v63;
  uint64_t next_marker;
  int v65;
  int v66;
  _QWORD *v67;
  uint64_t v68;
  int v69;
  char v70;
  int v71;
  uint64_t v72;

  v5 = *(_DWORD *)(a3 + 24);
  v6 = *(_DWORD *)(a3 + 28);
  if (v5 == (_DWORD)a4 && v6 == (_DWORD)a5)
    return 0;
  v8 = a5;
  v10 = v5 == a4;
  if (v6 <= (int)a5)
    v10 = 0;
  if (v5 > (int)a4 || v10)
  {
    aj_log_error((uint64_t)"Dec", "Trying to move backwards in the stream");
    return 3;
  }
  v16 = a1[20];
  v17 = v5 == (_DWORD)a4 && v6 == (_DWORD)a5;
  v18 = a5;
  v19 = a4;
  if (v17)
    goto LABEL_65;
  v20 = a4;
  v21 = a5;
  if (!*(_DWORD *)a2)
    goto LABEL_40;
  if (v5 < *(_DWORD *)(a2 + 8))
  {
    v20 = a4;
    v21 = a5;
    if (*(_DWORD *)(a2 + 12) <= (int)a4)
      goto LABEL_40;
  }
  v22 = *(_DWORD *)(a2 + 44);
  v21 = a5;
  v20 = a4;
  if (v5 <= v22)
  {
    v21 = a5;
    v20 = a4;
    if (v22 <= (int)a4)
    {
      v23 = *(_DWORD *)(a2 + 48);
      if (v22 < (int)a4)
      {
        if (v5 < v22)
        {
LABEL_30:
          if (v5 == v22)
          {
            v21 = *(_DWORD *)(a2 + 48);
            v20 = *(_DWORD *)(a2 + 44);
            if (v6 == v23)
              goto LABEL_64;
          }
          else
          {
            v21 = *(_DWORD *)(a2 + 48);
            v20 = *(_DWORD *)(a2 + 44);
          }
          goto LABEL_34;
        }
        v24 = 1;
      }
      else
      {
        v24 = v23 <= (int)a5;
        if (v5 < v22)
        {
          v21 = a5;
          v20 = a4;
          if (v23 > (int)a5)
            goto LABEL_34;
          goto LABEL_30;
        }
      }
      v21 = a5;
      v20 = a4;
      if (v6 > v23)
        goto LABEL_34;
      v21 = a5;
      v20 = a4;
      if (!v24)
        goto LABEL_34;
      goto LABEL_30;
    }
  }
LABEL_34:
  v25 = *(unsigned __int16 **)(a2 + 16);
  if (!v25)
    goto LABEL_40;
  v26 = *v25;
  if (v5 > v26 || v20 < v26)
    goto LABEL_40;
  v57 = v25[1];
  if (v20 <= v26)
  {
    v58 = v21 >= v57;
    if (v5 < v26)
    {
      if (v21 < v57)
        goto LABEL_40;
      goto LABEL_97;
    }
    goto LABEL_95;
  }
  if (v5 >= v26)
  {
    v58 = 1;
LABEL_95:
    if (v6 > v57 || !v58)
      goto LABEL_40;
  }
LABEL_97:
  v20 = v26;
  if (v5 == v26)
  {
    v21 = v57;
    if (v6 == v57)
      goto LABEL_64;
  }
  else
  {
    v21 = v57;
  }
LABEL_40:
  v28 = a1[1];
  v29 = v28[34];
  if ((v29 & 0xFFFFFFFE) == 2)
  {
    if (*((_QWORD *)v28 + 12))
    {
      v30 = *((_QWORD *)v28 + 13);
      if (v30)
      {
        if ((v29 != 2 || !*((_DWORD *)a1 + 1703)) && (v21 || v28[21] != v20))
        {
          v31 = v28[28];
          v32 = v20 / v31;
          v19 = (v20 / v31 * v31);
          if ((int)v19 >= v5)
          {
            v33 = v28[29];
            v34 = v21 / v33;
            v18 = (v21 / v33 * v33);
            if ((_DWORD)v19 != v5 || (int)v18 > v6)
            {
              v36 = *(_QWORD *)(v30 + 8 * v32);
              if (*(_BYTE *)(v36 + 20 * v34 + 17))
              {
                v71 = v21 / v33;
                v12 = aj_istream_state_restore(*(_QWORD *)a3, v36 + 20 * v34);
                if (!(_DWORD)v12)
                {
                  v37 = *a1;
                  if (**a1 >= 1)
                  {
                    v38 = 0;
                    do
                    {
                      *(_DWORD *)(a3 + 8 + 4 * v38) = *(__int16 *)(v36 + 20 * v71 + 8 + 2 * v38);
                      ++v38;
                    }
                    while (v38 < *v37);
                  }
                  v39 = v37[851];
                  if (v39)
                  {
                    v40 = v18 + a1[1][20] * v19;
                    v41 = v40 % v39;
                    v42 = v40 % (8 * v39) / v39;
                    v43 = __OFSUB__(v42, 1);
                    v44 = v42 - 1;
                    if (v44 < 0 != v43)
                      v44 = 7;
                    *(_DWORD *)(a3 + 32) = v41;
                    *(_DWORD *)(a3 + 36) = v44;
                  }
                  *(_DWORD *)(a3 + 24) = v19;
                  *(_DWORD *)(a3 + 28) = v18;
                  goto LABEL_65;
                }
                goto LABEL_127;
              }
            }
          }
        }
      }
    }
  }
  v45 = (*a1)[851];
  if (!v45
    || *((_BYTE *)*a1 + 84)
    || (v48 = v28[20], v49 = (v21 + v48 * v20) / v45, v50 = v49 - 1, v49 < 1)
    || (v51 = (v49 * v45 / v48), (int)v51 < v5))
  {
LABEL_64:
    v18 = *(unsigned int *)(a3 + 28);
    v19 = *(unsigned int *)(a3 + 24);
    goto LABEL_65;
  }
  v52 = (_DWORD)v51 == v5 && v49 * v45 % v48 <= v6;
  v18 = *(unsigned int *)(a3 + 28);
  v19 = *(unsigned int *)(a3 + 24);
  if (v52)
    goto LABEL_65;
  v53 = *(_QWORD *)a3;
  v54 = (v6 + v48 * v5) / v45;
  v55 = v54 - 1;
  v56 = *(unsigned __int8 **)(*(_QWORD *)a3 + 16);
  if (v56 && *(_DWORD *)(a3 + 32) == v45)
  {
    if ((v55 & 7 | 0xD0) == *v56)
    {
      v55 = v54 - 2;
      goto LABEL_107;
    }
    aj_log_error((uint64_t)"Dec", "Current restart marker does not have expected value (0x%02X != 0x%02X)");
LABEL_126:
    v12 = 7;
LABEL_127:
    aj_log_error((uint64_t)"Dec", "Jump to MCU failed with error: %d", v12);
    return v12;
  }
  if (*(_DWORD *)(a3 + 36) != (v55 & 7))
  {
    aj_log_error((uint64_t)"Dec", "Previous restart marker does not have expected value (0x%02X != 0x%02X)");
    goto LABEL_126;
  }
LABEL_107:
  if (v55 == v50)
  {
    aj_log_error((uint64_t)"Dec", "Already at requested restart marker");
    v19 = *(unsigned int *)(a3 + 24);
    v18 = *(unsigned int *)(a3 + 28);
    goto LABEL_65;
  }
  v18 = (v49 * v45 % v48);
  if (v55 >= v50)
  {
LABEL_121:
    if (v55 == v50 && *(_QWORD *)(v53 + 16))
      goto LABEL_123;
    aj_log_error((uint64_t)"Dec", "Unable to go to the correct RST position");
    goto LABEL_126;
  }
  v60 = 0;
  v67 = (_QWORD *)(a3 + 8);
  v68 = *(_QWORD *)a3;
  v72 = (v49 * v45 / v48);
  v70 = v49;
  v69 = v49 - 1;
  while (1)
  {
    v61 = *(unsigned __int8 **)(v53 + 16);
    if (v61)
      break;
    v63 = v60;
    next_marker = find_next_marker((uint64_t *)a3);
    v60 = v63;
    v12 = next_marker;
    if ((_DWORD)next_marker == -2 && (_DWORD)v60)
    {
      *v67 = 0;
      v67[1] = 0;
      v65 = v45 + v45 * v55;
      *(_DWORD *)(a3 + 32) = 0;
      *(_DWORD *)(a3 + 36) = v55 & 7;
      v66 = a1[1][20];
      *(_DWORD *)(a3 + 24) = v65 / v66;
      *(_DWORD *)(a3 + 28) = v65 % v66;
      v12 = 4294967294;
      goto LABEL_127;
    }
    v51 = v72;
    LOBYTE(v49) = v70;
    v50 = v69;
    v53 = v68;
    if ((_DWORD)next_marker)
      goto LABEL_127;
LABEL_120:
    if (v55 >= v50)
      goto LABEL_121;
  }
  *(_DWORD *)v53 = 0;
  *(_DWORD *)(v53 + 24) = -9;
  ++v55;
  v62 = *v61;
  if ((v55 & 7 | 0xD0) == v62)
  {
    if (v55 == v50)
      goto LABEL_123;
    *(_QWORD *)(v53 + 16) = 0;
    v60 = 1;
    goto LABEL_120;
  }
  if (v62 != 217)
  {
    aj_log_error((uint64_t)"Dec", "Incorrect restart marker found (0x%02X != 0x%02X). Skipping jump.");
    goto LABEL_126;
  }
  if (v55 != v50 || (_DWORD)v18 || a1[1][21] != (_DWORD)v51)
  {
    aj_log_error((uint64_t)"Dec", "Encountered EOI while trying to jump to [%d,%d]. Skipping jump.");
    goto LABEL_126;
  }
LABEL_123:
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 32) = v45;
  *(_DWORD *)(a3 + 36) = ((_BYTE)v49 + 6) & 7;
  *(_DWORD *)(a3 + 24) = v51;
  *(_DWORD *)(a3 + 28) = v18;
  v19 = v51;
LABEL_65:
  if ((_DWORD)v19 == (_DWORD)a4 && (_DWORD)v18 == v8)
    return 0;
  if (v16 == (int *)aj_mcu_decode_progressive)
    v46 = aj_mcu_decode_progressive;
  else
    v46 = aj_mcu_decode_index;
  if ((int)v19 >= (int)a4)
  {
LABEL_100:
    if ((int)v18 < v8)
    {
      while (1)
      {
        v12 = ((uint64_t (*)(int **, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))v46)(a1, a2, a3, v19, v18, 0, 0);
        if ((_DWORD)v12)
          break;
        v18 = (v18 + 1);
        if (v8 == (_DWORD)v18)
          return v12;
      }
      goto LABEL_77;
    }
    return 0;
  }
  while (1)
  {
    while ((int)v18 >= a1[1][20])
    {
      v18 = 0;
      v19 = (v19 + 1);
      if ((_DWORD)v19 == (_DWORD)a4)
      {
        v19 = a4;
        goto LABEL_100;
      }
    }
    v47 = ((uint64_t (*)(int **, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))v46)(a1, a2, a3, v19, v18, 0, 0);
    if ((_DWORD)v47)
      break;
    v18 = (v18 + 1);
  }
  v12 = v47;
LABEL_77:
  if ((_DWORD)v12 == -2)
  {
    *(_DWORD *)(a2 + 80) = v19;
    *(_DWORD *)(a2 + 84) = v18;
    return 4294967294;
  }
  return v12;
}

uint64_t aj_mcu_decode(int **a1, uint64_t a2, uint64_t *a3, int a4, int a5, uint64_t a6, unsigned int *a7)
{
  int *v14;
  __int128 v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  unint64_t v19;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t *v27;
  unsigned int v28;
  int v29;
  int *v30;
  int v31;
  uint64_t result;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int *v45;
  int v46;
  int v47;
  int *v48;
  void (**v49)(_OWORD *, uint64_t, _QWORD);
  _DWORD *v50;
  _DWORD *v51;
  int v52;
  int j;
  uint64_t v54;
  _DWORD *v55;
  int **v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t v60;
  unsigned __int16 *v61;
  uint64_t i;
  unint64_t v63;
  unint64_t v64;
  int v65;
  uint64_t *v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int *v72;
  uint64_t v73;
  int **v74;
  char *v75;
  uint64_t v76;
  _DWORD *v77;
  uint64_t v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  int32x2_t v88;
  unsigned int v89;
  int **v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  int *v96;
  int *v97;
  _DWORD *v98;
  uint64_t *v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  _OWORD v111[16];
  uint64_t v112;

  v112 = *MEMORY[0x24BDAC8D0];
  v14 = a1[1];
  v110 = 0;
  v108 = 0u;
  v109 = 0u;
  v106 = 0u;
  v107 = 0u;
  v104 = 0u;
  v105 = 0u;
  v103 = 0u;
  v102 = 0;
  v100 = 0u;
  v101 = 0u;
  if (v14[91])
  {
    v15 = *((_OWORD *)a3 + 1);
    v16 = a3[4];
    *((_QWORD *)&v100 + 1) = a3[1];
    v101 = v15;
    v17 = &v103;
    v102 = v16;
    *(_QWORD *)&v100 = &v103;
    v18 = (__int128 *)*a3;
    v19 = *(_QWORD *)(*a3 + 16);
    if (v19 >= *(_QWORD *)(*a3 + 8) || v19 == 0)
      v19 = *(_QWORD *)(*a3 + 8);
    *((_QWORD *)v18 + 13) = v19;
    v22 = v18[2];
    v21 = v18[3];
    v23 = v18[1];
    v103 = *v18;
    v104 = v23;
    v105 = v22;
    v106 = v21;
    v24 = v18[4];
    v25 = *((_QWORD *)v18 + 14);
    v26 = v18[6];
    v108 = v18[5];
    v109 = v26;
    v110 = v25;
    v107 = v24;
    v27 = (uint64_t *)&v100;
  }
  else
  {
    v17 = (__int128 *)*a3;
    v27 = a3;
  }
  v97 = (int *)(a1 + 24);
  v28 = aj_find_and_handle_markers(a1, v27, 0);
  if (v28)
    goto LABEL_11;
  v99 = v27;
  if (!*(_DWORD *)a2)
  {
LABEL_56:
    if (*((_BYTE *)a1 + 18))
    {
      v30 = v97;
      v66 = v99 + 1;
      v28 = ((uint64_t (*)(int *, __int128 *, uint64_t *, uint64_t, _QWORD))a1[90])(v97, v17, v99 + 1, a6, *a7);
      if (v28)
      {
        v29 = 1;
        goto LABEL_13;
      }
      v28 = ((uint64_t (*)(int *, __int128 *, uint64_t *, uint64_t, _QWORD))a1[90])(v97, v17, v66, a6, *((_DWORD *)a1 + 227) + *a7);
      if (v28)
      {
        v29 = 2;
        goto LABEL_13;
      }
      v28 = ((uint64_t (*)(int *, __int128 *, uint64_t *, uint64_t, _QWORD))a1[90])(v97, v17, v66, a6 + 8 * *((int *)a1 + 182), *a7);
      if (v28)
      {
        v29 = 3;
        goto LABEL_13;
      }
      v28 = ((uint64_t (*)(int *, __int128 *, uint64_t *, uint64_t, _QWORD))a1[90])(v97, v17, v66, a6 + 8 * *((int *)a1 + 182), *((_DWORD *)a1 + 227) + *a7);
      if (v28)
      {
        v29 = 4;
        goto LABEL_13;
      }
      v28 = ((uint64_t (*)(int **, __int128 *, uint64_t, uint64_t, _QWORD))a1[286])(a1 + 220, v17, (uint64_t)v99 + 12, a6 + 128, a7[1]);
      if (v28)
      {
        v29 = 5;
        goto LABEL_13;
      }
      v28 = ((uint64_t (*)(int **, __int128 *, uint64_t *, uint64_t, _QWORD))a1[482])(a1 + 416, v17, v99 + 2, a6 + 256, a7[2]);
      if (v28)
      {
        v29 = 6;
        goto LABEL_13;
      }
      v89 = a7[1];
      *a7 += 2 * *((_DWORD *)a1 + 227);
      a7[1] = v89 + *((_DWORD *)a1 + 619);
      a7[2] += *((_DWORD *)a1 + 1011);
    }
    else
    {
      v67 = *((_DWORD *)a1 + 49);
      v30 = v97;
      if (v67 >= 1)
      {
        v68 = 0;
        v69 = 0;
        v70 = *((_DWORD *)a1 + 48);
        v96 = v14;
        while (v70 < 1)
        {
LABEL_66:
          if (++v68 >= v67)
            goto LABEL_72;
        }
        v71 = 0;
        while (1)
        {
          v28 = ((uint64_t (*)(int *, __int128 *, uint64_t *, uint64_t, _QWORD))a1[90])(v97, v17, v99 + 1, a6 + 8 * *((_DWORD *)a1 + 182) * v68, *a7 + *((_DWORD *)a1 + 227) * v71);
          if (v28)
            break;
          ++v71;
          v70 = *v97;
          if (v71 >= *v97)
          {
            v67 = *((_DWORD *)a1 + 49);
            v69 += v71;
            v14 = v96;
            goto LABEL_66;
          }
        }
        v29 = v69 + v71 + 1;
        v14 = v96;
        goto LABEL_13;
      }
      v69 = 0;
LABEL_72:
      v72 = *a1;
      if (**a1 > 1)
      {
        v94 = v69;
        v73 = a6 + 128;
        v74 = a1 + 220;
        v75 = (char *)v99 + 12;
        v76 = 1;
        while (1)
        {
          v28 = ((uint64_t (*)(int **, __int128 *, char *, uint64_t, _QWORD))v74[66])(v74, v17, v75, v73, a7[v76]);
          if (v28)
            break;
          ++v76;
          v72 = *a1;
          v73 += 128;
          v74 += 196;
          v75 += 4;
          if (v76 >= **a1)
            goto LABEL_76;
        }
        v29 = v94 + v76;
        goto LABEL_12;
      }
LABEL_76:
      *a7 += *((_DWORD *)a1 + 48) * *((_DWORD *)a1 + 227);
      if (*v72 >= 2)
      {
        v77 = (_DWORD *)a1 + 619;
        v78 = 1;
        do
        {
          a7[v78++] += *v77;
          v77 += 392;
        }
        while (v78 < *v72);
      }
    }
    if (v14[91])
    {
      v79 = *a3;
      v80 = v101;
      *(_OWORD *)a3 = v100;
      *((_OWORD *)a3 + 1) = v80;
      a3[4] = v102;
      *a3 = v79;
      v81 = v100;
      v83 = *(_OWORD *)v100;
      v82 = *(_OWORD *)(v100 + 16);
      v84 = *(_OWORD *)(v100 + 48);
      *(_OWORD *)(v79 + 32) = *(_OWORD *)(v100 + 32);
      *(_OWORD *)(v79 + 48) = v84;
      *(_OWORD *)v79 = v83;
      v86 = *(_OWORD *)(v81 + 80);
      v85 = *(_OWORD *)(v81 + 96);
      v87 = *(_OWORD *)(v81 + 64);
      *(_QWORD *)(v79 + 112) = *(_QWORD *)(v81 + 112);
      *(_OWORD *)(v79 + 80) = v86;
      *(_OWORD *)(v79 + 96) = v85;
      *(_OWORD *)(v79 + 64) = v87;
      *(_OWORD *)(v79 + 16) = v82;
      *(_QWORD *)(*a3 + 104) = 0;
    }
    v88 = vadd_s32(*(int32x2_t *)((char *)a3 + 28), (int32x2_t)0x100000001);
    *(uint64_t *)((char *)a3 + 28) = (uint64_t)v88;
    result = 0;
    if (v88.i32[0] >= v14[20])
      a3[3] = (*((_DWORD *)a3 + 6) + 1);
    return result;
  }
  if (*(_DWORD *)(a2 + 48) == a5 && *(_DWORD *)(a2 + 44) == a4)
  {
    v57 = *(int *)(a2 + 52);
    v58 = *(_DWORD *)(a2 + 56);
    v93 = *(_QWORD *)(*((_QWORD *)v14 + 13) + 8 * v57);
    *(_DWORD *)(a2 + 56) = v58 + 1;
    v59 = v14[29] + a5;
    *(_DWORD *)(a2 + 48) = v59;
    if (v59 >= v14[20])
    {
      *(_DWORD *)(a2 + 48) = 0;
      *(_DWORD *)(a2 + 52) = v57 + 1;
      *(_DWORD *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 44) = v14[28] + a4;
    }
    v28 = aj_istream_state_save((uint64_t)v17, v93 + 20 * v58);
    if (v28)
      goto LABEL_11;
    if (**a1 >= 1)
    {
      v60 = 0;
      do
      {
        *(_WORD *)(v93 + 20 * v58 + 8 + 2 * v60) = *((_DWORD *)v99 + v60 + 2);
        ++v60;
      }
      while (v60 < **a1);
    }
  }
  v61 = *(unsigned __int16 **)(a2 + 16);
  if (!v61 || *v61 != a4 || v61[1] != a5)
    goto LABEL_56;
  v28 = aj_istream_state_save((uint64_t)v17, (uint64_t)(v61 + 2));
  if (!v28)
  {
    for (i = 0; i != 4; ++i)
    {
      if (i >= *((int *)v17 + 8))
        break;
      *((_BYTE *)v61 + i + 12) = *(_BYTE *)(*((_QWORD *)v17 + 1) + i);
    }
    *((_BYTE *)v61 + 16) = i;
    v63 = *(_QWORD *)(a2 + 16);
    if (v63 >= (unint64_t)(a1[1] + 83))
    {
      v64 = 0;
    }
    else
    {
      v65 = *(unsigned __int16 *)(v63 + 24);
      v64 = v63 + 24;
      if (*(_DWORD *)(a2 + 12) <= v65)
        v64 = 0;
    }
    *(_QWORD *)(a2 + 16) = v64;
    goto LABEL_56;
  }
LABEL_11:
  v29 = 0;
LABEL_12:
  v30 = v97;
LABEL_13:
  v31 = v14[91];
  if (v28 == -2)
  {
    if (v31)
    {
      restore_mcustate(a3, (uint64_t)&v100);
      return 4294967294;
    }
  }
  else if (v31)
  {
    v33 = *a3;
    v34 = v101;
    *(_OWORD *)a3 = v100;
    *((_OWORD *)a3 + 1) = v34;
    a3[4] = v102;
    *a3 = v33;
    v35 = v100;
    v37 = *(_OWORD *)v100;
    v36 = *(_OWORD *)(v100 + 16);
    v38 = *(_OWORD *)(v100 + 48);
    *(_OWORD *)(v33 + 32) = *(_OWORD *)(v100 + 32);
    *(_OWORD *)(v33 + 48) = v38;
    *(_OWORD *)v33 = v37;
    v40 = *(_OWORD *)(v35 + 80);
    v39 = *(_OWORD *)(v35 + 96);
    v41 = *(_OWORD *)(v35 + 64);
    *(_QWORD *)(v33 + 112) = *(_QWORD *)(v35 + 112);
    *(_OWORD *)(v33 + 80) = v40;
    *(_OWORD *)(v33 + 96) = v39;
    *(_OWORD *)(v33 + 64) = v41;
    *(_OWORD *)(v33 + 16) = v36;
    *(_QWORD *)(*a3 + 104) = 0;
  }
  v91 = v28;
  v42 = *((unsigned int *)a1 + 1616);
  memset(v111, 0, sizeof(v111));
  if (v29 && (int)v42 >= 1)
  {
    v92 = a6;
    v95 = v42;
    v90 = a1;
    v98 = a7;
    v43 = 0;
    v44 = 0;
    do
    {
      v45 = &v30[392 * v43];
      v46 = v45[1];
      if (v46 >= 1)
      {
        v47 = 0;
        v48 = &v30[392 * v43];
        v49 = (void (**)(_OWORD *, uint64_t, _QWORD))(v48 + 130);
        v50 = v48 + 134;
        v51 = v48 + 179;
        v52 = *v45;
        do
        {
          if (v52 >= 1)
          {
            for (j = 0; j < v52; ++j)
            {
              if (v44 + j >= v29)
              {
                (*v49)(v111, v92 + (v43 << 7) + 8 * *v50 * v47, (v98[v43] + *v51 * j));
                v52 = *v45;
              }
            }
            v46 = v45[1];
            v44 += j;
          }
          ++v47;
        }
        while (v47 < v46);
      }
      ++v43;
      v54 = v95;
      v30 = v97;
    }
    while (v43 != v95);
    v55 = v98;
    v56 = v90;
    do
    {
      *v55++ += *((_DWORD *)v56 + 48) * *((_DWORD *)v56 + 227);
      v56 += 196;
      --v54;
    }
    while (v54);
  }
  return v91;
}

uint64_t aj_block_decode(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v17;
  int v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v18 = 0;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v10 = aj_huffman_decode_val(*(_QWORD *)(a1 + 32), a2, 0, &v18);
  if ((_DWORD)v10)
  {
    v13 = v10;
    LOWORD(v14) = 0;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
  }
  else
  {
    v17 = 0;
    v18 = SHIWORD(v18);
    v15 = *a3 + v18;
    v14 = (v15 * *(_DWORD *)(a1 + 48) + 2048) >> 12;
    *a3 = v15;
    v13 = aj_huffman_decode_ac_s1(a1, a2, &v19, &v17, v11, v12);
  }
  LOWORD(v19) = v14;
  (*(void (**)(__int128 *, uint64_t *, uint64_t))(a1 + 520))(&v19, a4, a5);
  if (*(_BYTE *)(a1 + 1040))
    aj_mosquito_spray(a1, (uint64_t)&v19, a4, a5);
  return v13;
}

uint64_t aj_huffman_decode_val(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  BOOL v9;
  unsigned int v10;
  int v11;
  uint64_t result;
  int v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int *v32;
  int *v33;
  unsigned int *v34;
  int v35;

  v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(a2 + 24);
  if (*(_DWORD *)(a2 + 28))
    goto LABEL_32;
  v6 = *(_DWORD *)(a1 + 4 * ((*(_DWORD *)a2 >> 23) + 100));
  if ((v6 & 0x30000) == 0)
  {
    v7 = v6 >> 18;
    v8 = a3 + v6;
    if ((_BYTE)v6)
      v9 = 0;
    else
      v9 = v7 == 0;
    if (v9)
      v8 = 63;
    v10 = v4 << SBYTE1(v6);
    v11 = v5 - BYTE1(v6);
    if (v11 >= 0)
      goto LABEL_9;
    goto LABEL_11;
  }
  if ((v6 & 0x10000) != 0)
  {
LABEL_32:
    *(_DWORD *)(a2 + 24) = v5;
    return aj_huffman_decode_val_slow(a1, (unsigned int *)a2, a3, 0, a4);
  }
  v25 = BYTE1(v6);
  v26 = v6 >> 18;
  v11 = v5 - v25;
  v10 = v4 << v25;
  v8 = a3 + (v26 >> 4);
  v27 = v26 & 0xF;
  if (v27)
  {
    if (v11 + 9 < v27)
    {
      *(_DWORD *)(a2 + 24) = v11;
      *(_DWORD *)a2 = v10;
      v34 = (unsigned int *)a2;
      v31 = v8;
      v32 = a4;
      v30 = v27;
      result = aj_istream_fill_buf(a2, v27 - 9);
      v27 = v30;
      if ((_DWORD)result)
        return result;
      v8 = v31;
      a4 = v32;
      a2 = (uint64_t)v34;
      v11 = v34[6];
      v10 = *v34;
    }
    v11 -= v27;
    v28 = v10 >> (32 - v27);
    v10 <<= v27;
    v29 = 1 << (v27 - 1);
    if (v28 < v29)
      v7 = v28 + 1 - 2 * v29;
    else
      v7 = v28;
  }
  else
  {
    v7 = 0;
  }
  if (v11 >= 0)
  {
    *(_DWORD *)a2 = v10;
    *(_DWORD *)(a2 + 24) = v11;
    *a4 = v8 + (v7 << 16);
    return 0;
  }
  if (*(_DWORD *)(a2 + 28))
  {
LABEL_9:
    *(_DWORD *)a2 = v10;
    *(_DWORD *)(a2 + 24) = v11;
    *a4 = v8 + (v7 << 16);
    return 0;
  }
LABEL_11:
  v13 = *(_DWORD *)(a2 + 32);
  v14 = *(unsigned __int8 **)(a2 + 8);
  if (v13 < 8)
    goto LABEL_33;
  v15 = *v14;
  v16 = v14[1];
  v9 = v15 == 255;
  v17 = v16 + (v15 << 8);
  v18 = v9 || v16 == 255;
  v19 = v14[2];
  v20 = v14 + 3;
  v21 = v13 - 3;
  v22 = v19 + (v17 << 8);
  if (v18 || v19 == 255)
  {
LABEL_33:
    *(_DWORD *)a2 = v10;
    *(_DWORD *)(a2 + 24) = v11;
    v33 = a4;
    v35 = v8 + (v7 << 16);
    result = aj_istream_fill_buf(a2, -9);
    if (!(_DWORD)result)
    {
      result = 0;
      *v33 = v35;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 32) = v21;
    v24 = -v11 - 1;
    *(_QWORD *)(a2 + 8) = v20;
    *(_DWORD *)a2 = v10 | (v22 << v24);
    *(_DWORD *)(a2 + 24) = 23 - v24;
    *a4 = v8 + (v7 << 16);
    return 0;
  }
  return result;
}

uint64_t aj_huffman_decode_ac_s1(uint64_t a1, uint64_t a2, _QWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t result;
  unsigned __int8 *v19;
  int v20;
  int v21;
  int v22;
  BOOL v23;
  int v24;
  unsigned __int8 *v25;
  int v27;
  int v28;
  unsigned int v29;
  signed int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _DWORD *v40;
  uint64_t v41;
  unsigned int *v42;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = 0;
  a3[6] = 0;
  a3[7] = 0;
  a3[8] = 0;
  a3[9] = 0;
  a3[10] = 0;
  a3[11] = 0;
  a3[12] = 0;
  a3[13] = 0;
  a3[14] = 0;
  a3[15] = 0;
  LODWORD(v6) = 1;
  v7 = a1 + 48;
  v8 = *(_QWORD *)(a1 + 696);
  v9 = *(_DWORD *)a2;
  v10 = *(_DWORD *)(a2 + 28);
  v11 = *(_QWORD *)(a1 + 40) + 400;
  v12 = *(_DWORD *)(a2 + 24);
  v13 = *(_DWORD *)a2 >> 23;
  v14 = *(unsigned int *)(v11 + 4 * v13);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (v10)
          {
LABEL_42:
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            v41 = v11;
            v42 = (unsigned int *)a2;
            v39 = a3;
            v40 = a4;
            v37 = a6;
            v38 = v7;
            v35 = v13;
            v36 = v8;
            result = aj_huffman_decode_val_slow(v11 - 400, (unsigned int *)a2, v6, 0, (int *)&v33);
            if ((_DWORD)result)
              return result;
            LODWORD(v6) = v33;
            v32 = (int)v33 >> 16;
            v13 = v35;
            v8 = v36;
            v7 = v38;
            a3 = v39;
            a4 = v40;
            v11 = v41;
            a2 = (uint64_t)v42;
            v10 = v42[7];
            v12 = v42[6];
            v9 = *v42;
            goto LABEL_34;
          }
          v15 = (int)v14 >> 18;
          v16 = v6 + v14;
          if ((v14 & 0x20000) != 0)
            break;
          if (v15)
          {
            v17 = *(_DWORD *)(v7 + 4 * v16) * v15 + 2048;
            a6 = *(unsigned int *)(v8 + 4 * v16);
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            v13 = v9 >> 23;
            v6 = v16 + 1;
            v14 = *(unsigned int *)(v11 + 4 * v13);
            *(_WORD *)((char *)a3 + a6) = v17 >> 12;
            if (v12 < 0)
              goto LABEL_17;
LABEL_6:
            if ((int)v6 >= 64)
            {
              if ((int)v6 <= 64)
              {
                *(_DWORD *)a2 = v9;
                *(_DWORD *)(a2 + 24) = v12;
                *a4 = v6;
                return 0;
              }
              goto LABEL_48;
            }
          }
          else
          {
            if ((_BYTE)v14)
              v6 = v16 + 1;
            else
              v6 = 64;
            a6 = v14 >> 8;
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            if (v12 < 0)
              goto LABEL_17;
            v13 = v9 >> 23;
            v14 = *(unsigned int *)(v11 + 4 * v13);
            if ((int)v6 >= 64)
            {
              if ((int)v6 <= 64)
              {
                *(_DWORD *)a2 = v9;
                *(_DWORD *)(a2 + 24) = v12;
                *a4 = v6;
                return 0;
              }
              goto LABEL_48;
            }
          }
        }
        LODWORD(v6) = v16 - v14;
        a6 = v14 & 0x10000;
        if ((v14 & 0x10000) != 0)
          goto LABEL_42;
        v28 = BYTE1(v14);
        v29 = v14 >> 18;
        v12 -= v28;
        v9 <<= v28;
        v6 = v6 + (v29 >> 4);
        v14 = v29 & 0xF;
        if (!(_DWORD)v14)
          goto LABEL_35;
        if (v12 + 9 < (int)v14)
        {
          *(_DWORD *)(a2 + 24) = v12;
          *(_DWORD *)a2 = v9;
          v41 = v11;
          v42 = (unsigned int *)a2;
          v39 = a3;
          v40 = a4;
          v37 = (v12 + 9);
          v38 = v7;
          v35 = v6;
          v36 = v13;
          v33 = v8;
          v34 = v14;
          result = aj_istream_fill_buf(a2, (int)v14 - 9);
          if ((_DWORD)result)
            return result;
          v8 = v33;
          LODWORD(v14) = v34;
          LODWORD(v6) = v35;
          v13 = v36;
          v7 = v38;
          a3 = v39;
          a4 = v40;
          v11 = v41;
          a2 = (uint64_t)v42;
          v10 = v42[7];
          v12 = v42[6];
          v9 = *v42;
        }
        v12 -= v14;
        v30 = v9 >> (32 - v14);
        v9 <<= v14;
        v31 = 1 << (v14 - 1);
        v32 = v30 < v31 ? v30 + 1 - 2 * v31 : v30;
LABEL_34:
        v14 = *(unsigned int *)(v7 + 4 * v6);
        a6 = *(unsigned int *)(v8 + 4 * v6);
        v6 = (v6 + 1);
        *(_WORD *)((char *)a3 + a6) = ((int)v14 * v32 + 2048) >> 12;
LABEL_35:
        if (v12 < 0)
          break;
        v13 = v9 >> 23;
        v14 = *(unsigned int *)(v11 + 4 * v13);
        if ((int)v6 >= 64)
        {
          if ((int)v6 <= 64)
          {
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            *a4 = v6;
            return 0;
          }
          goto LABEL_48;
        }
      }
      if (v10)
        goto LABEL_6;
LABEL_17:
      a6 = *(unsigned int *)(a2 + 32);
      v19 = *(unsigned __int8 **)(a2 + 8);
      if ((int)a6 < 8)
        break;
      v20 = *v19;
      v21 = v19[1];
      v23 = v20 == 255;
      v22 = v21 + (v20 << 8);
      v23 = v23 || v21 == 255;
      v24 = v19[2];
      v25 = v19 + 3;
      a6 = (a6 - 3);
      v14 = (v24 + (v22 << 8));
      if (v23 || v24 == 255)
        break;
      v27 = ~v12;
      *(_DWORD *)(a2 + 32) = a6;
      *(_QWORD *)(a2 + 8) = v25;
      v9 |= (_DWORD)v14 << v27;
      v12 = 23 - v27;
      v13 = v9 >> 23;
      v14 = *(unsigned int *)(v11 + 4 * v13);
      if ((int)v6 >= 64)
      {
        if ((int)v6 <= 64)
        {
          *(_DWORD *)a2 = v9;
          *(_DWORD *)(a2 + 24) = v12;
          *a4 = v6;
          return 0;
        }
        goto LABEL_48;
      }
    }
    *(_DWORD *)a2 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    v41 = v11;
    v42 = (unsigned int *)a2;
    v39 = a3;
    v40 = a4;
    v37 = a6;
    v38 = v7;
    v35 = v6;
    v36 = v13;
    v33 = v8;
    v34 = v14;
    result = aj_istream_fill_buf(a2, -9);
    if ((_DWORD)result)
      return result;
    v8 = v33;
    LODWORD(v6) = v35;
    a6 = v37;
    v7 = v38;
    a3 = v39;
    a4 = v40;
    v11 = v41;
    a2 = (uint64_t)v42;
    v10 = v42[7];
    v12 = v42[6];
    v9 = *v42;
    v13 = *v42 >> 23;
    v14 = *(unsigned int *)(v41 + 4 * v13);
  }
  while ((int)v35 < 64);
  if ((int)v35 <= 64)
  {
    *v42 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    *a4 = v6;
    return 0;
  }
LABEL_48:
  *(_DWORD *)a2 = v9;
  *(_DWORD *)(a2 + 24) = v12;
  *a4 = v6;
  return 7;
}

uint64_t aj_mcu_decode_progressive(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  int v22;
  int v23;
  uint64_t v24;
  _BYTE *v25;
  unsigned int (**v26)(_QWORD *, uint64_t, int *, _BYTE *);
  uint64_t v27;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  int v32;
  int v33;
  uint64_t v34;
  int32x4_t *v35;
  int16x4_t *v36;
  int v37;
  int32x4_t *v38;
  int32x4_t *v39;
  int16x4_t *v40;
  int i;
  unint64_t v42;
  int16x4_t *v43;
  int32x4_t *v44;
  int32x4_t v45;
  __int32 v46;
  __int32 v47;
  __int32 v48;
  __int32 v49;
  int16x4_t *v50;
  __int32 v51;
  _DWORD *v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  __int16 *v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  int v70;
  int *v71;
  int v72;
  int v73;
  int v74;
  char v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t (**v91)(_QWORD *, uint64_t, int *, uint64_t);
  int v92;
  uint64_t v93;
  uint64_t v94;
  _DWORD *v95;
  __int16 *v96;
  uint64_t v97;
  _QWORD *v98;
  uint64_t v99;
  int v100;
  int v101;
  int v102;
  uint64_t v103;
  char v104;
  int v105;
  int v106;
  int v107;
  unsigned int (**v108)(_QWORD *, uint64_t, int *, uint64_t);
  uint64_t v110;
  uint64_t v111;
  int v112;
  _DWORD *v113;
  _DWORD v114[64];
  _DWORD v115[2];
  _BYTE v116[768];
  uint64_t v117;

  v117 = *MEMORY[0x24BDAC8D0];
  v10 = *a1;
  v11 = a1[1];
  v12 = *(_DWORD *)(*a1 + 8);
  v14 = v12 + 7;
  v13 = v12 < -7;
  v15 = v12 + 14;
  if (!v13)
    v15 = v14;
  if (*(_DWORD *)(v10 + 16) + *(_DWORD *)(v10 + 16) * a5 > v15 >> 3)
    v16 = 1;
  else
    v16 = *(_DWORD *)(v10 + 16);
  v17 = *(_DWORD *)(v11 + 404);
  v110 = v17;
  v111 = a1[1];
  if (*(_DWORD *)(v10 + 32) == 2)
  {
    if (!a5)
    {
      bzero(*(void **)(v11 + 424), *(int *)(v11 + 432));
      if (v17 >= 1)
      {
        v64 = 0;
        v107 = a4 + 1;
        v65 = 280;
        do
        {
          v66 = *(_QWORD *)(v11 + 408);
          v67 = v66 + 288 * v64;
          if (*(_DWORD *)(v67 + 280))
          {
            v113 = (_DWORD *)(v67 + 280);
            v68 = (int *)(v66 + 288 * v64);
            v69 = a1[1];
            if (*v68 != 1)
            {
              v71 = (int *)*a1;
LABEL_101:
              if (v71[20] == 194 && v68[13] >= 1)
                v89 = *(_QWORD *)(v69 + 424) + ((uint64_t)*((int *)a1 + v68[1] + 1617) << 7);
              else
                v89 = *(_QWORD *)(v69 + 424);
              if (*(int *)(v69 + 80) >= 1)
              {
                v90 = 0;
                v91 = (uint64_t (**)(_QWORD *, uint64_t, int *, uint64_t))(v66 + 288 * v64 + 88);
                do
                {
                  if (!*v113)
                    break;
                  result = aj_find_and_handle_markers((int **)a1, (uint64_t *)a3, v68);
                  if ((_DWORD)result)
                    return result;
                  v92 = (*v91)(a1, a3, v68, v89);
                  v93 = a1[1];
                  if (v92)
                  {
                    if (!v64)
                      goto LABEL_117;
                    *(_BYTE *)(v93 + 400) = 1;
                    v94 = *(int *)(v93 + 404);
                    if (v64 < v94)
                    {
                      v95 = (_DWORD *)(*(_QWORD *)(v93 + 408) + v65);
                      do
                      {
                        *v95 = 0;
                        --v94;
                        v95 += 72;
                      }
                      while (v64 != v94);
                    }
                  }
                  ++v90;
                  v89 += (uint64_t)*(int *)(v93 + 92) << 7;
                }
                while (v90 < *(_DWORD *)(v93 + 80));
              }
              goto LABEL_115;
            }
            v70 = v68[1];
            v71 = (int *)*a1;
            if (v70)
              goto LABEL_101;
            v72 = v71[3];
            v73 = v72 + 7;
            v13 = v72 < -7;
            v74 = v72 + 14;
            if (!v13)
              v74 = v73;
            v102 = v74 >> 3;
            v101 = v71[8] * v107;
            v108 = (unsigned int (**)(_QWORD *, uint64_t, int *, uint64_t))(v66 + 288 * v64 + 88);
            v75 = 1;
            v76 = a1[1];
            v103 = v76;
            do
            {
              if (!*v113)
                break;
              v104 = v75;
              if (*(int *)(v76 + 80) >= 1)
              {
                v77 = 0;
                v78 = *(_DWORD *)(*a1 + 8);
                v79 = v78 + 7;
                v13 = v78 < -7;
                v80 = v78 + 14;
                if (!v13)
                  v80 = v79;
                v81 = v80 >> 3;
                v82 = *(_QWORD *)(v69 + 424) + ((*(int *)(*a1 + 16) * (uint64_t)v70) << 7);
                do
                {
                  v83 = *(_DWORD *)(*a1 + 16);
                  if (v83 >= v81)
                    v84 = v81;
                  else
                    v84 = v83;
                  if ((int)v84 >= 1)
                  {
                    v85 = 0;
                    v105 = v81 - v84;
                    v106 = v77;
                    while (*v113)
                    {
                      result = aj_find_and_handle_markers((int **)a1, (uint64_t *)a3, v68);
                      if ((_DWORD)result)
                        return result;
                      if ((*v108)(a1, a3, v68, v82 + (v85 << 7)))
                      {
                        if (!v64)
                          goto LABEL_117;
                        v86 = a1[1];
                        *(_BYTE *)(v86 + 400) = 1;
                        v87 = *(int *)(v86 + 404);
                        if (v64 < v87)
                        {
                          v88 = *(_QWORD *)(v86 + 408);
                          do
                          {
                            *(_DWORD *)(v88 + v65) = 0;
                            --v87;
                            v88 += 288;
                          }
                          while (v64 != v87);
                        }
                      }
                      ++v85;
                      --v81;
                      if (v85 == v84)
                      {
                        v81 = v105;
                        break;
                      }
                    }
                    v76 = a1[1];
                    v77 = v106;
                  }
                  if (++v77 >= *(_DWORD *)(v76 + 80))
                    break;
                  v82 += (uint64_t)*(int *)(v76 + 92) << 7;
                }
                while (*v113);
              }
              v70 = 1;
              v75 = 0;
              v69 = v103;
            }
            while (((v101 <= v102) & v104) != 0);
          }
LABEL_115:
          ++v64;
          v65 += 288;
          v11 = v111;
        }
        while (v64 != v110);
      }
    }
    __memcpy_chk();
    goto LABEL_28;
  }
  v112 = v16;
  aj_clear_blocks(v116, *(_DWORD *)(v11 + 92));
  if (v17 < 1)
  {
LABEL_28:
    v32 = *(_DWORD *)(a3 + 28) + 1;
    *(_DWORD *)(a3 + 28) = v32;
    if (v32 >= *(_DWORD *)(a1[1] + 80))
      *(_QWORD *)(a3 + 24) = (*(_DWORD *)(a3 + 24) + 1);
    result = 0;
    if (a6 && a7)
    {
      if (*(_DWORD *)(*a1 + 4) == 8)
      {
        v33 = *((_DWORD *)a1 + 1616);
        if (v33 >= 1)
        {
          v34 = 0;
          v35 = (int32x4_t *)(a1 + 30);
          v36 = (int16x4_t *)v116;
          do
          {
            if (v34)
              v37 = 1;
            else
              v37 = *(_DWORD *)(a1[1] + 88);
            v38 = (int32x4_t *)&a1[196 * v34];
            v39 = v38 + 15;
            switch(v38[56].i32[2])
            {
              case 1:
                if (v37 >= 1)
                {
                  do
                  {
                    v40 = v36;
                    v36 += 16;
                    aj_block_dequantize_s1(v40, v39);
                    --v37;
                  }
                  while (v37);
                  v33 = *((_DWORD *)a1 + 1616);
                }
                break;
              case 2:
                if (v37 >= 1)
                {
                  for (i = 0; i != v37; ++i)
                  {
                    v42 = -8;
                    v43 = v36;
                    v44 = v35;
                    do
                    {
                      v45 = *v44;
                      v44 += 2;
                      *v43 = vmul_s16(*v43, vmovn_s32(v45));
                      v43 += 2;
                      v42 += 8;
                    }
                    while (v42 < 0x11);
                    v36 += 16;
                  }
                }
                break;
              case 4:
                if (v37 >= 1)
                {
                  v46 = v39->i32[0];
                  v47 = v38[15].i32[1];
                  v48 = v39[2].i32[0];
                  v49 = v39[2].i32[1];
                  do
                  {
                    v50 = v36 + 16;
                    v36->i16[0] *= (_WORD)v46;
                    v36->i16[1] *= (_WORD)v47;
                    v36[2].i16[0] *= (_WORD)v48;
                    v36[2].i16[1] *= (_WORD)v49;
                    v36 += 16;
                    --v37;
                  }
                  while (v37);
                  v36 = v50;
                }
                break;
              case 8:
                if (v37 >= 1)
                {
                  v51 = v39->i32[0];
                  do
                  {
                    v36->i16[0] *= (_WORD)v51;
                    v36 += 16;
                    --v37;
                  }
                  while (v37);
                }
                break;
              default:
                break;
            }
            ++v34;
            v35 += 98;
          }
          while (v34 < v33);
        }
      }
      v52 = a7;
      v53 = *a7;
      v115[0] = v53;
      v115[1] = v53;
      v54 = *((_DWORD *)a1 + 49);
      if (v54 < 1)
      {
        v56 = 0;
      }
      else
      {
        v55 = 0;
        v56 = 0;
        v57 = *((_DWORD *)a1 + 48);
        do
        {
          if (v57 >= 1)
          {
            v58 = 0;
            v59 = (__int16 *)&v116[128 * (uint64_t)v56];
            do
            {
              if (*(_DWORD *)(*a1 + 4) == 12)
              {
                aj_block_dequantize_12bit((_DWORD *)a1 + 48, v59, v114);
                v60 = v115[v55];
                v115[v55] = ((uint64_t (*)(_DWORD *, uint64_t, _QWORD))a1[89])(v114, a6 + 8 * *((_DWORD *)a1 + 182) * (int)v55, v60)+ v60;
              }
              else
              {
                v61 = v115[v55];
                v62 = (uint64_t *)(a6 + 8 * *((_DWORD *)a1 + 182) * (int)v55);
                v115[v55] = ((uint64_t (*)(__int16 *, uint64_t *, uint64_t))a1[89])(v59, v62, v61) + v61;
                if (*((_BYTE *)a1 + 1232))
                  aj_mosquito_spray((uint64_t)(a1 + 24), (uint64_t)v59, v62, v61);
              }
              ++v58;
              v57 = *((_DWORD *)a1 + 48);
              v59 += 64;
            }
            while (v58 < v57);
            v56 += v58;
            v54 = *((_DWORD *)a1 + 49);
          }
          ++v55;
        }
        while (v55 < v54);
        v53 = v115[0];
        v52 = a7;
      }
      *v52 = v53;
      if (*((int *)a1 + 1616) > 1)
      {
        v96 = (__int16 *)&v116[128 * (uint64_t)v56];
        v97 = a6 + 128;
        v98 = a1 + 220;
        v99 = 1;
        do
        {
          if (*(_DWORD *)(*a1 + 4) == 12)
          {
            aj_block_dequantize_12bit(v98, v96, v114);
            v100 = ((uint64_t (*)(_DWORD *, uint64_t, _QWORD))v98[65])(v114, v97, v52[v99]);
          }
          else
          {
            v100 = ((uint64_t (*)(__int16 *, uint64_t, _QWORD))v98[65])(v96, v97, v52[v99]);
          }
          v52[v99++] += v100;
          v96 += 64;
          v97 += 128;
          v98 += 196;
        }
        while (v99 < *((int *)a1 + 1616));
      }
      return 0;
    }
    return result;
  }
  v18 = 0;
  v19 = 280;
  while (1)
  {
    v20 = *(_QWORD *)(v11 + 408);
    v21 = (int *)(v20 + 288 * v18);
    if (v21[70])
    {
      if (*v21 == 1)
      {
        v22 = v112;
        if (v21[1])
          v22 = 1;
      }
      else
      {
        v22 = 1;
      }
      v23 = v21[13];
      if (v23)
        v23 = *((_DWORD *)a1 + v21[1] + 1617);
      if (v22 >= 1)
        break;
    }
LABEL_27:
    ++v18;
    v19 += 288;
    v11 = v111;
    if (v18 == v110)
      goto LABEL_28;
  }
  v24 = 0;
  v25 = &v116[128 * (uint64_t)v23];
  v26 = (unsigned int (**)(_QWORD *, uint64_t, int *, _BYTE *))(v20 + 288 * v18 + 88);
  v27 = v22;
  while (1)
  {
    result = aj_find_and_handle_markers((int **)a1, (uint64_t *)a3, v21);
    if ((_DWORD)result)
      return result;
    if ((*v26)(a1, a3, v21, &v25[128 * v24]))
    {
      if (!v18)
      {
LABEL_117:
        aj_log_error(0, "First scan failed, abort decode");
        return 7;
      }
      v29 = a1[1];
      *(_BYTE *)(v29 + 400) = 1;
      v30 = *(int *)(v29 + 404);
      if (v18 < v30)
      {
        v31 = (_DWORD *)(*(_QWORD *)(v29 + 408) + v19);
        do
        {
          *v31 = 0;
          --v30;
          v31 += 72;
        }
        while (v18 != v30);
      }
    }
    if (++v24 == v27)
      goto LABEL_27;
  }
}

uint64_t aj_find_and_handle_markers(int **a1, uint64_t *a2, int *a3)
{
  int *v4;
  int *v5;
  _DWORD *v6;
  int v7;
  int v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t result;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  uint64_t v19;
  uint64_t v20;

  if (a3)
  {
    v4 = a3 + 1;
    v5 = a3 + 18;
    v6 = a3 + 19;
    v7 = a3[17];
    v8 = *a3;
    v9 = (uint64_t)(a3 + 24);
    v10 = !a3[13] && !a3[16];
  }
  else
  {
    v5 = (int *)a2 + 9;
    v6 = a2 + 4;
    v9 = *a2;
    v7 = (*a1)[851];
    v8 = **a1;
    v10 = 1;
    v4 = &comp_ind_table;
  }
  if (*(_QWORD *)(v9 + 16) || *(int *)(v9 + 24) > 6 || (result = aj_istream_fill_buf(v9, -9), !(_DWORD)result))
  {
    if (v7 < 1 || *v6 != v7)
      return 0;
    v12 = *v5 + 1;
    v13 = -v12 < 0;
    v14 = -v12 & 7;
    v15 = v12 & 7;
    if (!v13)
      v15 = -v14;
    v16 = *(unsigned __int8 **)(v9 + 16);
    if (v16)
    {
      v17 = *v16;
      if ((v15 | 0xD0) == v17)
      {
        if (v8 > 0 && v10)
        {
          v19 = v8;
          do
          {
            v20 = *v4++;
            *((_DWORD *)a2 + v20 + 2) = 0;
            --v19;
          }
          while (v19);
        }
        result = 0;
        *(_DWORD *)v9 = 0;
        *(_DWORD *)(v9 + 24) = -9;
        *v6 = 0;
        *v5 = v15 & 0xF;
        *(_QWORD *)(v9 + 16) = 0;
        if (*(int *)(v9 + 24) <= 6)
          return aj_istream_fill_buf(v9, -9);
        return result;
      }
      aj_log_error(0, "Bitstream corrupt: Wrong marker (%02X) found.", v17);
      return 7;
    }
    if (*(int *)(v9 + 32) > 1)
      return 7;
    result = 7;
    if (*(_BYTE *)(v9 + 112))
    {
      if (*(_DWORD *)(v9 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t aj_prog_decode_AC_first(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unsigned int *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  char v28;

  v5 = (int)a3[1];
  v6 = *(_QWORD *)&a3[4 * a3[v5 + 9] + 56];
  v28 = 0;
  v7 = a3[20];
  if (v7)
    goto LABEL_2;
  v8 = a3[13];
  if (v8 <= a3[14])
  {
    v12 = a3 + 24;
    v13 = *(_QWORD *)(a1 + 1568 * (int)v5 + 896);
    do
    {
      v14 = a3[30];
      if (v14 <= -2)
      {
        v15 = aj_istream_fill_buf((uint64_t)(a3 + 24), -9);
        if ((_DWORD)v15)
        {
          v9 = v15;
LABEL_31:
          aj_log_error(0, "Unable to read more data");
          return v9;
        }
        v14 = a3[30];
        if (v14 <= -9)
        {
          v9 = 7;
          goto LABEL_31;
        }
      }
      v16 = *v12;
      v17 = *(unsigned __int16 *)(v6 + ((v16 >> 23) & 0x1FE) + 272);
      if (*(_WORD *)(v6 + ((v16 >> 23) & 0x1FE) + 272))
      {
        v18 = v14 + 9;
        if (v14 >= 0)
          v18 = 8;
        if (v18 < v17 >> 8)
          return 7;
        a3[24] = (_DWORD)v16 << SBYTE1(v17);
        a3[30] = v14 - (v17 >> 8);
        v28 = v17;
      }
      else
      {
        v19 = prog_huff_decode_loop(v6, a3 + 24, &v28);
        if ((_DWORD)v19)
          return v19;
        LOBYTE(v17) = v28;
      }
      v20 = v17 >> 4;
      v21 = v17 & 0xF;
      if ((v17 & 0xF) != 0)
      {
        v22 = a3[30];
        if (v22 < v21 - 9)
        {
          if (aj_istream_fill_buf((uint64_t)(a3 + 24), -9))
            return 9;
          v22 = a3[30];
          if (v22 < v21 - 9)
            return 9;
        }
        v23 = v20 + v8;
        v24 = a3[24];
        a3[24] = v24 << v21;
        a3[30] = v22 - v21;
        v25 = (-1 << v21) | 1;
        if (v24 < 0)
          v25 = 0;
        *(_WORD *)(a4 + 2 * *(int *)(v13 + 4 * v23)) = (v25 + (v24 >> -(char)v21)) << a3[15];
      }
      else
      {
        if (v20 != 15)
        {
          v7 = 1 << v20;
          a3[20] = 1 << v20;
          if (v17 >= 0x10u)
          {
            v26 = a3[30];
            if (v26 < v20 - 9)
            {
              if (aj_istream_fill_buf((uint64_t)(a3 + 24), -9))
                return 9;
              v26 = a3[30];
              if (v26 < v20 - 9)
                return 9;
              v7 = a3[20];
            }
            v27 = a3[24];
            a3[24] = v27 << v20;
            a3[30] = v26 - v20;
            v7 += v27 >> -(char)v20;
          }
LABEL_2:
          a3[20] = v7 - 1;
          break;
        }
        v23 = v8 + 15;
      }
      v8 = v23 + 1;
    }
    while (v23 < a3[14]);
  }
  v9 = 0;
  ++a3[19];
  return v9;
}

uint64_t aj_prog_decode_AC_refine(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  int v19;
  __int16 v20;
  int v21;
  unsigned int v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  __int16 v41;
  BOOL v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  __int16 v47;
  int v48;
  int v49;
  unsigned int v51;
  int v52;
  char v53;

  v6 = a3[1];
  v7 = *(_QWORD *)&a3[4 * a3[v6 + 9] + 56];
  v8 = (unsigned int *)(a3 + 24);
  v53 = 0;
  v9 = *(_QWORD *)(a1 + 1568 * (int)v6 + 896);
  v11 = a3[13];
  v10 = a3[14];
  v12 = (int *)(v9 + 4 * v10);
  v13 = (int *)(v9 + 4 * v11);
  if (a3[20])
    goto LABEL_2;
  if ((int)v11 > (int)v10)
    goto LABEL_28;
  do
  {
    v26 = a3[30];
    if (v26 > -2)
      goto LABEL_32;
    v27 = aj_istream_fill_buf((uint64_t)v8, -9);
    if ((_DWORD)v27)
    {
      v25 = v27;
LABEL_81:
      aj_log_error(0, "Unable to read more data");
      return v25;
    }
    v26 = a3[30];
    if (v26 <= -9)
    {
      v25 = 7;
      goto LABEL_81;
    }
LABEL_32:
    v28 = *v8;
    v29 = *(unsigned __int16 *)(v7 + ((v28 >> 23) & 0x1FE) + 272);
    if (*(_WORD *)(v7 + ((v28 >> 23) & 0x1FE) + 272))
    {
      v30 = v26 + 9;
      if (v26 >= 0)
        v30 = 8;
      if (v30 < v29 >> 8)
        return 7;
      a3[24] = (_DWORD)v28 << SBYTE1(v29);
      a3[30] = v26 - (v29 >> 8);
      v53 = v29;
    }
    else
    {
      v31 = prog_huff_decode_loop(v7, v8, &v53);
      if ((_DWORD)v31)
        return v31;
      LOBYTE(v29) = v53;
    }
    v32 = v29 >> 4;
    if ((v29 & 0xF) == 0)
    {
      if (v32 == 15)
      {
        v36 = 0;
        goto LABEL_49;
      }
      v48 = 1 << v32;
      a3[20] = 1 << v32;
      if (v29 >= 0x10u)
      {
        v49 = a3[30];
        if (v49 < v32 - 9)
        {
          if (aj_istream_fill_buf((uint64_t)v8, -9))
            return 9;
          v49 = a3[30];
          if (v49 < v32 - 9)
            return 9;
          v48 = a3[20];
        }
        v51 = a3[24];
        a3[24] = v51 << v32;
        a3[30] = v49 - v32;
        v52 = v48 | (v51 >> -(char)v32);
        a3[20] = v52;
        if (!v52)
          goto LABEL_28;
      }
LABEL_2:
      if (v13 < v12)
      {
        do
        {
          v14 = v13;
          v16 = *v13;
          v15 = v13[1];
          if (*(_WORD *)(a4 + 2 * v16))
          {
            v17 = a3[30];
            if (v17 <= -9)
            {
              if (aj_istream_fill_buf((uint64_t)v8, -9))
                return 9;
              v17 = a3[30];
              if (v17 < -8)
                return 9;
            }
            v18 = *v8;
            if ((*v8 & 0x80000000) != 0)
            {
              v19 = *(__int16 *)(a4 + 2 * v16);
              if (v19 > 0)
                v20 = 1;
              else
                v20 = -1;
              *(_WORD *)(a4 + 2 * v16) = v19 + (v20 << a3[15]);
            }
            a3[24] = 2 * v18;
            a3[30] = v17 - 1;
          }
          if (*(_WORD *)(a4 + 2 * v15))
          {
            v21 = a3[30];
            if (v21 <= -9)
            {
              if (aj_istream_fill_buf((uint64_t)v8, -9))
                return 9;
              v21 = a3[30];
              if (v21 < -8)
                return 9;
            }
            v22 = *v8;
            if ((*v8 & 0x80000000) != 0)
            {
              v23 = *(__int16 *)(a4 + 2 * v15);
              if (v23 > 0)
                v24 = 1;
              else
                v24 = -1;
              *(_WORD *)(a4 + 2 * v15) = v23 + (v24 << a3[15]);
            }
            a3[24] = 2 * v22;
            a3[30] = v21 - 1;
          }
          v13 = v14 + 2;
        }
        while (v14 + 2 < v12);
        v13 = v14 + 2;
      }
      if (v13 == v12 && *(_WORD *)(a4 + 2 * *v12))
      {
        v43 = a3[30];
        if (v43 <= -9)
        {
          if (aj_istream_fill_buf((uint64_t)v8, -9))
            return 9;
          v43 = a3[30];
          if (v43 < -8)
            return 9;
        }
        v44 = *v8;
        if ((*v8 & 0x80000000) != 0)
        {
          v45 = *v12;
          v46 = *(__int16 *)(a4 + 2 * v45);
          if (v46 > 0)
            v47 = 1;
          else
            v47 = -1;
          *(_WORD *)(a4 + 2 * v45) = v46 + (v47 << a3[15]);
        }
        a3[24] = 2 * v44;
        a3[30] = v43 - 1;
      }
      --a3[20];
      goto LABEL_28;
    }
    v33 = a3[30];
    if (v33 <= -9)
    {
      if (aj_istream_fill_buf((uint64_t)v8, -9))
        return 9;
      v33 = a3[30];
      if (v33 < -8)
        return 9;
    }
    v34 = a3[24];
    if (v34 >= 0)
      v35 = -1;
    else
      v35 = 1;
    v36 = v35 << a3[15];
    a3[24] = 2 * v34;
    a3[30] = v33 - 1;
    do
    {
LABEL_49:
      if (*(_WORD *)(a4 + 2 * *v13))
      {
        v37 = a3[30];
        if (v37 <= -9)
        {
          if (aj_istream_fill_buf((uint64_t)v8, -9))
            return 9;
          v37 = a3[30];
          if (v37 < -8)
            return 9;
        }
        v38 = *v8;
        if ((*v8 & 0x80000000) != 0)
        {
          v39 = *v13;
          v40 = *(__int16 *)(a4 + 2 * v39);
          if (v40 > 0)
            v41 = 1;
          else
            v41 = -1;
          *(_WORD *)(a4 + 2 * v39) = v40 + (v41 << a3[15]);
        }
        a3[24] = 2 * v38;
        a3[30] = v37 - 1;
      }
      else
      {
        v42 = __OFSUB__(v32--, 1);
        if (v32 < 0 != v42)
          break;
      }
      ++v13;
    }
    while (v13 <= v12);
    if (v36)
    {
      if (v13 > v12)
        v13 = v12;
      *(_WORD *)(a4 + 2 * *v13) = v36;
    }
    ++v13;
  }
  while (v13 <= v12);
  if (a3[20])
    goto LABEL_2;
LABEL_28:
  v25 = 0;
  ++a3[19];
  return v25;
}

int16x4_t *aj_block_dequantize_s1(int16x4_t *a1, int32x4_t *a2)
{
  int32x4_t *v2;
  int32x4_t v3;
  int32x4_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x4_t *v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;

  v3 = *a2;
  v4 = a2[1];
  v2 = a2 + 2;
  v5 = *v2;
  v6 = v2[1];
  v2 += 2;
  v7 = *v2;
  v8 = v2[1];
  v2 += 2;
  v9 = *v2;
  v10 = v2[1];
  v2 += 2;
  v11 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(a1[2]), v5), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1[2].i8), v6), 0xCuLL);
  v12 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(a1[4]), v7), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1[4].i8), v8), 0xCuLL);
  v13 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(a1[6]), v9), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1[6].i8), v10), 0xCuLL);
  *(int16x8_t *)a1->i8 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(*a1), v3), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1->i8), v4), 0xCuLL);
  *(int16x8_t *)a1[2].i8 = v11;
  v14 = a1 + 4;
  *(int16x8_t *)v14->i8 = v12;
  *(int16x8_t *)v14[2].i8 = v13;
  v14 += 4;
  v15 = *v2;
  v16 = v2[1];
  v2 += 2;
  v17 = *v2;
  v18 = v2[1];
  v2 += 2;
  v19 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(v14[2]), v17), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14[2].i8), v18), 0xCuLL);
  v20 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(v14[4]), *v2), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14[4].i8), v2[1]), 0xCuLL);
  v21 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(v14[6]), v2[2]), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14[6].i8), v2[3]), 0xCuLL);
  *(int16x8_t *)v14->i8 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(*v14), v15), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14->i8), v16), 0xCuLL);
  *(int16x8_t *)v14[2].i8 = v19;
  v14 += 4;
  *(int16x8_t *)v14->i8 = v20;
  *(int16x8_t *)v14[2].i8 = v21;
  return v14 + 4;
}

uint64_t aj_istream_fill_buf(uint64_t a1, int a2)
{
  int v4;
  int v5;
  int v6;
  unsigned __int8 *v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  int v13;
  uint64_t result;
  int v15;

  v4 = *(_DWORD *)(a1 + 32);
  if (v4 <= 7)
  {
    result = aj_istream_move_forward(a1);
    if ((_DWORD)result)
      return result;
    v4 = *(_DWORD *)(a1 + 32);
    if (v4 <= 7)
      return secure_fill_buf(a1, a2);
  }
  v5 = 0;
  v6 = 0;
  v7 = *(unsigned __int8 **)(a1 + 16);
  while (1)
  {
    if (v7)
    {
      v13 = *(_DWORD *)(a1 + 24);
      if (v13 < 0)
        goto LABEL_15;
      goto LABEL_13;
    }
    v8 = v4 - 1;
    *(_DWORD *)(a1 + 32) = v4 - 1;
    v9 = *(unsigned __int8 **)(a1 + 8);
    v10 = v9 + 1;
    *(_QWORD *)(a1 + 8) = v9 + 1;
    v11 = *v9;
    if (v11 == 255)
      break;
LABEL_7:
    v5 = v11 | (v5 << 8);
    v6 += 8;
    v13 = *(_DWORD *)(a1 + 24) + v6;
    v4 = v8;
    if (v13 >= 16)
    {
      v10 = 0;
      goto LABEL_9;
    }
  }
  v12 = v4 - 2;
  *(_DWORD *)(a1 + 32) = v12;
  *(_QWORD *)(a1 + 8) = v9 + 2;
  if (!v9[1])
  {
    v11 = 255;
    v8 = v12;
    goto LABEL_7;
  }
  if (v9[1] != 255)
  {
    *(_QWORD *)(a1 + 16) = v10;
    *(_DWORD *)(a1 + 28) = 1;
    v13 = *(_DWORD *)(a1 + 24);
    if (v6)
    {
      v13 += v6;
LABEL_9:
      *(_DWORD *)a1 |= v5 << (23 - v13);
      *(_DWORD *)(a1 + 24) = v13;
    }
    v7 = v10;
    if (v13 < 0)
    {
LABEL_15:
      if (v13 >= a2)
        return 0;
      else
        return aj_istream_get_error_code_eod(a1);
    }
LABEL_13:
    if (!v7)
      *(_DWORD *)(a1 + 28) = 0;
    goto LABEL_15;
  }
  *(_QWORD *)(a1 + 8) = v10;
  *(_DWORD *)(a1 + 32) = v8;
  if (v6)
  {
    v15 = *(_DWORD *)(a1 + 24) + v6;
    *(_DWORD *)a1 |= v5 << (23 - v15);
    *(_DWORD *)(a1 + 24) = v15;
  }
  return secure_fill_buf(a1, a2);
}

uint64_t aj_idct_s1(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  int16x8_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int16x8_t v85;
  int16x8_t v86;
  int16x8_t v87;
  int16x8_t v88;
  int16x8_t v89;
  int16x8_t v90;
  int16x8_t v91;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = vaddq_s16(v8, v4);
  v10 = vaddq_s16(*a1, v6);
  v11 = vsubq_s16(*a1, v6);
  v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  v13 = vqshlq_n_s16(a1[7], 1uLL);
  v14 = vaddq_s16(v5, v7);
  v15 = vsubq_s16(v7, v5);
  v16 = vaddq_s16(v3, v13);
  v17 = vsubq_s16(v3, v13);
  v18 = vaddq_s16(v16, v14);
  v19 = vaddq_s16(v9, v12);
  v20 = vaddq_s16(v10, v19);
  v21 = vsubq_s16(v10, v19);
  v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  v24 = vsubq_s16(v11, v12);
  v25 = vaddq_s16(v11, v12);
  v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  v28 = vaddq_s16(v18, v26);
  v29 = vaddq_s16(v26, v23);
  v30 = vaddq_s16(v27, v23);
  v31 = vaddq_s16(v20, v28);
  v32 = vaddq_s16(v25, v29);
  v33 = vaddq_s16(v24, v30);
  v34 = vaddq_s16(v21, v27);
  v35 = vsubq_s16(v21, v27);
  v36 = vsubq_s16(v24, v30);
  v37 = vsubq_s16(v25, v29);
  v38 = vsubq_s16(v20, v28);
  v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  v64 = *a2;
  v65 = a2[1];
  v63 = a2 + 2;
  v66 = *v63;
  v67 = v63[1];
  v63 += 2;
  v68 = *v63;
  v69 = v63[1];
  v63 += 2;
  v70 = vaddq_s16(v60, v59);
  v71 = vaddq_s16(v55, v56);
  v72 = vsubq_s16(v55, v56);
  v73 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  v74 = vqshlq_n_s16(v62, 1uLL);
  v75 = vaddq_s16(v61, v58);
  v76 = vsubq_s16(v58, v61);
  v77 = vaddq_s16(v57, v74);
  v78 = vsubq_s16(v57, v74);
  v79 = vaddq_s16(v77, v75);
  v80 = vaddq_s16(v70, v73);
  v81 = vaddq_s16(v71, v80);
  v82 = vsubq_s16(v71, v80);
  v83 = vqrdmulhq_lane_s16(vaddq_s16(v76, v78), (int16x4_t)0x30FC273D5A824546, 3);
  v84 = vqrdmulhq_lane_s16(vsubq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  v85 = vsubq_s16(v72, v73);
  v86 = vaddq_s16(v72, v73);
  v87 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 2), v78), v83);
  v88 = vaddq_s16(vqrdmulhq_lane_s16(v76, (int16x4_t)0x30FC273D5A824546, 0), v83);
  v89 = vaddq_s16(v79, v87);
  v90 = vaddq_s16(v87, v84);
  v91 = vaddq_s16(v88, v84);
  _X3 = (int8x8_t *)(v64 + a3);
  _X4 = (int8x8_t *)(v65 + a3);
  _X5 = (int8x8_t *)(v66 + a3);
  _X6 = (int8x8_t *)(v67 + a3);
  _X7 = (int8x8_t *)(v68 + a3);
  _X9 = (int8x8_t *)(v69 + a3);
  _X10 = (int8x8_t *)(*v63 + a3);
  _X11 = (int8x8_t *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *_X3 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  *_X4 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *_X5 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *_X6 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *_X7 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *_X9 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *_X10 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *_X11 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  return 8;
}

uint64_t aj_idct_s1_16x16_bilinear(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  int16x8_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int16x8_t v85;
  int16x8_t v86;
  int16x8_t v87;
  int16x8_t v88;
  int16x8_t v89;
  int16x8_t v90;
  int16x8_t v91;
  int16x8_t v92;
  int16x8_t v93;
  int16x8_t v94;
  int16x8_t v95;
  int16x8_t v96;
  int16x8_t v97;
  int16x8_t v98;
  int16x8_t v99;
  int16x8_t v100;
  int16x8_t v101;
  int16x8_t v122;
  uint16x8_t v123;
  uint16x8_t v124;
  int16x8_t v125;
  int16x8_t v126;
  uint8x8_t v127;
  int16x8_t v128;
  int16x8_t v129;
  int64x2_t v130;
  int64x2_t v131;
  uint16x8_t v132;
  uint16x8_t v133;
  int8x8x2_t v134;
  int8x8x2_t v135;
  uint16x8_t v136;
  uint8x8_t v137;
  uint8x8_t v138;
  int16x8_t v139;
  int16x8_t v140;
  int64x2_t v141;
  int64x2_t v142;
  uint16x8_t v143;
  uint16x8_t v144;
  int8x8x2_t v145;
  int8x8x2_t v146;
  uint16x8_t v147;
  uint8x8_t v148;
  uint8x8_t v149;
  int16x8_t v150;
  int16x8_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  int64x2_t v156;
  int64x2_t v157;
  uint16x8_t v158;
  uint16x8_t v159;
  int8x8x2_t v160;
  int8x8x2_t v161;
  uint16x8_t v162;
  uint8x8_t v163;
  uint8x8_t v164;
  int16x8_t v165;
  int16x8_t v166;
  int64x2_t v175;
  int64x2_t v176;
  uint16x8_t v177;
  uint16x8_t v178;
  int8x8x2_t v179;
  int8x8x2_t v180;
  uint16x8_t v181;
  uint8x8_t v182;
  uint8x8_t v183;
  int16x8_t v184;
  int16x8_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int64x2_t v190;
  int64x2_t v191;
  uint16x8_t v192;
  uint16x8_t v193;
  int8x8x2_t v194;
  int8x8x2_t v195;
  uint16x8_t v196;
  uint8x8_t v197;
  uint8x8_t v198;
  int16x8_t v199;
  int16x8_t v200;
  int64x2_t v209;
  int64x2_t v210;
  uint16x8_t v211;
  uint16x8_t v212;
  int8x8x2_t v213;
  int8x8x2_t v214;
  uint16x8_t v215;
  uint8x8_t v216;
  uint8x8_t v217;
  int16x8_t v218;
  int16x8_t v219;
  uint8x8_t v220;
  uint8x8_t v221;
  uint8x8_t v222;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = vaddq_s16(v8, v4);
  v10 = vaddq_s16(*a1, v6);
  v11 = vsubq_s16(*a1, v6);
  v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  v13 = vqshlq_n_s16(a1[7], 1uLL);
  v14 = vaddq_s16(v5, v7);
  v15 = vsubq_s16(v7, v5);
  v16 = vaddq_s16(v3, v13);
  v17 = vsubq_s16(v3, v13);
  v18 = vaddq_s16(v16, v14);
  v19 = vaddq_s16(v9, v12);
  v20 = vaddq_s16(v10, v19);
  v21 = vsubq_s16(v10, v19);
  v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  v24 = vsubq_s16(v11, v12);
  v25 = vaddq_s16(v11, v12);
  v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  v28 = vaddq_s16(v18, v26);
  v29 = vaddq_s16(v26, v23);
  v30 = vaddq_s16(v27, v23);
  v31 = vaddq_s16(v20, v28);
  v32 = vaddq_s16(v25, v29);
  v33 = vaddq_s16(v24, v30);
  v34 = vaddq_s16(v21, v27);
  v35 = vsubq_s16(v21, v27);
  v36 = vsubq_s16(v24, v30);
  v37 = vsubq_s16(v25, v29);
  v38 = vsubq_s16(v20, v28);
  v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  v64 = *a2;
  v65 = a2[1];
  v63 = a2 + 2;
  v66 = *v63;
  v67 = v63[1];
  v63 += 2;
  v68 = *v63;
  v69 = v63[1];
  v63 += 2;
  v70 = *v63;
  v71 = v63[1];
  v63 += 2;
  v72 = vaddq_s16(v60, v59);
  v73 = vaddq_s16(v55, v56);
  v74 = vsubq_s16(v55, v56);
  v75 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  v76 = vqshlq_n_s16(v62, 1uLL);
  v77 = vaddq_s16(v61, v58);
  v78 = vsubq_s16(v58, v61);
  v79 = vaddq_s16(v57, v76);
  v80 = vsubq_s16(v57, v76);
  v81 = vaddq_s16(v79, v77);
  v82 = vaddq_s16(v72, v75);
  v83 = vaddq_s16(v73, v82);
  v84 = vsubq_s16(v73, v82);
  v85 = vqrdmulhq_lane_s16(vaddq_s16(v78, v80), (int16x4_t)0x30FC273D5A824546, 3);
  v86 = vqrdmulhq_lane_s16(vsubq_s16(v79, v77), (int16x4_t)0x30FC273D5A824546, 1);
  v87 = vsubq_s16(v74, v75);
  v88 = vaddq_s16(v74, v75);
  v89 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v80, (int16x4_t)0x30FC273D5A824546, 2), v80), v85);
  v90 = vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 0), v85);
  v91 = vaddq_s16(v81, v89);
  v92 = vaddq_s16(v89, v86);
  v93 = vaddq_s16(v90, v86);
  v94 = vaddq_s16(v83, v91);
  v95 = vaddq_s16(v88, v92);
  v96 = vaddq_s16(v87, v93);
  v97 = vaddq_s16(v84, v90);
  v98 = vsubq_s16(v84, v90);
  v99 = vsubq_s16(v87, v93);
  v100 = vsubq_s16(v88, v92);
  v101 = vsubq_s16(v83, v91);
  _X3 = (char *)(v64 + a3);
  _X4 = (char *)(v65 + a3);
  _X5 = (char *)(v66 + a3);
  _X6 = (char *)(v67 + a3);
  _X7 = (char *)(v68 + a3);
  _X9 = (char *)(v69 + a3);
  _X10 = (char *)(v70 + a3);
  _X11 = (char *)(v71 + a3);
  *(int8x8_t *)v94.i8 = vadd_s8(vqrshrn_n_s16(v94, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v95.i8 = vadd_s8(vqrshrn_n_s16(v95, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v96.i8 = vadd_s8(vqrshrn_n_s16(v96, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v97.i8 = vadd_s8(vqrshrn_n_s16(v97, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v98.i8 = vadd_s8(vqrshrn_n_s16(v98, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v99.i8 = vadd_s8(vqrshrn_n_s16(v99, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v100.i8 = vadd_s8(vqrshrn_n_s16(v100, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v101.i8 = vadd_s8(vqrshrn_n_s16(v101, 5uLL), (int8x8_t)0x8080808080808080);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  v122.i64[0] = 0x3000300030003;
  v122.i64[1] = 0x3000300030003;
  v123 = vmull_u8(*(uint8x8_t *)v94.i8, (uint8x8_t)0x303030303030303);
  v124 = vmull_u8(*(uint8x8_t *)v95.i8, (uint8x8_t)0x303030303030303);
  v78.i64[0] = v94.i64[0];
  v83.i64[0] = v94.i64[0];
  v87.i64[0] = v95.i64[0];
  v46.i64[0] = v95.i64[0];
  v125 = (int16x8_t)vaddw_u8(v123, (uint8x8_t)*(_OWORD *)&vsliq_n_s64((int64x2_t)v78, (int64x2_t)v94, 8uLL));
  v126 = (int16x8_t)vaddw_u8(v123, (uint8x8_t)*(_OWORD *)&vsriq_n_s64((int64x2_t)v83, (int64x2_t)v94, 8uLL));
  *(uint8x8_t *)v48.i8 = vqshrn_n_u16(vaddw_u8((uint16x8_t)v125, (uint8x8_t)0x101010101010101), 2uLL);
  v127 = vqrshrn_n_u16((uint16x8_t)v126, 2uLL);
  v128 = (int16x8_t)vaddw_u8(v124, (uint8x8_t)*(_OWORD *)&vsliq_n_s64((int64x2_t)v87, (int64x2_t)v95, 8uLL));
  v129 = (int16x8_t)vaddw_u8(v124, (uint8x8_t)*(_OWORD *)&vsriq_n_s64((int64x2_t)v46, (int64x2_t)v95, 8uLL));
  vst2_s8(_X3, (int8x8x2_t)v48);
  v130 = (int64x2_t)vaddq_s16(v128, vmulq_s16(v125, v122));
  v131 = (int64x2_t)vaddq_s16(v125, vmulq_s16(v128, v122));
  v132 = (uint16x8_t)vaddq_s16(v129, vmulq_s16(v126, v122));
  v133 = (uint16x8_t)vaddq_s16(v126, vmulq_s16(v129, v122));
  v134 = (int8x8x2_t)vaddw_u8((uint16x8_t)v130, (uint8x8_t)0x707070707070707);
  v135 = (int8x8x2_t)vaddw_u8((uint16x8_t)v131, (uint8x8_t)0x707070707070707);
  v136 = vmull_u8(*(uint8x8_t *)v96.i8, (uint8x8_t)0x303030303030303);
  v130.i64[0] = v96.i64[0];
  v131.i64[0] = v96.i64[0];
  v137 = vqrshrn_n_u16(v132, 4uLL);
  v134.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v134, 4uLL);
  v135.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v135, 4uLL);
  v138 = vqrshrn_n_u16(v133, 4uLL);
  vst2_s8(_X4, v134);
  vst2_s8(_X5, v135);
  v139 = (int16x8_t)vaddw_u8(v136, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v130, (int64x2_t)v96, 8uLL));
  v140 = (int16x8_t)vaddw_u8(v136, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v131, (int64x2_t)v96, 8uLL));
  v141 = (int64x2_t)vaddq_s16(v139, vmulq_s16(v128, v122));
  v142 = (int64x2_t)vaddq_s16(v128, vmulq_s16(v139, v122));
  v143 = (uint16x8_t)vaddq_s16(v140, vmulq_s16(v129, v122));
  v144 = (uint16x8_t)vaddq_s16(v129, vmulq_s16(v140, v122));
  v145 = (int8x8x2_t)vaddw_u8((uint16x8_t)v141, (uint8x8_t)0x707070707070707);
  v146 = (int8x8x2_t)vaddw_u8((uint16x8_t)v142, (uint8x8_t)0x707070707070707);
  v147 = vmull_u8(*(uint8x8_t *)v97.i8, (uint8x8_t)0x303030303030303);
  v141.i64[0] = v97.i64[0];
  v142.i64[0] = v97.i64[0];
  v148 = vqrshrn_n_u16(v143, 4uLL);
  v145.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v145, 4uLL);
  v146.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v146, 4uLL);
  v149 = vqrshrn_n_u16(v144, 4uLL);
  vst2_s8(_X6, v145);
  vst2_s8(_X7, v146);
  v150 = (int16x8_t)vaddw_u8(v147, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v141, (int64x2_t)v97, 8uLL));
  v151 = (int16x8_t)vaddw_u8(v147, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v142, (int64x2_t)v97, 8uLL));
  v152 = *v63;
  v153 = v63[1];
  v63 += 2;
  v154 = *v63;
  v155 = v63[1];
  v63 += 2;
  v156 = (int64x2_t)vaddq_s16(v150, vmulq_s16(v139, v122));
  v157 = (int64x2_t)vaddq_s16(v139, vmulq_s16(v150, v122));
  v158 = (uint16x8_t)vaddq_s16(v151, vmulq_s16(v140, v122));
  v159 = (uint16x8_t)vaddq_s16(v140, vmulq_s16(v151, v122));
  v160 = (int8x8x2_t)vaddw_u8((uint16x8_t)v156, (uint8x8_t)0x707070707070707);
  v161 = (int8x8x2_t)vaddw_u8((uint16x8_t)v157, (uint8x8_t)0x707070707070707);
  v162 = vmull_u8(*(uint8x8_t *)v98.i8, (uint8x8_t)0x303030303030303);
  v156.i64[0] = v98.i64[0];
  v157.i64[0] = v98.i64[0];
  v163 = vqrshrn_n_u16(v158, 4uLL);
  v160.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v160, 4uLL);
  v161.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v161, 4uLL);
  v164 = vqrshrn_n_u16(v159, 4uLL);
  vst2_s8(_X9, v160);
  vst2_s8(_X10, v161);
  v165 = (int16x8_t)vaddw_u8(v162, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v156, (int64x2_t)v98, 8uLL));
  v166 = (int16x8_t)vaddw_u8(v162, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v157, (int64x2_t)v98, 8uLL));
  _X3 = (char *)(v152 + a3);
  _X4 = (char *)(v153 + a3);
  _X5 = (char *)(v154 + a3);
  _X6 = (char *)(v155 + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  v175 = (int64x2_t)vaddq_s16(v165, vmulq_s16(v150, v122));
  v176 = (int64x2_t)vaddq_s16(v150, vmulq_s16(v165, v122));
  v177 = (uint16x8_t)vaddq_s16(v166, vmulq_s16(v151, v122));
  v178 = (uint16x8_t)vaddq_s16(v151, vmulq_s16(v166, v122));
  v179 = (int8x8x2_t)vaddw_u8((uint16x8_t)v175, (uint8x8_t)0x707070707070707);
  v180 = (int8x8x2_t)vaddw_u8((uint16x8_t)v176, (uint8x8_t)0x707070707070707);
  v181 = vmull_u8(*(uint8x8_t *)v99.i8, (uint8x8_t)0x303030303030303);
  v175.i64[0] = v99.i64[0];
  v176.i64[0] = v99.i64[0];
  v182 = vqrshrn_n_u16(v177, 4uLL);
  v179.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v179, 4uLL);
  v180.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v180, 4uLL);
  v183 = vqrshrn_n_u16(v178, 4uLL);
  vst2_s8(_X11, v179);
  vst2_s8(_X3, v180);
  v184 = (int16x8_t)vaddw_u8(v181, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v175, (int64x2_t)v99, 8uLL));
  v185 = (int16x8_t)vaddw_u8(v181, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v176, (int64x2_t)v99, 8uLL));
  v186 = *v63;
  v187 = v63[1];
  v63 += 2;
  v188 = *v63;
  v189 = v63[1];
  v190 = (int64x2_t)vaddq_s16(v184, vmulq_s16(v165, v122));
  v191 = (int64x2_t)vaddq_s16(v165, vmulq_s16(v184, v122));
  v192 = (uint16x8_t)vaddq_s16(v185, vmulq_s16(v166, v122));
  v193 = (uint16x8_t)vaddq_s16(v166, vmulq_s16(v185, v122));
  v194 = (int8x8x2_t)vaddw_u8((uint16x8_t)v190, (uint8x8_t)0x707070707070707);
  v195 = (int8x8x2_t)vaddw_u8((uint16x8_t)v191, (uint8x8_t)0x707070707070707);
  v196 = vmull_u8(*(uint8x8_t *)v100.i8, (uint8x8_t)0x303030303030303);
  v190.i64[0] = v100.i64[0];
  v191.i64[0] = v100.i64[0];
  v197 = vqrshrn_n_u16(v192, 4uLL);
  v194.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v194, 4uLL);
  v195.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v195, 4uLL);
  v198 = vqrshrn_n_u16(v193, 4uLL);
  vst2_s8(_X4, v194);
  vst2_s8(_X5, v195);
  v199 = (int16x8_t)vaddw_u8(v196, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v190, (int64x2_t)v100, 8uLL));
  v200 = (int16x8_t)vaddw_u8(v196, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v191, (int64x2_t)v100, 8uLL));
  _X7 = (char *)(v186 + a3);
  _X9 = (char *)(v187 + a3);
  _X10 = (char *)(v188 + a3);
  _X11 = (char *)(v189 + a3);
  __asm
  {
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  v209 = (int64x2_t)vaddq_s16(v199, vmulq_s16(v184, v122));
  v210 = (int64x2_t)vaddq_s16(v184, vmulq_s16(v199, v122));
  v211 = (uint16x8_t)vaddq_s16(v200, vmulq_s16(v185, v122));
  v212 = (uint16x8_t)vaddq_s16(v185, vmulq_s16(v200, v122));
  v213 = (int8x8x2_t)vaddw_u8((uint16x8_t)v209, (uint8x8_t)0x707070707070707);
  v214 = (int8x8x2_t)vaddw_u8((uint16x8_t)v210, (uint8x8_t)0x707070707070707);
  v215 = vmull_u8(*(uint8x8_t *)v101.i8, (uint8x8_t)0x303030303030303);
  v209.i64[0] = v101.i64[0];
  v210.i64[0] = v101.i64[0];
  v216 = vqrshrn_n_u16(v211, 4uLL);
  v213.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v213, 4uLL);
  v214.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v214, 4uLL);
  v217 = vqrshrn_n_u16(v212, 4uLL);
  vst2_s8(_X6, v213);
  vst2_s8(_X7, v214);
  v218 = (int16x8_t)vaddw_u8(v215, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v209, (int64x2_t)v101, 8uLL));
  v219 = (int16x8_t)vaddw_u8(v215, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v210, (int64x2_t)v101, 8uLL));
  v213.val[0] = (int8x8_t)vqshrn_n_u16(vaddw_u8((uint16x8_t)v218, (uint8x8_t)0x101010101010101), 2uLL);
  v220 = vqrshrn_n_u16((uint16x8_t)v219, 2uLL);
  vst2_s8(_X11, v213);
  v213.val[0] = (int8x8_t)vqshrn_n_u16(vaddw_u8((uint16x8_t)vaddq_s16(v218, vmulq_s16(v199, v122)), (uint8x8_t)0x707070707070707), 4uLL);
  v221 = vqrshrn_n_u16((uint16x8_t)vaddq_s16(v219, vmulq_s16(v200, v122)), 4uLL);
  v214.val[0] = (int8x8_t)vqshrn_n_u16(vaddw_u8((uint16x8_t)vaddq_s16(v199, vmulq_s16(v218, v122)), (uint8x8_t)0x707070707070707), 4uLL);
  v222 = vqrshrn_n_u16((uint16x8_t)vaddq_s16(v200, vmulq_s16(v219, v122)), 4uLL);
  vst2_s8(_X9, v213);
  vst2_s8(_X10, v214);
  return 16;
}

uint64_t aj_mosquito_spray(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  int8x16_t v5;
  uint8x8_t v8;
  uint8x8_t v9;
  uint8x8_t v10;
  uint8x8_t v11;
  uint8x8_t v12;
  uint8x8_t v13;
  uint8x8_t v14;
  uint8x8_t v15;
  uint8x8_t v16;
  uint8x8_t v17;
  uint8x8_t v18;
  unsigned __int8 v19;
  uint8x8_t v20;
  uint8x8_t v21;
  uint8x8_t v22;
  int v23;
  uint8x8_t v24;
  int8x8_t v25;
  int8x8_t v26;
  int8x8_t v27;
  int8x8_t v28;
  int8x8_t v29;
  int8x8_t v30;
  int8x8_t v31;
  int8x8_t v32;
  int8x8_t v33;
  int8x8_t v34;
  int8x8_t v35;
  uint64_t v36;
  int v37;
  __int8 v38;
  __int8 v39;
  unint64_t v40;
  char *v41;
  __int8 v42;
  __int8 v43;
  int8x8_t v44;
  int8x8_t v45;
  int8x8_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t i;
  int v51;
  __int8 v52;
  __int8 v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  __int8 v58;
  __int8 v59;
  __int8 v60;
  __int8 v61;
  __int8 v62;
  __int8 v63;
  __int8 v64;
  __int8 v65;
  __int8 v66;
  __int8 v67;
  uint8x8_t *v68[8];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  int8x16_t v73;
  int16x8_t v74[8];
  int8x8_t v75;
  int8x8_t v76;
  int8x8_t v77;
  int8x8_t v78;
  int8x8_t v79;
  int8x8_t v80;
  int8x8_t v81;
  int8x8_t v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  if (*(uint64_t (**)(int16x8_t *, uint64_t *, uint64_t))(result + 520) == aj_idct_s1)
  {
    v5 = vorrq_s8(*(int8x16_t *)(a2 + 88), *(int8x16_t *)(a2 + 104));
    if (*(_QWORD *)&vorr_s8(*(int8x8_t *)v5.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL)) | *(_QWORD *)(a2 + 40) | *(_QWORD *)(a2 + 56) | *(_QWORD *)(a2 + 72) | *(_QWORD *)(a2 + 120) | *(unsigned int *)(a2 + 12) | *(unsigned __int16 *)(a2 + 54) | (*(_QWORD *)(a2 + 24) >> 16) | *(unsigned int *)(a2 + 68) | (*(_QWORD *)(a2 + 80) >> 16))
    {
      v8 = *(uint8x8_t *)(*a3 + (int)a4);
      v9 = *(uint8x8_t *)(a3[1] + (int)a4);
      *(uint8x8_t *)&v69 = v8;
      *((uint8x8_t *)&v69 + 1) = v9;
      v10 = *(uint8x8_t *)(a3[2] + (int)a4);
      v11 = *(uint8x8_t *)(a3[3] + (int)a4);
      *(uint8x8_t *)&v70 = v10;
      *((uint8x8_t *)&v70 + 1) = v11;
      v12 = *(uint8x8_t *)(a3[4] + (int)a4);
      v13 = *(uint8x8_t *)(a3[5] + (int)a4);
      *(uint8x8_t *)&v71 = v12;
      *((uint8x8_t *)&v71 + 1) = v13;
      v14 = *(uint8x8_t *)(a3[6] + (int)a4);
      v15 = *(uint8x8_t *)(a3[7] + (int)a4);
      *(uint8x8_t *)&v72 = v14;
      *((uint8x8_t *)&v72 + 1) = v15;
      v16 = vmin_u8(vmin_u8(vmin_u8(v8, v9), vmin_u8(v10, v11)), vmin_u8(vmin_u8(v12, v13), vmin_u8(v14, v15)));
      v17 = vpmin_u8(v16, v16);
      v18 = vpmin_u8(v17, v17);
      v19 = vpmin_u8(v18, v18).u8[0];
      v20 = vmax_u8(vmax_u8(vmax_u8(v8, v9), vmax_u8(v10, v11)), vmax_u8(vmax_u8(v12, v13), vmax_u8(v14, v15)));
      v21 = vpmax_u8(v20, v20);
      v22 = vpmax_u8(v21, v21);
      v23 = vpmax_u8(v22, v22).u8[0];
      if (v23 - v19 >= 32)
      {
        v24 = (uint8x8_t)vdup_n_s8((v23 + v19) >> 1);
        v25 = (int8x8_t)vcgt_u8(v8, v24);
        v26 = (int8x8_t)vcgt_u8(v9, v24);
        v27 = (int8x8_t)vcgt_u8(v10, v24);
        v28 = (int8x8_t)vcgt_u8(v11, v24);
        v29 = (int8x8_t)vcgt_u8(v12, v24);
        v30 = (int8x8_t)vcgt_u8(v13, v24);
        v31 = (int8x8_t)vcgt_u8(v14, v24);
        v32 = (int8x8_t)vcgt_u8(v15, v24);
        v33 = vadd_s8(vadd_s8(vadd_s8(veor_s8(v27, v26), veor_s8(v25, v26)), vadd_s8(veor_s8(v27, v28), veor_s8(v29, v28))), vadd_s8(vadd_s8(veor_s8(v29, v30), veor_s8(v31, v30)), veor_s8(v31, v32)));
        v34 = vpadd_s8(v33, v33);
        v35 = vpadd_s8(v34, v34);
        if (vpadd_s8(v35, v35).i8[0] >= -12)
        {
          v36 = result;
          v37 = 0;
          v75 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v25), v25);
          v76 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v26), v26);
          v77 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v27), v27);
          v78 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v28), v28);
          v79 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v29), v29);
          v80 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v30), v30);
          v81 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v31), v31);
          v82 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v32), v32);
          v58 = v75.i8[1];
          v83 = v69;
          v84 = v70;
          v62 = v75.i8[7];
          v63 = v75.i8[6];
          v38 = v75.i8[0];
          v61 = v76.i8[7];
          v39 = v76.i8[0];
          v40 = (unint64_t)&v83 | 9;
          v41 = (char *)&v70 + 1;
          result = 1;
          v85 = v71;
          v86 = v72;
          v42 = v82.i8[0];
          v59 = v81.i8[0];
          v60 = v82.i8[1];
          v43 = v75.i8[0];
          v66 = v82.i8[6];
          v67 = v82.i8[7];
          v44 = v76;
          v45 = v75;
          v64 = v82.i8[0];
          v65 = v81.i8[7];
          do
          {
            v46 = v45;
            v45 = v44;
            v47 = result + 1;
            v48 = 8 * (result + 1);
            v44 = *(int8x8_t *)((char *)&v75 + v48);
            v49 = *(_QWORD *)&v46 | (*(_QWORD *)&v45 >> 8) | (*(_QWORD *)&v45 << 8) | *(_QWORD *)&v45 | *(_QWORD *)&v44;
            if ((v46.i8[0] | v45.i8[1] | v45.i8[0] | v44.i8[0]) != 3)
            {
              *((_BYTE *)&v83 + 8 * result) = (*((unsigned __int8 *)&v69 + 8 * result - 8)
                                             + *((unsigned __int8 *)&v69 + 8 * result)
                                             + *((unsigned __int8 *)&v69 + v48)
                                             + *((unsigned __int8 *)&v69 + ((8 * result) | 1))
                                             + 2) >> 2;
              ++v37;
            }
            for (i = 0; i != 6; ++i)
            {
              v51 = v49;
              if ((v49 & 0xFF00) != 0x300)
              {
                *(_BYTE *)(v40 + i) = (13108
                                     * (v41[i - 16]
                                      + v41[i - 9]
                                      + v41[i - 8]
                                      + v41[i - 7]
                                      + v41[i])
                                     + 26216) >> 16;
                ++v37;
              }
              v49 >>= 8;
            }
            if ((*(_QWORD *)&v51 & 0xFF0000) != 0x30000)
            {
              *((_BYTE *)&v83 + ((8 * result) | 7)) = (*((unsigned __int8 *)&v69 + 8 * result - 1)
                                                     + *((unsigned __int8 *)&v69 + ((8 * result) | 7))
                                                     + *((unsigned __int8 *)&v69 + (v48 | 7))
                                                     + *((unsigned __int8 *)&v69 + ((8 * result) | 6))
                                                     + 2) >> 2;
              ++v37;
            }
            v52 = v75.i8[result];
            if ((v43 | v75.i8[v47] | *((_BYTE *)&v75 + result + 8) | v52) != 3)
            {
              *((_BYTE *)&v83 + result) = (*((unsigned __int8 *)&v69 + result - 1)
                                         + *((unsigned __int8 *)&v69 + result)
                                         + *((unsigned __int8 *)&v69 + v47)
                                         + *((unsigned __int8 *)&v69 + result + 8)
                                         + 2) >> 2;
              ++v37;
            }
            v53 = *((_BYTE *)&v75 + result + 56);
            if ((v42 | *((_BYTE *)&v75 + result + 57) | *((_BYTE *)&v75 + result + 48) | v53) != 3)
            {
              *((_BYTE *)&v83 + result + 56) = (*((unsigned __int8 *)&v69 + result + 55)
                                              + *((unsigned __int8 *)&v69 + result + 56)
                                              + *((unsigned __int8 *)&v69 + result + 57)
                                              + *((unsigned __int8 *)&v69 + result + 48)
                                              + 2) >> 2;
              ++v37;
            }
            v40 += 8;
            v41 += 8;
            v42 = v53;
            v43 = v52;
            ++result;
          }
          while (v47 != 7);
          if ((v58 | v39 | v38) != 3)
          {
            LOBYTE(v83) = (21846 * (v8.u8[0] + v8.u8[1] + v9.u8[0]) + 21846) >> 16;
            ++v37;
          }
          if ((v62 | v63 | v61) != 3)
          {
            BYTE7(v83) = (21846 * (v8.u8[6] + v8.u8[7] + v9.u8[7]) + 21846) >> 16;
            ++v37;
          }
          if ((v60 | v59 | v64) != 3)
          {
            BYTE8(v86) = (21846 * (v15.u8[0] + v15.u8[1] + v14.u8[0]) + 21846) >> 16;
            ++v37;
          }
          if ((v66 | v67 | v65) != 3)
          {
            HIBYTE(v86) = (21846 * (v15.u8[7] + v15.u8[6] + v14.u8[7]) + 21846) >> 16;
            ++v37;
          }
          if (v37 >= 33)
          {
            v68[0] = (uint8x8_t *)&v83;
            v68[1] = (uint8x8_t *)&v83 + 1;
            v68[2] = (uint8x8_t *)&v84;
            v68[3] = (uint8x8_t *)&v84 + 1;
            v68[4] = (uint8x8_t *)&v85;
            v68[5] = (uint8x8_t *)&v85 + 1;
            v68[6] = (uint8x8_t *)&v86;
            v68[7] = (uint8x8_t *)&v86 + 1;
            aj_block_dct(v68, &v73, (int16x8_t *)(v36 + 1300));
            v54 = 0;
            v55 = *(_QWORD *)(v36 + 704);
            do
            {
              v74[0].i16[*(int *)(v55 + 4 * v54)] = (*(_DWORD *)(v36 + 4 * *(int *)(v55 + 4 * v54) + 1044)
                                                                 * v73.i16[v54]
                                                                 + 2048) >> 12;
              ++v54;
            }
            while (v54 != 64);
            v56 = 0;
            v57 = -8;
            do
            {
              v74[v56 / 0x10] = vaddq_s16(vmaxq_s16(vminq_s16(vsubq_s16(v74[v56 / 0x10], *(int16x8_t *)(a2 + v56)), *(int16x8_t *)(v36 + 1440 + v56)), vnegq_s16(*(int16x8_t *)(v36 + 1440 + v56))), *(int16x8_t *)(a2 + v56));
              v57 += 8;
              v56 += 16;
            }
            while (v57 < 0x38);
            v74[0].i16[0] = *(_WORD *)a2;
            return aj_idct_s1(v74, a3, a4);
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_prog_decode_DC_first(_QWORD *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  int v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int *v12;
  int *v13;
  int v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  char v33;

  v6 = a3 + 24;
  v5 = *a3;
  v33 = 0;
  if (v5 >= 1)
  {
    v7 = 0;
    v29 = a1;
    v30 = a2;
    do
    {
      v8 = (int)a3[v7 + 1];
      v9 = *(_QWORD *)&a3[4 * a3[v8 + 5] + 54];
      if (v5 == 1)
      {
        v10 = 1;
LABEL_6:
        v31 = v7;
        v11 = 0;
        v12 = (int *)(a2 + 4 * v8 + 8);
        v13 = (int *)a1 + v8 + 1617;
        while (1)
        {
          v14 = *v13;
          v15 = a3[30];
          if (v15 <= -2)
          {
            v16 = aj_istream_fill_buf((uint64_t)v6, -9);
            if ((_DWORD)v16)
            {
              v27 = v16;
LABEL_34:
              aj_log_error(0, "Unable to read more data");
              return v27;
            }
            v15 = a3[30];
            if (v15 <= -9)
            {
              v27 = 7;
              goto LABEL_34;
            }
          }
          v17 = *v6;
          v18 = *(unsigned __int16 *)(v9 + ((v17 >> 23) & 0x1FE) + 272);
          if (*(_WORD *)(v9 + ((v17 >> 23) & 0x1FE) + 272))
          {
            v19 = v15 + 9;
            if (v15 >= 0)
              v19 = 8;
            if (v19 < v18 >> 8)
              return 7;
            a3[24] = (_DWORD)v17 << SBYTE1(v18);
            a3[30] = v15 - (v18 >> 8);
            v33 = v18;
          }
          else
          {
            v20 = prog_huff_decode_loop(v9, v6, &v33);
            if ((_DWORD)v20)
              return v20;
            LOBYTE(v18) = v33;
          }
          if ((_BYTE)v18)
          {
            v21 = a3[30];
            v22 = v18;
            v23 = v18 - 9;
            if (v21 < v23)
            {
              if (aj_istream_fill_buf((uint64_t)v6, -9))
                return 9;
              v21 = a3[30];
              if (v21 < v23)
                return 9;
            }
            v24 = a3[24];
            a3[24] = v24 << v22;
            a3[30] = v21 - v22;
            if (v24 >= 0)
              v25 = (-1 << v22) + 1;
            else
              v25 = 0;
            v26 = ((v25 + (v24 >> -(char)v22)) << a3[15]) + *v12;
          }
          else
          {
            v26 = *v12;
          }
          *(_WORD *)(a4 + ((uint64_t)(v11 + v14) << 7)) = v26;
          *v12 = (__int16)v26;
          if (v10 == ++v11)
          {
            v5 = *a3;
            a1 = v29;
            a2 = v30;
            v7 = v31;
            goto LABEL_28;
          }
        }
      }
      v10 = *(_DWORD *)(*a1 + 4 * v8 + 32) * *(_DWORD *)(*a1 + 4 * v8 + 16);
      if (v10 >= 1)
        goto LABEL_6;
LABEL_28:
      ++v7;
    }
    while (v7 < v5);
  }
  v27 = 0;
  ++a3[19];
  return v27;
}

uint64_t (*aj_block_dct(uint8x8_t **a1, int8x16_t *a2, int16x8_t *a3))()
{
  uint8x8_t *v3;
  uint8x8_t *v4;
  uint8x8_t *v5;
  uint8x8_t *v6;
  uint8x8_t *v7;
  uint8x8_t *v8;
  uint8x8_t *v9;
  int16x8_t v10;
  uint16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int16x8_t v39;
  int16x8_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int32x4_t v52;
  int32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int64x2_t v56;
  int64x2_t v57;
  int64x2_t v58;
  int64x2_t v59;
  int64x2_t v60;
  int64x2_t v61;
  int64x2_t v62;
  int64x2_t v63;
  int16x8_t v64;
  int16x8_t v65;
  int16x8_t v66;
  int16x8_t v67;
  int16x8_t v68;
  int16x8_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int16x8_t v85;
  int16x8_t v86;
  int16x8_t v87;
  int16x8_t v88;
  int16x8_t v89;
  int16x8_t v90;
  int16x8_t v91;
  int16x8_t v92;
  int16x8_t v93;
  int16x8_t v94;
  int16x8_t v95;
  int16x8_t v96;
  int16x8_t v97;
  int16x8_t v98;
  int16x8_t v99;
  int32x4_t v100;
  int32x4_t v101;
  int32x4_t v102;
  int32x4_t v103;
  int32x4_t v104;
  int32x4_t v105;
  int32x4_t v106;
  int32x4_t v107;
  int64x2_t v108;
  int64x2_t v109;
  int64x2_t v110;
  int64x2_t v111;
  int64x2_t v112;
  int64x2_t v113;
  int64x2_t v114;
  int64x2_t v115;
  int16x8_t v116;
  int16x8_t v117;
  int16x8_t v118;
  int16x8_t v119;
  int16x8_t v120;
  int16x8_t v121;
  int16x8_t v122;
  int16x8_t v123;
  int16x8_t *v124;
  int16x8_t v125;
  int16x8_t v126;
  int16x8_t v127;
  int16x8_t v128;
  int16x8_t v129;
  int16x8_t v130;
  int8x16_t v131;
  int8x16_t *v132;
  uint64_t (*result)();
  int8x16x4_t v134;
  int8x16x4_t v135;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = a1[7];
  v10.i64[0] = 0x80008000800080;
  v10.i64[1] = 0x80008000800080;
  v11 = (uint16x8_t)vnegq_s16(v10);
  v12 = (int16x8_t)vaddw_u8(v11, **a1);
  v13 = (int16x8_t)vaddw_u8(v11, *v3);
  v14 = (int16x8_t)vaddw_u8(v11, *v4);
  v15 = (int16x8_t)vaddw_u8(v11, *v5);
  v16 = (int16x8_t)vaddw_u8(v11, *v6);
  v17 = (int16x8_t)vaddw_u8(v11, *v7);
  v18 = (int16x8_t)vaddw_u8(v11, *v8);
  v19 = (int16x8_t)vaddw_u8(v11, *v9);
  ++*a1;
  a1[1] = v3 + 1;
  a1[2] = v4 + 1;
  a1[3] = v5 + 1;
  a1[4] = v6 + 1;
  a1[5] = v7 + 1;
  a1[6] = v8 + 1;
  a1[7] = v9 + 1;
  v20 = vaddq_s16(v12, v19);
  v21 = vsubq_s16(v12, v19);
  v22 = vaddq_s16(v13, v18);
  v23 = vsubq_s16(v13, v18);
  v24 = vaddq_s16(v14, v17);
  v25 = vsubq_s16(v14, v17);
  v26 = vaddq_s16(v15, v16);
  v27 = vsubq_s16(v22, v24);
  v28 = vaddq_s16(v22, v24);
  v29 = vaddq_s16(vsubq_s16(v15, v16), v25);
  v30 = vaddq_s16(v23, v21);
  v31 = vaddq_s16(v20, v26);
  v32 = vsubq_s16(v20, v26);
  v33 = vqrdmulhq_lane_s16(vsubq_s16(v30, v29), (int16x4_t)0x30FC273D5A824546, 3);
  v34 = vqrdmulhq_lane_s16(vaddq_s16(v25, v23), (int16x4_t)0x30FC273D5A824546, 1);
  v35 = vqrdmulhq_lane_s16(vaddq_s16(v27, v32), (int16x4_t)0x30FC273D5A824546, 1);
  v36 = vsubq_s16(vqrdmulhq_lane_s16(v29, (int16x4_t)0x30FC273D5A824546, 0), v33);
  v37 = vsubq_s16(v31, v28);
  v38 = vaddq_s16(v31, v28);
  v39 = vaddq_s16(vqrdmulhq_lane_s16(v30, (int16x4_t)0x30FC273D5A824546, 2), vsubq_s16(v30, v33));
  v40 = vaddq_s16(v34, v21);
  v41 = vsubq_s16(v21, v34);
  v42 = vaddq_s16(v40, v39);
  v43 = vsubq_s16(v40, v39);
  v44 = vaddq_s16(v36, v41);
  v45 = vsubq_s16(v41, v36);
  v46 = vsubq_s16(v32, v35);
  v47 = vaddq_s16(v35, v32);
  v48 = (int32x4_t)vtrn1q_s16(v38, v42);
  v49 = (int32x4_t)vtrn2q_s16(v38, v42);
  v50 = (int32x4_t)vtrn1q_s16(v47, v45);
  v51 = (int32x4_t)vtrn2q_s16(v47, v45);
  v52 = (int32x4_t)vtrn1q_s16(v37, v44);
  v53 = (int32x4_t)vtrn2q_s16(v37, v44);
  v54 = (int32x4_t)vtrn1q_s16(v46, v43);
  v55 = (int32x4_t)vtrn2q_s16(v46, v43);
  v56 = (int64x2_t)vtrn1q_s32(v48, v50);
  v57 = (int64x2_t)vtrn2q_s32(v48, v50);
  v58 = (int64x2_t)vtrn1q_s32(v49, v51);
  v59 = (int64x2_t)vtrn2q_s32(v49, v51);
  v60 = (int64x2_t)vtrn1q_s32(v52, v54);
  v61 = (int64x2_t)vtrn2q_s32(v52, v54);
  v62 = (int64x2_t)vtrn1q_s32(v53, v55);
  v63 = (int64x2_t)vtrn2q_s32(v53, v55);
  v64 = (int16x8_t)vtrn1q_s64(v56, v60);
  v65 = (int16x8_t)vtrn2q_s64(v56, v60);
  v66 = (int16x8_t)vtrn1q_s64(v58, v62);
  v67 = (int16x8_t)vtrn2q_s64(v58, v62);
  v68 = (int16x8_t)vtrn1q_s64(v57, v61);
  v69 = (int16x8_t)vtrn2q_s64(v57, v61);
  v70 = (int16x8_t)vtrn1q_s64(v59, v63);
  v71 = (int16x8_t)vtrn2q_s64(v59, v63);
  v72 = vaddq_s16(v64, v71);
  v73 = vsubq_s16(v64, v71);
  v74 = vaddq_s16(v66, v69);
  v75 = vsubq_s16(v66, v69);
  v76 = vaddq_s16(v68, v67);
  v77 = vsubq_s16(v68, v67);
  v78 = vaddq_s16(v70, v65);
  v79 = vsubq_s16(v74, v76);
  v80 = vaddq_s16(v74, v76);
  v81 = vaddq_s16(vsubq_s16(v70, v65), v77);
  v82 = vaddq_s16(v75, v73);
  v83 = vaddq_s16(v72, v78);
  v84 = vsubq_s16(v72, v78);
  v85 = vqrdmulhq_lane_s16(vsubq_s16(v82, v81), (int16x4_t)0x30FC273D5A824546, 3);
  v86 = vqrdmulhq_lane_s16(vaddq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  v87 = vqrdmulhq_lane_s16(vaddq_s16(v79, v84), (int16x4_t)0x30FC273D5A824546, 1);
  v88 = vsubq_s16(vqrdmulhq_lane_s16(v81, (int16x4_t)0x30FC273D5A824546, 0), v85);
  v89 = vsubq_s16(v83, v80);
  v90 = vaddq_s16(v83, v80);
  v91 = vaddq_s16(vqrdmulhq_lane_s16(v82, (int16x4_t)0x30FC273D5A824546, 2), vsubq_s16(v82, v85));
  v92 = vaddq_s16(v86, v73);
  v93 = vsubq_s16(v73, v86);
  v94 = vaddq_s16(v92, v91);
  v95 = vsubq_s16(v92, v91);
  v96 = vaddq_s16(v88, v93);
  v97 = vsubq_s16(v93, v88);
  v98 = vsubq_s16(v84, v87);
  v99 = vaddq_s16(v87, v84);
  v100 = (int32x4_t)vtrn1q_s16(v90, v94);
  v101 = (int32x4_t)vtrn2q_s16(v90, v94);
  v102 = (int32x4_t)vtrn1q_s16(v99, v97);
  v103 = (int32x4_t)vtrn2q_s16(v99, v97);
  v104 = (int32x4_t)vtrn1q_s16(v89, v96);
  v105 = (int32x4_t)vtrn2q_s16(v89, v96);
  v106 = (int32x4_t)vtrn1q_s16(v98, v95);
  v107 = (int32x4_t)vtrn2q_s16(v98, v95);
  v108 = (int64x2_t)vtrn1q_s32(v100, v102);
  v109 = (int64x2_t)vtrn2q_s32(v100, v102);
  v110 = (int64x2_t)vtrn1q_s32(v101, v103);
  v111 = (int64x2_t)vtrn2q_s32(v101, v103);
  v112 = (int64x2_t)vtrn1q_s32(v104, v106);
  v113 = (int64x2_t)vtrn2q_s32(v104, v106);
  v114 = (int64x2_t)vtrn1q_s32(v105, v107);
  v115 = (int64x2_t)vtrn2q_s32(v105, v107);
  v116 = (int16x8_t)vtrn1q_s64(v108, v112);
  v117 = (int16x8_t)vtrn2q_s64(v108, v112);
  v118 = (int16x8_t)vtrn1q_s64(v110, v114);
  v119 = (int16x8_t)vtrn2q_s64(v110, v114);
  v120 = (int16x8_t)vtrn1q_s64(v109, v113);
  v121 = (int16x8_t)vtrn2q_s64(v109, v113);
  v122 = (int16x8_t)vtrn1q_s64(v111, v115);
  v123 = (int16x8_t)vtrn2q_s64(v111, v115);
  v125 = *a3;
  v126 = a3[1];
  v124 = a3 + 2;
  v127 = *v124;
  v128 = v124[1];
  v124 += 2;
  v129 = *v124;
  v130 = v124[1];
  v124 += 2;
  v134.val[0] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v116, 1uLL), v125);
  v134.val[1] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v118, 1uLL), v126);
  v134.val[2] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v120, 1uLL), v127);
  v134.val[3] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v122, 1uLL), v128);
  v135.val[0] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v117, 1uLL), v129);
  v135.val[1] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v119, 1uLL), v130);
  v135.val[2] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v121, 1uLL), *v124);
  v135.val[3] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v123, 1uLL), v124[1]);
  v131.i64[1] = -1;
  v109.i64[0] = 0xFFFF0100FFFFFFFFLL;
  v131.i64[0] = -3907647224;
  v109.i64[1] = -1;
  *a2 = vqtbx4q_s8(v134, (int8x16_t)xmmword_2062444C0);
  a2[1] = vqtbx1q_s8(v135.val[0], (int8x16_t)v109);
  v132 = a2 + 2;
  *v132 = vqtbx2q_s8(*(int8x16x2_t *)v134.val[1].i8, v131);
  v132[1] = vqtbx4q_s8(v134, (int8x16_t)xmmword_206244500);
  v132 += 2;
  v130.i64[0] = 0x1F1E0F0E1D1CFFFFLL;
  result = aj_block_dct;
  v131.i64[0] = -4177132284;
  v130.i64[1] = -1;
  *v132 = vqtbx4q_s8(v135, (int8x16_t)xmmword_206244510);
  v132[1] = vqtbx2q_s8(*(int8x16x2_t *)v134.val[1].i8, (int8x16_t)v130);
  v132 += 2;
  *v132 = vqtbx1q_s8(v135.val[3], v131);
  v132[1] = vqtbx3q_s8(*(int8x16x3_t *)v135.val[1].i8, (int8x16_t)xmmword_206244550);
  return result;
}

uint64_t aj_huffman_decode_val_slow(uint64_t a1, unsigned int *a2, int a3, unsigned int a4, int *a5)
{
  uint64_t error_code_eod;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;

  if ((int)a2[6] <= 6)
  {
    error_code_eod = aj_istream_fill_buf((uint64_t)a2, -8);
    if ((_DWORD)error_code_eod)
      return error_code_eod;
  }
  v11 = *a2;
  v12 = *a2 >> 1;
  do
  {
    v13 = a4;
    v14 = *(_DWORD *)(a1 + 4 * a4++ + 272);
  }
  while (v12 >= v14);
  if (a4 != 1)
    v12 -= *(_DWORD *)(a1 + 4 * (a4 - 2) + 272);
  v15 = (v12 >> ~(_BYTE)a4) + *(_DWORD *)(a1 + 4 * v13 + 336);
  if (v15 >= *(unsigned __int16 *)(a1 + 4496))
  {
    aj_log_error((uint64_t)"HuffDec", "Bad huffman code in bitstream");
    return 7;
  }
  v16 = *(unsigned __int8 *)(a1 + v15 + 16);
  v17 = a2[6] - a4;
  a2[6] = v17;
  if (v17 <= -10)
    goto LABEL_9;
  v18 = v11 << a4;
  *a2 = v18;
  v19 = a3 + (v16 >> 4);
  if (v16 == 16)
  {
    if (*(_BYTE *)(a1 + 4498))
    {
      v19 = 0;
      v20 = 0x8000;
      goto LABEL_24;
    }
LABEL_22:
    v20 = 0;
    if (v16 < 0x10)
      v19 = 63;
    goto LABEL_24;
  }
  v21 = v16 & 0xF;
  if ((v16 & 0xF) == 0)
    goto LABEL_22;
  if (v17 < v21 - 9)
  {
    error_code_eod = aj_istream_fill_buf((uint64_t)a2, v21 - 9);
    if ((_DWORD)error_code_eod)
      return error_code_eod;
    v18 = *a2;
    v17 = a2[6];
  }
  *a2 = v18 << v21;
  v17 -= v21;
  a2[6] = v17;
  if (v17 <= -10)
  {
LABEL_9:
    error_code_eod = aj_istream_get_error_code_eod((uint64_t)a2);
    if ((_DWORD)error_code_eod != -2)
      aj_log_error((uint64_t)"HuffDec", "Not enough data in bitstream");
    return error_code_eod;
  }
  v20 = v18 >> -(char)v21;
  if ((v18 & 0x80000000) == 0)
    v20 += (0x7FFFFFFF << v21) | 1;
LABEL_24:
  if ((v17 & 0x80000000) == 0 || (error_code_eod = aj_istream_fill_buf((uint64_t)a2, -9), !(_DWORD)error_code_eod))
  {
    error_code_eod = 0;
    *a5 = v19 | (v20 << 16);
  }
  return error_code_eod;
}

uint64_t prog_huff_decode_loop(uint64_t a1, unsigned int *a2, _BYTE *a3)
{
  int v6;
  int v7;
  int v8;
  uint64_t result;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;

  v6 = *(_DWORD *)(a1 + 784);
  v7 = *(_DWORD *)(a1 + 788);
  v8 = a2[6];
  if (v8 > 6)
    goto LABEL_4;
  result = aj_istream_fill_buf((uint64_t)a2, -9);
  if ((_DWORD)result)
    return result;
  v8 = a2[6];
  if (v8 < 0)
  {
LABEL_16:
    aj_log_error(0, "No huffman code found.");
    return 7;
  }
  else
  {
LABEL_4:
    v10 = *a2;
    if (v8 >= 7)
      v11 = 7;
    else
      v11 = v8;
    v12 = (v11 + 10);
    v13 = 9;
    while (!*(_BYTE *)(v13 + a1 - 1) || v7 > 255)
    {
LABEL_15:
      v6 *= 2;
      if (++v13 == v12)
        goto LABEL_16;
    }
    v14 = 0;
    while ((v10 >> -(char)v13) - v6 != (_DWORD)v14)
    {
      v15 = v14 + 1;
      if ((int)v14 + 1 < *(unsigned __int8 *)(v13 + a1 - 1))
      {
        v16 = v7 + v14++;
        if (v16 <= 254)
          continue;
      }
      v7 += v15;
      v6 += v15;
      goto LABEL_15;
    }
    result = 0;
    *a2 = v10 << v13;
    a2[6] = v8 - v13;
    *a3 = *(_BYTE *)(a1 + v7 + v14 + 16);
  }
  return result;
}

uint64_t aj_istream_state_save(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  uint64_t result;
  int v8;
  int v9;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 24);
  if (v2)
    v4 = v3 == -9;
  else
    v4 = 0;
  if (v4)
    return 1;
  if (v3 <= 15)
  {
    result = secure_fill_buf(a1, -8);
    if ((_DWORD)result)
      return result;
    v2 = *(_QWORD *)(a1 + 16);
    v3 = *(_DWORD *)(a1 + 24);
  }
  result = 0;
  v4 = v2 == 0;
  v8 = *(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 96) - 2;
  if (v4)
    v8 = *(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 96);
  *(_BYTE *)(a2 + 16) = v3 + 9;
  v9 = *(_DWORD *)a1;
  *(_DWORD *)a2 = v8;
  *(_DWORD *)(a2 + 4) = v9;
  *(_BYTE *)(a2 + 17) = 1;
  return result;
}

uint64_t secure_fill_buf(uint64_t a1, int a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  uint64_t v13;

  if (*(int *)(a1 + 32) <= 7)
  {
    result = aj_istream_move_forward(a1);
    if ((_DWORD)result)
      return result;
  }
  v5 = *(_DWORD *)(a1 + 24);
  if (v5 > 15)
    goto LABEL_23;
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = *(_DWORD *)(a1 + 32);
    if (v8 < 1 || *(_QWORD *)(a1 + 16))
      break;
    v9 = *(unsigned __int8 **)(a1 + 8);
    *(_DWORD *)(a1 + 32) = v8 - 1;
    v10 = v9 + 1;
    *(_QWORD *)(a1 + 8) = v9 + 1;
    v11 = *v9;
    if (v11 == 255)
    {
      if (v8 == 1)
      {
        *(_QWORD *)(a1 + 8) = v9;
        *(_DWORD *)(a1 + 32) = 1;
        break;
      }
      v12 = *v10;
      if (v12 == 255)
      {
        if (v8 <= 8)
        {
          result = aj_istream_move_forward(a1);
          if ((_DWORD)result)
            return result;
          v5 = *(_DWORD *)(a1 + 24);
        }
        continue;
      }
      *(_DWORD *)(a1 + 32) = v8 - 2;
      *(_QWORD *)(a1 + 8) = v9 + 2;
      if (v12)
      {
        *(_QWORD *)(a1 + 16) = v10;
        break;
      }
      v11 = 255;
    }
    v7 = v11 | (v7 << 8);
    v6 += 8;
  }
  while (v5 + v6 < 16);
  if (v6 >= 1)
  {
    v5 += v6;
    *(_DWORD *)a1 |= v7 << (23 - v5);
    *(_DWORD *)(a1 + 24) = v5;
  }
  if (v5 < 0)
  {
LABEL_24:
    LODWORD(v13) = 1;
  }
  else
  {
LABEL_23:
    v13 = *(_QWORD *)(a1 + 16);
    if (v13)
      goto LABEL_24;
  }
  *(_DWORD *)(a1 + 28) = v13;
  if (v5 >= a2)
    return 0;
  else
    return aj_istream_get_error_code_eod(a1);
}

uint64_t applejpeg_decode_get_chroma_subsampling(_DWORD *a1)
{
  int v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  if (!a1)
  {
    aj_log_error((uint64_t)"Decode", "Image session is NULL");
    return 0xFFFFFFFFLL;
  }
  if (a1[3232] != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 0xFFFFFFFFLL;
  }
  if (applejpeg_decode_get_image_info((uint64_t)a1, (uint64_t)&v8))
  {
    aj_log_error((uint64_t)"Decode", "get_image_info returned error: %d");
    return 0xFFFFFFFFLL;
  }
  if (!DWORD1(v9))
    return 4;
  v3 = a1[44];
  if (v3 == 2)
  {
    v6 = a1[40];
    if (v6 == 2)
      v7 = 3;
    else
      v7 = -1;
    if (v6 == 1)
      return 2;
    else
      return v7;
  }
  else
  {
    if (v3 != 1)
      return 0xFFFFFFFFLL;
    v4 = a1[40];
    if (v4 == 2)
      v5 = 1;
    else
      v5 = -1;
    if (v4 == 1)
      return 0;
    else
      return v5;
  }
}

uint64_t applejpeg_decode_get_image_info(uint64_t a1, uint64_t a2)
{
  int internal_format;
  uint64_t result;
  int v6;

  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 12928) == 2)
    {
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 3572);
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 152);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 144);
      *(_DWORD *)(a2 + 16) = aj_convert_SOF_type_to_jpeg_type(*(_DWORD *)(a1 + 224));
      internal_format = aj_get_internal_format(*(_DWORD *)(a1 + 144), *(unsigned __int8 *)(a1 + 3552), *(_DWORD *)(a1 + 3556));
      result = 0;
      v6 = *(_DWORD *)(a1 + 3548);
      *(_DWORD *)(a2 + 20) = internal_format;
      *(_DWORD *)(a2 + 24) = v6;
    }
    else
    {
      aj_log_error((uint64_t)"Decode", "Image session not opened");
      return 1;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t aj_get_internal_format(int a1, int a2, int a3)
{
  int v3;
  uint64_t result;

  if (a2)
  {
    v3 = a1 - 1;
    result = 0;
    switch(v3)
    {
      case 0:
        return result;
      case 1:
        result = 6;
        break;
      case 2:
        if (a3)
          result = 1;
        else
          result = 2;
        break;
      case 3:
        if (a3)
          result = 5;
        else
          result = 4;
        break;
      default:
        return 1;
    }
  }
  else if ((a1 - 1) >= 4)
  {
    return 1;
  }
  else
  {
    return dword_20627C5B0[a1 - 1];
  }
  return result;
}

uint64_t aj_convert_SOF_type_to_jpeg_type(int a1)
{
  if (a1 == 194)
    return 1;
  else
    return 2 * (a1 == 195);
}

uint64_t applejpeg_decode_get_output_dimensions(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result;

  if (a1 && a1[3232] == 2)
  {
    result = commit_decode_options_if_needed((uint64_t)a1);
    if (!(_DWORD)result)
    {
      if (a2)
        *a2 = a1[3176];
      result = 0;
      if (a3)
        *a3 = a1[3177];
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 8;
  }
  return result;
}

uint64_t applejpeg_decode_get_output_buffer_size(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  uint64_t result;
  __int128 v9;
  __int128 v10;

  if (a1 && *(_DWORD *)(a1 + 12928) == 2)
  {
    result = commit_decode_options_if_needed(a1);
    if (!(_DWORD)result)
    {
      if (a2)
        *a2 = *(_QWORD *)(a1 + 12816);
      if (a4)
      {
        v9 = *(_OWORD *)(a1 + 12832);
        v10 = *(_OWORD *)(a1 + 12848);
        *(_QWORD *)(a4 + 32) = *(_QWORD *)(a1 + 12864);
        *(_OWORD *)a4 = v9;
        *(_OWORD *)(a4 + 16) = v10;
      }
      result = 0;
      if (a3)
        *a3 = *(_QWORD *)(a1 + 12824);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 8;
  }
  return result;
}

uint64_t applejpeg_decode_image_all(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  NSObject *os_log_object;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;

  if (!a1 || !a2 || !a4)
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  if (a3 - 5 <= 0xFFFFFFFB)
  {
    aj_log_error((uint64_t)"Decode", "nplanes clearly incorrect: %d");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  kdebug_trace();
  v7 = commit_decode_options_if_needed(a1);
  if (!(_DWORD)v7)
  {
    v10 = *(_DWORD *)(a1 + 12864);
    if (a3 != 1 && v10 != a3)
    {
      aj_log_error((uint64_t)"Decode", "The number of allocated planes needs to match the output format or be one: %d");
      return 8;
    }
    v11 = 0;
    v12 = (uint64_t *)(a1 + 12832);
    v13 = a2 + 1;
    do
    {
      if (!*(v13 - 1) || !*v13)
      {
        aj_log_error((uint64_t)"Decode", "Destination pointer or size is NULL/zero for plane ind: %d");
        return 8;
      }
      ++v11;
      v13 += 2;
    }
    while (a3 != v11);
    if (v10 <= (int)a3)
    {
      v17 = 0;
      v18 = (unint64_t *)(a2 + 1);
      while (1)
      {
        v19 = *v18;
        v18 += 2;
        if (v19 < *v12 - v12[5])
          break;
        ++v12;
        if (-(uint64_t)a3 == --v17)
          goto LABEL_33;
      }
      aj_log_error((uint64_t)"Decode", "Destination plane %d is too small for decoded data: %zu vs %zu");
      return 8;
    }
    if (v10 < 1)
    {
      v14 = 0;
    }
    else
    {
      v14 = 0;
      v15 = *(unsigned int *)(a1 + 12864);
      do
      {
        v16 = *v12++;
        v14 += v16;
        --v15;
      }
      while (v15);
    }
    if (a2[1] < (unint64_t)(v14 - *(_QWORD *)(a1 + 8 * v10 + 12864)))
    {
      aj_log_error((uint64_t)"Decode", "Destination buffer is too small for decoded data: %zu vs %zu");
      return 8;
    }
LABEL_33:
    v20 = *(_DWORD *)(a1 + 4100);
    *(_DWORD *)(a4 + 32) = a3;
    v21 = a2;
    v22 = (uint64_t *)a4;
    v23 = a3;
    do
    {
      v24 = *v21;
      v21 += 2;
      *v22++ = v24;
      --v23;
    }
    while (v23);
    aj_init_bitmapinfo(a4 + 40, (_DWORD *)(a1 + 144), a1 + 3584, v20);
    v25 = *(_DWORD *)(a1 + 12996);
    if (!v25)
    {
      log_basic_decode_info(OS_LOG_TYPE_DEBUG, a1, 1, (_DWORD *)(a1 + 3744), a1 + 144, a1 + 3584);
      v25 = *(_DWORD *)(a1 + 12996);
    }
    *(_DWORD *)(a1 + 4108) = v25;
    v26 = perform_decode((uint64_t *)(a1 + 13000), (_QWORD *)(a1 + 13048), a1 + 4192, a1 + 3744, (_DWORD *)(a1 + 11168), a2, a3, a1 + 144, a1 + 3584, a1 + 24);
    v7 = v26;
    if ((_DWORD)v26 != -2)
    {
      if ((_DWORD)v26)
      {
        if ((_DWORD)v26 == -1)
        {
          os_log_object = aj_get_os_log_object();
          if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_ERROR))
            applejpeg_decode_image_all_cold_3(a1, os_log_object, v28);
        }
        else
        {
          v36 = aj_get_os_log_object();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            applejpeg_decode_image_all_cold_1();
        }
        log_basic_decode_info(OS_LOG_TYPE_ERROR, a1, 1, (_DWORD *)(a1 + 3744), a1 + 144, a1 + 3584);
      }
      else
      {
        v29 = aj_get_os_log_object();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
          applejpeg_decode_image_all_cold_2(a1, v29, v30, v31, v32, v33, v34, v35);
      }
    }
    kdebug_trace();
  }
  return v7;
}

uint64_t commit_decode_options_if_needed(uint64_t a1)
{
  _BYTE *v1;
  uint64_t result;
  _DWORD *v4;
  int v5;
  _DWORD *v6;
  unint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  char v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  BOOL v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  char v34;
  char v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  int v42;
  _QWORD *v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  _OWORD v53[4];
  _QWORD v54[2];
  _QWORD v55[2];
  _QWORD v56[4];
  _QWORD v57[6];

  v57[5] = *MEMORY[0x24BDAC8D0];
  v1 = (_BYTE *)(a1 + 12697);
  if (*(_BYTE *)(a1 + 12697))
    return 0;
  v4 = (_DWORD *)(a1 + 144);
  v5 = *(_DWORD *)(a1 + 4100);
  v6 = (_DWORD *)(a1 + 3584);
  memset(v53, 0, sizeof(v53));
  v52 = 0;
  v50 = 0u;
  v51 = 0u;
  result = aj_check_options(a1 + 3584, (int *)(a1 + 144), 0);
  if (!(_DWORD)result)
  {
    aj_init_bitmapinfo(a1 + 12704, v4, (uint64_t)v6, v5);
    v49 = 0;
    result = aj_calculate_dimensions(v6, (uint64_t)v4, (int *)&v49 + 1, (int *)&v49, 0, 0, 0, 0, 0);
    if (!(_DWORD)result)
    {
      result = aj_get_format_description(*(_DWORD *)(a1 + 3592), (uint64_t)&v50);
      if (!(_DWORD)result)
      {
        v8 = *(_DWORD *)(a1 + 3664);
        if (v8 == 270 || v8 == 90)
        {
          v49 = __PAIR64__(v49, HIDWORD(v49));
          *((int32x2_t *)&v51 + 1) = vrev64_s32(*(int32x2_t *)((char *)&v51 + 8));
        }
        v9 = *(_DWORD *)(a1 + 3592);
        if (v9 == 14)
        {
          result = aj_get_texture_size(v4, (uint64_t)v6, (uint64_t)v53, v5, (_QWORD *)(a1 + 12816), a1 + 12832, (_QWORD *)(a1 + 12824));
          goto LABEL_61;
        }
        memset(v57, 0, 32);
        memset(v56, 0, sizeof(v56));
        if ((v9 - 25) < 2)
        {
          v10 = 0;
          v11 = 0;
          v12 = v9 != 25;
          v13 = *(_DWORD *)(a1 + 3824);
          v14 = *(_DWORD *)(a1 + 3816);
          v15 = *(_DWORD *)(a1 + 3828);
          v16 = *(_DWORD *)(a1 + 3820);
          do
          {
            if (v10 * 8)
              v17 = 1;
            else
              v17 = v14;
            v18 = (v13 * (uint64_t)v17) << v12;
            if (v10 * 8)
              v19 = 1;
            else
              v19 = v16;
            v20 = *(_QWORD *)(a1 + 3624 + v10 * 8);
            if (v20)
            {
              v21 = v20 >= v18;
              v7 = v20 - v18;
              if (!v21)
                goto LABEL_48;
              v56[v10] = v7;
            }
            v22 = v18 * v15 * (uint64_t)v19;
            v57[v10] = v22;
            v11 += v22;
            ++v10;
          }
          while (v10 != 3);
LABEL_24:
          v23 = 0;
          goto LABEL_57;
        }
        if (v9 == 7)
        {
          v24 = 2 * ((BYTE4(v49) & 1) + HIDWORD(v49));
          v25 = *(_QWORD *)(a1 + 3624);
          if (v25)
          {
            if ((v25 & 3) != 0 || (v21 = v25 >= v24, v26 = v25 - v24, !v21))
            {
              aj_log_error((uint64_t)"Decode", "The set stride is smaller than the output size or unaligned", v7);
              goto LABEL_53;
            }
            v56[0] = v26;
            v24 = v25;
          }
          v23 = 0;
          v11 = v24 * (int)v49;
        }
        else
        {
          if (DWORD1(v50) == 2)
          {
            v27 = 0;
            v11 = 0;
            v28 = v49;
            v29 = v49 & 1;
            if (HIDWORD(v51) != 2)
              v29 = 0;
            v30 = v29 + (int)v49;
            if (HIDWORD(v51) == 2)
              v28 = ((int)v49 + 1) >> 1;
            v55[0] = v30;
            v55[1] = v28;
            v31 = HIDWORD(v49);
            v32 = BYTE4(v49) & 1;
            if (DWORD2(v51) != 2)
              v32 = 0;
            v33 = v32 + HIDWORD(v49);
            if (DWORD2(v51) == 2)
              v31 = (HIDWORD(v49) + 1) >> 1;
            v54[0] = v33;
            v54[1] = v31;
            v34 = 1;
            while (1)
            {
              v35 = v34;
              v36 = v54[v27] * *((int *)&v50 + v27 + 2);
              v37 = *(_QWORD *)(a1 + 8 * v27 + 3624);
              if (v37)
              {
                v21 = v37 >= v36;
                v38 = v37 - v36;
                if (!v21)
                {
LABEL_48:
                  aj_log_error((uint64_t)"Decode", "Set stride is smaller than required row size", v7);
                  goto LABEL_53;
                }
                v56[v27] = v38;
                v36 = v37;
              }
              v34 = 0;
              v39 = v55[v27] * v36;
              v57[v27] = v39;
              v11 += v39;
              v27 = 1;
              if ((v35 & 1) == 0)
                goto LABEL_24;
            }
          }
          v40 = *(_QWORD *)(a1 + 3624);
          v23 = SDWORD2(v50) * (uint64_t)SHIDWORD(v49);
          if (v40)
          {
            v21 = v40 >= v23;
            v41 = v40 - v23;
            if (!v21)
            {
              aj_log_error((uint64_t)"Decode", "Set stride is smaller than output size", v7);
LABEL_53:
              result = 5;
LABEL_61:
              if (!(_DWORD)result)
              {
                v1[207] = 0;
                *v1 = 1;
              }
              return result;
            }
            v56[0] = v41;
            v23 = v40;
          }
          v11 = v23 * (int)v49;
        }
        v57[0] = v11;
LABEL_57:
        v42 = DWORD1(v50);
        if (SDWORD1(v50) >= 1)
        {
          v43 = (_QWORD *)(a1 + 12872);
          v44 = v56;
          v45 = v57;
          v46 = DWORD1(v50);
          do
          {
            v47 = *v45++;
            *(v43 - 5) = v47;
            v48 = *v44++;
            *v43++ = v48;
            --v46;
          }
          while (v46);
        }
        result = 0;
        *(_DWORD *)(a1 + 12864) = v42;
        *(_QWORD *)(a1 + 12816) = v11;
        *(_QWORD *)(a1 + 12824) = v23;
        goto LABEL_61;
      }
    }
  }
  return result;
}

uint64_t aj_init_bitmapinfo(uint64_t a1, _DWORD *a2, uint64_t a3, int a4)
{
  uint64_t result;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;

  v14 = 0;
  result = aj_calculate_dimensions((_DWORD *)a3, (uint64_t)a2, (int *)&v14 + 1, (int *)&v14, 0, 0, 0, 0, 0);
  if ((_DWORD)result)
    goto LABEL_2;
  v9 = *(_DWORD *)(a3 + 80);
  if (v9 == 270 || v9 == 90)
  {
    v10 = HIDWORD(v14);
    *(_DWORD *)a1 = v14;
    *(_DWORD *)(a1 + 4) = v10;
    v11 = *(_DWORD *)(a3 + 8);
    v12 = v11 - 8;
    if ((v11 - 8) < 6 && ((0x33u >> v12) & 1) != 0)
    {
      *(_DWORD *)(a1 + 8) = dword_20627BAA0[v12];
      goto LABEL_13;
    }
    *(_DWORD *)(a1 + 8) = v11;
  }
  else
  {
    v11 = *(_DWORD *)(a3 + 8);
    v13 = v14;
    *(_DWORD *)a1 = HIDWORD(v14);
    *(_DWORD *)(a1 + 4) = v13;
    *(_DWORD *)(a1 + 8) = v11;
  }
  if (v11 == 14)
  {
    result = aj_get_texture_size(a2, a3, a1 + 16, a4, 0, 0, 0);
    if ((_DWORD)result)
    {
LABEL_2:
      *(_OWORD *)(a1 + 80) = 0u;
      *(_OWORD *)(a1 + 96) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)(a1 + 64) = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)a1 = 0u;
      return result;
    }
  }
LABEL_13:
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a3 + 40);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 48);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a3 + 56);
  return result;
}

uint64_t aj_calculate_dimensions(_DWORD *a1, uint64_t a2, int *a3, int *a4, int *a5, int *a6, _OWORD *a7, int *a8, int *a9)
{
  unsigned int *v16;
  int v17;
  int *v18;
  int v19;
  unsigned int *v20;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  BOOL v41;
  int v42;
  int v43;
  int v44;
  char v45;
  int v46;
  int v47;
  int v49;
  uint64_t result;
  int v52;
  int v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  int v58;
  int v59;
  unsigned int v60;
  __int128 v61;

  v16 = a1 + 5;
  v17 = a1[5];
  v18 = a1 + 3;
  v20 = v16 + 1;
  v19 = v16[1];
  if (v19 == -1 && v17 == -1)
  {
    if (*v18 == -1 && a1[4] == -1)
    {
      v22 = *(_DWORD *)(a2 + 8);
      v23 = *(_DWORD *)(a2 + 12);
      *(_QWORD *)&v61 = 0;
      *((_QWORD *)&v61 + 1) = __PAIR64__(v23, v22);
      v17 = -1;
      goto LABEL_10;
    }
    v17 = -1;
  }
  v61 = *(_OWORD *)v18;
  v22 = v17;
  v23 = v19;
LABEL_10:
  v24 = a1[7];
  if (!v24 || (v25 = a1[8]) == 0)
  {
    v26 = a1[19];
    v24 = v22 / v26;
    v25 = v23 / v26;
LABEL_21:
    if (v26 >= 3)
    {
      if (v26 == 3)
      {
        v28 = 0;
        v26 = 2;
      }
      else if (v26 >= 8)
      {
        if (v26 > 0xF)
        {
          v32 = v24;
          v36 = v25;
LABEL_91:
          if (v32 <= v22 >> 5)
          {
            v49 = 5;
            while (1)
            {
              v28 = v49 - 4;
              if ((v49 - 4) > 9 || v36 > v23 >> v49)
                break;
              if (v32 > v22 >> ++v49)
              {
                v28 = v49 - 4;
                goto LABEL_87;
              }
            }
          }
          else
          {
            v28 = 1;
          }
          goto LABEL_87;
        }
        v28 = 0;
        v26 = 8;
      }
      else
      {
        v28 = 0;
        v26 = 4;
      }
    }
    else
    {
      v28 = 0;
    }
    v32 = v24;
    v36 = v25;
    goto LABEL_103;
  }
  if (v22 >= v24)
  {
    v26 = 1;
    v27 = v22;
    do
    {
      if (v26 > 8 || v23 / v26 < v25)
        break;
      if (v27 == v24 && v23 / v26 == v25)
        goto LABEL_21;
      v26 *= 2;
      v27 = v22 / v26;
    }
    while (v22 / v26 >= v24);
    if (v22 >= v24)
    {
      v26 = 1;
      v29 = v22;
      while (v23 / v26 >= v25)
      {
        if (v29 == v24 && v23 / v26 == v25)
          goto LABEL_21;
        ++v26;
        v29 = v22 / v26;
        if (v22 / v26 < v24)
          break;
      }
    }
  }
  v30 = a1[9];
  if (v30 == 1)
  {
    if (v19 == -1 && v17 == -1 && *v18 == -1 && a1[4] == -1)
    {
      v52 = *(_DWORD *)(a2 + 8);
      v53 = *(_DWORD *)(a2 + 12);
      if ((v52 << 15) / v24 <= (v53 << 15) / v25)
      {
        v58 = v52 * v25;
        v59 = v53 + 2;
        if (v53 >= -1)
          v59 = v53 + 1;
        v60 = v58 + (v59 >> 1);
        v36 = v25;
        v57 = v60 / v53;
      }
      else
      {
        v54 = v53 * v24;
        v55 = v52 + 2;
        if (v52 >= -1)
          v55 = v52 + 1;
        v56 = v54 + (v55 >> 1);
        v57 = v24;
        v36 = v56 / v52;
      }
      if (v57 <= 1)
        v32 = 1;
      else
        v32 = v57;
      if (v36 <= 1)
        v36 = 1;
    }
    else
    {
      if ((v17 << 15) / v24 <= (v19 << 15) / v25)
      {
        v37 = v19 + 2;
        if (v19 >= -1)
          v37 = v19 + 1;
        v38 = v17 * v25 + (v37 >> 1);
        v33 = v25;
        v32 = v38 / v19;
      }
      else
      {
        v31 = v17 + 2;
        if (v17 >= -1)
          v31 = v17 + 1;
        v32 = a1[7];
        v33 = (v24 * v19 + (v31 >> 1)) / v17;
      }
      if (v32 <= 1)
        v32 = 1;
      if (v33 <= 1)
        v36 = 1;
      else
        v36 = v33;
    }
  }
  else
  {
    if (v30 == 3)
    {
      if (v19 == -1 && v17 == -1 && *v18 == -1 && a1[4] == -1)
      {
        v16 = (unsigned int *)(a2 + 8);
        v20 = (unsigned int *)(a2 + 12);
      }
      v34 = *v20;
      v35 = *v16;
      if ((int)(*v16 << 15) / v24 <= (int)(*v20 << 15) / v25)
        v24 = v35 * v25 / v34;
      else
        v25 = v34 * v24 / v35;
      if (v24 <= 1)
        v24 = 1;
      if (v25 <= 1)
        v25 = 1;
    }
    else if (v30 == 2)
    {
      aj_calc_crop(v18, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), v24, v25, &v61);
      v22 = DWORD2(v61);
      v23 = HIDWORD(v61);
    }
    v32 = v24;
    v36 = v25;
  }
  v39 = (v22 << 15) / v32;
  v40 = (v23 << 15) / v36;
  v41 = v39 <= v40;
  if (v39 <= v40)
    v42 = v23;
  else
    v42 = v22;
  if (v41)
    v43 = v36;
  else
    v43 = v32;
  if (v41)
    v44 = v22;
  else
    v44 = v23;
  v45 = -1;
  do
  {
    v46 = v42 >> (v45 + 2);
    v47 = v44 >> (v45 + 2);
    ++v45;
  }
  while (v46 >= v43 && v47 > 0);
  v26 = 1 << v45;
  if (1 << v45 < 9)
  {
    v28 = 0;
    goto LABEL_103;
  }
  if (v22 / v24 > 15 && v23 / v25 >= 16)
    goto LABEL_91;
  v28 = 0;
LABEL_87:
  v26 = 8;
LABEL_103:
  if (v24 < 1 || v25 < 1 || v32 < 1 || v36 < 1 || v32 > v24 || v36 > v25)
  {
    aj_log_error((uint64_t)"DecodeInit", "Out dimensions are invalid, check options", (_QWORD)v61);
    return 5;
  }
  else
  {
    if (a3)
      *a3 = v24;
    if (a4)
      *a4 = v25;
    if (a5)
      *a5 = v32;
    if (a6)
      *a6 = v36;
    if (a7)
      *a7 = v61;
    if (a8)
      *a8 = v26;
    result = 0;
    if (a9)
      *a9 = v28;
  }
  return result;
}

uint64_t aj_get_format_description(int a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  int v5;
  __int128 v6;
  uint64_t v7;
  int v8;

  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = 0x100000003;
  *(_QWORD *)(a2 + 16) = 0;
  *(_OWORD *)(a2 + 24) = xmmword_20627BB20;
  switch(a1)
  {
    case 0:
    case 6:
      result = 0;
      v5 = 3;
      goto LABEL_25;
    case 1:
    case 2:
      goto LABEL_22;
    case 3:
    case 4:
    case 15:
      result = 0;
      v4 = 4;
      goto LABEL_11;
    case 5:
      result = 0;
      v4 = 1;
LABEL_11:
      *(_DWORD *)a2 = v4;
      goto LABEL_13;
    case 7:
      result = 0;
      v4 = 2;
      *(_DWORD *)(a2 + 24) = 2;
      goto LABEL_13;
    case 8:
      goto LABEL_15;
    case 9:
      *(_QWORD *)(a2 + 32) = 0x100000002;
LABEL_15:
      result = 0;
      *(_QWORD *)(a2 + 24) = 0x100000002;
      goto LABEL_27;
    case 10:
      goto LABEL_17;
    case 11:
      *(_QWORD *)(a2 + 32) = 0x100000002;
LABEL_17:
      result = 0;
      v7 = 0x200000002;
      goto LABEL_20;
    case 12:
      goto LABEL_19;
    case 13:
      *(_QWORD *)(a2 + 32) = 0x100000002;
LABEL_19:
      result = 0;
      v7 = 0x200000001;
LABEL_20:
      *(_QWORD *)(a2 + 24) = v7;
      goto LABEL_27;
    case 14:
    case 25:
      result = 0;
      v6 = xmmword_20627BB30;
      goto LABEL_30;
    case 16:
    case 17:
    case 21:
      result = 0;
      *(_DWORD *)a2 = 4;
      v4 = 8;
      goto LABEL_13;
    case 18:
      *(_DWORD *)a2 = 1;
LABEL_22:
      result = 0;
      v5 = 2;
      goto LABEL_25;
    case 19:
      result = 0;
      *(_QWORD *)(a2 + 24) = 0x200000002;
      *(_QWORD *)(a2 + 4) = 0x200000002;
      v8 = 4;
      goto LABEL_28;
    case 20:
      result = 0;
      v5 = 6;
LABEL_25:
      *(_DWORD *)(a2 + 8) = v5;
      break;
    case 22:
    case 23:
      result = 0;
      *(_DWORD *)a2 = 2;
      if (a1 == 22)
        v4 = 2;
      else
        v4 = 4;
LABEL_13:
      *(_DWORD *)(a2 + 8) = v4;
      break;
    case 24:
      result = 0;
      *(_DWORD *)(a2 + 28) = 1;
LABEL_27:
      *(_QWORD *)(a2 + 4) = 0x100000002;
      v8 = 2;
LABEL_28:
      *(_DWORD *)(a2 + 12) = v8;
      break;
    case 26:
      result = 0;
      v6 = xmmword_20627BB40;
LABEL_30:
      *(_OWORD *)(a2 + 4) = v6;
      break;
    default:
      result = 1;
      break;
  }
  return result;
}

uint64_t perform_decode(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t *a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  _OWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t v26;
  unsigned __int8 *v27;
  uint64_t v28;
  int v29;
  _OWORD v31[7];
  uint64_t v32;

  v32 = 0;
  memset(v31, 0, sizeof(v31));
  if ((*(_DWORD *)(a4 + 360) | 2) == 2)
  {
    v18 = (_OWORD *)a10;
    LODWORD(v19) = *(_DWORD *)(a8 + 3420);
    if (*(_BYTE *)(a8 + 84) && *(_QWORD *)(a10 + 80))
    {
      *(_DWORD *)(a4 + 360) = 0;
      v20 = mmap_multiscan(a2, a4 + 368, (uint64_t)v31, a10, a8);
      v19 = v20;
      if ((_DWORD)v20)
      {
        if ((_DWORD)v20 != -2)
        {
LABEL_26:
          dec_free_allocations(a3, *a1, (uint64_t)a1, (uint64_t)a5);
          return v19;
        }
        LODWORD(v19) = 0;
        *(_DWORD *)(a4 + 360) = 2;
      }
      v18 = v31;
    }
    v21 = aj_decode_init((uint64_t)a1, (uint64_t)a2, a3, a4, (uint64_t)a5, (int *)a8, (uint64_t)v18, a9, *a1, a6, a7, 0, v19);
    if ((_DWORD)v21)
    {
LABEL_24:
      v19 = v21;
      goto LABEL_25;
    }
  }
  v22 = aj_decode_all_mt(a3, (uint64_t)a5);
  v19 = v22;
  if (*(_DWORD *)(a4 + 360) == 2)
  {
    v23 = *(_QWORD *)(a4 + 408);
    v24 = *(int *)(a4 + 404) - 1;
    v25 = *(unsigned __int8 **)(v23 + 288 * v24 + 112);
    if (!v25 || *v25 != 217)
    {
      v26 = *(unsigned int *)(v23 + 288 * v24 + 128);
      if ((int)v26 < 2)
        goto LABEL_22;
      v27 = (unsigned __int8 *)(*(_QWORD *)(v23 + 288 * v24 + 104) + 1);
      v28 = v26 - 1;
      while (1)
      {
        if (*(v27 - 1) == 255)
        {
          v29 = *v27;
          if (v29 != 255)
            break;
        }
        ++v27;
        if (!--v28)
          goto LABEL_22;
      }
      if (v29 != 217)
      {
LABEL_22:
        *(_BYTE *)(a4 + 401) = 0;
        v19 = 4294967294;
        handle_error_from_decode(0xFFFFFFFE, (uint64_t)a2, a4, *a1, a5);
        goto LABEL_26;
      }
    }
  }
  if (!(_DWORD)v22)
  {
LABEL_25:
    *(_DWORD *)(a4 + 360) = 0;
    goto LABEL_26;
  }
  if ((_DWORD)v22 != -2)
  {
    v21 = handle_error_from_decode(v22, (uint64_t)a2, a4, *a1, a5);
    goto LABEL_24;
  }
  *(_DWORD *)(a4 + 360) = 1;
  return v19;
}

void log_basic_decode_info(os_log_type_t a1, uint64_t a2, int a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  NSObject *os_log_object;
  _BOOL4 v19;
  int v20;
  int v21;
  int v22;
  const char *v23;
  NSObject *v24;
  os_log_type_t v25;
  uint32_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  NSObject *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint8_t buf[4];
  uint64_t v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  v11 = *(_DWORD *)(a5 + 28) | (16 * *(_DWORD *)(a5 + 44)) | (*(_DWORD *)(a5 + 24) << 8) | (*(_DWORD *)(a5 + 40) << 12) | (*(_DWORD *)(a5 + 20) << 16) | (*(_DWORD *)(a5 + 36) << 20) | (*(_DWORD *)(a5 + 16) << 24) | (*(_DWORD *)(a5 + 32) << 28);
  v12 = (a4[32] << 14) | (a4[34] << 28) | a4[33];
  v13 = *(_DWORD *)(a5 + 3328);
  if (v13 <= 3)
    v14 = 32 * v13;
  else
    v14 = 0;
  v15 = *(_DWORD *)(a5 + 3332);
  if (v15 <= 3)
    v16 = 4 * v15;
  else
    v16 = 0;
  v17 = (*(_DWORD *)a5 << 12) | (*(_DWORD *)(a5 + 3404) << 16) | (*(unsigned __int8 *)(a5 + 84) << 11) | (*(_DWORD *)(a5 + 3408) << 10) | (*(_DWORD *)(a5 + 3412) << 8) | v14 | v16 | (2 * (*(_QWORD *)(a2 + 104) != 0));
  os_log_object = aj_get_os_log_object();
  v19 = os_log_type_enabled(os_log_object, a1);
  if (a3)
  {
    if (!v19)
      goto LABEL_13;
    v20 = *(_DWORD *)(a5 + 80);
    v21 = *(_DWORD *)(a5 + 12) | (*(_DWORD *)(a5 + 8) << 16);
    v22 = *(_DWORD *)(a2 + 76);
    *(_DWORD *)buf = 134219520;
    v50 = a2;
    v51 = 1024;
    v52 = v20;
    v53 = 1024;
    v54 = v21;
    v55 = 1024;
    v56 = v17;
    v57 = 1024;
    v58 = v11;
    v59 = 1024;
    v60 = v12;
    v61 = 1024;
    v62 = v22;
    v23 = "[%p] Decoding: %2X 0x%08X 0x%08X 0x%08X 0x%08X %d";
    v24 = os_log_object;
    v25 = a1;
    v26 = 48;
  }
  else
  {
    if (!v19)
      goto LABEL_13;
    v27 = *(_DWORD *)(a5 + 80);
    v28 = *(_DWORD *)(a5 + 12) | (*(_DWORD *)(a5 + 8) << 16);
    *(_DWORD *)buf = 134219264;
    v50 = a2;
    v51 = 1024;
    v52 = v27;
    v53 = 1024;
    v54 = v28;
    v55 = 1024;
    v56 = v17;
    v57 = 1024;
    v58 = v11;
    v59 = 1024;
    v60 = v12;
    v23 = "[%p] Building: %2X 0x%08X 0x%08X 0x%08X 0x%08X";
    v24 = os_log_object;
    v25 = a1;
    v26 = 42;
  }
  _os_log_impl(&dword_20623C000, v24, v25, v23, buf, v26);
LABEL_13:
  v30 = *(_DWORD *)(a6 + 28);
  v29 = *(_DWORD *)(a6 + 32);
  v48 = a2;
  if (v30)
  {
LABEL_14:
    v47 = v29;
    goto LABEL_17;
  }
  if (!v29)
  {
    v30 = *(_DWORD *)(a6 + 76);
    v29 = -1;
    goto LABEL_14;
  }
  v47 = *(_DWORD *)(a6 + 32);
  v30 = 0;
LABEL_17:
  v32 = *(_DWORD *)a6;
  v31 = *(_DWORD *)(a6 + 4);
  v33 = *(_DWORD *)(a6 + 80);
  v34 = *(_DWORD *)(a6 + 104);
  v35 = *(_DWORD *)(a6 + 108);
  v36 = *(_DWORD *)(a6 + 8);
  v45 = *(unsigned __int16 *)(a6 + 16);
  v46 = *(_DWORD *)(a6 + 12);
  v43 = *(_DWORD *)(a6 + 100);
  v44 = *(_DWORD *)(a6 + 20);
  v37 = *(unsigned __int16 *)(a6 + 24);
  v38 = aj_get_os_log_object();
  if (os_log_type_enabled(v38, a1))
  {
    if (v35 <= 63)
      v39 = v35;
    else
      v39 = 0;
    v40 = (v32 << 19) - 0x80000;
    if (v32 >= 8)
      v40 = 3670016;
    *(_DWORD *)buf = 134219264;
    v50 = v48;
    v41 = v40 | (v36 << 15) | ((v31 != 0) << 14) | ((v33 != 0) << 13) | ((v43 != 0) << 12);
    v42 = v34 << 6;
    v51 = 1024;
    v52 = v30;
    v53 = 1024;
    v54 = v47;
    if (v34 > 63)
      v42 = 0;
    v55 = 1024;
    v56 = v45 | (v46 << 16);
    v57 = 1024;
    v58 = v37 | (v44 << 16);
    v59 = 1024;
    v60 = v41 | v42 | v39;
    _os_log_impl(&dword_20623C000, v38, a1, "[%p] Options: %dx%d [%08X,%08X] %08X", buf, 0x2Au);
  }
}

uint64_t aj_decode_all_mt(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  pthread_t *v6;
  uint64_t v7;
  pthread_t *v8;
  uint64_t v9;
  pthread_t *v10;
  unsigned int v11;
  BOOL v12;
  uint64_t v13;
  pthread_t *v14;
  pthread_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  pthread_t *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t *v23;
  uint64_t v24;
  _DWORD *v25;
  int v26;
  uint64_t v27;
  pthread_t *v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  pthread_t *v35;
  uint64_t v36;
  uint64_t pos;
  uint64_t result;
  unsigned int v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;

  v2 = a2;
  v4 = *(_DWORD *)(a1 + 6948);
  v5 = (v4 - 1);
  if (v4 <= 1)
    return aj_decode_all(a1, a2);
  v41 = *(_DWORD *)(a1 + 6948);
  v6 = *(pthread_t **)(a1 + 6952);
  v7 = (v4 - 1);
  v8 = v6;
  do
  {
    pthread_create(v8 + 193, 0, (void *(__cdecl *)(void *))job, v8);
    v8 += 209;
    --v7;
  }
  while (v7);
  v9 = v5;
  v10 = v6;
  v39 = aj_decode_all(a1, v2);
  v11 = v39;
  do
  {
    pthread_join(v10[193], 0);
    if (v11)
      v12 = 1;
    else
      v12 = *(_DWORD *)v10 == 0;
    if (!v12)
      v11 = *(_DWORD *)v10;
    v10 += 209;
    --v9;
  }
  while (v9);
  v40 = v11;
  v13 = 0;
  v14 = v6 + 144;
  v42 = v5;
  v43 = v2;
  do
  {
    v15 = &v6[209 * v13];
    if (v13)
      v16 = (uint64_t)(v15 - 207);
    else
      v16 = v2;
    if (*((_DWORD *)v15 + 283))
    {
      v17 = *(unsigned int *)(a1 + 6464);
      if ((int)v17 >= 1)
      {
        v18 = 0;
        v19 = (_QWORD *)(v16 + 568);
        v20 = v14;
        do
        {
          v21 = *((unsigned int *)&v6[209 * v13 + 141] + v18 + 1);
          v22 = v19;
          v23 = (uint64_t *)v20;
          if ((int)v21 >= 1)
          {
            do
            {
              v24 = *v23++;
              *v22++ = v24;
              --v21;
            }
            while (v21);
          }
          ++v18;
          v20 += 10;
          v19 += 16;
        }
        while (v18 != v17);
      }
      v25 = (_DWORD *)v15 + 283;
      *(_BYTE *)(v16 + 1082) = 1;
      (**(void (***)(void))(v16 + 1488))();
      *(_DWORD *)(v16 + 104) += *v25;
      *(_BYTE *)(v16 + 1082) = 0;
      v26 = *(_DWORD *)(a1 + 6464);
      if (v26 >= 1)
      {
        v27 = 0;
        v28 = v14;
        do
        {
          v29 = (uint64_t)&v6[209 * v13] + 4 * v27;
          if (*(int *)(v29 + 1132) >= 1)
          {
            v30 = 0;
            v31 = (int *)(v29 + 1132);
            do
              aj_rowbuffer_return_buffer((unsigned int *)&v6[209 * v13 + 21], (unint64_t)v28[v30++]);
            while (v30 < *v31);
            v26 = *(_DWORD *)(a1 + 6464);
          }
          ++v27;
          v28 += 10;
        }
        while (v27 < v26);
      }
    }
    v32 = v42;
    v2 = v43;
    v33 = *(_DWORD *)(v43 + 40);
    if (v33 <= SLODWORD(v6[209 * v13 + 7]))
      v33 = (int)v6[209 * v13 + 7];
    *(_DWORD *)(v43 + 40) = v33;
    ++v13;
    v14 += 209;
  }
  while (v13 != v42);
  v34 = v40;
  if (v40 && !v39)
  {
    v35 = v6;
    while (!*(_DWORD *)v35)
    {
      v35 += 209;
      if (!--v32)
        goto LABEL_39;
    }
    *(_DWORD *)(v43 + 36) = *((_DWORD *)v35 + 13);
  }
LABEL_39:
  v36 = *(_QWORD *)(v43 + 112);
  pos = aj_istream_get_pos((uint64_t)v6[209 * (v41 - 2) + 16]);
  result = aj_istream_move_to_position(v36, pos);
  if (!(_DWORD)result)
    return v34;
  return result;
}

uint64_t aj_decode_all(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, _DWORD *);
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (**v10)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD);
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  int v23;

  if (*(_BYTE *)(*(_QWORD *)a1 + 86))
    return aj_lossless_decode_all((int **)a1, a2);
  if (*(_DWORD *)(a1 + 6612))
  {
    v5 = 1;
    v6 = (uint64_t (*)(uint64_t, uint64_t, _DWORD *))get_row_lpf;
  }
  else
  {
    v5 = *(unsigned int *)(a1 + 172);
    v6 = fill_coeff_buffer;
  }
  v7 = *(unsigned int *)(a2 + 80);
  v8 = *(unsigned int *)(a2 + 84);
  v9 = *(_DWORD *)(a1 + 6848);
  if ((int)v8 + *(_DWORD *)(*(_QWORD *)(a1 + 8) + 80) * (int)v7 >= v9
                                                                    + (*(_DWORD *)(a2 + 28) - 1)
                                                                    * *(_DWORD *)(*(_QWORD *)(a1 + 8) + 80))
  {
LABEL_19:
    if (!*(_DWORD *)a2 || (v16 = move_to_mcu((int **)a1, a2, a2 + 112, *(unsigned int *)(a2 + 12), 0), !(_DWORD)v16))
    {
      v17 = *(_QWORD *)(a1 + 8);
      if ((*(_DWORD *)(v17 + 136) - 1) <= 1)
      {
        *(_DWORD *)(v17 + 136) = 3;
        *(_DWORD *)a2 = 0;
      }
      if (*(_DWORD *)(a2 + 1496))
      {
        v18 = (*(uint64_t (**)(_QWORD))(a2 + 1504))(*(_QWORD *)(a2 + 1512));
        *(_DWORD *)(a2 + 1520) = *(_DWORD *)(a2 + 1496);
        if (v18)
          v16 = 10;
        else
          v16 = 0;
      }
      else
      {
        v16 = 0;
      }
    }
    goto LABEL_42;
  }
  v10 = *(void (***)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD))(a2 + 1488);
  if (*(_DWORD *)(a2 + 1088))
  {
LABEL_8:
    v23 = v7;
    if (*(_DWORD *)(a2 + 64) < *(_DWORD *)(a2 + 60))
    {
      do
      {
        if (*(_DWORD *)(a2 + 1496))
        {
          v11 = *(_DWORD *)(a2 + 1520);
          if (!v11)
          {
            v12 = (*(uint64_t (**)(_QWORD))(a2 + 1504))(*(_QWORD *)(a2 + 1512));
            v11 = *(_DWORD *)(a2 + 1496);
            if (v12)
            {
              *(_DWORD *)(a2 + 1520) = v11 - 1;
              v16 = 10;
              goto LABEL_42;
            }
          }
          *(_DWORD *)(a2 + 1520) = v11 - 1;
        }
        v13 = v6(a1, a2, &v23);
        if ((_DWORD)v13)
        {
          v16 = v13;
          goto LABEL_42;
        }
        if (*(_BYTE *)(a1 + 6945))
        {
          (*v10)(v10, a1, a2, v5, *(unsigned int *)(a2 + 104));
          *(_DWORD *)(a2 + 104) += v5;
          aj_return_rowptrs(a1, a2, (unint64_t *)(a2 + 568));
          if (!*(_DWORD *)(a2 + 1088))
            *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 36);
        }
        v14 = *(_DWORD *)(a2 + 60);
        v15 = *(_DWORD *)(a2 + 64) + 1;
        *(_DWORD *)(a2 + 64) = v15;
      }
      while (v15 < v14);
    }
    v16 = *(unsigned int *)(a2 + 1084);
    if ((_DWORD)v16)
      goto LABEL_42;
    goto LABEL_19;
  }
  v19 = *(unsigned int *)(a2 + 24);
  if ((int)v7 < (int)v19)
  {
    *(_DWORD *)(a2 + 80) = v19;
    v20 = *(unsigned int *)(a1 + 6844);
    v7 = v19;
LABEL_33:
    *(_DWORD *)(a2 + 84) = v20;
    v8 = v20;
    goto LABEL_34;
  }
  v20 = *(unsigned int *)(a1 + 6844);
  if ((int)v8 < (int)v20)
    goto LABEL_33;
  if ((int)v8 >= v9)
  {
    v7 = (v7 + 1);
    *(_DWORD *)(a2 + 80) = v7;
    goto LABEL_33;
  }
LABEL_34:
  v21 = move_to_mcu((int **)a1, a2, a2 + 112, v7, v8);
  v16 = v21;
  if ((_DWORD)v21 == -2
    || !(_DWORD)v21
    || *(_DWORD *)(a2 + 1084)
    || (*(_DWORD *)(a2 + 1084) = v21, v16 = do_error_recovery(a1, a2, *(_DWORD *)(a2 + 84), v21), (_DWORD)v16 != -2))
  {
    if ((_DWORD)v16)
    {
LABEL_42:
      if (*(_BYTE *)(a2 + 560) && (_DWORD)v16 != -2)
        aj_return_rowptrs(a1, a2, (unint64_t *)(a2 + 568));
      if (*(_BYTE *)(*(_QWORD *)(a1 + 8) + 400))
        v22 = (_DWORD)v16 == 0;
      else
        v22 = 0;
      if (v22)
        return aj_handle_partial_progressive_decode(a1);
      return v16;
    }
    LODWORD(v7) = *(_DWORD *)(a2 + 80);
    goto LABEL_8;
  }
  *(_DWORD *)(a2 + 1084) = 0;
  return v16;
}

void aj_return_rowptrs(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  int v4;
  uint64_t i;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  v4 = *(_DWORD *)(a1 + 6464);
  if (v4 >= 1)
  {
    for (i = 0; i < v4; ++i)
    {
      v8 = *(int *)(a1 + 4 * i + 6684);
      v9 = a3;
      if ((_DWORD)v8)
      {
        do
        {
          v10 = *v9++;
          aj_rowbuffer_return_buffer((unsigned int *)(a2 + 152), v10);
          --v8;
        }
        while (v8);
        v4 = *(_DWORD *)(a1 + 6464);
      }
      a3 += 16;
    }
  }
  *(_BYTE *)(a2 + 560) = 0;
}

void aj_rowbuffer_return_buffer(unsigned int *a1, unint64_t a2)
{
  _BYTE *rowbuffer_for_pointer;

  rowbuffer_for_pointer = (_BYTE *)find_rowbuffer_for_pointer(a1, a2);
  if (rowbuffer_for_pointer)
  {
    if (*rowbuffer_for_pointer)
      --*rowbuffer_for_pointer;
    else
      aj_log_error(0, "Releasing a rowbuffer without lock");
  }
  else
  {
    aj_log_error(0, "Releasing a rowbuffer that is not in the list");
  }
}

uint64_t find_rowbuffer_for_pointer(unsigned int *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v2 = *a1;
  if ((int)v2 < 1)
    return 0;
  v3 = 0;
  v4 = a1 + 2;
  do
  {
    v5 = (unint64_t *)&v4[10 * v3];
    v6 = v5[3];
    if (v6 > a2 || v6 + *(_QWORD *)&v4[10 * v3 + 8] <= a2)
    {
      result = 0;
    }
    else
    {
      v7 = *v5;
      v8 = *(_QWORD *)&v4[10 * v3 + 4];
      v9 = 1;
      if (v7 >= 2)
      {
        while (*(_QWORD *)(v8 + 8 * v9) <= a2)
        {
          if (v7 == ++v9)
          {
            v9 = v7;
            break;
          }
        }
      }
      result = *(_QWORD *)(v8 + (((v9 << 32) - 0x100000000) >> 29));
    }
    ++v3;
  }
  while (v3 < v2 && !result);
  return result;
}

uint64_t (***aj_bufferproc_crop(uint64_t (***result)(void), uint64_t a2, uint64_t a3, int a4, int a5))(void)
{
  int v5;
  uint64_t (***v8)(void);
  int v9;
  int v10;
  int v11;
  uint64_t v13;
  _QWORD *v14;
  _BYTE *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  char *v38;
  int *v39;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  _QWORD v43[2];
  _BYTE __src[512];
  uint64_t v45;

  v5 = a4;
  v8 = result;
  v45 = *MEMORY[0x24BDAC8D0];
  v43[0] = 0;
  v43[1] = 0;
  v9 = *(_DWORD *)(a3 + 72);
  v10 = v9 - a5;
  if (v9 <= a5)
    goto LABEL_22;
  if (a5 + a4 <= v9)
    return result;
  v5 = a4 - v10;
  v11 = *(_DWORD *)(a2 + 6464);
  if (v11 >= 2)
  {
    if (*((_DWORD *)result + 11) == 2 && (v10 & 1) != 0)
      *(_BYTE *)(a3 + 1080) = 1;
    goto LABEL_10;
  }
  if (v11 == 1)
  {
LABEL_10:
    v13 = 0;
    v14 = (_QWORD *)(a3 + 568);
    v15 = __src;
    do
    {
      if (v13)
        v16 = aj_highest_set_bit(*((_DWORD *)v8 + 11)) - 1;
      else
        v16 = 0;
      LODWORD(v17) = (v16 + v5) >> v16;
      if (v13)
        v17 = v17;
      else
        v17 = v5;
      *((_DWORD *)v43 + v13) = v17;
      if ((int)v17 >= 1)
      {
        v18 = v10 >> v16;
        v19 = v15;
        v20 = v14;
        do
        {
          *v19++ = *v20;
          *v20 = v20[v18];
          ++v20;
          --v17;
        }
        while (v17);
      }
      ++v13;
      v14 += 16;
      v15 += 128;
    }
    while (v13 < *(int *)(a2 + 6464));
  }
  a5 = v9;
LABEL_22:
  v21 = *(_DWORD *)(a3 + 76);
  if (v5 + a5 > v21)
  {
    v22 = v21 - a5;
    if (!*(_BYTE *)(a3 + 1082))
      v5 = v22;
  }
  v23 = *(unsigned int *)(a2 + 6464);
  if ((int)v23 >= 1)
  {
    v24 = 0;
    v25 = (_QWORD *)(a3 + 568);
    do
    {
      v26 = *(int *)(a2 + 4 * v24 + 6868);
      if ((_DWORD)v26)
        v27 = v5 < 1;
      else
        v27 = 1;
      if (!v27)
      {
        v28 = v5;
        v29 = v25;
        do
        {
          *v29++ += v26;
          --v28;
        }
        while (v28);
      }
      ++v24;
      v25 += 16;
    }
    while (v24 != v23);
    if ((int)v23 > 1 && *((_DWORD *)v8 + 10) == 2 && (*(_BYTE *)(a2 + 6868) & 1) != 0)
      *(_BYTE *)(a3 + 1081) = 1;
  }
  result = (uint64_t (***)(void))(*v8[10])();
  v8[4] = (uint64_t (**)(void))((char *)v8[4] + v5);
  v30 = *(unsigned int *)(a2 + 6464);
  if ((int)v30 < 1)
  {
    if (LODWORD(v43[0]))
      *(_BYTE *)(a3 + 1080) = 0;
  }
  else
  {
    v31 = 0;
    v32 = (_QWORD *)(a3 + 568);
    do
    {
      v33 = *(int *)(a2 + 4 * v31 + 6868);
      if ((_DWORD)v33)
        v34 = v5 < 1;
      else
        v34 = 1;
      if (!v34)
      {
        v35 = -v33;
        v36 = v5;
        v37 = v32;
        do
        {
          *v37++ += v35;
          --v36;
        }
        while (v36);
      }
      ++v31;
      v32 += 16;
    }
    while (v31 != v30);
    if (LODWORD(v43[0]))
    {
      *(_BYTE *)(a3 + 1080) = 0;
      v38 = (char *)(a3 + 568);
      v39 = (int *)v43;
      v40 = __src;
      do
      {
        v42 = *v39++;
        v41 = v42;
        if (v42 >= 1)
          result = (uint64_t (***)(void))memcpy(v38, v40, 8 * v41);
        v40 += 128;
        v38 += 128;
        --v30;
      }
      while (v30);
    }
  }
  return result;
}

void aj_icol_mcurow_default(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD *v8;
  int v9;
  BOOL v10;
  unsigned __int8 **v11;
  unsigned __int8 **v12;
  uint64_t v13;
  int v14;
  char *v16;
  unsigned int v17;
  char *buffer;
  int v19;
  unsigned int v20;
  unint64_t v21;
  _QWORD *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unsigned int v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned __int8 **v31;
  unsigned __int8 **v32;

  if (a4)
  {
    v8 = (_QWORD *)(a3 + 568);
    v9 = **(_DWORD **)a2;
    v10 = v9 == 3;
    if (v9 == 3)
      v11 = (unsigned __int8 **)(a3 + 696);
    else
      v11 = 0;
    v31 = v11;
    if (v10)
      v12 = (unsigned __int8 **)(a3 + 824);
    else
      v12 = 0;
    v32 = v12;
    if (*(_DWORD *)(a2 + 6464) == 3 && !*(_DWORD *)(a2 + 6884))
    {
      if (*(_BYTE *)(a3 + 1080))
      {
        if (*(_DWORD *)(a2 + 6804))
          buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a2 + 6776));
        else
          buffer = (char *)(*(_QWORD *)(a2 + 64) + *(_QWORD *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
        invcol_wrapper(a2, v8, v31++, v32++, (uint64_t)buffer, 0, 1, *(unsigned int *)(a1 + 48), *(_BYTE *)(a3 + 1081));
        v20 = *(_DWORD *)(a2 + 6804);
        if (v20)
        {
          aj_row_translate(v20, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), buffer, *(_QWORD *)(a2 + 64));
          aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)buffer);
        }
        ++*(_DWORD *)(a3 + 36);
        v19 = *(unsigned __int8 *)(a3 + 1080);
      }
      else
      {
        v19 = 0;
      }
      v29 = a4 - 1;
      if (a4 - 1 > v19)
      {
        v30 = (unsigned int *)(a3 + 152);
        v21 = (unint64_t)v19 >> 1;
        v22 = (_QWORD *)(a3 + 8 * v19 + 568);
        do
        {
          if (*(_DWORD *)(a2 + 6804))
          {
            v23 = aj_rowbuffer_get_buffer(v30, *(_QWORD *)(a2 + 6776));
            v24 = aj_rowbuffer_get_buffer(v30, *(_QWORD *)(a2 + 6776));
          }
          else
          {
            v25 = *(_QWORD *)(a2 + 96);
            v23 = (char *)(*(_QWORD *)(a2 + 64) + v25 * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
            v24 = &v23[v25];
          }
          invcol_wrapper(a2, v22, &v31[v21 & 0x7FFFFFFF], &v32[v21 & 0x7FFFFFFF], (uint64_t)v23, (uint64_t)v24, 2, *(unsigned int *)(a1 + 48), *(_BYTE *)(a3 + 1081));
          v26 = *(_DWORD *)(a2 + 6804);
          if (v26)
          {
            aj_row_translate(v26, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v23, *(_QWORD *)(a2 + 64));
            aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v23);
            aj_row_translate(*(_DWORD *)(a2 + 6804), *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v24, *(_QWORD *)(a2 + 64));
            aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v24);
          }
          *(_DWORD *)(a3 + 36) += 2;
          LODWORD(v21) = v21 + 1;
          v22 += 2;
          v19 += 2;
        }
        while ((int)v29 > v19);
      }
      if (v19 == v29)
      {
        if (*(_DWORD *)(a2 + 6804))
          v27 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a2 + 6776));
        else
          v27 = (char *)(*(_QWORD *)(a2 + 64) + *(_QWORD *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
        invcol_wrapper(a2, &v8[v29], &v31[v29 >> 1], &v32[v29 >> 1], (uint64_t)v27, 0, 1, *(unsigned int *)(a1 + 48), *(_BYTE *)(a3 + 1081));
        v28 = *(_DWORD *)(a2 + 6804);
        if (v28)
        {
          aj_row_translate(v28, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v27, *(_QWORD *)(a2 + 64));
          aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v27);
        }
        ++*(_DWORD *)(a3 + 36);
      }
    }
    else if (a4 >= 1)
    {
      v13 = 0;
      v14 = *(int *)(a1 + 44) >> 1;
      do
      {
        if (*(_DWORD *)(a2 + 6804))
          v16 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a2 + 6776));
        else
          v16 = (char *)(*(_QWORD *)(a2 + 64) + *(_QWORD *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
        (*(void (**)(_QWORD *, unsigned __int8 **, unsigned __int8 **, char *, _QWORD, uint64_t, _QWORD))(a2 + 6912))(v8, &v31[v13 >> v14], &v32[v13 >> v14], v16, 0, 1, *(unsigned int *)(a1 + 48));
        v17 = *(_DWORD *)(a2 + 6804);
        if (v17)
        {
          aj_row_translate(v17, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v16, *(_QWORD *)(a2 + 64));
          aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v16);
        }
        ++*(_DWORD *)(a3 + 36);
        ++v13;
        ++v8;
      }
      while (a4 != v13);
    }
  }
}

uint8x8_t **aj_icol_row_444_to_rgba(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, int16x8_t *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64x2_t a9, uint64_t a10, uint64_t a11, unsigned int a12)
{
  uint8x8_t v12;
  int8x16_t v13;
  uint8x8_t *v14;
  uint8x8_t *v15;
  uint8x8_t *v16;
  unsigned int i;
  uint8x8_t v18;
  uint8x8_t v19;
  uint8x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int v29;

  v12 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  v13 = vdupq_n_s8(0xFFu);
  v14 = *result;
  v15 = *a2;
  v16 = *a3;
  for (i = a12 >> 3; i; --i)
  {
    v18 = *v14++;
    v19 = *v15++;
    v20 = *v16++;
    v21 = (int16x8_t)vshll_n_u8(v18, 7uLL);
    v22 = (int16x8_t)vsubl_u8(v19, v12);
    v23 = (int16x8_t)vsubl_u8(v20, v12);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_n_s16(v23, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v21, vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    v24 = (int16x8_t)vzip1q_s8((int8x16_t)a7, (int8x16_t)a8);
    v25 = (int16x8_t)vzip1q_s8((int8x16_t)a9, v13);
    *a4 = vzip1q_s16(v24, v25);
    a4[1] = vzip2q_s16(v24, v25);
    a4 += 2;
  }
  if ((a12 & 7) != 0)
  {
    v26 = (int16x8_t)vshll_n_u8(*v14, 7uLL);
    v27 = (int16x8_t)vsubl_u8(*v15, v12);
    v28 = (int16x8_t)vsubl_u8(*v16, v12);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_n_s16(v28, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v26, vqaddq_s16(vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v28, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    v29 = a12 & 7;
    do
    {
      a4->i8[0] = a7.i8[0];
      a4->i8[1] = a8.i8[0];
      a4->i8[2] = a9.i8[0];
      a4->i8[3] = v13.i8[0];
      a4 = (int16x8_t *)((char *)a4 + 4);
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      a9 = vshrq_n_u64(a9, 8uLL);
      --v29;
    }
    while (v29);
  }
  return result;
}

uint64_t aj_check_options(uint64_t a1, int *a2, int a3)
{
  int v3;
  _BOOL4 v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v11;
  BOOL v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  signed int v19;
  signed int v20;
  signed int v21;
  signed int v22;
  int v23;
  int v24;
  unsigned int *v25;
  int *v26;
  int v27;
  _BOOL4 v28;

  v3 = *(_DWORD *)(a1 + 24);
  v4 = *(_QWORD *)(a1 + 20) != -1 || *(_DWORD *)(a1 + 12) != -1 || *(_DWORD *)(a1 + 16) != -1;
  v5 = *(_DWORD *)(a1 + 80);
  if (v5 > 179)
  {
    if (v5 != 180 && v5 != 270)
      goto LABEL_21;
  }
  else if (v5 && v5 != 90)
  {
LABEL_21:
    aj_log_error((uint64_t)"Parse", "Unsupported rotation. Rotation: %d.");
    return 5;
  }
  v6 = *(_DWORD *)(a1 + 28);
  if (v6 && (v7 = *(_DWORD *)(a1 + 32)) != 0)
  {
    if (v6 >= 0x10000 || v7 >= 0x10000)
    {
      aj_log_error((uint64_t)"Parse", "Output width/height cannot exceed 65535.");
      return 5;
    }
    v8 = *(_DWORD *)(a1 + 8);
    if (v8 == 14)
    {
      aj_log_error((uint64_t)"Parse", "The texture format is only allowed with fixed scales");
      return 5;
    }
    if (v6 < 1 || v7 <= 0)
    {
      aj_log_error((uint64_t)"Parse", "Output size is not set properly.");
      return 5;
    }
    if (!a3 && (v7 > a2[3] << 9 || v6 > a2[2] << 9))
    {
      aj_log_error((uint64_t)"Parse", "Selected output width or height is too large.");
      return 5;
    }
  }
  else
  {
    if ((*(_DWORD *)(a1 + 76) - 65) < 0xFFFFFFC0)
    {
      aj_log_error((uint64_t)"Parse", "Unsupported scale. Scale: %d.");
      return 5;
    }
    v8 = *(_DWORD *)(a1 + 8);
  }
  if (v8 >= 0x1B)
  {
    aj_log_error((uint64_t)"Parse", "Unsupported output format");
    return 5;
  }
  v11 = *a2;
  if (*a2 != 4)
  {
    if (((1 << v8) & 0x4BF0000) != 0)
      goto LABEL_47;
    if (v8 == 15)
    {
      aj_log_error((uint64_t)"Parse", "Can only decode to CMYK if image has 4 components");
      return 3;
    }
LABEL_56:
    v14 = a2[1];
    if (v14 >= 9)
    {
      aj_log_error((uint64_t)"Parse", ">8 bit JPEGs require 16-bit output formats");
      return 3;
    }
    v17 = 0;
    v15 = 1;
    if (*((_BYTE *)a2 + 86))
      goto LABEL_60;
LABEL_68:
    if (v8 - 25 <= 1)
    {
      aj_log_error((uint64_t)"Parse", "Tri-planar formats only supported for lossless JPEG");
      return 3;
    }
    goto LABEL_90;
  }
  v13 = v8 == 21 && *((_BYTE *)a2 + 86) != 0;
  if (v8 != 15 && !v13)
  {
    aj_log_error((uint64_t)"Parse", "Image with 4 components can only be decoded CMYK or lossless RGGB");
    return 3;
  }
  if (v8 - 16 >= 6)
    goto LABEL_56;
LABEL_47:
  v14 = a2[1];
  v15 = v14 < 9;
  if (v14 == 8)
  {
    aj_log_error((uint64_t)"Parse", "16-bit output is only supported for >8 bit JPEGs");
    return 3;
  }
  if (v14 < 9)
  {
    v17 = 0;
    if (*((_BYTE *)a2 + 86))
      goto LABEL_60;
    goto LABEL_68;
  }
  v16 = *(_DWORD *)(a1 + 76);
  if (v16 > 8 || ((1 << v16) & 0x117) == 0)
  {
    aj_log_error((uint64_t)"Parse", "Rescaling beyond DCT scales is not supported for 12-bit JPEGs");
    return 3;
  }
  if (v5 || *(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88))
  {
    aj_log_error((uint64_t)"Parse", "Output transforms are not supported for 12-bit JPEGs");
    return 3;
  }
  v17 = 1;
  if (!*((_BYTE *)a2 + 86))
    goto LABEL_68;
LABEL_60:
  if (v3 != -1
    || *(_DWORD *)(a1 + 20) != -1
    || *(_DWORD *)(a1 + 12) != -1
    || *(_DWORD *)(a1 + 16) != -1
    || v5
    || *(_DWORD *)(a1 + 76) != 1
    || *(_DWORD *)(a1 + 88)
    || *(_DWORD *)(a1 + 84))
  {
    aj_log_error((uint64_t)"Parse", "Cropping, scaling or rotating not supported for lossless JPEG");
    return 3;
  }
  if (v11 == 2)
    goto LABEL_90;
  if (v11 == 1)
  {
    if (v17)
    {
      if (v8 != 18)
      {
        aj_log_error((uint64_t)"Parse", ">8 bit grayscale lossless JPEG can only be decode to 16-bit grayscale");
        return 3;
      }
      if (!v15)
        goto LABEL_103;
LABEL_85:
      aj_log_error((uint64_t)"Parse", "8-bit grayscale lossless JPEG can only be decode to 8-bit grayscale");
      return 3;
    }
    if (v15)
    {
      if (v8 == 5)
        goto LABEL_103;
      goto LABEL_85;
    }
  }
  else
  {
    if (v8 >= 0x19 && v11 != 3)
    {
      aj_log_error((uint64_t)"Parse", "Only three-component JPEGs can be decoded to tri-planar formats");
      return 3;
    }
    if (!(v15 | (v8 < 0x1B) & (0x4330000u >> v8)))
    {
      aj_log_error((uint64_t)"Parse", ">8 bit RGB lossless JPEG can only be decode to 16-bit RGB format");
      return 3;
    }
    if (v14 == 8 && ((v8 < 0x1A) & (0x2000019u >> v8)) == 0)
    {
      aj_log_error((uint64_t)"Parse", "8-bit RGB lossless JPEG can only be decode to 8-bit RGB format");
      return 3;
    }
  }
LABEL_90:
  if (v8 == 14)
  {
    v18 = *(_DWORD *)(a1 + 76);
    if (v18 > 8 || ((1 << v18) & 0x116) == 0)
    {
      aj_log_error((uint64_t)"Parse", "The texture format is only allowed with fixed scales");
      return 3;
    }
    if (v5)
    {
      aj_log_error((uint64_t)"Parse", "The texture format is not compatible with rotation");
      return 3;
    }
    if (*(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88))
    {
      aj_log_error((uint64_t)"Parse", "The texture format is not compatible with flipping");
      return 3;
    }
  }
  else if (v8 == 7 && (v5 || *(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88)))
  {
    aj_log_error((uint64_t)"Parse", "Rotation/Flipping and YUV422_YUYV is not yet supported");
    return 3;
  }
LABEL_103:
  if (v4)
  {
    v19 = *(_DWORD *)(a1 + 12);
    if (v19 < 0 || (v20 = a2[2], v19 >= v20))
    {
      aj_log_error((uint64_t)"Parse", "Cropping-regions x-position is invalid");
      return 5;
    }
    v21 = *(_DWORD *)(a1 + 16);
    if (v21 < 0 || (v22 = a2[3], v21 >= v22))
    {
      aj_log_error((uint64_t)"Parse", "Cropping-regions y-position is invalid");
      return 5;
    }
    v23 = *(_DWORD *)(a1 + 20);
    if (v23 + v19 > v20 || v21 + v3 > v22)
    {
      aj_log_error((uint64_t)"Parse", "Cropping-region exceeds image dimensions [%d,%d+%d,%d] > [%d,%d]");
      return 5;
    }
    if (v3 < 1 || v23 <= 0)
    {
      aj_log_error((uint64_t)"Parse", "Cropping-region is empty");
      return 5;
    }
  }
  if ((*(_DWORD *)a1 & 0x80000000) != 0)
  {
    aj_log_error((uint64_t)"Parse", "Number of threads can't be negative");
    return 5;
  }
  v9 = *(unsigned __int8 *)(a1 + 136);
  if (*(_BYTE *)(a1 + 136))
  {
    v9 = 0;
    if (!*(_DWORD *)(a1 + 140) && v11 >= 1)
    {
      v24 = 0;
      v25 = (unsigned int *)(a2 + 8);
      v9 = *a2;
      v26 = a2 + 8;
      do
      {
        v27 = *v26++;
        v28 = v27 > 1 || (int)*(v25 - 4) > 1;
        v24 |= v28;
        v25 = (unsigned int *)v26;
        --v9;
      }
      while (v9);
      if (v11 != 1 && v24)
      {
        aj_log_error((uint64_t)"Parse", "Unsupported decimation with APP14 transform");
        return 3;
      }
    }
  }
  return v9;
}

uint64_t mmap_multiscan(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  const void *v20;
  size_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  void *v35;
  void *v36;
  int v38;

  v10 = (uint64_t *)(a2 + 16);
  v9 = *(_QWORD *)(a2 + 16);
  if (v9)
  {
    v11 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    v28 = *(_DWORD *)(a4 + 32);
    v29 = *(_DWORD *)(a4 + 52);
    v30 = *(_DWORD *)(a4 + 48) - v28;
    *(_DWORD *)a2 = v30;
    if (v29)
    {
      v31 = v29 - v30;
    }
    else
    {
      v32 = estimate_jpeg_size(*(_DWORD *)(a5 + 8), *(_DWORD *)(a5 + 12));
      if (v32 >= 5242880)
        v31 = 5242880;
      else
        v31 = v32;
      v28 = *(_DWORD *)(a4 + 32);
    }
    if (v31 <= v28)
      v33 = v28;
    else
      v33 = v31;
    v34 = a1[3];
    if (v34)
      (*(void (**)(uint64_t, _QWORD))(*a1 + 8))(v34, *(_QWORD *)(*a1 + 16));
    v35 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))*a1)(v33, *(_QWORD *)(*a1 + 16));
    *v10 = (uint64_t)v35;
    a1[3] = v35;
    if (!v35 || (bzero(v35, v33), (v36 = (void *)a1[3]) == 0))
    {
      aj_log_error((uint64_t)"Decode", "Could not allocate memory for input mapping");
      return 6;
    }
    *(_DWORD *)(a2 + 8) = v33;
    memcpy(v36, *(const void **)(a4 + 8), *(int *)(a4 + 32));
    v11 = *(_DWORD *)(a4 + 32);
    *(_DWORD *)(a2 + 4) = v11;
    v9 = *(_QWORD *)(a2 + 16);
  }
  v12 = *(_DWORD *)(a2 + 8);
  v13 = *(_DWORD *)(a4 + 36);
  v14 = *(_QWORD *)(a4 + 40);
  *(_QWORD *)(a4 + 40) = v9;
  *(_QWORD *)(a4 + 8) = v9 + v11;
  *(_DWORD *)(a4 + 32) = 0;
  *(_DWORD *)(a4 + 36) = v12;
  *(_QWORD *)(a4 + 104) = v9;
  if (*(_DWORD *)(a4 + 56) != 2)
  {
    v38 = v13;
    v17 = 0;
    v18 = v12 - v11;
    while (1)
    {
      if (!v18)
      {
        v19 = 3 * *(int *)(a2 + 8);
        if (HIDWORD(v19))
          return 1;
        v20 = *(const void **)(a2 + 16);
        v21 = v19 >> 1;
        v22 = (char *)(*(uint64_t (**)(unint64_t, _QWORD))*a1)(v19 >> 1, *(_QWORD *)(*a1 + 16));
        if (!v22)
          return 6;
        v23 = v22;
        bzero(v22, v21);
        memcpy(v23, v20, *(int *)(a2 + 4));
        a1[3] = v23;
        *(_QWORD *)(a2 + 16) = v23;
        *(_DWORD *)(a2 + 8) = v21;
        if (v20)
        {
          (*(void (**)(const void *, _QWORD))(*a1 + 8))(v20, *(_QWORD *)(*a1 + 16));
          LODWORD(v21) = *(_DWORD *)(a2 + 8);
          v23 = *(char **)(a2 + 16);
        }
        v17 = 0;
        v24 = *(int *)(a2 + 4);
        v18 = v21 - v24;
        *(_QWORD *)(a4 + 40) = v23;
        *(_QWORD *)(a4 + 8) = &v23[v24];
        *(_DWORD *)(a4 + 32) = 0;
        *(_DWORD *)(a4 + 36) = v21;
        *(_QWORD *)(a4 + 104) = v23;
      }
      v25 = aj_istream_move_forward(a4);
      if ((_DWORD)v25)
      {
        v15 = v25;
        aj_log_error((uint64_t)"Decode", "Could not read file into memory");
        v11 = *(_DWORD *)(a2 + 4);
        v16 = *(_DWORD *)(a4 + 56);
        goto LABEL_37;
      }
      v26 = *(_DWORD *)(a4 + 32);
      v11 = *(_DWORD *)(a2 + 4) + v26 - v17;
      *(_DWORD *)(a2 + 4) = v11;
      v27 = *(_DWORD *)(a4 + 52);
      if (v27 && v27 == *(_DWORD *)a2 + v11)
      {
        v15 = 0;
        v16 = 2;
        *(_DWORD *)(a4 + 56) = 2;
        goto LABEL_37;
      }
      v16 = *(_DWORD *)(a4 + 56);
      if (v16 == 1)
      {
        v15 = 4294967294;
        goto LABEL_37;
      }
      v18 -= v26 - v17;
      v17 = v26;
      if (v16 == 2)
      {
        v15 = 0;
LABEL_37:
        v13 = v38;
        goto LABEL_38;
      }
    }
  }
  v15 = 0;
  v16 = 2;
LABEL_38:
  *(_QWORD *)(a4 + 40) = v14;
  *(_QWORD *)(a4 + 8) = v14;
  *(_DWORD *)(a4 + 32) = 0;
  *(_DWORD *)(a4 + 36) = v13;
  *(_QWORD *)(a4 + 104) = 0;
  *(_QWORD *)(a2 + 24) = v11;
  aj_istream_init_mem(a3, v10, *(_BYTE *)(a4 + 112), v16);
  *(_DWORD *)(a3 + 96) = *(_DWORD *)a2;
  return v15;
}

uint64_t init_prog_scans(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  int *v11;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  unsigned __int8 *v21;
  unsigned int v22;
  unsigned __int8 *v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  uint8x16_t v28;
  uint16x8_t v29;
  uint16x8_t v30;
  int v31;
  BOOL v32;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  size_t v40;
  void *v41;
  _OWORD *v42;
  int *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  char v52;
  __int128 *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t inited;
  uint64_t v67;
  uint64_t v68;
  unsigned __int8 *v69;
  unsigned int *v70;
  int v71;
  unsigned __int8 *v72;
  unsigned __int8 *v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  void *v77;
  int v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  unsigned __int8 *v84;
  _OWORD v85[4];
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a3 + 112);
  memset(v85, 0, sizeof(v85));
  v7 = *a2;
  v8 = a2[1];
  if (*(_BYTE *)(v8 + 401))
  {
    if (a5)
    {
      v9 = *(_DWORD *)(v8 + 404);
      if (v9 >= 1)
      {
        v10 = *(int **)(v8 + 408);
        v11 = &v10[72 * v9];
        do
        {
          v10[70] = scan_is_needed((uint64_t)a2, v10);
          v10 += 72;
        }
        while (v10 < v11);
      }
    }
    else if (*(int *)(v8 + 404) >= 1)
    {
      v34 = *(_QWORD *)(v8 + 408);
      while (1)
      {
        *(_QWORD *)(v34 + 72) = 7;
        *(_DWORD *)(v34 + 80) = 0;
        *(_DWORD *)(v34 + 280) = scan_is_needed((uint64_t)a2, (int *)v34);
        v35 = aj_istream_move_to_position(v34 + 96, 0);
        if ((_DWORD)v35)
          break;
        v34 += 288;
        if (v34 >= *(_QWORD *)(v8 + 408) + 288 * *(int *)(v8 + 404))
          return 0;
      }
      return v35;
    }
    return 0;
  }
  v15 = *(unsigned __int8 **)(v6 + 8);
  v83 = 0;
  v84 = v15;
  v16 = &v15[*(int *)(v6 + 32)];
  v17 = *(_DWORD *)(v7 + 3332) + *(_DWORD *)(v7 + 3328);
  v18 = 1;
  *(_DWORD *)(v8 + 404) = 1;
  v19 = (unint64_t)(v16 - 3);
  if (v15 >= v16 - 3)
    goto LABEL_43;
  v18 = 1;
  while (1)
  {
    if (*v15 != 255 || (v20 = v15[1]) == 0)
    {
      ++v15;
      goto LABEL_11;
    }
    if ((v20 - 208) < 9)
      goto LABEL_16;
    v21 = v15 + 2;
    v22 = __rev16(*((unsigned __int16 *)v15 + 1));
    if (v15[1] > 0xD9u)
    {
      if (v20 == 255)
      {
LABEL_16:
        v84 = ++v15;
        goto LABEL_12;
      }
      if (v20 == 218)
      {
        if (&v21[v22] > v16)
          goto LABEL_41;
        v18 = (v18 + 1);
        *(_DWORD *)(v8 + 404) = v18;
      }
LABEL_33:
      v15 += v22 + 2;
LABEL_11:
      v84 = v15;
      goto LABEL_12;
    }
    if (v20 != 196)
      break;
    v23 = &v21[v22];
    if (v23 > v16)
      goto LABEL_41;
    v84 = v15 + 2;
    v24 = __rev16(*((unsigned __int16 *)v15 + 1));
    if (v24 < 0x13)
    {
      v25 = 0;
    }
    else
    {
      v25 = 0;
      v26 = v24 - 2;
      v27 = v15 + 4;
      do
      {
        v28 = *(uint8x16_t *)(v27 + 1);
        v29 = vmovl_high_u8(v28);
        v30 = vmovl_u8(*(uint8x8_t *)v28.i8);
        v30.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v30.i8, *(uint16x4_t *)v29.i8), (int32x4_t)vaddl_high_u16(v30, v29)));
        ++v25;
        v31 = v26 - 17;
        v27 += v30.u32[0] + 17;
        v32 = __OFSUB__(v31, v30.i32[0]);
        v26 = v31 - v30.i32[0];
      }
      while (v26 < 0 == v32 && v26 > 16);
    }
    v17 += v25;
    v84 = v23;
    v15 = v23;
LABEL_12:
    if ((unint64_t)v15 >= v19)
      goto LABEL_41;
  }
  if (v20 != 217)
    goto LABEL_33;
LABEL_41:
  if ((int)v18 >= 1025)
  {
    aj_log_error((uint64_t)"DecodeInit", "The number of scans exceed the allowed limit, %d > %d", v18, 1024);
    return 7;
  }
LABEL_43:
  v37 = *(_QWORD *)(a1 + 40);
  if (v37)
  {
    (*(void (**)(uint64_t, _QWORD))(a4 + 8))(v37, *(_QWORD *)(a4 + 16));
    v18 = *(unsigned int *)(v8 + 404);
  }
  v38 = (*(_QWORD *(**)(uint64_t __return_ptr, uint64_t, _QWORD))a4)(v18, 288 * (int)v18, *(_QWORD *)(a4 + 16));
  *(_QWORD *)(v8 + 408) = v38;
  *(_QWORD *)(a1 + 40) = v38;
  if (!v38)
    return 6;
  bzero(v38, 288 * *(int *)(v8 + 404));
  if (!*(_QWORD *)(v8 + 408))
    return 6;
  v39 = *(_QWORD *)(a1 + 48);
  if (v39)
    (*(void (**)(uint64_t, _QWORD))(a4 + 8))(v39, *(_QWORD *)(a4 + 16));
  v40 = 792 * v17;
  v41 = (void *)(*(uint64_t (**)(size_t, _QWORD))a4)(v40, *(_QWORD *)(a4 + 16));
  *(_QWORD *)(v8 + 416) = v41;
  *(_QWORD *)(a1 + 48) = v41;
  if (!v41)
    return 6;
  v82 = (unint64_t)v16;
  bzero(v41, v40);
  v42 = *(_OWORD **)(v8 + 416);
  if (!v42)
    return 6;
  v81 = v6;
  v80 = a1;
  v43 = *(int **)(v8 + 408);
  v44 = *(_DWORD *)(v7 + 3336);
  *v43 = v44;
  if (v44 >= 1)
  {
    v45 = 0;
    do
    {
      v46 = *(int *)(v7 + 3340 + 4 * v45);
      v43[v45 + 1] = v46;
      v47 = v7 + 4 * v46;
      v48 = &v43[v46];
      v48[5] = *(_DWORD *)(v47 + 3356);
      v48[9] = *(_DWORD *)(v47 + 3372);
      ++v45;
    }
    while (v45 < *v43);
  }
  v49 = 0;
  *(_OWORD *)(v43 + 13) = *(_OWORD *)(v7 + 3388);
  while (2)
  {
    v50 = 0;
    v51 = 1;
    do
    {
      v52 = v51;
      if (*(_BYTE *)(v7 + 2 * v49 + v50 + 3320))
      {
        *((_QWORD *)&v85[v49] + v50) = v42;
        *v42 = *(_OWORD *)(v7 + 32 * v49 + 16 * v50 + 1144);
        v53 = (__int128 *)(v7 + (v49 << 9) + (v50 << 8) + 1272);
        v54 = v53[7];
        v56 = v53[4];
        v55 = v53[5];
        v42[7] = v53[6];
        v42[8] = v54;
        v42[5] = v56;
        v42[6] = v55;
        v57 = v53[11];
        v59 = v53[8];
        v58 = v53[9];
        v42[11] = v53[10];
        v42[12] = v57;
        v42[9] = v59;
        v42[10] = v58;
        v60 = v53[15];
        v62 = v53[12];
        v61 = v53[13];
        v42[15] = v53[14];
        v42[16] = v60;
        v42[13] = v62;
        v42[14] = v61;
        v63 = *v53;
        v64 = v53[1];
        v65 = v53[3];
        v42[3] = v53[2];
        v42[4] = v65;
        v42[1] = v63;
        v42[2] = v64;
        inited = aj_init_lookup((uint64_t)v42);
        if ((_DWORD)inited)
        {
          v36 = inited;
          aj_log_error((uint64_t)"DecodeInit", "Corrupt huffman table before scan. Error code: %d", inited);
          return v36;
        }
        v42 = (_OWORD *)((char *)v42 + 792);
      }
      v51 = 0;
      v50 = 1;
    }
    while ((v52 & 1) != 0);
    if (++v49 != 4)
      continue;
    break;
  }
  v67 = init_scan(a2, a3, v43, (uint64_t)v85, *(_QWORD *)(v81 + 8), *(_QWORD *)(v81 + 40), *(_DWORD *)(v81 + 36), *(_DWORD *)(v7 + 3404));
  if ((_DWORD)v67)
  {
    v36 = v67;
    aj_log_error((uint64_t)"DecodeInit", "First scan corrupt, cannot decode image. Error code: %d", v67);
    return v36;
  }
  v68 = *(_QWORD *)(v8 + 408);
  v83 = *(_QWORD *)(v8 + 416) + 792 * *(int *)(v7 + 3328) + 792 * *(int *)(v7 + 3332);
  v69 = *(unsigned __int8 **)(v81 + 8);
  v84 = v69;
  if ((unint64_t)v69 < v19)
  {
    v79 = *(_DWORD *)(v7 + 3404);
    v70 = (unsigned int *)(v68 + 288);
    v71 = 1;
    do
    {
      if (*v69 == 255 && v69[1])
      {
        v73 = v69 + 2;
        v74 = __rev16(*((unsigned __int16 *)v69 + 1));
        switch(v69[1])
        {
          case 0xC4u:
            if ((unint64_t)&v73[v74] > v82)
              goto LABEL_87;
            v84 = v69 + 2;
            if (aj_read_dht_prog(&v84, &v83, (uint64_t)v85))
              goto LABEL_96;
            break;
          case 0xC5u:
          case 0xC6u:
          case 0xC7u:
          case 0xC8u:
          case 0xC9u:
          case 0xCAu:
          case 0xCBu:
          case 0xCCu:
          case 0xCDu:
          case 0xCEu:
          case 0xCFu:
          case 0xDBu:
          case 0xDCu:
            goto LABEL_76;
          case 0xD0u:
          case 0xD1u:
          case 0xD2u:
          case 0xD3u:
          case 0xD4u:
          case 0xD5u:
          case 0xD6u:
          case 0xD7u:
          case 0xD8u:
            goto LABEL_74;
          case 0xD9u:
            goto LABEL_87;
          case 0xDAu:
            if ((unint64_t)&v73[v74] > v82)
              goto LABEL_87;
            v84 = v69 + 2;
            if (aj_read_sos_prog((unsigned __int16 **)&v84, v70, (int *)v7)
              || init_scan(a2, a3, (int *)v70, (uint64_t)v85, (uint64_t)v84, *(_QWORD *)(v81 + 40), *(_DWORD *)(v81 + 36), v79))
            {
LABEL_96:
              *(_BYTE *)(v8 + 400) = 1;
              *(_DWORD *)(v8 + 404) = v71;
              goto LABEL_88;
            }
            v70 += 72;
            ++v71;
            break;
          case 0xDDu:
            if ((unint64_t)(v69 + 6) > v82)
              goto LABEL_87;
            if (v74 != 4)
            {
              aj_log_error((uint64_t)"DecodeInit", "Illegal DRI segment length.");
              return 4;
            }
            v79 = __rev16(*((unsigned __int16 *)v69 + 2));
            v84 = v69 + 6;
            break;
          default:
            if (v69[1] == 255)
            {
LABEL_74:
              v84 = v69 + 1;
              break;
            }
LABEL_76:
            v72 = &v69[v74 + 2];
            goto LABEL_69;
        }
      }
      else
      {
        v72 = v69 + 1;
LABEL_69:
        v84 = v72;
      }
      v69 = v84;
    }
    while ((unint64_t)v84 < v19);
  }
LABEL_87:
  *(_BYTE *)(v8 + 400) = 0;
LABEL_88:
  if (*(_DWORD *)(v7 + 32) == 2)
  {
    v75 = (*(_DWORD *)(a2[1] + 80) * *(_DWORD *)(a2[1] + 92)) << 7;
    *(_DWORD *)(v8 + 432) = v75;
    v76 = *(_QWORD *)(v80 + 56);
    if (v76)
    {
      (*(void (**)(uint64_t, _QWORD))(a4 + 8))(v76, *(_QWORD *)(a4 + 16));
      v75 = *(_DWORD *)(v8 + 432);
    }
    v77 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a4)(v75, *(_QWORD *)(a4 + 16));
    *(_QWORD *)(v8 + 424) = v77;
    *(_QWORD *)(v80 + 56) = v77;
    if (!v77)
      return 6;
    bzero(v77, *(int *)(v8 + 432));
    if (!*(_QWORD *)(v8 + 424))
      return 6;
  }
  v36 = 0;
  *(_BYTE *)(v8 + 401) = 1;
  return v36;
}

uint64_t init_scan(uint64_t *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  _BOOL4 v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint8x16_t *v17;
  uint8x16_t *v18;
  uint64_t result;
  char *i8;
  uint64_t v21;
  uint8x16_t *v22;
  _BOOL4 v23;
  int *v24;
  int *v25;
  uint64_t i;
  int *v27;
  int v28;
  void *v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v36 = 0;
  v37 = 0;
  if (*(_BYTE *)(*a1 + 84))
    v12 = *(unsigned __int8 *)(*a1 + 85) != 0;
  else
    v12 = 0;
  v13 = a3[13];
  LODWORD(v14) = *a3;
  if (*a3 >= 1)
  {
    v32 = a6;
    v33 = a5;
    v34 = a7;
    v35 = a2;
    v15 = 1;
    while (1)
    {
      v16 = &a3[a3[v15]];
      if (v12)
      {
        v17 = *(uint8x16_t **)(a4 + 16 * v16[5]);
        if (!v17)
        {
          aj_log_error((uint64_t)"DecodeInit", "Trying to use DC huffman table #%d that is uninitialized");
          return 4;
        }
        v18 = *(uint8x16_t **)(a4 + 16 * v16[9] + 8);
        if (!v18)
        {
          aj_log_error((uint64_t)"DecodeInit", "Trying to use AC huffman table #%d that is uninitialized");
          return 4;
        }
        result = aj_check_single_huffman_table(v17, v17[1].i8, 0, *a1);
        if ((_DWORD)result)
          return result;
        i8 = v18[1].i8;
        v21 = *a1;
        v22 = v18;
        v23 = 1;
      }
      else
      {
        v24 = v16 + 9;
        v25 = v16 + 5;
        if (v13)
          v25 = v24;
        v22 = *(uint8x16_t **)(a4 + 16 * *v25 + 8 * (v13 != 0));
        if (!v22)
        {
          aj_log_error((uint64_t)"DecodeInit", "Trying to use huffman table #%d that is uninitialized");
          return 4;
        }
        i8 = v22[1].i8;
        v21 = *a1;
        v23 = v13 != 0;
      }
      result = aj_check_single_huffman_table(v22, i8, v23, v21);
      if ((_DWORD)result)
        return result;
      ++v15;
      v14 = *a3;
      if (v15 - 1 >= v14)
      {
        a2 = v35;
        a7 = v34;
        a6 = v32;
        a5 = v33;
        break;
      }
    }
  }
  for (i = 0; i != 16; i += 4)
  {
    v27 = &a3[i];
    *((_QWORD *)v27 + 27) = *(_QWORD *)(a4 + i * 4);
    *((_QWORD *)v27 + 28) = *(_QWORD *)(a4 + i * 4 + 8);
  }
  a3[17] = a8;
  v28 = a3[16];
  if (!v28 || v28 == a3[15] + 1)
  {
    if ((int)v14 < 1 || (int)v14 > *(_DWORD *)*a1)
    {
      aj_log_error((uint64_t)"DecodeInit", "Illegal number of components in scan: %d");
      return 4;
    }
    if (v12)
    {
      v29 = aj_baseline_multiscan_decode_scan;
LABEL_27:
      *((_QWORD *)a3 + 11) = v29;
      v36 = a5;
      v37 = a6 - (int)a5 + a7;
      aj_istream_init_mem((uint64_t)(a3 + 24), &v36, *(_BYTE *)(*(_QWORD *)(a2 + 112) + 112), *(_DWORD *)(*(_QWORD *)(a2 + 112) + 56));
      *((_QWORD *)a3 + 9) = 7;
      a3[20] = 0;
      a3[70] = scan_is_needed((uint64_t)a1, a3);
      return aj_istream_move_to_position((uint64_t)(a3 + 24), 0);
    }
    v30 = a3[13];
    if (v30)
    {
      if ((_DWORD)v14 == 1 && (v30 - 64) >= 0xFFFFFFC1)
      {
        v31 = a3[14];
        if (v31 >= v30 && v31 < 64)
        {
          if (v28)
            v29 = aj_prog_decode_AC_refine;
          else
            v29 = aj_prog_decode_AC_first;
          goto LABEL_27;
        }
      }
    }
    else if (!a3[14])
    {
      if (v28)
        v29 = aj_prog_decode_DC_refine;
      else
        v29 = aj_prog_decode_DC_first;
      goto LABEL_27;
    }
  }
  aj_log_error((uint64_t)"DecodeInit", "Faulty scan format");
  return 4;
}

double aj_istream_init_mem(uint64_t a1, uint64_t *a2, char a3, int a4)
{
  double result;
  int v5;
  uint64_t v6;

  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  v5 = *((_DWORD *)a2 + 2);
  v6 = *a2;
  *(_QWORD *)(a1 + 40) = *a2;
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 24) = -9;
  *(_DWORD *)(a1 + 32) = v5;
  *(_DWORD *)(a1 + 36) = v5;
  *(_DWORD *)(a1 + 48) = v5;
  *(_DWORD *)(a1 + 52) = v5;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 56) = a4;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 112) = a3;
  return result;
}

uint64_t scan_is_needed(uint64_t a1, int *a2)
{
  int v3;
  int v4;
  int v5;
  BOOL v6;

  if (*a2 > 1)
    return 1;
  v3 = a2[1];
  v4 = *(_DWORD *)(a1 + 1568 * v3 + 904);
  if (a2[16])
  {
    v5 = a2[13];
    if (v5 >= 1)
    {
      v6 = v4 == 2 && v5 > 0x19;
      if (!v6 && v4 != 8 && (v4 != 4 || v5 <= 4))
        return *a2 != 1 || *(_DWORD *)(a1 + 6464) != 1 || v3 == 0;
      return 0;
    }
  }
  if (v4 == 8 && a2[13] > 0)
    return 0;
  return *a2 != 1 || *(_DWORD *)(a1 + 6464) != 1 || v3 == 0;
}

uint64_t aj_read_sos_prog(unsigned __int16 **a1, unsigned int *a2, int *a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t result;
  unint64_t v8;
  int v9;
  BOOL v10;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int *v21;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;

  v3 = (uint64_t)*a1;
  v4 = __rev16(**a1);
  if (v4 <= 7)
  {
    aj_log_error((uint64_t)"Read", "Illegal length of SOS segment: %d");
    return 4;
  }
  v8 = *(unsigned __int8 *)(v3 + 2);
  *a2 = v8;
  v9 = *a3;
  if ((_DWORD)v8)
    v10 = v9 < (int)v8;
  else
    v10 = 1;
  if (v10)
  {
    aj_log_error((uint64_t)"Read", "Component count is %d, only values between 1 and %d supported.", v8, v9);
    return 3;
  }
  else
  {
    if (v4 != 2 * (_DWORD)v8 + 6)
    {
      aj_log_error((uint64_t)"Read", "Illegal length of SOS segment.");
      return 4;
    }
    v12 = 0;
    v13 = v3 + 3;
    v14 = 1;
    v15 = (unsigned __int8 *)(v3 + 3);
    while (1)
    {
      v17 = *v15++;
      v16 = v17;
      v18 = *a3;
      if ((int)v18 < 1)
      {
LABEL_24:
        aj_log_error((uint64_t)"Read", "Component ID not found among declared components");
        goto LABEL_25;
      }
      v19 = 0;
      while (a3[v19 + 16] != v16)
      {
        if (v18 == ++v19)
          goto LABEL_24;
      }
      a2[v12 + 1] = v19;
      v15 = (unsigned __int8 *)(v13 + 2);
      v20 = *(unsigned __int8 *)(v13 + 1);
      v21 = &a2[v19];
      v21[5] = v20 >> 4;
      v21[9] = v20 & 0xF;
      if (v20 > 0x3F || (v20 & 0xF) >= 4)
        break;
      ++v12;
      v13 += 2;
      v14 = v12 < v8;
      if (v12 == v8)
        goto LABEL_26;
    }
    aj_log_error((uint64_t)"Read", "Corrupt scan, invalid huffman table indices. DC: %d, AC: %d");
LABEL_25:
    if (v14)
      return 4;
LABEL_26:
    v23 = *a2;
    if ((int)v23 >= 2)
    {
      v24 = 0;
      while (1)
      {
        v25 = v24 + 1;
        if (v24 + 1 < v23)
          break;
LABEL_32:
        ++v24;
        if (v25 == (_DWORD)v23 - 1)
          goto LABEL_33;
      }
      v26 = v24;
      while (a2[v24 + 1] != a2[v26 + 2])
      {
        if (v23 - 1 == ++v26)
          goto LABEL_32;
      }
      aj_log_error((uint64_t)"Read", "SOS components IDs are not unique. id[%d] == id[%d] == %d");
      return 4;
    }
LABEL_33:
    v27 = *v15;
    a2[13] = v27;
    v28 = v15[1];
    a2[14] = v28;
    v29 = v15[2];
    v30 = v29 >> 4;
    v31 = v29 & 0xF;
    a2[15] = v31;
    a2[16] = v29 >> 4;
    if (a3[20] == 194)
    {
      if (v27 > v28 || v28 >= 0x40)
      {
        aj_log_error((uint64_t)"Read", "Bad spectral selection. Ss = %d, Se = %d.");
        return 4;
      }
      if (v31 > 0xD || v29 >= 0x10 && v30 != v31 + 1)
      {
        aj_log_error((uint64_t)"Read", "Bad successive approximation. Ah = %d, Al = %d.");
        return 4;
      }
    }
    else
    {
      if (v27 || v28 != 63)
      {
        aj_log_error((uint64_t)"Read", "Bad spectral selection for baseline multiscan image. Ss = %d, Se = %d. Assuming Ss = 0, Se = 63.", v27, v28);
        *(_QWORD *)(a2 + 13) = 0x3F00000000;
        v31 = a2[15];
        v30 = a2[16];
      }
      if (v31 | v30)
        aj_log_error((uint64_t)"Read", "Bad successive approximation for baseline multiscan image. Al = %d, Ah = %d. Assuming Al = 0, Ah = 0.", v31, v30);
    }
    result = 0;
    *a1 = (unsigned __int16 *)(v15 + 3);
  }
  return result;
}

uint64_t aj_read_dht_prog(unsigned __int8 **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  unsigned __int8 *v7;
  signed int v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  uint64_t result;

  v6 = *a2;
  v7 = *a1 + 2;
  v8 = __rev16(*(unsigned __int16 *)*a1) - 2;
  while (1)
  {
    if (v8 < 1)
    {
      result = 0;
      *a1 = v7;
      *a2 = v6;
      return result;
    }
    if (v8 <= 0x10)
    {
      aj_log_error((uint64_t)"Read", "Not enough bytes in header for Huffman table. %d bytes remaining, requires >= 17.");
      return 4;
    }
    v9 = *v7;
    v10 = v9 >> 4;
    if (v9 >= 0x20)
    {
      aj_log_error((uint64_t)"Read", "Huffman table class is %d, only values 0 and 1 are allowed.");
      return 4;
    }
    v11 = v9 & 0xF;
    if (v11 >= 4)
    {
      aj_log_error((uint64_t)"Read", "Huffman table index is %d, only values 0 to 3 are allowed.", v11);
      return 3;
    }
    v12 = 0;
    LODWORD(v13) = 0;
    *(_QWORD *)(a3 + 16 * v11 + 8 * v10) = v6;
    v14 = v7 + 1;
    do
    {
      v15 = v14[v12];
      *(_BYTE *)(v6 + v12) = v15;
      v13 = (v13 + v15);
      ++v12;
    }
    while (v12 != 16);
    v16 = v8 - 17;
    v8 = v8 - 17 - v13;
    if (v16 < (int)v13)
    {
      aj_log_error((uint64_t)"Read", "Too few bytes in Huffman header. %d bytes left, requires %d bytes.");
      return 4;
    }
    if (v13 >= 0x101)
      break;
    memcpy((void *)(v6 + 16), v7 + 17, v13);
    bzero((void *)(v6 + 16 + v13), (256 - v13));
    v7 = &v14[v13 + 16];
    result = aj_init_lookup(v6);
    v6 += 792;
    if ((_DWORD)result)
      return result;
  }
  aj_log_error((uint64_t)"Read", "Too many codes in Huffman table: %d codes.");
  return 4;
}

uint64_t aj_init_lookup(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  char v7;
  __int16 v8;
  unsigned int v9;
  uint64_t v11;

  v1 = 0;
  LODWORD(v2) = 0;
  v3 = 1;
  while (!*(_BYTE *)(a1 + v3 - 1))
  {
LABEL_10:
    v1 *= 2;
    if (++v3 == 9)
    {
      v11 = 0;
      *(_DWORD *)(a1 + 784) = v1;
      *(_DWORD *)(a1 + 788) = v2;
      return v11;
    }
  }
  v4 = 0;
  v5 = ~(-1 << v3);
  v2 = (int)v2;
  v6 = v5 - v1;
  if (v5 < v1)
    v6 = 0;
  v7 = 8 - v3;
  while (v4 != v6)
  {
    v8 = ((_WORD)v3 << 8) | *(unsigned __int8 *)(a1 + v2 + 16);
    v9 = 1;
    do
      *(_WORD *)(a1 + 2 * ((v9 - 1) | (v1 << v7)) + 272) = v8;
    while (!(v9++ >> v7));
    ++v1;
    ++v2;
    if (++v4 >= *(unsigned __int8 *)(a1 + v3 - 1))
      goto LABEL_10;
  }
  aj_log_error((uint64_t)"Read", "Code larger than bitlength: %d >= %d", v1, ~(-1 << v3));
  return 7;
}

uint64_t applejpeg_decode_set_option_outformat(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
    return 8;
  result = 0;
  *(_DWORD *)(a1 + 3592) = a2;
  *(_BYTE *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_mosquito_spray(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
    return 8;
  result = 0;
  *(_DWORD *)(a1 + 3732) = a2;
  *(_BYTE *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_error_fill(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 8;
  result = 0;
  *(_BYTE *)(a1 + 3728) = a2;
  *(_BYTE *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_multithread(uint64_t a1, int a2, int a3)
{
  uint64_t result;

  if (!a1)
    return 8;
  result = 0;
  *(_DWORD *)(a1 + 3584) = a2;
  *(_DWORD *)(a1 + 3588) = a3;
  *(_BYTE *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_get_ra_table_sz(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;
  int v9;
  int v10;

  if ((*(_DWORD *)(a1 + 3880) & 0xFFFFFFFE) != 2 || !*(_QWORD *)(a1 + 3840) || !*(_QWORD *)(a1 + 3848))
    return 0;
  v3 = *(_DWORD *)(a1 + 3860);
  if (v3 < *a3)
    v3 *= (v3 + *a3 - 1) / v3;
  *a3 = v3;
  v4 = *(_DWORD *)(a1 + 3856);
  if (v4 < *a2)
    v4 *= (v4 + *a2 - 1) / v4;
  *a2 = v4;
  v5 = *(_DWORD *)(a1 + 3824);
  v6 = *(_DWORD *)(a1 + 3828);
  v7 = (v4 + v6 - 1) / v4;
  v8 = v5 < 4 || v6 < 4;
  v9 = v7 * ((v5 + *a3 - 1) / *a3);
  if (v8)
    v10 = v9 + 1;
  else
    v10 = v9 + 9;
  return v10 * aj_istream_state_serialized_size() + 52;
}

uint64_t applejpeg_decode_dump_ra_table(uint64_t a1, uint64_t a2, unint64_t a3, int a4, int a5)
{
  int v8;
  int v9;
  uint64_t result;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v16;
  int v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;

  if (!a2 || !a3)
  {
    aj_log_error((uint64_t)"Decode", "Cannot take null input");
    return 8;
  }
  if (a3 >> 31)
  {
    aj_log_error((uint64_t)"Decode", "Table size may not be larger than %d");
    return 5;
  }
  if ((a4 - 0x10000) < 0xFFFF0001 || (a5 - 0x10000) <= 0xFFFF0000)
  {
    aj_log_error((uint64_t)"Decode", "Unsupported sampling interval");
    return 8;
  }
  v8 = *(_DWORD *)(a1 + 3856);
  if (v8 > a4 || (v9 = *(_DWORD *)(a1 + 3860), v9 > a5))
  {
    aj_log_error((uint64_t)"Decode", "Illegal sampling interval. Use recommended intervals.");
    return 5;
  }
  if ((*(_DWORD *)(a1 + 3880) & 0xFFFFFFFE) != 2 || !*(_QWORD *)(a1 + 3840) || !*(_QWORD *)(a1 + 3848))
  {
    aj_log_error((uint64_t)"Decode", "RA-table not created, cannot dump it");
    return 5;
  }
  v12 = *(_DWORD *)(a1 + 3824);
  v13 = ((a5 + v12 - 1) / a5);
  v14 = *(_DWORD *)(a1 + 3828);
  if (v12 < 4 || v14 < 4)
    v16 = 1;
  else
    v16 = 9;
  v27 = ((a4 + v14 - 1) / a4);
  v26 = v16 + v27 * v13;
  if ((int)(v26 * aj_istream_state_serialized_size()) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Supplied table is not large enough");
    return 8;
  }
  v17 = a5 / v9;
  *(_OWORD *)a2 = *(_OWORD *)"APPLEJPGMCUCACHE";
  *(_DWORD *)(a2 + 16) = 4;
  v25 = a4 / v8;
  *(_DWORD *)(a2 + 20) = aj_istream_state_serialized_size() * v26 + 26;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 120) + *(_DWORD *)(a1 + 76);
  *(_DWORD *)(a2 + 32) = v16;
  v18 = (_DWORD *)(a2 + 36);
  v19 = (int)aj_istream_state_serialized_size();
  v20 = a1 + 3888;
  do
  {
    aj_istream_state_serialize((uint64_t)v18, v20);
    v18 = (_DWORD *)((char *)v18 + v19);
    v20 += 24;
    --v16;
  }
  while (v16);
  *v18 = v13;
  v18[1] = v27;
  v18[2] = a5;
  v18[3] = a4;
  if ((int)v27 >= 1)
  {
    v21 = 0;
    v22 = (uint64_t)(v18 + 4);
    v23 = v13;
    do
    {
      if ((int)v13 >= 1)
      {
        v24 = 0;
        do
        {
          aj_istream_state_serialize(v22, *(_QWORD *)(*(_QWORD *)(a1 + 3848) + 8 * v21 * v25) + v24);
          v22 += v19;
          v24 += 20 * v17;
          --v13;
        }
        while (v13);
      }
      ++v21;
      v13 = v23;
    }
    while (v21 != v27);
  }
  result = 0;
  *(_DWORD *)(a2 + 24) = 0;
  return result;
}

uint64_t aj_istream_state_serialize(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = 0;
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  do
  {
    *(_WORD *)(result + 8 + v2) = *(_WORD *)(a2 + 8 + v2);
    v2 += 2;
  }
  while (v2 != 8);
  *(_BYTE *)(result + 16) = *(_BYTE *)(a2 + 16);
  return result;
}

uint64_t aj_istream_state_serialized_size()
{
  return 17;
}

uint64_t applejpeg_decode_set_option_stride(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v3;

  if (!a1)
    return 8;
  for (i = 0; i != 32; i += 8)
    *(_QWORD *)(a1 + 3624 + i) = *(_QWORD *)(a2 + i);
  v3 = 0;
  *(_BYTE *)(a1 + 12697) = 0;
  return v3;
}

uint64_t applejpeg_decode_set_option_buildindex(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4;

  if (!a1)
    return 8;
  *(_DWORD *)(a1 + 3684) = a2;
  if (a4 >= 1)
    *(_DWORD *)(a1 + 3692) = a4;
  if (a3 >= 1)
    *(_DWORD *)(a1 + 3688) = a3;
  v4 = 0;
  *(_BYTE *)(a1 + 12697) = 0;
  return v4;
}

uint64_t applejpeg_decode_set_option_outsize(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4;

  if (!a1)
    return 8;
  if (a4 | a3 | a2)
  {
    if (a2 && a4 | a3)
    {
      aj_log_error((uint64_t)"Decode", "Can not set both output scale and width/height");
    }
    else
    {
      if ((a3 != 0) == (a4 != 0))
      {
        v4 = 0;
        *(_DWORD *)(a1 + 3660) = a2;
        *(_DWORD *)(a1 + 3612) = a3;
        *(_DWORD *)(a1 + 3616) = a4;
        *(_BYTE *)(a1 + 12697) = 0;
        return v4;
      }
      aj_log_error((uint64_t)"Decode", "Can not set only one output dimension");
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Must set either output scale or width/height");
  }
  return 5;
}

double applejpeg_decode_clear_options(uint64_t a1)
{
  double result;

  if (a1)
  {
    *(_QWORD *)(a1 + 3584) = 0x100000001;
    *(_DWORD *)(a1 + 3592) = 0;
    *(_QWORD *)(a1 + 3596) = -1;
    *(_QWORD *)(a1 + 3604) = -1;
    *(_DWORD *)(a1 + 3612) = 0;
    *(_QWORD *)(a1 + 3616) = 0;
    *(_QWORD *)(a1 + 3672) = 0;
    *(_QWORD *)(a1 + 3664) = 0;
    *(_QWORD *)(a1 + 3656) = 0x1FF000000;
    *(_OWORD *)(a1 + 3680) = xmmword_20627C5A0;
    result = 0.0;
    *(_OWORD *)(a1 + 3624) = 0u;
    *(_OWORD *)(a1 + 3640) = 0u;
    *(_DWORD *)(a1 + 3696) = 0;
    *(_DWORD *)(a1 + 3724) = 0;
    *(_QWORD *)(a1 + 3712) = 0;
    *(_QWORD *)(a1 + 3704) = 0;
    *(_BYTE *)(a1 + 3720) = 0;
    *(_BYTE *)(a1 + 3728) = 1;
    *(_BYTE *)(a1 + 12697) = 0;
  }
  return result;
}

uint64_t aj_mosquito_spray_enable(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  aj_init_QT_aanIDCT(aj_mosquito_spray_enable_qt_100, (_DWORD *)(a1 + 1044), 1, *(int **)(a1 + 704));
  result = aj_dct_prescale_qtable((uint64_t)aj_mosquito_spray_enable_qt_100, a1 + 1300);
  v3 = 0;
  v4 = *(_QWORD *)(a1 + 704);
  do
  {
    *(_WORD *)(a1 + 2 * *(int *)(v4 + v3) + 1440) = ((*(_DWORD *)(a1 + 48 + v3) + 2048) >> 12) / 2;
    v3 += 4;
  }
  while (v3 != 256);
  *(_BYTE *)(a1 + 1040) = 1;
  return result;
}

uint64_t aj_bufferproc_crop_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int128 v7;
  __int128 v8;
  int v9;
  int v10;
  int v11;
  int v12;
  __int128 v13;
  int v14;
  __int128 v15;

  v7 = *(_OWORD *)(a1 + 40);
  v8 = *(_OWORD *)(a1 + 56);
  *(_QWORD *)(a5 + 32) = *(_QWORD *)(a1 + 72);
  *(_OWORD *)a5 = v7;
  *(_OWORD *)(a5 + 16) = v8;
  v10 = *(_DWORD *)(a3 + 72);
  v9 = *(_DWORD *)(a3 + 76);
  v11 = *(_DWORD *)(a2 + 6616);
  v12 = aj_highest_set_bit(*(_DWORD *)(a1 + 44));
  LODWORD(v13) = v9 - v10;
  DWORD1(v13) = (v12 - 1 + v9 - v10) >> (v12 - 1);
  DWORD2(v13) = DWORD1(v13);
  HIDWORD(v13) = DWORD1(v13);
  *(_OWORD *)(a5 + 24) = v13;
  v14 = aj_highest_set_bit(*(_DWORD *)(a1 + 40));
  LODWORD(v15) = v11;
  DWORD1(v15) = (v14 - 1 + v11) >> (v14 - 1);
  DWORD2(v15) = DWORD1(v15);
  HIDWORD(v15) = DWORD1(v15);
  *(_OWORD *)(a5 + 8) = v15;
  *(_QWORD *)(a1 + 32) = 0;
  return 0;
}

uint64_t aj_decode_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10, int a11, char a12, unsigned int a13)
{
  uint64_t v18;
  _BOOL4 v19;
  int v20;
  _DWORD *v21;
  int v22;
  unsigned int v23;
  _DWORD *v24;
  uint64_t result;
  uint64_t i;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  uint64_t (*v36)(int16x8_t *, uint64_t *, uint64_t);
  uint64_t *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  _DWORD *v42;
  int v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  _DWORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v68;
  size_t v69;
  _DWORD *v70;
  int v71;
  int v72;
  _BOOL4 v74;
  _BOOL4 v75;
  int v76;
  int v77;
  int v78;
  int v79;
  uint64_t (*v80)(int16x8_t *, uint64_t *, uint64_t);
  void *v81;
  uint64_t (*v82)(_DWORD *, _QWORD *, int);
  uint64_t (*v83)(int16x8_t *, uint64_t *, uint64_t);
  uint64_t (*v84)(int *, uint64_t *, int);
  uint64_t (*v85)(int32x4_t *, _QWORD *, int);
  void *v86;
  uint64_t (*v87)(int16x8_t *, uint64_t *, uint64_t);
  void *v88;
  void *v89;
  uint64_t (*v90)(__int16 *, _QWORD *, int);
  int v91;
  int v92;
  int v93;
  uint64_t (*v94)(__int16 *, _QWORD *, int);
  uint64_t v95;
  int v96;
  int v97;
  uint64_t (*v98)(__int16 *, _QWORD *, int);
  uint64_t v99;
  uint64_t v100;
  _QWORD *v101;
  int *v102;
  uint64_t (*v103)(__int16 *, _QWORD *, int);
  int v108;
  int v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v115;
  uint64_t v116;
  unsigned __int8 v117;
  uint64_t (*v118)(int16x8_t *, uint64_t *, uint64_t);
  uint64_t (*v119)(int16x8_t *, uint64_t *, uint64_t);
  uint64_t (*v120)(int16x8_t *, uint64_t *, uint64_t);
  uint64_t (*v121)(int16x8_t *, uint64_t *, uint64_t);
  void *v122;
  void *v123;
  void *v124;
  uint64_t (*v125)(int16x8_t *, uint64_t *, uint64_t);
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  void *v130;
  uint64_t (*v131)(__int16 *, _QWORD *, int);
  void *v132;
  void *v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;

  v115 = a1;
  v116 = a2;
  v136 = *MEMORY[0x24BDAC8D0];
  v18 = a3 + 6888;
  v117 = 0;
  reset_decode_job(a5);
  bzero((void *)a3, 0x1B40uLL);
  *(_BYTE *)(a3 + 17) = a12;
  v19 = 1;
  *(_BYTE *)(a3 + 16) = 1;
  *(_QWORD *)a3 = a6;
  *(_QWORD *)(a3 + 8) = a4;
  if (*(_DWORD *)(a8 + 24) == -1 && *(_DWORD *)(a8 + 20) == -1 && *(_DWORD *)(a8 + 12) == -1)
    v19 = *(_DWORD *)(a8 + 16) != -1;
  *(_QWORD *)(v18 + 4) = 0x100000001;
  *(_BYTE *)(v18 + 16) = *(_BYTE *)(a8 + 152);
  if (a6[852])
  {
    *(_BYTE *)(v18 + 49) = 1;
    v20 = *(unsigned __int8 *)(a8 + 136);
  }
  else
  {
    v20 = *(unsigned __int8 *)(a8 + 136);
    *(_BYTE *)(v18 + 49) = *(_BYTE *)(a8 + 136) != 0;
    if (!v20)
      goto LABEL_12;
  }
  if (v20)
    v21 = (_DWORD *)(a8 + 140);
  else
    v21 = a6 + 853;
  *(_DWORD *)(a3 + 6940) = *v21;
LABEL_12:
  *(_BYTE *)(v18 + 56) = *(_BYTE *)(a8 + 144);
  v22 = *(_DWORD *)(a8 + 80);
  *(_DWORD *)(a3 + 6808) = v22;
  v23 = *(_DWORD *)(a3 + 6804) & 0xFFFFFFFC | (v22 / 90);
  *(_DWORD *)(a3 + 6804) = v23;
  if (*(_DWORD *)(a8 + 84))
  {
    v23 |= 4u;
    *(_DWORD *)(a3 + 6804) = v23;
  }
  if (*(_DWORD *)(a8 + 88))
    *(_DWORD *)(a3 + 6804) = v23 | 8;
  *(_DWORD *)(a3 + 6608) = *(_DWORD *)(a8 + 72);
  v24 = (_DWORD *)(a3 + 168);
  result = aj_calculate_dimensions((_DWORD *)a8, (uint64_t)a6, (int *)(a3 + 6484), (int *)(a3 + 6488), (int *)(a3 + 6500), (int *)(a3 + 6504), (_OWORD *)(a3 + 6820), (int *)(a3 + 168), (int *)(a3 + 6612));
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a3 + 6812) = v19;
    if (*(_DWORD *)(a3 + 6828) == a6[2] && *(_DWORD *)(a3 + 6832) == a6[3])
    {
      *(_DWORD *)(a3 + 6816) = 0;
    }
    else
    {
      *(_DWORD *)(a3 + 6816) = 1;
      if (*((_BYTE *)a6 + 86))
      {
        aj_log_error((uint64_t)"DecodeInit", "Cropping is not supported for lossless JPEG");
        return 5;
      }
    }
    *(_DWORD *)a5 = *(_DWORD *)(a8 + 100);
    if (*((_BYTE *)a6 + 84) || *((_BYTE *)a6 + 86))
      *(_DWORD *)a5 = 0;
    for (i = 0; i != 32; i += 8)
      *(_QWORD *)(a3 + i + 128) = *(_QWORD *)(a8 + i + 40);
    v28 = *(_DWORD *)(a8 + 8);
    *(_DWORD *)(a3 + 6580) = v28;
    v29 = *(int *)(a8 + 96);
    if (v29 < 5)
    {
      *(_DWORD *)(a3 + 6884) = dword_206276B30[v29];
      *(_DWORD *)(a3 + 6680) = *(_DWORD *)(a8 + 148);
      *(_DWORD *)(a5 + 1496) = *(_DWORD *)(a8 + 112);
      *(_OWORD *)(a5 + 1504) = *(_OWORD *)(a8 + 120);
      if (v28 == 14)
      {
        result = aj_get_texture_size(a6, a8, a3 + 6512, *(unsigned __int8 *)(*(_QWORD *)(a3 + 8) + 356), 0, 0, 0);
        if ((_DWORD)result)
          return result;
      }
      result = aj_compute_helpers(a3);
      if ((_DWORD)result)
        return result;
      if (a11 != 1)
      {
        v30 = *(_DWORD *)(a3 + 24);
        if (v30 != a11)
        {
          aj_log_error((uint64_t)"DecodeInit", "Number of output planes (%d) must be either 1 or %d\n", a11, v30);
          return 8;
        }
      }
      v31 = *(_DWORD *)(a3 + 6808);
      v32 = *(_DWORD *)(a3 + 6580);
      if ((v32 - 25) > 1)
      {
        v41 = *(_DWORD *)(a3 + 24);
        if (v41 == 3)
        {
          v42 = *(_DWORD **)a3;
          if (*(_DWORD *)(a3 + 168) == 8 || *v42 == 1)
          {
            *(_DWORD *)(a3 + 44) = v42[4];
            v43 = v42[8];
          }
          else
          {
            v43 = 2;
            *(_DWORD *)(a3 + 44) = 2;
          }
          *(_DWORD *)(a3 + 48) = v43;
          v48 = *(_QWORD *)(a3 + 128);
          if (!v48)
            v48 = *(_QWORD *)(a3 + 6512);
          *(_QWORD *)(a3 + 96) = v48;
          v49 = *(_QWORD *)(a3 + 136);
          if (!v49)
            v49 = *(_QWORD *)(a3 + 6544);
          *(_QWORD *)(a3 + 104) = v49;
          v50 = *(_QWORD *)(a3 + 144);
          if (!v50)
            v50 = *(_QWORD *)(a3 + 6544);
          *(_QWORD *)(a3 + 112) = v50;
        }
        else
        {
          if (v31 == 270 || v31 == 90)
            v44 = 6496;
          else
            v44 = 6492;
          v45 = *(int *)(a3 + v44);
          v46 = *(_QWORD *)(a3 + 128);
          if (!v46)
            v46 = *(int *)(a3 + 28) * (uint64_t)(int)v45;
          *(_QWORD *)(a3 + 96) = v46;
          if (v41 == 2)
          {
            v47 = *(_QWORD *)(a3 + 136);
            if (!v47)
              v47 = v45 / *(int *)(a3 + 44) * *(int *)(a3 + 32);
            *(_QWORD *)(a3 + 104) = v47;
          }
        }
      }
      else
      {
        v33 = 0;
        v34 = *(_DWORD **)a3;
        v35 = *(_QWORD *)(a3 + 8);
        *(_DWORD *)(a3 + 44) = *(_DWORD *)(*(_QWORD *)a3 + 16);
        *(_DWORD *)(a3 + 48) = v34[8];
        v36 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))*(int *)(v35 + 80);
        v118 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))(*(int *)(v35 + 72) * (uint64_t)(int)v36);
        v119 = v36;
        v120 = v36;
        v37 = (uint64_t *)(a3 + 128);
        v38 = (uint64_t *)(a3 + 128);
        do
        {
          v40 = *v38++;
          v39 = v40;
          if (!v40)
            v39 = (_QWORD)*(&v118 + v33) * *(int *)(a3 + 28 + 4 * v33);
          *(v37 - 4) = v39;
          ++v33;
          v37 = v38;
        }
        while (v33 != 3);
      }
      if (a11 >= 1)
      {
        v51 = (_QWORD *)(a3 + 64);
        v52 = a11;
        do
        {
          v53 = *a10;
          a10 += 2;
          *v51++ = v53;
          --v52;
        }
        while (v52);
      }
      v54 = *(_DWORD *)(a3 + 24);
      if (v54 > a11)
      {
        if (v54 == 2)
        {
          if (v31 == 270 || v31 == 90)
            v55 = 6492;
          else
            v55 = 6496;
          *(_QWORD *)(a3 + 72) = *(_QWORD *)(a3 + 64) + *(_QWORD *)(a3 + 96) * *(int *)(a3 + v55);
LABEL_93:
          v70 = *(_DWORD **)a3;
          v71 = *(_DWORD *)(*(_QWORD *)a3 + 16);
          v72 = *(_DWORD *)(*(_QWORD *)a3 + 32);
          v74 = v71 == 2 && v72 == 2;
          v75 = *(_DWORD *)(a3 + 44) == 2 && *(_DWORD *)(a3 + 48) == 2;
          v76 = *(_DWORD *)(a3 + 6580);
          if ((v76 - 25) < 2)
            goto LABEL_124;
          if (*(_BYTE *)(v18 + 49) && *(_DWORD *)(a3 + 6940) != 1 || v76 == 15 || *v70 == 4)
            *(_DWORD *)(a3 + 6884) = 2;
          if (v76 == 14)
            *(_DWORD *)(a3 + 6884) = 0;
          if (!v74)
            goto LABEL_261;
          if (*(_DWORD *)(a3 + 6884) != 2)
            *(_DWORD *)(a3 + 6884) = 0;
          if (v75)
          {
            v77 = 0;
          }
          else
          {
LABEL_261:
            if (*v24 != 8 || *(_DWORD *)(a3 + 6884))
              goto LABEL_119;
            v77 = 1;
          }
          *(_DWORD *)(a3 + 6884) = v77;
LABEL_119:
          if (*(_DWORD *)(a3 + 6612))
          {
            *(_DWORD *)(a3 + 6884) = 2;
          }
          else
          {
            v78 = *(_DWORD *)(a3 + 6884);
            if (v78 != 2 || v72 != 2)
            {
              if (v78 == 2 && v71 == 2 && *(_DWORD *)(a3 + 20) != 1)
              {
                *(_BYTE *)(v18 + 1) = 1;
                *(_QWORD *)(a3 + 6704) += 2;
              }
              goto LABEL_124;
            }
          }
          *(_BYTE *)v18 = 1;
LABEL_124:
          v134 = 0u;
          v135 = 0u;
          if (v70[1] == 12)
          {
            *(_QWORD *)&v134 = aj_idct_s1_12bit;
            *((_QWORD *)&v134 + 1) = aj_idct_s2_12bit;
            *(_QWORD *)&v135 = aj_idct_s4_12bit;
            *((_QWORD *)&v135 + 1) = aj_idct_s8_12bit;
            v79 = *(_DWORD *)(a3 + 6884);
            if (v79)
              v80 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_12bit;
            else
              v80 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s2_12bit;
            if (v79)
              v81 = aj_idct_s2_12bit;
            else
              v81 = aj_idct_s4_12bit;
            if (v79)
              v82 = aj_idct_s4_12bit;
            else
              v82 = aj_idct_s8_12bit;
            if (v79)
              v83 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_16x16_bilinear_12bit;
            else
              v83 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_12bit;
            if (v79)
              v84 = aj_idct_s1_12bit;
            else
              v84 = aj_idct_s1_4x8_12bit;
            v120 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))v84;
            v121 = v83;
            if (v79)
              v85 = aj_idct_s2_12bit;
            else
              v85 = aj_idct_s2_2x4_12bit;
            v124 = v85;
            v125 = v80;
            if (v79)
              v86 = aj_idct_s4_12bit;
            else
              v86 = aj_idct_s4_1x2_12bit;
            v128 = v86;
            v129 = v81;
            v132 = aj_idct_s8_12bit;
            v133 = v82;
            if (v79)
              v87 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_16x8_bilinear_12bit;
            else
              v87 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_8x4_12bit;
            v118 = v80;
            v119 = v87;
            if (v79)
              v88 = aj_idct_s1_8x4_12bit;
            else
              v88 = aj_idct_s2_4x2_12bit;
            v122 = v81;
            v123 = v88;
            if (v79)
              v89 = aj_idct_s2_4x2_12bit;
            else
              v89 = aj_idct_s4_2x1_12bit;
            v126 = v82;
            v127 = v89;
            if (v79)
              v90 = (uint64_t (*)(__int16 *, _QWORD *, int))aj_idct_s4_2x1_12bit;
            else
              v90 = (uint64_t (*)(__int16 *, _QWORD *, int))aj_idct_s8_12bit;
            v130 = aj_idct_s8_12bit;
            v131 = v90;
            if (v79)
            {
              v91 = 1;
              v92 = 1;
              if (v70[8] == 1)
              {
                if (v70[4] == 2)
                  v92 = 2;
                else
                  v92 = 1;
              }
            }
            else if (*v24 == 8)
            {
              v91 = v70[8];
              v92 = v70[4];
            }
            else
            {
              v91 = 2;
              v92 = 2;
            }
          }
          else
          {
            *(_QWORD *)&v134 = aj_idct_s1;
            *((_QWORD *)&v134 + 1) = aj_idct_s2;
            *(_QWORD *)&v135 = aj_idct_s4;
            *((_QWORD *)&v135 + 1) = aj_idct_s8;
            v93 = *(_DWORD *)(a3 + 6884);
            if (v93)
            {
              v118 = aj_idct_s1;
              v122 = aj_idct_s2;
              v126 = aj_idct_s4;
              v130 = aj_idct_s8;
              v91 = v70[8];
              v92 = 1;
              if (v93 == 2)
              {
                if (v91 == 1)
                {
                  if (v70[4] == 2)
                    v92 = 2;
                  else
                    v92 = 1;
                }
                v119 = aj_idct_s1_16x8_bilinear;
                v120 = aj_idct_s1;
                v121 = aj_idct_s1_16x16_bilinear;
                v123 = aj_idct_s1_8x4;
                v124 = aj_idct_s2;
                v125 = aj_idct_s1;
                v127 = aj_idct_s2_4x2;
                v128 = aj_idct_s4;
                v129 = aj_idct_s2;
                v131 = aj_idct_s4_2x1;
                v132 = aj_idct_s8;
                v91 = 1;
                v133 = aj_idct_s4;
              }
              else
              {
                if (v76 == 14 && *v24 == 8)
                  v92 = v70[4];
                v119 = aj_idct_s1;
                v120 = aj_idct_s1_8x16_nearest;
                v121 = aj_idct_s1_8x16_nearest;
                v123 = aj_idct_s2;
                v124 = aj_idct_s2_4x8_nearest;
                v125 = aj_idct_s2_4x8_nearest;
                v127 = aj_idct_s4;
                v128 = aj_idct_s4_2x4_nearest;
                v129 = aj_idct_s4_2x4_nearest;
                v94 = aj_idct_s8_1x2_nearest;
                if (v76 == 14)
                  v94 = aj_idct_s8;
                v131 = aj_idct_s8;
                v132 = v94;
                v133 = v94;
              }
            }
            else
            {
              if (*v24 == 8)
              {
                v91 = v70[8];
                v92 = v70[4];
              }
              else
              {
                v91 = 2;
                v92 = 2;
              }
              v118 = aj_idct_s2;
              v119 = aj_idct_s1_8x4;
              v120 = aj_idct_s1_4x8;
              v121 = aj_idct_s1;
              v122 = aj_idct_s4;
              v123 = aj_idct_s2_4x2;
              v124 = aj_idct_s2_2x4;
              v125 = aj_idct_s2;
              v126 = aj_idct_s8;
              v127 = aj_idct_s4_2x1;
              v128 = aj_idct_s4_1x2;
              v129 = aj_idct_s4;
              v130 = aj_idct_s8;
              v131 = aj_idct_s8;
              v132 = aj_idct_s8;
              v133 = aj_idct_s8;
            }
          }
          v95 = (int)aj_highest_set_bit(*(_DWORD *)(a3 + 168)) - 1;
          v96 = aj_highest_set_bit(*(_DWORD *)(*(_QWORD *)a3 + 16));
          v97 = aj_highest_set_bit(*(_DWORD *)(*(_QWORD *)a3 + 32));
          *(_QWORD *)(a3 + 712) = *((_QWORD *)&v134 + v95);
          if (*(_DWORD *)(a3 + 6612))
          {
            v91 = 1;
            v98 = aj_idct_s8;
            v92 = 1;
          }
          else
          {
            v98 = (uint64_t (*)(__int16 *, _QWORD *, int))*(&v118 + 4 * v95 + 2 * v96 + v97 - 3);
          }
          *(_DWORD *)(a3 + 6892) = v92;
          *(_DWORD *)(a3 + 6896) = v91;
          v99 = *(unsigned int *)(a3 + 6464);
          if ((int)v99 > 1)
          {
            v100 = v99 - 1;
            v101 = (_QWORD *)(a3 + 2280);
            do
            {
              *v101 = v98;
              v101 += 196;
              --v100;
            }
            while (v100);
          }
          if ((int)v99 >= 1)
          {
            v102 = (int *)(a3 + 908);
            do
            {
              v103 = *(uint64_t (**)(__int16 *, _QWORD *, int))(v102 - 49);
              if ((char *)v103 == (char *)aj_idct_s1_16x16_bilinear_12bit)
              {
                v108 = 32;
              }
              else if ((char *)v103 == (char *)aj_idct_s1_4x8_12bit
                     || (char *)v103 == (char *)aj_idct_s1_16x8_bilinear_12bit
                     || (char *)v103 == (char *)aj_idct_s1_12bit
                     || (char *)v103 == (char *)aj_idct_s1_8x16_nearest
                     || (char *)v103 == (char *)aj_idct_s1_16x16_bilinear)
              {
                v108 = 16;
              }
              else
              {
                v108 = 8;
                if ((char *)v103 != (char *)aj_idct_s2_2x4_12bit
                  && (char *)v103 != (char *)aj_idct_s2_12bit
                  && (char *)v103 != (char *)aj_idct_s1_8x4_12bit
                  && (char *)v103 != (char *)aj_idct_s2_4x8_nearest
                  && (char *)v103 != (char *)aj_idct_s1_16x8_bilinear
                  && (char *)v103 != (char *)aj_idct_s1
                  && (char *)v103 != (char *)aj_idct_s1_4x8)
                {
                  v108 = 4;
                  if ((char *)v103 != (char *)aj_idct_s4_1x2_12bit
                    && (char *)v103 != (char *)aj_idct_s4_12bit
                    && (char *)v103 != (char *)aj_idct_s2_4x2_12bit
                    && (char *)v103 != (char *)aj_idct_s4_2x4_nearest
                    && (char *)v103 != (char *)aj_idct_s2_2x4
                    && (char *)v103 != (char *)aj_idct_s1_8x4
                    && (char *)v103 != (char *)aj_idct_s2)
                  {
                    v108 = 2;
                    if ((char *)v103 != (char *)aj_idct_s8_12bit
                      && (char *)v103 != (char *)aj_idct_s4_2x1_12bit
                      && v103 != aj_idct_s8_1x2_nearest
                      && v103 != aj_idct_s4_1x2
                      && (char *)v103 != (char *)aj_idct_s2_4x2
                      && (char *)v103 != (char *)aj_idct_s4)
                    {
                      v108 = v103 == aj_idct_s4_2x1 || v103 == aj_idct_s8;
                    }
                  }
                }
              }
              *v102 = v108;
              v102 += 392;
              --v99;
            }
            while (v99);
          }
          result = init_ra_table(a4, a5, a9, *(_DWORD *)(a8 + 104), *(_DWORD *)(a8 + 108), v116);
          if (!(_DWORD)result)
          {
            set_crop_offset(a3);
            result = init_invcol((uint64_t *)a3);
            if (!(_DWORD)result)
            {
              result = aj_compute_buffer_sizes(v115, a3, a5, a9);
              if (!(_DWORD)result)
              {
                v110 = *(_DWORD *)a8;
                if (*(int *)a8 >= 8)
                  v110 = 8;
                if (v110 <= 1)
                  v111 = 1;
                else
                  v111 = v110;
                *(_DWORD *)(a3 + 6948) = aj_get_numthreads_decode(a3, a8, *(_QWORD *)(a7 + 80) == 0, v111, (_DWORD *)(a3 + 6960));
                result = aj_init_decode_jobs(a3, (_DWORD *)a5, a4, v115, a9, 0);
                if (!(_DWORD)result)
                {
                  result = aj_init_input_states(a3, a5, a7, a13, (char *)&v117);
                  if (!(_DWORD)result)
                  {
                    if (*(_DWORD *)(a8 + 36) == 1 && !*(_BYTE *)(a3 + 17))
                      fill_image_edges(a3);
                    if (*a6 >= 1)
                    {
                      v112 = 0;
                      v113 = a3 + 192;
                      do
                      {
                        aj_init_component(a3, v113, v112++, 0, 0);
                        v113 += 1568;
                      }
                      while (v112 < *a6);
                    }
                    if (!*((_BYTE *)a6 + 84)
                      || (result = init_prog_scans(v116, (uint64_t *)a3, a5, a9, v117), !(_DWORD)result))
                    {
                      init_blockdec(a3, 0);
                      return 0;
                    }
                  }
                }
              }
            }
          }
          return result;
        }
        if (v32 == 14)
        {
          v56 = *(_QWORD *)(a3 + 64);
          v57 = *(_QWORD *)(a3 + 96);
          if (*(_BYTE *)(a3 + 17))
          {
            v58 = *(int *)(a3 + 172);
            v59 = v56 + v57 * v58;
            v60 = (int)v58 / *(_DWORD *)(a3 + 48);
          }
          else
          {
            v59 = v56 + *(_QWORD *)(a3 + 6520) * v57;
            v60 = *(_QWORD *)(a3 + 6552);
          }
          v61 = v59 + *(_QWORD *)(a3 + 104) * v60;
          *(_QWORD *)(a3 + 72) = v59;
          *(_QWORD *)(a3 + 80) = v61;
        }
        else if (v54 == 3)
        {
          v63 = *(_DWORD **)a3;
          v62 = *(int **)(a3 + 8);
          v64 = v62[21];
          v65 = *(_QWORD *)(a3 + 64) + *(_QWORD *)(a3 + 96) * v64 * v62[19];
          v66 = v65 + *(_QWORD *)(a3 + 104) * v64;
          *(_QWORD *)(a3 + 72) = v65;
          *(_QWORD *)(a3 + 80) = v66;
          if (*v63 != 1)
            goto LABEL_93;
          goto LABEL_89;
        }
      }
      if (v54 != 3 || **(_DWORD **)a3 != 1)
        goto LABEL_93;
      v62 = *(int **)(a3 + 8);
LABEL_89:
      if (v62[89])
      {
        v68 = (void *)(*(_QWORD *)(a3 + 64) + 8 * *(_QWORD *)(a3 + 96) * *(int *)(a3 + 48));
        v69 = 8 * (*(_QWORD *)(a3 + 112) + *(_QWORD *)(a3 + 104));
      }
      else
      {
        memset(*(void **)(a3 + 72), 128, *(_QWORD *)(a3 + 6552) * *(_QWORD *)(a3 + 104));
        v68 = *(void **)(a3 + 80);
        v69 = *(_QWORD *)(a3 + 6552) * *(_QWORD *)(a3 + 112);
      }
      memset(v68, 128, v69);
      goto LABEL_93;
    }
    aj_log_error((uint64_t)"DecodeInit", "Unsupported decoding quality.");
    return 5;
  }
  return result;
}

uint64_t aj_highest_set_bit(unsigned int a1)
{
  unsigned int v1;

  v1 = 32 - __clz(a1);
  if (a1)
    return v1;
  else
    return 0;
}

uint64_t aj_init_component(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int *v12;
  int *v13;
  void *v14;
  _DWORD *v15;
  int *v16;
  int v17;
  int v18;
  uint64_t v19;

  v7 = result;
  v8 = *(_QWORD *)result;
  v9 = *(_QWORD *)result + 4 * a3;
  v10 = *(_QWORD *)(result + 8) + 8;
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(v10 + 16 * *(int *)(v9 + 3356));
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(v10 + 16 * *(int *)(v9 + 3372) + 8);
  v11 = *(_DWORD *)(result + 168);
  *(_DWORD *)(a2 + 712) = v11;
  if (a3 && !a5)
  {
    if (*(_DWORD *)(result + 6884) || v11 == 8)
    {
      if (!*(_DWORD *)(result + 6612) && *(_BYTE *)(result + 6888) && v11 != 1)
      {
        v11 >>= 1;
        goto LABEL_12;
      }
    }
    else if (*(_DWORD *)(v8 + 16) == 1 && *(_DWORD *)(v8 + 32) == 1)
    {
      v11 *= 2;
LABEL_12:
      *(_DWORD *)(a2 + 712) = v11;
    }
  }
  *(_DWORD *)(a2 + 536) = 8 / v11;
  if (*(_BYTE *)(v8 + 86))
    goto LABEL_32;
  if (a4)
  {
    *(_QWORD *)(a2 + 704) = &glob_non_zigzag;
    *(_QWORD *)(a2 + 696) = &glob_non_zigzag_pm;
    result = aj_init_QT_as_no_op(a2 + 48, 1);
    goto LABEL_32;
  }
  v12 = (int *)(v8 + ((uint64_t)*(int *)(v8 + 4 * a3 + 48) << 8) + 88);
  if (v11 == 1)
    v13 = (int *)&aj_glob_zigzag_trans;
  else
    v13 = aj_glob_zigzag;
  v14 = &aj_glob_zigzag_pm;
  if (v11 == 1)
    v14 = &aj_glob_zigzag_trans_pm;
  *(_QWORD *)(a2 + 704) = v13;
  *(_QWORD *)(a2 + 696) = v14;
  v15 = (_DWORD *)(a2 + 48);
  if (*(_DWORD *)(v8 + 4) == 12)
  {
    aj_init_QT_as_no_op(a2 + 48, v11);
    result = (uint64_t)aj_init_QT_aanIDCT(v12, (_DWORD *)(a2 + 720), *(_DWORD *)(a2 + 712), v13);
    goto LABEL_32;
  }
  if (*(_BYTE *)(v8 + 84))
    v16 = v13;
  else
    v16 = (int *)&glob_non_zigzag;
  result = (uint64_t)aj_init_QT_aanIDCT(v12, v15, v11, v16);
  v17 = *(_DWORD *)(v7 + 6680);
  if (v17 == 1)
  {
    if (a3)
      goto LABEL_33;
    goto LABEL_35;
  }
  if (v17 == 2 && *v12 >= 4 && *(int *)(*(_QWORD *)v7 + 8) <= 640 && !a3 && *(int *)(*(_QWORD *)v7 + 12) < 641)
  {
LABEL_35:
    if (*(_DWORD *)(a2 + 712) == 1)
      result = aj_mosquito_spray_enable(a2);
    goto LABEL_37;
  }
LABEL_32:
  if (!a3)
  {
LABEL_37:
    v18 = *(_DWORD *)(*(_QWORD *)(v7 + 8) + 88);
    goto LABEL_38;
  }
LABEL_33:
  v18 = 1;
LABEL_38:
  *(_DWORD *)(a2 + 8) = v18;
  v19 = v8 + 4 * a3;
  *(_DWORD *)a2 = *(_DWORD *)(v19 + 16);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v19 + 32);
  *(_DWORD *)(a2 + 12) = 0;
  return result;
}

_DWORD *aj_init_QT_aanIDCT(_DWORD *result, _DWORD *a2, int a3, int *a4)
{
  uint64_t i;
  uint64_t j;

  switch(a3)
  {
    case 1:
      for (i = 0; i != 64; ++i)
        a2[a4[i]] = dword_20627C418[aj_glob_zigzag[i]] * result[i];
      break;
    case 2:
      for (j = 0; j != 25; ++j)
        a2[a4[j]] = result[j];
      break;
    case 4:
      a2[*a4] = *result;
      a2[a4[1]] = result[1];
      a2[a4[2]] = result[2];
      a2[a4[4]] = result[4];
      break;
    case 8:
      *a2 = *result;
      break;
    default:
      return result;
  }
  return result;
}

int32x4_t set_crop_offset(uint64_t a1)
{
  int v1;
  int v2;
  const float *v3;
  int32x4_t v4;
  int32x4_t result;

  v1 = *(_DWORD *)(a1 + 6852);
  if (*(_DWORD *)(a1 + 6884) || *(_DWORD *)(a1 + 6464) != 3)
  {
    *(_DWORD *)(a1 + 6868) = v1;
    v2 = v1;
  }
  else
  {
    v2 = 0;
    *(_DWORD *)(a1 + 6868) = v1;
    v1 /= 2;
  }
  *(_DWORD *)(a1 + 6872) = v1;
  *(_DWORD *)(a1 + 6876) = v1;
  *(_DWORD *)(a1 + 6880) = v2;
  v3 = (const float *)(a1 + 6800);
  v4 = (int32x4_t)vld1q_dup_f32(v3);
  result = vmulq_s32(*(int32x4_t *)(a1 + 6868), v4);
  *(int32x4_t *)(a1 + 6868) = result;
  return result;
}

__n128 reset_decode_job(uint64_t a1)
{
  __n128 result;
  __n128 v3;
  __int128 v4;
  uint64_t v5;

  v3 = *(__n128 *)(a1 + 112);
  v4 = *(_OWORD *)(a1 + 128);
  v5 = *(_QWORD *)(a1 + 144);
  bzero((void *)a1, 0x5F8uLL);
  result = v3;
  *(__n128 *)(a1 + 112) = v3;
  *(_OWORD *)(a1 + 128) = v4;
  *(_QWORD *)(a1 + 144) = v5;
  return result;
}

uint64_t init_ra_table(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  int v10;
  int v11;
  uint64_t result;
  uint64_t v13;
  int *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  void *v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  _WORD *v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  __int128 v61;

  if (!*(_DWORD *)a2)
  {
    result = 0;
    goto LABEL_11;
  }
  if ((a4 - 0x10000) < 0xFFFF0001 || (a5 - 0x10000) <= 0xFFFF0000)
  {
    aj_log_error((uint64_t)"DecodeInit", "Unsupported RA-table sampling frequency");
    *(_DWORD *)a2 = 0;
    *(_QWORD *)(a2 + 16) = 0;
    return 8;
  }
  else
  {
    if ((*(_DWORD *)(a1 + 136) & 0xFFFFFFFE) == 2 && *(_QWORD *)(a1 + 96) && *(_QWORD *)(a1 + 104))
    {
      v11 = *(_DWORD *)(a1 + 112);
      v10 = *(_DWORD *)(a1 + 116);
      if (v10 == a5 && v11 == a4)
      {
        result = 0;
        *(_DWORD *)a2 = 0;
LABEL_11:
        *(_QWORD *)(a2 + 16) = 0;
        return result;
      }
      v13 = *(_QWORD *)(a6 + 32);
      *(_QWORD *)(a6 + 32) = 0;
    }
    else
    {
      v13 = 0;
      v10 = 0;
      v11 = 0;
    }
    *(_DWORD *)(a1 + 112) = a4;
    *(_DWORD *)(a1 + 116) = a5;
    v14 = (int *)(a1 + 112);
    v15 = *(_DWORD *)(a1 + 80);
    v16 = (a5 + v15 - 1) / a5;
    v17 = (a4 + *(_DWORD *)(a1 + 84) - 1) / a4;
    *(_DWORD *)(a1 + 128) = v17;
    *(_DWORD *)(a1 + 132) = v16;
    v18 = 8 * v17;
    while (1)
    {
      v19 = 20 * v16;
      if (20 * v16 * v17 < 41943041)
        break;
      v20 = v15 + a5++;
      *(_DWORD *)(a1 + 116) = a5;
      v16 = v20 / a5;
      *(_DWORD *)(a1 + 132) = v16;
      if (v16 == 1)
      {
        v19 = 20;
        break;
      }
    }
    v21 = *(_QWORD *)(a6 + 32);
    if (v21)
    {
      (*(void (**)(uint64_t, _QWORD))(a3 + 8))(v21, *(_QWORD *)(a3 + 16));
      v17 = *(_DWORD *)(a1 + 128);
    }
    v22 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a3)(v18 + v17 * v19, *(_QWORD *)(a3 + 16));
    *(_QWORD *)(a6 + 32) = v22;
    if (v22 && (bzero(v22, v18 + *(_DWORD *)(a1 + 128) * v19), (v23 = *(_QWORD *)(a6 + 32)) != 0))
    {
LABEL_22:
      *(_QWORD *)(a1 + 96) = v23;
      *(_QWORD *)(a1 + 104) = v23;
      v24 = *(unsigned int *)(a1 + 128);
      if ((int)v24 >= 1)
      {
        v25 = 0;
        v26 = v23 + v18;
        v27 = 8 * v24;
        v28 = 20 * *(int *)(a1 + 132);
        do
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 104) + v25) = v26;
          v25 += 8;
          v26 += v28;
        }
        while (v27 != v25);
      }
      if (v13)
      {
        v29 = *(_DWORD *)(a1 + 116);
        if (v10 >= v29)
          v30 = *(_DWORD *)(a1 + 116);
        else
          v30 = v10;
        if (v10 <= v29)
          v31 = *(_DWORD *)(a1 + 116);
        else
          v31 = v10;
        if (v30)
        {
          do
          {
            v32 = v30;
            v30 = v31 % v30;
            v31 = v32;
          }
          while (v30);
        }
        else
        {
          v32 = v31;
        }
        v48 = v29 * v10;
        v49 = *v14;
        if (v11 >= *v14)
          v50 = *v14;
        else
          v50 = v11;
        if (v11 <= v49)
          v51 = *v14;
        else
          v51 = v11;
        v52 = v48 / v32;
        if (v50)
        {
          do
          {
            v53 = v50;
            v50 = v51 % v50;
            v51 = v53;
          }
          while (v50);
        }
        else
        {
          v53 = v51;
        }
        v54 = v49 * v11 / v53;
        *(_DWORD *)(a1 + 120) = v54;
        *(_DWORD *)(a1 + 124) = v52;
        v55 = *(_DWORD *)(a1 + 84);
        if (v55 >= 1)
        {
          v56 = 0;
          v57 = *(_DWORD *)(a1 + 80);
          do
          {
            if (v57 >= 1)
            {
              v58 = 0;
              do
              {
                v59 = *(_QWORD *)(v13 + 8 * (v56 / v11)) + 20 * (v58 / v10);
                v60 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8 * (v56 / *(_DWORD *)(a1 + 112)))
                    + 20 * (v58 / *(_DWORD *)(a1 + 116));
                v61 = *(_OWORD *)v59;
                *(_DWORD *)(v60 + 16) = *(_DWORD *)(v59 + 16);
                *(_OWORD *)v60 = v61;
                v58 += v52;
                v57 = *(_DWORD *)(a1 + 80);
              }
              while (v58 < v57);
              v55 = *(_DWORD *)(a1 + 84);
            }
            v56 += v54;
          }
          while (v56 < v55);
        }
        *(_DWORD *)(a1 + 136) = 2;
        *(_QWORD *)(a2 + 16) = 0;
        (*(void (**)(uint64_t, _QWORD))(a3 + 8))(v13, *(_QWORD *)(a3 + 16));
        return 0;
      }
      else
      {
        v42 = 0;
        v43 = *(_DWORD *)(a1 + 80);
        v44 = *(_DWORD *)(a1 + 84);
        do
        {
          v45 = a1 + v42;
          *(_WORD *)(v45 + 140) = v44;
          *(_WORD *)(v45 + 142) = v43;
          v42 += 24;
        }
        while (v42 != 216);
        if (v43 < 4 || v44 < 4)
        {
          *(_WORD *)(a1 + 140) = v44 / 2;
          *(_WORD *)(a1 + 142) = v43 / 2;
        }
        else
        {
          v46 = 0;
          v47 = (_WORD *)(a1 + 142);
          do
          {
            *(v47 - 1) = (int)(v44 + v44 * (v46 / 3u)) / 4;
            *v47 = v43 * (v46 % 3u + 1) / 4;
            v47 += 12;
            ++v46;
          }
          while (v46 != 9);
        }
        result = 0;
        *(_QWORD *)(a2 + 16) = a1 + 140;
        *(_DWORD *)(a1 + 136) = 1;
      }
    }
    else
    {
      while (1)
      {
        v36 = *(_DWORD *)(a1 + 80);
        v37 = *(_DWORD *)(a1 + 116);
        if (!(v36 / v37))
          break;
        *(_DWORD *)(a1 + 116) = v37 + 1;
        v33 = (v37 + v36) / (v37 + 1);
        *(_DWORD *)(a1 + 132) = v33;
        v34 = 20 * v33;
        v35 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a3)(v18 + *(_DWORD *)(a1 + 128) * 20 * v33, *(_QWORD *)(a3 + 16));
        *(_QWORD *)(a6 + 32) = v35;
        if (v35)
        {
          bzero(v35, v18 + *(_DWORD *)(a1 + 128) * v34);
          v23 = *(_QWORD *)(a6 + 32);
          if (v23)
            goto LABEL_22;
        }
      }
      aj_log_error((uint64_t)"DecodeInit", "Failed to allocate RA-table");
      if (v13)
        (*(void (**)(uint64_t, _QWORD))(a3 + 8))(v13, *(_QWORD *)(a3 + 16));
      v38 = 0;
      *(_DWORD *)a2 = 0;
      *(_QWORD *)v14 = 0;
      *(_QWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 136) = 0;
      *(_QWORD *)(a1 + 128) = 0;
      v40 = *(_DWORD *)(a1 + 80);
      v39 = *(_DWORD *)(a1 + 84);
      do
      {
        v41 = a1 + v38;
        *(_WORD *)(v41 + 140) = v39;
        *(_WORD *)(v41 + 142) = v40;
        v38 += 24;
      }
      while (v38 != 216);
      return 6;
    }
  }
  return result;
}

uint64_t init_invcol(uint64_t *a1)
{
  int v1;
  int *v2;
  _BYTE *v3;
  uint64_t result;
  void *v5;
  void *v6;
  int v7;
  void *v8;
  char v9;
  int v10;
  void *v11;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int, int);
  int v13;
  uint8x8_t **(*v14)(uint8x8_t **, uint8x8_t **, uint8x8_t **, char *, double, double, uint64x2_t, uint64x2_t, uint64_t, uint64_t, unsigned int);
  uint8x16_t **(*v15)(uint8x16_t **, uint8x8_t **, uint8x8_t **, char *, char *, int, unsigned int);
  int v16;
  uint8x8_t **(*v17)(uint8x8_t **, uint8x8_t **, uint8x8_t **, int16x8_t *, double, double, uint64x2_t, uint64x2_t, uint64x2_t, uint64_t, uint64_t, unsigned int);
  uint8x16_t **(*v18)(uint8x16_t **, uint8x8_t **, uint8x8_t **, char *, char *, int, unsigned int);
  int v19;
  unsigned __int16 **(*v20)(unsigned __int16 **, unsigned __int16 **, unsigned __int16 **, __int16 *, uint64_t, uint64_t, int);
  _QWORD *(*v21)(_QWORD *, unsigned __int16 **, unsigned __int16 **, uint64_t, uint64_t, int, int);
  int v22;

  v1 = *((_DWORD *)a1 + 1645);
  if (v1 == 14)
    return 0;
  v2 = (int *)*a1;
  *((_OWORD *)a1 + 432) = 0u;
  if (v1 == 15)
  {
    v3 = a1 + 867;
    a1[866] = (uint64_t)aj_icol_mcurow_cmyk;
    if (*(_DWORD *)(a1[1] + 356))
    {
      result = 0;
      *v3 = 0;
    }
    else
    {
      v9 = *((_BYTE *)a1 + 6937);
      if (v9)
        v9 = *((_DWORD *)a1 + 1735) == 2;
      result = 0;
      *v3 = v9;
    }
    return result;
  }
  a1[866] = (uint64_t)aj_icol_mcurow_default;
  switch(v1)
  {
    case 0:
      v6 = 0;
      v10 = *v2;
      if (*((_DWORD *)a1 + 1721))
        v11 = aj_icol_row_444_to_rgb;
      else
        v11 = aj_icol_row_420_to_rgb;
      v12 = aj_icol_row_gray_to_rgb;
      goto LABEL_54;
    case 1:
      v6 = 0;
      v10 = *v2;
      v13 = *((_DWORD *)a1 + 1721);
      v14 = aj_icol_row_444_to_rgb565;
      v15 = aj_icol_row_420_to_rgb565;
      goto LABEL_22;
    case 2:
      v6 = 0;
      v10 = *v2;
      v13 = *((_DWORD *)a1 + 1721);
      v14 = aj_icol_row_444_to_bgr565;
      v15 = aj_icol_row_420_to_bgr565;
LABEL_22:
      if (v13)
        v11 = v14;
      else
        v11 = v15;
      v12 = aj_icol_row_gray_to_rgb565;
      goto LABEL_54;
    case 3:
      v6 = 0;
      v10 = *v2;
      v16 = *((_DWORD *)a1 + 1721);
      v17 = aj_icol_row_444_to_rgba;
      v18 = aj_icol_row_420_to_rgba;
      goto LABEL_28;
    case 4:
      v6 = 0;
      v10 = *v2;
      v16 = *((_DWORD *)a1 + 1721);
      v17 = aj_icol_row_444_to_bgra;
      v18 = aj_icol_row_420_to_bgra;
LABEL_28:
      if (v16)
        v11 = v17;
      else
        v11 = v18;
      v12 = aj_icol_row_gray_to_rgba;
      goto LABEL_54;
    case 5:
      v6 = 0;
      v5 = aj_icol_row_all_to_gray;
      goto LABEL_59;
    case 6:
      v6 = 0;
      v10 = *v2;
      if (*((_DWORD *)a1 + 1721))
        v11 = aj_icol_row_444_to_yuv;
      else
        v11 = aj_icol_row_420_to_yuv;
      v12 = aj_icol_row_gray_to_yuv;
      goto LABEL_54;
    case 7:
      v6 = 0;
      v10 = *v2;
      if (*((_DWORD *)a1 + 1721))
        v11 = aj_icol_row_444_to_yuyv;
      else
        v11 = aj_icol_row_420_to_yuyv;
      v12 = aj_icol_row_gray_to_yuyv;
      goto LABEL_54;
    case 8:
    case 9:
      v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar422;
      v6 = aj_icol_row_gray_to_422biplanar;
      v7 = *v2;
      v8 = aj_icol_row_422_to_biplanar;
      goto LABEL_61;
    case 10:
    case 11:
      v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar4X0;
      v6 = aj_icol_row_gray_to_420biplanar;
      v7 = *v2;
      v8 = aj_icol_row_420_to_biplanar;
      goto LABEL_61;
    case 12:
    case 13:
      v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar4X0;
      v6 = aj_icol_row_gray_to_440biplanar;
      v7 = *v2;
      v8 = aj_icol_row_440_to_biplanar;
      goto LABEL_61;
    case 16:
      v6 = 0;
      v10 = *v2;
      v19 = *((_DWORD *)a1 + 1721);
      v20 = aj_icol_row_444_to_rgba_12bit;
      v21 = aj_icol_row_420_to_rgba_12bit;
      goto LABEL_44;
    case 17:
      v6 = 0;
      v10 = *v2;
      v19 = *((_DWORD *)a1 + 1721);
      v20 = aj_icol_row_444_to_bgra_12bit;
      v21 = aj_icol_row_420_to_bgra_12bit;
LABEL_44:
      if (v19)
        v11 = v20;
      else
        v11 = v21;
      v12 = aj_icol_row_gray_to_rgba_12bit;
      goto LABEL_54;
    case 18:
      v6 = 0;
      v5 = aj_icol_row_all_to_gray_12bit;
      goto LABEL_59;
    case 19:
      v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar4X0;
      v6 = aj_icol_row_gray_to_420biplanar_12bit;
      v7 = *v2;
      v8 = aj_icol_row_420_to_biplanar_12bit;
      goto LABEL_61;
    case 20:
      v6 = 0;
      v10 = *v2;
      if (*((_DWORD *)a1 + 1721))
        v11 = aj_icol_row_444_to_bgr_12bit;
      else
        v11 = aj_icol_row_420_to_bgr_12bit;
      v12 = aj_icol_row_gray_to_rgb_12bit;
LABEL_54:
      if (v10 == 1)
        v5 = v12;
      else
        v5 = v11;
      a1[864] = (uint64_t)v5;
      goto LABEL_64;
    case 21:
      v6 = 0;
      v5 = aj_icol_row_gray_to_rgba_12bit;
LABEL_59:
      a1[864] = (uint64_t)v5;
      goto LABEL_64;
    case 22:
    case 23:
      if (*((_BYTE *)v2 + 86))
        goto LABEL_15;
      aj_log_error((uint64_t)"DecodeInit", "Two component output only supported for lossless images");
      return 5;
    case 24:
      v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar444;
      v6 = aj_icol_row_gray_to_444biplanar;
      v7 = *v2;
      v8 = aj_icol_row_444_to_biplanar;
LABEL_61:
      if (v7 == 3)
        v6 = v8;
      a1[865] = (uint64_t)v6;
      goto LABEL_64;
    case 25:
    case 26:
      if (*((_BYTE *)v2 + 86))
      {
LABEL_15:
        v6 = 0;
        v5 = 0;
LABEL_64:
        if (*((_BYTE *)v2 + 86))
          return 0;
        v22 = *((_DWORD *)a1 + 6);
        if (v5)
        {
          result = 0;
          if (v22 != 2 || v6)
            return result;
        }
        else
        {
          if (v22 != 2)
          {
            aj_log_error((uint64_t)"DecodeInit", "No pixel-row inverse color transform set");
            return 1;
          }
          if (v6)
            return 0;
        }
        aj_log_error((uint64_t)"DecodeInit", "No pixel-row semiplanar transform set");
        return 1;
      }
      aj_log_error((uint64_t)"DecodeInit", "Tri-planar output only supported for lossless images");
      return 5;
    default:
      aj_log_error((uint64_t)"DecodeInit", "Unknown output format");
      return 5;
  }
}

uint64_t init_blockdec(uint64_t result, int a2)
{
  unsigned int **v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  BOOL v7;
  uint64_t (*v8)(uint64_t, uint64_t, _DWORD *, uint64_t, uint64_t);
  uint64_t (*v9)(uint64_t, uint64_t, _DWORD *, uint64_t, uint64_t);
  uint64_t (*v10)(uint64_t, uint64_t, _DWORD *, uint64_t, uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD v17[6];

  v2 = (unsigned int **)result;
  v17[5] = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    *(_QWORD *)(result + 160) = aj_mcu_decode_index;
    v3 = **(unsigned int **)result;
    if ((int)v3 >= 1)
    {
      v4 = (_QWORD *)(result + 720);
      do
      {
        *v4 = aj_block_decode_skip;
        v4 += 196;
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    v5 = *(_QWORD *)result;
    v6 = aj_mcu_decode_progressive;
    if (!*(_BYTE *)(*(_QWORD *)result + 84))
      v6 = aj_mcu_decode;
    *(_QWORD *)(result + 160) = v6;
    v7 = *(_DWORD *)(v5 + 4) == 12;
    v8 = aj_block_decode_S8;
    v9 = aj_block_decode_S4;
    v10 = aj_block_decode_S2;
    v11 = aj_block_decode;
    if (v7)
    {
      v11 = aj_block_decode_12bit;
      v10 = aj_block_decode_12bit;
      v9 = aj_block_decode_12bit;
      v8 = aj_block_decode_12bit;
    }
    v17[0] = v11;
    v17[1] = v10;
    v17[2] = v9;
    v17[3] = v8;
    v17[4] = aj_block_decode_skip;
    result = aj_highest_set_bit(*(_DWORD *)(result + 168));
    v12 = (int)result - 1;
    v2[90] = (unsigned int *)v17[v12];
    if (*((_DWORD *)v2 + 1616) == 1)
    {
      result = 4;
    }
    else if (*((_DWORD *)v2 + 1721) || (*v2)[4] != 1 || (*v2)[8] != 1 || *((_DWORD *)v2 + 42) == 8)
    {
      if (*((_DWORD *)v2 + 1653) || !*((_BYTE *)v2 + 6888))
      {
        result = (int)result - 1;
      }
      else if (*((int *)v2 + 42) <= 1)
      {
        result = v12;
      }
      else
      {
        result = (result - 2);
      }
    }
    v13 = **v2;
    if ((int)v13 >= 2)
    {
      v14 = v17[(int)result];
      v15 = v2 + 286;
      v16 = v13 - 1;
      do
      {
        *v15 = v14;
        v15 += 196;
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

uint64_t aj_init_input_states(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5)
{
  _BOOL4 v8;
  uint64_t result;
  uint64_t v10;
  uint64_t i;
  __int128 *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  if (*(_DWORD *)a2)
    v8 = 0;
  else
    v8 = *(_BYTE *)(*(_QWORD *)(a1 + 8) + 400) == 0;
  result = init_mcustate(a2, a3, a4, v8, a5);
  if (!(_DWORD)result)
  {
    if (*(int *)(a1 + 6948) < 2)
    {
      return 0;
    }
    else
    {
      v10 = 0;
      for (i = *(_QWORD *)(a1 + 6952); ; i += 1672)
      {
        v12 = *(__int128 **)(a2 + 112);
        v13 = *v12;
        v14 = v12[1];
        v15 = v12[2];
        *(_OWORD *)(i + 1600) = v12[3];
        *(_OWORD *)(i + 1584) = v15;
        *(_OWORD *)(i + 1568) = v14;
        *(_OWORD *)(i + 1552) = v13;
        v16 = v12[4];
        v17 = v12[5];
        v18 = v12[6];
        *(_QWORD *)(i + 1664) = *((_QWORD *)v12 + 14);
        *(_OWORD *)(i + 1648) = v18;
        *(_OWORD *)(i + 1632) = v17;
        *(_OWORD *)(i + 1616) = v16;
        *(_QWORD *)(i + 128) = i + 1552;
        *(_QWORD *)(i + 136) = 0;
        *(_QWORD *)(i + 144) = 0;
        *(_QWORD *)(i + 152) = 0;
        *(_QWORD *)(i + 160) = 0x700000000;
        result = aj_istream_move_to_position(i + 1552, a4);
        if ((_DWORD)result)
          break;
        if (++v10 >= *(int *)(a1 + 6948) - 1)
          return 0;
      }
    }
  }
  return result;
}

uint64_t init_mcustate(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char *a5)
{
  uint64_t result;
  char v7;
  int v8;
  int v9;
  BOOL v10;

  if (!a4
    || *(_QWORD *)(a1 + 112) != a2
    || (v8 = *(_DWORD *)(a1 + 136), v9 = *(_DWORD *)(a1 + 80), v8 >= v9)
    && (v8 == v9 ? (v10 = *(_DWORD *)(a1 + 140) <= *(_DWORD *)(a1 + 84)) : (v10 = 0), !v10))
  {
    *(_QWORD *)(a1 + 112) = a2;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 144) = 0x700000000;
    result = aj_istream_move_to_position(a2, a3);
    if ((_DWORD)result)
      return result;
    v7 = 0;
    if (!a5)
      return 0;
LABEL_14:
    result = 0;
    *a5 = v7;
    return result;
  }
  if (a5)
  {
    v7 = 1;
    goto LABEL_14;
  }
  return 0;
}

uint64_t aj_init_decode_jobs(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v7;
  _DWORD *v9;
  int v11;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  _DWORD *v17;
  _QWORD *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  _DWORD *v23;
  int v24;
  int v25;
  uint64_t result;
  uint64_t v27;
  int v28;
  uint64_t v29;
  _QWORD *v30;
  _DWORD *v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  _DWORD *v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  int v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  _QWORD *v49;
  _BOOL4 v50;
  int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  _BOOL4 v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  BOOL v70;
  int v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  _DWORD *v77;
  _DWORD *v78;
  _DWORD *v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  char v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  _BOOL4 v87;
  _BOOL4 v88;
  unsigned int v89;
  int v90;
  int v91;
  _BYTE *v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95;
  __int128 v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  uint64_t v103;
  _DWORD *v104;
  _OWORD v105[3];
  uint64_t v106;
  uint64_t v107;

  v7 = a5;
  v9 = a2;
  v107 = *MEMORY[0x24BDAC8D0];
  v106 = 0;
  memset(v105, 0, sizeof(v105));
  v104 = a2;
  v11 = *(_DWORD *)(a1 + 6948);
  if (v11 < 2)
    goto LABEL_9;
  v13 = (v11 - 1);
  v14 = *(_QWORD *)(a4 + 32);
  if (v14)
    (*(void (**)(uint64_t, _QWORD))(a5 + 8))(v14, *(_QWORD *)(a5 + 16));
  v15 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))v7)(1672 * v13, *(_QWORD *)(v7 + 16));
  *(_QWORD *)(a1 + 6952) = v15;
  *(_QWORD *)(a4 + 32) = v15;
  if (v15)
  {
    bzero(v15, 1672 * v13);
    v16 = *(_QWORD *)(a1 + 6952);
    if (v16)
    {
      v17 = (_DWORD *)(v16 + 16);
      v18 = v105;
      do
      {
        *((_QWORD *)v17 - 1) = a1;
        *v17 = *v9;
        *v18++ = v17;
        v17 += 418;
        --v13;
      }
      while (v13);
      v11 = *(_DWORD *)(a1 + 6948);
LABEL_9:
      v19 = *(_DWORD *)(a1 + 6840);
      v20 = *(_DWORD *)(a1 + 6836);
      v21 = v19 - v20;
      if (*(_DWORD *)(a1 + 6960) == 1)
      {
        v22 = *(_DWORD *)(a1 + 168);
        if (v22 <= 8)
          v23 = (_DWORD *)((char *)&unk_206276B10 + 4 * v22 - 4);
        else
          v23 = &unk_206276B2C;
        v24 = *v23 * v21 / 100;
      }
      else
      {
        v24 = v21 / v11;
      }
      if (*(_DWORD *)(a1 + 6612))
        v25 = 1;
      else
        v25 = *(_DWORD *)(a1 + 172);
      v9[6] = v20;
      v27 = v11;
      if (v11 >= 2)
      {
        v28 = v24 + v20;
        v29 = v11 - 1;
        v30 = v105;
        do
        {
          v9[7] = v28;
          v31 = (_DWORD *)*v30++;
          v9 = v31;
          v31[6] = v28;
          v28 += v24;
          --v29;
        }
        while (v29);
      }
      v32 = __OFSUB__(v11, 1);
      v33 = (v11 - 1);
      (&v104)[(int)v33][7] = v19;
      if ((int)v33 < 0 == v32)
      {
        v34 = 0;
        v35 = *(_DWORD *)(a1 + 6844);
        v36 = *(_DWORD *)(a1 + 6628);
        v37 = a3 + 140;
        do
        {
          v38 = 0;
          v39 = (&v104)[v34];
          v40 = v39[6];
          v41 = v39[7];
          v39[20] = v40;
          v39[21] = v35;
          v42 = (v41 - v40) / v36;
          *(_QWORD *)(v39 + 15) = v42;
          if (!v34)
            v38 = *(_DWORD *)(a1 + 6856);
          v43 = v42 * v25;
          v39[18] = v38;
          v39[19] = v43;
          if (v34 == v33)
          {
            v39[19] = v43 - v25 + *(_DWORD *)(a1 + 6864);
            if (!v34)
              v40 = 0;
            v39[2] = v40;
            v41 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 84);
          }
          else
          {
            if (!v34)
              v40 = 0;
            v39[2] = v40;
          }
          v39[3] = v41;
          if (*v39)
          {
            v44 = *(_DWORD *)(a3 + 112);
            v45 = (v40 + v44 - 1) / v44;
            *(_QWORD *)(v39 + 13) = v45;
            v39[11] = v45 * v44;
            v39[12] = 0;
            *((_QWORD *)v39 + 2) = 0;
            if (*(_DWORD *)(a3 + 136) == 1)
            {
              v46 = 0;
              while (1)
              {
                v47 = *(unsigned __int16 *)(v37 + v46);
                if (v40 <= v47 && v41 > v47)
                  break;
                v46 += 24;
                if (v46 == 216)
                  goto LABEL_43;
              }
              *((_QWORD *)v39 + 2) = v37 + v46;
            }
          }
LABEL_43:
          v39[380] = v39[374];
          ++v34;
        }
        while (v34 != v27);
      }
      if (a6)
        return 0;
      v49 = (_QWORD *)(a1 + 6892);
      v50 = *(_DWORD *)(a1 + 24) == 2 && *(_DWORD *)(a1 + 48) > 1;
      v88 = *(_BYTE *)(a1 + 6937) && !*(_DWORD *)(a1 + 6940) && *(_DWORD *)(a1 + 6464) == 3;
      v51 = *(_DWORD *)(a1 + 6584);
      v52 = aj_highest_set_bit(*(_DWORD *)(a1 + 6892));
      v53 = aj_highest_set_bit(*(_DWORD *)(a1 + 6896));
      v54 = *(_DWORD *)(a1 + 6612) ? 1 : *(_DWORD *)(a1 + 172);
      v91 = v54;
      v55 = *(_DWORD *)(a1 + 6900);
      v103 = 0;
      LODWORD(v56) = *(_DWORD *)(a1 + 6948);
      if ((int)v56 <= 0)
        return 0;
      v57 = 0;
      v92 = (_BYTE *)(a1 + 6576);
      v90 = v53 - 1;
      v58 = (int)(v55 + v52 - 1) >> (v52 - 1);
      v59 = v88;
      v87 = v50;
      v89 = v55;
      while (1)
      {
        v60 = (uint64_t)(&v104)[v57];
        v61 = *(_DWORD *)(v60 + 60) * v91;
        *(_QWORD *)&v96 = *v49;
        *((_QWORD *)&v96 + 1) = __PAIR64__(v58, v55);
        v97 = v58;
        v98 = v58;
        v99 = v61;
        v100 = (v61 + v90) >> v90;
        v101 = v100;
        v102 = v100;
        *(_DWORD *)(v60 + 32) = v51;
        *(_DWORD *)(v60 + 36) = v51;
        if (v57)
        {
          if (v50)
          {
            v62 = HIDWORD(v103);
            if (v51 & 1 | HIDWORD(v103))
              goto LABEL_64;
          }
          else
          {
            v62 = HIDWORD(v103);
            if (HIDWORD(v103))
            {
LABEL_64:
              v63 = v7;
              if (v62 <= 1)
                v64 = 1;
              else
                v64 = v62;
              if (*(int *)(a1 + 6464) >= 1)
              {
                v65 = 0;
                do
                {
                  if (v65)
                    v66 = aj_highest_set_bit(DWORD1(v96)) - 1;
                  else
                    v66 = 0;
                  *(_DWORD *)(v60 + 1100 + 4 * v65++) = (v66 + v64) >> v66;
                }
                while (v65 < *(int *)(a1 + 6464));
              }
              v7 = v63;
              v67 = aj_bufferprocessor_append(a1, v60, v63, &aj_savefirst_processor, &v96);
              v49 = (_QWORD *)(a1 + 6892);
              v50 = v87;
              v59 = v88;
              if (!v67)
                return 6;
            }
          }
        }
        if (*(_BYTE *)(a1 + 6889) && !aj_bufferprocessor_append(a1, v60, v7, &aj_upsample422_processor, &v96))
          return 6;
        if (*(int *)(v60 + 72) > 0 || *(_DWORD *)(v60 + 76) < *(_DWORD *)(v60 + 60) * v91 || *(_DWORD *)(a1 + 6868))
        {
          if (!aj_bufferprocessor_append(a1, v60, v7, &aj_crop_processor, &v96))
            return 6;
        }
        else if (DWORD2(v96) != *(_DWORD *)(a1 + 6616))
        {
          DWORD2(v96) = *(_DWORD *)(a1 + 6616);
          v71 = aj_highest_set_bit(v96);
          v72 = 0;
          v73 = (*(_DWORD *)(a1 + 6616) + v71 - 1) >> (v71 - 1);
          do
          {
            *(_DWORD *)((char *)&v96 + v72 + 12) = v73;
            v72 += 4;
          }
          while (v72 != 12);
        }
        if (v59 && !aj_bufferprocessor_append(a1, v60, v7, &aj_rgb2yuv_processor, &v96))
          return 6;
        if (*(_BYTE *)(a1 + 6577) || *v92)
        {
          v68 = aj_bufferprocessor_append(a1, v60, v7, aj_resize_processor, &v96);
          if (!v68)
            return 6;
          aj_bufferproc_resize_get_blendrows(v68, a1, v60, (_DWORD *)&v103 + 1, &v103);
        }
        *(_QWORD *)&v93 = *(_QWORD *)(a1 + 6928);
        *((_QWORD *)&v93 + 1) = aj_icol_max_rows_out;
        v94 = 0;
        v95 = 0;
        if (!aj_bufferprocessor_append(a1, v60, v7, &v93, &v96))
          return 6;
        v51 += v99 + v103;
        if (v57 == (_DWORD)v56 - 1)
        {
          v69 = 1;
          v55 = v89;
        }
        else
        {
          v55 = v89;
          v70 = (v50 & v51 & 1) != 0 || *v92 != 0;
          v69 = !v70;
        }
        *(_BYTE *)(v60 + 1083) = v69;
        ++v57;
        v56 = *(int *)(a1 + 6948);
        if (v57 >= v56)
        {
          if ((int)v56 >= 1)
          {
            v74 = 0;
LABEL_101:
            v75 = *(_DWORD *)(a1 + 6464);
            if (v75 >= 1)
            {
              v76 = 0;
              v77 = (&v104)[v74];
              v78 = v77 + 38;
              v79 = v77 + 275;
              v80 = (uint64_t *)(a1 + 6712);
              do
              {
                v81 = *(v80 - 1) + (int)v79[v76];
                if (v81)
                {
                  result = aj_rowbuffer_add_block(v78, (uint64_t (**)(size_t, _QWORD))v7, *v80, v81, 0x10uLL);
                  if ((_DWORD)result)
                    return result;
                  v75 = *(_DWORD *)(a1 + 6464);
                }
                ++v76;
                v80 += 2;
              }
              while (v76 < v75);
            }
            v82 = 0;
            v83 = 1;
            while (1)
            {
              v84 = v83;
              v85 = a1 + 16 * v82;
              v86 = *(_QWORD *)(v85 + 6768);
              if (v86)
              {
                result = aj_rowbuffer_add_block((&v104)[v74] + 38, (uint64_t (**)(size_t, _QWORD))v7, *(_QWORD *)(v85 + 6776), v86, 4uLL);
                if ((_DWORD)result)
                  return result;
              }
              v83 = 0;
              v82 = 1;
              if ((v84 & 1) == 0)
              {
                result = 0;
                if (++v74 < *(int *)(a1 + 6948))
                  goto LABEL_101;
                return result;
              }
            }
          }
          return 0;
        }
      }
    }
  }
  aj_log_error((uint64_t)"DecodeInit", "Could not allocate thread instances");
  return 6;
}

uint64_t aj_rowbuffer_add_block(_DWORD *a1, uint64_t (**a2)(size_t, _QWORD), uint64_t a3, uint64_t a4, unint64_t a5)
{
  int v9;
  uint64_t result;
  uint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  size_t v17;
  size_t *v18;
  size_t v19;
  uint64_t *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;

  if (a1 && a2 && a3 && a4)
  {
    v9 = *a1;
    if ((int)*a1 < 10)
    {
      v11 = (uint64_t *)&a1[10 * v9 + 2];
      v12 = (8 * a4 + 15) & 0xFFFFFFFFFFFFFFF0;
      v13 = (a3 + 15) & 0xFFFFFFFFFFFFFFF0;
      v14 = v13 + 16;
      v15 = a5 >= v13 - a3;
      v16 = a5 - (v13 - a3);
      if (!v15)
        v16 = 0;
      v17 = v12 + v14 * a4 + v16;
      v11[4] = v17;
      v18 = (size_t *)(v11 + 4);
      v20 = v11 + 3;
      v19 = v11[3];
      if (v19)
      {
        a2[1](v19, a2[2]);
        v17 = *v18;
      }
      v21 = (void *)(*a2)(v17, a2[2]);
      *v20 = (uint64_t)v21;
      if (v21 && (bzero(v21, *v18), (v22 = *v20) != 0))
      {
        v23 = 0;
        v24 = (uint64_t)&a1[10 * v9 + 2];
        *(_QWORD *)(v24 + 16) = v22;
        v25 = (_QWORD *)(v24 + 16);
        v26 = v22 + v12;
        do
        {
          *(_QWORD *)(*v25 + 8 * v23++) = v26;
          v26 += v14;
        }
        while (a4 != v23);
        result = 0;
        *v11 = a4;
        *(_QWORD *)&a1[10 * v9 + 4] = a3;
        ++*a1;
      }
      else
      {
        return 6;
      }
    }
    else
    {
      aj_log_error(0, "Rowbuffermanager is full (%d blocks)", *a1);
      return 1;
    }
  }
  else
  {
    aj_log_error(0, "Illegal input to add_block: mgr=%p, mem=%p, len=%zu, rows=%zu\n", a1, a2, a3, a4);
    return 8;
  }
  return result;
}

uint64_t aj_bufferprocessor_append(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, __int128 *a5)
{
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  unsigned int (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *);

  v10 = (*(uint64_t (**)(uint64_t, _QWORD))a3)(88, *(_QWORD *)(a3 + 16));
  v11 = v10;
  if (v10)
  {
    *(_OWORD *)(v10 + 48) = 0u;
    *(_OWORD *)(v10 + 64) = 0u;
    *(_OWORD *)(v10 + 16) = 0u;
    *(_OWORD *)(v10 + 32) = 0u;
    *(_OWORD *)v10 = 0u;
    *(_QWORD *)(v10 + 80) = 0;
    v12 = a4[1];
    *(_OWORD *)v10 = *a4;
    *(_OWORD *)(v10 + 16) = v12;
    if (!*(_QWORD *)(v10 + 8))
      *(_QWORD *)(v10 + 8) = aj_bufferprocessor_maxoutrows_default;
    v13 = *a5;
    v14 = a5[1];
    *(_QWORD *)(v10 + 72) = *((_QWORD *)a5 + 4);
    *(_OWORD *)(v10 + 56) = v14;
    *(_OWORD *)(v10 + 40) = v13;
    v15 = (uint64_t *)(a2 + 1488);
    do
    {
      v16 = v15;
      v17 = *v15;
      v15 = (uint64_t *)(*v15 + 80);
    }
    while (v17);
    *v16 = v10;
    v18 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *))(v10 + 16);
    if (v18 && v18(v10, a1, a2, a3, a5))
      return 0;
  }
  return v11;
}

uint64_t aj_get_numthreads_decode(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  int v5;
  uint64_t v6;
  uint64_t v8;
  int v9;
  BOOL v10;
  int v11;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  BOOL v18;

  *a5 = 0;
  v5 = *(_DWORD *)(a1 + 6504);
  if (v5 / 32 < (int)a4)
  {
    a4 = (v5 / 32);
    if (v5 < 64)
      return 1;
  }
  if (*(_DWORD *)(a1 + 6580) == 14 || *(_BYTE *)(*(_QWORD *)a1 + 84))
    return 1;
  v6 = 1;
  if (a3 && !*(_BYTE *)(a1 + 17) && (int)a4 >= 2 && !*(_DWORD *)(a1 + 6612))
  {
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(_DWORD *)(v8 + 136);
    if ((v9 & 0xFFFFFFFE) == 2 && *(_QWORD *)(v8 + 96) && *(_QWORD *)(v8 + 104))
    {
      v10 = v9 == 2;
      v11 = *(_DWORD *)(v8 + 128);
      v13 = v10 || v11 < 3;
      v14 = *(_DWORD *)(a1 + 6812);
      if (v14)
        v14 = *(_DWORD *)(v8 + 112) > 1;
      if (!(v14 | v13))
      {
        if (v11 <= (int)a4)
          a4 = (v11 - 1);
        else
          a4 = a4;
        LODWORD(v6) = 3;
        goto LABEL_41;
      }
    }
    v15 = *(_DWORD *)(*(_QWORD *)a1 + 3404);
    if (!v15)
      goto LABEL_26;
    v16 = *(_DWORD *)(v8 + 80);
    if (*(_DWORD *)(a1 + 6812))
    {
      if (v16 < v15)
      {
LABEL_26:
        if (!*(_DWORD *)(a2 + 4))
          return 1;
        v6 = 1;
        if (*(_DWORD *)(a1 + 6812) | (*(_DWORD *)(a1 + 168) > 8))
          return v6;
        a4 = 2;
LABEL_41:
        *a5 = v6;
        return a4;
      }
    }
    else
    {
      v17 = *(_DWORD *)(v8 + 84) * v16 / v15;
      v18 = v17 < (int)a4;
      if (v17 >= (int)a4)
        a4 = a4;
      else
        a4 = v17;
      if (v18 && v17 <= 1)
        goto LABEL_26;
    }
    LODWORD(v6) = 2;
    goto LABEL_41;
  }
  return v6;
}

uint64_t aj_compute_helpers(uint64_t a1)
{
  int *v2;
  uint64_t result;
  int v4;
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  const float *v16;
  int32x2_t v17;
  _DWORD *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unint64_t v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  BOOL v49;
  BOOL v50;
  int v51;

  v2 = *(int **)a1;
  result = aj_get_format_description(*(_DWORD *)(a1 + 6580), a1 + 20);
  if (!(_DWORD)result)
  {
    v4 = *(unsigned __int8 *)(a1 + 6937);
    if (*(_BYTE *)(a1 + 6937))
      v4 = *(_DWORD *)(a1 + 6940) == 0;
    if (*(_DWORD *)(a1 + 20) == 1 && v4 == 0)
      v6 = 1;
    else
      v6 = **(_DWORD **)a1;
    *(_DWORD *)(a1 + 6464) = v6;
    *(_DWORD *)(a1 + 6468) = 0;
    v7 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 88);
    *(_DWORD *)(a1 + 6472) = v7;
    *(int32x2_t *)(a1 + 6476) = vadd_s32(vdup_n_s32(v7), (int32x2_t)0x200000001);
    v8 = *(unsigned int *)(a1 + 6484);
    v9 = *(_DWORD *)(a1 + 6484) & 1;
    v10 = *(_DWORD *)(a1 + 44);
    v11 = *(_DWORD *)(a1 + 48);
    if (v10 <= 1)
      v9 = 0;
    *(_DWORD *)(a1 + 6492) = v8 + v9;
    v12 = *(_DWORD *)(a1 + 6488);
    if (v11 <= 1)
    {
      *(_DWORD *)(a1 + 6496) = v12;
    }
    else
    {
      *(_DWORD *)(a1 + 6496) = (*(_DWORD *)(a1 + 6488) & 1) + *(_DWORD *)(a1 + 6488);
      v13 = *(_DWORD *)(a1 + 6504);
      if ((v13 & 1) != 0 && v13 < v12)
        *(_DWORD *)(a1 + 6504) = v13 + 1;
    }
    v14 = *(_DWORD *)(a1 + 6500);
    if (v10 >= 2 && (v14 & 1) != 0 && v14 < (int)v8)
      *(_DWORD *)(a1 + 6500) = ++v14;
    compute_padding(v8, v14, v10, (unsigned int *)(a1 + 6592));
    *(_DWORD *)(a1 + 6596) = *(_DWORD *)(a1 + 6492) - (*(_DWORD *)(a1 + 6500) + *(_DWORD *)(a1 + 6592));
    compute_padding(*(unsigned int *)(a1 + 6488), *(_DWORD *)(a1 + 6504), *(_DWORD *)(a1 + 48), (unsigned int *)(a1 + 6584));
    v15 = *(_DWORD *)(a1 + 6504);
    *(_DWORD *)(a1 + 6588) = *(_DWORD *)(a1 + 6496) - (v15 + *(_DWORD *)(a1 + 6584));
    v16 = (const float *)(a1 + 28);
    v17 = (int32x2_t)vld1_dup_f32(v16);
    *(int32x2_t *)(a1 + 6600) = vmul_s32(*(int32x2_t *)(a1 + 6592), v17);
    v18 = *(_DWORD **)(a1 + 8);
    v19 = *(_DWORD *)(a1 + 168);
    v21 = v18[18];
    v20 = v18[19];
    *(_DWORD *)(a1 + 172) = v20 / v19;
    *(_DWORD *)(a1 + 176) = v21 / v19;
    v22 = *(_DWORD *)(a1 + 6612);
    if (v22)
      v23 = 1 << (v22 + 3);
    else
      v23 = v19;
    v24 = *(_DWORD *)(a1 + 6828) / v23;
    v25 = *(_DWORD *)(a1 + 6832) / v23;
    v26 = *(_DWORD *)(a1 + 6824);
    v27 = v26 / v20;
    v28 = v26 % v20;
    v29 = (v23 - 1 + v20 - v26 % v20) / v23;
    if (v29 >= v25)
      v30 = *(_DWORD *)(a1 + 6832) / v23;
    else
      v30 = v29;
    v31 = *(_DWORD *)(a1 + 6820);
    v32 = v31 / v21;
    v33 = v31 % v21;
    v34 = (v23 - 1 + v21 - v31 % v21) / v23;
    if (v34 >= v24)
      v35 = *(_DWORD *)(a1 + 6828) / v23;
    else
      v35 = v34;
    v36 = v25 - v30;
    v37 = v24 - v35;
    v38 = (v21 - 1 + (v24 - v35) * v23) / v21;
    v39 = v38 + v32 + (v23 + v21 - 1) / v21;
    *(_DWORD *)(a1 + 6836) = v27;
    *(_DWORD *)(a1 + 6840) = (v20 - 1 + v36 * v23) / v20 + v27 + (v23 + v20 - 1) / v20;
    *(_DWORD *)(a1 + 6844) = v32;
    *(_DWORD *)(a1 + 6848) = v39;
    v40 = (v38 + (v23 + v21 - 1) / v21) * v21;
    if (v39 == v18[20])
    {
      v41 = *(_DWORD *)(*(_QWORD *)a1 + 8) % v21;
      if (v41)
        v40 -= v21 - v41;
    }
    *(_DWORD *)(a1 + 6900) = v40 / v23;
    *(_DWORD *)(a1 + 6616) = v24;
    *(_DWORD *)(a1 + 6620) = v25;
    *(_DWORD *)(a1 + 6624) = v22;
    v42 = 1;
    if (v22 >= 1)
      v42 = (1 << v22) / *(_DWORD *)(*(_QWORD *)a1 + 32);
    *(_DWORD *)(a1 + 6628) = v42;
    v43 = v33 / v23;
    *(_DWORD *)(a1 + 6852) = v43;
    *(_DWORD *)(a1 + 6856) = v28 / v23;
    if (v21 <= v23)
    {
      v44 = 1;
    }
    else if (v24 <= v34)
    {
      v44 = v43 + v24;
    }
    else
    {
      v44 = v21 / v23;
      if (v37 % v44)
        v44 = v37 % v44;
    }
    *(_DWORD *)(a1 + 6860) = v44;
    if (v20 <= v23)
    {
      v45 = 1;
    }
    else if (v25 <= v29)
    {
      v45 = v28 / v23 + v25;
    }
    else
    {
      v45 = v20 / v23;
      if (v36 % v45)
        v45 = v36 % v45;
    }
    *(_DWORD *)(a1 + 6864) = v45;
    v46 = *(_DWORD *)(a1 + 6500);
    *(_BYTE *)(a1 + 6577) = v24 != v46;
    *(_BYTE *)(a1 + 6576) = v25 != v15;
    v47 = *(_DWORD *)(*(_QWORD *)a1 + 4);
    if (v47 <= 8)
    {
      v49 = v24 != v46 || v25 != v15;
      if (*(_BYTE *)(*(_QWORD *)a1 + 86) && v49)
        goto LABEL_59;
    }
    else if (v24 != v46 || v25 != v15)
    {
LABEL_59:
      aj_log_error((uint64_t)"DecodeInit", "Resizing is not supported for 12-bit or lossless jpegs");
      return 3;
    }
    v50 = *v2 == 3 && v2[4] == 2 && v2[8] == 2;
    result = 0;
    *(_BYTE *)(a1 + 18) = v50;
    if (v47 <= 8)
      v51 = 1;
    else
      v51 = 2;
    *(_DWORD *)(a1 + 6800) = v51;
  }
  return result;
}

uint64_t compute_padding(uint64_t result, int a2, int a3, unsigned int *a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;

  v4 = result - a2;
  v5 = result - a2 + 1;
  if (v5 >= 0)
    v6 = v4 + 1;
  else
    v6 = result - a2 + 2;
  v7 = v6 >> 1;
  if (v4 >= 0)
    v8 = result - a2;
  else
    v8 = v4 + 1;
  v9 = ((v8 >> 1) & 1) + (v8 >> 1);
  if (a3 >= 2)
    v7 = v9;
  if (v4 >= 0)
    v10 = result - a2;
  else
    v10 = v4 + 1;
  v11 = v10 >> 1;
  if (v5 >= 0)
    v12 = v4 + 1;
  else
    v12 = result - a2 + 2;
  v13 = (v12 >> 1) & 0xFFFFFFFE;
  if (a3 < 2)
    v13 = v11;
  if ((result & 1) == 0)
    v13 = v7;
  *a4 = v13;
  return result;
}

uint64_t aj_compute_buffer_sizes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int *v24;
  _QWORD *v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;

  if (*(_DWORD *)(a2 + 6612))
  {
    v8 = *(_DWORD *)(*(_QWORD *)a2 + 16) * *(_DWORD *)(*(_QWORD *)(a2 + 8) + 80);
    if (*(_DWORD *)(a2 + 6464) == 1)
      v9 = 0;
    else
      v9 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 80);
    v10 = v8 + v9 * (*(_DWORD *)(a2 + 6464) - 1);
    *(_DWORD *)(a2 + 6640) = v10;
    v11 = *(_QWORD *)(a1 + 24);
    if (v11)
    {
      (*(void (**)(uint64_t, _QWORD))(a4 + 8))(v11, *(_QWORD *)(a4 + 16));
      v10 = *(_DWORD *)(a2 + 6640);
    }
    v12 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a4)(4 * v10, *(_QWORD *)(a4 + 16));
    *(_QWORD *)(a2 + 6632) = v12;
    *(_QWORD *)(a1 + 24) = v12;
    if (!v12)
      return 6;
    bzero(v12, 4 * *(int *)(a2 + 6640));
    if (!*(_QWORD *)(a1 + 24))
      return 6;
    v13 = *(_QWORD *)(a2 + 6632);
    *(_QWORD *)(a2 + 6648) = v13;
    v14 = v13 + 4 * v8;
    *(_QWORD *)(a2 + 6656) = v14;
    v15 = v14 + 4 * v9;
    *(_QWORD *)(a2 + 6664) = v15;
    *(_QWORD *)(a2 + 6672) = v15 + 4 * v9;
  }
  v16 = *(_DWORD *)(a2 + 6580);
  if ((v16 - 25) < 2)
    return 0;
  if (v16 == 14)
  {
    aj_reset_texture_buffer_ptrs((unsigned int **)a2, a3 + 568, a2 + 64);
    result = 0;
    *(_BYTE *)(a2 + 6945) = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 6945) = 1;
    v19 = *(int *)(a2 + 172);
    v18 = *(int *)(a2 + 176);
    *(_DWORD *)(a2 + 6684) = v19;
    v20 = *(int *)(a2 + 6848) - (uint64_t)*(int *)(a2 + 6844);
    v21 = *(_QWORD *)(a2 + 6704) + v19;
    *(_QWORD *)(a2 + 6704) = v21;
    v22 = v20 * v18 * *(int *)(a2 + 6800);
    *(_QWORD *)(a2 + 6712) = v22;
    v23 = *(unsigned int *)(a2 + 6464);
    if ((int)v23 >= 2)
    {
      v24 = (int *)(a2 + 6688);
      v25 = (_QWORD *)(a2 + 6720);
      v26 = v23 - 1;
      do
      {
        v27 = (int)v19 / *(_DWORD *)(a2 + 6896);
        *v24++ = v27;
        v28 = v22 / *(int *)(a2 + 6892);
        *v25 += v27;
        v25[1] = v28;
        v25 += 2;
        --v26;
      }
      while (v26);
    }
    if (*(_DWORD *)(a2 + 24) == 2)
    {
      v29 = *(int *)(a2 + 48);
      if ((int)v29 >= 2)
      {
        *(_QWORD *)(a2 + 6704) = v21 + 1;
        if ((_DWORD)v23 == 3)
        {
          if (*(_BYTE *)(a2 + 6889))
          {
            *(_QWORD *)(a2 + 6704) = v21 + 3;
          }
          else
          {
            ++*(_QWORD *)(a2 + 6720);
            ++*(_QWORD *)(a2 + 6736);
          }
        }
      }
      if (!*(_DWORD *)(a2 + 6804))
        return 0;
      result = 0;
      *(_QWORD *)(a2 + 6768) = v29;
      v31 = *(int *)(a2 + 6492);
      *(_QWORD *)(a2 + 6776) = v31;
      *(_QWORD *)(a2 + 6784) = 1;
      *(_QWORD *)(a2 + 6792) = 2 * ((int)v31 / *(_DWORD *)(a2 + 44));
    }
    else
    {
      if (!*(_DWORD *)(a2 + 6804))
        return 0;
      *(_QWORD *)(a2 + 6768) = 1;
      if ((_DWORD)v23 == 3 && !*(_DWORD *)(a2 + 6884))
        *(_QWORD *)(a2 + 6768) = 2;
      result = 0;
      if (*(_DWORD *)(a2 + 44) == 2)
        v30 = *(_DWORD *)(a2 + 6500) & 1;
      else
        v30 = 0;
      *(_QWORD *)(a2 + 6776) = *(int *)(a2 + 28) * (uint64_t)(*(_DWORD *)(a2 + 6500) + v30);
    }
  }
  return result;
}

uint64_t aj_dct_prescale_qtable(uint64_t result, uint64_t a2)
{
  uint64_t i;

  for (i = 0; i != 64; ++i)
    *(_WORD *)(a2 + 2 * i) = dword_20627BB84[8 * (i >> 3) + (i & 7)] / *(_DWORD *)(result + 4 * i);
  return result;
}

uint64_t aj_idct_s4_2x4_nearest(unsigned int *a1, _QWORD *a2, uint64_t a3)
{
  int16x8_t v3;
  unsigned int v4;
  _DWORD *v5;
  int64x2_t v6;
  int32x2_t v7;
  int16x8_t v8;
  unint64_t v9;
  int16x8_t v10;

  v3.i64[0] = 0x400040004000400;
  v3.i64[1] = 0x400040004000400;
  v4 = a1[4];
  v5 = (_DWORD *)(a2[1] + a3);
  v6 = (int64x2_t)vaddq_s16((int16x8_t)*a1, (int16x8_t)v4);
  v7 = (int32x2_t)vsubq_s16(vtrn1q_s16((int16x8_t)*a1, (int16x8_t)v4), vtrn2q_s16((int16x8_t)*a1, (int16x8_t)v4)).u64[0];
  v8 = vsubq_s16((int16x8_t)*a1, (int16x8_t)v4);
  LODWORD(v9) = 0;
  WORD2(v9) = 0;
  HIWORD(v9) = v7.i16[1];
  v8.i16[2] = v7.i16[0];
  *(int32x2_t *)v6.i8 = vzip1_s32(*(int32x2_t *)v6.i8, v7);
  v10 = (int16x8_t)vzip1q_s64(v6, (int64x2_t)vsubq_s16(v8, (int16x8_t)v9));
  *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vpaddq_s16(v10, v10), v3), 3uLL);
  *(int8x8_t *)v10.i8 = vzip1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8);
  *(_DWORD *)(*a2 + a3) = v10.i32[0];
  *v5 = v10.i32[1];
  return 4;
}

uint64_t aj_block_pack(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t *v6;
  uint64_t v7;
  __int16 *v8;
  __int16 *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  int v15;
  __int16 v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v25;
  BOOL v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  BOOL v30;
  char v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  signed int v45;
  signed int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t *v56;
  int v57;
  int v58;
  signed int v59;
  uint64_t v60;
  signed int v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  _BOOL4 v67;
  _BOOL4 v68;
  unsigned int v69;
  char v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  unsigned __int16 v76[64];
  __int128 v77;
  __int16 *v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v6 = a1 + 5578;
  v77 = xmmword_24BEFBB80;
  v78 = &zero_block;
  v7 = *a1;
  *(_OWORD *)(v7 + 50) = 0u;
  *(_OWORD *)(v7 + 35) = 0u;
  *(_OWORD *)(v7 + 19) = 0u;
  *(_OWORD *)(v7 + 3) = 0u;
  *(_DWORD *)a1[5614] = 0;
  v8 = (__int16 *)a1[1];
  if (v8)
    *(_QWORD *)&v77 = a1[1];
  else
    v8 = &zero_block;
  v9 = (__int16 *)a1[2];
  if (v9)
    *((_QWORD *)&v77 + 1) = a1[2];
  else
    v9 = &zero_block;
  v10 = (__int16 *)a1[3];
  if (v10)
    v78 = (__int16 *)a1[3];
  else
    v10 = &zero_block;
  v11 = a1[5615];
  v74 = 0;
  LODWORD(v75) = 0;
  result = aj_huffman_decode_val(*(_QWORD *)(v11 + 32), a2, 0, (int *)&v75);
  if ((_DWORD)result)
    return result;
  v15 = *a3 + SWORD1(v75);
  *a3 = v15;
  LODWORD(v75) = v15;
  result = aj_huffman_decode_ac_s1(v11, a2, v76, &v74, v13, v14);
  if ((_DWORD)result)
    return result;
  v16 = v75;
  v76[0] = v75;
  *(_WORD *)v7 = v75;
  if (v16 >= 0)
    v17 = v16;
  else
    v17 = -v16;
  if (v17 < 0x800)
  {
    v18 = 63;
    while (!v76[v18])
    {
      v26 = v18-- != 0;
      if (v18 == 0 || !v26)
      {
        v18 = 0;
        break;
      }
    }
    *(_BYTE *)(v7 + 2) = v18;
    v19 = *((unsigned __int8 *)v8 + 2);
    v20 = *((unsigned __int8 *)v9 + 2);
    v21 = *((unsigned __int8 *)v10 + 2);
    v22 = v20 + v19 - v21;
    if ((int)v19 <= (int)v20)
      v23 = *((unsigned __int8 *)v9 + 2);
    else
      v23 = *((unsigned __int8 *)v8 + 2);
    if (v21 <= v19 && v21 <= v20)
      v22 = v23;
    if ((int)v19 >= (int)v20)
      v25 = *((unsigned __int8 *)v9 + 2);
    else
      v25 = *((unsigned __int8 *)v8 + 2);
    v26 = v21 >= v19 && v21 >= v20;
    if (v26)
      v27 = v25;
    else
      v27 = v22;
    v75 = a1[((int)(v27 + ((unsigned __int16)(v27 & 0xC000) >> 14)) >> 2) + 18];
    v28 = (v21 & 0xFFFFFFF8) + 8;
    v29 = 11 * (v18 / 8);
    v30 = v18 == 0;
    if (v18)
      v31 = v18 / 8 + 1;
    else
      v31 = 0;
    if (v30)
      v32 = 88;
    else
      v32 = v29;
    if (v30)
      v33 = 1;
    else
      v33 = v28;
    LOBYTE(v74) = v31;
    result = (*(uint64_t (**)(uint64_t, uint64_t *, int *, uint64_t))(a1[5] + 40))(a1[4], &v75, &v74, 1);
    if (!(_DWORD)result)
    {
      v34 = *v8;
      v35 = *v9;
      v36 = *v10;
      if (v36 < v34 || v36 < v35)
      {
        if ((__int16)v36 > v34 || (__int16)v36 > v35)
        {
          LOWORD(v35) = v35 + v34 - v36;
        }
        else if (v34 > v35)
        {
          LOWORD(v35) = *v8;
        }
      }
      else if (v34 < v35)
      {
        LOWORD(v35) = *v8;
      }
      v37 = v76[0];
      v38 = (__int16)(v76[0] - v35);
      v76[0] -= v35;
      v39 = *v10;
      v40 = v34 - v39;
      if (v40 < 0)
        v40 = -v40;
      v41 = *v9 - v39;
      if (v41 < 0)
        v41 = -v41;
      v42 = v41 + v40;
      v43 = 32 - __clz(v42 >> 1);
      v44 = v42 >= 2 ? v43 : 0;
      v75 = a1[v44 + 6];
      v45 = *(_DWORD *)v6;
      v46 = v38 >= 0 ? v38 : -v38;
      v47 = __clz(v46);
      v48 = 32 - v47;
      v49 = (-1 << -(char)v47) | v46;
      v50 = v38 < 0 ? ~v49 : v46;
      v51 = v37 == (unsigned __int16)v35 ? 0 : v50;
      v52 = v37 == (unsigned __int16)v35 ? 0 : v48;
      if (v46 >= v45)
      {
        v46 = v45 + v52 + ~*((_DWORD *)v6 + 1);
      }
      else
      {
        v51 = v38 >> 31;
        v52 = v37 != (unsigned __int16)v35;
      }
      LOBYTE(v74) = v46;
      result = (*(uint64_t (**)(uint64_t, uint64_t *, int *, uint64_t))(a1[5] + 40))(a1[4], &v75, &v74, 1);
      if (!(_DWORD)result)
      {
        if (!v52
          || (result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1[5] + 56))(a1[4], v51, v52), !(_DWORD)result))
        {
          if (v33 >= 2)
          {
            v53 = 0;
            v54 = 0;
            v55 = (v33 - 1);
            v56 = a1 + 34;
            v57 = 32;
            do
            {
              v58 = (__int16)v76[v53 + 1];
              if (v58 >= 0)
                v59 = (__int16)v76[v53 + 1];
              else
                v59 = -v58;
              if (v59 >= 0x400)
              {
                aj_log_error(0, "Illegal ac value: %d");
                return 7;
              }
              v60 = v56[v32 + *(unsigned __int8 *)(*((_QWORD *)&v77 + nbr_ind[v53]) + v53 + 3)];
              v61 = *((_DWORD *)v6 + 2);
              v62 = v58 >> 31;
              v63 = __clz(v59);
              v64 = 32 - v63;
              v65 = (-1 << -(char)v63) | v59;
              if (v58 < 0)
                v66 = ~v65;
              else
                v66 = v59;
              if (!v76[v53 + 1])
              {
                v66 = 0;
                v64 = 0;
              }
              v67 = v58 != 0;
              if (v59 < v61)
                v68 = v67;
              else
                v68 = v64;
              if (v59 < v61)
                v69 = v62;
              else
                v69 = v66;
              if (v59 >= v61)
                LOBYTE(v59) = v61 + v64 + ~*((_DWORD *)v6 + 3);
              *(_BYTE *)(v7 + 3 + v53) = v64;
              *(_BYTE *)(v6[34] + v53) = v59;
              *(_QWORD *)(v6[35] + 8 * v53) = v60;
              if (v68)
              {
                v70 = v68;
                v71 = v6[36];
                v72 = v54;
                v62 = *(unsigned int *)(v71 + 4 * v54);
                if (v57 >= v68)
                {
                  v57 -= v68;
                }
                else
                {
                  *(_DWORD *)(v71 + 4 * v54) = ((_DWORD)v62 << v57) | (v69 >> (v68 - v57));
                  v72 = v54 + 1;
                  *(_DWORD *)(v71 + 4 * v72) = 0;
                  v70 = v68 - v57;
                  v57 = 32 - (v68 - v57);
                  v69 &= 0xFFFFFFFF >> -v70;
                  ++v54;
                  v62 = 0;
                }
                *(_DWORD *)(v71 + 4 * v72) = ((_DWORD)v62 << v70) | v69;
              }
              ++v53;
              v56 += 88;
            }
            while (v55 != v53);
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1[5] + 40))(a1[4], v6[35], v6[34], v55, v62);
            if ((_DWORD)result)
              return result;
            if (v54 >= 1)
            {
              v73 = 0;
              do
              {
                result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1[5] + 56))(a1[4], *(unsigned int *)(v6[36] + v73), 32);
                if ((_DWORD)result)
                  return result;
                v73 += 4;
              }
              while (4 * v54 != v73);
            }
            if (v57 <= 31)
            {
              result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1[5] + 56))(a1[4], *(unsigned int *)(v6[36] + 4 * v54), (32 - v57));
              if ((_DWORD)result)
                return result;
            }
          }
          return 0;
        }
      }
    }
  }
  else
  {
    aj_log_error(0, "Illegal dc value: %d");
    return 7;
  }
  return result;
}

uint64_t aj_block_unpack(uint64_t *a1, int32x2_t *a2, _DWORD *a3)
{
  uint64_t v6;
  __int16 *v7;
  __int16 *v8;
  __int16 *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t result;
  unint64_t v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int *v23;
  int v24;
  int v25;
  __int16 v26;
  int v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  signed int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  _BYTE *v47;
  __int16 *v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  char v57;
  unsigned int v58;
  int v59;
  _DWORD *v60;
  unsigned __int8 v61;
  uint64_t v62;
  unsigned int v63;
  _OWORD v64[8];
  __int128 v65;
  __int16 *v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v66 = &zero_block;
  v6 = *a1;
  v65 = xmmword_24BEFBB80;
  memset(v64, 0, sizeof(v64));
  *(_OWORD *)(v6 + 50) = 0u;
  *(_OWORD *)(v6 + 35) = 0u;
  *(_OWORD *)(v6 + 19) = 0u;
  *(_OWORD *)(v6 + 3) = 0u;
  v7 = (__int16 *)a1[1];
  if (v7)
    *(_QWORD *)&v65 = a1[1];
  else
    v7 = &zero_block;
  v8 = (__int16 *)a1[2];
  if (v8)
    *((_QWORD *)&v65 + 1) = a1[2];
  else
    v8 = &zero_block;
  v9 = (__int16 *)a1[3];
  if (v9)
    v66 = (__int16 *)a1[3];
  else
    v9 = &zero_block;
  v10 = *((unsigned __int8 *)v7 + 2);
  v11 = *((unsigned __int8 *)v8 + 2);
  v12 = *((unsigned __int8 *)v9 + 2);
  if (v12 < v10 || v12 < v11)
  {
    if (v12 > v10 || v12 > v11)
    {
      v10 = v11 + v10 - v12;
    }
    else if ((int)v10 <= (int)v11)
    {
      v10 = *((unsigned __int8 *)v8 + 2);
    }
  }
  else if ((int)v10 >= (int)v11)
  {
    v10 = *((unsigned __int8 *)v8 + 2);
  }
  LOBYTE(v62) = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t))(a1[5] + 48))(a1[4], &a1[((int)(v10 + ((unsigned __int16)(v10 & 0xC000) >> 14)) >> 2) + 18], &v62, 1);
  if (!(_DWORD)result)
  {
    v14 = v62;
    if ((_BYTE)v62)
    {
      v15 = 8 * v62;
      if ((8 * v62) >= 0x41u)
        return 7;
    }
    else
    {
      v15 = 1;
    }
    v60 = a3;
    v61 = 0;
    v16 = *v9;
    v17 = *v7 - v16;
    if (v17 < 0)
      v17 = v16 - *v7;
    v18 = *v8 - v16;
    if (v18 < 0)
      v18 = -v18;
    v19 = v18 + v17;
    v20 = v19 >> 1;
    v21 = 32 - __clz(v19 >> 1);
    v22 = v19 >= 2 ? v21 : 0;
    v63 = v20;
    v62 = a1[v22 + 6];
    result = (*(uint64_t (**)(uint64_t, uint64_t *, unsigned __int8 *, uint64_t))(a1[5] + 48))(a1[4], &v62, &v61, 1);
    if (!(_DWORD)result)
    {
      v23 = (int *)(a1 + 5578);
      LOWORD(v24) = v61;
      if (v61)
      {
        if (v61 < *v23)
        {
          result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(a1[5] + 64))(a1[4], &v63, 1);
          if ((_DWORD)result)
            return result;
          if (v63)
            v24 = -v61;
          else
            LOWORD(v24) = v61;
        }
        else
        {
          v25 = *((_DWORD *)a1 + 11157) + v61 - *v23;
          result = (*(uint64_t (**)(uint64_t, unsigned int *, _QWORD))(a1[5] + 64))(a1[4], &v63, (v25 + 1));
          if ((_DWORD)result)
            return result;
          if (v63 >> v25)
            v26 = 0;
          else
            v26 = (-2 << v25) | 1;
          LOWORD(v24) = v26 + v63;
        }
      }
      v27 = *v7;
      v28 = *v8;
      v29 = *v9;
      if (v29 < v27 || v29 < v28)
      {
        if ((__int16)v29 > v27 || (__int16)v29 > v28)
        {
          LOWORD(v27) = v28 + v27 - v29;
        }
        else if (v27 <= v28)
        {
          LOWORD(v27) = *v8;
        }
      }
      else if (v27 >= v28)
      {
        LOWORD(v27) = *v8;
      }
      LOWORD(v64[0]) = v24 + v27;
      *(_WORD *)v6 = v24 + v27;
      v30 = (unsigned __int8 *)a1[5612];
      LODWORD(v62) = 0;
      v31 = a1[5614];
      if (v15 >= 2u)
      {
        v32 = 0;
        if (v14 <= 1)
          v33 = 1;
        else
          v33 = v14;
        v34 = (uint64_t)&a1[11 * v33 + 23];
        do
        {
          *(_QWORD *)(a1[5613] + 8 * v32) = *(_QWORD *)(v34
                                                      + 8
                                                      * *(unsigned __int8 *)(*((_QWORD *)&v65
                                                                             + nbr_ind[v32])
                                                                           + v32
                                                                           + 3));
          ++v32;
          v34 += 704;
        }
        while (v15 - 1 != v32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, _QWORD))(a1[5] + 48))(a1[4], a1[5613], v30, v15 - 1);
      if (!(_DWORD)result)
      {
        if (v15 <= 1u)
        {
          *(_BYTE *)(v6 + 2) = 0;
LABEL_94:
          aj_block_encode(a1[5615], (__int16 *)v64, a2, v60);
          return 0;
        }
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = v6 + 3;
        do
        {
          v39 = v30[v35];
          if (v30[v35])
          {
            *((_WORD *)v64 + v35 + 1) = v39;
            v40 = *((_DWORD *)a1 + 11158);
            v36 = v35 + 1;
            if (v40 <= v39)
            {
              v39 = v39 - v40 + *((_DWORD *)a1 + 11159) + 1;
              *(_BYTE *)(v38 + v35) = v39;
              v37 = (v39 + v37);
            }
            else
            {
              LODWORD(v62) = v39;
              *(_BYTE *)(v38 + v35) = 32 - __clz(v39);
              v37 = (v37 + 1);
              LOBYTE(v39) = 1;
            }
          }
          v30[v35++] = v39;
        }
        while (v15 - 1 != v35);
        *(_BYTE *)(v6 + 2) = v36;
        if (!(_DWORD)v37)
        {
LABEL_79:
          if (v36 >= 1)
          {
            LODWORD(v45) = 0;
            v46 = (v36 + 1) - 1;
            v47 = (_BYTE *)(v6 + 3);
            v48 = (__int16 *)v64 + 1;
            v49 = 32;
            do
            {
              v50 = *v48;
              if (*v48)
              {
                v51 = *v30;
                v52 = (int)v45;
                v53 = *(_DWORD *)(v31 + 4 * (int)v45);
                v54 = v53 >> -(char)v51;
                if (v49 >= v51)
                {
                  *(_DWORD *)(v31 + 4 * (int)v45) = v53 << v51;
                  v49 -= v51;
                }
                else
                {
                  v45 = (int)v45 + 1;
                  v55 = *(_DWORD *)(v31 + 4 * (v52 + 1));
                  v56 = v51 - v49;
                  v49 = 32 - v56;
                  v54 |= v55 >> -(char)v56;
                  *(_DWORD *)(v31 + 4 * v45) = v55 << v56;
                }
                if (*((_DWORD *)a1 + 11158) <= v50)
                {
                  v57 = *v47 - 1;
                  v58 = v54 >> v57;
                  v50 = v54 + (-2 << v57);
                  if (v58)
                    LOWORD(v50) = v54;
                  else
                    LOWORD(v50) = v50 + 1;
                }
                else if (v54)
                {
                  v50 = -v50;
                }
                *v48 = v50;
              }
              ++v47;
              ++v30;
              ++v48;
              --v46;
            }
            while (v46);
          }
          goto LABEL_94;
        }
        v59 = v36;
        if ((int)v37 >= 33)
        {
          v41 = 0;
          v42 = v37;
          while (1)
          {
            result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1[5] + 64))(a1[4], &v62, 32);
            if ((_DWORD)result)
              return result;
            v43 = v41 + 1;
            *(_DWORD *)(v31 + 4 * v41) = v62;
            v37 = (v42 - 32);
            ++v41;
            v44 = v42 <= 64;
            v42 -= 32;
            if (v44)
              goto LABEL_77;
          }
        }
        v43 = 0;
LABEL_77:
        result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1[5] + 64))(a1[4], &v62, v37);
        if (!(_DWORD)result)
        {
          *(_DWORD *)(v31 + 4 * v43) = (_DWORD)v62 << -(char)v37;
          v36 = v59;
          goto LABEL_79;
        }
      }
    }
  }
  return result;
}

uint64_t AJReducerGetAPIVersionNumber()
{
  return 1;
}

BOOL AJReducerIsFilePacked(const __CFURL *a1)
{
  FILE *v1;
  FILE *v2;
  _BOOL8 v3;
  int __ptr;
  UInt8 buffer[1024];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to resolve url");
    return 0;
  }
  v1 = fopen((const char *)buffer, "rb");
  if (!v1)
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to open file: %s");
    return 0;
  }
  v2 = v1;
  v3 = fread(&__ptr, 1uLL, 4uLL, v1) == 4 && applejpeg_reduce_is_reduced_jpeg(&__ptr, 4uLL);
  fclose(v2);
  return v3;
}

BOOL AJReducerIsDataPacked(const __CFData *a1)
{
  UInt8 *BytePtr;
  CFIndex Length;

  BytePtr = (UInt8 *)CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  return applejpeg_reduce_is_reduced_jpeg(BytePtr, Length);
}

void *AJReducerCreate()
{
  return malloc_type_calloc(1uLL, 0x50uLL, 0x1060040C12426CFuLL);
}

void AJReducerRelease(void *a1)
{
  AJReducerCloseSource((uint64_t)a1);
  free(a1);
}

uint64_t AJReducerCloseSource(uint64_t result)
{
  uint64_t *v1;
  _QWORD *v2;
  const void *v3;

  if (result)
  {
    v1 = (uint64_t *)result;
    v2 = *(_QWORD **)(result + 32);
    if (v2)
    {
      applejpeg_reduce_close(v2);
      v1[4] = 0;
    }
    v3 = (const void *)v1[3];
    if (v3)
    {
      CFRelease(v3);
      v1[3] = 0;
    }
    result = *v1;
    if (*v1)
    {
      result = fclose((FILE *)result);
      *v1 = 0;
    }
  }
  return result;
}

uint64_t AJReducerOpenSourceData(uint64_t a1, CFTypeRef cf, int *a3)
{
  uint64_t result;
  int v6;
  BOOL *v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned int v10;
  _QWORD v11[3];

  BytePtr = 0;
  Length = 0;
  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer session is NULL", BytePtr, Length);
LABEL_10:
    v6 = 4;
    goto LABEL_11;
  }
  if (!cf)
  {
    aj_log_error((uint64_t)"CFReduce", "Input source is NULL", BytePtr, Length);
    goto LABEL_10;
  }
  if (*(_QWORD *)(a1 + 32) || *(_QWORD *)(a1 + 24) || *(_QWORD *)a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Source is already open. Close must be called before source can be reopened.", BytePtr, Length);
    result = 0;
    if (a3)
      *a3 = 17;
    return result;
  }
  *(_QWORD *)(a1 + 24) = cf;
  CFRetain(cf);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
  v11[0] = mallocCallback;
  v11[1] = freeCallback;
  v11[2] = 0;
  v10 = 0;
  v7 = applejpeg_reduce_open_mem(v11, (uint64_t *)&BytePtr, a1 + 40, (int *)&v10);
  v6 = translateErrorCode(v10);
  *(_QWORD *)(a1 + 32) = v7;
  if (v7)
  {
    if (a3)
      *a3 = 0;
    return 1;
  }
LABEL_11:
  if (a3)
    *a3 = v6;
  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    result = 0;
    *(_QWORD *)(a1 + 24) = 0;
  }
  return result;
}

FILE *AJReducerOpenSourceURLWithOptions(uint64_t a1, const __CFURL *a2, int *a3, const __CFDictionary *a4)
{
  FILE *result;
  int v7;
  BOOL *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD v14[3];

  v12 = 0;
  v10 = 0u;
  v11 = 0u;
  v9 = 0u;
  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer session is NULL", v9, v10, v11, v12);
LABEL_10:
    v7 = 4;
    goto LABEL_11;
  }
  if (!a2)
  {
    aj_log_error((uint64_t)"CFReduce", "Input source is NULL", v9, v10, v11, v12);
    goto LABEL_10;
  }
  if (*(_QWORD *)(a1 + 32) || *(_QWORD *)(a1 + 24) || *(_QWORD *)a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Source is already open. Close must be called before source can be reopened.", v9, v10, v11, v12);
    result = 0;
    if (a3)
      *a3 = 17;
    return result;
  }
  v7 = setupFileManager(a2, 1, a4, (uint64_t (**)(void *, int, uint64_t))&v9, (FILE **)a1);
  if (!v7)
  {
    v14[0] = mallocCallback;
    v14[1] = freeCallback;
    v14[2] = 0;
    v13 = 0;
    v8 = applejpeg_reduce_open_file(v14, (unint64_t)&v9, a1 + 40, (int *)&v13);
    v7 = translateErrorCode(v13);
    *(_QWORD *)(a1 + 32) = v8;
    if (v8)
    {
      if (a3)
        *a3 = 0;
      return (FILE *)1;
    }
  }
LABEL_11:
  if (a3)
    *a3 = v7;
  result = *(FILE **)a1;
  if (*(_QWORD *)a1)
  {
    fclose(result);
    result = 0;
    *(_QWORD *)a1 = 0;
  }
  return result;
}

uint64_t setupFileManager(const __CFURL *a1, int a2, const __CFDictionary *a3, uint64_t (**a4)(void *a1, int a2, uint64_t a3), FILE **a5)
{
  const char *v9;
  FILE *v10;
  FILE *v11;
  uint64_t v12;
  const __CFString *v13;
  uint64_t result;
  int v15;
  const __CFBoolean *Value;
  const __CFDictionary *CFIndexFromDictionary;
  UInt8 buffer[1024];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "URL may not be null");
    return 4;
  }
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to resolve url");
    return 7;
  }
  if (a2)
  {
    v9 = "rb";
  }
  else
  {
    v15 = access((const char *)buffer, 0);
    v9 = "wb";
    if (a3 && v15 != -1)
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("DoNotOverwriteOutputFile"));
      if (Value && CFBooleanGetValue(Value))
      {
        aj_log_error((uint64_t)"CFReduce", "Output file already exists: %s", (const char *)buffer);
        return 16;
      }
      v9 = "wb";
    }
  }
  v10 = fopen((const char *)buffer, v9);
  if (!v10)
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to open file: %s");
    return 7;
  }
  v11 = v10;
  a4[4] = (uint64_t (*)(void *, int, uint64_t))a5;
  fseek(v10, 0, 2);
  v12 = MEMORY[0x20BCF0FB4](v11);
  fseek(v11, 0, 0);
  a4[2] = (uint64_t (*)(void *, int, uint64_t))fskipCallback;
  a4[3] = (uint64_t (*)(void *, int, uint64_t))frewindCallback;
  a4[5] = (uint64_t (*)(void *, int, uint64_t))0x2000;
  a4[6] = (uint64_t (*)(void *, int, uint64_t))v12;
  if (a2)
  {
    *a4 = freadCallback;
    v13 = CFSTR("SimulateReadFailAfterXBytes");
  }
  else
  {
    a4[1] = (uint64_t (*)(void *, int, uint64_t))fwriteCallback;
    v13 = CFSTR("SimulateWriteFailAfterXBytes");
  }
  CFIndexFromDictionary = getCFIndexFromDictionary(a3, v13);
  result = 0;
  a5[1] = 0;
  a5[2] = (FILE *)CFIndexFromDictionary;
  *a5 = v11;
  return result;
}

FILE *AJReducerOpenSourceURL(uint64_t a1, const __CFURL *a2, int *a3)
{
  return AJReducerOpenSourceURLWithOptions(a1, a2, a3, 0);
}

uint64_t AJReducerIsSourcePacked(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 40);
  return result;
}

uint64_t AJReducerSourceUnpackedFileSize(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

uint64_t AJReducerPackToData(uint64_t a1, CFTypeRef *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToData(a1, a2, a3, a4, 0);
}

uint64_t performTaskToData(uint64_t a1, CFTypeRef *a2, const __CFDictionary *a3, _DWORD *a4, int a5)
{
  const void **v10;
  const void **v11;
  unint64_t IOFile;
  const void *DataRef;
  int v15;
  int v16;

  v16 = 0;
  v10 = (const void **)AJMemoryWriterCreate();
  v11 = v10;
  if (!v10)
  {
    aj_log_error((uint64_t)"CFReduce", "Could not create memory writer");
    v15 = 6;
LABEL_9:
    v16 = v15;
    goto LABEL_10;
  }
  if (!a2)
  {
    aj_log_error((uint64_t)"CFReduce", "Destination pointer may not be null");
    v15 = 4;
    goto LABEL_9;
  }
  IOFile = AJMemoryWriterGetIOFile((uint64_t)v10);
  if (performReducerTask(a1, IOFile, a3, &v16, a5))
  {
    DataRef = (const void *)AJMemoryWriterGetDataRef((uint64_t)v11);
    *a2 = CFRetain(DataRef);
    AJMemoryWriterRelease(v11);
    if (a4)
      *a4 = 0;
    return 1;
  }
LABEL_10:
  if (a4)
    *a4 = v16;
  AJMemoryWriterRelease(v11);
  return 0;
}

uint64_t AJReducerUnpackToData(uint64_t a1, CFTypeRef *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToData(a1, a2, a3, a4, 1);
}

FILE *AJReducerPackToURL(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToURL(a1, a2, a3, a4, 0);
}

FILE *performTaskToURL(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3, _DWORD *a4, int a5)
{
  FILE *result;
  FILE *v10[3];
  _OWORD v11[3];
  uint64_t v12;
  int v13;

  v12 = 0;
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  v13 = setupFileManager(a2, 0, a3, (uint64_t (**)(void *, int, uint64_t))v11, v10);
  if (v13 || !performReducerTask(a1, (unint64_t)v11, a3, &v13, a5))
  {
    if (a4)
      *a4 = v13;
    result = v10[0];
    if (v10[0])
    {
      fclose(v10[0]);
      return 0;
    }
  }
  else
  {
    if (v10[0])
      fclose(v10[0]);
    if (a4)
      *a4 = 0;
    return (FILE *)1;
  }
  return result;
}

FILE *AJReducerUnpackToURL(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToURL(a1, a2, a3, a4, 1);
}

uint64_t AJReducerDestinationBytesWritten(uint64_t result)
{
  if (result)
    return *(int *)(result + 72);
  return result;
}

void *mallocCallback(size_t a1)
{
  return malloc_type_malloc(a1, 0x37F67C75uLL);
}

uint64_t translateErrorCode(unsigned int a1)
{
  if (a1 > 0xB)
    return 1;
  else
    return dword_2062767E4[a1];
}

uint64_t fskipCallback(int a1, uint64_t a2)
{
  FILE *v2;

  v2 = *(FILE **)a2;
  *(_QWORD *)(a2 + 8) += a1;
  return fseek(v2, a1, 1);
}

uint64_t frewindCallback(uint64_t a1)
{
  *(_QWORD *)(a1 + 8) = 0;
  return fseek(*(FILE **)a1, 0, 0);
}

uint64_t freadCallback(void *a1, int a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  size_t v6;

  if (!a2)
    return 0;
  v4 = *(_QWORD *)(a3 + 16);
  if (v4)
  {
    v5 = *(_QWORD *)(a3 + 8);
    if (v5 + a2 >= v4)
    {
      aj_log_error((uint64_t)"CFReduce", "Simulated read fail when reading %d bytes at position %zu", a2, v5);
      return 4294967294;
    }
  }
  v6 = fread(a1, 1uLL, a2, *(FILE **)a3);
  if (!(_DWORD)v6)
  {
    if (feof(*(FILE **)a3))
      return 0xFFFFFFFFLL;
    if (ferror(*(FILE **)a3))
      return 4294967294;
  }
  *(_QWORD *)(a3 + 8) += (int)v6;
  return v6;
}

uint64_t fwriteCallback(const void *a1, int a2, uint64_t a3)
{
  unint64_t v5;
  size_t v6;
  int v7;
  uint64_t result;

  v5 = *(_QWORD *)(a3 + 16);
  if (v5)
  {
    if (*(_QWORD *)(a3 + 8) + a2 >= v5)
    {
      aj_log_error((uint64_t)"CFReduce", "Simulated write fail when writing %d bytes at position %zu");
      return 1;
    }
    v6 = a2;
  }
  else
  {
    v6 = a2;
  }
  v7 = fwrite(a1, 1uLL, v6, *(FILE **)a3);
  if (v7 == a2)
  {
    result = 0;
    *(_QWORD *)(a3 + 8) += v7;
    return result;
  }
  aj_log_error((uint64_t)"CFReduce", "Requested write of %d, wrote: %d");
  return 1;
}

const __CFDictionary *getCFIndexFromDictionary(const __CFDictionary *result, const void *a2)
{
  const __CFNumber *Value;
  uint64_t valuePtr;

  if (result)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(result, a2);
    if (Value && (valuePtr = 0, CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr)))
      return (const __CFDictionary *)valuePtr;
    else
      return 0;
  }
  return result;
}

uint64_t performReducerTask(uint64_t a1, unint64_t a2, const __CFDictionary *a3, int *a4, int a5)
{
  __CFString *Value;
  int v11;
  int v12;
  uint64_t v13;
  unsigned int v15;
  uint64_t v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t v19;

  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer session is NULL");
LABEL_12:
    v12 = 4;
    goto LABEL_13;
  }
  if (!*(_QWORD *)(a1 + 32))
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer input is NULL. Call AJReducerOpenSource first.");
    goto LABEL_12;
  }
  if (!a2)
  {
    aj_log_error((uint64_t)"CFReduce", "Destination is NULL");
    goto LABEL_12;
  }
  v19 = 0;
  applejpeg_reduce_options_init((uint64_t)&v19);
  if (!a3)
    goto LABEL_18;
  Value = (__CFString *)CFDictionaryGetValue(a3, CFSTR("CompressionMethod"));
  if (Value != CFSTR("AdaptiveArithmetic"))
  {
    if (Value == CFSTR("SemistaticArithmetic"))
    {
      v11 = 1;
      goto LABEL_17;
    }
    if (!Value)
      goto LABEL_18;
  }
  v11 = 0;
LABEL_17:
  LODWORD(v19) = v11;
LABEL_18:
  v15 = applejpeg_reduce_set_options(*(_QWORD *)(a1 + 32), (uint64_t)&v19);
  if (v15)
  {
    v12 = translateErrorCode(v15);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 32);
    v17 = (_DWORD *)(a1 + 72);
    if (a5)
      v18 = applejpeg_reduce_unpack_file(v16, a2, v17);
    else
      v18 = applejpeg_reduce_pack_file(v16, a2, v17);
    v12 = translateErrorCode(v18);
    if (!v12)
    {
      v13 = 1;
      if (!a4)
        return v13;
      v12 = 0;
      goto LABEL_14;
    }
  }
LABEL_13:
  v13 = 0;
  if (a4)
LABEL_14:
    *a4 = v12;
  return v13;
}

uint64_t aj_idct_s1_4x8(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  int16x8_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  int16x8_t v66;
  int16x8_t v67;
  int16x8_t v68;
  int16x8_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = vaddq_s16(v8, v4);
  v10 = vaddq_s16(*a1, v6);
  v11 = vsubq_s16(*a1, v6);
  v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  v13 = vqshlq_n_s16(a1[7], 1uLL);
  v14 = vaddq_s16(v5, v7);
  v15 = vsubq_s16(v7, v5);
  v16 = vaddq_s16(v3, v13);
  v17 = vsubq_s16(v3, v13);
  v18 = vaddq_s16(v16, v14);
  v19 = vaddq_s16(v9, v12);
  v20 = vaddq_s16(v10, v19);
  v21 = vsubq_s16(v10, v19);
  v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  v24 = vsubq_s16(v11, v12);
  v25 = vaddq_s16(v11, v12);
  v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  v28 = vaddq_s16(v18, v26);
  v29 = vaddq_s16(v26, v23);
  v30 = vaddq_s16(v27, v23);
  v31 = vaddq_s16(v20, v28);
  v32 = vaddq_s16(v25, v29);
  v33 = vaddq_s16(v24, v30);
  v34 = vaddq_s16(v21, v27);
  v35 = vsubq_s16(v21, v27);
  v36 = vsubq_s16(v24, v30);
  v37 = vsubq_s16(v25, v29);
  v38 = vsubq_s16(v20, v28);
  v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  v64 = *a2;
  v65 = a2[1];
  v63 = a2 + 2;
  v66 = vaddq_s16(v60, v59);
  v67 = vaddq_s16(v55, v56);
  v68 = vsubq_s16(v55, v56);
  v69 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  v70 = vqshlq_n_s16(v62, 1uLL);
  v71 = vaddq_s16(v61, v58);
  v72 = vsubq_s16(v58, v61);
  v73 = vaddq_s16(v57, v70);
  v74 = vsubq_s16(v57, v70);
  v75 = vaddq_s16(v66, v69);
  v76 = vqrdmulhq_lane_s16(vaddq_s16(v72, v74), (int16x4_t)0x30FC273D5A824546, 3);
  v77 = vqrdmulhq_lane_s16(vsubq_s16(v73, v71), (int16x4_t)0x30FC273D5A824546, 1);
  v78 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v74, (int16x4_t)0x30FC273D5A824546, 2), v74), v76);
  v79 = vaddq_s16(vqrdmulhq_lane_s16(v72, (int16x4_t)0x30FC273D5A824546, 0), v76);
  _X3 = (int8x8_t *)(v64 + a3);
  _X4 = (int8x8_t *)(v65 + a3);
  _X5 = (int8x8_t *)(*v63 + a3);
  _X6 = (int8x8_t *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  *_X3 = vadd_s8(vqrshrn_n_s16(vaddq_s16(vaddq_s16(v67, v75), vaddq_s16(vaddq_s16(v73, v71), v78)), 5uLL), (int8x8_t)0x8080808080808080);
  *_X4 = vadd_s8(vqrshrn_n_s16(vaddq_s16(vsubq_s16(v68, v69), vaddq_s16(v79, v77)), 5uLL), (int8x8_t)0x8080808080808080);
  *_X5 = vadd_s8(vqrshrn_n_s16(vsubq_s16(vsubq_s16(v67, v75), v79), 5uLL), (int8x8_t)0x8080808080808080);
  *_X6 = vadd_s8(vqrshrn_n_s16(vsubq_s16(vaddq_s16(v68, v69), vaddq_s16(v78, v77)), 5uLL), (int8x8_t)0x8080808080808080);
  return 8;
}

_QWORD *AJMemoryWriterCreate()
{
  _QWORD *v0;
  CFMutableDataRef Mutable;

  v0 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A00409DD6F009uLL);
  v0[1] = 0;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  *v0 = Mutable;
  if (Mutable)
  {
    v0[3] = AJCFDataWriteCallback;
    v0[4] = AJCFDataSkipCallback;
    v0[5] = AJCFDataRewindCallback;
    v0[6] = v0;
  }
  else
  {
    free(v0);
    return 0;
  }
  return v0;
}

uint64_t AJCFDataWriteCallback(const UInt8 *a1, int a2, uint64_t a3)
{
  CFIndex v4;
  __CFData *v6;
  uint64_t v7;
  CFRange v9;

  if (a2)
  {
    LODWORD(v4) = a2;
    v6 = *(__CFData **)a3;
    v7 = *(_QWORD *)(a3 + 8);
    if (v7 == CFDataGetLength(*(CFDataRef *)a3))
    {
      v4 = (int)v4;
      CFDataAppendBytes(v6, a1, (int)v4);
    }
    else
    {
      v9.location = *(_QWORD *)(a3 + 8);
      v4 = (int)v4;
      v9.length = v4;
      CFDataReplaceBytes(v6, v9, a1, (int)v4);
    }
    *(_QWORD *)(a3 + 8) += v4;
  }
  return 0;
}

uint64_t AJCFDataSkipCallback(int a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 8) += a1;
  return 0;
}

uint64_t AJCFDataRewindCallback(uint64_t a1)
{
  *(_QWORD *)(a1 + 8) = 0;
  return 0;
}

void AJMemoryWriterRelease(const void **a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      CFRelease(v2);
    free(a1);
  }
}

uint64_t AJMemoryWriterGetDataRef(uint64_t a1)
{
  return *(_QWORD *)a1;
}

CFIndex AJMemoryWriterGetLength(CFDataRef *a1)
{
  return CFDataGetLength(*a1);
}

uint64_t AJMemoryWriterGetIOFile(uint64_t a1)
{
  return a1 + 16;
}

uint8x16_t **aj_icol_row_420_to_rgb(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint64x2_t v7;
  uint64x2_t v8;
  uint64x2_t v9;
  uint64x2_t v10;
  uint8x8_t v11;
  uint8x16_t *v12;
  uint8x8_t *v13;
  uint8x8_t *v14;
  unsigned int v15;
  uint8x16_t *j;
  uint8x16_t v17;
  uint8x16_t v18;
  uint8x8_t v19;
  uint8x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  char *v33;
  int16x8_t v34;
  int16x8_t v35;
  char *v36;
  int16x8_t v37;
  unsigned int v38;
  uint64x2_t v39;
  uint64x2_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  int16x8_t v54;
  int16x8_t v55;
  unsigned int i;
  uint8x16_t v57;
  uint8x8_t v58;
  uint8x8_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  int16x8_t v63;
  int16x8_t v64;
  int16x8_t v65;
  char *v66;
  int16x8_t v67;
  unsigned int v68;
  uint64x2_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int8x8x3_t v83;
  int8x8x3_t v84;
  int8x8x3_t v85;
  int8x8x3_t v86;

  v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  if (a6 >= 1)
  {
    v12 = *result;
    v13 = *a2;
    v14 = *a3;
    if (a6 == 1)
    {
      for (i = a7 >> 4; i; --i)
      {
        v57 = *v12++;
        v58 = *v13++;
        v59 = *v14++;
        v60 = (int16x8_t)vsubl_u8(v58, v11);
        v61 = (int16x8_t)vsubl_u8(v59, v11);
        v62 = vmulq_lane_s16(v60, (int16x4_t)0xE3005B002C00B3, 3);
        v63 = vmulq_n_s16(v61, 179);
        v64 = vqaddq_s16(vmulq_lane_s16(v60, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 2));
        v65 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v57.i8, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v65, vzip1q_s16(v62, v62)), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v65, vzip1q_s16(v63, v63)), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v65, vzip1q_s16(v64, v64)), 7uLL);
        vst3_s8(a4, v85);
        v66 = a4 + 24;
        v67 = (int16x8_t)vshll_high_n_u8(v57, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v67, vzip2q_s16(v62, v62)), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v67, vzip2q_s16(v63, v63)), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v67, vzip2q_s16(v64, v64)), 7uLL);
        vst3_s8(v66, v85);
        a4 = v66 + 24;
      }
      v68 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v69 = *(uint64x2_t *)v12;
        v70 = (int16x8_t)vsubl_u8(*v13, v11);
        v71 = (int16x8_t)vsubl_u8(*v14, v11);
        v72 = vmulq_lane_s16(v70, (int16x4_t)0xE3005B002C00B3, 3);
        v73 = vmulq_n_s16(v71, 179);
        v74 = vqaddq_s16(vmulq_lane_s16(v70, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 2));
        v75 = vzip2q_s16(v72, v72);
        v76 = vzip2q_s16(v73, v73);
        v77 = vzip2q_s16(v74, v74);
        v78 = vzip1q_s16(v72, v72);
        v79 = vzip1q_s16(v73, v73);
        v80 = vzip1q_s16(v74, v74);
        if (!(v68 >> 3))
          goto LABEL_16;
        v81 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v69.i8, 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v81, v78), 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v81, v79), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v81, v80), 7uLL);
        vst3_s8(a4, v86);
        a4 += 24;
        v78 = v75;
        v79 = v76;
        v80 = v77;
        v69.i64[0] = v69.i64[1];
        v68 -= 8;
        if (v68)
        {
LABEL_16:
          v82 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v69.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v82, v78), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v82, v79), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v82, v80), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4 += 3;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            v9 = vshrq_n_u64(v9, 8uLL);
            --v68;
          }
          while (v68);
        }
      }
    }
    else
    {
      v15 = a7 >> 4;
      for (j = result[1]; v15; --v15)
      {
        v17 = *v12++;
        v18 = *j++;
        v19 = *v13++;
        v20 = *v14++;
        v21 = (int16x8_t)vsubl_u8(v19, v11);
        v22 = (int16x8_t)vsubl_u8(v20, v11);
        v23 = vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 3);
        v24 = vmulq_n_s16(v22, 179);
        v25 = vqaddq_s16(vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 2));
        v26 = vzip2q_s16(v23, v23);
        v27 = vzip2q_s16(v24, v24);
        v28 = vzip2q_s16(v25, v25);
        v29 = vzip1q_s16(v23, v23);
        v30 = vzip1q_s16(v24, v24);
        v31 = vzip1q_s16(v25, v25);
        v32 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v17.i8, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v32, v29), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v32, v30), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v32, v31), 7uLL);
        vst3_s8(a4, v83);
        v33 = a4 + 24;
        v34 = (int16x8_t)vshll_high_n_u8(v17, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v34, v26), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v34, v27), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v34, v28), 7uLL);
        vst3_s8(v33, v83);
        a4 = v33 + 24;
        v35 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v18.i8, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v35, v29), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v35, v30), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v35, v31), 7uLL);
        vst3_s8(a5, v83);
        v36 = a5 + 24;
        v37 = (int16x8_t)vshll_high_n_u8(v18, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v37, v26), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v37, v27), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v37, v28), 7uLL);
        vst3_s8(v36, v83);
        a5 = v36 + 24;
      }
      v38 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v39 = *(uint64x2_t *)v12;
        v40 = *(uint64x2_t *)j;
        v41 = (int16x8_t)vsubl_u8(*v13, v11);
        v42 = (int16x8_t)vsubl_u8(*v14, v11);
        v43 = vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 3);
        v44 = vmulq_n_s16(v42, 179);
        v45 = vqaddq_s16(vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 2));
        v46 = vzip2q_s16(v43, v43);
        v47 = vzip2q_s16(v44, v44);
        v48 = vzip2q_s16(v45, v45);
        v49 = vzip1q_s16(v43, v43);
        v50 = vzip1q_s16(v44, v44);
        v51 = vzip1q_s16(v45, v45);
        if (!(v38 >> 3))
          goto LABEL_8;
        v52 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v52, v49), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v52, v50), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v52, v51), 7uLL);
        vst3_s8(a4, v84);
        a4 += 24;
        v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v53, v49), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v53, v50), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v53, v51), 7uLL);
        vst3_s8(a5, v84);
        a5 += 24;
        v49 = v46;
        v50 = v47;
        v51 = v48;
        v39.i64[0] = v39.i64[1];
        v40.i64[0] = v40.i64[1];
        v38 -= 8;
        if (v38)
        {
LABEL_8:
          v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v54, v49), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v54, v50), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v54, v51), 7uLL);
          v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
          *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v49), 7uLL);
          *(int8x8_t *)v39.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v50), 7uLL);
          *(int8x8_t *)v40.i8 = vqrshrun_n_s16(vqsubq_s16(v55, v51), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4 += 3;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            v9 = vshrq_n_u64(v9, 8uLL);
            *a5 = v39.i8[0];
            a5[1] = v40.i8[0];
            a5[2] = v10.i8[0];
            a5 += 3;
            v39 = vshrq_n_u64(v39, 8uLL);
            v40 = vshrq_n_u64(v40, 8uLL);
            v10 = vshrq_n_u64(v10, 8uLL);
            --v38;
          }
          while (v38);
        }
      }
    }
  }
  return result;
}

uint64_t aj_huffman_decode_skip_block(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  int v15;
  BOOL v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;

  if ((int)a3 >= 64)
    return 0;
  v4 = *(_DWORD *)a2;
  v5 = 612;
  v6 = *(_DWORD *)(a2 + 28);
  v7 = *(_DWORD *)(a2 + 24);
  do
  {
    while (1)
    {
      while (1)
      {
        while (v6)
        {
          v23 = 0;
LABEL_26:
          *(_DWORD *)(a2 + 24) = v7;
          *(_DWORD *)a2 = v4;
          v27 = a1;
          v28 = (unsigned int *)a2;
          v25 = a3;
          v26 = v5;
          v24 = 0;
          result = aj_huffman_decode_skip_val_slow(a1, a2, &v25, v23, (int *)&v24);
          if ((_DWORD)result)
            return result;
          v5 = v26;
          a1 = v27;
          a2 = (uint64_t)v28;
          v7 = v28[6];
          v4 = *v28;
          v6 = v28[7];
          a3 = (v25 + ((_DWORD)v24 << 6));
          if ((int)a3 >= 64)
            goto LABEL_10;
        }
        v8 = *(_DWORD *)(a1 + 4 * (v5 + (v4 >> 23)));
        if (!v8)
        {
          v23 = 9;
          goto LABEL_26;
        }
        v9 = a3 + *(_DWORD *)(a1 + 4 * (v5 + (v4 >> 23)));
        if (v9 >= 64)
        {
          a3 = v9 - *(_DWORD *)(a1 + 4 * (v5 + (v4 >> 23)));
          v23 = 0;
          goto LABEL_26;
        }
        a3 = v9 + (HIWORD(v8) << 6);
        v10 = BYTE1(v8);
        if (v7 < BYTE1(v8) - 9)
        {
          *(_DWORD *)(a2 + 24) = v7;
          *(_DWORD *)a2 = v4;
          v27 = a1;
          v28 = (unsigned int *)a2;
          v25 = a3;
          v26 = v5;
          v24 = BYTE1(v8);
          result = aj_istream_fill_buf(a2, BYTE1(v8) - 9);
          v10 = v24;
          if ((_DWORD)result)
            return result;
          a3 = v25;
          v5 = v26;
          a1 = v27;
          a2 = (uint64_t)v28;
          v7 = v28[6];
          v4 = *v28;
          v6 = v28[7];
        }
        v4 <<= v10;
        v7 -= v10;
        if (v7 < 0)
          break;
        if ((int)a3 >= 64)
          goto LABEL_10;
      }
      v11 = *(_DWORD *)(a2 + 32);
      if (v6)
        goto LABEL_21;
      v12 = *(unsigned __int8 **)(a2 + 8);
      if (v11 >= 8)
      {
        v13 = *v12;
        v14 = v12[1];
        v16 = v13 == 255;
        v15 = v14 + (v13 << 8);
        v16 = v16 || v14 == 255;
        v17 = v12[2];
        v18 = v12 + 3;
        v19 = v11 - 3;
        v20 = v17 + (v15 << 8);
        if (!v16 && v17 != 255)
          break;
      }
      *(_DWORD *)a2 = v4;
      *(_DWORD *)(a2 + 24) = v7;
      v27 = a1;
      v28 = (unsigned int *)a2;
      v25 = a3;
      v26 = v5;
      result = aj_istream_fill_buf(a2, -9);
      if ((_DWORD)result)
        return result;
      a3 = v25;
      v5 = v26;
      a1 = v27;
      a2 = (uint64_t)v28;
      v7 = v28[6];
      v4 = *v28;
      v6 = v28[7];
      if ((int)v25 >= 64)
      {
LABEL_10:
        *(_DWORD *)a2 = v4;
        *(_DWORD *)(a2 + 24) = v7;
        return 0;
      }
    }
    v22 = ~v7;
    *(_DWORD *)(a2 + 32) = v19;
    *(_QWORD *)(a2 + 8) = v18;
    v4 |= v20 << v22;
    v7 = 23 - v22;
LABEL_21:
    ;
  }
  while ((int)a3 < 64);
  *(_DWORD *)a2 = v4;
  *(_DWORD *)(a2 + 24) = v7;
  return 0;
}

uint64_t aj_get_os_log_object()
{
  if (aj_get_os_log_object_onceToken != -1)
    dispatch_once(&aj_get_os_log_object_onceToken, &__block_literal_global);
  return aj_get_os_log_object_s_logger;
}

os_log_t __aj_get_os_log_object_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.applejpeg", "default");
  aj_get_os_log_object_s_logger = (uint64_t)result;
  return result;
}

void aj_log_error(uint64_t a1, char *__format, ...)
{
  FILE *v4;
  char __str[1024];
  uint64_t v6;
  va_list va;

  va_start(va, __format);
  v6 = *MEMORY[0x24BDAC8D0];
  if (aj_logging_enabled_g_aj_check_once != -1)
    dispatch_once(&aj_logging_enabled_g_aj_check_once, &__block_literal_global_6);
  if (aj_logging_enabled_s_should_log)
  {
    vsnprintf(__str, 0x400uLL, __format, va);
    v4 = (FILE *)*MEMORY[0x24BDAC8D8];
    if (a1)
      fprintf(v4, "AppleJPEG, %s: %s\n");
    else
      fprintf(v4, "AppleJPEG: %s\n");
  }
}

void __aj_logging_enabled_block_invoke()
{
  const __CFString *v0;
  const __CFString *v1;
  CFTypeID v2;
  BOOL v3;
  Boolean Value;
  CFTypeID v5;
  CFTypeID v6;
  int valuePtr;

  v0 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("aj_log_errors"), CFSTR("com.apple.applejpeg"));
  if (v0)
  {
    v1 = v0;
    v2 = CFGetTypeID(v0);
    if (v2 == CFStringGetTypeID())
    {
      v3 = CFStringGetIntValue(v1) == 0;
    }
    else
    {
      v5 = CFGetTypeID(v1);
      if (v5 != CFNumberGetTypeID())
      {
        v6 = CFGetTypeID(v1);
        if (v6 == CFBooleanGetTypeID())
          Value = CFBooleanGetValue((CFBooleanRef)v1);
        else
          Value = 0;
        goto LABEL_10;
      }
      valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v1, kCFNumberIntType, &valuePtr);
      v3 = valuePtr == 0;
    }
    Value = !v3;
LABEL_10:
    CFRelease(v1);
    goto LABEL_11;
  }
  Value = 0;
LABEL_11:
  aj_logging_enabled_s_should_log = Value;
}

uint8x8_t **aj_icol_row_444_to_bgr565(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64_t a9, uint64_t a10, unsigned int a11)
{
  uint8x8_t v11;
  uint8x8_t *v12;
  uint8x8_t *v13;
  uint8x8_t *v14;
  unsigned int i;
  uint8x8_t v16;
  uint8x8_t v17;
  uint8x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int8x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int8x8_t v26;
  int v27;
  int8x8x2_t v28;

  v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  v12 = *result;
  v13 = *a2;
  v14 = *a3;
  for (i = a11 >> 3; i; --i)
  {
    v16 = *v12++;
    v17 = *v13++;
    v18 = *v14++;
    v19 = (int16x8_t)vshll_n_u8(v16, 7uLL);
    v20 = (int16x8_t)vsubl_u8(v17, v11);
    v21 = (int16x8_t)vsubl_u8(v18, v11);
    v22 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v19, vqaddq_s16(vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    v28.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v22, 5uLL));
    v28.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v22, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_n_s16(v21, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    vst2_s8(a4, v28);
    a4 += 16;
  }
  if ((a11 & 7) != 0)
  {
    v23 = (int16x8_t)vshll_n_u8(*v12, 7uLL);
    v24 = (int16x8_t)vsubl_u8(*v13, v11);
    v25 = (int16x8_t)vsubl_u8(*v14, v11);
    v26 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v23, vqaddq_s16(vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v25, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    *(int8x8_t *)a7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v26, 5uLL));
    *(int8x8_t *)a8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v26, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_n_s16(v25, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    v27 = a11 & 7;
    do
    {
      *a4 = a7.i8[0];
      a4[1] = a8.i8[0];
      a4 += 2;
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      --v27;
    }
    while (v27);
  }
  return result;
}

uint64_t (**aj_select_semistatic_coder(uint64_t (**result)(int a1)))(int a1)
{
  result[2] = (uint64_t (*)(int))arithmetic_decode_init;
  result[3] = (uint64_t (*)(int))arithmetic_context_init;
  result[9] = (uint64_t (*)(int))arithmetic_encode_close;
  result[10] = (uint64_t (*)(int))arithmetic_decode_close;
  result[7] = (uint64_t (*)(int))arithmetic_encode_static_data;
  result[8] = (uint64_t (*)(int))arithmetic_decode_static_data;
  result[4] = (uint64_t (*)(int))arithmetic_context_init_prob;
  result[5] = (uint64_t (*)(int))arithmetic_encode_symbols;
  result[6] = (uint64_t (*)(int))arithmetic_decode_symbols;
  *result = arithmetic_prob_table_size;
  result[1] = (uint64_t (*)(int))arithmetic_encode_init;
  return result;
}

void arithmetic_context_init(uint64_t a1, unsigned __int16 *a2, int a3, int a4)
{
  init_cum_prob(a2, a3, 0, a4);
}

void arithmetic_context_init_prob(uint64_t a1, unsigned __int16 *a2, int a3, int a4, unsigned __int8 *a5)
{
  init_cum_prob(a2, a3, a5, a4);
}

uint64_t arithmetic_decode_close()
{
  return 0;
}

uint64_t arithmetic_decode_static_data(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  char v3;
  uint64_t result;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;

  v3 = a3;
  if (a3 - 33 <= 0xFFFFFFDF)
  {
    aj_log_error(0, "Illegal number of data bits: %d", a3);
    return 7;
  }
  *a2 = 0;
  if (a3 < 0x11)
    goto LABEL_9;
  v7 = HIWORD(*(_DWORD *)a1);
  if (*(_DWORD *)(a1 + 8) / v7 >= 0xFFFF)
    v8 = 0xFFFF;
  else
    v8 = *(_DWORD *)(a1 + 8) / v7;
  result = arithmetic_decode((int *)a1, *(_QWORD *)(a1 + 24), v8, v8 + 1, v7);
  if (!(_DWORD)result)
  {
    v3 -= 16;
    *a2 = v8 << v3;
LABEL_9:
    v9 = *(_DWORD *)a1 >> v3;
    if (*(_DWORD *)(a1 + 8) / v9 >= ~(-1 << v3))
      v10 = ~(-1 << v3);
    else
      v10 = *(_DWORD *)(a1 + 8) / v9;
    result = arithmetic_decode((int *)a1, *(_QWORD *)(a1 + 24), v10, v10 + 1, v9);
    if (!(_DWORD)result)
      *a2 |= v10;
  }
  return result;
}

uint64_t arithmetic_decode_init(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t result;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)a1 = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = 0;
  v3 = 4;
  do
  {
    v5 = 0;
    result = aj_istream_read_bytes_le(v2, &v5, 1);
    if ((_DWORD)result)
      break;
    *(_DWORD *)(a1 + 8) = v5 | (*(_DWORD *)(a1 + 8) << 8);
    --v3;
  }
  while (v3);
  return result;
}

uint64_t arithmetic_decode_symbols(uint64_t a1, unsigned __int16 **a2, _BYTE *a3, int a4)
{
  int v4;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  unsigned int v16;
  unsigned __int16 *v17;
  _WORD *v18;
  int v19;
  uint64_t v20;
  uint64_t result;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int16 *v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  unint64_t v29;
  unsigned __int16 *v30;
  int v31;
  uint64_t v32;
  unsigned __int16 **v33;

  if (!a4)
    return 0;
  v4 = a4;
  v32 = a1;
  while (1)
  {
    v7 = *a2;
    v8 = (uint64_t)(*a2 + 2);
    v9 = **a2;
    v10 = *(_DWORD *)a1 >> 15;
    v33 = a2 + 1;
    if (**a2)
    {
      v11 = 0;
      v12 = *(_DWORD *)(a1 + 8) / v10;
      if (v12 >= 0x7FFF)
        LOWORD(v12) = 0x7FFF;
      while (*(unsigned __int16 *)(v8 + 2 * v11) <= (unsigned __int16)v12)
      {
        if (v9 == ++v11)
        {
          v13 = **a2;
          LODWORD(v11) = **a2;
          goto LABEL_11;
        }
      }
      v13 = **a2;
    }
    else
    {
      v13 = 0;
      LODWORD(v11) = 0;
    }
LABEL_11:
    v14 = &v7[v13 + 2];
    v15 = &v14[v13];
    v16 = v15[2];
    if ((int)v11 >= (int)v16)
      break;
    v17 = v7 + 1;
    v18 = (_WORD *)(v8 + 2 * (int)v11);
    v19 = (unsigned __int16)*(v18 - 1);
    LOWORD(v18) = *v18 - v19;
    ++v14[(int)v11];
    v20 = *(_QWORD *)(a1 + 24);
    ++*v15;
    ++v15[1];
    result = arithmetic_decode((int *)a1, v20, v19, v19 + (unsigned __int16)v18, v10);
    if ((_DWORD)result)
      return result;
    *a3 = v11;
    v22 = v15[1];
    a1 = v32;
    a2 = v33;
    if (v22 >= 0x800)
    {
      v22 = 0;
      if ((_DWORD)v9)
      {
        do
        {
          v23 = *v14 + 1;
          *v14++ = v23 >> 1;
          v22 += v23 >> 1;
          --v13;
        }
        while (v13);
      }
      v15[1] = v22;
    }
    v24 = *v15;
    if ((unsigned __int16)v22 <= 0x7Fu)
    {
      v25 = v17;
      if ((v22 & 1) == 0 && v24 <= 0x80)
        goto LABEL_42;
LABEL_40:
      v31 = v15[2];
LABEL_41:
      renormalize_probs(v25, v9, v31);
      a1 = v32;
      goto LABEL_42;
    }
    v25 = v17;
    if (v24 >= 0x81)
      goto LABEL_40;
LABEL_42:
    ++a3;
    if (!--v4)
      return 0;
  }
  result = arithmetic_decode((int *)a1, *(_QWORD *)(a1 + 24), *(unsigned __int16 *)(v8 + 2 * v11 - 2), v7[v11 + 2], v10);
  if ((_DWORD)result)
    return result;
  v26 = -1;
  do
    ++v26;
  while (v26 <= 0x1F && 1 << v26 < (int)v9);
  v27 = *(_DWORD *)v32 >> v26;
  v28 = *(_DWORD *)(v32 + 8) / v27 >= ~(-1 << v26) ? ~(-1 << v26) : *(_DWORD *)(v32 + 8) / v27;
  result = arithmetic_decode((int *)v32, *(_QWORD *)(v32 + 24), v28, v28 + 1, v27);
  if ((_DWORD)result)
    return result;
  *a3 = v28;
  if (v28 < v9)
  {
    if (v28 > v16)
    {
      v29 = v28 - (unint64_t)v16;
      v30 = &v7[v13 + 3 + v16];
      do
      {
        ++*v30++;
        ++v15[1];
        --v29;
      }
      while (v29);
    }
    if (v28 + 1 < v9)
    {
      ++v14[v28 + 1];
      ++v15[1];
    }
    ++v14[v28];
    ++v15[1];
    if (v28 + 2 == (_DWORD)v9)
      v31 = v9;
    else
      v31 = v28 + 1;
    v15[2] = v31;
    a2 = v33;
    v25 = v7 + 1;
    goto LABEL_41;
  }
  aj_log_error(0, "Symbol is too large. %d > %d", v28, v9);
  return 7;
}

uint64_t arithmetic_encode_close(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  uint64_t result;
  int v6;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 4);
  v4 = 4;
  while (1)
  {
    result = byte_plus_prev(a1, v2, HIBYTE(v3));
    if ((_DWORD)result)
      return result;
    v3 = *(_DWORD *)(a1 + 4) << 8;
    *(_DWORD *)(a1 + 4) = v3;
    if (!--v4)
    {
      result = aj_ostream_write_bytes(v2, *(unsigned __int8 *)(a1 + 33), 1);
      if (!(_DWORD)result)
      {
        if (*(_DWORD *)(a1 + 12))
        {
          while (1)
          {
            result = aj_ostream_write_bytes(v2, 255, 1);
            if ((_DWORD)result)
              break;
            v6 = *(_DWORD *)(a1 + 12) - 1;
            *(_DWORD *)(a1 + 12) = v6;
            if (!v6)
              goto LABEL_8;
          }
        }
        else
        {
LABEL_8:
          result = 0;
          *(_BYTE *)(a1 + 33) = 0;
        }
      }
      return result;
    }
  }
}

uint64_t arithmetic_encode_static_data(uint64_t a1, unsigned int a2, int a3)
{
  char v3;
  int v4;
  uint64_t result;

  v3 = a3;
  v4 = a2;
  if (a3 >= 17)
  {
    v3 = a3 - 16;
    result = arithmetic_encode(a1, *(_QWORD *)(a1 + 16), a2 >> (a3 - 16), (a2 >> (a3 - 16)) + 1, 16);
    if ((_DWORD)result)
      return result;
    v4 &= ~(-1 << v3);
  }
  return arithmetic_encode(a1, *(_QWORD *)(a1 + 16), v4, v4 + 1, v3);
}

uint64_t arithmetic_encode_init(uint64_t a1)
{
  *(_QWORD *)a1 = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = 0;
  return 0;
}

uint64_t arithmetic_encode_symbols(uint64_t a1, unsigned __int16 **a2, unsigned __int8 *a3, int a4)
{
  int v4;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  int v16;
  unsigned __int16 v17;
  uint64_t v18;
  uint64_t result;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int16 *v27;
  int v28;
  int v29;
  unsigned __int8 *v31;

  if (!a4)
    return 0;
  v4 = a4;
  while (1)
  {
    v8 = *a2++;
    v7 = v8;
    v9 = v8 + 1;
    v10 = *v8;
    LODWORD(v8) = *a3;
    v11 = a3 + 1;
    v12 = v8;
    if (v8 >= v10)
      break;
    v31 = v11;
    v13 = &v9[v10 + 1];
    v14 = &v13[v10];
    v15 = v14[2];
    if (v15 <= v12)
    {
      result = arithmetic_encode(a1, *(_QWORD *)(a1 + 16), v7[v14[2] + 1], v9[v14[2] + 1], 15);
      if ((_DWORD)result)
        return result;
      v29 = v4;
      v24 = -1;
      do
        ++v24;
      while (v24 <= 0x1F && 1 << v24 < (int)v10);
      v25 = v12 + 1;
      result = arithmetic_encode(a1, *(_QWORD *)(a1 + 16), v12, (int)v12 + 1, v24);
      if ((_DWORD)result)
        return result;
      if (v15 < v12)
      {
        v26 = v12 - v15;
        v27 = &v7[v10 + 3 + v15];
        do
        {
          ++*v27++;
          ++v14[1];
          --v26;
        }
        while (v26);
      }
      if (v25 < v10)
      {
        ++v13[v25];
        ++v14[1];
      }
      ++v13[v12];
      ++v14[1];
      if ((_DWORD)v12 + 2 == (_DWORD)v10)
        v28 = v10;
      else
        v28 = v12 + 1;
      v14[2] = v28;
      v4 = v29;
      a3 = v31;
      goto LABEL_30;
    }
    v16 = v7[v12 + 1];
    v17 = v7[v12 + 2] - v16;
    ++v13[v12];
    v18 = *(_QWORD *)(a1 + 16);
    ++*v14;
    ++v14[1];
    result = arithmetic_encode(a1, v18, v16, v16 + v17, 15);
    if ((_DWORD)result)
      return result;
    v20 = v14[1];
    if (v20 >= 0x800)
    {
      v20 = 0;
      v21 = v10;
      do
      {
        v22 = *v13 + 1;
        *v13++ = v22 >> 1;
        v20 += v22 >> 1;
        --v21;
      }
      while (v21);
      v14[1] = v20;
    }
    v23 = *v14;
    if ((unsigned __int16)v20 <= 0x7Fu)
    {
      a3 = v31;
      if ((v20 & 1) == 0 && v23 <= 0x80)
        goto LABEL_31;
LABEL_29:
      v28 = v14[2];
LABEL_30:
      renormalize_probs(v9, v10, v28);
      goto LABEL_31;
    }
    a3 = v31;
    if (v23 >= 0x81)
      goto LABEL_29;
LABEL_31:
    if (!--v4)
      return 0;
  }
  aj_log_error(0, "Illegal symbol to be encoded (%d). Num syms in this context is %d.", v12, v10);
  return 7;
}

uint64_t arithmetic_prob_table_size(int a1)
{
  return (4 * a1 + 10);
}

void init_cum_prob(unsigned __int16 *a1, int a2, unsigned __int8 *a3, int a4)
{
  uint64_t v4;
  uint64_t v8;
  _WORD *v9;
  _WORD *v10;
  __int16 v11;
  uint64_t v12;
  _WORD *v13;
  __int16 v14;

  LODWORD(v4) = a4;
  bzero(a1, 4 * a2 + 10);
  *a1 = a2;
  v8 = (uint64_t)&a1[a2 + 1];
  v9 = (_WORD *)(v8 + 2);
  if (a2 - 1 <= (int)v4)
    v4 = a2;
  else
    v4 = v4;
  v10 = &v9[a2];
  v10[2] = v4;
  if (a3)
  {
    v11 = 0;
    if ((int)v4 >= 1)
    {
      v12 = v4;
      v13 = v9;
      do
      {
        *v13++ = *a3;
        v14 = *a3++;
        v11 += v14;
        --v12;
      }
      while (v12);
    }
    if ((int)v4 >= a2)
      goto LABEL_15;
LABEL_14:
    v9[(int)v4] = 1;
    ++v11;
    goto LABEL_15;
  }
  if ((int)v4 >= 1)
    memset_pattern16((void *)(v8 + 2), &unk_206276820, 2 * v4);
  v11 = v4;
  if ((int)v4 < a2)
  {
    bzero(&a1[a2 + 2 + (uint64_t)(int)v4], 2 * (a2 - 1 - v4) + 2);
    v11 = v4;
    goto LABEL_14;
  }
LABEL_15:
  v10[1] = v11;
  renormalize_probs(a1 + 1, a2, v4);
}

void renormalize_probs(unsigned __int16 *a1, int a2, int a3)
{
  uint64_t v5;
  _WORD *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  unsigned int v13;
  unint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  v5 = (uint64_t)&a1[a2 + a2];
  v6 = a1 + 1;
  v7 = *(unsigned __int16 *)(v5 + 4);
  *(_WORD *)(v5 + 2) = 0;
  if (a3 >= a2)
    v8 = a3;
  else
    v8 = (a3 + 1);
  if ((int)v8 < 1)
  {
    v10 = 0;
    v15 = 0x8000;
  }
  else
  {
    v9 = 0;
    LODWORD(v10) = 0;
    v11 = 0;
    v12 = v7 - 1;
    v13 = 0x80000000 / v7;
    do
    {
      v14 = (v13 * (unint64_t)(v12 + ((unsigned __int16)v6[a2 + v9] << 15))) >> 31;
      v6[v9] = v14;
      v11 += v14;
      if ((unsigned __int16)v14 <= (unsigned __int16)v6[v10])
        v10 = v10;
      else
        v10 = v9;
      ++v9;
    }
    while (v8 != v9);
    v15 = (v11 ^ 0x7FFF) + 1;
  }
  if ((int)v8 < a2)
  {
    v16 = a3;
    if (a3 < a2)
      v16 = a3 + 1;
    bzero(&a1[v16 + 1], 2 * (~a3 + a2 - (a3 < a2)) + 2);
  }
  v6[v10] += v15;
  if (a2 >= 1)
  {
    v17 = a2;
    v18 = *a1;
    do
    {
      v18 += (unsigned __int16)*v6;
      *v6++ = v18;
      --v17;
    }
    while (v17);
  }
}

uint64_t arithmetic_decode(int *a1, uint64_t a2, int a3, int a4, int a5)
{
  int v6;
  uint64_t result;
  int v9;
  unsigned int v10;

  v6 = (a4 - a3) * a5;
  *a1 = v6;
  a1[2] -= a5 * a3;
  if ((v6 - 16777217) >> 24 == 255)
  {
    while (1)
    {
      v10 = 0;
      result = aj_istream_read_bytes_le(a2, &v10, 1);
      if ((_DWORD)result)
        break;
      a1[2] = v10 | (a1[2] << 8);
      v9 = *a1;
      v6 = *a1 << 8;
      *a1 = v6;
      if (((v9 << 8) - 16777217) >> 24 != 255)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    result = 0;
    if (!v6)
      *a1 = -1;
  }
  return result;
}

uint64_t byte_plus_prev(uint64_t a1, uint64_t a2, int a3)
{
  char v3;
  uint64_t result;
  int v7;

  v3 = a3;
  if (*(_BYTE *)(a1 + 32))
  {
    if (a3 == 255)
    {
      result = 0;
      ++*(_DWORD *)(a1 + 12);
    }
    else
    {
      result = aj_ostream_write_bytes(a2, *(unsigned __int8 *)(a1 + 33), 1);
      if (!(_DWORD)result)
      {
        if (*(_DWORD *)(a1 + 12))
        {
          while (1)
          {
            result = aj_ostream_write_bytes(a2, 255, 1);
            if ((_DWORD)result)
              break;
            v7 = *(_DWORD *)(a1 + 12) - 1;
            *(_DWORD *)(a1 + 12) = v7;
            if (!v7)
              goto LABEL_7;
          }
        }
        else
        {
LABEL_7:
          result = 0;
          *(_BYTE *)(a1 + 33) = v3;
        }
      }
    }
  }
  else
  {
    result = 0;
    *(_BYTE *)(a1 + 32) = 1;
    *(_BYTE *)(a1 + 33) = a3;
    *(_DWORD *)(a1 + 12) = 0;
  }
  return result;
}

uint64_t arithmetic_encode(uint64_t a1, uint64_t a2, int a3, int a4, char a5)
{
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned __int8 v12;
  int v13;
  uint64_t result;
  int v15;
  int v16;

  v7 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)a1 >> a5;
  v9 = v8 * (a4 - a3);
  *(_DWORD *)a1 = v9;
  v10 = v8 * a3;
  v11 = v10 + v7;
  if (__CFADD__(v10, v7) && (v12 = *(_BYTE *)(a1 + 33) + 1, *(_BYTE *)(a1 + 33) = v12, *(_DWORD *)(a1 + 12)))
  {
    v13 = v12;
    while (1)
    {
      result = aj_ostream_write_bytes(a2, v13, 1);
      if ((_DWORD)result)
        break;
      v13 = 0;
      *(_BYTE *)(a1 + 33) = 0;
      v15 = *(_DWORD *)(a1 + 12) - 1;
      *(_DWORD *)(a1 + 12) = v15;
      if (!v15)
      {
        v9 = *(_DWORD *)a1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    *(_DWORD *)(a1 + 4) = v11;
    if ((v9 - 16777217) >> 24 == 255)
    {
      while (1)
      {
        result = byte_plus_prev(a1, a2, HIBYTE(v11));
        if ((_DWORD)result)
          break;
        v16 = *(_DWORD *)a1;
        v11 = *(_DWORD *)(a1 + 4) << 8;
        v9 = *(_DWORD *)a1 << 8;
        *(_DWORD *)a1 = v9;
        *(_DWORD *)(a1 + 4) = v11;
        if (((v16 << 8) - 16777217) >> 24 != 255)
          goto LABEL_11;
      }
    }
    else
    {
LABEL_11:
      result = 0;
      if (!v9)
        *(_DWORD *)a1 = -1;
    }
  }
  return result;
}

BOOL aj_allow_multithread_encode(_DWORD *a1, uint64_t a2, int a3)
{
  return a3 >= 2 && a1[3359] >= a3 && (int)a1[3358] <= 65534 && a1[3340] != 14 && a1[4952] < 2;
}

uint64_t aj_encode_buffers_baseline(int *a1, _DWORD *a2)
{
  int v4;
  uint64_t result;

  if (a1[3358] < 1)
    return 0;
  v4 = 0;
  while (1)
  {
    result = aj_mcu_dct(a1, a2);
    if ((_DWORD)result)
      break;
    if (++v4 >= a1[3358])
      return 0;
  }
  return result;
}

uint64_t aj_encode_buffers_progressive(int *a1, uint8x8_t **a2, int a3)
{
  uint8x8_t **v3;
  int *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t i;
  uint64_t v15;
  uint64_t result;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t j;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int *v27;
  _DWORD *v28;
  int v29;
  int v30;
  int v31;
  BOOL v32;
  int v33;
  int v34;
  uint64_t (**v35)(unsigned int *, int8x16_t *, uint64_t);
  uint64_t v36;
  uint64_t v37;
  int v39;
  uint8x8_t **v40;
  int v42;
  uint8x8_t **v43;
  int8x16_t v44[8];
  _QWORD v45[4];

  v3 = a2;
  v45[2] = *MEMORY[0x24BDAC8D0];
  v5 = a1 + 3360;
  v45[0] = 0;
  v45[1] = 0;
  memset(v44, 0, sizeof(v44));
  v6 = a1[2];
  v7 = v6 + 7;
  if (v6 < -7)
    v7 = v6 + 14;
  v8 = v7 >> 3;
  if (a1[8] == 2)
  {
    LODWORD(v45[0]) = 8;
    aj_fill_prog_coeff_buf((uint64_t (*)())a1, a2);
    if (v6 >= 1)
    {
      v9 = 0;
      v10 = *((_QWORD *)a1 + 2478);
      if (v8 <= 1)
        v11 = 1;
      else
        v11 = v8;
      v12 = v5[1592];
      do
      {
        if (v12 >= 1)
        {
          v13 = 0;
          for (i = 0; i < v12; ++i)
          {
            v15 = *((_QWORD *)a1 + 2477);
            if (*(_DWORD *)(v15 + v13) == 1 && !*(_DWORD *)(v15 + v13 + 4))
            {
              result = (*(uint64_t (**)(void))(v15 + v13 + 232))();
              if ((_DWORD)result)
                return result;
              v12 = v5[1592];
            }
            v13 += 304;
          }
        }
        ++v9;
        v10 += 128;
      }
      while (v9 != v11);
    }
  }
  if (a1[3358] < 1)
    return 0;
  v17 = 0;
  v18 = *((_QWORD *)a1 + 2478);
  do
  {
    if (a1[8] == 2)
    {
      v19 = a1[4];
      if (v19 >= 1)
      {
        v20 = 0;
        v21 = v5[1592];
        do
        {
          if (v21 >= 1)
          {
            v22 = 0;
            for (j = 0; j < v21; ++j)
            {
              v24 = *((_QWORD *)a1 + 2477);
              if (*(int *)(v24 + v22) >= 2 && !*(_DWORD *)(v24 + v22 + 4))
              {
                result = (*(uint64_t (**)(void))(v24 + v22 + 232))();
                if ((_DWORD)result)
                  return result;
                v21 = v5[1592];
              }
              v22 += 304;
            }
            v19 = a1[4];
          }
          ++v20;
          v18 += 128;
        }
        while (v20 < v19);
      }
    }
    v25 = *a1;
    if (*a1 >= 1)
    {
      v26 = 0;
      v40 = v3;
      v39 = v17;
      do
      {
        v27 = &a1[v26];
        v29 = v27[4];
        v28 = v27 + 4;
        if (v29 >= 1)
        {
          v30 = 0;
          v43 = &(&v3[16 * v26])[*((int *)v45 + v26)];
          if (v26)
            v31 = 0;
          else
            v31 = -1;
          v42 = v31;
          do
          {
            aj_block_dct(v43, v44, (int16x8_t *)&a1[392 * v26 + 3503]);
            if (v26)
            {
              v32 = 0;
            }
            else
            {
              v32 = v8 == 0;
              if (v8 && a3)
                v32 = *(_BYTE *)v5 != 0;
            }
            v33 = v5[1592];
            if (v33 >= 1)
            {
              v34 = 0;
              v35 = (uint64_t (**)(unsigned int *, int8x16_t *, uint64_t))*((_QWORD *)a1 + 2477);
              do
              {
                v36 = *(unsigned int *)v35;
                if ((int)v36 >= 1)
                {
                  v37 = 0;
                  while (v26 != *((_DWORD *)v35 + v37 + 1))
                  {
                    if (v36 == ++v37)
                      goto LABEL_56;
                  }
                  if ((_DWORD)v36 != 1 || !v32)
                  {
                    result = v35[29]((unsigned int *)v35, v44, (uint64_t)v35[v37 + 25] + 12);
                    if ((_DWORD)result)
                      return result;
                    v33 = v5[1592];
                  }
                }
LABEL_56:
                ++v34;
                v35 += 38;
              }
              while (v34 < v33);
            }
            v8 += v42;
            ++v30;
          }
          while (v30 < *v28);
          v25 = *a1;
          v3 = v40;
          v17 = v39;
        }
        ++v26;
      }
      while (v26 < v25);
    }
    result = 0;
    ++v17;
  }
  while (v17 < a1[3358]);
  return result;
}

uint64_t aj_encode_row(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  int v7;

  if (*(_DWORD *)(a1 + 13360) == 14)
  {
    a2[224] = a2[229];
    a2[225] = a2[231];
    a2[226] = a2[233];
    aj_reset_row_ptrs((unsigned int *)a1, a2, (uint64_t)(a2 + 224));
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(a1 + 19752))(a1, a2, a3);
  }
  aj_col_trans_row((int *)a1, (uint64_t)a2, (uint64_t)a2, *(unsigned int *)(a1 + 32), *(_DWORD *)(a1 + 13284));
  v7 = *(_DWORD *)(a1 + 13284) + 1;
  *(_DWORD *)(a1 + 13284) = v7;
  if (v7 == *(_DWORD *)(a1 + 13280))
  {
    result = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(a1 + 19752))(a1, a2, a3);
    if ((_DWORD)result)
      return result;
    *(_DWORD *)(a1 + 13284) = 0;
    aj_reset_row_ptrs((unsigned int *)a1, a2, (uint64_t)(a2 + 224));
  }
  return 0;
}

uint64_t aj_encode_row_close(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t result;

  if (*(_DWORD *)(a1 + 13360) == 14)
    goto LABEL_9;
  v4 = *(unsigned int *)(a1 + 13276);
  v5 = *(_DWORD *)(a1 + 13284);
  if ((_DWORD)v4)
  {
    aj_col_trans_row((int *)a1, a2, a2, v4, v5);
    v5 = *(_DWORD *)(a1 + 13284) + 1;
    *(_DWORD *)(a1 + 13284) = v5;
    *(_DWORD *)(a1 + 13276) = 0;
  }
  if (!v5)
    goto LABEL_9;
  while (v5 < *(_DWORD *)(a1 + 13280))
  {
    aj_col_trans_row((int *)a1, a2, a2, 0, v5);
    v6 = *(_DWORD *)(a1 + 13284);
    v5 = v6 + 1;
    *(_DWORD *)(a1 + 13284) = v6 + 1;
    if (v6 == -1)
      goto LABEL_9;
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 19752))(a1, a2, 1);
  if (!(_DWORD)result)
  {
LABEL_9:
    if (*(_DWORD *)(a1 + 19800))
      aj_concatenate_scans(a1, a2);
    result = aj_ostream_write_bytes(a2 + 1928, 65497, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_flush_buffer(a2 + 1928);
      if (!(_DWORD)result)
        *(_DWORD *)(a2 + 2016) = *(_DWORD *)(a2 + 1944);
    }
  }
  return result;
}

uint64_t aj_concatenate_scans(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  int v4;
  uint64_t v5;
  uint64_t i;
  int v7;
  uint64_t v8;
  uint8x16_t *v9;
  uint64_t v10;
  uint64_t result;
  _BYTE *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;

  v2 = (_DWORD *)(a1 + 19808);
  if (*(int *)(a1 + 19808) < 1)
    return 0;
  v4 = 0;
  v5 = a2 + 1928;
  for (i = *(_QWORD *)(a1 + 19816); ; i += 304)
  {
    if (v4)
    {
      v7 = *(_DWORD *)i;
      if (*(int *)i >= 1)
      {
        v8 = 0;
        do
        {
          v9 = *(uint8x16_t **)(i + 8 * v8 + 240);
          if (v9 && !v9[17].i8[1])
          {
            v10 = i + 4 * v8;
            result = aj_write_single_dht(v5, v9, 1, *(_DWORD *)(v10 + 4) != 0);
            if ((_DWORD)result)
              return result;
            v12 = (_BYTE *)(a1 + 274 * (*(_DWORD *)(v10 + 4) != 0) + 10937);
            if (*(_DWORD *)(i + 64))
              v12 = (_BYTE *)(a1 + 548 * (*(_DWORD *)(v10 + 4) != 0) + 3971);
            *v12 = 0;
            v7 = *(_DWORD *)i;
          }
          ++v8;
        }
        while (v8 < v7);
      }
      result = aj_write_sos_progressive(v5, a1, (int *)i);
      if ((_DWORD)result)
        break;
    }
    result = aj_prog_encode_close(i);
    if ((_DWORD)result)
      break;
    result = aj_ostream_flush_bitreg((unsigned int *)(i + 88));
    if ((_DWORD)result)
      break;
    v13 = *(char **)(i + 168);
    if (v13)
    {
      v14 = *(unsigned int *)(i + 180);
      if ((_DWORD)v14)
      {
        result = aj_ostream_write_buf(v5, v13, v14);
        if ((_DWORD)result)
          break;
      }
    }
    v15 = *(char **)(i + 96);
    v16 = *(char **)(i + 112);
    if (v15 != v16)
    {
      result = aj_ostream_write_buf(v5, v16, ((_DWORD)v15 - (_DWORD)v16));
      if ((_DWORD)result)
        break;
    }
    if (++v4 >= *v2)
      return 0;
  }
  return result;
}

uint64_t aj_encode_all(uint64_t a1, uint64_t a2, int a3)
{
  _DWORD *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int i;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v26;

  v5 = (_DWORD *)(a1 + 19800);
  v6 = *(int *)(a1 + 32);
  v7 = *(_DWORD *)(a1 + 19844);
  v8 = *(_QWORD *)(a1 + 19776);
  if (v7 <= (int)v6)
    v8 *= (int)v6 / v7;
  v9 = *(_QWORD *)(a1 + 19768);
  *(_OWORD *)(a2 + 2000) = 0u;
  if (*(_DWORD *)(a1 + 13360) == 14)
  {
    v26 = *(_QWORD *)(a2 + 1832) + *(_QWORD *)(a1 + 13296) * *(int *)(a1 + 13316) + *(int *)(a1 + 13312);
    v10 = *(_QWORD *)(a1 + 13328) * *(int *)(a1 + 13348);
    v11 = *(int *)(a1 + 13344);
    v12 = *(_QWORD *)(a2 + 1848) + v11 + v10;
    v13 = *(_QWORD *)(a2 + 1864) + v11 + v10;
  }
  else
  {
    v26 = 0;
    v12 = 0;
    v13 = 0;
  }
  v14 = *(int *)(a2 + 1824);
  if ((int)v14 >= *(_DWORD *)(a2 + 1828))
  {
LABEL_24:
    if (!*v5 || (result = aj_concatenate_scans(a1, a2), !(_DWORD)result))
    {
      if (a3 == 217 && *(_BYTE *)(a2 + 2096))
      {
        result = aj_ostream_flush_buffer(a2 + 1928);
        if ((_DWORD)result)
          return result;
      }
      else
      {
        result = aj_ostream_write_bytes(a2 + 1928, a3 | 0xFF00u, 2);
        if ((_DWORD)result)
          return result;
        if (a3 != 217)
        {
          v22 = *(_QWORD *)(a2 + 2072);
          if (v22)
          {
            v23 = *(_DWORD *)(a2 + 2080) + *(_DWORD *)(a2 + 1944) - *(_DWORD *)(a2 + 2020) - 2;
            v24 = *(int *)(a2 + 2088);
            *(_DWORD *)(a2 + 2088) = v24 + 1;
            *(_DWORD *)(v22 + 4 * v24) = v23;
          }
        }
      }
      if (*(_DWORD *)(a2 + 2024))
      {
        (*(void (**)(_QWORD))(a2 + 2032))(*(_QWORD *)(a2 + 2040));
        result = 0;
        *(_DWORD *)(a2 + 2048) = *(_DWORD *)(a2 + 2024);
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    v15 = v9 * v6;
    while (1)
    {
      if (*(_DWORD *)(a2 + 2024))
      {
        v16 = *(_DWORD *)(a2 + 2048);
        if (!v16)
        {
          (*(void (**)(_QWORD))(a2 + 2032))(*(_QWORD *)(a2 + 2040));
          v16 = *(_DWORD *)(a2 + 2024);
        }
        *(_DWORD *)(a2 + 2048) = v16 - 1;
      }
      if (*(_DWORD *)(a1 + 13360) == 14)
      {
        *(_QWORD *)(a2 + 1792) = v26 + 8 * v14 * *(_QWORD *)(a1 + 13296) * *(int *)(a1 + 32);
        v17 = 8 * v14 * *(_QWORD *)(a1 + 13328);
        *(_QWORD *)(a2 + 1800) = v12 + v17;
        *(_QWORD *)(a2 + 1808) = v13 + v17;
      }
      aj_reset_row_ptrs((unsigned int *)a1, (_QWORD *)a2, a2 + 1792);
      if (*(_DWORD *)(a1 + 13360) != 14)
      {
        for (i = 0; i != 8; ++i)
        {
          aj_col_trans_row((int *)a1, a2, a2, (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 32) * i - *(_DWORD *)(a1 + 13428) * v14), i);
          *(_QWORD *)(a2 + 1832) += v15;
          *(_QWORD *)(a2 + 1840) += v15;
          if (v5[8])
          {
            if (v5[11] <= *(_DWORD *)(a1 + 32))
              v19 = 1;
            else
              v19 = i & 1;
            v20 = v8 * v19;
            *(_QWORD *)(a2 + 1848) += v20;
            *(_QWORD *)(a2 + 1856) += v20;
          }
        }
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(a1 + 19752))(a1, a2, *(_DWORD *)(a1 + 13436) - 1 == (_DWORD)v14);
      if ((_DWORD)result)
        break;
      if (++v14 >= *(int *)(a2 + 1828))
        goto LABEL_24;
    }
  }
  return result;
}

uint64_t aj_encode_all_mt(uint64_t a1, uint64_t a2, signed int a3, uint64_t a4)
{
  int *v8;
  int v9;
  int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  uint64_t enc_buffers;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  _BYTE *v33;
  pthread_t *v34;
  uint64_t v35;
  uint64_t v36;
  pthread_t *v37;
  unsigned int v38;
  unsigned int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  unsigned int *v46;
  char *v47;
  uint64_t v48;
  _DWORD *v49;
  _DWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t i;
  _DWORD *v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t j;
  uint64_t v59;
  size_t v61;
  int *v62;
  _OWORD v63[2];
  __int128 v64;
  uint64_t v65;
  void *v66;
  size_t v67;
  _OWORD v68[8];
  uint64_t v69;
  _DWORD v70[6];
  _QWORD v71[17];
  _BYTE v72[40];
  uint64_t v73;
  _QWORD v74[311];

  v74[309] = *MEMORY[0x24BDAC8D0];
  v8 = (int *)(a1 + 19760);
  bzero(v70, 0xA78uLL);
  v66 = 0;
  v67 = 0;
  v65 = 0;
  v64 = 0u;
  memset(v63, 0, sizeof(v63));
  memset(v68, 0, sizeof(v68));
  v9 = *(_DWORD *)(a1 + 13436);
  v62 = v8;
  if (v9 % *v8)
    v10 = v9 / *v8 + 1;
  else
    v10 = v9 / *v8;
  if (v10 / a3)
    v11 = a3;
  else
    v11 = v10;
  if ((v10 / a3) <= 1)
    v12 = 1;
  else
    v12 = v10 / a3;
  *((_QWORD *)&v63[0] + 1) = mt_write_callback;
  v71[0] = a2;
  v69 = a1;
  v70[2] = 0;
  v70[3] = v12;
  v13 = estimate_jpeg_size(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  LODWORD(v14) = (_DWORD)v11 << 10;
  if (v13 <= (int)((_DWORD)v11 << 10))
    v14 = (int)v14;
  else
    v14 = v13;
  if ((int)v11 > 1)
  {
    v15 = 0;
    v16 = v72;
    v17 = v11 - 1;
    v61 = (int)(v14 / v11);
    v18 = v11 - 1;
    while (1)
    {
      v19 = *((_QWORD *)v16 + 4);
      if (v19)
        (*(void (**)(uint64_t, _QWORD))(a4 + 8))(v19, *(_QWORD *)(a4 + 16));
      v20 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a4)(2112, *(_QWORD *)(a4 + 16));
      *((_QWORD *)v16 + 4) = v20;
      if (!v20 || (bzero(v20, 0x840uLL), (v21 = (_QWORD *)*((_QWORD *)v16 + 4)) == 0))
      {
LABEL_59:
        v36 = 6;
        goto LABEL_63;
      }
      enc_buffers = aj_allocate_enc_buffers((unsigned int *)a1, v21, a4);
      if ((_DWORD)enc_buffers)
      {
        v36 = enc_buffers;
        goto LABEL_63;
      }
      v66 = 0;
      v67 = v61;
      v23 = (void *)(*(uint64_t (**)(void))a4)();
      v66 = v23;
      if (!v23)
        goto LABEL_59;
      bzero(v23, v67);
      if (!v66)
        goto LABEL_59;
      *(_QWORD *)v16 = a1;
      *((_QWORD *)v16 + 1) = a4;
      *((_DWORD *)v16 + 4) = v12 + v15;
      *((_DWORD *)v16 + 5) = 2 * v12 + v15;
      v24 = *((_QWORD *)v16 + 4);
      *(_DWORD *)(v24 + 2056) = *(_DWORD *)(a2 + 2056);
      *(_DWORD *)(v24 + 2068) = *(_DWORD *)(a2 + 2068);
      *(_QWORD *)(v24 + 2072) = *(_QWORD *)(a2 + 2072);
      *(_DWORD *)(v24 + 2080) = *(_DWORD *)(a2 + 2080);
      *(_BYTE *)(v24 + 2096) = *(_BYTE *)(a2 + 2096);
      *(_DWORD *)(v24 + 2020) = 0;
      if (*(_DWORD *)(a1 + 13360) == 14)
        return 3;
      v25 = *v62 * (uint64_t)(v12 + v15);
      v26 = *(_QWORD *)(a1 + 19768);
      *(_QWORD *)(v24 + 1832) = *(_QWORD *)(a2 + 1832) + v26 * v25 * *(int *)(a1 + 13428);
      *(_QWORD *)(*((_QWORD *)v16 + 4) + 1840) = *(_QWORD *)(*((_QWORD *)v16 + 4) + 1832) + v26;
      if (!v62[18])
        goto LABEL_33;
      v27 = v62[21];
      if (v27 == 1)
        break;
      if (v27 == 2)
      {
        v28 = *(_DWORD *)(a1 + 32) == 1;
        v29 = 4;
        goto LABEL_28;
      }
      v30 = 8;
LABEL_32:
      v31 = v30 * (int)v25;
      v32 = *(_QWORD *)(a1 + 19776);
      *(_QWORD *)(*((_QWORD *)v16 + 4) + 1848) = *(_QWORD *)(a2 + 1848) + v32 * v31;
      *(_QWORD *)(*((_QWORD *)v16 + 4) + 1856) = *(_QWORD *)(*((_QWORD *)v16 + 4) + 1848) + v32;
LABEL_33:
      *(_QWORD *)&v64 = v16;
      aj_init_out_stream(*((_QWORD *)v16 + 4) + 1928, (uint64_t)v63, (uint64_t *)&v66);
      v15 += v12;
      v16 += 168;
      if (!--v18)
      {
        v33 = v72;
        v34 = (pthread_t *)v68 + 1;
        do
        {
          pthread_create(v34, 0, (void *(__cdecl *)(void *))enc_job, v33);
          v33 += 168;
          ++v34;
          --v17;
        }
        while (v17);
        goto LABEL_36;
      }
    }
    v28 = *(_DWORD *)(a1 + 32) == 2;
    v29 = 16;
LABEL_28:
    if (v28)
      v30 = v29;
    else
      v30 = 8;
    goto LABEL_32;
  }
LABEL_36:
  enc_job((uint64_t)&v69);
  if ((int)v11 < 1)
    goto LABEL_57;
  v35 = 0;
  LODWORD(v36) = 0;
  v37 = (pthread_t *)v68;
  do
  {
    if (v35 * 4)
      pthread_join(*v37, 0);
    v38 = v70[v35 + 4];
    if (v38)
      v36 = v38;
    else
      v36 = v36;
    v35 += 42;
    ++v37;
  }
  while (42 * v11 != v35);
  if ((_DWORD)v36)
    goto LABEL_63;
  if ((int)v11 < 2)
    goto LABEL_57;
  v39 = (unsigned int *)v74;
  v40 = 1;
  while (2)
  {
    v41 = *(_QWORD *)(a2 + 2072);
    if (v41)
    {
      v42 = v71[21 * v40];
      v43 = *(int *)(v42 + 2084);
      if ((int)v43 < *(_DWORD *)(v42 + 2088))
      {
        v44 = *(_DWORD *)(a2 + 1944) - *(_DWORD *)(a2 + 2020);
        do
          *(_DWORD *)(v41 + 4 * v43++) += v44;
        while (v43 < *(int *)(v42 + 2088));
      }
    }
    v45 = 0;
    v46 = v39;
    do
    {
      v47 = (char *)*((_QWORD *)v46 - 1);
      if (!v47)
        break;
      v48 = aj_ostream_write_buf(a2 + 1928, v47, *v46);
      if ((_DWORD)v48)
      {
        v36 = v48;
        aj_log_error((uint64_t)"Enc", "IO error when copying buffer %d from thread %d");
        goto LABEL_63;
      }
      ++v45;
      v46 += 4;
    }
    while (v45 != 8);
    v49 = &v70[42 * v40 - 2];
    v51 = *((_QWORD *)v49 + 4);
    v50 = v49 + 8;
    v52 = aj_ostream_write_buf(a2 + 1928, *(char **)(v51 + 1952), *(_DWORD *)(v51 + 1936) - *(_QWORD *)(v51 + 1952));
    if (!(_DWORD)v52)
    {
      *(_DWORD *)(a2 + 2016) += *(_DWORD *)(*(_QWORD *)v50 + 2016);
      ++v40;
      v39 += 42;
      if (v40 != v11)
        continue;
LABEL_57:
      v36 = aj_ostream_flush_buffer(a2 + 1928);
      if ((_DWORD)v36)
        aj_log_error((uint64_t)"Enc", "IO error when flushing thread buffers");
      goto LABEL_63;
    }
    break;
  }
  v36 = v52;
  aj_log_error((uint64_t)"Enc", "IO error when copying buffer from thread %d");
LABEL_63:
  if ((int)v11 >= 2)
  {
    v53 = &v73;
    for (i = 1; i != v11; ++i)
    {
      v55 = &v70[42 * i - 2];
      v57 = *((_QWORD *)v55 + 4);
      v56 = v55 + 8;
      if (v57)
      {
        for (j = 0; j != 16; j += 2)
        {
          v59 = v53[j];
          if (!v59)
            break;
          (*(void (**)(uint64_t, _QWORD))(a4 + 8))(v59, *(_QWORD *)(a4 + 16));
          v53[j] = 0;
        }
        (*(void (**)(_QWORD, _QWORD))(a4 + 8))(*(_QWORD *)(*v56 + 1952), *(_QWORD *)(a4 + 16));
        (*(void (**)(_QWORD, _QWORD))(a4 + 8))(*(_QWORD *)(*v56 + 1792), *(_QWORD *)(a4 + 16));
        (*(void (**)(_QWORD, _QWORD))(a4 + 8))(*v56, *(_QWORD *)(a4 + 16));
        *v56 = 0;
      }
      v53 += 21;
    }
  }
  return v36;
}

uint64_t mt_write_callback(const void *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  void *v9;
  void *v10;

  v5 = 0;
  while (1)
  {
    v6 = a3 + v5;
    if (!*(_QWORD *)(a3 + v5 + 40))
      break;
    v5 += 16;
    if (v5 == 128)
    {
      aj_log_error((uint64_t)"Enc", "Max number of allocations used in thread job.");
      return 1;
    }
  }
  v7 = a2;
  *(_QWORD *)(v6 + 48) = a2;
  v8 = *(_QWORD *)(v6 + 40);
  if (v8)
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a3 + 8) + 8))(v8, *(_QWORD *)(*(_QWORD *)(a3 + 8) + 16));
  v9 = (void *)(**(uint64_t (***)(size_t, _QWORD))(a3 + 8))(v7, *(_QWORD *)(*(_QWORD *)(a3 + 8) + 16));
  *(_QWORD *)(v6 + 40) = v9;
  if (v9)
  {
    bzero(v9, v7);
    v10 = *(void **)(v6 + 40);
    if (v10)
    {
      memcpy(v10, a1, v7);
      return 0;
    }
  }
  return 1;
}

uint64_t enc_job(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)a1;
  v4 = *(_DWORD *)(a1 + 16);
  v5 = (int *)(*(_QWORD *)a1 + 19760);
  while (v4 < *(_DWORD *)(a1 + 20))
  {
    v6 = *v5;
    v7 = *v5 * v4;
    *(_DWORD *)(v2 + 1824) = v7;
    v8 = v6 + v7;
    *(_DWORD *)(v2 + 1828) = v8;
    *(_DWORD *)(v2 + 2060) = 0;
    v9 = *(_DWORD *)(v3 + 13432) * v7;
    v10 = *(_DWORD *)(v2 + 2056);
    v11 = v9 / v10;
    v12 = *(_DWORD *)(v2 + 2068);
    *(_DWORD *)(v2 + 2064) = ((_BYTE)v11 + (_BYTE)v12 - 1) & 7;
    if (v4 == *(_DWORD *)(a1 + 16))
      *(_DWORD *)(v2 + 2084) = v11;
    *(_DWORD *)(v2 + 2088) = v11;
    *(_QWORD *)(v2 + 2000) = 0;
    *(_QWORD *)(v2 + 2008) = 0;
    v13 = *(_DWORD *)(v3 + 13436);
    if (v8 >= v13)
    {
      *(_DWORD *)(v2 + 1828) = v13;
      LOBYTE(v14) = -39;
    }
    else
    {
      v14 = (*(_DWORD *)(v3 + 13432) * v8 / v10 + v12 - 1) & 7 | 0xFFFFFFD0;
    }
    v15 = aj_encode_all(v3, v2, v14);
    *(_DWORD *)(a1 + 24) = v15;
    ++v4;
    if (v15)
    {
      aj_log_error((uint64_t)"Enc", "IO error in MT encode job, mcu rows %d to %d", *(_DWORD *)(v2 + 1824), *(_DWORD *)(v2 + 1828));
      return 0;
    }
  }
  return 0;
}

int *plugin_iosaccelerator_create(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  int *v7;
  mach_port_t v8;
  const __CFDictionary *v9;
  io_service_t MatchingService;
  const __CFDictionary *v11;
  int v12;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  const __CFAllocator *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  IOSurfaceRef IOSurface;
  IOSurfaceRef v37;
  CFNumberRef v38;
  void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  int valuePtr;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x24BDAC8D0];
  v7 = (int *)malloc_type_calloc(1uLL, 0xE8uLL, 0x106004020B7C528uLL);
  if (!v7)
  {
    v12 = 6;
    goto LABEL_25;
  }
  v8 = *MEMORY[0x24BDD8B18];
  v9 = IOServiceMatching("AppleM2ScalerCSCDriver");
  MatchingService = IOServiceGetMatchingService(v8, v9);
  v11 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", CFSTR("IOSurfaceAcceleratorCapabilitiesDict"), 0, 0);
  IOObjectRelease(MatchingService);
  if (!v11)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to get scaler capabilities");
    goto LABEL_24;
  }
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorFilterVerticalTapsCount"), keys))
    goto LABEL_21;
  v7[2] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorFilterHorizontalTapsCount"), keys))
    goto LABEL_21;
  v7[3] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorFormatIn2Planes420"), keys))
    goto LABEL_21;
  *((_BYTE *)v7 + 16) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorFormatOut2Planes420"), keys))
    goto LABEL_21;
  *((_BYTE *)v7 + 17) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorFormatIn2Planes422"), keys))
    goto LABEL_21;
  *((_BYTE *)v7 + 18) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorFormatOut2Planes422"), keys))
    goto LABEL_21;
  *((_BYTE *)v7 + 19) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMinSourceWidth"), keys))
    goto LABEL_21;
  v7[5] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMinSourceHeight"), keys))
    goto LABEL_21;
  v7[6] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxSourceWidth"), keys))
    goto LABEL_21;
  v7[7] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxSourceHeight"), keys))
    goto LABEL_21;
  v7[8] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMinDestWidth"), keys))
    goto LABEL_21;
  v7[9] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMinDestHeight"), keys))
    goto LABEL_21;
  v7[10] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxDestWidth"), keys))
    goto LABEL_21;
  v7[11] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxDestHeight"), keys))
    goto LABEL_21;
  v7[12] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxHUpscale"), keys)
    || (v7[13] = (int)keys[0],
        keys[0] = 0,
        get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxHDownscale"), keys))
    || (v7[14] = (int)keys[0],
        keys[0] = 0,
        get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxVUpscale"), keys))
    || (v7[15] = (int)keys[0],
        keys[0] = 0,
        get_Int64_value(v11, CFSTR("IOSurfaceAcceleratorCapabilitiesMaxVDownscale"), keys)))
  {
LABEL_21:
    aj_log_error((uint64_t)"IOSAPlugin", "Bailing from get_scaler_setup");
    CFRelease(v11);
LABEL_24:
    v12 = 1;
    goto LABEL_25;
  }
  v7[16] = (int)keys[0];
  if (v7[2] != 9)
    aj_log_error((uint64_t)"IOSAPlugin", "WARNING: Device is reporting v_taps != 9. This not fatal but may lead to artifacts in image. Please file a radar to CoreMedia JPEG Software|All with device and OS versions for verification.");
  CFRelease(v11);
  if (v7[2] <= 0)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "vTaps is negative or zero: %d");
    goto LABEL_24;
  }
  if (v7[3] <= 0)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "hTaps is negative or zero: %d");
    goto LABEL_24;
  }
  v14 = a2[4];
  v12 = 3;
  if (v14 > 9)
  {
    if (v14 != 15)
    {
      if (v14 != 10)
        goto LABEL_25;
      if (!*((_BYTE *)v7 + 17) || !*((_BYTE *)v7 + 16))
      {
        aj_log_error((uint64_t)"IOSAPlugin", "Unsupported format: 420f");
        goto LABEL_25;
      }
    }
  }
  else if ((v14 - 3) >= 2)
  {
    if (v14 != 8)
      goto LABEL_25;
    if (!*((_BYTE *)v7 + 19) || !*((_BYTE *)v7 + 18))
    {
      aj_log_error((uint64_t)"IOSAPlugin", "Unsupported format: 422f");
      goto LABEL_25;
    }
  }
  v15 = *a2;
  if (*a2 > v7[7] || v15 < v7[5])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Input width is outside the supported range: %d");
    goto LABEL_25;
  }
  v16 = a2[2];
  if (v16 > v7[11] || v16 < v7[9])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Output width is outside the supported range: %d");
    goto LABEL_25;
  }
  if (v15 > v16 && v15 > v7[14] * v16 || v15 < v16 && v7[13] * v15 < v16)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Horizontal scaling factor is beyond the supported range: %d -> %d");
    goto LABEL_25;
  }
  v17 = a2[1];
  if (v17 < v7[6])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Input height is smaller than the supported min: %d");
    goto LABEL_25;
  }
  v18 = a2[3];
  if (v18 < v7[10])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Output height is smaller than the supported min: %d");
    goto LABEL_25;
  }
  if (a2[5] > v7[8])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "max-input-rows is larger than the supported max: %d");
    goto LABEL_25;
  }
  if (v17 < v18)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Up-scaling vertically is currently not supported");
    goto LABEL_25;
  }
  if (v17 <= v18 || v17 <= v7[16] * v18)
  {
    v19 = 0;
    if (v14 > 9)
    {
      if (v14 == 10)
      {
        v20 = 0x234323066;
LABEL_74:
        v19 = 1;
        v21 = 2;
        goto LABEL_75;
      }
    }
    else if ((v14 - 3) >= 2)
    {
      if (v14 != 8)
        goto LABEL_76;
      v20 = 0x134323266;
      goto LABEL_74;
    }
    v19 = 0;
    v20 = 0x142475241;
    v21 = 1;
LABEL_75:
    *((_QWORD *)v7 + 18) = v20;
    v7[38] = v21;
LABEL_76:
    v22 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    if (IOSurfaceAcceleratorCreate())
    {
      aj_log_error((uint64_t)"IOSAPlugin", "Unable to create the IOSurfaceAcceleratorRef");
    }
    else
    {
      v23 = a2[3];
      v24 = a2[1];
      v25 = (v23 << 20) / v24;
      v26 = (v24 << 20) / v23;
      *((_QWORD *)v7 + 24) = v25;
      *((_QWORD *)v7 + 25) = v26;
      *((_QWORD *)v7 + 26) = 0;
      v27 = v7[6];
      if (v27 <= (int)((v26 * v7[10] + 0xFFFFF) >> 20))
        v27 = (v26 * v7[10] + 0xFFFFF) >> 20;
      v28 = ((4 * v26 + 0xFFFFF) >> 20) + ((2 * v26 + 0xFFFFF) >> 20) + v27;
      v7[40] = v28;
      if (v7[37] == 2)
      {
        v29 = v26 & 0x1FFFFF;
        if ((v26 & 0x1FFFFF) > 0x100000)
          v29 = 0x200000 - (v26 & 0x1FFFFF);
        if (v29)
          v30 = 0x100000 / v29 + 1;
        else
          v30 = 1;
        v32 = (((v30 * v26 + 0xFFFFF) >> 20) & 1) + ((v30 * v26 + 0xFFFFF) >> 20);
        v31 = a2[5];
        if (v31 >= 0)
          v33 = a2[5];
        else
          v33 = v31 + 1;
        if (v32 <= v33 >> 1)
        {
          *((_BYTE *)v7 + 224) = 1;
          v28 += v32;
          v7[40] = v28;
        }
        else
        {
          *((_BYTE *)v7 + 224) = 0;
        }
      }
      else
      {
        *((_BYTE *)v7 + 224) = 0;
        v31 = a2[5];
      }
      v34 = v28 + v31;
      v7[39] = (v25 * v34 + 0xFFFFF) >> 20;
      if (v19)
        v35 = a2[2] & 1;
      else
        v35 = 0;
      IOSurface = create_IOSurface(*a2, v34, v7[36]);
      *((_QWORD *)v7 + 21) = IOSurface;
      if (IOSurface)
      {
        v37 = create_IOSurface(a2[2] + (unint64_t)v35, v7[39], v7[36]);
        *((_QWORD *)v7 + 22) = v37;
        if (v37)
        {
          v7[55] = 0;
          *((_QWORD *)v7 + 16) = *(_QWORD *)a2;
          *((_QWORD *)v7 + 17) = *((_QWORD *)a2 + 1);
          valuePtr = 0;
          v38 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
          v39 = (void *)*MEMORY[0x24BE51760];
          values = v38;
          keys[0] = v39;
          *((_QWORD *)v7 + 15) = CFDictionaryCreate(v22, (const void **)keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
          CFRelease(v38);
          v7[28] = a2[2] + v35;
          v7[29] = 0;
          *((_QWORD *)v7 + 13) = 0;
          *((_QWORD *)v7 + 11) = (uint64_t)*a2 << 16;
          *((_QWORD *)v7 + 12) = 0;
          *((_QWORD *)v7 + 9) = 0;
          *((_QWORD *)v7 + 10) = 0;
          set_plugin_config((uint64_t)v7, a3);
          v12 = 0;
          if (!a4)
            return v7;
          goto LABEL_26;
        }
        aj_log_error((uint64_t)"IOSAPlugin", "Couldn't create destination IOSurface");
      }
      else
      {
        aj_log_error((uint64_t)"IOSAPlugin", "Couldn't create source IOSurface");
      }
      if (*(_QWORD *)v7)
      {
        CFRelease(*(CFTypeRef *)v7);
        *(_QWORD *)v7 = 0;
      }
      v40 = (const void *)*((_QWORD *)v7 + 21);
      if (v40)
      {
        CFRelease(v40);
        *((_QWORD *)v7 + 21) = 0;
      }
      v41 = (const void *)*((_QWORD *)v7 + 22);
      if (v41)
      {
        CFRelease(v41);
        *((_QWORD *)v7 + 22) = 0;
      }
      v42 = (const void *)*((_QWORD *)v7 + 15);
      if (v42)
      {
        CFRelease(v42);
        *((_QWORD *)v7 + 15) = 0;
      }
    }
    goto LABEL_24;
  }
  aj_log_error((uint64_t)"IOSAPlugin", "Vertical scaling factor is beyond the supported range: %d -> %d");
LABEL_25:
  plugin_iosaccelerator_destroy(v7);
  v7 = 0;
  if (a4)
LABEL_26:
    *a4 = v12;
  return v7;
}

size_t set_plugin_config(uint64_t a1, uint64_t a2)
{
  size_t result;
  int64_t v5;
  _QWORD *v6;

  *(_QWORD *)a2 = *(_QWORD *)(a1 + 156);
  *(_DWORD *)(a2 + 8) = 1;
  *(_DWORD *)(a2 + 80) = 1;
  IOSurfaceLock(*(IOSurfaceRef *)(a1 + 168), 0, 0);
  *(_BYTE *)(a1 + 184) = 1;
  result = IOSurfaceLock(*(IOSurfaceRef *)(a1 + 176), 1u, 0);
  *(_BYTE *)(a1 + 185) = 1;
  if (*(int *)(a1 + 152) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = (_QWORD *)(a2 + 8 * v5);
      v6[2] = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 168), v5);
      v6[6] = (int)IOSurfaceGetBytesPerRowOfPlane(*(IOSurfaceRef *)(a1 + 168), v5);
      v6[11] = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 176), v5);
      result = IOSurfaceGetBytesPerRowOfPlane(*(IOSurfaceRef *)(a1 + 176), v5);
      v6[15] = (int)result;
      ++v5;
    }
    while (v5 < *(int *)(a1 + 152));
  }
  return result;
}

void plugin_iosaccelerator_destroy(_QWORD *a1)
{
  __IOSurface *v2;
  __IOSurface *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  if (a1)
  {
    if (*((_BYTE *)a1 + 184))
    {
      v2 = (__IOSurface *)a1[21];
      if (v2)
      {
        IOSurfaceUnlock(v2, 0, 0);
        *((_BYTE *)a1 + 184) = 0;
      }
    }
    if (*((_BYTE *)a1 + 185))
    {
      v3 = (__IOSurface *)a1[22];
      if (v3)
      {
        IOSurfaceUnlock(v3, 1u, 0);
        *((_BYTE *)a1 + 185) = 0;
      }
    }
    if (*a1)
    {
      CFRelease((CFTypeRef)*a1);
      *a1 = 0;
    }
    v4 = (const void *)a1[21];
    if (v4)
    {
      CFRelease(v4);
      a1[21] = 0;
    }
    v5 = (const void *)a1[22];
    if (v5)
    {
      CFRelease(v5);
      a1[22] = 0;
    }
    v6 = (const void *)a1[15];
    if (v6)
      CFRelease(v6);
    free(a1);
  }
}

uint64_t plugin_iosaccelerator_resize(uint64_t a1, int *a2, _DWORD *a3, int a4)
{
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t result;
  int v15;
  int v16;
  BOOL v17;
  int v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  char *v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  __IOSurface *v29;
  int PlaneCount;
  BOOL v31;
  size_t v32;
  int v33;
  uint64_t v34;
  char v35;
  int v36;
  int v37;
  size_t BytesPerRowOfPlane;
  char *BaseAddressOfPlane;
  uint64_t v40;
  _DWORD *v41;

  if (!a1)
    return 1;
  v7 = *a2;
  v8 = a2[1];
  v9 = *(_DWORD *)(a1 + 220) + *a2;
  *(_DWORD *)(a1 + 220) = v9;
  v10 = v8 + v7;
  if (a4)
  {
    LODWORD(v11) = *(_DWORD *)(a1 + 140) - *(_DWORD *)(a1 + 216);
    v12 = *(_QWORD *)(a1 + 208);
    v13 = ((uint64_t)v10 << 20) - v12;
  }
  else
  {
    v15 = *(_DWORD *)(a1 + 132) - v9;
    v16 = *(_DWORD *)(a1 + 24);
    v17 = __OFSUB__(v16, v15);
    v18 = v16 - v15;
    if ((v18 < 0) ^ v17 | (v18 == 0))
      v19 = 0;
    else
      v19 = v18;
    v20 = *(_QWORD *)(a1 + 192);
    v21 = *(int *)(a1 + 40);
    if (v21 > (unint64_t)(v20 * (v19 + v15)) >> 20)
      v19 = ((*(_QWORD *)(a1 + 200) * v21 + 0xFFFFF) >> 20) - v15;
    LODWORD(v11) = ((unint64_t)(v20 * (v9 - v19) + 0x80000) >> 20) - *(_DWORD *)(a1 + 216);
    if (*(int *)(a1 + 148) >= 2)
    {
      LODWORD(v11) = v11 & 0xFFFFFFFE;
      if (*(_BYTE *)(a1 + 224))
      {
        v22 = v11 + 2;
        do
          v22 -= 2;
        while (((*(_QWORD *)(a1 + 200) * v22) & 0x100000) != 0);
        if (v22)
          LODWORD(v11) = v22;
      }
    }
    v12 = *(_QWORD *)(a1 + 208);
    v13 = *(_QWORD *)(a1 + 200) * (int)v11;
  }
  *(_QWORD *)(a1 + 96) = v13 >> 4;
  *(_DWORD *)(a1 + 116) = v11;
  *(_QWORD *)(a1 + 80) = v12 >> 4;
  if (*(_BYTE *)(a1 + 184))
  {
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 168), 0, 0);
    *(_BYTE *)(a1 + 184) = 0;
  }
  if (*(_BYTE *)(a1 + 185))
  {
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 176), 1u, 0);
    *(_BYTE *)(a1 + 185) = 0;
  }
  v23 = IOSurfaceAcceleratorTransformSurface();
  if ((_DWORD)v23)
  {
    v40 = v23;
    v24 = "Rescaling error: 0x%X";
LABEL_23:
    aj_log_error((uint64_t)"IOSAPlugin", v24, v40);
    return 1;
  }
  IOSurfaceLock(*(IOSurfaceRef *)(a1 + 168), 0, 0);
  *(_BYTE *)(a1 + 184) = 1;
  IOSurfaceLock(*(IOSurfaceRef *)(a1 + 176), 1u, 0);
  *(_BYTE *)(a1 + 185) = 1;
  if (a4 || (int)v11 < 5)
  {
    v25 = *(_QWORD *)(a1 + 208) + v13;
    *(_QWORD *)(a1 + 208) = v25;
    *(_DWORD *)(a1 + 216) += v11;
    if (a4)
    {
      v26 = 0;
      goto LABEL_46;
    }
  }
  else
  {
    v11 = (v11 - 4);
    v25 = *(_QWORD *)(a1 + 208) + *(_QWORD *)(a1 + 200) * v11;
    *(_DWORD *)(a1 + 216) += v11;
  }
  v27 = *(_DWORD *)(a1 + 148);
  if (v27 <= 1)
    v28 = v25 >> 20;
  else
    v28 = (v25 >> 20) & 0xFFFFFFFE;
  *(_QWORD *)(a1 + 208) = v25 - ((uint64_t)v28 << 20);
  v26 = v10 - v28;
  v29 = *(__IOSurface **)(a1 + 168);
  PlaneCount = IOSurfaceGetPlaneCount(v29);
  if (v28)
    v31 = v26 == 0;
  else
    v31 = 1;
  if (!v31)
  {
    if (v27 == 2)
    {
      if ((v26 & 1) != 0)
      {
        v24 = "nrows is not even";
        goto LABEL_23;
      }
      if ((v28 & 1) != 0)
      {
        v24 = "Offset is not even";
        goto LABEL_23;
      }
    }
    if (PlaneCount >= 1)
    {
      v41 = a3;
      v32 = 0;
      v33 = v27 >> 1;
      v34 = PlaneCount;
      do
      {
        if (v32)
          v35 = v33;
        else
          v35 = 0;
        v36 = v26 >> v35;
        v37 = v28 >> v35;
        BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v29, v32);
        BaseAddressOfPlane = (char *)IOSurfaceGetBaseAddressOfPlane(v29, v32);
        memmove(BaseAddressOfPlane, &BaseAddressOfPlane[BytesPerRowOfPlane * v37], BytesPerRowOfPlane * v36);
        ++v32;
      }
      while (v34 != v32);
      a3 = v41;
    }
  }
LABEL_46:
  result = 0;
  *a3 = v11;
  a3[1] = v26;
  return result;
}

uint64_t get_Int64_value(const __CFDictionary *a1, const void *a2, void *a3)
{
  const __CFNumber *Value;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt64Type, a3);
    return 0;
  }
  else
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to get value for key.");
    return 1;
  }
}

IOSurfaceRef create_IOSurface(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  unint64_t v7;
  CFIndex v8;
  int v9;
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  unint64_t v12;
  unint64_t v13;
  CFMutableArrayRef v14;
  __CFArray *v15;
  __CFDictionary *v16;
  __CFDictionary *v17;
  int v18;
  char v19;
  char v20;
  int v21;
  unint64_t v22;
  const void *v23;
  int v24;
  const void *v25;
  const void *v26;
  const void *v27;
  __CFDictionary *v28;
  __CFDictionary *v29;
  unint64_t v30;
  IOSurfaceRef v31;
  char v33;
  int v34;

  if (a3 > 1111970368)
  {
    if (a3 != 1111970369 && a3 != 1380401729)
      goto LABEL_34;
    v6 = 0;
    v9 = 0;
    v7 = 1;
    v8 = 1;
  }
  else
  {
    if (a3 != 875704422)
    {
      if (a3 == 875704934)
      {
        v6 = 0;
        v7 = 1;
        v8 = 2;
        v9 = 1;
        goto LABEL_9;
      }
LABEL_34:
      aj_log_error((uint64_t)"IOSAPlugin", "Only 420f, 422f and RGBA/BGRA are supported");
      return 0;
    }
    v6 = 1;
    v7 = 2;
    v9 = 1;
    v8 = 2;
  }
LABEL_9:
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to create options dictionary");
    return 0;
  }
  v11 = Mutable;
  v12 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8;
  v13 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  set_int_value(Mutable, (const void *)*MEMORY[0x24BDD8EF8], a3);
  set_int_value(v11, (const void *)*MEMORY[0x24BDD8FD0], a1);
  set_int_value(v11, (const void *)*MEMORY[0x24BDD8EB0], a2);
  v14 = CFArrayCreateMutable(0, v8, MEMORY[0x24BDBD690]);
  if (v14)
  {
    v15 = v14;
    v16 = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (v16)
    {
      v17 = v16;
      set_int_value(v16, (const void *)*MEMORY[0x24BDD8FA8], a1);
      set_int_value(v17, (const void *)*MEMORY[0x24BDD8F70], a2);
      if (v9)
        v18 = 1;
      else
        v18 = 4;
      v19 = 2;
      if (v9)
        v20 = 0;
      else
        v20 = 2;
      if (v9)
        v19 = 0;
      v33 = v19;
      set_int_value(v17, (const void *)*MEMORY[0x24BDD8F10], v18);
      v34 = v6;
      v21 = v9;
      v22 = v7;
      v23 = (const void *)*MEMORY[0x24BDD8F18];
      set_int_value(v17, (const void *)*MEMORY[0x24BDD8F90], 0);
      v24 = (_DWORD)v12 << v20;
      v25 = (const void *)*MEMORY[0x24BDD8F98];
      v26 = v23;
      v7 = v22;
      v9 = v21;
      v6 = v34;
      set_int_value(v17, v26, v24);
      v27 = v25;
      v13 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
      set_int_value(v17, v27, ((((_DWORD)a2 + 7) & 0xFFFFFFF8) * (_DWORD)v12) << v33);
      CFArrayAppendValue(v15, v17);
      CFRelease(v17);
    }
    if (v9)
    {
      v28 = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
      if (v28)
      {
        v29 = v28;
        if (v6)
          LODWORD(a2) = (unint64_t)(a2 + 1) >> 1;
        set_int_value(v28, (const void *)*MEMORY[0x24BDD8FA8], (unint64_t)(a1 + 1) >> 1);
        set_int_value(v29, (const void *)*MEMORY[0x24BDD8F70], a2);
        set_int_value(v29, (const void *)*MEMORY[0x24BDD8F10], 2);
        set_int_value(v29, (const void *)*MEMORY[0x24BDD8F90], v13 * v12);
        set_int_value(v29, (const void *)*MEMORY[0x24BDD8F18], v12);
        set_int_value(v29, (const void *)*MEMORY[0x24BDD8F98], v13 / v7 * v12);
        CFArrayAppendValue(v15, v29);
        CFRelease(v29);
      }
    }
    CFDictionarySetValue(v11, (const void *)*MEMORY[0x24BDD8F88], v15);
    CFRelease(v15);
  }
  if (v9)
    v30 = (v13 / v7 + v13) * v12;
  else
    LODWORD(v30) = 4 * v13 * v12;
  set_int_value(v11, (const void *)*MEMORY[0x24BDD8E18], v30);
  v31 = IOSurfaceCreate(v11);
  if (!v31)
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to create an output surface");
  CFRelease(v11);
  return v31;
}

void set_int_value(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  if (v5)
    CFRelease(v5);
}

_QWORD *aj_reset_mcustate(_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0x700000000;
  return result;
}

int *aj_calc_crop(int *result, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6)
{
  unsigned int v6;
  unsigned int v7;
  int v8;
  int v9;
  BOOL v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  BOOL v23;
  int v24;
  signed int v25;

  if (a6)
  {
    v7 = result[2];
    v6 = result[3];
    v9 = *result;
    v8 = result[1];
    v12 = v6 == -1 && v7 == -1 && v9 == -1 && v8 == -1;
    if (v12)
      v8 = 0;
    if (v12)
      v9 = 0;
    if (v12)
      v7 = a2;
    if (v12)
      v6 = a3;
    v13 = (int)(v7 << 15) / a4;
    v14 = a4 + 2;
    if (a4 >= -1)
      v14 = a4 + 1;
    v15 = v7 * a5 + (v14 >> 1);
    v16 = a5 + 2;
    if (a5 >= -1)
      v16 = a5 + 1;
    v17 = v6 * a4 + (v16 >> 1);
    v18 = (int)(v6 << 15) / a5;
    v19 = v17 / a5;
    v20 = v13 <= v18;
    if (v13 > v18)
      v21 = v19;
    else
      v21 = v7;
    v22 = v15 / a4;
    if (!v20)
      v22 = v6;
    if (v21 <= 1)
      v21 = 1;
    if (v22 <= 1)
      v22 = 1;
    v23 = __OFSUB__(v7, v21);
    v24 = v7 - v21;
    v25 = v6 - v22;
    if (v24 < 0 != v23)
      ++v24;
    *a6 = v9 + (v24 >> 1);
    a6[1] = v8 + v25 / 2;
    a6[2] = v21;
    a6[3] = v22;
  }
  return result;
}

uint64_t fill_image_edges(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  __int16 v18;
  __int16 v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  char *v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  _BYTE v43[12];
  int v44;
  int v45;
  int v46;
  _QWORD v47[2];
  _DWORD v48[2];
  _DWORD v49[2];
  _DWORD v50[2];
  uint64_t v51;

  v1 = result;
  v51 = *MEMORY[0x24BDAC8D0];
  v2 = *(_DWORD *)(result + 6608);
  v46 = 0;
  if (*(_DWORD *)(result + 6592)
    || *(_DWORD *)(result + 6596)
    || *(_DWORD *)(result + 6584)
    || *(_DWORD *)(result + 6588))
  {
    v3 = BYTE2(v2);
    v4 = BYTE1(v2);
    v5 = v2;
    result = 16448;
    v6 = (BYTE2(v2) << 6)
       - (((340992 * v2 + 0x4000) >> 15)
        + ((1756160 * BYTE1(v2) + 0x4000) >> 15))
       + 16448;
    v7 = v6 >> 7;
    v8 = (v2 << 6)
       - (((1389568 * BYTE1(v2) + 0x4000) >> 15)
        + ((707584 * BYTE2(v2) + 0x4000) >> 15))
       + 16448;
    if (v8 >= 0x8000)
      LOBYTE(v9) = -1;
    else
      v9 = v8 >> 7;
    if (v6 >= 0x8000)
      LOBYTE(v7) = -1;
    v10 = ((478208 * v2 + 0x4000) >> 15)
        + ((2462080 * BYTE1(v2) + 0x4000) >> 15)
        + ((1254144 * BYTE2(v2) + 0x4000) >> 15)
        + 64;
    v11 = *(_DWORD *)(v1 + 6580);
    if (v11 == 7)
    {
      LOBYTE(v46) = v10 >> 7;
      BYTE1(v46) = v9;
      BYTE2(v46) = v46;
      HIBYTE(v46) = v7;
      v12 = 4;
      v13 = 2;
      v14 = *(_DWORD *)(v1 + 24);
    }
    else
    {
      v14 = *(_DWORD *)(v1 + 24);
      if (v14 == 2)
      {
        LOBYTE(v46) = v10 >> 7;
        BYTE1(v46) = v46;
        BYTE2(v46) = v9;
        HIBYTE(v46) = v7;
      }
      else if ((v11 - 1) < 2)
      {
        v15 = (BYTE1(v2) + 2) >> 2;
        if (v3 >= 0xFC)
          LOWORD(v16) = 31;
        else
          v16 = (v3 + 4) >> 3;
        v17 = (v5 + 4) >> 3;
        if (v4 >= 0xFE)
          LOWORD(v15) = 63;
        if (v5 >= 0xFC)
          LOWORD(v17) = 31;
        v18 = 32 * v15;
        if (v11 == 1)
          v19 = v18 | ((_WORD)v17 << 11) | v16;
        else
          v19 = v18 | ((_WORD)v16 << 11) | v17;
        LOWORD(v46) = v19;
      }
      else if (v11 == 15)
      {
        v20 = (BYTE2(v2) | BYTE1(v2) | v2) == 0;
        if (*(_BYTE *)(v1 + 6937))
        {
          if (*(_DWORD *)(v1 + 6940) && *(_DWORD *)(*(_QWORD *)(v1 + 8) + 356))
          {
            LOBYTE(v46) = ~(v10 >> 7);
            BYTE1(v46) = ~(_BYTE)v9;
            LOBYTE(v2) = ~(_BYTE)v7;
          }
          else
          {
            LOBYTE(v46) = BYTE2(v2);
            BYTE1(v46) = BYTE1(v2);
          }
          BYTE2(v46) = v2;
          LOBYTE(v2) = v20 - 1;
        }
        else
        {
          LOBYTE(v46) = ~HIWORD(v2);
          BYTE1(v46) = ~(v2 >> 8);
          BYTE2(v46) = ~(_BYTE)v2;
          v2 = v20 << 31 >> 31;
        }
        HIBYTE(v46) = v2;
      }
      else if (v11 == 6)
      {
        LOBYTE(v46) = v10 >> 7;
        BYTE1(v46) = v9;
        BYTE2(v46) = v7;
      }
      else
      {
        LOBYTE(v46) = BYTE2(v2);
        BYTE1(v46) = BYTE1(v2);
        BYTE2(v46) = v2;
        HIBYTE(v46) = HIBYTE(v2);
      }
      v12 = *(_DWORD *)(v1 + 28);
      v13 = 1;
    }
    v21 = *(_DWORD *)(v1 + 32);
    v50[0] = v12;
    v50[1] = v21;
    v22 = *(_DWORD *)(v1 + 44);
    v23 = *(_DWORD *)(v1 + 48);
    v49[0] = v13;
    v49[1] = v22;
    v48[0] = 1;
    v48[1] = v23;
    v47[0] = &v46;
    v47[1] = (char *)&v46 + 2;
    if (v14 >= 1)
    {
      v24 = 0;
      do
      {
        v25 = v49[v24];
        v26 = *(_DWORD *)(v1 + 6492) / v25;
        v27 = *(_DWORD *)(v1 + 6496);
        v28 = v48[v24];
        v29 = *(_DWORD *)(v1 + 6584);
        v30 = *(_DWORD *)(v1 + 6588);
        v31 = v27 / v28;
        if (*(_QWORD *)(v1 + 6584))
        {
          *(_DWORD *)&v43[8] = 0;
          v44 = v26;
          v45 = v29 / v28;
          v40 = 0;
          v41 = (v27 - v30) / v28;
          v42 = v26;
          *(_QWORD *)v43 = (v30 / v28);
          v32 = v1 + 8 * v24;
          v33 = (char *)v47[v24];
          v34 = v50[v24];
          aj_paint_region(*(void **)(v32 + 64), *(_DWORD *)(v1 + 6808), v33, v34, v26, *(_QWORD *)(v32 + 96), v31, (int *)&v43[4]);
          result = (uint64_t)aj_paint_region(*(void **)(v32 + 64), *(_DWORD *)(v1 + 6808), v33, v34, v26, *(_QWORD *)(v32 + 96), v31, &v40);
        }
        v35 = *(_DWORD *)(v1 + 6592);
        v36 = *(_DWORD *)(v1 + 6596);
        if (*(_QWORD *)(v1 + 6592))
        {
          *(_QWORD *)&v43[4] = 0;
          v44 = v35 / v25;
          v45 = v31;
          v40 = (*(_DWORD *)(v1 + 6492) - v36) / v25;
          v41 = 0;
          v42 = v36 / v25;
          *(_DWORD *)v43 = v31;
          v37 = v1 + 8 * v24;
          v38 = (char *)v47[v24];
          v39 = v50[v24];
          aj_paint_region(*(void **)(v37 + 64), *(_DWORD *)(v1 + 6808), v38, v39, v26, *(_QWORD *)(v37 + 96), v31, (int *)&v43[4]);
          result = (uint64_t)aj_paint_region(*(void **)(v37 + 64), *(_DWORD *)(v1 + 6808), v38, v39, v26, *(_QWORD *)(v37 + 96), v31, &v40);
        }
        ++v24;
      }
      while (v24 < *(int *)(v1 + 24));
    }
  }
  return result;
}

uint64_t aj_decode_init_index(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10)
{
  int v18;
  __int128 v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  int v26;

  reset_decode_job(a5);
  bzero(a3, 0x1B40uLL);
  *((_BYTE *)a3 + 16) = 1;
  *a3 = a6;
  a3[1] = a4;
  *(_DWORD *)a5 = *((_BYTE *)a6 + 84) == 0;
  *(_QWORD *)((char *)a3 + 6804) = 0;
  *((_DWORD *)a3 + 42) = 8;
  *((_DWORD *)a3 + 1653) = 0;
  *((_DWORD *)a3 + 1657) = 1;
  *(_QWORD *)((char *)a3 + 6484) = *((_QWORD *)a6 + 1);
  *((_DWORD *)a3 + 1704) = 0;
  *((_DWORD *)a3 + 1645) = 0;
  *((_DWORD *)a3 + 1721) = 1;
  *(_QWORD *)((char *)a3 + 6892) = 0x100000001;
  if (a8)
  {
    v18 = *(_DWORD *)(a8 + 112);
    v19 = *(_OWORD *)(a8 + 120);
  }
  else
  {
    v18 = 0;
    v19 = 0uLL;
  }
  *(_DWORD *)(a5 + 1496) = v18;
  *(_OWORD *)(a5 + 1504) = v19;
  if (!*(_DWORD *)a5)
    return 0;
  result = init_ra_table(a4, a5, a9, *(_DWORD *)(a8 + 104), *(_DWORD *)(a8 + 108), a2);
  if (!(_DWORD)result)
  {
    if (*a6 >= 1)
    {
      v21 = 0;
      v22 = (uint64_t)(a3 + 24);
      do
      {
        aj_init_component((uint64_t)a3, v22, v21++, 0, 1);
        v22 += 1568;
      }
      while (v21 < *a6);
    }
    a3[20] = aj_mcu_decode_index;
    v23 = *(unsigned int *)*a3;
    if ((int)v23 >= 1)
    {
      v24 = a3 + 90;
      do
      {
        *v24 = aj_block_decode_skip;
        v24 += 196;
        --v23;
      }
      while (v23);
    }
    v25 = *(_DWORD *)a8;
    if (*(int *)a8 >= 8)
      v25 = 8;
    if (v25 <= 1)
      v26 = 1;
    else
      v26 = v25;
    *((_DWORD *)a3 + 1737) = aj_get_numthreads_ratbl(a3, *(_QWORD *)(a7 + 80) == 0, v26);
    result = aj_init_decode_jobs((uint64_t)a3, (_DWORD *)a5, a4, a1, a9, 1);
    if (!(_DWORD)result)
      return aj_init_input_states((uint64_t)a3, a5, a7, a10, 0);
  }
  return result;
}

uint8x8_t **aj_icol_row_444_to_bgra(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, int16x8_t *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64x2_t a9, uint64_t a10, uint64_t a11, unsigned int a12)
{
  uint8x8_t v12;
  int8x16_t v13;
  uint8x8_t *v14;
  uint8x8_t *v15;
  uint8x8_t *v16;
  unsigned int i;
  uint8x8_t v18;
  uint8x8_t v19;
  uint8x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int v29;

  v12 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  v13 = vdupq_n_s8(0xFFu);
  v14 = *result;
  v15 = *a2;
  v16 = *a3;
  for (i = a12 >> 3; i; --i)
  {
    v18 = *v14++;
    v19 = *v15++;
    v20 = *v16++;
    v21 = (int16x8_t)vshll_n_u8(v18, 7uLL);
    v22 = (int16x8_t)vsubl_u8(v19, v12);
    v23 = (int16x8_t)vsubl_u8(v20, v12);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_n_s16(v23, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v21, vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    v24 = (int16x8_t)vzip1q_s8((int8x16_t)a7, (int8x16_t)a8);
    v25 = (int16x8_t)vzip1q_s8((int8x16_t)a9, v13);
    *a4 = vzip1q_s16(v24, v25);
    a4[1] = vzip2q_s16(v24, v25);
    a4 += 2;
  }
  if ((a12 & 7) != 0)
  {
    v26 = (int16x8_t)vshll_n_u8(*v14, 7uLL);
    v27 = (int16x8_t)vsubl_u8(*v15, v12);
    v28 = (int16x8_t)vsubl_u8(*v16, v12);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_n_s16(v28, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v26, vqaddq_s16(vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v28, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    v29 = a12 & 7;
    do
    {
      a4->i8[0] = a7.i8[0];
      a4->i8[1] = a8.i8[0];
      a4->i8[2] = a9.i8[0];
      a4->i8[3] = v13.i8[0];
      a4 = (int16x8_t *)((char *)a4 + 4);
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      a9 = vshrq_n_u64(a9, 8uLL);
      --v29;
    }
    while (v29);
  }
  return result;
}

uint64_t aj_RGBA8888_YUV422(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4)
{
  const char *v4;
  int8x8_t *v5;
  uint8x8_t *v6;
  uint8x8_t *v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  unsigned int i;
  const char *v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int8x8_t *v19;
  int8x8x4_t v21;
  int8x8x4_t v22;

  v4 = *a2;
  v5 = *(int8x8_t **)a3;
  v6 = *(uint8x8_t **)(a3 + 16);
  v7 = *(uint8x8_t **)(a3 + 32);
  v8.i64[0] = 0x80008000800080;
  v8.i64[1] = 0x80008000800080;
  v9 = vshlq_n_s16(v8, 7uLL);
  v10.i64[0] = 0x15980E984B232646;
  v10.i64[1] = 0xA6835982A68;
  for (i = a4 >> 4; i; --i)
  {
    v21 = vld4_s8(v4);
    v12 = v4 + 32;
    v22 = vld4_s8(v12);
    v4 = v12 + 32;
    v13 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[0], 7uLL);
    v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[1], 7uLL);
    v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[2], 7uLL);
    v21.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v14, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v15, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v21.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v14, v10, 4)), vrshrq_n_s16(v15, 1uLL)), 7uLL);
    v21.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v13, 1uLL), vqrdmulhq_laneq_s16(v14, v10, 5)), vqrdmulhq_laneq_s16(v15, v10, 6)), v9), 7uLL);
    v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[0], 7uLL);
    v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[1], 7uLL);
    v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[2], 7uLL);
    v22.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v17, v10, 4)), vrshrq_n_s16(v18, 1uLL)), 7uLL);
    v22.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v16, 1uLL), vqrdmulhq_laneq_s16(v17, v10, 5)), vqrdmulhq_laneq_s16(v18, v10, 6)), v9), 7uLL);
    *v5 = v21.val[0];
    v19 = v5 + 1;
    *v19 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v17, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v5 = v19 + 1;
    *v6++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[1], v22.val[1]), (uint8x8_t)vuzp2_s8(v21.val[1], v22.val[1]));
    *v7++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[2], v22.val[2]), (uint8x8_t)vuzp2_s8(v21.val[2], v22.val[2]));
  }
  if ((a4 & 8) == 0)
    JUMPOUT(0x2062522C4);
  return sub_206252240();
}

uint64_t sub_206252240(int16x8_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5, int a6, _DWORD *a7, _DWORD *a8, _QWORD *a9)
{
  int64x2_t v9;
  int64x2_t v10;
  int64x2_t v11;
  int16x8_t v12;
  __int8 *v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  uint64_t result;
  unsigned int v28;
  char v29;
  char v30;
  char v31;
  int8x8x4_t v32;

  v32 = vld4_s8(a3);
  v13 = (__int8 *)(a3 + 32);
  v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[0], 7uLL);
  v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[1], 7uLL);
  v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[2], 7uLL);
  *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v15, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v16, *(int16x4_t *)a1.i8, 2)), 7uLL);
  v32.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v15, a1, 4)), vrshrq_n_s16(v16, 1uLL)), 7uLL);
  v32.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v14, 1uLL), vqrdmulhq_laneq_s16(v15, a1, 5)), vqrdmulhq_laneq_s16(v16, a1, 6)), v12), 7uLL);
  *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[1], v32.val[1]), (uint8x8_t)vuzp2_s8(v32.val[1], v32.val[1]));
  *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[2], v32.val[2]), (uint8x8_t)vuzp2_s8(v32.val[2], v32.val[2]));
  *a9 = v9.i64[0];
  v17 = a9 + 1;
  *a7 = v10.i32[0];
  v18 = a7 + 1;
  *a8 = v11.i32[0];
  v19 = a8 + 1;
  v20 = a5 & 7;
  if ((a5 & 7) != 0)
  {
    do
    {
      v9 = vshlq_n_s64(v9, 8uLL);
      v10 = vshlq_n_s64(v10, 8uLL);
      v11 = vshlq_n_s64(v11, 8uLL);
      v9.i8[0] = *v13;
      v10.i8[0] = v13[1];
      v11.i8[0] = v13[2];
      v13 += 4;
      --v20;
    }
    while (v20);
    v21 = a5 & 7;
    v22 = 8 - v21;
    v23 = (v21 + 1) >> 1;
    v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
    v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
    v26 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v11.i8, 7uLL);
    *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v25, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v26, *(int16x4_t *)a1.i8, 2)), 7uLL);
    *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v25, a1, 4)), vrshrq_n_s16(v26, 1uLL)), 7uLL);
    *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v24, 1uLL), vqrdmulhq_laneq_s16(v25, a1, 5)), vqrdmulhq_laneq_s16(v26, a1, 6)), v12), 7uLL);
    do
    {
      v9 = vsliq_n_s64(v9, v9, 8uLL);
      v10 = vsliq_n_s64(v10, v10, 8uLL);
      v11 = vsliq_n_s64(v11, v11, 8uLL);
      --v22;
    }
    while (v22);
    *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8));
    *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8));
    do
    {
      *v17++ = v9.i8[7];
      v9 = vshlq_n_s64(v9, 8uLL);
      --v21;
    }
    while (v21);
    do
    {
      *v18++ = v10.i8[3];
      *v19++ = v11.i8[3];
      v10 = vshlq_n_s64(v10, 8uLL);
      v11 = vshlq_n_s64(v11, 8uLL);
      --v23;
    }
    while (v23);
  }
  result = (a6 - a5);
  if (a6 != a5)
  {
    v28 = result >> 1;
    v29 = *(v17 - 1);
    v30 = *(v18 - 1);
    v31 = *(v19 - 1);
    do
    {
      *v17++ = v29;
      result = (result - 1);
    }
    while ((_DWORD)result);
    for (; v28; --v28)
    {
      *v18++ = v30;
      *v19++ = v31;
    }
  }
  return result;
}

uint64_t aj_bufferprocessor_maxoutrows_default(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
    return (*(uint64_t (**)(void))(v4 + 8))();
  else
    return a4;
}

void *aj_huffman_encode_init_baseline(uint64_t a1, int a2, int a3)
{
  *(_WORD *)(a1 + 272) = a3;
  return aj_huffman_fill_standard_counts_values((_OWORD *)a1, (void *)(a1 + 16), a2, a3);
}

void *aj_huffman_fill_standard_counts_values(_OWORD *a1, void *__dst, int a3, int a4)
{
  char *v4;
  char *v5;
  size_t v6;

  v4 = (char *)&std_huffman_luma;
  if (!a3)
    v4 = (char *)&std_huffman_chroma;
  v5 = &v4[4500 * (a4 == 0)];
  *a1 = *(_OWORD *)v5;
  if (a4)
    v6 = 16;
  else
    v6 = 256;
  return memcpy(__dst, v5 + 16, v6);
}

void aj_huffman_encode_init_progressive(uint64_t a1, int a2, int a3, int a4)
{
  _BOOL8 v4;
  uint64_t v5;
  size_t v6;

  *(_BYTE *)(a1 + 272) = a3;
  *(_BYTE *)(a1 + 273) = 0;
  v4 = a3 == 0;
  *(_OWORD *)a1 = *(_OWORD *)*(&aj_huffman_encode_init_progressive_countvecs + 4 * v4 + 2 * (a2 == 0) + (a4 == 0));
  v5 = a1 + 16;
  v6 = aj_huffman_encode_init_progressive_nsyms[2 * v4 + (a4 == 0)];
  memcpy((void *)(a1 + 16), *(&aj_huffman_encode_init_progressive_valuevecs + 4 * v4 + 2 * (a2 == 0) + (a4 == 0)), v6);
  bzero((void *)(v5 + v6), 256 - v6);
}

_QWORD *plugin_vimage_create(uint64_t a1, uint64_t *a2, _DWORD *a3, int *a4)
{
  _QWORD *v7;
  _QWORD *v8;
  unsigned int v9;
  int v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  int v15;

  v7 = malloc_type_calloc(1uLL, 0x28uLL, 0x1010040139C5EC2uLL);
  v8 = v7;
  if (!v7)
  {
    aj_log_error(0, "Unable to allocate session");
LABEL_14:
    v11 = 6;
    goto LABEL_15;
  }
  v9 = *((_DWORD *)a2 + 4);
  if (v9 > 0xF || ((1 << v9) & 0x8018) == 0)
  {
    aj_log_error(0, "Unsupported dataformat: %d", *((_DWORD *)a2 + 4));
    v11 = 3;
    goto LABEL_15;
  }
  if (*((_DWORD *)a2 + 5) > *((_DWORD *)a2 + 1))
  {
    aj_log_error(0, "Max_input_rows is larger than input height");
    v11 = 1;
LABEL_15:
    if (a4)
      *a4 = v11;
    if (v8)
    {
      plugin_vimage_destroy(v8);
      return 0;
    }
    return v8;
  }
  v12 = a2[1];
  v7[1] = v12;
  v13 = *a2;
  *v7 = *a2;
  LODWORD(v12) = 4 * v12;
  v7[4] = (int)v12;
  v14 = malloc_type_malloc(SHIDWORD(v13) * (uint64_t)(int)v12, 0x9B906E5DuLL);
  v8[3] = v14;
  if (!v14)
  {
    aj_log_error(0, "Unable to allocate temp buffer");
    goto LABEL_14;
  }
  v15 = *((_DWORD *)a2 + 3);
  a3[20] = 0;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = v15;
  if (a4)
    *a4 = 0;
  return v8;
}

void plugin_vimage_destroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    v2 = (void *)a1[3];
    if (v2)
      free(v2);
    free(a1);
  }
}

vImage_Error plugin_vimage_resize(int *a1, unsigned int *a2, uint64_t a3, int a4)
{
  vImagePixelCount v4;
  uint64_t v5;
  int v6;
  size_t v11;
  void *v12;
  size_t v13;
  void *v14;
  void *v15;
  size_t v16;
  vImagePixelCount v17;
  void *v18;
  size_t v19;
  vImagePixelCount v20;
  vImage_Error result;
  vImage_Buffer dest;
  vImage_Buffer src;

  v4 = *a2;
  v5 = a1[4];
  v6 = v5 + v4;
  if ((int)v5 + (int)v4 <= a1[1])
  {
    if ((int)v4 >= 1)
    {
      v11 = *((_QWORD *)a2 + 1);
      v12 = (void *)(*((_QWORD *)a2 + 5) + v11 * (int)a2[1]);
      v13 = *((_QWORD *)a1 + 4);
      v14 = (void *)(*((_QWORD *)a1 + 3) + v13 * v5);
      src.width = *a1;
      src.rowBytes = v11;
      src.data = v12;
      src.height = v4;
      dest.width = a1[2];
      dest.rowBytes = v13;
      dest.data = v14;
      dest.height = v4;
      if (vImageScale_ARGB8888(&src, &dest, 0, 8u))
      {
LABEL_8:
        aj_log_error(0, "Error from vImage: %d");
        return 1;
      }
      v6 = a1[4] + v4;
    }
    a1[4] = v6;
    if (!a4)
    {
      result = 0;
      *(_QWORD *)a3 = 0;
      return result;
    }
    v15 = (void *)*((_QWORD *)a1 + 3);
    v16 = *((_QWORD *)a1 + 4);
    v17 = a1[1];
    src.width = a1[2];
    src.rowBytes = v16;
    src.data = v15;
    src.height = v17;
    v18 = (void *)*((_QWORD *)a2 + 13);
    v19 = *((_QWORD *)a2 + 9);
    dest.width = src.width;
    dest.rowBytes = v19;
    v20 = a1[3];
    dest.data = v18;
    dest.height = v20;
    result = vImageScale_ARGB8888(&src, &dest, 0, 8u);
    if (!result)
    {
      *(_DWORD *)(a3 + 4) = 0;
      *(_DWORD *)a3 = a1[3];
      return result;
    }
    goto LABEL_8;
  }
  aj_log_error(0, "Got too many rows from the recoder");
  return 1;
}

uint64_t aj_idct_s4(unsigned int *a1, _QWORD *a2, uint64_t a3)
{
  int16x8_t v3;
  unsigned int v4;
  _WORD *v5;
  int64x2_t v6;
  int32x2_t v7;
  int16x8_t v8;
  unint64_t v9;
  int16x8_t v10;

  v3.i64[0] = 0x400040004000400;
  v3.i64[1] = 0x400040004000400;
  v4 = a1[4];
  v5 = (_WORD *)(a2[1] + a3);
  v6 = (int64x2_t)vaddq_s16((int16x8_t)*a1, (int16x8_t)v4);
  v7 = (int32x2_t)vsubq_s16(vtrn1q_s16((int16x8_t)*a1, (int16x8_t)v4), vtrn2q_s16((int16x8_t)*a1, (int16x8_t)v4)).u64[0];
  v8 = vsubq_s16((int16x8_t)*a1, (int16x8_t)v4);
  LODWORD(v9) = 0;
  WORD2(v9) = 0;
  HIWORD(v9) = v7.i16[1];
  v8.i16[2] = v7.i16[0];
  *(int32x2_t *)v6.i8 = vzip1_s32(*(int32x2_t *)v6.i8, v7);
  v10 = (int16x8_t)vzip1q_s64(v6, (int64x2_t)vsubq_s16(v8, (int16x8_t)v9));
  v10.i32[0] = vqrshrun_n_s16(vaddq_s16(vpaddq_s16(v10, v10), v3), 3uLL).u32[0];
  *(_WORD *)(*a2 + a3) = v10.i16[0];
  *v5 = v10.i16[1];
  return 2;
}

uint64_t *restore_mcustate(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;

  v2 = *result;
  v3 = *(_QWORD *)(*result + 104);
  v4 = v3 - *(_DWORD *)(*(_QWORD *)a2 + 104);
  v5 = *(_DWORD *)(*(_QWORD *)a2 + 48);
  *(_QWORD *)(v2 + 104) = v3 - v4;
  v6 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v2 + 8) -= v4;
  v7 = *(_DWORD *)(v2 + 48);
  if (v6)
    *(_QWORD *)(v2 + 16) = v6 - v4;
  *(_DWORD *)(v2 + 48) = v5;
  *(_DWORD *)(v2 + 32) += v5 - v7;
  return result;
}

uint64_t aj_mcu_decode_index(int **a1, uint64_t a2, uint64_t *a3, int a4, int a5)
{
  unsigned int *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 *v14;
  __int128 *v15;
  unint64_t v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 *v24;
  uint64_t v25;
  uint64_t v27;
  int v28;
  uint64_t v29;
  signed int v30;
  _WORD *v31;
  int *v32;
  int v33;
  unsigned __int16 *v34;
  uint64_t i;
  unint64_t v36;
  unint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  int32x2_t v53;
  uint64_t v54;
  int v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  v10 = (unsigned int *)a1[1];
  v11 = **a1;
  v66 = 0;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v59 = 0u;
  v58 = 0;
  v56 = 0u;
  v57 = 0u;
  if (v10[91])
  {
    v12 = *((_OWORD *)a3 + 1);
    v13 = a3[4];
    *((_QWORD *)&v56 + 1) = a3[1];
    v57 = v12;
    v14 = &v59;
    v58 = v13;
    *(_QWORD *)&v56 = &v59;
    v15 = (__int128 *)*a3;
    v16 = *(_QWORD *)(*a3 + 16);
    if (v16 >= *(_QWORD *)(*a3 + 8) || v16 == 0)
      v16 = *(_QWORD *)(*a3 + 8);
    *((_QWORD *)v15 + 13) = v16;
    v19 = v15[2];
    v18 = v15[3];
    v20 = v15[1];
    v59 = *v15;
    v60 = v20;
    v61 = v19;
    v62 = v18;
    v21 = v15[4];
    v22 = *((_QWORD *)v15 + 14);
    v23 = v15[6];
    v64 = v15[5];
    v65 = v23;
    v66 = v22;
    v63 = v21;
    v24 = &v56;
  }
  else
  {
    v14 = (__int128 *)*a3;
    v24 = (__int128 *)a3;
  }
  v25 = aj_find_and_handle_markers(a1, (uint64_t *)v24, 0);
  if ((_DWORD)v25)
    goto LABEL_11;
  if (*(_DWORD *)a2 && *(_DWORD *)(a2 + 48) == a5 && *(_DWORD *)(a2 + 44) == a4)
  {
    v27 = *(int *)(a2 + 52);
    v28 = *(_DWORD *)(a2 + 56);
    v29 = *(_QWORD *)(*((_QWORD *)v10 + 13) + 8 * v27);
    *(_DWORD *)(a2 + 56) = v28 + 1;
    v30 = v10[29] + a5;
    *(_DWORD *)(a2 + 48) = v30;
    if (v30 >= (int)v10[20])
    {
      *(_DWORD *)(a2 + 48) = 0;
      *(_DWORD *)(a2 + 52) = v27 + 1;
      *(_DWORD *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 44) = v10[28] + a4;
    }
    if (v29)
    {
      v54 = v29;
      v55 = v28;
      v25 = aj_istream_state_save((uint64_t)v14, v29 + 20 * v28);
      if ((_DWORD)v25)
        goto LABEL_11;
      if ((int)v11 >= 1)
      {
        v31 = (_WORD *)(v54 + 20 * v55 + 8);
        v32 = (int *)v24 + 2;
        do
        {
          v33 = *v32++;
          *v31++ = v33;
          --v11;
        }
        while (v11);
      }
    }
  }
  v34 = *(unsigned __int16 **)(a2 + 16);
  if (v34 && *v34 == a4 && v34[1] == a5)
  {
    v25 = aj_istream_state_save((uint64_t)v14, (uint64_t)(v34 + 2));
    if ((_DWORD)v25)
      goto LABEL_11;
    for (i = 0; i != 4; ++i)
    {
      if (i >= *((int *)v14 + 8))
        break;
      *((_BYTE *)v34 + i + 12) = *(_BYTE *)(*((_QWORD *)v14 + 1) + i);
    }
    *((_BYTE *)v34 + 16) = i;
    v36 = *(_QWORD *)(a2 + 16);
    if (v36 >= (unint64_t)(a1[1] + 83))
    {
      v37 = 0;
    }
    else
    {
      v38 = *(unsigned __int16 *)(v36 + 24);
      v37 = v36 + 24;
      if (*(_DWORD *)(a2 + 12) <= v38)
        v37 = 0;
    }
    *(_QWORD *)(a2 + 16) = v37;
  }
  if ((int)v10[22] >= 1)
  {
    v39 = 0;
    do
    {
      v40 = aj_block_decode_skip((uint64_t)(a1 + 24), (uint64_t)v14, (_DWORD *)v24 + 2);
      if ((_DWORD)v40)
        goto LABEL_49;
    }
    while (++v39 < (int)v10[22]);
  }
  if (**a1 > 1)
  {
    v41 = (uint64_t)(a1 + 220);
    v42 = (_DWORD *)v24 + 3;
    v43 = 1;
    while (1)
    {
      v40 = aj_block_decode_skip(v41, (uint64_t)v14, v42);
      if ((_DWORD)v40)
        break;
      ++v43;
      v41 += 1568;
      ++v42;
      if (v43 >= **a1)
        goto LABEL_45;
    }
LABEL_49:
    v25 = v40;
LABEL_11:
    if (v10[91])
      restore_mcustate(a3, (uint64_t)&v56);
    return v25;
  }
LABEL_45:
  if (v10[91])
  {
    v44 = *a3;
    v45 = v57;
    *(_OWORD *)a3 = v56;
    *((_OWORD *)a3 + 1) = v45;
    a3[4] = v58;
    *a3 = v44;
    v46 = v56;
    v48 = *(_OWORD *)v56;
    v47 = *(_OWORD *)(v56 + 16);
    v49 = *(_OWORD *)(v56 + 48);
    *(_OWORD *)(v44 + 32) = *(_OWORD *)(v56 + 32);
    *(_OWORD *)(v44 + 48) = v49;
    *(_OWORD *)v44 = v48;
    v51 = *(_OWORD *)(v46 + 80);
    v50 = *(_OWORD *)(v46 + 96);
    v52 = *(_OWORD *)(v46 + 64);
    *(_QWORD *)(v44 + 112) = *(_QWORD *)(v46 + 112);
    *(_OWORD *)(v44 + 80) = v51;
    *(_OWORD *)(v44 + 96) = v50;
    *(_OWORD *)(v44 + 64) = v52;
    *(_OWORD *)(v44 + 16) = v47;
    *(_QWORD *)(*a3 + 104) = 0;
  }
  v53 = vadd_s32(*(int32x2_t *)((char *)a3 + 28), (int32x2_t)0x100000001);
  *(uint64_t *)((char *)a3 + 28) = (uint64_t)v53;
  v25 = 0;
  if (v53.i32[0] >= (int)v10[20])
    a3[3] = (*((_DWORD *)a3 + 6) + 1);
  return v25;
}

uint64_t aj_pack_all(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return loop_through_image(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 80), *(_DWORD *)(*(_QWORD *)(a1 + 8) + 84), 0, a2, a3, a1, 0);
}

uint64_t loop_through_image(int a1, int a2, int a3, uint64_t *a4, uint64_t a5, uint64_t a6, int32x2_t *a7)
{
  int i;
  uint64_t j;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t result;

  if (a2 < 1)
    return 0;
  for (i = 0; i != a2; ++i)
  {
    for (j = 0; j != 3; ++j)
    {
      v16 = &a4[j];
      v17 = a4[j];
      *v16 = a4[j + 3];
      v16[3] = v17;
    }
    if (a1 >= 1)
    {
      v18 = a1;
      do
      {
        if (a3)
        {
          result = aj_mcu_unpack(a4, a5, a7);
          if ((_DWORD)result)
            return result;
        }
        else
        {
          result = aj_mcu_pack(a4, a6, a5);
          if ((_DWORD)result)
            return result;
        }
        --v18;
      }
      while (v18);
    }
  }
  return 0;
}

uint64_t aj_unpack_all(uint64_t *a1, uint64_t a2, int32x2_t *a3)
{
  return loop_through_image(*(_DWORD *)(a1[17718] + 80), *(_DWORD *)(a1[17718] + 84), 1, a1, a2, 0, a3);
}

unint64_t aj_RGBA8888_YUV420(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4, size_t a5)
{
  int64x2_t v5;
  int64x2_t v6;
  int64x2_t v7;
  int64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  unint64_t result;
  const char *v12;
  const char *v13;
  int8x8_t *v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  unsigned int i;
  const char *v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  uint8x16_t v29;
  uint8x16_t v30;
  int8x8_t *v31;
  const char *v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint8x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  int16x8_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  unsigned int v59;
  __int8 v60;
  char v61;
  char v62;
  char v63;
  int8x8x4_t v66;
  int8x8x4_t v67;
  int8x8x4_t v68;
  int8x8x4_t v69;
  int8x8x4_t v70;

  if ((_DWORD)a1 == 1)
  {
    aj_RGBA8888_YUV422(a1, a2, a3, a4);
    return (unint64_t)memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    v12 = a2[1];
    v13 = *a2;
    v14 = *(int8x8_t **)a3;
    v15 = *(_BYTE **)(a3 + 8);
    v16 = *(_BYTE **)(a3 + 16);
    v17 = *(_BYTE **)(a3 + 32);
    v18.i64[0] = 0x80008000800080;
    v18.i64[1] = 0x80008000800080;
    v19 = vshlq_n_s16(v18, 7uLL);
    v20.i64[0] = 0x15980E984B232646;
    v20.i64[1] = 0xA6835982A68;
    for (i = a4 >> 4; i; --i)
    {
      v66 = vld4_s8(v13);
      v22 = v13 + 32;
      v68 = vld4_s8(v22);
      v13 = v22 + 32;
      v23 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[0], 7uLL);
      v24 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[1], 7uLL);
      v25 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[2], 7uLL);
      v66.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v66.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v24, v20, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
      v66.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v20, 5)), vqrdmulhq_laneq_s16(v25, v20, 6)), v19), 7uLL);
      v26 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[0], 7uLL);
      v27 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[1], 7uLL);
      v28 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[2], 7uLL);
      v29.i64[0] = (uint64_t)v66.val[1];
      v29.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v27, v20, 4)), vrshrq_n_s16(v28, 1uLL)), 7uLL);
      v30.i64[0] = (uint64_t)v66.val[2];
      v30.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v26, 1uLL), vqrdmulhq_laneq_s16(v27, v20, 5)), vqrdmulhq_laneq_s16(v28, v20, 6)), v19), 7uLL);
      *v14 = v66.val[0];
      v31 = v14 + 1;
      *v31 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v27, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v28, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v14 = v31 + 1;
      v67 = vld4_s8(v12);
      v32 = v12 + 32;
      v69 = vld4_s8(v32);
      v12 = v32 + 32;
      v33 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[0], 7uLL);
      v34 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[1], 7uLL);
      v35 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[2], 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v34, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v35, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v67.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v34, v20, 4)), vrshrq_n_s16(v35, 1uLL)), 7uLL);
      v67.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v33, 1uLL), vqrdmulhq_laneq_s16(v34, v20, 5)), vqrdmulhq_laneq_s16(v35, v20, 6)), v19), 7uLL);
      v36 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[0], 7uLL);
      v37 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[1], 7uLL);
      v38 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v37, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v38, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v37, v20, 4)), vrshrq_n_s16(v38, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v36, 1uLL), vqrdmulhq_laneq_s16(v37, v20, 5)), vqrdmulhq_laneq_s16(v38, v20, 6)), v19), 7uLL);
      *(_QWORD *)v15 = v5.i64[0];
      v39 = v15 + 8;
      *v39 = v8.i64[0];
      v15 = v39 + 1;
      v40 = v9.i64[0];
      v41 = v10.i64[0];
      v6 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[1].i8), (int16x8_t)vpaddlq_u8(v29));
      v7 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[2].i8), (int16x8_t)vpaddlq_u8(v30));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(_QWORD *)v16 = v6.i64[0];
      v16 += 8;
      *(_QWORD *)v17 = v7.i64[0];
      v17 += 8;
    }
    if ((a4 & 8) != 0)
    {
      *(int8x8x4_t *)((char *)&v6 - 8) = vld4_s8(v13);
      v13 += 32;
      v70 = vld4_s8(v12);
      v12 += 32;
      v43 = (int16x8_t)vshll_n_u8(v42, 7uLL);
      v44 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      v45 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v44, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v45, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v44, v20, 4)), vrshrq_n_s16(v45, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v43, 1uLL), vqrdmulhq_laneq_s16(v44, v20, 5)), vqrdmulhq_laneq_s16(v45, v20, 6)), v19), 7uLL);
      v46 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[0], 7uLL);
      v47 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[1], 7uLL);
      v48 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v47, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v48, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *v14++ = *(int8x8_t *)v5.i8;
      *(_QWORD *)v15 = v8.i64[0];
      v15 += 8;
      *(uint16x4_t *)v9.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v47, v20, 4)), vrshrq_n_s16(v48, 1uLL)), 7uLL));
      *(uint16x4_t *)v10.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v46, 1uLL), vqrdmulhq_laneq_s16(v47, v20, 5)), vqrdmulhq_laneq_s16(v48, v20, 6)), v19), 7uLL));
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), *(int16x4_t *)v9.i8);
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), *(int16x4_t *)v10.i8);
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(_DWORD *)v16 = v6.i32[0];
      v16 += 4;
      *(_DWORD *)v17 = v7.i32[0];
      v17 += 4;
    }
    v49 = a4 & 7;
    if ((a4 & 7) != 0)
    {
      do
      {
        v5 = vshlq_n_s64(v5, 8uLL);
        v6 = vshlq_n_s64(v6, 8uLL);
        v7 = vshlq_n_s64(v7, 8uLL);
        v8 = vshlq_n_s64(v8, 8uLL);
        v9 = vshlq_n_s64(v9, 8uLL);
        v10 = vshlq_n_s64(v10, 8uLL);
        v5.i8[0] = *v13;
        v6.i8[0] = v13[1];
        v7.i8[0] = v13[2];
        v13 += 4;
        v8.i8[0] = *v12;
        v9.i8[0] = v12[1];
        v10.i8[0] = v12[2];
        v12 += 4;
        --v49;
      }
      while (v49);
      v50 = a4 & 7;
      v51 = 8 - v50;
      v52 = (v50 + 1) >> 1;
      v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v54, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v55, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v54, v20, 4)), vrshrq_n_s16(v55, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v53, 1uLL), vqrdmulhq_laneq_s16(v54, v20, 5)), vqrdmulhq_laneq_s16(v55, v20, 6)), v19), 7uLL);
      v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v8.i8, 7uLL);
      v57 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
      v58 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v57, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v58, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v57, v20, 4)), vrshrq_n_s16(v58, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v56, 1uLL), vqrdmulhq_laneq_s16(v57, v20, 5)), vqrdmulhq_laneq_s16(v58, v20, 6)), v19), 7uLL);
      do
      {
        v5 = vsliq_n_s64(v5, v5, 8uLL);
        v6 = vsliq_n_s64(v6, v6, 8uLL);
        v7 = vsliq_n_s64(v7, v7, 8uLL);
        v8 = vsliq_n_s64(v8, v8, 8uLL);
        v9 = vsliq_n_s64(v9, v9, 8uLL);
        v10 = vsliq_n_s64(v10, v10, 8uLL);
        --v51;
      }
      while (v51);
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v9.i8));
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v10.i8));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      do
      {
        v14->i8[0] = v5.i8[7];
        v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v8.i8[7];
        v5 = vshlq_n_s64(v5, 8uLL);
        v8 = vshlq_n_s64(v8, 8uLL);
        --v50;
      }
      while (v50);
      do
      {
        *v16++ = v6.i8[3];
        *v17++ = v7.i8[3];
        v6 = vshlq_n_s64(v6, 8uLL);
        v7 = vshlq_n_s64(v7, 8uLL);
        --v52;
      }
      while (v52);
    }
    result = a5 - a4;
    if ((_DWORD)a5 != a4)
    {
      v59 = result >> 1;
      v60 = v14[-1].i8[7];
      v61 = *(v15 - 1);
      v62 = *(v16 - 1);
      v63 = *(v17 - 1);
      do
      {
        v14->i8[0] = v60;
        v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v61;
        result = (result - 1);
      }
      while ((_DWORD)result);
      for (; v59; --v59)
      {
        *v16++ = v62;
        *v17++ = v63;
      }
    }
  }
  return result;
}

uint64_t aj_handle_partial_progressive_decode(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  unsigned int *v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  __int16 *j;
  uint64_t v10;
  uint64_t v11;
  __int16 *v12;
  uint64_t v13;
  __int16 *v14;
  int v15;
  _OWORD v17[32];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, sizeof(v17));
  v2 = *(_QWORD *)(a1 + 8);
  if (*(int *)(v2 + 404) >= 1)
  {
    v3 = 0;
    for (i = 0; i < *(int *)(v2 + 404); ++i)
    {
      v5 = (unsigned int *)(*(_QWORD *)(v2 + 408) + v3);
      if (v5[70])
      {
        if (aj_fill_coeffblock_from_scan_info(v5, (uint64_t)v17, *(_DWORD *)(a1 + 6464)))
          return 0xFFFFFFFFLL;
        v2 = *(_QWORD *)(a1 + 8);
      }
      v3 += 288;
    }
  }
  v6 = *(unsigned int *)(a1 + 6464);
  if ((int)v6 < 1)
  {
    v8 = 0;
  }
  else
  {
    v7 = 0;
    v8 = 1;
    for (j = (__int16 *)v17; ; j += 64)
    {
      v10 = *(unsigned int *)(a1 + 1568 * v7 + 728);
      if ((int)v10 >= 1)
        break;
LABEL_15:
      v8 = ++v7 < v6;
      if (v7 == v6)
        return (v8 << 31 >> 31);
    }
    v11 = 0;
    v12 = j;
LABEL_11:
    v13 = *(unsigned int *)(a1 + 1568 * v7 + 728);
    v14 = v12;
    while (1)
    {
      v15 = *v14++;
      if (v15 != -1)
        break;
      if (!--v13)
      {
        ++v11;
        v12 += 8;
        if (v11 != v10)
          goto LABEL_11;
        goto LABEL_15;
      }
    }
  }
  return (v8 << 31 >> 31);
}

uint64_t get_row_lpf(void **a1, uint64_t a2, _DWORD *a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t result;
  _DWORD *v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  unsigned __int8 *v18;
  unsigned int v19;
  _DWORD *v20;
  int v21;
  int v22;
  uint64_t i;
  _DWORD *v24;
  unsigned __int8 *v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  _BYTE **v32;
  uint64_t v33;
  _BYTE *v34;
  uint64_t v35;

  v6 = (1 << *((_DWORD *)a1 + 1656)) / *((_DWORD *)*a1 + 8);
  v7 = *((_DWORD *)a1 + 1712) - *((_DWORD *)a1 + 1711);
  v8 = *((_DWORD *)*a1 + 4);
  v9 = *(_DWORD *)(a2 + 68);
  if (!v9)
  {
    bzero(a1[829], 4 * *((int *)a1 + 1660));
    v9 = *(_DWORD *)(a2 + 68);
  }
  v10 = v7 * v8;
  if (v9 < v6)
  {
    do
    {
      if (*(_DWORD *)(a2 + 1496))
      {
        v11 = *(_DWORD *)(a2 + 1520);
        if (!v11)
        {
          v12 = (*(uint64_t (**)(_QWORD))(a2 + 1504))(*(_QWORD *)(a2 + 1512));
          v11 = *(_DWORD *)(a2 + 1496);
          if (v12)
          {
            *(_DWORD *)(a2 + 1520) = v11 - 1;
            return 10;
          }
        }
        *(_DWORD *)(a2 + 1520) = v11 - 1;
      }
      result = fill_coeff_buffer((uint64_t)a1, a2, a3);
      if ((_DWORD)result)
        return result;
      v14 = *a1;
      v15 = *((_DWORD *)*a1 + 8);
      if (v15 >= 1)
      {
        v16 = 0;
        v17 = a1[831];
        do
        {
          if (v10 >= 1)
          {
            v18 = *(unsigned __int8 **)(a2 + 568 + 8 * v16);
            v19 = v10 + 1;
            v20 = v17;
            do
            {
              v21 = *v18++;
              *v20++ += v21;
              --v19;
            }
            while (v19 > 1);
            v15 = v14[8];
          }
          ++v16;
        }
        while (v16 < v15);
      }
      v22 = *((_DWORD *)a1 + 1616);
      if (v22 > 1)
      {
        for (i = 1; i < v22; ++i)
        {
          if (v7 >= 1)
          {
            v24 = a1[i + 831];
            v25 = *(unsigned __int8 **)(a2 + (i << 7) + 568);
            v26 = v7 + 1;
            do
            {
              v27 = *v25++;
              *v24++ += v27;
              --v26;
            }
            while (v26 > 1);
            v22 = *((_DWORD *)a1 + 1616);
          }
        }
      }
      aj_return_rowptrs((uint64_t)a1, a2, (unint64_t *)(a2 + 568));
      v28 = *(_DWORD *)(a2 + 68) + 1;
      *(_DWORD *)(a2 + 68) = v28;
    }
    while (v28 < v6);
  }
  *(_DWORD *)(a2 + 68) = 0;
  aj_get_rowptrs((uint64_t)a1, a2, (_QWORD *)(a2 + 568));
  lpf_row(*(_BYTE **)(a2 + 568), (int *)a1[831], v10, *((_DWORD *)a1 + 1656), *((_DWORD *)a1 + 1656));
  result = 0;
  if (*((int *)a1 + 1616) >= 2)
  {
    v29 = *((_DWORD *)a1 + 1656);
    v30 = v29 - (*((_DWORD *)*a1 + 4) == 2);
    v31 = v29 - (*((_DWORD *)*a1 + 8) == 2);
    v32 = (_BYTE **)(a2 + 696);
    v33 = 832;
    do
    {
      v34 = *v32;
      v32 += 16;
      lpf_row(v34, (int *)a1[v33], v7, v30, v31);
      v35 = v33 - 830;
      ++v33;
    }
    while (v35 < *((int *)a1 + 1616));
    return 0;
  }
  return result;
}

uint64_t aj_decode_row(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  *(_QWORD *)(a2 + 60) = 1;
  if (*(_DWORD *)(a2 + 80) == *(_DWORD *)(a2 + 24)
    || (*(_QWORD *)(a2 + 88) = 0,
        *(_QWORD *)(a2 + 96) = 0,
        result = aj_get_rowptrs(a1, a2, (_QWORD *)(a2 + 568)),
        !(_DWORD)result))
  {
    result = aj_decode_all(a1, a2);
    *(_QWORD *)(a2 + 80) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a1 + 6628));
  }
  return result;
}

uint64_t aj_create_ra_table(uint64_t a1, _DWORD *a2)
{
  uint64_t *v2;
  uint64_t v4;
  int v5;
  uint64_t result;

  v2 = (uint64_t *)(a2 + 28);
  if (!*a2)
    return 0;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_DWORD *)(v4 + 136);
  if (v5 == 2)
  {
    result = extend_ra_table(a1, (uint64_t)a2, v2, 0, *(unsigned int *)(v4 + 84));
    if ((_DWORD)result)
      return result;
    goto LABEL_8;
  }
  if (v5 == 1)
  {
    result = build_ra_table(a1, (uint64_t)a2);
    if ((_DWORD)result)
      return result;
LABEL_8:
    result = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 136) = 3;
    return result;
  }
  aj_log_error((uint64_t)"Dec", "Illegal ra-state", v2);
  return 5;
}

uint64_t build_ra_table(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  _DWORD *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t result;

  v4 = (uint64_t *)(a2 + 112);
  v5 = *(_DWORD **)(a1 + 8);
  v6 = ((v5[21] - 1) / v5[28] * v5[28]);
  v7 = (v5[20] - 1) / v5[29] * v5[29];
  result = move_to_mcu((int **)a1, a2, a2 + 112, v6, v7);
  if (!(_DWORD)result)
    return aj_mcu_decode_index((int **)a1, a2, v4, v6, v7);
  return result;
}

uint64_t extend_ra_table(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  int v10;
  _DWORD *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;

  if (*(_DWORD *)(a2 + 1496))
  {
    v10 = *(_DWORD *)(a2 + 1520);
    if (!v10)
    {
      v21 = (*(uint64_t (**)(_QWORD))(a2 + 1504))(*(_QWORD *)(a2 + 1512));
      v10 = *(_DWORD *)(a2 + 1496);
      if (v21)
      {
        *(_DWORD *)(a2 + 1520) = v10 - 1;
        return 10;
      }
    }
    *(_DWORD *)(a2 + 1520) = v10 - 1;
  }
  if ((int)a4 >= (int)a5)
    return move_to_mcu((int **)a1, a2, a2 + 112, a5, 0);
  v11 = *(_DWORD **)(a1 + 8);
  v13 = v11[28];
  v12 = v11[29];
  v14 = v11[20];
  while (v14 < 1)
  {
LABEL_17:
    a4 = (a4 + v13);
    if ((int)a4 >= (int)a5)
      return move_to_mcu((int **)a1, a2, a2 + 112, a5, 0);
  }
  v15 = 0;
  while (1)
  {
    result = move_to_mcu((int **)a1, a2, (uint64_t)a3, a4, v15);
    if ((_DWORD)result)
      return result;
    if (*(_DWORD *)a2 && (_DWORD)a4 == *(_DWORD *)(a2 + 44) && (_DWORD)v15 == *(_DWORD *)(a2 + 48))
    {
      v17 = *(_QWORD *)(a1 + 8);
      v18 = *(int *)(a2 + 52);
      v19 = *(_DWORD *)(a2 + 56);
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v17 + 104) + 8 * v18) + 20 * v19 + 17))
      {
        *(_DWORD *)(a2 + 56) = v19 + 1;
        v20 = v15 + *(_DWORD *)(v17 + 116);
        *(_DWORD *)(a2 + 48) = v20;
        if (v20 >= *(_DWORD *)(v17 + 80))
        {
          *(_QWORD *)(a2 + 52) = (v18 + 1);
          *(_QWORD *)(a2 + 44) = (*(_DWORD *)(v17 + 112) + a4);
        }
      }
      else
      {
        result = aj_mcu_decode_index((int **)a1, a2, a3, a4, v15);
        if ((_DWORD)result)
          return result;
      }
    }
    v15 = (v15 + v12);
    if ((int)v15 >= v14)
      goto LABEL_17;
  }
}

uint64_t aj_get_numthreads_ratbl(_QWORD *a1, int a2, int a3)
{
  uint64_t v3;
  int v5;
  int v6;
  int v7;
  int v8;

  v3 = a1[1];
  if ((*(_DWORD *)(v3 + 136) & 0xFFFFFFFE) != 2)
    return 1;
  if (!*(_QWORD *)(v3 + 96))
    return 1;
  if (!a2)
    return 1;
  if (!*(_QWORD *)(v3 + 104))
    return 1;
  if (*(_BYTE *)(*a1 + 84))
    return 1;
  v5 = *(_DWORD *)(v3 + 120);
  if (!v5 || !*(_DWORD *)(v3 + 124))
    return 1;
  v6 = (v5 + *(_DWORD *)(v3 + 84) - 1) / v5;
  if (v6 <= 1)
    v7 = 1;
  else
    v7 = v6;
  if (v6 >= a3)
    v8 = a3;
  else
    v8 = v7;
  if (v8 <= 1)
    return 1;
  else
    return v8;
}

uint64_t job(uint64_t a1)
{
  *(_DWORD *)a1 = aj_decode_all(*(_QWORD *)(a1 + 8), a1 + 16);
  return 0;
}

uint64_t aj_create_ra_table_mt(uint64_t a1, _DWORD *a2)
{
  uint64_t *v2;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  int v10;
  int numthreads_ratbl;
  uint64_t v12;
  signed int v13;
  int v14;
  int v15;
  signed int v16;
  int v17;
  int v18;
  int v19;
  int *v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  pthread_t *v27;
  uint64_t v28;

  v2 = (uint64_t *)(a2 + 28);
  if (!*a2)
    return 0;
  v5 = *(unsigned int **)(a1 + 8);
  v6 = v5[34];
  if (v6 == 2)
  {
    v9 = *(unsigned int **)(a1 + 6952);
    v10 = *(_DWORD *)(a1 + 6948);
    numthreads_ratbl = aj_get_numthreads_ratbl((_QWORD *)a1, *(_QWORD *)(*v2 + 80) == 0, v10);
    v12 = v5[21];
    if (numthreads_ratbl != 1)
    {
      v13 = v5[30];
      v14 = ((int)v12 + v13 - 1) / v13 / v10;
      v15 = v14 * v13;
      v16 = v5[28];
      if (v10 < 2)
      {
        v18 = 0;
      }
      else
      {
        v17 = 0;
        v18 = v10 - 1;
        v19 = v13 * v14;
        v20 = (int *)(v9 + 17);
        v21 = (v10 - 1);
        do
        {
          *(v20 - 7) = v17;
          v22 = v16 + v17;
          v17 += v19;
          *(v20 - 6) = v17;
          v23 = (v22 - 1) / v16;
          *v20 = v23;
          *(v20 - 2) = v23 * v16;
          v20 += 418;
          --v21;
        }
        while (v21);
      }
      v24 = (v18 * v15);
      a2[6] = v24;
      a2[7] = v12;
      v25 = ((int)v24 + v16 - 1) / v16;
      a2[13] = v25;
      a2[11] = v25 * v16;
      if (v10 >= 2)
      {
        v26 = 0;
        v27 = (pthread_t *)v9;
        do
        {
          pthread_create(v27 + 193, 0, (void *(__cdecl *)(void *))ra_job, v27);
          ++v26;
          v27 += 209;
        }
        while (v26 < *(int *)(a1 + 6948) - 1);
        v24 = a2[6];
        v12 = a2[7];
      }
      v8 = extend_ra_table(a1, (uint64_t)a2, v2, v24, v12);
      if (*(int *)(a1 + 6948) >= 2)
      {
        v28 = 0;
        do
        {
          pthread_join(*((pthread_t *)v9 + 193), 0);
          if (*v9)
            v8 = *v9;
          else
            v8 = v8;
          ++v28;
          v9 += 418;
        }
        while (v28 < *(int *)(a1 + 6948) - 1);
      }
      if (!(_DWORD)v8)
        goto LABEL_27;
      return v8;
    }
    v7 = extend_ra_table(a1, (uint64_t)a2, v2, 0, v12);
  }
  else
  {
    if (v6 != 1)
    {
      aj_log_error((uint64_t)"Dec", "Illegal ra-state");
      return 5;
    }
    v7 = build_ra_table(a1, (uint64_t)a2);
  }
  v8 = v7;
  if (!(_DWORD)v7)
  {
LABEL_27:
    v8 = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 136) = 3;
  }
  return v8;
}

uint64_t ra_job(uint64_t a1)
{
  *(_DWORD *)a1 = extend_ra_table(*(_QWORD *)(a1 + 8), a1 + 16, (uint64_t *)(a1 + 128), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44));
  return 0;
}

_BYTE *lpf_row(_BYTE *result, int *a2, int a3, int a4, int a5)
{
  int i;
  unsigned int v6;
  int *v7;
  int *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;

  for (i = a5 + a4; a4; --a4)
  {
    if (a3 >= 2)
    {
      v6 = a3 + 2;
      v7 = a2;
      v8 = a2;
      do
      {
        v9 = *v8;
        v10 = v8[1];
        v8 += 2;
        *v7++ = v10 + v9;
        v6 -= 2;
      }
      while (v6 > 3);
    }
    a3 >>= 1;
  }
  if (i)
  {
    if (a3 >= 1)
    {
      v11 = a3 + 1;
      do
      {
        v12 = *a2++;
        *result++ = (v12 + (1 << (i - 1))) >> i;
        --v11;
      }
      while (v11 > 1);
    }
  }
  else if (a3 >= 1)
  {
    v13 = a3 + 1;
    do
    {
      v14 = *a2++;
      *result++ = v14;
      --v13;
    }
    while (v13 > 1);
  }
  return result;
}

uint64_t do_error_recovery(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  int v10;
  char *v11;
  int v12;
  int v13;
  int v14;
  uint64_t next_marker;
  int v16;
  int v17;
  int v18;
  char *v19;
  char v20;
  int v21;
  uint64_t v24;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;

  v8 = (uint64_t *)(a2 + 112);
  v9 = *(_QWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 1088) = 2;
  v10 = *(_DWORD *)(*(_QWORD *)a1 + 3404);
  if (!v10 || *(_BYTE *)(*(_QWORD *)a1 + 84))
  {
    v11 = "No RST markers or image is multiscan, can't do recovery";
LABEL_4:
    aj_log_error((uint64_t)"Dec", v11);
LABEL_5:
    if ((_DWORD)a4)
    {
      if ((_DWORD)a4 == -2)
      {
        *(_DWORD *)(a2 + 1088) = 1;
      }
      else
      {
LABEL_29:
        if (*(_DWORD *)(a2 + 36) == *(_DWORD *)(a2 + 32)
          && *(_DWORD *)(a1 + 6844) == a3
          && *(_DWORD *)(a1 + 6836) == *(_DWORD *)(a2 + 24))
        {
          *(_DWORD *)(a2 + 1084) = 0;
        }
        else if (*(_BYTE *)(a1 + 6944))
        {
          a4 = 0;
          *(_DWORD *)(a2 + 1096) = *(_DWORD *)(a1 + 6844);
          *(_DWORD *)(a2 + 1092) = *(_DWORD *)(a1 + 6840) + 1;
        }
      }
    }
    return a4;
  }
  *(_QWORD *)(v9 + 104) = 0;
  v12 = *(_DWORD *)(a2 + 140) + *(_DWORD *)(*(_QWORD *)(a1 + 8) + 80) * *(_DWORD *)(a2 + 136);
  v13 = v12 / v10 - 1;
  if (v12 && !(v12 % v10) && *(_DWORD *)(a2 + 144) == v10)
    v13 = v12 / v10 - 2;
  v14 = *(_DWORD *)(a2 + 148);
  next_marker = find_next_marker((uint64_t *)(a2 + 112));
  if ((_DWORD)next_marker)
  {
    a4 = next_marker;
    aj_log_error((uint64_t)"Dec", "Could not find next marker");
    goto LABEL_5;
  }
  v33 = v13;
  v34 = a3;
  v35 = ((_BYTE)v14 + 2) & 7;
  v16 = ((_BYTE)v14 + 3) & 7;
  v17 = v14 & 7;
  v18 = (v14 - 1) & 7;
  v11 = "Could not find next marker";
  while (1)
  {
    v19 = *(char **)(v9 + 16);
    if (!v19)
    {
      aj_log_error((uint64_t)"Dec", "No marker found");
      a4 = 7;
      a3 = v34;
      goto LABEL_29;
    }
    v20 = *v19;
    if ((v20 & 0xF8) != 0xD0)
      goto LABEL_26;
    v21 = v20 & 0xF;
    if (v35 == v21 || v16 == v21)
      break;
    if (v17 != v21 && v18 != v21)
    {
      v26 = 1;
      goto LABEL_37;
    }
LABEL_26:
    *(_QWORD *)(v9 + 16) = 0;
    v24 = find_next_marker(v8);
    if ((_DWORD)v24)
    {
      a4 = v24;
      a3 = v34;
      goto LABEL_4;
    }
  }
  v26 = ((_BYTE)v21 - *(_DWORD *)(a2 + 148)) & 7;
LABEL_37:
  a4 = 0;
  v27 = v26 + v33;
  v28 = v10 + v10 * v27;
  v29 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 80);
  v30 = v28 / v29;
  v31 = v28 % v29;
  *(_DWORD *)(a2 + 1092) = v30;
  v32 = *(_DWORD *)(a1 + 6844);
  if (v31 > v32)
    v32 = v31;
  *(_DWORD *)(a2 + 1096) = v32;
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(v9 + 16) = 0;
  *(_DWORD *)(a2 + 144) = 0;
  *(_DWORD *)(a2 + 148) = v27 & 7;
  *(_DWORD *)(a2 + 136) = v30;
  *(_DWORD *)(a2 + 140) = v31;
  return a4;
}

int *fill_mcu_row_with_gray(int *result, uint64_t a2, int a3)
{
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int *v10;
  int v11;
  int v12;
  int *v13;
  uint64_t v14;
  int *v15;

  if (result[1616] >= 1)
  {
    v5 = result;
    v6 = 0;
    v7 = a2 + 568;
    do
    {
      v8 = a2 + 4 * v6;
      v11 = *(_DWORD *)(v8 + 88);
      v10 = (int *)(v8 + 88);
      v9 = v11;
      v12 = (a3 - v5[1711]) * v5[392 * v6 + 227] * v5[392 * v6 + 48] - v11;
      v13 = &v5[v6];
      if (v13[1671] >= 1)
      {
        v14 = 0;
        v15 = v13 + 1671;
        do
          result = (int *)memset((void *)(*(_QWORD *)(v7 + 8 * v14++) + *v10), 128, v12);
        while (v14 < *v15);
        v9 = *v10;
      }
      *v10 = v9 + v12;
      ++v6;
      v7 += 128;
    }
    while (v6 < v5[1616]);
  }
  return result;
}

uint64_t find_next_marker(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t next_val;
  int v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v12;

  v1 = *a1;
  if (!*(_QWORD *)(*a1 + 16))
  {
    next_val = aj_istream_find_next_val(*a1, 255);
    v4 = *(_DWORD *)(v1 + 32);
    if (v4 <= 1 && (_DWORD)next_val == 0)
    {
LABEL_15:
      if (*(_BYTE *)(v1 + 112) && *(_DWORD *)(v1 + 56) == 1)
        return 4294967294;
      v2 = 7;
    }
    else
    {
      v2 = next_val;
      while (!(_DWORD)v2)
      {
        v6 = *(_QWORD *)(v1 + 8);
        v8 = *(unsigned __int8 *)(v6 + 1);
        v7 = v6 + 1;
        if (v8)
        {
          if (**(unsigned __int8 **)(v1 + 8) == 255)
          {
            v12 = aj_istream_fill_buf(v1, -9);
            v2 = v12;
            if ((_DWORD)v12)
              aj_log_error((uint64_t)"Dec", "Error when reading from inputstream: %d", v12);
          }
          else
          {
            aj_log_error((uint64_t)"Dec", "Could not find next marker");
            return 7;
          }
          return v2;
        }
        *(_QWORD *)(v1 + 8) = v7;
        *(_DWORD *)(v1 + 32) = v4 - 1;
        v9 = aj_istream_find_next_val(v1, 255);
        v2 = v9;
        v4 = *(_DWORD *)(v1 + 32);
        if (v4 <= 1 && (_DWORD)v9 == 0)
          goto LABEL_15;
      }
      if ((_DWORD)v2 == -2)
        return v2;
    }
    aj_log_error((uint64_t)"Dec", "Encountered error %d while searching for next marker", v2);
    return v2;
  }
  v2 = 0;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 24) = -9;
  return v2;
}

uint64_t aj_write_app0(uint64_t a1)
{
  uint64_t result;

  result = aj_ostream_write_bytes(a1, 65504, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a1, 16, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, 4867657, 3);
      if (!(_DWORD)result)
      {
        result = aj_ostream_write_bytes(a1, 17920, 2);
        if (!(_DWORD)result)
        {
          result = aj_ostream_write_bytes(a1, 258, 2);
          if (!(_DWORD)result)
          {
            result = aj_ostream_write_bytes(a1, 1, 1);
            if (!(_DWORD)result)
            {
              result = aj_ostream_write_bytes(a1, 72, 2);
              if (!(_DWORD)result)
              {
                result = aj_ostream_write_bytes(a1, 72, 2);
                if (!(_DWORD)result)
                  return aj_ostream_write_bytes(a1, 0, 2);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_sof(uint64_t a1, int *a2, int a3)
{
  int v3;
  int v6;
  uint64_t result;
  uint64_t v8;
  int *v9;
  int v10;
  int v11;

  v3 = a3;
  if (!a3)
    v3 = a2[3];
  v6 = *a2;
  result = aj_ostream_write_bytes(a1, a2[20] + 65280, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a1, 3 * v6 + 8, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, a2[1], 1);
      if (!(_DWORD)result)
      {
        result = aj_ostream_write_bytes(a1, v3, 2);
        if (!(_DWORD)result)
        {
          result = aj_ostream_write_bytes(a1, a2[2], 2);
          if (!(_DWORD)result)
          {
            result = aj_ostream_write_bytes(a1, *a2, 1);
            if (!(_DWORD)result)
            {
              if (*a2 < 1)
              {
                return 0;
              }
              else
              {
                v8 = 0;
                do
                {
                  v9 = &a2[v8];
                  v10 = v9[4];
                  v11 = v9[8];
                  result = aj_ostream_write_bytes(a1, v9[16], 1);
                  if ((_DWORD)result)
                    break;
                  result = aj_ostream_write_bytes(a1, v11 + 16 * v10, 1);
                  if ((_DWORD)result)
                    break;
                  result = aj_ostream_write_bytes(a1, a2[v8 + 12], 1);
                  if ((_DWORD)result)
                    break;
                  ++v8;
                }
                while (v8 < *a2);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_dht(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint8x16_t v8;
  uint16x8_t v9;
  uint16x8_t v10;
  int v11;
  uint8x16_t v12;
  uint8x16_t v13;
  uint16x8_t v14;
  uint16x8_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int8 *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  int v34;

  result = aj_ostream_write_bytes(a1, 65476, 2);
  if (!(_DWORD)result)
  {
    v7 = a3 + 274;
    v8 = *(uint8x16_t *)(a3 + 274);
    v9 = vaddl_high_u8(*(uint8x16_t *)a3, v8);
    v10 = vaddl_u8(*(uint8x8_t *)a3, *(uint8x8_t *)v8.i8);
    v11 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v10.i8, *(uint16x4_t *)v9.i8), (int32x4_t)vaddl_high_u16(v10, v9)));
    if (*a2 == 3)
    {
      v12 = *(uint8x16_t *)(a3 + 548);
      v13 = *(uint8x16_t *)(a3 + 822);
      v14 = vaddl_high_u8(v12, v13);
      v15 = vaddl_u8(*(uint8x8_t *)v12.i8, *(uint8x8_t *)v13.i8);
      v16 = v11
          + vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v15.i8, *(uint16x4_t *)v14.i8), (int32x4_t)vaddl_high_u16(v15, v14)))+ 70;
    }
    else
    {
      v16 = v11 + 36;
    }
    result = aj_ostream_write_bytes(a1, v16, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, 0, 1);
      if (!(_DWORD)result)
      {
        v17 = 0;
        LODWORD(v18) = 0;
        while (1)
        {
          result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(a3 + v17), 1);
          if ((_DWORD)result)
            break;
          v18 = v18 + *(unsigned __int8 *)(a3 + v17++);
          if (v17 == 16)
          {
            if ((_DWORD)v18)
            {
              v19 = (unsigned __int8 *)(a3 + 16);
              while (1)
              {
                v20 = *v19++;
                result = aj_ostream_write_bytes(a1, v20, 1);
                if ((_DWORD)result)
                  break;
                if (!--v18)
                  goto LABEL_15;
              }
            }
            else
            {
LABEL_15:
              *(_BYTE *)(a3 + 273) = 1;
              result = aj_ostream_write_bytes(a1, 16, 1);
              if (!(_DWORD)result)
              {
                v21 = 0;
                LODWORD(v22) = 0;
                while (1)
                {
                  result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(v7 + v21), 1);
                  if ((_DWORD)result)
                    break;
                  v22 = v22 + *(unsigned __int8 *)(v7 + v21++);
                  if (v21 == 16)
                  {
                    if ((_DWORD)v22)
                    {
                      v23 = (unsigned __int8 *)(a3 + 290);
                      while (1)
                      {
                        v24 = *v23++;
                        result = aj_ostream_write_bytes(a1, v24, 1);
                        if ((_DWORD)result)
                          break;
                        if (!--v22)
                          goto LABEL_23;
                      }
                    }
                    else
                    {
LABEL_23:
                      *(_BYTE *)(a3 + 547) = 1;
                      if (*a2 == 3)
                      {
                        result = aj_ostream_write_bytes(a1, 1, 1);
                        if (!(_DWORD)result)
                        {
                          v25 = 0;
                          LODWORD(v26) = 0;
                          v27 = a3 + 548;
                          while (1)
                          {
                            result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(v27 + v25), 1);
                            if ((_DWORD)result)
                              break;
                            v26 = v26 + *(unsigned __int8 *)(v27 + v25++);
                            if (v25 == 16)
                            {
                              if ((_DWORD)v26)
                              {
                                v28 = (unsigned __int8 *)(a3 + 564);
                                while (1)
                                {
                                  v29 = *v28++;
                                  result = aj_ostream_write_bytes(a1, v29, 1);
                                  if ((_DWORD)result)
                                    break;
                                  if (!--v26)
                                    goto LABEL_32;
                                }
                              }
                              else
                              {
LABEL_32:
                                *(_BYTE *)(a3 + 821) = 1;
                                result = aj_ostream_write_bytes(a1, 17, 1);
                                if (!(_DWORD)result)
                                {
                                  v30 = 0;
                                  LODWORD(v31) = 0;
                                  v32 = a3 + 822;
                                  while (1)
                                  {
                                    result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(v32 + v30), 1);
                                    if ((_DWORD)result)
                                      break;
                                    v31 = v31 + *(unsigned __int8 *)(v32 + v30++);
                                    if (v30 == 16)
                                    {
                                      if ((_DWORD)v31)
                                      {
                                        v33 = (unsigned __int8 *)(a3 + 838);
                                        while (1)
                                        {
                                          v34 = *v33++;
                                          result = aj_ostream_write_bytes(a1, v34, 1);
                                          if ((_DWORD)result)
                                            break;
                                          if (!--v31)
                                            goto LABEL_40;
                                        }
                                      }
                                      else
                                      {
LABEL_40:
                                        result = 0;
                                        *(_BYTE *)(a3 + 1095) = 1;
                                      }
                                      return result;
                                    }
                                  }
                                }
                              }
                              return result;
                            }
                          }
                        }
                      }
                      else
                      {
                        return 0;
                      }
                    }
                    return result;
                  }
                }
              }
            }
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_single_dht(uint64_t a1, uint8x16_t *a2, int a3, int a4)
{
  uint64_t result;
  uint16x8_t v9;
  uint16x8_t v10;
  uint64_t v11;
  uint64_t v12;
  uint8x16_t *v13;
  int v14;

  result = aj_ostream_write_bytes(a1, 65476, 2);
  if (!(_DWORD)result)
  {
    v9 = vmovl_high_u8(*a2);
    v10 = vmovl_u8(*(uint8x8_t *)a2->i8);
    result = aj_ostream_write_bytes(a1, vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v10.i8, *(uint16x4_t *)v9.i8), (int32x4_t)vaddl_high_u16(v10, v9)))+ 19, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, a4 + 16 * a3, 1);
      if (!(_DWORD)result)
      {
        v11 = 0;
        LODWORD(v12) = 0;
        while (1)
        {
          result = aj_ostream_write_bytes(a1, a2->u8[v11], 1);
          if ((_DWORD)result)
            break;
          v12 = v12 + a2->u8[v11++];
          if (v11 == 16)
          {
            if ((_DWORD)v12)
            {
              v13 = a2 + 1;
              while (1)
              {
                v14 = v13->u8[0];
                v13 = (uint8x16_t *)((char *)v13 + 1);
                result = aj_ostream_write_bytes(a1, v14, 1);
                if ((_DWORD)result)
                  break;
                if (!--v12)
                  goto LABEL_12;
              }
            }
            else
            {
LABEL_12:
              result = 0;
              a2[17].i8[1] = 1;
            }
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_dqt(uint64_t a1, int *a2)
{
  int v2;
  uint64_t v5;
  int *v6;
  int *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  _QWORD v11[3];

  v11[2] = *MEMORY[0x24BDAC8D0];
  v11[0] = 0;
  v11[1] = 0;
  v2 = *a2;
  if (*a2 < 1)
    return 0;
  v5 = 0;
  while (1)
  {
    v6 = &a2[v5];
    v8 = v6[12];
    v7 = v6 + 12;
    if (!*((_DWORD *)v11 + v8))
      break;
LABEL_11:
    if (++v5 >= v2)
      return 0;
  }
  result = aj_ostream_write_bytes(a1, 65499, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a1, 67, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, *v7, 1);
      if (!(_DWORD)result)
      {
        v10 = 0;
        while (1)
        {
          result = aj_ostream_write_bytes(a1, LOBYTE(a2[64 * (uint64_t)*v7 + 22 + aj_glob_zigzag[v10]]), 1);
          if ((_DWORD)result)
            break;
          if (++v10 == 64)
          {
            *((_DWORD *)v11 + *v7) = 1;
            v2 = *a2;
            goto LABEL_11;
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_sos_baseline(uint64_t a1, int *a2)
{
  int v4;
  uint64_t result;
  uint64_t v6;
  int *v7;
  int v8;
  int v9;

  v4 = *a2;
  result = aj_ostream_write_bytes(a1, 65498, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a1, 2 * v4 + 6, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, *a2, 1);
      if (!(_DWORD)result)
      {
        if (*a2 < 1)
        {
          return aj_ostream_write_bytes(a1, 16128, 3);
        }
        else
        {
          v6 = 0;
          while (1)
          {
            v7 = &a2[v6];
            v8 = v7[839];
            v9 = v7[843];
            result = aj_ostream_write_bytes(a1, v7[16], 1);
            if ((_DWORD)result)
              break;
            result = aj_ostream_write_bytes(a1, v9 + 16 * v8, 1);
            if ((_DWORD)result)
              break;
            if (++v6 >= *a2)
              return aj_ostream_write_bytes(a1, 16128, 3);
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_sos_progressive(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;
  uint64_t result;
  uint64_t v8;
  int *v9;

  v6 = *a3;
  result = aj_ostream_write_bytes(a1, 65498, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a1, 2 * v6 + 6, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, *a3, 1);
      if (!(_DWORD)result)
      {
        if (*a3 < 1)
        {
LABEL_10:
          result = aj_ostream_write_bytes(a1, a3[13], 1);
          if (!(_DWORD)result)
          {
            result = aj_ostream_write_bytes(a1, a3[14], 1);
            if (!(_DWORD)result)
              return aj_ostream_write_bytes(a1, a3[15] + 16 * a3[16], 1);
          }
        }
        else
        {
          v8 = 0;
          while (1)
          {
            v9 = &a3[v8];
            result = aj_ostream_write_bytes(a1, *(_DWORD *)(a2 + 4 * v9[1] + 64), 1);
            if ((_DWORD)result)
              break;
            result = aj_ostream_write_bytes(a1, v9[9] + 16 * v9[5], 1);
            if ((_DWORD)result)
              break;
            if (++v8 >= *a3)
              goto LABEL_10;
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_exif (uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t result;
  int v6;
  int v7;

  v4 = *(_DWORD *)(a2 + 3416);
  result = aj_ostream_write_bytes(a1, 65505, 2);
  if (!(_DWORD)result)
  {
    v6 = v4 ? 34 : 22;
    result = aj_ostream_write_bytes(a1, v6, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, 1165519206, 4);
      if (!(_DWORD)result)
      {
        result = aj_ostream_write_bytes(a1, 0, 2);
        if (!(_DWORD)result)
        {
          result = aj_ostream_write_bytes(a1, 19789, 2);
          if (!(_DWORD)result)
          {
            result = aj_ostream_write_bytes(a1, 42, 2);
            if (!(_DWORD)result)
            {
              result = aj_ostream_write_bytes(a1, 8, 4);
              if (!(_DWORD)result)
              {
                result = aj_ostream_write_bytes(a1, v4 != 0, 2);
                if (!(_DWORD)result)
                {
                  v7 = *(_DWORD *)(a2 + 3416);
                  if (v7)
                    write_ifd_field(a1, v7);
                  return aj_ostream_write_bytes(a1, 0, 4);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_ifd_field(uint64_t a1, int a2)
{
  uint64_t result;

  result = aj_ostream_write_bytes(a1, 274, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a1, 3, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a1, 1, 4);
      if (!(_DWORD)result)
      {
        result = aj_ostream_write_bytes(a1, a2, 2);
        if (!(_DWORD)result)
          return aj_ostream_write_bytes(a1, 0, 2);
      }
    }
  }
  return result;
}

uint64_t aj_write_jpeg_headers(int *a1, uint64_t a2, uint64_t a3, int *a4, int a5, int a6, uint64_t a7, char *__src, int a9)
{
  uint64_t result;
  uint64_t v17;
  int *v18;
  int v19;
  uint8x16_t *v20;
  int v21;

  if (a6
    || (result = aj_ostream_write_bytes(a2, 65496, 2), !(_DWORD)result) && (result = aj_write_app0(a2), !(_DWORD)result))
  {
    if (!(_DWORD)a7 || (result = aj_ostream_write_buf(a2, __src, a7), !(_DWORD)result))
    {
      result = aj_write_sof(a2, a1, a9);
      if (!(_DWORD)result)
      {
        if (*a1 < 1)
        {
LABEL_12:
          result = aj_write_dqt(a2, a1);
          if (!(_DWORD)result)
          {
            if (!a5 || (result = write_dri(a2, (__int16)a5), !(_DWORD)result))
            {
              if (a1[20] == 192)
                return aj_write_sos_baseline(a2, a1);
              else
                return aj_write_sos_progressive(a2, (uint64_t)a1, a4);
            }
          }
        }
        else
        {
          v17 = 0;
          while (1)
          {
            v18 = &a1[v17];
            v19 = v18[839];
            v20 = (uint8x16_t *)(a3 + 548 * v19);
            v21 = v18[843];
            if (!v20[17].i8[1])
            {
              result = aj_write_single_dht(a2, v20, 0, v19);
              if ((_DWORD)result)
                break;
            }
            if (!*(_BYTE *)(a3 + 548 * v21 + 547))
            {
              result = aj_write_single_dht(a2, (uint8x16_t *)(a3 + 548 * v21 + 274), 1, v18[843]);
              if ((_DWORD)result)
                break;
            }
            if (++v17 >= *a1)
              goto LABEL_12;
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_dri(uint64_t a1, int a2)
{
  uint64_t result;

  result = aj_ostream_write_bytes(a1, 65501, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a1, 4, 2);
    if (!(_DWORD)result)
      return aj_ostream_write_bytes(a1, a2, 2);
  }
  return result;
}

uint64_t aj_huffman_decode_ac_s4(uint64_t a1, uint64_t a2, _QWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t result;
  unsigned __int8 *v19;
  int v20;
  int v21;
  int v22;
  BOOL v23;
  int v24;
  unsigned __int8 *v25;
  int v27;
  int v28;
  unsigned int v29;
  signed int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _DWORD *v40;
  uint64_t v41;
  unsigned int *v42;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  LODWORD(v6) = 1;
  v7 = a1 + 48;
  v8 = *(_QWORD *)(a1 + 696);
  v9 = *(_DWORD *)a2;
  v10 = *(_DWORD *)(a2 + 28);
  v11 = *(_QWORD *)(a1 + 40) + 400;
  v12 = *(_DWORD *)(a2 + 24);
  v13 = *(_DWORD *)a2 >> 23;
  v14 = *(unsigned int *)(v11 + 4 * v13);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (v10)
          {
LABEL_38:
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            v41 = v11;
            v42 = (unsigned int *)a2;
            v39 = a3;
            v40 = a4;
            v37 = a6;
            v38 = v7;
            v35 = v13;
            v36 = v8;
            result = aj_huffman_decode_val_slow(v11 - 400, (unsigned int *)a2, v6, 0, (int *)&v33);
            if ((_DWORD)result)
              return result;
            LODWORD(v6) = v33;
            v32 = (int)v33 >> 16;
            v13 = v35;
            v8 = v36;
            v7 = v38;
            a3 = v39;
            a4 = v40;
            v11 = v41;
            a2 = (uint64_t)v42;
            v10 = v42[7];
            v12 = v42[6];
            v9 = *v42;
            goto LABEL_31;
          }
          v15 = (int)v14 >> 18;
          v16 = v6 + v14;
          if ((v14 & 0x20000) != 0)
            break;
          if (v15)
          {
            v17 = *(_DWORD *)(v7 + 4 * v16) * v15;
            a6 = *(unsigned int *)(v8 + 4 * v16);
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            v13 = v9 >> 23;
            v6 = v16 + 1;
            v14 = *(unsigned int *)(v11 + 4 * v13);
            *(_WORD *)((char *)a3 + a6) = v17;
            if (v12 < 0)
              goto LABEL_15;
LABEL_6:
            if ((int)v6 >= 5)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
          else
          {
            if ((_BYTE)v14)
              v6 = v16 + 1;
            else
              v6 = 64;
            a6 = v14 >> 8;
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            if (v12 < 0)
              goto LABEL_15;
            v13 = v9 >> 23;
            v14 = *(unsigned int *)(v11 + 4 * v13);
            if ((int)v6 >= 5)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
        }
        LODWORD(v6) = v16 - v14;
        a6 = v14 & 0x10000;
        if ((v14 & 0x10000) != 0)
          goto LABEL_38;
        v28 = BYTE1(v14);
        v29 = v14 >> 18;
        v12 -= v28;
        v9 <<= v28;
        v6 = v6 + (v29 >> 4);
        v14 = v29 & 0xF;
        if (!(_DWORD)v14)
          goto LABEL_32;
        if (v12 + 9 < (int)v14)
        {
          *(_DWORD *)(a2 + 24) = v12;
          *(_DWORD *)a2 = v9;
          v41 = v11;
          v42 = (unsigned int *)a2;
          v39 = a3;
          v40 = a4;
          v37 = (v12 + 9);
          v38 = v7;
          v35 = v6;
          v36 = v13;
          v33 = v8;
          v34 = v14;
          result = aj_istream_fill_buf(a2, (int)v14 - 9);
          if ((_DWORD)result)
            return result;
          v8 = v33;
          LODWORD(v14) = v34;
          LODWORD(v6) = v35;
          v13 = v36;
          v7 = v38;
          a3 = v39;
          a4 = v40;
          v11 = v41;
          a2 = (uint64_t)v42;
          v10 = v42[7];
          v12 = v42[6];
          v9 = *v42;
        }
        v12 -= v14;
        v30 = v9 >> (32 - v14);
        v9 <<= v14;
        v31 = 1 << (v14 - 1);
        LOWORD(v32) = v30 < v31 ? v30 + 1 - 2 * v31 : (unsigned __int16)v30;
LABEL_31:
        v14 = *(unsigned int *)(v7 + 4 * v6);
        a6 = *(unsigned int *)(v8 + 4 * v6);
        v6 = (v6 + 1);
        *(_WORD *)((char *)a3 + a6) = v14 * v32;
LABEL_32:
        if (v12 < 0)
          break;
        v13 = v9 >> 23;
        v14 = *(unsigned int *)(v11 + 4 * v13);
        if ((int)v6 >= 5)
        {
          *(_DWORD *)a2 = v9;
          *(_DWORD *)(a2 + 24) = v12;
          *a4 = v6;
          return 0;
        }
      }
      if (v10)
        goto LABEL_6;
LABEL_15:
      a6 = *(unsigned int *)(a2 + 32);
      v19 = *(unsigned __int8 **)(a2 + 8);
      if ((int)a6 < 8)
        break;
      v20 = *v19;
      v21 = v19[1];
      v23 = v20 == 255;
      v22 = v21 + (v20 << 8);
      v23 = v23 || v21 == 255;
      v24 = v19[2];
      v25 = v19 + 3;
      a6 = (a6 - 3);
      v14 = (v24 + (v22 << 8));
      if (v23 || v24 == 255)
        break;
      v27 = ~v12;
      *(_DWORD *)(a2 + 32) = a6;
      *(_QWORD *)(a2 + 8) = v25;
      v9 |= (_DWORD)v14 << v27;
      v12 = 23 - v27;
      v13 = v9 >> 23;
      v14 = *(unsigned int *)(v11 + 4 * v13);
      if ((int)v6 >= 5)
      {
        *(_DWORD *)a2 = v9;
        *(_DWORD *)(a2 + 24) = v12;
        *a4 = v6;
        return 0;
      }
    }
    *(_DWORD *)a2 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    v41 = v11;
    v42 = (unsigned int *)a2;
    v39 = a3;
    v40 = a4;
    v37 = a6;
    v38 = v7;
    v35 = v6;
    v36 = v13;
    v33 = v8;
    v34 = v14;
    result = aj_istream_fill_buf(a2, -9);
    if ((_DWORD)result)
      return result;
    v8 = v33;
    LODWORD(v6) = v35;
    a6 = v37;
    v7 = v38;
    a3 = v39;
    a4 = v40;
    v11 = v41;
    a2 = (uint64_t)v42;
    v10 = v42[7];
    v12 = v42[6];
    v9 = *v42;
    v13 = *v42 >> 23;
    v14 = *(unsigned int *)(v41 + 4 * v13);
  }
  while ((int)v35 < 5);
  *v42 = v9;
  *(_DWORD *)(a2 + 24) = v12;
  *a4 = v6;
  return 0;
}

uint64_t sub_206255110(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, int a5, uint64_t a6, int a7)
{
  int v7;

  *a2 = a7;
  a2[6] = a5;
  *a4 = v7;
  return 7;
}

uint64_t aj_BGRA8888_YUV444(double a1, int64x2_t a2, int64x2_t a3, int64x2_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unsigned int a8, int a9)
{
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  unsigned int i;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int v20;
  int v21;
  int v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  uint64_t result;
  char v27;
  char v28;
  char v29;
  int8x8x4_t v30;

  v9 = *a6;
  v10 = *(_BYTE **)a7;
  v11 = *(_BYTE **)(a7 + 16);
  v12 = *(_BYTE **)(a7 + 32);
  v13.i64[0] = 0x80008000800080;
  v13.i64[1] = 0x80008000800080;
  v14 = vshlq_n_s16(v13, 7uLL);
  v15.i64[0] = 0x15980E984B232646;
  v15.i64[1] = 0xA6835982A68;
  for (i = a8 >> 3; i; --i)
  {
    v30 = vld4_s8((const char *)v9);
    v9 += 32;
    v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[2], 7uLL);
    v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[1], 7uLL);
    v19 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[0], 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v19, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v18, v15, 4)), vrshrq_n_s16(v19, 1uLL)), 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v17, 1uLL), vqrdmulhq_laneq_s16(v18, v15, 5)), vqrdmulhq_laneq_s16(v19, v15, 6)), v14), 7uLL);
    *(_QWORD *)v10 = a4.i64[0];
    v10 += 8;
    *(_QWORD *)v11 = a3.i64[0];
    v11 += 8;
    *(_QWORD *)v12 = a2.i64[0];
    v12 += 8;
  }
  v20 = a8 & 7;
  if ((a8 & 7) != 0)
  {
    do
    {
      a4 = vshlq_n_s64(a4, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a2 = vshlq_n_s64(a2, 8uLL);
      a2.i8[0] = *(_BYTE *)v9;
      a3.i8[0] = *(_BYTE *)(v9 + 1);
      a4.i8[0] = *(_BYTE *)(v9 + 2);
      v9 += 4;
      --v20;
    }
    while (v20);
    v21 = a8 & 7;
    v22 = 8 - v21;
    v23 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a4.i8, 7uLL);
    v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a3.i8, 7uLL);
    v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a2.i8, 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v24, v15, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v15, 5)), vqrdmulhq_laneq_s16(v25, v15, 6)), v14), 7uLL);
    do
    {
      a4 = vshlq_n_s64(a4, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a2 = vshlq_n_s64(a2, 8uLL);
      --v22;
    }
    while (v22);
    do
    {
      *v10++ = a4.i8[7];
      *v11++ = a3.i8[7];
      *v12++ = a2.i8[7];
      a4 = vshlq_n_s64(a4, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a2 = vshlq_n_s64(a2, 8uLL);
      --v21;
    }
    while (v21);
  }
  result = a9 - a8;
  if (a9 != a8)
  {
    v27 = *(v10 - 1);
    v28 = *(v11 - 1);
    v29 = *(v12 - 1);
    do
    {
      *v10++ = v27;
      *v11++ = v28;
      *v12++ = v29;
      result = (result - 1);
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t aj_huffman_decode_skip_val_slow(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, int *a5)
{
  int v10;
  uint64_t error_code_eod;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v21;
  int v22;
  int v23;

  v10 = *(_DWORD *)(a2 + 24);
  if (v10 > 6)
    goto LABEL_5;
  error_code_eod = aj_istream_fill_buf(a2, -9);
  if ((_DWORD)error_code_eod)
    return error_code_eod;
  v10 = *(_DWORD *)(a2 + 24);
  if (v10 > 6 || *(_QWORD *)(a2 + 16))
  {
LABEL_5:
    v12 = *(_DWORD *)a2;
    v13 = *(_DWORD *)a2 >> 1;
    v14 = ((uint64_t)a4 << 32) - 0x200000000;
    v15 = (unsigned int *)(a1 + 4 * a4 + 272);
    do
    {
      v16 = *v15++;
      v14 += 0x100000000;
      ++a4;
    }
    while (v13 >= v16);
    if (a4 != 1)
      v13 -= *(_DWORD *)(a1 + (v14 >> 30) + 272);
    v17 = (v13 >> ~(_BYTE)a4) + v15[15];
    if (v17 >= *(unsigned __int16 *)(a1 + 4496))
    {
      aj_log_error((uint64_t)"HuffDec", "Bad huffman code in bitstream");
      return 7;
    }
    v18 = *(unsigned __int8 *)(a1 + v17 + 16);
    v19 = v10 - a4;
    *(_DWORD *)(a2 + 24) = v19;
    if (v19 <= -10)
      goto LABEL_11;
    *(_DWORD *)a2 = v12 << a4;
    if (v18)
    {
      v21 = v18 & 0xF;
      if (v19 < v21 - 9)
      {
        error_code_eod = aj_istream_fill_buf(a2, v21 - 9);
        if ((_DWORD)error_code_eod)
          return error_code_eod;
        v19 = *(_DWORD *)(a2 + 24);
      }
      v22 = v19 - v21;
      *(_DWORD *)(a2 + 24) = v22;
      if (v22 <= -10)
      {
LABEL_11:
        error_code_eod = aj_istream_get_error_code_eod(a2);
        if ((_DWORD)error_code_eod != -2)
          aj_log_error((uint64_t)"HuffDec", "Not enough data in bitstream");
        return error_code_eod;
      }
      *(_DWORD *)a2 <<= v21;
      *a3 += (v18 >> 4) + 1;
      if ((*(_DWORD *)(a2 + 24) & 0x80000000) != 0)
      {
        error_code_eod = aj_istream_fill_buf(a2, -9);
        if ((_DWORD)error_code_eod)
          return error_code_eod;
      }
      v23 = 0;
    }
    else
    {
      if (v19 < 0)
      {
        error_code_eod = aj_istream_fill_buf(a2, -9);
        if ((_DWORD)error_code_eod)
          return error_code_eod;
      }
      v23 = 1;
    }
    error_code_eod = 0;
    *a5 = v23;
    return error_code_eod;
  }
  error_code_eod = 7;
  if (*(_BYTE *)(a2 + 112))
  {
    if (*(_DWORD *)(a2 + 56) == 1)
      return 4294967294;
    else
      return 7;
  }
  return error_code_eod;
}

uint64_t aj_block_encode(uint64_t a1, __int16 *a2, int32x2_t *a3, _DWORD *a4)
{
  int v7;
  int v8;
  uint64_t result;

  v7 = *a2;
  v8 = v7 - *a4;
  *a4 = v7;
  result = aj_huffman_encode_val_lkup(*(_QWORD *)(a1 + 672), 0, v8, a3);
  if (!(_DWORD)result)
    return aj_block_encode_ac(a1, (uint64_t)a2, (uint64_t)a3);
  return result;
}

uint64_t aj_prog_encode_DC_first(int32x2_t *a1, __int16 *a2, int *a3, int a4)
{
  int v4;
  int v5;

  v4 = *a2 >> a1[7].i32[1];
  v5 = v4 - *a3;
  *a3 = v4;
  return aj_huffman_encode_val_lkup(*(_QWORD *)&a1[a4 + 34], 0, v5, a1 + 11);
}

uint64_t aj_prog_encode_DC_refine(int32x2_t *a1, __int16 *a2)
{
  unsigned int v2;
  int v3;
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  _BYTE *v7;
  _BYTE *v8;
  int v9;

  v2 = (*a2 >> a1[7].i32[1]) & 1;
  if (a1[13].i32[1] >= 9 && (v3 = a1[11].i32[1], v3 < 32))
  {
    v5 = a1[11].i32[0] | (v2 << ~(_BYTE)v3);
    a1[11].i32[0] = v5;
    a1[11].i32[1] = v3 + 1;
    if (v3 >= 7)
    {
      do
      {
        v6 = HIBYTE(v5);
        v7 = (_BYTE *)a1[12];
        a1[12] = (int32x2_t)(v7 + 1);
        *v7 = v6;
        a1[13] = vadd_s32(a1[13], (int32x2_t)0xFFFFFFFF00000001);
        if (v6 == 255)
        {
          v8 = (_BYTE *)a1[12];
          a1[12] = (int32x2_t)(v8 + 1);
          *v8 = 0;
          a1[13] = vadd_s32(a1[13], (int32x2_t)0xFFFFFFFF00000001);
        }
        v9 = a1[11].i32[1];
        v5 = a1[11].i32[0] << 8;
        a1[11].i32[0] = v5;
        a1[11].i32[1] = v9 - 8;
      }
      while (v9 > 15);
    }
  }
  else
  {
    result = aj_ostream_write((unsigned int *)&a1[11], v2, 1);
    if ((_DWORD)result)
      return result;
  }
  return 0;
}

uint64_t aj_prog_encode_AC_first(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;
  int v6;
  int32x2_t *v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v18;
  unsigned int v19;
  _BYTE *v20;
  _BYTE *v21;
  int v22;
  unsigned int v23;

  v2 = *(int *)(a1 + 52);
  if ((int)v2 > *(_DWORD *)(a1 + 56))
    return 0;
  v6 = 0;
  v7 = (int32x2_t *)(a1 + 88);
  do
  {
    v8 = *(__int16 *)(a2 + 2 * v2);
    if (!*(_WORD *)(a2 + 2 * v2))
    {
LABEL_15:
      ++v6;
      continue;
    }
    if ((v8 & 0x80000000) != 0)
    {
      v9 = -v8 >> *(_DWORD *)(a1 + 60);
      v10 = ~v9;
      if (!v9)
        goto LABEL_15;
    }
    else
    {
      v9 = v8 >> *(_DWORD *)(a1 + 60);
      v10 = v9;
      if (!v9)
        goto LABEL_15;
    }
    if (*(_DWORD *)(a1 + 80))
    {
      result = write_eobn(a1);
      if ((_DWORD)result)
        return result;
    }
    v11 = 16 * v6;
    v12 = v6 + 16;
    while (1)
    {
      v12 -= 16;
      if (v12 < 16)
        break;
      v11 -= 256;
      result = aj_huffman_encode_sym_lkup(*(_QWORD *)(a1 + 272), 240, v7);
      if ((_DWORD)result)
        return result;
    }
    v13 = aj_highest_set_bit(v9);
    result = aj_huffman_encode_sym_lkup(*(_QWORD *)(a1 + 272), v13 + v11, v7);
    if ((_DWORD)result)
      return result;
    v14 = (0xFFFFFFFF >> -(char)v13) & v10;
    if (*(int *)(a1 + 108) < 9 || (v15 = *(_DWORD *)(a1 + 92), v16 = v15 + v13, v15 + v13 >= 33))
    {
      result = aj_ostream_write((unsigned int *)v7, v14, v13);
      if ((_DWORD)result)
        return result;
LABEL_20:
      v6 = 0;
      continue;
    }
    v18 = *(_DWORD *)(a1 + 88) | (v14 << (32 - v13 - v15));
    *(_DWORD *)(a1 + 88) = v18;
    *(_DWORD *)(a1 + 92) = v16;
    if (v16 < 8)
      goto LABEL_20;
    do
    {
      v19 = HIBYTE(v18);
      v20 = *(_BYTE **)(a1 + 96);
      *(_QWORD *)(a1 + 96) = v20 + 1;
      *v20 = v19;
      *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
      if (v19 == 255)
      {
        v21 = *(_BYTE **)(a1 + 96);
        *(_QWORD *)(a1 + 96) = v21 + 1;
        *v21 = 0;
        *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
      }
      v6 = 0;
      v22 = *(_DWORD *)(a1 + 92);
      v18 = *(_DWORD *)(a1 + 88) << 8;
      *(_DWORD *)(a1 + 88) = v18;
      *(_DWORD *)(a1 + 92) = v22 - 8;
    }
    while (v22 > 15);
  }
  while (v2++ < *(int *)(a1 + 56));
  if (v6 < 1)
    return 0;
  v23 = *(_DWORD *)(a1 + 80) + 1;
  *(_DWORD *)(a1 + 80) = v23;
  if (v23 < 0x7FFF)
    return 0;
  result = write_eobn(a1);
  if (!(_DWORD)result)
    return 0;
  return result;
}

uint64_t write_eobn(uint64_t a1)
{
  int v1;
  int v3;
  int v4;
  uint64_t result;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  _BYTE *v11;
  _BYTE *v12;
  int v13;
  int v14;
  unsigned __int8 *v15;
  BOOL v16;
  unsigned int v17;

  v1 = *(_DWORD *)(a1 + 80);
  if (!v1)
    return 0;
  v3 = aj_highest_set_bit(*(_DWORD *)(a1 + 80));
  v4 = v3 - 1;
  *(_DWORD *)(a1 + 80) = 0;
  result = aj_huffman_encode_sym_lkup(*(_QWORD *)(a1 + 272), 16 * (v3 - 1), (int32x2_t *)(a1 + 88));
  if ((_DWORD)result)
    return result;
  if (v3 != 1)
  {
    v6 = (0xFFFFFFFF >> (33 - v3)) & v1;
    if (*(int *)(a1 + 108) >= 9 && (v7 = *(_DWORD *)(a1 + 92), v8 = v7 + v4, v7 + v4 < 33))
    {
      v9 = *(_DWORD *)(a1 + 88) | (v6 << (33 - v3 - v7));
      *(_DWORD *)(a1 + 88) = v9;
      *(_DWORD *)(a1 + 92) = v8;
      if (v8 >= 8)
      {
        do
        {
          v10 = HIBYTE(v9);
          v11 = *(_BYTE **)(a1 + 96);
          *(_QWORD *)(a1 + 96) = v11 + 1;
          *v11 = v10;
          *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
          if (v10 == 255)
          {
            v12 = *(_BYTE **)(a1 + 96);
            *(_QWORD *)(a1 + 96) = v12 + 1;
            *v12 = 0;
            *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
          }
          v13 = *(_DWORD *)(a1 + 92);
          v9 = *(_DWORD *)(a1 + 88) << 8;
          *(_DWORD *)(a1 + 88) = v9;
          *(_DWORD *)(a1 + 92) = v13 - 8;
        }
        while (v13 > 15);
      }
    }
    else
    {
      result = aj_ostream_write((unsigned int *)(a1 + 88), v6, v4);
      if ((_DWORD)result)
        return result;
    }
  }
  v14 = *(_DWORD *)(a1 + 196);
  if (!v14)
    return 0;
  v15 = *(unsigned __int8 **)(a1 + 184);
  while (1)
  {
    v16 = __OFSUB__(v14--, 1);
    if (v14 < 0 != v16)
      break;
    v17 = *v15++;
    result = aj_ostream_write((unsigned int *)(a1 + 88), v17, 1);
    if ((_DWORD)result)
      return result;
  }
  result = 0;
  *(_DWORD *)(a1 + 196) = 0;
  return result;
}

uint64_t aj_prog_encode_AC_refine(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  __int16 *v14;
  unsigned int *v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  BOOL v23;
  unsigned int v24;
  BOOL v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  _BYTE *v30;
  _BYTE *v31;
  int v32;
  unsigned int v33;
  uint64_t v35;
  _DWORD v36[64];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 52);
  v4 = *(_DWORD *)(a1 + 56);
  if (v3 <= v4)
  {
    v10 = 0;
    v11 = v3;
    v12 = *(_DWORD *)(a1 + 60);
    v13 = v4 + 1;
    v14 = (__int16 *)(a2 + 2 * v3);
    v15 = &v36[v3];
    do
    {
      v17 = *v14++;
      v16 = v17;
      if (v17 < 0)
        v16 = -v16;
      v18 = v16 >> v12;
      *v15++ = v18;
      if (v18 == 1)
        v10 = v3;
      ++v3;
    }
    while (v13 != v3);
    v6 = 0;
    v19 = 0;
    v35 = v10;
    v20 = (unsigned __int8 *)(*(_QWORD *)(a1 + 184) + *(int *)(a1 + 196));
    while (1)
    {
      v21 = v36[v11];
      if (v21)
      {
        if ((int)v19 < 16)
        {
          v5 = v19;
          v22 = v6;
        }
        else
        {
          v5 = v19;
          v22 = v6;
          if (v11 <= v35)
          {
            do
            {
              if (*(_DWORD *)(a1 + 80))
              {
                result = write_eobn(a1);
                if ((_DWORD)result)
                  return result;
              }
              result = aj_huffman_encode_sym_lkup(*(_QWORD *)(a1 + 272), 240, (int32x2_t *)(a1 + 88));
              if ((_DWORD)result)
                return result;
              v5 = (v19 - 16);
              while (1)
              {
                v23 = __OFSUB__(v6--, 1);
                if (v6 < 0 != v23)
                  break;
                v24 = *v20++;
                result = aj_ostream_write((unsigned int *)(a1 + 88), v24, 1);
                if ((_DWORD)result)
                  return result;
              }
              v6 = 0;
              v22 = 0;
              v20 = *(unsigned __int8 **)(a1 + 184);
              v25 = (int)v19 <= 31;
              LODWORD(v19) = v19 - 16;
            }
            while (!v25);
          }
        }
        if (v21 < 2)
        {
          if (!*(_DWORD *)(a1 + 80) || (result = write_eobn(a1), !(_DWORD)result))
          {
            result = aj_huffman_encode_sym_lkup(*(_QWORD *)(a1 + 272), (16 * v5) | 1, (int32x2_t *)(a1 + 88));
            if (!(_DWORD)result)
            {
              v26 = (*(unsigned __int16 *)(a2 + 2 * v11) >> 15) ^ 1;
              if (*(int *)(a1 + 108) >= 9)
              {
                v27 = *(_DWORD *)(a1 + 92);
                if (v27 < 32)
                {
                  v28 = *(_DWORD *)(a1 + 88) | (v26 << ~(_BYTE)v27);
                  *(_DWORD *)(a1 + 88) = v28;
                  *(_DWORD *)(a1 + 92) = v27 + 1;
                  if (v27 >= 7)
                  {
                    do
                    {
                      v29 = HIBYTE(v28);
                      v30 = *(_BYTE **)(a1 + 96);
                      *(_QWORD *)(a1 + 96) = v30 + 1;
                      *v30 = v29;
                      *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
                      if (v29 == 255)
                      {
                        v31 = *(_BYTE **)(a1 + 96);
                        *(_QWORD *)(a1 + 96) = v31 + 1;
                        *v31 = 0;
                        *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
                      }
                      v32 = *(_DWORD *)(a1 + 92);
                      v28 = *(_DWORD *)(a1 + 88) << 8;
                      *(_DWORD *)(a1 + 88) = v28;
                      *(_DWORD *)(a1 + 92) = v32 - 8;
                    }
                    while (v32 > 15);
                  }
                  goto LABEL_44;
                }
              }
              while (1)
              {
                result = aj_ostream_write((unsigned int *)(a1 + 88), v26, 1);
                if ((_DWORD)result)
                  break;
LABEL_44:
                v23 = __OFSUB__(v22--, 1);
                if (v22 < 0 != v23)
                {
                  v5 = 0;
                  v6 = 0;
                  v20 = *(unsigned __int8 **)(a1 + 184);
                  goto LABEL_47;
                }
                v33 = *v20++;
                v26 = v33;
              }
            }
          }
          return result;
        }
        v6 = v22 + 1;
        v20[v22] = v21 & 1;
      }
      else
      {
        v5 = (v19 + 1);
      }
LABEL_47:
      ++v11;
      v19 = v5;
      if (v13 == (_DWORD)v11)
        goto LABEL_3;
    }
  }
  LODWORD(v5) = 0;
  v6 = 0;
LABEL_3:
  if (!(v5 | v6))
    return 0;
  v7 = *(_DWORD *)(a1 + 80) + 1;
  *(_DWORD *)(a1 + 80) = v7;
  v8 = *(_DWORD *)(a1 + 196) + v6;
  *(_DWORD *)(a1 + 196) = v8;
  if (v7 <= 0x7FFE && v8 < 961)
    return 0;
  result = write_eobn(a1);
  if (!(_DWORD)result)
    return 0;
  return result;
}

uint64_t aj_prog_encode_close(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80))
    return write_eobn(a1);
  else
    return 0;
}

uint8x16_t **aj_icol_row_420_to_rgb565(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint64x2_t v7;
  uint64x2_t v8;
  uint8x8_t v9;
  uint8x16_t *v10;
  uint8x8_t *v11;
  uint8x8_t *v12;
  unsigned int v13;
  uint8x16_t *j;
  uint8x16_t v15;
  uint8x16_t v16;
  uint8x8_t v17;
  uint8x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int8x8_t v31;
  char *v32;
  int16x8_t v33;
  int16x8_t v34;
  char *v35;
  int16x8_t v36;
  unsigned int v37;
  uint64x2_t v38;
  uint64x2_t v39;
  int16x8_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int8x8_t v52;
  int16x8_t v53;
  int16x8_t v54;
  int8x8_t v55;
  int16x8_t v56;
  int8x8_t v57;
  unsigned int i;
  uint8x16_t v59;
  uint8x8_t v60;
  uint8x8_t v61;
  int16x8_t v62;
  int16x8_t v63;
  int16x8_t v64;
  int16x8_t v65;
  int16x8_t v66;
  int16x8_t v67;
  int8x8_t v68;
  char *v69;
  int16x8_t v70;
  unsigned int v71;
  uint64x2_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int8x8_t v85;
  int16x8_t v86;
  int8x8_t v87;
  int8x8x2_t v88;
  int8x8x2_t v89;
  int8x8x2_t v90;
  int8x8x2_t v91;

  v9 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  if (a6 >= 1)
  {
    v10 = *result;
    v11 = *a2;
    v12 = *a3;
    if (a6 == 1)
    {
      for (i = a7 >> 4; i; --i)
      {
        v59 = *v10++;
        v60 = *v11++;
        v61 = *v12++;
        v62 = (int16x8_t)vsubl_u8(v60, v9);
        v63 = (int16x8_t)vsubl_u8(v61, v9);
        v64 = vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 3);
        v65 = vmulq_n_s16(v63, 179);
        v66 = vqaddq_s16(vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v63, (int16x4_t)0xE3005B002C00B3, 2));
        v67 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v59.i8, 7uLL);
        v68 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v67, vzip1q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v68, 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v68, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v90);
        v69 = a4 + 16;
        v70 = (int16x8_t)vshll_high_n_u8(v59, 7uLL);
        v90.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v70, vzip2q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v90.val[1], 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v90.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v69, v90);
        a4 = v69 + 16;
      }
      v71 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v72 = *(uint64x2_t *)v10;
        v73 = (int16x8_t)vsubl_u8(*v11, v9);
        v74 = (int16x8_t)vsubl_u8(*v12, v9);
        v75 = vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 3);
        v76 = vmulq_n_s16(v74, 179);
        v77 = vqaddq_s16(vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v74, (int16x4_t)0xE3005B002C00B3, 2));
        v78 = vzip2q_s16(v75, v75);
        v79 = vzip2q_s16(v76, v76);
        v80 = vzip2q_s16(v77, v77);
        v81 = vzip1q_s16(v75, v75);
        v82 = vzip1q_s16(v76, v76);
        v83 = vzip1q_s16(v77, v77);
        if (!(v71 >> 3))
          goto LABEL_16;
        v84 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
        v85 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v84, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v91.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v85, 5uLL));
        v91.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v85, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v91);
        a4 += 16;
        v81 = v78;
        v82 = v79;
        v83 = v80;
        v72.i64[0] = v72.i64[1];
        v71 -= 8;
        if (v71)
        {
LABEL_16:
          v86 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
          v87 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v86, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v87, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v87, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            --v71;
          }
          while (v71);
        }
      }
    }
    else
    {
      v13 = a7 >> 4;
      for (j = result[1]; v13; --v13)
      {
        v15 = *v10++;
        v16 = *j++;
        v17 = *v11++;
        v18 = *v12++;
        v19 = (int16x8_t)vsubl_u8(v17, v9);
        v20 = (int16x8_t)vsubl_u8(v18, v9);
        v21 = vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 3);
        v22 = vmulq_n_s16(v20, 179);
        v23 = vqaddq_s16(vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 2));
        v24 = vzip2q_s16(v21, v21);
        v25 = vzip2q_s16(v22, v22);
        v26 = vzip2q_s16(v23, v23);
        v27 = vzip1q_s16(v21, v21);
        v28 = vzip1q_s16(v22, v22);
        v29 = vzip1q_s16(v23, v23);
        v30 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v15.i8, 7uLL);
        v31 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v30, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v31, 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v31, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v88);
        v32 = a4 + 16;
        v33 = (int16x8_t)vshll_high_n_u8(v15, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v33, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v32, v88);
        a4 = v32 + 16;
        v34 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v16.i8, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v34, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v88);
        v35 = a5 + 16;
        v36 = (int16x8_t)vshll_high_n_u8(v16, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v36, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v35, v88);
        a5 = v35 + 16;
      }
      v37 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v38 = *(uint64x2_t *)v10;
        v39 = *(uint64x2_t *)j;
        v40 = (int16x8_t)vsubl_u8(*v11, v9);
        v41 = (int16x8_t)vsubl_u8(*v12, v9);
        v42 = vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 3);
        v43 = vmulq_n_s16(v41, 179);
        v44 = vqaddq_s16(vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 2));
        v45 = vzip2q_s16(v42, v42);
        v46 = vzip2q_s16(v43, v43);
        v47 = vzip2q_s16(v44, v44);
        v48 = vzip1q_s16(v42, v42);
        v49 = vzip1q_s16(v43, v43);
        v50 = vzip1q_s16(v44, v44);
        if (!(v37 >> 3))
          goto LABEL_8;
        v51 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
        v52 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v51, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v52, 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v52, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v89);
        a4 += 16;
        v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
        v89.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v53, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v89.val[1], 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v89.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v89);
        a5 += 16;
        v48 = v45;
        v49 = v46;
        v50 = v47;
        v38.i64[0] = v38.i64[1];
        v39.i64[0] = v39.i64[1];
        v37 -= 8;
        if (v37)
        {
LABEL_8:
          v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
          v55 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v54, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v55, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v55, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
          v57 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v56, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v38.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v57, 5uLL));
          *(int8x8_t *)v39.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v57, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            *a5 = v38.i8[0];
            a5[1] = v39.i8[0];
            a5 += 2;
            v38 = vshrq_n_u64(v38, 8uLL);
            v39 = vshrq_n_u64(v39, 8uLL);
            --v37;
          }
          while (v37);
        }
      }
    }
  }
  return result;
}

uint8x16_t **aj_icol_row_420_to_bgra(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint64x2_t v7;
  uint64x2_t v8;
  uint64x2_t v9;
  uint64x2_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint8x16_t *v13;
  uint8x8_t *v14;
  uint8x8_t *v15;
  unsigned int v16;
  uint8x16_t *j;
  uint8x16_t v18;
  uint8x16_t v19;
  uint8x8_t v20;
  uint8x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  char *v34;
  int16x8_t v35;
  int16x8_t v36;
  char *v37;
  int16x8_t v38;
  unsigned int v39;
  uint64x2_t v40;
  uint64x2_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int16x8_t v56;
  unsigned int i;
  uint8x16_t v58;
  uint8x8_t v59;
  uint8x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  int16x8_t v63;
  int16x8_t v64;
  int16x8_t v65;
  int16x8_t v66;
  char *v67;
  int16x8_t v68;
  unsigned int v69;
  uint64x2_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int8x8x4_t v84;
  int8x8x4_t v85;
  int8x8x4_t v86;
  int8x8x4_t v87;

  v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  v12 = vdupq_n_s8(0xFFu).u64[0];
  if (a6 >= 1)
  {
    v13 = *result;
    v14 = *a2;
    v15 = *a3;
    if (a6 == 1)
    {
      for (i = a7 >> 4; i; --i)
      {
        v58 = *v13++;
        v59 = *v14++;
        v60 = *v15++;
        v61 = (int16x8_t)vsubl_u8(v59, v11);
        v62 = (int16x8_t)vsubl_u8(v60, v11);
        v63 = vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 3);
        v64 = vmulq_n_s16(v62, 179);
        v65 = vqaddq_s16(vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 2));
        v66 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v58.i8, 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v63, v63)), 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v66, vzip1q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v86);
        v67 = a4 + 32;
        v68 = (int16x8_t)vshll_high_n_u8(v58, 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v63, v63)), 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v68, vzip2q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(v67, v86);
        a4 = v67 + 32;
      }
      v69 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v70 = *(uint64x2_t *)v13;
        v71 = (int16x8_t)vsubl_u8(*v14, v11);
        v72 = (int16x8_t)vsubl_u8(*v15, v11);
        v73 = vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 3);
        v74 = vmulq_n_s16(v72, 179);
        v75 = vqaddq_s16(vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v72, (int16x4_t)0xE3005B002C00B3, 2));
        v76 = vzip2q_s16(v73, v73);
        v77 = vzip2q_s16(v74, v74);
        v78 = vzip2q_s16(v75, v75);
        v79 = vzip1q_s16(v73, v73);
        v80 = vzip1q_s16(v74, v74);
        v81 = vzip1q_s16(v75, v75);
        if (!(v69 >> 3))
          goto LABEL_16;
        v82 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
        v87.val[0] = vqrshrun_n_s16(vqaddq_s16(v82, v79), 7uLL);
        v87.val[2] = vqrshrun_n_s16(vqaddq_s16(v82, v80), 7uLL);
        v87.val[1] = vqrshrun_n_s16(vqsubq_s16(v82, v81), 7uLL);
        v87.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v87);
        a4 += 32;
        v79 = v76;
        v80 = v77;
        v81 = v78;
        v70.i64[0] = v70.i64[1];
        v69 -= 8;
        if (v69)
        {
LABEL_16:
          v83 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v79), 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v80), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v83, v81), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            v9 = vshrq_n_u64(v9, 8uLL);
            --v69;
          }
          while (v69);
        }
      }
    }
    else
    {
      v16 = a7 >> 4;
      for (j = result[1]; v16; --v16)
      {
        v18 = *v13++;
        v19 = *j++;
        v20 = *v14++;
        v21 = *v15++;
        v22 = (int16x8_t)vsubl_u8(v20, v11);
        v23 = (int16x8_t)vsubl_u8(v21, v11);
        v24 = vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3);
        v25 = vmulq_n_s16(v23, 179);
        v26 = vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2));
        v27 = vzip2q_s16(v24, v24);
        v28 = vzip2q_s16(v25, v25);
        v29 = vzip2q_s16(v26, v26);
        v30 = vzip1q_s16(v24, v24);
        v31 = vzip1q_s16(v25, v25);
        v32 = vzip1q_s16(v26, v26);
        v33 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v18.i8, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v33, v30), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v33, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v33, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v84);
        v34 = a4 + 32;
        v35 = (int16x8_t)vshll_high_n_u8(v18, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v35, v27), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v35, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v35, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v34, v84);
        a4 = v34 + 32;
        v36 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v19.i8, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v36, v30), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v36, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v36, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v84);
        v37 = a5 + 32;
        v38 = (int16x8_t)vshll_high_n_u8(v19, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v38, v27), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v38, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v38, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v37, v84);
        a5 = v37 + 32;
      }
      v39 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v40 = *(uint64x2_t *)v13;
        v41 = *(uint64x2_t *)j;
        v42 = (int16x8_t)vsubl_u8(*v14, v11);
        v43 = (int16x8_t)vsubl_u8(*v15, v11);
        v44 = vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 3);
        v45 = vmulq_n_s16(v43, 179);
        v46 = vqaddq_s16(vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v43, (int16x4_t)0xE3005B002C00B3, 2));
        v47 = vzip2q_s16(v44, v44);
        v48 = vzip2q_s16(v45, v45);
        v49 = vzip2q_s16(v46, v46);
        v50 = vzip1q_s16(v44, v44);
        v51 = vzip1q_s16(v45, v45);
        v52 = vzip1q_s16(v46, v46);
        if (!(v39 >> 3))
          goto LABEL_8;
        v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v53, v50), 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v53, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v53, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v85);
        a4 += 32;
        v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v54, v50), 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v54, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v54, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v85);
        a5 += 32;
        v50 = v47;
        v51 = v48;
        v52 = v49;
        v40.i64[0] = v40.i64[1];
        v41.i64[0] = v41.i64[1];
        v39 -= 8;
        if (v39)
        {
LABEL_8:
          v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v50), 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v51), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v55, v52), 7uLL);
          v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
          *(int8x8_t *)v40.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v50), 7uLL);
          *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v51), 7uLL);
          *(int8x8_t *)v41.i8 = vqrshrun_n_s16(vqsubq_s16(v56, v52), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            v9 = vshrq_n_u64(v9, 8uLL);
            *a5 = v40.i8[0];
            a5[1] = v41.i8[0];
            a5[2] = v10.i8[0];
            a5[3] = v12;
            a5 += 4;
            v40 = vshrq_n_u64(v40, 8uLL);
            v41 = vshrq_n_u64(v41, 8uLL);
            v10 = vshrq_n_u64(v10, 8uLL);
            --v39;
          }
          while (v39);
        }
      }
    }
  }
  return result;
}

uint64_t aj_idct_s2_4x8_nearest(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = vqrdmulhq_lane_s16(vaddq_s16(v3, v5), (int16x4_t)0x6C8361F84546, 0);
  v7 = vaddq_s16(*a1, v4);
  v8 = vsubq_s16(*a1, v4);
  v9 = vaddq_s16(vqrdmulhq_lane_s16(v3, (int16x4_t)0x6C8361F84546, 1), v6);
  v10 = vsubq_s16(vsubq_s16(v6, vqrdmulhq_lane_s16(v5, (int16x4_t)0x6C8361F84546, 2)), v5);
  v11 = vaddq_s16(v7, v9);
  v12 = vaddq_s16(v8, v10);
  v13 = vsubq_s16(v8, v10);
  v14 = vsubq_s16(v7, v9);
  v15 = (int32x4_t)vtrn1q_s16(v11, v12);
  v16 = (int32x4_t)vtrn2q_s16(v11, v12);
  v17 = (int32x4_t)vtrn1q_s16(v13, v14);
  v18 = (int32x4_t)vtrn2q_s16(v13, v14);
  v19 = (int16x8_t)vtrn1q_s32(v15, v17);
  v20 = (int16x8_t)vtrn2q_s32(v15, v17);
  v21 = (int16x8_t)vtrn1q_s32(v16, v18);
  v22 = (int16x8_t)vtrn2q_s32(v16, v18);
  v23 = vqrdmulhq_lane_s16(vaddq_s16(v21, v22), (int16x4_t)0x6C8361F84546, 0);
  v24 = vaddq_s16(v19, v20);
  v25 = vsubq_s16(v19, v20);
  v26 = vaddq_s16(vqrdmulhq_lane_s16(v21, (int16x4_t)0x6C8361F84546, 1), v23);
  v27 = vsubq_s16(vsubq_s16(v23, vqrdmulhq_lane_s16(v22, (int16x4_t)0x6C8361F84546, 2)), v22);
  v28 = vaddq_s16(v24, v26);
  v29 = vaddq_s16(v25, v27);
  v30 = vsubq_s16(v25, v27);
  v31 = vsubq_s16(v24, v26);
  v32 = (int32x4_t)vtrn1q_s16(v28, v29);
  v33 = (int32x4_t)vtrn2q_s16(v28, v29);
  v34 = (int32x4_t)vtrn1q_s16(v30, v31);
  v35 = (int32x4_t)vtrn2q_s16(v30, v31);
  v37 = *a2;
  v38 = a2[1];
  v36 = a2 + 2;
  _X3 = (int8x8_t *)(v37 + a3);
  _X4 = (int8x8_t *)(v38 + a3);
  _X5 = (int8x8_t *)(*v36 + a3);
  _X6 = (int8x8_t *)(v36[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  *(int8x8_t *)v28.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v29.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v30.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v31.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080);
  *_X3 = vzip1_s8(*(int8x8_t *)v28.i8, *(int8x8_t *)v28.i8);
  *_X4 = vzip1_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)v29.i8);
  *_X5 = vzip1_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)v30.i8);
  *_X6 = vzip1_s8(*(int8x8_t *)v31.i8, *(int8x8_t *)v31.i8);
  return 8;
}

uint64_t aj_RGBA8888_YUV444(double a1, int64x2_t a2, int64x2_t a3, int64x2_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unsigned int a8, int a9)
{
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  unsigned int i;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int v20;
  int v21;
  int v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  uint64_t result;
  char v27;
  char v28;
  char v29;
  int8x8x4_t v30;

  v9 = *a6;
  v10 = *(_BYTE **)a7;
  v11 = *(_BYTE **)(a7 + 16);
  v12 = *(_BYTE **)(a7 + 32);
  v13.i64[0] = 0x80008000800080;
  v13.i64[1] = 0x80008000800080;
  v14 = vshlq_n_s16(v13, 7uLL);
  v15.i64[0] = 0x15980E984B232646;
  v15.i64[1] = 0xA6835982A68;
  for (i = a8 >> 3; i; --i)
  {
    v30 = vld4_s8((const char *)v9);
    v9 += 32;
    v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[0], 7uLL);
    v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[1], 7uLL);
    v19 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[2], 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v19, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v18, v15, 4)), vrshrq_n_s16(v19, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v17, 1uLL), vqrdmulhq_laneq_s16(v18, v15, 5)), vqrdmulhq_laneq_s16(v19, v15, 6)), v14), 7uLL);
    *(_QWORD *)v10 = a2.i64[0];
    v10 += 8;
    *(_QWORD *)v11 = a3.i64[0];
    v11 += 8;
    *(_QWORD *)v12 = a4.i64[0];
    v12 += 8;
  }
  v20 = a8 & 7;
  if ((a8 & 7) != 0)
  {
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      a2.i8[0] = *(_BYTE *)v9;
      a3.i8[0] = *(_BYTE *)(v9 + 1);
      a4.i8[0] = *(_BYTE *)(v9 + 2);
      v9 += 4;
      --v20;
    }
    while (v20);
    v21 = a8 & 7;
    v22 = 8 - v21;
    v23 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a2.i8, 7uLL);
    v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a3.i8, 7uLL);
    v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a4.i8, 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v24, v15, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v15, 5)), vqrdmulhq_laneq_s16(v25, v15, 6)), v14), 7uLL);
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v22;
    }
    while (v22);
    do
    {
      *v10++ = a2.i8[7];
      *v11++ = a3.i8[7];
      *v12++ = a4.i8[7];
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v21;
    }
    while (v21);
  }
  result = a9 - a8;
  if (a9 != a8)
  {
    v27 = *(v10 - 1);
    v28 = *(v11 - 1);
    v29 = *(v12 - 1);
    do
    {
      *v10++ = v27;
      *v11++ = v28;
      *v12++ = v29;
      result = (result - 1);
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t aj_ostream_write(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  _BYTE *v9;
  _BYTE *v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v15;
  unsigned int v16;
  _BYTE *v17;
  unsigned int v18;
  _BYTE *v19;
  unsigned __int8 v20;
  unsigned int *v21;
  unsigned int v22;
  int v23;

  if (!a3)
    return 0;
  if (a1[16] && (int)a1[5] <= 8)
  {
    v22 = a2;
    v23 = a3;
    v21 = a1;
    v20 = (*((uint64_t (**)(_QWORD, _QWORD, _QWORD))a1 + 5))(*((_QWORD *)a1 + 3), a1[2] - *((_QWORD *)a1 + 3), *((_QWORD *)a1 + 4));
    if (v20)
    {
      aj_log_error(0, "Output callback returned error code %d.", v20);
      return 9;
    }
    a1 = v21;
    *((_QWORD *)v21 + 1) = *((_QWORD *)v21 + 3);
    v21[5] = v21[16];
    a2 = v22;
    a3 = v23;
  }
  v3 = *a1;
  v4 = a1[1];
  v5 = v4 + a3;
  if (v4 + a3 >= 33)
  {
    a3 = v5 - 32;
    v15 = v3 | (a2 >> v5);
    *a1 = v15;
    a2 &= 0xFFFFFFFF >> -(char)v5;
    v16 = HIBYTE(v15);
    v17 = (_BYTE *)*((_QWORD *)a1 + 1);
    *((_QWORD *)a1 + 1) = v17 + 1;
    *v17 = v16;
    v18 = a1[4];
    a1[4] = v18 + 1;
    if (v16 == 255)
    {
      a1[4] = v18 + 2;
      v19 = (_BYTE *)*((_QWORD *)a1 + 1);
      *((_QWORD *)a1 + 1) = v19 + 1;
      *v19 = 0;
    }
    v3 = *a1 << 8;
    v4 = 24;
  }
  v6 = v4 + a3;
  v7 = (a2 << -(char)v6) | v3;
  *a1 = v7;
  a1[1] = v6;
  if (v6 >= 8)
  {
    do
    {
      v8 = HIBYTE(v7);
      v9 = (_BYTE *)*((_QWORD *)a1 + 1);
      *((_QWORD *)a1 + 1) = v9 + 1;
      *v9 = v8;
      ++a1[4];
      if (v8 == 255)
      {
        v10 = (_BYTE *)*((_QWORD *)a1 + 1);
        *((_QWORD *)a1 + 1) = v10 + 1;
        *v10 = 0;
        ++a1[4];
      }
      v11 = a1[1];
      v7 = *a1 << 8;
      *a1 = v7;
      a1[1] = v11 - 8;
    }
    while (v11 > 15);
  }
  v12 = a1[16];
  v13 = 0;
  if (v12)
    a1[5] = v12 + a1[6] - a1[2];
  return v13;
}

uint64_t aj_ostream_write_bytes(uint64_t a1, int a2, int a3)
{
  int v3;
  int v6;
  uint64_t result;
  int v8;
  _BYTE *v9;
  int v10;
  int v11;

  if (!a3)
    return 0;
  v3 = a3;
  v6 = *(_DWORD *)(a1 + 4);
  if (!v6 || (result = aj_ostream_write((unsigned int *)a1, 0xFFu >> v6, 8 - v6), !(_DWORD)result))
  {
    if (*(_DWORD *)(a1 + 64) && *(int *)(a1 + 20) <= 8)
    {
      v11 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1 + 40))(*(_QWORD *)(a1 + 24), *(_DWORD *)(a1 + 8) - *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
      if (v11)
      {
        aj_log_error(0, "Output callback returned error code %d.", v11);
        return 9;
      }
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 64);
    }
    v8 = a2 << (-8 * v3);
    do
    {
      v9 = *(_BYTE **)(a1 + 8);
      *(_QWORD *)(a1 + 8) = v9 + 1;
      *v9 = HIBYTE(v8);
      v8 <<= 8;
      ++*(_DWORD *)(a1 + 16);
      --v3;
    }
    while (v3);
    v10 = *(_DWORD *)(a1 + 64);
    if (v10)
    {
      result = 0;
      *(_DWORD *)(a1 + 20) = v10 + *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 8);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t aj_ostream_write_buf(uint64_t a1, char *__src, uint64_t a3)
{
  uint64_t v3;
  int v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  int v10;

  if (!(_DWORD)a3)
    return 0;
  v3 = a3;
  v6 = *(_DWORD *)(a1 + 4);
  if (v6)
  {
    result = aj_ostream_write((unsigned int *)a1, 0xFFu >> v6, 8 - v6);
    if ((_DWORD)result)
      return result;
  }
  v8 = *(_DWORD *)(a1 + 20);
  if (v8 <= (int)v3)
  {
    v10 = *(_DWORD *)(a1 + 64);
    if (!v10)
      goto LABEL_12;
LABEL_9:
    if (v8 != v10)
    {
      LODWORD(result) = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1 + 40))(*(_QWORD *)(a1 + 24), *(_DWORD *)(a1 + 8) - *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
      if ((_DWORD)result)
      {
LABEL_14:
        aj_log_error(0, "Output callback returned error code %d.", result);
        return 9;
      }
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 64);
    }
    goto LABEL_12;
  }
  memcpy(*(void **)(a1 + 8), __src, (int)v3);
  v9 = *(_QWORD *)(a1 + 8) + (int)v3;
  *(_QWORD *)(a1 + 8) = v9;
  __src += (int)v3;
  v10 = *(_DWORD *)(a1 + 64);
  v8 = v10 + *(_DWORD *)(a1 + 24) - v9;
  *(_DWORD *)(a1 + 16) += v3;
  *(_DWORD *)(a1 + 20) = v8;
  v3 = 0;
  if (v10)
    goto LABEL_9;
LABEL_12:
  if (!(_DWORD)v3)
    return 0;
  result = (*(uint64_t (**)(char *, uint64_t, _QWORD))(a1 + 40))(__src, v3, *(_QWORD *)(a1 + 32));
  if ((_DWORD)result)
    goto LABEL_14;
  *(_DWORD *)(a1 + 16) += v3;
  return result;
}

uint64_t aj_ostream_flush_bitreg(unsigned int *a1)
{
  unsigned int v1;

  v1 = a1[1];
  if (v1)
    return aj_ostream_write(a1, 0xFFu >> v1, 8 - v1);
  else
    return 0;
}

uint64_t aj_ostream_flush_buffer(uint64_t a1)
{
  int v2;
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  if (!*(_DWORD *)(a1 + 64))
    return 0;
  v2 = *(_DWORD *)(a1 + 4);
  if (!v2 || (result = aj_ostream_write((unsigned int *)a1, 0xFFu >> v2, 8 - v2), !(_DWORD)result))
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(_QWORD *)(a1 + 24);
    if (v4 > v5)
    {
      result = (*(uint64_t (**)(unint64_t, _QWORD, _QWORD))(a1 + 40))(v5, (v4 - v5), *(_QWORD *)(a1 + 32));
      if ((_DWORD)result)
      {
        aj_log_error(0, "Output callback returned error code %d.", result);
        return 9;
      }
      else
      {
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 24);
      }
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t aj_idct_s1_16x8_bilinear(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  int16x8_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int16x8_t v85;
  int16x8_t v86;
  int16x8_t v87;
  int16x8_t v88;
  int16x8_t v89;
  int16x8_t v90;
  int16x8_t v91;
  int16x8_t v92;
  int16x8_t v93;
  uint16x8_t v114;
  uint16x8_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint16x8_t v120;
  uint16x8_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint16x8_t v126;
  uint16x8_t v127;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = vaddq_s16(v8, v4);
  v10 = vaddq_s16(*a1, v6);
  v11 = vsubq_s16(*a1, v6);
  v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  v13 = vqshlq_n_s16(a1[7], 1uLL);
  v14 = vaddq_s16(v5, v7);
  v15 = vsubq_s16(v7, v5);
  v16 = vaddq_s16(v3, v13);
  v17 = vsubq_s16(v3, v13);
  v18 = vaddq_s16(v16, v14);
  v19 = vaddq_s16(v9, v12);
  v20 = vaddq_s16(v10, v19);
  v21 = vsubq_s16(v10, v19);
  v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  v24 = vsubq_s16(v11, v12);
  v25 = vaddq_s16(v11, v12);
  v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  v28 = vaddq_s16(v18, v26);
  v29 = vaddq_s16(v26, v23);
  v30 = vaddq_s16(v27, v23);
  v31 = vaddq_s16(v20, v28);
  v32 = vaddq_s16(v25, v29);
  v33 = vaddq_s16(v24, v30);
  v34 = vaddq_s16(v21, v27);
  v35 = vsubq_s16(v21, v27);
  v36 = vsubq_s16(v24, v30);
  v37 = vsubq_s16(v25, v29);
  v38 = vsubq_s16(v20, v28);
  v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  v64 = *a2;
  v65 = a2[1];
  v63 = a2 + 2;
  v66 = *v63;
  v67 = v63[1];
  v63 += 2;
  v68 = *v63;
  v69 = v63[1];
  v63 += 2;
  v70 = *v63;
  v71 = v63[1];
  v63 += 2;
  v72 = vaddq_s16(v60, v59);
  v73 = vaddq_s16(v55, v56);
  v74 = vsubq_s16(v55, v56);
  v75 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  v76 = vqshlq_n_s16(v62, 1uLL);
  v77 = vaddq_s16(v61, v58);
  v78 = vsubq_s16(v58, v61);
  v79 = vaddq_s16(v57, v76);
  v80 = vsubq_s16(v57, v76);
  v81 = vaddq_s16(v79, v77);
  v82 = vaddq_s16(v72, v75);
  v83 = vaddq_s16(v73, v82);
  v84 = vsubq_s16(v73, v82);
  v85 = vqrdmulhq_lane_s16(vaddq_s16(v78, v80), (int16x4_t)0x30FC273D5A824546, 3);
  v86 = vqrdmulhq_lane_s16(vsubq_s16(v79, v77), (int16x4_t)0x30FC273D5A824546, 1);
  v87 = vsubq_s16(v74, v75);
  v88 = vaddq_s16(v74, v75);
  v89 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v80, (int16x4_t)0x30FC273D5A824546, 2), v80), v85);
  v90 = vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 0), v85);
  v91 = vaddq_s16(v81, v89);
  v92 = vaddq_s16(v89, v86);
  v93 = vaddq_s16(v90, v86);
  _X3 = (_QWORD *)(v64 + a3);
  _X4 = (uint8x8_t *)(v65 + a3);
  _X5 = (uint8x8_t *)(v66 + a3);
  _X6 = (uint8x8_t *)(v67 + a3);
  _X7 = (uint8x8_t *)(v68 + a3);
  _X9 = (uint8x8_t *)(v69 + a3);
  _X10 = (uint8x8_t *)(v70 + a3);
  _X11 = (uint8x8_t *)(v71 + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *(int8x8_t *)v55.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v83, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v86.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v88, v92), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v75.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v87, v93), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v81.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v84, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v74.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v84, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v90.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v87, v93), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v84.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v88, v92), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v92.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v83, v91), 5uLL), (int8x8_t)0x8080808080808080);
  v91.i64[0] = 0x1000100010001;
  v91.i64[1] = 0x1000100010001;
  *_X3 = v55.i64[0];
  v114 = vmull_u8(*(uint8x8_t *)v86.i8, (uint8x8_t)0x303030303030303);
  v115 = vmull_u8(*(uint8x8_t *)v75.i8, (uint8x8_t)0x303030303030303);
  *_X4 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(vmull_u8(*(uint8x8_t *)v55.i8, (uint8x8_t)0x303030303030303), *(uint8x8_t *)v86.i8), v91), 2uLL);
  *_X5 = vqrshrn_n_u16(vaddw_u8(v114, *(uint8x8_t *)v55.i8), 2uLL);
  *_X6 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v114, *(uint8x8_t *)v75.i8), v91), 2uLL);
  *_X7 = vqrshrn_n_u16(vaddw_u8(v115, *(uint8x8_t *)v86.i8), 2uLL);
  v116 = *v63;
  v117 = v63[1];
  v63 += 2;
  v118 = *v63;
  v119 = v63[1];
  v63 += 2;
  v120 = vmull_u8(*(uint8x8_t *)v81.i8, (uint8x8_t)0x303030303030303);
  v121 = vmull_u8(*(uint8x8_t *)v74.i8, (uint8x8_t)0x303030303030303);
  *_X9 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v115, *(uint8x8_t *)v81.i8), v91), 2uLL);
  *_X10 = vqrshrn_n_u16(vaddw_u8(v120, *(uint8x8_t *)v75.i8), 2uLL);
  *_X11 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v120, *(uint8x8_t *)v74.i8), v91), 2uLL);
  *(uint8x8_t *)(v116 + a3) = vqrshrn_n_u16(vaddw_u8(v121, *(uint8x8_t *)v81.i8), 2uLL);
  v122 = *v63;
  v123 = v63[1];
  v63 += 2;
  v124 = *v63;
  v125 = v63[1];
  v126 = vmull_u8(*(uint8x8_t *)v90.i8, (uint8x8_t)0x303030303030303);
  v127 = vmull_u8(*(uint8x8_t *)v84.i8, (uint8x8_t)0x303030303030303);
  *(uint8x8_t *)(v117 + a3) = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v121, *(uint8x8_t *)v90.i8), v91), 2uLL);
  *(uint8x8_t *)(v118 + a3) = vqrshrn_n_u16(vaddw_u8(v126, *(uint8x8_t *)v74.i8), 2uLL);
  *(uint8x8_t *)(v119 + a3) = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v126, *(uint8x8_t *)v84.i8), v91), 2uLL);
  *(uint8x8_t *)(v122 + a3) = vqrshrn_n_u16(vaddw_u8(v127, *(uint8x8_t *)v90.i8), 2uLL);
  *(uint8x8_t *)(v123 + a3) = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v127, *(uint8x8_t *)v92.i8), v91), 2uLL);
  *(uint8x8_t *)(v124 + a3) = vqrshrn_n_u16(vaddw_u8(vmull_u8(*(uint8x8_t *)v92.i8, (uint8x8_t)0x303030303030303), *(uint8x8_t *)v84.i8), 2uLL);
  *(_QWORD *)(v125 + a3) = v92.i64[0];
  return 8;
}

uint64_t aj_idct_s1_8x4(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  int16x8_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int16x8_t v85;
  int16x8_t v86;
  int16x8_t v87;
  int16x8_t v88;
  int16x8_t v89;
  int16x8_t v90;
  int16x8_t v91;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = vaddq_s16(v8, v4);
  v10 = vaddq_s16(*a1, v6);
  v11 = vsubq_s16(*a1, v6);
  v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  v13 = vqshlq_n_s16(a1[7], 1uLL);
  v14 = vaddq_s16(v5, v7);
  v15 = vsubq_s16(v7, v5);
  v16 = vaddq_s16(v3, v13);
  v17 = vsubq_s16(v3, v13);
  v18 = vaddq_s16(v16, v14);
  v19 = vaddq_s16(v9, v12);
  v20 = vaddq_s16(v10, v19);
  v21 = vsubq_s16(v10, v19);
  v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  v24 = vsubq_s16(v11, v12);
  v25 = vaddq_s16(v11, v12);
  v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  v28 = vaddq_s16(v18, v26);
  v29 = vaddq_s16(v26, v23);
  v30 = vaddq_s16(v27, v23);
  v31 = vaddq_s16(v20, v28);
  v32 = vaddq_s16(v25, v29);
  v33 = vaddq_s16(v24, v30);
  v34 = vaddq_s16(v21, v27);
  v35 = vsubq_s16(v21, v27);
  v36 = vsubq_s16(v24, v30);
  v37 = vsubq_s16(v25, v29);
  v38 = vsubq_s16(v20, v28);
  v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  v64 = *a2;
  v65 = a2[1];
  v63 = a2 + 2;
  v66 = *v63;
  v67 = v63[1];
  v63 += 2;
  v68 = *v63;
  v69 = v63[1];
  v63 += 2;
  v70 = vaddq_s16(v60, v59);
  v71 = vaddq_s16(v55, v56);
  v72 = vsubq_s16(v55, v56);
  v73 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  v74 = vqshlq_n_s16(v62, 1uLL);
  v75 = vaddq_s16(v61, v58);
  v76 = vsubq_s16(v58, v61);
  v77 = vaddq_s16(v57, v74);
  v78 = vsubq_s16(v57, v74);
  v79 = vaddq_s16(v77, v75);
  v80 = vaddq_s16(v70, v73);
  v81 = vaddq_s16(v71, v80);
  v82 = vsubq_s16(v71, v80);
  v83 = vqrdmulhq_lane_s16(vaddq_s16(v76, v78), (int16x4_t)0x30FC273D5A824546, 3);
  v84 = vqrdmulhq_lane_s16(vsubq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  v85 = vsubq_s16(v72, v73);
  v86 = vaddq_s16(v72, v73);
  v87 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 2), v78), v83);
  v88 = vaddq_s16(vqrdmulhq_lane_s16(v76, (int16x4_t)0x30FC273D5A824546, 0), v83);
  v89 = vaddq_s16(v79, v87);
  v90 = vaddq_s16(v87, v84);
  v91 = vaddq_s16(v88, v84);
  _X3 = (_DWORD *)(v64 + a3);
  _X4 = (_DWORD *)(v65 + a3);
  _X5 = (_DWORD *)(v66 + a3);
  _X6 = (_DWORD *)(v67 + a3);
  _X7 = (_DWORD *)(v68 + a3);
  _X9 = (_DWORD *)(v69 + a3);
  _X10 = (_DWORD *)(*v63 + a3);
  _X11 = (_DWORD *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *(int8x8_t *)v55.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v84.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v73.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v79.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v72.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v88.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v82.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v90.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  *(uint8x8_t *)v55.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v84.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v84.i8));
  *(uint8x8_t *)v84.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v73.i8, *(int8x8_t *)v79.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v73.i8, *(int8x8_t *)v79.i8));
  *(uint8x8_t *)v73.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v72.i8, *(int8x8_t *)v88.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v72.i8, *(int8x8_t *)v88.i8));
  *(uint8x8_t *)v79.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v82.i8, *(int8x8_t *)v90.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v82.i8, *(int8x8_t *)v90.i8));
  *_X3 = v55.i32[0];
  *_X4 = v55.i32[1];
  *_X5 = v84.i32[0];
  *_X6 = v84.i32[1];
  *_X7 = v73.i32[0];
  *_X9 = v73.i32[1];
  *_X10 = v79.i32[0];
  *_X11 = v79.i32[1];
  return 4;
}

uint64_t huffman_gen(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unsigned int *v3;
  char *v4;
  unsigned int v5;
  char *v6;
  char **v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t j;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  int v24;
  _QWORD *v25;
  _QWORD v27[4];
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (*(int *)(a1 + 20) >= 1)
  {
    v1 = 0;
    do
    {
      v2 = 0;
      v3 = (unsigned int *)(a1 + 68 * v1 + 148);
      v27[0] = 0;
      v27[1] = 0;
      v4 = &v28;
      do
      {
        v5 = *v3;
        *((_DWORD *)v4 + 6) = v2;
        *((_DWORD *)v4 + 7) = v5;
        *((_QWORD *)v4 + 2) = v5;
        *((_QWORD *)v4 + 1) = 0;
        v6 = (char *)v27;
        while (1)
        {
          v7 = (char **)v6;
          v6 = *(char **)v6;
          if (!v6)
            break;
          if ((signed int)v5 <= *((_DWORD *)v6 + 7))
          {
            *(_QWORD *)v4 = v6;
            *v7 = v4;
            goto LABEL_9;
          }
        }
        *v7 = v4;
        *(_QWORD *)v4 = 0;
LABEL_9:
        ++v2;
        v4 += 32;
        ++v3;
      }
      while (v2 != 17);
      v8 = 0;
      *(_DWORD *)(v27[0] + 20) = 1;
      do
      {
        v9 = v27[0];
        v10 = *(_QWORD *)v27[0];
        v11 = *(_QWORD *)(*(_QWORD *)v27[0] + 8);
        v27[0] = **(_QWORD **)v27[0];
        v12 = *(_DWORD *)(v10 + 28) + *(_DWORD *)(v9 + 28);
        *(_DWORD *)(v10 + 28) = v12;
        ++*(_DWORD *)(v10 + 20);
        for (i = v10; v11; v11 = *(_QWORD *)(v11 + 8))
        {
          i = v11;
          ++*(_DWORD *)(v11 + 20);
        }
        *(_QWORD *)(i + 8) = v9;
        *(_QWORD *)v9 = 0;
        do
        {
          ++*(_DWORD *)(v9 + 20);
          v9 = *(_QWORD *)(v9 + 8);
        }
        while (v9);
        v14 = v27;
        while (1)
        {
          v15 = v14;
          v14 = (_QWORD *)*v14;
          if (!v14)
            break;
          if (v12 <= *((_DWORD *)v14 + 7))
          {
            *(_QWORD *)v10 = v14;
            *v15 = v10;
            goto LABEL_20;
          }
        }
        *v15 = v10;
        *(_QWORD *)v10 = 0;
LABEL_20:
        ++v8;
      }
      while (v8 != 16);
      v16 = a1 + 16 * v1 + 48;
      for (j = v27[0]; j; j = *(_QWORD *)(j + 8))
      {
        if (*(_DWORD *)(j + 16))
        {
          v18 = *(int *)(j + 20);
          if ((int)v18 <= 16)
            ++*(_BYTE *)(v18 + v16 - 1);
        }
      }
      v19 = 0;
      v20 = (_BYTE *)(a1 + 17 * v1 + 96);
      do
      {
        v21 = v27[0];
        v22 = v19 + 1;
        if (*(_BYTE *)(v16 + v19))
          v23 = v27[0] == 0;
        else
          v23 = 1;
        if (!v23)
        {
          v24 = 0;
          v25 = v27;
          do
          {
            if (v22 == *(_DWORD *)(v21 + 20))
            {
              *v20++ = *(_DWORD *)(v21 + 24);
              v25[1] = *(_QWORD *)(v21 + 8);
              if (*(unsigned __int8 *)(v16 + v19) == ++v24)
                break;
            }
            v25 = (_QWORD *)v21;
            v21 = *(_QWORD *)(v21 + 8);
          }
          while (v21);
        }
        ++v19;
      }
      while (v22 != 16);
      ++v1;
    }
    while (v1 < *(int *)(a1 + 20));
  }
  return 0;
}

uint64_t do_encode_lossless(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  int v12;
  int v13;
  char v14;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  char *v20;
  char *v21;
  int v22;
  uint16x8_t *v23;
  uint64_t v24;
  __int128 *v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  _OWORD *v32;
  BOOL v33;
  uint8x16_t v34;
  uint16x8_t v35;
  uint16x8_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  unsigned __int8 *v43;
  uint64_t v44;
  unsigned int v45;
  char *v46;
  _WORD *v47;
  char v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  int v54;
  int v55;
  int v56;
  int v57;
  uint16x8_t *v58;
  uint64_t v59;
  int v61;
  int v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  __int128 v66;
  int v67;
  int v68;
  _BYTE v69[12];
  int v70;
  uint8x16_t v71[3];
  __int128 v72;
  char v73;
  void *v74;
  char *v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 20184;
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD *)(a1 + 60);
  v5 = *(_DWORD *)(a1 + 13408);
  v64 = *(_QWORD *)(a1 + 19816);
  v6 = *(_DWORD *)(a1 + 13492);
  v7 = *(_DWORD *)(a1 + 20184);
  v8 = *(_DWORD *)(a1 + 20188);
  v9 = a1 + 22360;
  v74 = 0;
  v75 = 0;
  bzero(&v66, 0x228uLL);
  v65 = v9;
  *(_DWORD *)&v69[8] = 4;
  v70 = v3;
  v10 = 1;
  switch(v5)
  {
    case 0:
      v66 = xmmword_20627B430;
      v68 = 0;
      if (v6 == 3)
        goto LABEL_15;
      return v10;
    case 1:
    case 2:
      return v10;
    case 3:
      v66 = xmmword_20627B420;
      v68 = 0;
      *(_DWORD *)&v69[4] = 0x7FFFFFFF;
      goto LABEL_14;
    case 4:
      v66 = xmmword_20627B420;
      v67 = 2;
      *(_QWORD *)v69 = 0x7FFFFFFFFFFFFFFELL;
LABEL_14:
      if (v6 != 4)
        return v10;
LABEL_15:
      v62 = v4;
      v11 = 0;
      v14 = 0;
      v13 = 8;
LABEL_22:
      v12 = 1;
      if (v7)
        goto LABEL_23;
      goto LABEL_25;
    case 5:
      v66 = xmmword_20627B450;
      *(_DWORD *)&v69[8] = 7;
      if (v6 != 1)
        return v10;
      v62 = v4;
      v11 = 0;
      v12 = 0;
      v13 = 8;
LABEL_10:
      v14 = 1;
      if (!v7)
        goto LABEL_25;
LABEL_23:
      if (v7 > v13)
        return v10;
      DWORD1(v66) = v7;
LABEL_25:
      v63 = 0;
      if (v6 != 1 || v8 == 0)
        v16 = v8;
      else
        v16 = 0;
      if (v11)
        v17 = v12;
      else
        v17 = 1;
      v61 = v16;
      if (v16)
      {
        v18 = v64;
        if (v17)
        {
          v19 = v12;
          v20 = (char *)(*(uint64_t (**)(uint64_t, _QWORD))a1)(2 * v64, *(_QWORD *)(a1 + 16));
          v74 = v20;
          if (!v20)
          {
            aj_log_error(0, "Could not allocate memory for LLJPEG buffer");
            return 6;
          }
          v21 = v20;
          bzero(v20, 2 * v64);
          v63 = v21;
          v75 = &v21[v64];
          v12 = v19;
        }
        if ((v12 & 1) != 0)
        {
LABEL_39:
          if ((v14 & 1) != 0)
            goto LABEL_62;
LABEL_48:
          if ((_DWORD)v66 != 2)
          {
            v71[0] = (uint8x16_t)g_huff8_n;
            v73 = 16;
            v72 = g_huff8_v;
            goto LABEL_62;
          }
          if (SDWORD1(v66) > 11)
          {
            if (DWORD1(v66) == 12)
            {
              v71[0] = (uint8x16_t)g_huff16_n_12;
              v73 = 16;
              v72 = g_huff16_v_12;
LABEL_58:
              v26 = 0;
              v27 = 0;
              v28 = DWORD1(v66) + 2;
              do
              {
                v29 = v71[0].u8[v26];
                v27 += v29;
                if (v27 - v28 >= 1)
                {
                  v71[0].i8[v26] = v29 - (v27 - v28);
                  v27 = v28;
                }
                ++v26;
              }
              while (v26 != 16);
              goto LABEL_62;
            }
            v71[0] = (uint8x16_t)g_huff16_n;
            v25 = &g_huff16_v;
          }
          else
          {
            v71[0].i64[0] = 0x101010101010101;
            v71[0].i64[1] = 0x101010101010101;
            v25 = &g_huff8_v;
          }
          v72 = *v25;
          v73 = *((_BYTE *)v25 + 16);
          if (!DWORD1(v66) || SDWORD1(v66) >= 16)
            goto LABEL_62;
          if (SDWORD1(v66) < 9)
            goto LABEL_79;
          goto LABEL_58;
        }
      }
      else
      {
        v18 = v64;
        if ((v12 & 1) != 0)
          goto LABEL_39;
      }
      v22 = v12;
      v23 = *(uint16x8_t **)(a1 + 22264);
      if (v11)
        v24 = do_compress_lossless_neon(v23, &v65, v62, v18, v61, 1);
      else
        v24 = do_compress_lossless((uint64_t)v23, (uint64_t)&v65, (uint64_t)&v74, v62, v3, v18, v61, 0, 1);
      v10 = v24;
      if ((_DWORD)v24)
        goto LABEL_127;
      huffman_gen((uint64_t)&v65);
      v12 = v22;
      if ((v14 & 1) == 0)
        goto LABEL_48;
LABEL_62:
      v30 = HIDWORD(v66);
      if (SHIDWORD(v66) >= 1)
      {
        v31 = 0;
        v32 = (_OWORD *)v71;
        v33 = 1;
        while (1)
        {
          v34 = v71[v31];
          v35 = vmovl_high_u8(v34);
          v36 = vmovl_u8(*(uint8x8_t *)v34.i8);
          v37 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v36.i8, *(uint16x4_t *)v35.i8), (int32x4_t)vaddl_high_u16(v36, v35)));
          if (v37)
            break;
LABEL_76:
          ++v31;
          ++v32;
          v33 = v31 < v30;
          if (v31 == v30)
            goto LABEL_80;
        }
        v38 = 0;
        LODWORD(v39) = 0;
        v40 = 0;
        v41 = 0;
        while (v38 < (int)v39)
        {
LABEL_73:
          if (v40 >= ~(-1 << v41))
            goto LABEL_78;
          v46 = (char *)&v65 + 68 * v31 + 4 * *((unsigned __int8 *)&v65 + 17 * v31 + v38 + 96);
          if (*((_WORD *)v46 + 176))
            goto LABEL_78;
          v47 = v46 + 352;
          *v47 = v41;
          v47[1] = v40;
          ++v38;
          ++v40;
          if (v38 == v37)
            goto LABEL_76;
        }
        v42 = v41 <= 17 ? 17 : v41;
        v43 = (unsigned __int8 *)v32 + v41;
        v44 = v42 - v41;
        while (v44)
        {
          v45 = *v43++;
          v39 = v45 + (uint64_t)(int)v39;
          v40 *= 2;
          ++v41;
          --v44;
          if (v38 < v39)
            goto LABEL_73;
        }
LABEL_78:
        if (v33)
        {
LABEL_79:
          v10 = 1;
          goto LABEL_127;
        }
      }
LABEL_80:
      v48 = v17;
      v49 = v12;
      v10 = aj_ostream_write_bytes(v9, 65496, 2);
      if (!(_DWORD)v10)
      {
        v10 = aj_ostream_write_bytes(v9, 65504, 2);
        if (!(_DWORD)v10)
        {
          v10 = aj_ostream_write_bytes(v9, 16, 2);
          if (!(_DWORD)v10)
          {
            v10 = aj_ostream_write_bytes(v9, 19014, 2);
            if (!(_DWORD)v10)
            {
              v10 = aj_ostream_write_bytes(v9, 18758, 2);
              if (!(_DWORD)v10)
              {
                v10 = aj_ostream_write_bytes(v9, 0, 1);
                if (!(_DWORD)v10)
                {
                  v10 = aj_ostream_write_bytes(v9, 258, 2);
                  if (!(_DWORD)v10)
                  {
                    v10 = aj_ostream_write_bytes(v9, 1, 1);
                    if (!(_DWORD)v10)
                    {
                      v10 = aj_ostream_write_bytes(v9, 72, 2);
                      if (!(_DWORD)v10)
                      {
                        v10 = aj_ostream_write_bytes(v9, 72, 2);
                        if (!(_DWORD)v10)
                        {
                          v10 = aj_ostream_write_bytes(v9, 0, 2);
                          if (!(_DWORD)v10)
                          {
                            v10 = aj_ostream_write_bytes(v9, 65475, 2);
                            if (!(_DWORD)v10)
                            {
                              v10 = aj_ostream_write_bytes(v9, 3 * HIDWORD(v66) + 8, 2);
                              if (!(_DWORD)v10)
                              {
                                v10 = aj_ostream_write_bytes(v9, SDWORD1(v66), 1);
                                if (!(_DWORD)v10)
                                {
                                  v10 = aj_ostream_write_bytes(v9, v62, 2);
                                  if (!(_DWORD)v10)
                                  {
                                    v10 = aj_ostream_write_bytes(v9, v3, 2);
                                    if (!(_DWORD)v10)
                                    {
                                      v10 = aj_ostream_write_bytes(v9, SHIDWORD(v66), 1);
                                      if (!(_DWORD)v10)
                                      {
                                        if (SHIDWORD(v66) >= 1)
                                        {
                                          v50 = 0;
                                          do
                                          {
                                            v51 = aj_ostream_write_bytes(v9, v50, 1);
                                            if ((_DWORD)v51)
                                              goto LABEL_126;
                                            v51 = aj_ostream_write_bytes(v9, 17, 1);
                                            if ((_DWORD)v51)
                                              goto LABEL_126;
                                            v51 = aj_ostream_write_bytes(v9, 0, 1);
                                            if ((_DWORD)v51)
                                              goto LABEL_126;
                                          }
                                          while (++v50 < SHIDWORD(v66));
                                        }
                                        v52 = encodeWriteHuffTable(&v65, 0);
                                        if (SHIDWORD(v66) < 2)
                                          v53 = 1;
                                        else
                                          v53 = v49;
                                        if ((v53 & 1) == 0)
                                        {
                                          v54 = 1;
                                          do
                                            v52 = encodeWriteHuffTable(&v65, v54++);
                                          while (v54 < SHIDWORD(v66));
                                        }
                                        v10 = v52;
                                        if (!(_DWORD)v52)
                                        {
                                          v10 = aj_ostream_write_bytes(v9, 65498, 2);
                                          if (!(_DWORD)v10)
                                          {
                                            v10 = aj_ostream_write_bytes(v9, 2 * HIDWORD(v66) + 6, 2);
                                            if (!(_DWORD)v10)
                                            {
                                              v10 = aj_ostream_write_bytes(v9, SHIDWORD(v66), 1);
                                              if (!(_DWORD)v10)
                                              {
                                                if (SHIDWORD(v66) >= 1)
                                                {
                                                  v55 = 0;
                                                  v56 = 0;
                                                  while (1)
                                                  {
                                                    v51 = aj_ostream_write_bytes(v9, v56, 1);
                                                    if ((_DWORD)v51)
                                                      break;
                                                    v57 = v49 ? 0 : v55;
                                                    v51 = aj_ostream_write_bytes(v9, v57, 1);
                                                    if ((_DWORD)v51)
                                                      break;
                                                    ++v56;
                                                    v55 += 16;
                                                    if (v56 >= SHIDWORD(v66))
                                                      goto LABEL_121;
                                                  }
LABEL_126:
                                                  v10 = v51;
                                                  goto LABEL_127;
                                                }
LABEL_121:
                                                v10 = aj_ostream_write_bytes(v9, *(int *)&v69[8], 1);
                                                if (!(_DWORD)v10)
                                                {
                                                  v10 = aj_ostream_write_bytes(v9, 0, 1);
                                                  if (!(_DWORD)v10)
                                                  {
                                                    v10 = aj_ostream_write_bytes(v9, 0, 1);
                                                    if (!(_DWORD)v10)
                                                    {
                                                      v58 = *(uint16x8_t **)(a1 + 22264);
                                                      v59 = (v48 & 1) != 0
                                                          ? do_compress_lossless((uint64_t)v58, (uint64_t)&v65, (uint64_t)&v74, v62, v3, v64, v61, v49, 0): do_compress_lossless_neon(v58, &v65, v62, v64, v61, 0);
                                                      v10 = v59;
                                                      if (!(_DWORD)v59)
                                                      {
                                                        v10 = aj_ostream_write_bytes(v9, 65497, 2);
                                                        if (!(_DWORD)v10)
                                                        {
                                                          v10 = aj_ostream_flush_buffer(v9);
                                                          if (!(_DWORD)v10)
                                                            *(_DWORD *)(v2 + 2264) = *(_DWORD *)(v2 + 2192);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
LABEL_127:
      if (v63)
        (*(void (**)(char *, _QWORD))(a1 + 8))(v63, *(_QWORD *)(a1 + 16));
      return v10;
    default:
      switch(v5)
      {
        case 16:
          v66 = xmmword_20627B400;
          v68 = 0;
          v11 = (v3 & 7) == 0;
          *(_QWORD *)&v69[4] = 0x77FFFFFFFLL;
          if (v6 == 8)
          {
            v62 = v4;
            v12 = 0;
            v13 = 16;
            goto LABEL_10;
          }
          break;
        case 17:
          v66 = xmmword_20627B400;
          v67 = 2;
          *(_QWORD *)v69 = 0x7FFFFFFFFFFFFFFELL;
          if (v6 == 8)
            goto LABEL_21;
          break;
        case 18:
          v66 = xmmword_20627B440;
          if (v6 == 2)
            goto LABEL_21;
          break;
        case 20:
          v66 = xmmword_20627B410;
          v68 = 0;
          if (v6 == 6)
          {
LABEL_21:
            v62 = v4;
            v11 = 0;
            v14 = 0;
            v13 = 16;
            goto LABEL_22;
          }
          break;
        default:
          return v10;
      }
      return v10;
  }
}

uint64_t do_compress_lossless_neon(uint16x8_t *a1, _DWORD *a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  int16x8_t v6;
  int v8;
  uint16x8_t *v9;
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  _DWORD *v14;
  uint16x8_t v15;
  _DWORD *v16;
  int16x8_t v17;
  uint16x8_t v18;
  int16x8_t v19;
  int32x2_t *v20;
  int32x2_t *v21;
  uint16x8_t *v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  _BYTE *v31;
  int v32;
  __int32 v33;
  int v34;
  int v35;
  uint16x8_t *v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  unint64_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int16x8_t v53;
  int8x16_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  uint16x8_t v59;
  uint16x8_t v60;
  uint16x8_t v61;
  uint16x8_t v62;
  int64x2_t v63;
  int64x2_t v64;
  uint64_t v65;
  int64x2_t v66;
  _DWORD *v67;
  uint64_t v68;
  int v69;
  int8x16_t v70;
  unsigned __int16 *v71;
  int v72;
  unint64_t v73;
  BOOL v74;
  int v75;
  unint64_t v76;
  int32x2_t v77;
  int v78;
  unsigned __int16 *v79;
  int v80;
  unint64_t v81;
  int v82;
  int v83;
  unsigned __int16 *v84;
  int v85;
  unint64_t v86;
  int v87;
  int v88;
  unsigned __int16 *v89;
  int v90;
  unint64_t v91;
  int v92;
  int v93;
  unsigned __int16 *v94;
  int v95;
  unint64_t v96;
  int v97;
  int v98;
  unsigned __int16 *v99;
  int v100;
  unint64_t v101;
  int v102;
  int v103;
  int8x16_t v104;
  unsigned __int16 *v105;
  int v106;
  unint64_t v107;
  int v108;
  int v109;
  unsigned __int16 *v110;
  int v111;
  unint64_t v112;
  int v113;
  int v114;
  unsigned __int16 *v115;
  int v116;
  unint64_t v117;
  int v118;
  int v119;
  unsigned __int16 *v120;
  int v121;
  unint64_t v122;
  int v123;
  int v124;
  unsigned __int16 *v125;
  int v126;
  unint64_t v127;
  int v128;
  int v129;
  unsigned __int16 *v130;
  int v131;
  unint64_t v132;
  int v133;
  int v134;
  int8x16_t v135;
  unsigned __int16 *v136;
  int v137;
  unint64_t v138;
  int v139;
  int v140;
  unsigned __int16 *v141;
  int v142;
  unint64_t v143;
  int v144;
  int v145;
  unsigned __int16 *v146;
  int v147;
  unint64_t v148;
  int v149;
  int v150;
  unsigned __int16 *v151;
  int v152;
  unint64_t v153;
  int v154;
  int v155;
  unsigned __int16 *v156;
  int v157;
  unint64_t v158;
  int v159;
  int v160;
  unsigned __int16 *v161;
  int v162;
  unint64_t v163;
  int v164;
  int v165;
  int8x16_t v166;
  unsigned __int16 *v167;
  int v168;
  unint64_t v169;
  int v170;
  int v171;
  unsigned __int16 *v172;
  int v173;
  unint64_t v174;
  int v175;
  int v176;
  unsigned __int16 *v177;
  int v178;
  unint64_t v179;
  int v180;
  int v181;
  unsigned __int16 *v182;
  int v183;
  unint64_t v184;
  int v185;
  int v186;
  unsigned __int16 *v187;
  int v188;
  unint64_t v189;
  int v190;
  int v191;
  unsigned __int16 *v192;
  int v193;
  unint64_t v194;
  unsigned int v195;
  BOOL v196;
  int v197;
  int v198;
  uint16x8_t v199;
  uint16x8_t *v200;
  uint16x8_t v201;
  uint16x8_t v202;
  uint16x8_t v203;
  uint16x8_t v204;
  int v208;
  _DWORD *v210;
  _DWORD *v211;
  uint16x8_t v212;
  _DWORD *v213;
  char v214;
  uint16x8_t *v215;
  uint16x8_t v216;
  int16x8_t v217;
  uint16x8_t v218;
  int16x8_t v219;
  uint16x8_t v220;
  int16x8_t v221;
  uint16x8_t v222;
  int8x16_t v223;
  int8x16_t v224;
  int8x16_t v225;
  int8x16_t v226;
  uint16x8_t *v227;
  int v228;
  int8x16_t v229;
  int8x16_t v230;
  int8x16_t v231;
  int8x16_t v232;
  int16x8_t v233;
  int8x16_t v234;
  uint16x8_t *v235;

  if (a3 < 1)
    return 0;
  v8 = 0;
  v9 = 0;
  v10 = a2 + 37;
  v11 = a2 + 54;
  v12 = a2 + 71;
  v13 = a2 + 88;
  v14 = a2 + 105;
  v15 = (uint16x8_t)vdupq_n_s16(-a5);
  v16 = a2 + 122;
  v17.i64[0] = 0x10001000100010;
  v17.i64[1] = 0x10001000100010;
  v18.i64[0] = 0x1000100010001;
  v18.i64[1] = 0x1000100010001;
  v19.i64[0] = -1;
  v19.i64[1] = -1;
  v20 = (int32x2_t *)&unk_20627B000;
  v21 = (int32x2_t *)&unk_20627B000;
  v213 = a2 + 105;
  v212 = v15;
  v210 = a2 + 88;
  v211 = a2 + 122;
  while (1)
  {
    v208 = v8;
    if (v9)
    {
      v22 = v9 + 5;
      v23 = (int8x16_t)vshlq_u16(*v9, v15);
      v24 = (int8x16_t)vshlq_u16(v9[1], v15);
      v25 = (int8x16_t)vshlq_u16(v9[2], v15);
      v26 = (int8x16_t)vshlq_u16(v9[3], v15);
      v27 = (int8x16_t)vshlq_u16(v9[4], v15);
      v6.i64[0] = v23.i64[0];
    }
    else
    {
      v22 = 0;
      *(int16x4_t *)v6.i8 = vdup_n_s16(1 << (a2[3] - 1));
      v26 = 0uLL;
      v25 = 0uLL;
      v24 = 0uLL;
      v23 = 0uLL;
      v27 = 0uLL;
    }
    v28 = *(_QWORD *)a2;
    v29 = *(_DWORD *)(*(_QWORD *)a2 + 4);
    v30 = (unint64_t)**(unsigned int **)a2 << 32;
    v31 = *(_BYTE **)(*(_QWORD *)a2 + 8);
    v33 = *(_DWORD *)(*(_QWORD *)a2 + 16);
    v32 = *(_DWORD *)(*(_QWORD *)a2 + 20);
    if ((int)a2[11] >= 8)
      break;
LABEL_308:
    *(_DWORD *)v28 = HIDWORD(v30);
    *(_DWORD *)(v28 + 4) = v29;
    *(_QWORD *)(v28 + 8) = v31;
    v9 = a1;
    v8 = v208 + 1;
    a1 = (uint16x8_t *)((char *)a1 + a4);
    *(_DWORD *)(v28 + 16) = v33;
    *(_DWORD *)(v28 + 20) = v32;
    if (v208 + 1 == a3)
      return 0;
  }
  v34 = 0;
  v35 = a2[10];
  v36 = a1 + 4;
  v37 = (int8x16_t)vshlq_u16(*a1, v15);
  v38 = (int8x16_t)vshlq_u16(a1[1], v15);
  v39 = (int8x16_t)vshlq_u16(a1[2], v15);
  v40 = (int8x16_t)vshlq_u16(a1[3], v15);
  v215 = v9;
  v214 = v35;
  while (1)
  {
    if (v9)
    {
      if (v35 == 3)
      {
        v6.i64[1] = v23.i64[0];
        v41 = (int16x8_t)vextq_s8(v23, v24, 8uLL);
        v42 = (int16x8_t)vextq_s8(v24, v25, 8uLL);
        v43 = (int16x8_t)vextq_s8(v25, v26, 8uLL);
        v44 = v6;
        v45 = vextq_s8(v26, v26, 8uLL).u64[0];
        goto LABEL_24;
      }
      if (v35 == 2)
      {
        v44 = (int16x8_t)v23;
        v41 = (int16x8_t)v24;
        v42 = (int16x8_t)v25;
        v43 = (int16x8_t)v26;
        goto LABEL_25;
      }
      if (v35 != 1)
      {
        v46 = (int16x8_t)vextq_s8(v23, v24, 8uLL);
        v47 = (int16x8_t)vextq_s8(v24, v25, 8uLL);
        v48 = (int16x8_t)vextq_s8(v25, v26, 8uLL);
        v49 = (int16x8_t)vextq_s8(v26, v27, 8uLL);
        switch(v35)
        {
          case 6u:
            v50 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v37, (uint16x8_t)v23), v46);
            v51 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v38, (uint16x8_t)v24), v47);
            v52 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v39, (uint16x8_t)v25), v48);
            v54 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v40, (uint16x8_t)v26), v49);
            break;
          case 5u:
            v53 = (int16x8_t)vhsubq_u16((uint16x8_t)v49, (uint16x8_t)v26);
            v50 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v46, (uint16x8_t)v23), (int16x8_t)v37);
            v51 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v47, (uint16x8_t)v24), (int16x8_t)v38);
            v52 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v48, (uint16x8_t)v25), (int16x8_t)v39);
LABEL_21:
            v54 = (int8x16_t)vaddq_s16(v53, (int16x8_t)v40);
            break;
          case 4u:
            v50 = (int8x16_t)vaddq_s16(vsubq_s16(v46, (int16x8_t)v23), (int16x8_t)v37);
            v51 = (int8x16_t)vaddq_s16(vsubq_s16(v47, (int16x8_t)v24), (int16x8_t)v38);
            v52 = (int8x16_t)vaddq_s16(vsubq_s16(v48, (int16x8_t)v25), (int16x8_t)v39);
            v53 = vsubq_s16(v49, (int16x8_t)v26);
            goto LABEL_21;
          default:
            v50 = (int8x16_t)vhaddq_u16((uint16x8_t)v37, (uint16x8_t)v46);
            v51 = (int8x16_t)vhaddq_u16((uint16x8_t)v38, (uint16x8_t)v47);
            v52 = (int8x16_t)vhaddq_u16((uint16x8_t)v39, (uint16x8_t)v48);
            v54 = (int8x16_t)vhaddq_u16((uint16x8_t)v40, (uint16x8_t)v49);
            break;
        }
        v6.i64[1] = v50.i64[0];
        v41 = (int16x8_t)vextq_s8(v50, v51, 8uLL);
        v42 = (int16x8_t)vextq_s8(v51, v52, 8uLL);
        v43 = (int16x8_t)vextq_s8(v52, v54, 8uLL);
        v44 = v6;
        v45 = vextq_s8(v54, v54, 8uLL).u64[0];
        goto LABEL_24;
      }
    }
    v6.i64[1] = v37.i64[0];
    v41 = (int16x8_t)vextq_s8(v37, v38, 8uLL);
    v42 = (int16x8_t)vextq_s8(v38, v39, 8uLL);
    v43 = (int16x8_t)vextq_s8(v39, v40, 8uLL);
    v44 = v6;
    v45 = vextq_s8(v40, v40, 8uLL).u64[0];
LABEL_24:
    v6.i64[0] = v45;
LABEL_25:
    v55 = vsubq_s16((int16x8_t)v37, v44);
    v56 = vsubq_s16((int16x8_t)v38, v41);
    v57 = vsubq_s16((int16x8_t)v39, v42);
    v58 = vsubq_s16((int16x8_t)v40, v43);
    v59 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v55)));
    v60 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v56)));
    v61 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v57)));
    v62 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v58)));
    if (!(_DWORD)a6)
      break;
    ++v10[v59.i16[0]];
    ++v11[v59.i16[1]];
    ++v12[v59.i16[2]];
    ++v10[v59.i16[4]];
    ++v11[v59.i16[5]];
    ++v12[v59.i16[6]];
    ++v10[v60.i16[0]];
    ++v11[v60.i16[1]];
    ++v12[v60.i16[2]];
    ++v10[v60.i16[4]];
    ++v11[v60.i16[5]];
    ++v12[v60.i16[6]];
    ++v10[v61.i16[0]];
    ++v11[v61.i16[1]];
    ++v12[v61.i16[2]];
    ++v10[v61.i16[4]];
    ++v11[v61.i16[5]];
    ++v12[v61.i16[6]];
    ++v10[v62.i16[0]];
    v63.i64[0] = v62.u16[1];
    v63.i64[1] = v62.u16[5];
    v64 = vshrq_n_s64(vshlq_n_s64(v63, 0x30uLL), 0x30uLL);
    v65 = v64.i64[1];
    ++v11[v64.i64[0]];
    v63.i64[0] = v62.u16[2];
    v63.i64[1] = v62.u16[6];
    v66 = vshrq_n_s64(vshlq_n_s64(v63, 0x30uLL), 0x30uLL);
    ++v12[v66.i64[0]];
    ++v10[v62.i16[4]];
    ++v11[v65];
    ++v12[v66.i64[1]];
LABEL_300:
    v198 = a2[11] / 8;
    if (v34 < v198 - 1)
    {
      if (v9)
      {
        if (v34 >= v198 - 2)
        {
          v200 = v22 + 3;
          v199 = (uint16x8_t)v27;
        }
        else
        {
          v199 = v22[3];
          v200 = v22 + 4;
        }
        v24 = (int8x16_t)vshlq_u16(*v22, v15);
        v25 = (int8x16_t)vshlq_u16(v22[1], v15);
        v26 = (int8x16_t)vshlq_u16(v22[2], v15);
        v23 = v27;
        v27 = (int8x16_t)vshlq_u16(v199, v15);
        v22 = v200;
      }
      v201 = *v36;
      v202 = v36[1];
      v203 = v36[2];
      v204 = v36[3];
      v36 += 4;
      v37 = (int8x16_t)vshlq_u16(v201, v15);
      v38 = (int8x16_t)vshlq_u16(v202, v15);
      v39 = (int8x16_t)vshlq_u16(v203, v15);
      v40 = (int8x16_t)vshlq_u16(v204, v15);
    }
    if (++v34 >= v198)
      goto LABEL_308;
  }
  if (v32 > 95)
  {
LABEL_30:
    v70 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v59), v19), (int8x16_t)vsraq_n_s16(v55, v55, 0xFuLL));
    v71 = (unsigned __int16 *)&v13[v59.i16[0]];
    v72 = v29 + *v71;
    v73 = ((unint64_t)v71[1] << -(char)(v29 + *v71)) | v30;
    LODWORD(v71) = (unsigned __int16)(v59.i16[0] - 1);
    v74 = v71 > 0xE;
    if (v71 <= 0xE)
      v75 = v72 + v59.u16[0];
    else
      v75 = v72;
    if (v74)
      v76 = v73;
    else
      v76 = v73 | ((unint64_t)v70.u16[0] << -(char)(v72 + v59.i8[0]));
    v77 = (int32x2_t)__PAIR64__(v32, v33);
    if (v75 < 8)
    {
      v78 = v75;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v76);
        if (HIBYTE(v76) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v76 <<= 8;
        v78 = v75 - 8;
        v74 = v75 <= 15;
        v75 -= 8;
      }
      while (!v74);
    }
    v79 = (unsigned __int16 *)&v14[v59.i16[1]];
    v80 = v78 + *v79;
    v81 = ((unint64_t)v79[1] << -(char)v80) | v76;
    v82 = v80 + v59.u16[1];
    if ((unsigned __int16)(v59.i16[1] - 1) <= 0xEu)
      v81 |= (unint64_t)v70.u16[1] << -(char)(v80 + v59.i8[2]);
    else
      v82 = v80;
    if (v82 < 8)
    {
      v83 = v82;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v81);
        if (HIBYTE(v81) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v81 <<= 8;
        v83 = v82 - 8;
        v74 = v82 <= 15;
        v82 -= 8;
      }
      while (!v74);
    }
    v84 = (unsigned __int16 *)&v16[v59.i16[2]];
    v85 = v83 + *v84;
    v86 = ((unint64_t)v84[1] << -(char)v85) | v81;
    v87 = v85 + v59.u16[2];
    if ((unsigned __int16)(v59.i16[2] - 1) <= 0xEu)
      v86 |= (unint64_t)v70.u16[2] << -(char)(v85 + v59.i8[4]);
    else
      v87 = v85;
    if (v87 < 8)
    {
      v88 = v87;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v86);
        if (HIBYTE(v86) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v86 <<= 8;
        v88 = v87 - 8;
        v74 = v87 <= 15;
        v87 -= 8;
      }
      while (!v74);
    }
    v89 = (unsigned __int16 *)&v13[v59.i16[4]];
    v90 = v88 + *v89;
    v91 = ((unint64_t)v89[1] << -(char)v90) | v86;
    v92 = v90 + v59.u16[4];
    if ((unsigned __int16)(v59.i16[4] - 1) <= 0xEu)
      v91 |= (unint64_t)v70.u16[4] << -(char)(v90 + v59.i8[8]);
    else
      v92 = v90;
    if (v92 < 8)
    {
      v93 = v92;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v91);
        if (HIBYTE(v91) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v91 <<= 8;
        v93 = v92 - 8;
        v74 = v92 <= 15;
        v92 -= 8;
      }
      while (!v74);
    }
    v94 = (unsigned __int16 *)&v14[v59.i16[5]];
    v95 = v93 + *v94;
    v96 = ((unint64_t)v94[1] << -(char)v95) | v91;
    v97 = v95 + v59.u16[5];
    if ((unsigned __int16)(v59.i16[5] - 1) <= 0xEu)
      v96 |= (unint64_t)v70.u16[5] << -(char)(v95 + v59.i8[10]);
    else
      v97 = v95;
    if (v97 < 8)
    {
      v98 = v97;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v96);
        if (HIBYTE(v96) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v96 <<= 8;
        v98 = v97 - 8;
        v74 = v97 <= 15;
        v97 -= 8;
      }
      while (!v74);
    }
    v99 = (unsigned __int16 *)&v16[v59.i16[6]];
    v100 = v98 + *v99;
    v101 = ((unint64_t)v99[1] << -(char)v100) | v96;
    v102 = v100 + v59.u16[6];
    if ((unsigned __int16)(v59.i16[6] - 1) <= 0xEu)
      v101 |= (unint64_t)v70.u16[6] << -(char)(v100 + v59.i8[12]);
    else
      v102 = v100;
    if (v102 < 8)
    {
      v103 = v102;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v101);
        if (HIBYTE(v101) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v101 <<= 8;
        v103 = v102 - 8;
        v74 = v102 <= 15;
        v102 -= 8;
      }
      while (!v74);
    }
    v104 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v60), v19), (int8x16_t)vsraq_n_s16(v56, v56, 0xFuLL));
    v105 = (unsigned __int16 *)&v13[v60.i16[0]];
    v106 = v103 + *v105;
    v107 = ((unint64_t)v105[1] << -(char)v106) | v101;
    v108 = v106 + v60.u16[0];
    if ((unsigned __int16)(v60.i16[0] - 1) <= 0xEu)
      v107 |= (unint64_t)v104.u16[0] << -(char)(v106 + v60.i8[0]);
    else
      v108 = v106;
    if (v108 < 8)
    {
      v109 = v108;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v107);
        if (HIBYTE(v107) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v107 <<= 8;
        v109 = v108 - 8;
        v74 = v108 <= 15;
        v108 -= 8;
      }
      while (!v74);
    }
    v110 = (unsigned __int16 *)&v14[v60.i16[1]];
    v111 = v109 + *v110;
    v112 = ((unint64_t)v110[1] << -(char)v111) | v107;
    v113 = v111 + v60.u16[1];
    if ((unsigned __int16)(v60.i16[1] - 1) <= 0xEu)
      v112 |= (unint64_t)v104.u16[1] << -(char)(v111 + v60.i8[2]);
    else
      v113 = v111;
    if (v113 < 8)
    {
      v114 = v113;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v112);
        if (HIBYTE(v112) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v112 <<= 8;
        v114 = v113 - 8;
        v74 = v113 <= 15;
        v113 -= 8;
      }
      while (!v74);
    }
    v115 = (unsigned __int16 *)&v16[v60.i16[2]];
    v116 = v114 + *v115;
    v117 = ((unint64_t)v115[1] << -(char)v116) | v112;
    v118 = v116 + v60.u16[2];
    if ((unsigned __int16)(v60.i16[2] - 1) <= 0xEu)
      v117 |= (unint64_t)v104.u16[2] << -(char)(v116 + v60.i8[4]);
    else
      v118 = v116;
    if (v118 < 8)
    {
      v119 = v118;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v117);
        if (HIBYTE(v117) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v117 <<= 8;
        v119 = v118 - 8;
        v74 = v118 <= 15;
        v118 -= 8;
      }
      while (!v74);
    }
    v120 = (unsigned __int16 *)&v13[v60.i16[4]];
    v121 = v119 + *v120;
    v122 = ((unint64_t)v120[1] << -(char)v121) | v117;
    v123 = v121 + v60.u16[4];
    if ((unsigned __int16)(v60.i16[4] - 1) <= 0xEu)
      v122 |= (unint64_t)v104.u16[4] << -(char)(v121 + v60.i8[8]);
    else
      v123 = v121;
    if (v123 < 8)
    {
      v124 = v123;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v122);
        if (HIBYTE(v122) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v77 = vadd_s32(v77, v21[142]);
        }
        else
        {
          v77 = vadd_s32(v77, v20[126]);
          ++v31;
        }
        v122 <<= 8;
        v124 = v123 - 8;
        v74 = v123 <= 15;
        v123 -= 8;
      }
      while (!v74);
    }
    v125 = (unsigned __int16 *)&v14[v60.i16[5]];
    v126 = v124 + *v125;
    v127 = ((unint64_t)v125[1] << -(char)v126) | v122;
    v128 = v126 + v60.u16[5];
    if ((unsigned __int16)(v60.i16[5] - 1) <= 0xEu)
      v127 |= (unint64_t)v104.u16[5] << -(char)(v126 + v60.i8[10]);
    else
      v128 = v126;
    v33 = v77.i32[0];
    v32 = v77.i32[1];
    if (v128 < 8)
    {
      v129 = v128;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v127);
        if (HIBYTE(v127) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v127 <<= 8;
        v129 = v128 - 8;
        v74 = v128 <= 15;
        v128 -= 8;
      }
      while (!v74);
    }
    v130 = (unsigned __int16 *)&v16[v60.i16[6]];
    v131 = v129 + *v130;
    v132 = ((unint64_t)v130[1] << -(char)v131) | v127;
    v133 = v131 + v60.u16[6];
    if ((unsigned __int16)(v60.i16[6] - 1) <= 0xEu)
      v132 |= (unint64_t)v104.u16[6] << -(char)(v131 + v60.i8[12]);
    else
      v133 = v131;
    if (v133 < 8)
    {
      v134 = v133;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v132);
        if (HIBYTE(v132) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v132 <<= 8;
        v134 = v133 - 8;
        v74 = v133 <= 15;
        v133 -= 8;
      }
      while (!v74);
    }
    v135 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v61), v19), (int8x16_t)vsraq_n_s16(v57, v57, 0xFuLL));
    v136 = (unsigned __int16 *)&v13[v61.i16[0]];
    v137 = v134 + *v136;
    v138 = ((unint64_t)v136[1] << -(char)v137) | v132;
    v139 = v137 + v61.u16[0];
    if ((unsigned __int16)(v61.i16[0] - 1) <= 0xEu)
      v138 |= (unint64_t)v135.u16[0] << -(char)(v137 + v61.i8[0]);
    else
      v139 = v137;
    if (v139 < 8)
    {
      v140 = v139;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v138);
        if (HIBYTE(v138) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v138 <<= 8;
        v140 = v139 - 8;
        v74 = v139 <= 15;
        v139 -= 8;
      }
      while (!v74);
    }
    v141 = (unsigned __int16 *)&v14[v61.i16[1]];
    v142 = v140 + *v141;
    v143 = ((unint64_t)v141[1] << -(char)v142) | v138;
    v144 = v142 + v61.u16[1];
    if ((unsigned __int16)(v61.i16[1] - 1) <= 0xEu)
      v143 |= (unint64_t)v135.u16[1] << -(char)(v142 + v61.i8[2]);
    else
      v144 = v142;
    if (v144 < 8)
    {
      v145 = v144;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v143);
        if (HIBYTE(v143) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v143 <<= 8;
        v145 = v144 - 8;
        v74 = v144 <= 15;
        v144 -= 8;
      }
      while (!v74);
    }
    v146 = (unsigned __int16 *)&v16[v61.i16[2]];
    v147 = v145 + *v146;
    v148 = ((unint64_t)v146[1] << -(char)v147) | v143;
    v149 = v147 + v61.u16[2];
    if ((unsigned __int16)(v61.i16[2] - 1) <= 0xEu)
      v148 |= (unint64_t)v135.u16[2] << -(char)(v147 + v61.i8[4]);
    else
      v149 = v147;
    if (v149 < 8)
    {
      v150 = v149;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v148);
        if (HIBYTE(v148) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v148 <<= 8;
        v150 = v149 - 8;
        v74 = v149 <= 15;
        v149 -= 8;
      }
      while (!v74);
    }
    v151 = (unsigned __int16 *)&v13[v61.i16[4]];
    v152 = v150 + *v151;
    v153 = ((unint64_t)v151[1] << -(char)v152) | v148;
    v154 = v152 + v61.u16[4];
    if ((unsigned __int16)(v61.i16[4] - 1) <= 0xEu)
      v153 |= (unint64_t)v135.u16[4] << -(char)(v152 + v61.i8[8]);
    else
      v154 = v152;
    if (v154 < 8)
    {
      v155 = v154;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v153);
        if (HIBYTE(v153) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v153 <<= 8;
        v155 = v154 - 8;
        v74 = v154 <= 15;
        v154 -= 8;
      }
      while (!v74);
    }
    v156 = (unsigned __int16 *)&v14[v61.i16[5]];
    v157 = v155 + *v156;
    v158 = ((unint64_t)v156[1] << -(char)v157) | v153;
    v159 = v157 + v61.u16[5];
    if ((unsigned __int16)(v61.i16[5] - 1) <= 0xEu)
      v158 |= (unint64_t)v135.u16[5] << -(char)(v157 + v61.i8[10]);
    else
      v159 = v157;
    if (v159 < 8)
    {
      v160 = v159;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v158);
        if (HIBYTE(v158) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v158 <<= 8;
        v160 = v159 - 8;
        v74 = v159 <= 15;
        v159 -= 8;
      }
      while (!v74);
    }
    v161 = (unsigned __int16 *)&v16[v61.i16[6]];
    v162 = v160 + *v161;
    v163 = ((unint64_t)v161[1] << -(char)v162) | v158;
    v164 = v162 + v61.u16[6];
    if ((unsigned __int16)(v61.i16[6] - 1) <= 0xEu)
      v163 |= (unint64_t)v135.u16[6] << -(char)(v162 + v61.i8[12]);
    else
      v164 = v162;
    if (v164 < 8)
    {
      v165 = v164;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v163);
        if (HIBYTE(v163) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v163 <<= 8;
        v165 = v164 - 8;
        v74 = v164 <= 15;
        v164 -= 8;
      }
      while (!v74);
    }
    v166 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v62), v19), (int8x16_t)vsraq_n_s16(v58, v58, 0xFuLL));
    v167 = (unsigned __int16 *)&v13[v62.i16[0]];
    v168 = v165 + *v167;
    v169 = ((unint64_t)v167[1] << -(char)v168) | v163;
    v170 = v168 + v62.u16[0];
    if ((unsigned __int16)(v62.i16[0] - 1) <= 0xEu)
      v169 |= (unint64_t)v166.u16[0] << -(char)(v168 + v62.i8[0]);
    else
      v170 = v168;
    if (v170 < 8)
    {
      v171 = v170;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v169);
        if (HIBYTE(v169) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v169 <<= 8;
        v171 = v170 - 8;
        v74 = v170 <= 15;
        v170 -= 8;
      }
      while (!v74);
    }
    v172 = (unsigned __int16 *)&v14[v62.i16[1]];
    v173 = v171 + *v172;
    v174 = ((unint64_t)v172[1] << -(char)v173) | v169;
    v175 = v173 + v62.u16[1];
    if ((unsigned __int16)(v62.i16[1] - 1) <= 0xEu)
      v174 |= (unint64_t)v166.u16[1] << -(char)(v173 + v62.i8[2]);
    else
      v175 = v173;
    if (v175 < 8)
    {
      v176 = v175;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v174);
        if (HIBYTE(v174) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v174 <<= 8;
        v176 = v175 - 8;
        v74 = v175 <= 15;
        v175 -= 8;
      }
      while (!v74);
    }
    v177 = (unsigned __int16 *)&v16[v62.i16[2]];
    v178 = v176 + *v177;
    v179 = ((unint64_t)v177[1] << -(char)v178) | v174;
    v180 = v178 + v62.u16[2];
    if ((unsigned __int16)(v62.i16[2] - 1) <= 0xEu)
      v179 |= (unint64_t)v166.u16[2] << -(char)(v178 + v62.i8[4]);
    else
      v180 = v178;
    if (v180 < 8)
    {
      v181 = v180;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v179);
        if (HIBYTE(v179) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v179 <<= 8;
        v181 = v180 - 8;
        v74 = v180 <= 15;
        v180 -= 8;
      }
      while (!v74);
    }
    v182 = (unsigned __int16 *)&v13[v62.i16[4]];
    v183 = v181 + *v182;
    v184 = ((unint64_t)v182[1] << -(char)v183) | v179;
    v185 = v183 + v62.u16[4];
    if ((unsigned __int16)(v62.i16[4] - 1) <= 0xEu)
      v184 |= (unint64_t)v166.u16[4] << -(char)(v183 + v62.i8[8]);
    else
      v185 = v183;
    if (v185 < 8)
    {
      v186 = v185;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v184);
        if (HIBYTE(v184) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v184 <<= 8;
        v186 = v185 - 8;
        v74 = v185 <= 15;
        v185 -= 8;
      }
      while (!v74);
    }
    v187 = (unsigned __int16 *)&v14[v62.i16[5]];
    v188 = v186 + *v187;
    v189 = ((unint64_t)v187[1] << -(char)v188) | v184;
    v190 = v188 + v62.u16[5];
    if ((unsigned __int16)(v62.i16[5] - 1) <= 0xEu)
      v189 |= (unint64_t)v166.u16[5] << -(char)(v188 + v62.i8[10]);
    else
      v190 = v188;
    if (v190 < 8)
    {
      v191 = v190;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v189);
        if (HIBYTE(v189) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v189 <<= 8;
        v191 = v190 - 8;
        v74 = v190 <= 15;
        v190 -= 8;
      }
      while (!v74);
    }
    v192 = (unsigned __int16 *)&v16[v62.i16[6]];
    v193 = v191 + *v192;
    v194 = ((unint64_t)v192[1] << -(char)v193) | v189;
    v195 = (unsigned __int16)(v62.i16[6] - 1);
    v196 = v195 > 0xE;
    if (v195 <= 0xE)
      v197 = v193 + v62.u16[6];
    else
      v197 = v193;
    if (v196)
      v30 = v194;
    else
      v30 = v194 | ((unint64_t)v166.u16[6] << -(char)(v193 + v62.i8[12]));
    if (v197 < 8)
    {
      v29 = v197;
    }
    else
    {
      do
      {
        *v31 = HIBYTE(v30);
        if (HIBYTE(v30) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v30 <<= 8;
        v29 = v197 - 8;
        v74 = v197 <= 15;
        v197 -= 8;
      }
      while (!v74);
    }
    goto LABEL_300;
  }
  v216 = v59;
  v217 = v56;
  v218 = v60;
  v219 = v57;
  v220 = v61;
  v221 = v58;
  v222 = v62;
  v223 = v40;
  v224 = v39;
  v225 = v38;
  v226 = v37;
  v227 = v36;
  v228 = v34;
  v229 = v23;
  v230 = v26;
  v231 = v25;
  v232 = v24;
  v233 = v6;
  v234 = v27;
  v235 = v22;
  v67 = v12;
  v68 = a6;
  v32 = *(_DWORD *)(v28 + 64);
  v69 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, int32x2_t *, int32x2_t *))(v28 + 40))(*(_QWORD *)(v28 + 24), v31 - *(_QWORD *)(v28 + 24), *(_QWORD *)(v28 + 32), v20, v21);
  if (!v69)
  {
    v31 = *(_BYTE **)(v28 + 24);
    a6 = v68;
    v12 = v67;
    v13 = v210;
    v16 = v211;
    v14 = v213;
    v15 = v212;
    v17.i64[0] = 0x10001000100010;
    v17.i64[1] = 0x10001000100010;
    v18.i64[0] = 0x1000100010001;
    v18.i64[1] = 0x1000100010001;
    v19.i64[0] = -1;
    v19.i64[1] = -1;
    v20 = (int32x2_t *)&unk_20627B000;
    v21 = (int32x2_t *)&unk_20627B000;
    v9 = v215;
    v22 = v235;
    v6 = v233;
    v27 = v234;
    v25 = v231;
    v24 = v232;
    v23 = v229;
    v26 = v230;
    v34 = v228;
    LOBYTE(v35) = v214;
    v36 = v227;
    v38 = v225;
    v37 = v226;
    v40 = v223;
    v39 = v224;
    v58 = v221;
    v62 = v222;
    v57 = v219;
    v61 = v220;
    v56 = v217;
    v60 = v218;
    v59 = v216;
    goto LABEL_30;
  }
  aj_log_error(0, "Output callback returned error code %d.", v69);
  return 9;
}

uint64_t do_compress_lossless(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, int a7, int a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t result;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  __int16 v51;
  int v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  __int16 v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  int v73;
  uint64_t v74;
  uint64_t v76;

  if (a4 >= 1)
  {
    v10 = a1;
    v11 = 0;
    v12 = 0;
    v74 = a4;
    v13 = a1;
    v73 = a7;
    do
    {
      v76 = v11;
      if (*(_DWORD *)(a2 + 8) == 2)
      {
        if (a7)
        {
          v13 = *(_QWORD *)(a3 + 8 * (v11 & 1));
          if (*(_DWORD *)(a2 + 16) * a5 >= 1)
          {
            v14 = 0;
            v15 = 2 * (*(_DWORD *)(a2 + 16) * a5);
            do
            {
              *(_WORD *)(v13 + v14) = *(unsigned __int16 *)(v10 + v14) >> a7;
              v14 += 2;
            }
            while (v15 != v14);
          }
        }
        if (!*(_DWORD *)(a2 + 40))
          return 3;
        if (v12)
          v16 = *(_DWORD *)(a2 + 40);
        else
          v16 = 1;
        v17 = *(_DWORD *)(a2 + 44);
        v18 = *(_DWORD *)(a2 + 16);
        if (v18 < 1)
        {
          LODWORD(v19) = 0;
          LOWORD(v20) = 0;
        }
        else
        {
          v69 = *(_DWORD *)(a2 + 44);
          v19 = 0;
          LOWORD(v20) = 0;
          do
          {
            v21 = *(_DWORD *)(a2 + 4 * v19 + 24);
            if (v21 != 0x7FFFFFFF)
            {
              v22 = v19 + v21;
              if (v12)
              {
                v23 = v22;
                LOWORD(v20) = *(_WORD *)(v12 + 2 * v22);
              }
              else
              {
                v20 = 1 << (*(_DWORD *)(a2 + 12) - 1);
                v23 = v22;
              }
              v24 = *(unsigned __int16 *)(v13 + 2 * v23);
              LOWORD(v25) = v24 - v20;
              if (a9)
              {
                v25 = (__int16)v25;
                if ((v25 & 0x8000u) != 0)
                  v25 = -(__int16)v25;
                v26 = 32 - __clz(v25);
                if (v24 == (unsigned __int16)v20)
                  v27 = 0;
                else
                  v27 = v26;
                v28 = a2 + 68 * (int)v23 + 4 * v27;
                ++*(_DWORD *)(v28 + 148);
              }
              else
              {
                result = encode_symbol((unsigned int **)a2, (__int16)v25, v22, a8);
                if ((_DWORD)result)
                  return result;
              }
            }
            ++v19;
          }
          while (v19 < *(int *)(a2 + 16));
          v17 = v69;
        }
        v43 = v18 * v17;
        if ((int)v19 < v43)
        {
          do
          {
            v44 = *(_DWORD *)(a2 + 16);
            v45 = *(_DWORD *)(a2 + 4 * ((int)v19 % v44) + 24);
            if (v45 != 0x7FFFFFFF)
            {
              v46 = v19 + v45;
              v47 = v46 - v44;
              switch(v16)
              {
                case 1:
                  LOWORD(v20) = *(_WORD *)(v13 + 2 * v47);
                  break;
                case 2:
                  LOWORD(v20) = *(_WORD *)(v12 + 2 * v46);
                  break;
                case 3:
                  LOWORD(v20) = *(_WORD *)(v12 + 2 * v47);
                  break;
                case 4:
                  LOWORD(v20) = *(_WORD *)(v12 + 2 * v46) + *(_WORD *)(v13 + 2 * v47) - *(_WORD *)(v12 + 2 * v47);
                  break;
                case 5:
                  v48 = *(unsigned __int16 *)(v13 + 2 * v47);
                  v49 = *(unsigned __int16 *)(v12 + 2 * v46);
                  goto LABEL_58;
                case 6:
                  v48 = *(unsigned __int16 *)(v12 + 2 * v46);
                  v49 = *(unsigned __int16 *)(v13 + 2 * v47);
LABEL_58:
                  v20 = v48 + ((v49 - *(unsigned __int16 *)(v12 + 2 * v47)) >> 1);
                  break;
                case 7:
                  v20 = (*(unsigned __int16 *)(v12 + 2 * v46) + *(unsigned __int16 *)(v13 + 2 * v47)) >> 1;
                  break;
                default:
                  break;
              }
              v50 = *(unsigned __int16 *)(v13 + 2 * v46);
              v51 = v50 - v20;
              v52 = v46 % v44;
              if (a9)
              {
                v53 = v51;
                if (v51 < 0)
                  v53 = -v51;
                v54 = 32 - __clz(v53);
                if (v50 == (unsigned __int16)v20)
                  v54 = 0;
                v55 = a2 + 68 * v52 + 4 * v54;
                ++*(_DWORD *)(v55 + 148);
              }
              else
              {
                result = encode_symbol((unsigned int **)a2, v51, v52, a8);
                if ((_DWORD)result)
                  return result;
              }
            }
            LODWORD(v19) = v19 + 1;
          }
          while (v43 != (_DWORD)v19);
        }
      }
      else
      {
        if (!*(_DWORD *)(a2 + 40))
          return 3;
        if (v12)
          v30 = *(_DWORD *)(a2 + 40);
        else
          v30 = 1;
        v31 = *(_DWORD *)(a2 + 44);
        v32 = *(_DWORD *)(a2 + 16);
        if (v32 < 1)
        {
          LODWORD(v33) = 0;
          LOWORD(v34) = 0;
        }
        else
        {
          v70 = *(_DWORD *)(a2 + 44);
          v33 = 0;
          LOWORD(v34) = 0;
          do
          {
            v35 = *(_DWORD *)(a2 + 4 * v33 + 24);
            if (v35 != 0x7FFFFFFF)
            {
              v36 = v33 + v35;
              if (v12)
              {
                v37 = v36;
                LOWORD(v34) = *(unsigned __int8 *)(v12 + v36);
              }
              else
              {
                v34 = 1 << (*(_DWORD *)(a2 + 12) - 1);
                v37 = v36;
              }
              v38 = *(unsigned __int8 *)(v13 + v37);
              LOWORD(v39) = v38 - v34;
              if (a9)
              {
                v39 = (__int16)v39;
                if ((v39 & 0x8000u) != 0)
                  v39 = -(__int16)v39;
                v40 = 32 - __clz(v39);
                if (v38 == (unsigned __int16)v34)
                  v41 = 0;
                else
                  v41 = v40;
                v42 = a2 + 68 * (int)v37 + 4 * v41;
                ++*(_DWORD *)(v42 + 148);
              }
              else
              {
                result = encode_symbol((unsigned int **)a2, (__int16)v39, v36, a8);
                if ((_DWORD)result)
                  return result;
              }
            }
            ++v33;
          }
          while (v33 < *(int *)(a2 + 16));
          v31 = v70;
        }
        v56 = v32 * v31;
        if ((int)v33 < v56)
        {
          do
          {
            v57 = *(_DWORD *)(a2 + 16);
            v58 = *(_DWORD *)(a2 + 4 * ((int)v33 % v57) + 24);
            if (v58 != 0x7FFFFFFF)
            {
              v59 = v33 + v58;
              v60 = v59 - v57;
              switch(v30)
              {
                case 1:
                  LOWORD(v34) = *(unsigned __int8 *)(v13 + v60);
                  break;
                case 2:
                  LOWORD(v34) = *(unsigned __int8 *)(v12 + v59);
                  break;
                case 3:
                  LOWORD(v34) = *(unsigned __int8 *)(v12 + v60);
                  break;
                case 4:
                  LOWORD(v34) = *(unsigned __int8 *)(v12 + v59)
                              + *(unsigned __int8 *)(v13 + v60)
                              - *(unsigned __int8 *)(v12 + v60);
                  break;
                case 5:
                  v61 = *(unsigned __int8 *)(v13 + v60);
                  v62 = *(unsigned __int8 *)(v12 + v59);
                  goto LABEL_79;
                case 6:
                  v61 = *(unsigned __int8 *)(v12 + v59);
                  v62 = *(unsigned __int8 *)(v13 + v60);
LABEL_79:
                  v34 = v61 + ((v62 - *(unsigned __int8 *)(v12 + v60)) >> 1);
                  break;
                case 7:
                  v34 = (*(unsigned __int8 *)(v12 + v59) + *(unsigned __int8 *)(v13 + v60)) >> 1;
                  break;
                default:
                  break;
              }
              v63 = *(unsigned __int8 *)(v13 + v59);
              v64 = v63 - v34;
              v65 = v59 % v57;
              if (a9)
              {
                v66 = v64;
                if (v64 < 0)
                  v66 = -v64;
                v67 = 32 - __clz(v66);
                if (v63 == (unsigned __int16)v34)
                  v67 = 0;
                v68 = a2 + 68 * v65 + 4 * v67;
                ++*(_DWORD *)(v68 + 148);
              }
              else
              {
                result = encode_symbol((unsigned int **)a2, v64, v65, a8);
                if ((_DWORD)result)
                  return result;
              }
            }
            LODWORD(v33) = v33 + 1;
          }
          while (v56 != (_DWORD)v33);
        }
      }
      a7 = v73;
      v12 = v13;
      v13 += a6;
      v11 = v76 + 1;
      v10 += a6;
    }
    while (v76 + 1 != v74);
  }
  return 0;
}

uint64_t encodeWriteHuffTable(uint64_t *a1, int a2)
{
  uint8x16_t v2;
  uint16x8_t v3;
  uint16x8_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  int v12;

  v2 = *(uint8x16_t *)&a1[2 * a2 + 6];
  v3 = vmovl_high_u8(v2);
  v4 = vmovl_u8(*(uint8x8_t *)v2.i8);
  v4.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v4.i8, *(uint16x4_t *)v3.i8), (int32x4_t)vaddl_high_u16(v4, v3)));
  v5 = v4.u32[0];
  if (v4.i32[0] > 0x11u)
    return 1;
  v9 = *a1;
  result = aj_ostream_write_bytes(*a1, 65476, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(v9, (int)v5 + 19, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(v9, a2, 1);
      if (!(_DWORD)result)
      {
        v10 = 0;
        while (1)
        {
          result = aj_ostream_write_bytes(v9, *((unsigned __int8 *)&a1[2 * a2 + 6] + v10), 1);
          if ((_DWORD)result)
            break;
          if (++v10 == 16)
          {
            if (!(_DWORD)v5)
              return 0;
            v11 = (unsigned __int8 *)a1 + 17 * a2 + 96;
            do
            {
              v12 = *v11++;
              result = aj_ostream_write_bytes(v9, v12, 1);
              if ((_DWORD)result)
                break;
              --v5;
            }
            while (v5);
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t encode_symbol(unsigned int **a1, int a2, int a3, int a4)
{
  int32x2_t *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t result;
  unsigned int v16;
  unsigned int v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  unsigned int v21;
  __int32 v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  _BYTE *v26;
  _BYTE *v27;
  int v28;

  v5 = (int32x2_t *)*a1;
  v6 = a3;
  if (a2 >= 0)
    v7 = a2;
  else
    v7 = -a2;
  v8 = __clz(v7);
  if (a2)
    v9 = v8;
  else
    v9 = 32;
  v10 = 32 - v9;
  if (a4)
    v6 = 0;
  v11 = (uint64_t)a1 + 68 * v6 + 4 * v10;
  v12 = *(unsigned __int16 *)(v11 + 352);
  v13 = *(unsigned __int16 *)(v11 + 354);
  if (v5[2].i32[1] >= 9 && (v14 = v5->i32[1] + v12, v14 < 33))
  {
    v16 = v5->i32[0] | (v13 << -(char)v14);
    v5->i32[0] = v16;
    v5->i32[1] = v14;
    if (v14 >= 8)
    {
      do
      {
        v17 = HIBYTE(v16);
        v18 = (_BYTE *)v5[1];
        v5[1] = (int32x2_t)(v18 + 1);
        *v18 = v17;
        v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
        if (v17 == 255)
        {
          v19 = (_BYTE *)v5[1];
          v5[1] = (int32x2_t)(v19 + 1);
          *v19 = 0;
          v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
        }
        v20 = v5->i32[1];
        v16 = v5->i32[0] << 8;
        v5->i32[0] = v16;
        v5->i32[1] = v20 - 8;
      }
      while (v20 > 15);
    }
  }
  else
  {
    result = aj_ostream_write(*a1, v13, v12);
    if ((_DWORD)result)
      return result;
  }
  if ((v9 - 17) <= 0xE)
  {
    v21 = (__int16)(a2 + (a2 >> 15)) & ~(-1 << v10);
    if (v5[2].i32[1] >= 9 && (v22 = v5->i32[1], v23 = v22 + v10, (int)(v22 + v10) < 33))
    {
      v24 = v5->i32[0] | (v21 << (v9 - v22));
      v5->i32[0] = v24;
      v5->i32[1] = v23;
      if (v23 >= 8)
      {
        do
        {
          v25 = HIBYTE(v24);
          v26 = (_BYTE *)v5[1];
          v5[1] = (int32x2_t)(v26 + 1);
          *v26 = v25;
          v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
          if (v25 == 255)
          {
            v27 = (_BYTE *)v5[1];
            v5[1] = (int32x2_t)(v27 + 1);
            *v27 = 0;
            v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
          }
          v28 = v5->i32[1];
          v24 = v5->i32[0] << 8;
          v5->i32[0] = v24;
          v5->i32[1] = v28 - 8;
        }
        while (v28 > 15);
      }
    }
    else
    {
      result = aj_ostream_write((unsigned int *)v5, v21, v10);
      if ((_DWORD)result)
        return result;
    }
  }
  return 0;
}

uint64_t aj_block_decode_S2(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v19;
  __int16 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _WORD v27[15];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v19 = 0;
  v10 = aj_huffman_decode_val(*(_QWORD *)(a1 + 32), a2, 0, (int *)&v19 + 1);
  if ((_DWORD)v10)
  {
    v13 = v10;
    LOWORD(v14) = 0;
    memset(v27, 0, sizeof(v27));
    v26 = 0u;
    v25 = 0u;
    v24 = 0u;
    v23 = 0u;
    v22 = 0u;
    v21 = 0u;
  }
  else
  {
    v15 = HIDWORD(v19);
    LODWORD(v19) = WORD2(v19);
    SHIDWORD(v19) >>= 16;
    v16 = *a3 + (v15 >> 16);
    v14 = v16 * *(_DWORD *)(a1 + 48);
    *a3 = v16;
    v17 = aj_huffman_decode_ac_s2(a1, a2, &v20, &v19, v11, v12);
    if (!(_DWORD)v17)
      v17 = aj_huffman_decode_skip_block(*(_QWORD *)(a1 + 40), a2, v19);
    v13 = v17;
  }
  v20 = v14;
  (*(void (**)(__int16 *, uint64_t, uint64_t))(a1 + 520))(&v20, a4, a5);
  return v13;
}

uint64_t aj_block_decode_S4(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v19;
  __int16 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _WORD v27[15];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v19 = 0;
  v10 = aj_huffman_decode_val(*(_QWORD *)(a1 + 32), a2, 0, (int *)&v19 + 1);
  if ((_DWORD)v10)
  {
    v13 = v10;
    LOWORD(v14) = 0;
    memset(v27, 0, sizeof(v27));
    v26 = 0u;
    v25 = 0u;
    v24 = 0u;
    v23 = 0u;
    v22 = 0u;
    v21 = 0u;
  }
  else
  {
    v15 = HIDWORD(v19);
    LODWORD(v19) = WORD2(v19);
    SHIDWORD(v19) >>= 16;
    v16 = *a3 + (v15 >> 16);
    v14 = v16 * *(_DWORD *)(a1 + 48);
    *a3 = v16;
    v17 = aj_huffman_decode_ac_s4(a1, a2, &v20, &v19, v11, v12);
    if (!(_DWORD)v17)
      v17 = aj_huffman_decode_skip_block(*(_QWORD *)(a1 + 40), a2, v19);
    v13 = v17;
  }
  v20 = v14;
  (*(void (**)(__int16 *, uint64_t, uint64_t))(a1 + 520))(&v20, a4, a5);
  return v13;
}

uint64_t aj_block_decode_S8(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  __int16 v13;
  int v14;

  v14 = 0;
  v13 = 0;
  v10 = aj_huffman_decode_val(*(_QWORD *)(a1 + 32), a2, 0, &v14);
  if (!(_DWORD)v10)
  {
    v14 = SHIWORD(v14);
    v11 = *a3 + v14;
    v13 = (*(_WORD *)a3 + v14) * *(_WORD *)(a1 + 48);
    *a3 = v11;
    v10 = aj_huffman_decode_skip_block(*(_QWORD *)(a1 + 40), a2, 1);
  }
  (*(void (**)(__int16 *, uint64_t, uint64_t))(a1 + 520))(&v13, a4, a5);
  return v10;
}

_DWORD *aj_block_dequantize_12bit(_DWORD *result, __int16 *a2, _DWORD *a3)
{
  int v3;
  uint64_t v4;
  char v5;
  char v6;
  uint64_t i;
  _DWORD *v8;
  __int16 *v9;
  int *v10;
  unint64_t v11;
  int v12;

  v3 = result[178];
  switch(v3)
  {
    case 1:
      for (i = 0; i != 64; ++i)
        a3[i] = (unint64_t)((int)result[i + 180] * (uint64_t)a2[i] + 2048) >> 12;
      break;
    case 2:
      v8 = a3 + 2;
      v9 = a2 + 2;
      v10 = result + 183;
      v11 = -8;
      do
      {
        *(v8 - 2) = *(v10 - 3) * *(v9 - 2);
        *(v8 - 1) = *(v10 - 2) * *(v9 - 1);
        *v8 = *(v10 - 1) * *v9;
        v12 = *v10;
        v10 += 8;
        v11 += 8;
        v8[1] = v12 * v9[1];
        v8 += 8;
        v9 += 8;
      }
      while (v11 < 0x11);
      break;
    case 4:
      v4 = 0;
      v5 = 1;
      do
      {
        a3[v4] = result[v4 + 180] * a2[v4];
        v6 = v5;
        a3[v4 | 1] = result[(v4 | 1) + 180] * a2[v4 | 1];
        v4 = 8;
        v5 = 0;
      }
      while ((v6 & 1) != 0);
      break;
    default:
      *a3 = result[180] * *a2;
      break;
  }
  return result;
}

uint64_t aj_block_decode_12bit(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int16 v14;
  int v15;
  uint64_t v16;
  unsigned int v18;
  int v19;
  _DWORD v20[64];
  __int16 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[30];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v19 = 0;
  v10 = aj_huffman_decode_val(*(_QWORD *)(a1 + 32), a2, 0, &v19);
  if ((_DWORD)v10)
  {
    v13 = v10;
    v14 = 0;
    memset(v28, 0, sizeof(v28));
    v27 = 0u;
    v26 = 0u;
    v25 = 0u;
    v24 = 0u;
    v23 = 0u;
    v22 = 0u;
    goto LABEL_14;
  }
  v14 = *a3 + HIWORD(v19);
  *a3 = v14;
  v18 = 0;
  v15 = *(_DWORD *)(a1 + 712);
  switch(v15)
  {
    case 4:
      v16 = aj_huffman_decode_ac_s4(a1, a2, &v21, &v18, v11, v12);
      goto LABEL_9;
    case 2:
      v16 = aj_huffman_decode_ac_s2(a1, a2, &v21, &v18, v11, v12);
      goto LABEL_9;
    case 1:
      v16 = aj_huffman_decode_ac_s1(a1, a2, &v21, &v18, v11, v12);
LABEL_9:
      v13 = v16;
      if ((_DWORD)v16)
        goto LABEL_14;
      v15 = *(_DWORD *)(a1 + 712);
      break;
  }
  if (v15 < 2)
    v13 = 0;
  else
    v13 = aj_huffman_decode_skip_block(*(_QWORD *)(a1 + 40), a2, v18);
LABEL_14:
  v21 = v14;
  aj_block_dequantize_12bit((_DWORD *)a1, &v21, v20);
  (*(void (**)(_DWORD *, uint64_t, uint64_t))(a1 + 520))(v20, a4, a5);
  return v13;
}

uint64_t aj_block_decode_skip(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  int v7;

  v7 = 0;
  result = aj_huffman_decode_val(*(_QWORD *)(a1 + 32), a2, 0, &v7);
  if (!(_DWORD)result)
  {
    v7 = SHIWORD(v7);
    *a3 += v7;
    return aj_huffman_decode_skip_block(*(_QWORD *)(a1 + 40), a2, 1);
  }
  return result;
}

uint64_t aj_prog_decode_DC_refine(_QWORD *a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t result;

  v6 = (uint64_t)(a3 + 24);
  LODWORD(v5) = *a3;
  if (*a3 < 1)
  {
LABEL_15:
    result = 0;
    ++a3[19];
  }
  else
  {
    v9 = 0;
    v10 = 1 << a3[15];
    while (1)
    {
      v11 = a3[v9 + 1];
      v12 = (_DWORD)v5 == 1 ? 1 : *(_DWORD *)(*a1 + 4 * v11 + 32) * *(_DWORD *)(*a1 + 4 * v11 + 16);
      v13 = a3[30];
      if (v13 < v12 - 9)
      {
        if (aj_istream_fill_buf(v6, -9))
          return 9;
        v13 = a3[30];
        if (v13 < v12 - 9)
          return 9;
      }
      v14 = a3[24];
      a3[24] = v14 << v12;
      a3[30] = v13 - v12;
      if (v12 >= 1)
      {
        v15 = 0;
        v16 = v14 & (-1 << -(char)v12);
        do
        {
          if (v16 < 0)
          {
            v17 = (v15 + *((int *)a1 + v11 + 1617)) << 7;
            *(_WORD *)(a4 + v17) |= v10;
          }
          v16 *= 2;
          ++v15;
        }
        while (v12 != (_DWORD)v15);
      }
      ++v9;
      v5 = *a3;
      if (v9 >= v5)
        goto LABEL_15;
    }
  }
  return result;
}

uint64_t aj_baseline_multiscan_decode_scan(_QWORD *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  int v5;
  unsigned int *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  int *v13;
  _DWORD *v14;
  int *v15;
  int *v16;
  __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  __int16 v31;
  int v32;
  int v33;
  unint64_t v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int *v47;
  int *v48;
  int *v49;
  int v50;
  _DWORD *v51;
  char v52;

  v6 = a3 + 24;
  v5 = *a3;
  if ((int)*a3 < 1)
  {
LABEL_50:
    v42 = 0;
    ++a3[19];
  }
  else
  {
    v8 = 0;
    v46 = a4;
    v44 = a2;
    while (1)
    {
      v9 = (int)a3[v8 + 1];
      v10 = a1[196 * (int)v9 + 112];
      if (v5 == 1)
        break;
      v50 = *(_DWORD *)(*a1 + 4 * v9 + 32) * *(_DWORD *)(*a1 + 4 * v9 + 16);
      if (v50 >= 1)
        goto LABEL_6;
LABEL_49:
      if (++v8 >= v5)
        goto LABEL_50;
    }
    v50 = 1;
LABEL_6:
    v45 = v8;
    v11 = 0;
    v12 = (_DWORD *)(a2 + 4 * v9 + 8);
    v13 = (int *)a1 + v9 + 1617;
    v14 = &a3[v9];
    v15 = v14 + 5;
    v16 = v14 + 9;
    v51 = v12;
    v48 = v14 + 5;
    v49 = v13;
    v47 = v14 + 9;
LABEL_7:
    v17 = (__int16 *)(a4 + ((*v13 + (uint64_t)v11) << 7));
    v18 = *(_QWORD *)&a3[4 * *v15 + 54];
    v19 = *(_QWORD *)&a3[4 * *v16 + 56];
    *v17 = *v12;
    v20 = a3[30];
    if (v20 <= -2)
    {
      v21 = aj_istream_fill_buf((uint64_t)v6, -9);
      if ((_DWORD)v21)
      {
LABEL_53:
        v42 = v21;
LABEL_55:
        aj_log_error(0, "Unable to read more data");
        return v42;
      }
      v20 = a3[30];
      v12 = v51;
      if (v20 < -8)
      {
LABEL_54:
        v42 = 7;
        goto LABEL_55;
      }
    }
    v52 = 0;
    v22 = *v6;
    v23 = *(unsigned __int16 *)(v18 + ((v22 >> 23) & 0x1FE) + 272);
    if (*(_WORD *)(v18 + ((v22 >> 23) & 0x1FE) + 272))
    {
      v24 = v20 + 9;
      if (v20 >= 0)
        v24 = 8;
      if (v24 < v23 >> 8)
        return 7;
      a3[24] = (_DWORD)v22 << SBYTE1(v23);
      a3[30] = v20 - (v23 >> 8);
      v52 = v23;
    }
    else
    {
      v25 = prog_huff_decode_loop(v18, v6, &v52);
      if ((_DWORD)v25)
        return v25;
      LOBYTE(v23) = v52;
      v12 = v51;
    }
    if (!(_BYTE)v23)
    {
      v31 = *v17;
      goto LABEL_26;
    }
    v26 = a3[30];
    v27 = v23;
    v28 = v23 - 9;
    if (v26 >= v28 || !aj_istream_fill_buf((uint64_t)v6, -9) && (v26 = a3[30], v26 >= v28))
    {
      v29 = a3[24];
      a3[24] = v29 << v27;
      a3[30] = v26 - v27;
      if (v29 >= 0)
        v30 = (-1 << v27) + 1;
      else
        LOWORD(v30) = 0;
      v31 = *v17 + v30 + (v29 >> -(char)v27);
      *v17 = v31;
      v12 = v51;
LABEL_26:
      *v12 = v31;
      v32 = 1;
      while (1)
      {
        v33 = a3[30];
        if (v33 <= -2)
        {
          v21 = aj_istream_fill_buf((uint64_t)v6, -9);
          if ((_DWORD)v21)
            goto LABEL_53;
          v33 = a3[30];
          if (v33 < -8)
            goto LABEL_54;
        }
        v34 = *v6;
        v35 = *(unsigned __int16 *)(v19 + ((v34 >> 23) & 0x1FE) + 272);
        if (*(_WORD *)(v19 + ((v34 >> 23) & 0x1FE) + 272))
        {
          v36 = v33 + 9;
          if (v33 >= 0)
            v36 = 8;
          if (v36 < v35 >> 8)
            return 7;
          a3[24] = (_DWORD)v34 << SBYTE1(v35);
          a3[30] = v33 - (v35 >> 8);
          v52 = v35;
        }
        else
        {
          v25 = prog_huff_decode_loop(v19, v6, &v52);
          if ((_DWORD)v25)
            return v25;
          LOBYTE(v35) = v52;
        }
        v37 = v32 + ((v35 & 0xF0) >> 4);
        v38 = v35 & 0xF;
        if ((v35 & 0xF) != 0)
        {
          v39 = a3[30];
          if (v39 < v38 - 9)
          {
            if (aj_istream_fill_buf((uint64_t)v6, -9))
              return 9;
            v39 = a3[30];
            if (v39 < v38 - 9)
              return 9;
          }
          v40 = a3[24];
          a3[24] = v40 << v38;
          a3[30] = v39 - v38;
          v41 = (-1 << v38) | 1;
          if (v40 < 0)
            LOWORD(v41) = 0;
          v17[*(int *)(v10 + 4 * v37)] = v41 + (v40 >> -(char)v38);
        }
        else
        {
          if (v35 < 0x10u)
            goto LABEL_47;
          if (v35 >> 4 != 15)
          {
            v42 = 7;
            aj_log_error(0, "Illegal huffman symbol.");
            return v42;
          }
        }
        v32 = v37 + 1;
        if (v37 >= 63)
        {
LABEL_47:
          ++v11;
          a4 = v46;
          v16 = v47;
          v12 = v51;
          v15 = v48;
          v13 = v49;
          if (v11 != v50)
            goto LABEL_7;
          v5 = *a3;
          a2 = v44;
          v8 = v45;
          goto LABEL_49;
        }
      }
    }
    return 9;
  }
  return v42;
}

void aj_rotate_ip(char *a1, void *a2, int a3, int a4, int a5, int a6)
{
  int16x8_t v12;
  uint8x8_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  char *v19;
  char *v20;
  int v21;
  char v22;

  if (a5 == 180)
  {
    switch(a6)
    {
      case 1:
        rotate180_1bpp(a1, a3, a4);
        break;
      case 2:
        rotate180_2bpp(a1, a3, a4);
        break;
      case 3:
        rotate180_3bpp(a1, a3, a4);
        break;
      case 4:
        rotate180_4bpp(a1, a3, a4);
        break;
      default:
        return;
    }
  }
  else
  {
    bzero(a2, a4 * a3 / 8 + 1);
    v14 = a6 - 1;
    switch(v14)
    {
      case 0:
        transpose_1bpp((uint64_t)a1, (uint64_t)a2, a3, a4);
        break;
      case 1:
        transpose_2bpp((uint64_t)a1, (uint64_t)a2, a3, a4);
        break;
      case 2:
        transpose_3bpp((uint64_t)a1, (uint64_t)a2, a3, a4);
        break;
      case 3:
        transpose_4bpp((uint64_t)a1, (uint64_t)a2, a3, a4, v12, v13);
        break;
      default:
        break;
    }
    if (a5 == 90)
    {
      switch(v14)
      {
        case 0:
          if (a4 >= 1)
          {
            v15 = 0;
            if (a3 >= 0)
              v16 = a3;
            else
              v16 = a3 + 1;
            v17 = v16 >> 1;
            v18 = (uint64_t)&a1[a3 - 1];
            do
            {
              if (a3 >= 2)
              {
                v19 = &a1[v15 * a3];
                v20 = (char *)v18;
                v21 = v17;
                do
                {
                  v22 = *v19;
                  *v19++ = *v20;
                  *v20-- = v22;
                  --v21;
                }
                while (v21);
              }
              ++v15;
              v18 += a3;
            }
            while (v15 != a4);
          }
          break;
        case 1:
          mirror_horizontal_2bpp((uint64_t)a1, a4, a3);
          break;
        case 2:
          mirror_horizontal_3bpp((uint64_t)a1, a4, a3);
          break;
        case 3:
          mirror_horizontal_4bpp((uint64_t)a1, a4, a3);
          break;
        default:
          return;
      }
    }
    else
    {
      switch(v14)
      {
        case 0:
          mirror_vertical_1bpp((uint64_t)a1, a4, a3);
          break;
        case 1:
          mirror_vertical_2bpp((uint64_t)a1, a4, a3);
          break;
        case 2:
          mirror_vertical_3bpp((uint64_t)a1, a4, a3);
          break;
        case 3:
          mirror_vertical_4bpp((uint64_t)a1, a4, a3);
          break;
        default:
          return;
      }
    }
  }
}

char *rotate180_1bpp(char *result, int a2, int a3)
{
  char *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char v8;
  int v9;
  int v10;
  char v11;

  v3 = &result[a3 * a2 - 1];
  if (a2 >= 0)
    v4 = a2;
  else
    v4 = a2 + 1;
  if (a2 >= 2)
  {
    v5 = 0;
    v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        v7 = a3;
        do
        {
          v8 = *result;
          *result++ = *v3;
          *v3-- = v8;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if ((a2 & 1) != 0)
  {
    if (a3 >= 0)
      v9 = a3;
    else
      v9 = a3 + 1;
    if (a3 >= 2)
    {
      v10 = v9 >> 1;
      do
      {
        v11 = *result;
        *result++ = *v3;
        *v3-- = v11;
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

char *rotate180_2bpp(char *result, int a2, int a3)
{
  char *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char v8;
  char v9;
  int v10;
  int v11;
  char v12;
  char v13;

  v3 = &result[2 * a2 * a3 - 2];
  if (a2 >= 0)
    v4 = a2;
  else
    v4 = a2 + 1;
  if (a2 >= 2)
  {
    v5 = 0;
    v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        v7 = a3;
        do
        {
          v8 = *result;
          *result = *v3;
          *v3 = v8;
          v9 = result[1];
          result[1] = v3[1];
          v3[1] = v9;
          result += 2;
          v3 -= 2;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if ((a2 & 1) != 0)
  {
    if (a3 >= 0)
      v10 = a3;
    else
      v10 = a3 + 1;
    if (a3 >= 2)
    {
      v11 = v10 >> 1;
      do
      {
        v12 = *result;
        *result = *v3;
        *v3 = v12;
        v13 = result[1];
        result[1] = v3[1];
        v3[1] = v13;
        result += 2;
        v3 -= 2;
        --v11;
      }
      while (v11);
    }
  }
  return result;
}

char *rotate180_3bpp(char *result, int a2, int a3)
{
  char *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char v8;
  char v9;
  char v10;
  int v11;
  int v12;
  char v13;
  char v14;
  char v15;

  v3 = &result[3 * a2 * a3 - 3];
  if (a2 >= 0)
    v4 = a2;
  else
    v4 = a2 + 1;
  if (a2 >= 2)
  {
    v5 = 0;
    v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        v7 = a3;
        do
        {
          v8 = *result;
          *result = *v3;
          *v3 = v8;
          v9 = result[1];
          result[1] = v3[1];
          v3[1] = v9;
          v10 = result[2];
          result[2] = v3[2];
          v3[2] = v10;
          result += 3;
          v3 -= 3;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if ((a2 & 1) != 0)
  {
    if (a3 >= 0)
      v11 = a3;
    else
      v11 = a3 + 1;
    if (a3 >= 2)
    {
      v12 = v11 >> 1;
      do
      {
        v13 = *result;
        *result = *v3;
        *v3 = v13;
        v14 = result[1];
        result[1] = v3[1];
        v3[1] = v14;
        v15 = result[2];
        result[2] = v3[2];
        v3[2] = v15;
        result += 3;
        v3 -= 3;
        --v12;
      }
      while (v12);
    }
  }
  return result;
}

char *rotate180_4bpp(char *result, int a2, int a3)
{
  char *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char v8;
  char v9;
  char v10;
  char v11;
  int v12;
  int v13;
  char v14;
  char v15;
  char v16;
  char v17;

  v3 = &result[4 * a2 * a3 - 4];
  if (a2 >= 0)
    v4 = a2;
  else
    v4 = a2 + 1;
  if (a2 >= 2)
  {
    v5 = 0;
    v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        v7 = a3;
        do
        {
          v8 = *result;
          *result = *v3;
          *v3 = v8;
          v9 = result[1];
          result[1] = v3[1];
          v3[1] = v9;
          v10 = result[2];
          result[2] = v3[2];
          v3[2] = v10;
          v11 = result[3];
          result[3] = v3[3];
          v3[3] = v11;
          result += 4;
          v3 -= 4;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if ((a2 & 1) != 0)
  {
    if (a3 >= 0)
      v12 = a3;
    else
      v12 = a3 + 1;
    if (a3 >= 2)
    {
      v13 = v12 >> 1;
      do
      {
        v14 = *result;
        *result = *v3;
        *v3 = v14;
        v15 = result[1];
        result[1] = v3[1];
        v3[1] = v15;
        v16 = result[2];
        result[2] = v3[2];
        v3[2] = v16;
        v17 = result[3];
        result[3] = v3[3];
        v3[3] = v17;
        result += 4;
        v3 -= 4;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t transpose_1bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  char v13;

  if (a3 >= 1)
  {
    v4 = 0;
    v5 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        v6 = 0;
        v7 = v4 * a4;
        do
        {
          v8 = v6 + v7;
          v9 = v6 + v7 + 7;
          if (v6 + v7 < 0 == __OFADD__(v6, v7))
            v9 = v6 + v7;
          if (((*(unsigned __int8 *)(a2 + (v9 >> 3)) >> (v8 - 8 * (v9 >> 3))) & 1) == 0)
          {
            v10 = *(_BYTE *)(result + v8);
            v11 = v6 + v7;
            do
            {
              v12 = a4 * a3 - 1;
              if (v11 != v5)
                v12 = v11 * a3 % v5;
              v13 = *(_BYTE *)(result + v12);
              *(_BYTE *)(result + v12) = v10;
              *(_BYTE *)(a2 + v12 / 8) |= 1 << (v12 % 8);
              v11 = v12;
              v10 = v13;
            }
            while (v12 != v8);
          }
          ++v6;
        }
        while (v6 != a4);
      }
      ++v4;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t transpose_2bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char v16;
  char v17;

  if (a3 >= 1)
  {
    v4 = 0;
    v5 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        v6 = 0;
        v7 = v4 * a4;
        do
        {
          v8 = v6 + v7;
          v9 = v6 + v7 + 7;
          if (v6 + v7 < 0 == __OFADD__(v6, v7))
            v9 = v6 + v7;
          if (((*(unsigned __int8 *)(a2 + (v9 >> 3)) >> (v8 - 8 * (v9 >> 3))) & 1) == 0)
          {
            v10 = (char *)(result + 2 * v8);
            v11 = *v10;
            v12 = v10[1];
            v13 = v6 + v7;
            do
            {
              v14 = a4 * a3 - 1;
              if (v13 != v5)
                v14 = v13 * a3 % v5;
              v15 = (char *)(result + 2 * v14);
              v16 = *v15;
              v17 = v15[1];
              *v15 = v11;
              v15[1] = v12;
              *(_BYTE *)(a2 + v14 / 8) |= 1 << (v14 % 8);
              v13 = v14;
              v11 = v16;
              v12 = v17;
            }
            while (v14 != v8);
          }
          ++v6;
        }
        while (v6 != a4);
      }
      ++v4;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t transpose_3bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char v11;
  char v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char v17;
  char v18;
  char v19;

  if (a3 >= 1)
  {
    v4 = 0;
    v5 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        v6 = 0;
        v7 = v4 * a4;
        do
        {
          v8 = v6 + v7;
          v9 = v6 + v7 + 7;
          if (v6 + v7 < 0 == __OFADD__(v6, v7))
            v9 = v6 + v7;
          if (((*(unsigned __int8 *)(a2 + (v9 >> 3)) >> (v8 - 8 * (v9 >> 3))) & 1) == 0)
          {
            v10 = (char *)(result + 3 * v8);
            v11 = *v10;
            v12 = v10[1];
            v13 = v10[2];
            v14 = v6 + v7;
            do
            {
              v15 = a4 * a3 - 1;
              if (v14 != v5)
                v15 = v14 * a3 % v5;
              v16 = (char *)(result + 3 * v15);
              v17 = *v16;
              v18 = v16[1];
              v19 = v16[2];
              *v16 = v11;
              v16[1] = v12;
              v16[2] = v13;
              *(_BYTE *)(a2 + v15 / 8) |= 1 << (v15 % 8);
              v14 = v15;
              v11 = v17;
              v12 = v18;
              v13 = v19;
            }
            while (v15 != v8);
          }
          ++v6;
        }
        while (v6 != a4);
      }
      ++v4;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t transpose_4bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t a5, uint8x8_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a3 >= 1)
  {
    v6 = 0;
    v7 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        v8 = 0;
        v9 = v6 * a4;
        do
        {
          v10 = v8 + v9;
          v11 = v8 + v9 + 7;
          if (v8 + v9 < 0 == __OFADD__(v8, v9))
            v11 = v8 + v9;
          if (((*(unsigned __int8 *)(a2 + (v11 >> 3)) >> (v10 - 8 * (v11 >> 3))) & 1) == 0)
          {
            a5.i32[0] = *(_DWORD *)(result + 4 * v10);
            a5 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a5.i8);
            v12 = v8 + v9;
            do
            {
              v13 = a4 * a3 - 1;
              if (v12 != v7)
                v13 = v12 * a3 % v7;
              a6.i32[0] = *(_DWORD *)(result + 4 * v13);
              *(_DWORD *)(result + 4 * v13) = vmovn_s16(a5).u32[0];
              a5 = (int16x8_t)vmovl_u8(a6);
              *(_BYTE *)(a2 + v13 / 8) |= 1 << (v13 % 8);
              v12 = v13;
            }
            while (v13 != v10);
          }
          ++v8;
        }
        while (v8 != a4);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

uint64_t mirror_horizontal_1bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  char *v7;
  char *v8;
  int v9;
  char v10;

  if (a2 >= 1)
  {
    v3 = 0;
    if (a3 >= 0)
      v4 = a3;
    else
      v4 = a3 + 1;
    v5 = v4 >> 1;
    v6 = result + a3 - 1;
    do
    {
      if (a3 >= 2)
      {
        v7 = (char *)(result + v3 * a3);
        v8 = (char *)v6;
        v9 = v5;
        do
        {
          v10 = *v7;
          *v7++ = *v8;
          *v8-- = v10;
          --v9;
        }
        while (v9);
      }
      ++v3;
      v6 += a3;
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_horizontal_2bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char *v8;
  char *v9;
  int v10;
  char v11;
  char v12;

  if (a2 >= 1)
  {
    v3 = 0;
    v4 = 2 * a3;
    if (a3 >= 0)
      v5 = a3;
    else
      v5 = a3 + 1;
    v6 = v5 >> 1;
    do
    {
      v7 = v3++;
      if (a3 >= 2)
      {
        v8 = (char *)(result + v4 * (int)v3 - 2);
        v9 = (char *)(result + v4 * v7);
        v10 = v6;
        do
        {
          v11 = *v9;
          *v9 = *v8;
          *v8 = v11;
          v12 = v9[1];
          v9[1] = v8[1];
          v8[1] = v12;
          v9 += 2;
          v8 -= 2;
          --v10;
        }
        while (v10);
      }
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_horizontal_3bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char *v8;
  char *v9;
  int v10;
  char v11;
  char v12;
  char v13;

  if (a2 >= 1)
  {
    v3 = 0;
    v4 = 3 * a3;
    if (a3 >= 0)
      v5 = a3;
    else
      v5 = a3 + 1;
    v6 = v5 >> 1;
    do
    {
      v7 = v3++;
      if (a3 >= 2)
      {
        v8 = (char *)(result + v4 * (int)v3 - 3);
        v9 = (char *)(result + v4 * v7);
        v10 = v6;
        do
        {
          v11 = *v9;
          *v9 = *v8;
          *v8 = v11;
          v12 = v9[1];
          v9[1] = v8[1];
          v8[1] = v12;
          v13 = v9[2];
          v9[2] = v8[2];
          v8[2] = v13;
          v9 += 3;
          v8 -= 3;
          --v10;
        }
        while (v10);
      }
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_horizontal_4bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char *v8;
  char *v9;
  int v10;
  char v11;
  char v12;
  char v13;
  char v14;

  if (a2 >= 1)
  {
    v3 = 0;
    v4 = 4 * a3;
    if (a3 >= 0)
      v5 = a3;
    else
      v5 = a3 + 1;
    v6 = v5 >> 1;
    do
    {
      v7 = v3++;
      if (a3 >= 2)
      {
        v8 = (char *)(result + v4 * (int)v3 - 4);
        v9 = (char *)(result + v4 * v7);
        v10 = v6;
        do
        {
          v11 = *v9;
          *v9 = *v8;
          *v8 = v11;
          v12 = v9[1];
          v9[1] = v8[1];
          v8[1] = v12;
          v13 = v9[2];
          v9[2] = v8[2];
          v8[2] = v13;
          v14 = v9[3];
          v9[3] = v8[3];
          v8[3] = v14;
          v9 += 4;
          v8 -= 4;
          --v10;
        }
        while (v10);
      }
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_vertical_1bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  char *v4;
  char *v5;
  int v6;
  char v7;

  if (a2 >= 2)
  {
    v3 = 0;
    do
    {
      if (a3 >= 1)
      {
        v4 = (char *)(result + (~(_DWORD)v3 + a2) * a3);
        v5 = (char *)(result + v3 * a3);
        v6 = a3;
        do
        {
          v7 = *v5;
          *v5++ = *v4;
          *v4++ = v7;
          --v6;
        }
        while (v6);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t mirror_vertical_2bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  int v4;
  char *v5;
  char *v6;
  int v7;
  char v8;
  char v9;

  if (a2 >= 2)
  {
    v3 = 0;
    v4 = 2 * a3;
    do
    {
      if (a3 >= 1)
      {
        v5 = (char *)(result + v4 * (~(_DWORD)v3 + a2));
        v6 = (char *)(result + v4 * (int)v3);
        v7 = a3;
        do
        {
          v8 = *v6;
          *v6 = *v5;
          *v5 = v8;
          v9 = v6[1];
          v6[1] = v5[1];
          v5[1] = v9;
          v6 += 2;
          v5 += 2;
          --v7;
        }
        while (v7);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t mirror_vertical_3bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  int v4;
  char *v5;
  char *v6;
  int v7;
  char v8;
  char v9;
  char v10;

  if (a2 >= 2)
  {
    v3 = 0;
    v4 = 3 * a3;
    do
    {
      if (a3 >= 1)
      {
        v5 = (char *)(result + v4 * (~(_DWORD)v3 + a2));
        v6 = (char *)(result + v4 * (int)v3);
        v7 = a3;
        do
        {
          v8 = *v6;
          *v6 = *v5;
          *v5 = v8;
          v9 = v6[1];
          v6[1] = v5[1];
          v5[1] = v9;
          v10 = v6[2];
          v6[2] = v5[2];
          v5[2] = v10;
          v6 += 3;
          v5 += 3;
          --v7;
        }
        while (v7);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t mirror_vertical_4bpp(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  int v4;
  char *v5;
  char *v6;
  int v7;
  char v8;
  char v9;
  char v10;
  char v11;

  if (a2 >= 2)
  {
    v3 = 0;
    v4 = 4 * a3;
    do
    {
      if (a3 >= 1)
      {
        v5 = (char *)(result + v4 * (~(_DWORD)v3 + a2));
        v6 = (char *)(result + v4 * (int)v3);
        v7 = a3;
        do
        {
          v8 = *v6;
          *v6 = *v5;
          *v5 = v8;
          v9 = v6[1];
          v6[1] = v5[1];
          v5[1] = v9;
          v10 = v6[2];
          v6[2] = v5[2];
          v5[2] = v10;
          v11 = v6[3];
          v6[3] = v5[3];
          v5[3] = v11;
          v6 += 4;
          v5 += 4;
          --v7;
        }
        while (v7);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t applejpeg_bitmap_rotate_inplace(_QWORD *a1, int32x2_t *a2, uint64_t a3)
{
  uint64_t v6;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  BOOL v14;
  int v15;
  void *v16;
  size_t v17;
  void *v18;
  uint64_t v19;
  char *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  int16x8_t v32;
  uint8x8_t v33;
  size_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  size_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  size_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  char *v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  int16x8_t v65;
  uint8x8_t v66;
  size_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  size_t v73;
  int v74;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  size_t v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  char v94;

  if (!a1 || !*a1 || !a1[1])
  {
    aj_log_error(0, "Cannot accept NULL arguments");
    return 8;
  }
  v6 = check_rotinput((uint64_t)a2, a3);
  if (!(_DWORD)v6)
  {
    if ((_DWORD)a3 == 180)
    {
      if (!a2)
      {
        aj_log_error(0, "bitmap struct pointer is NULL");
        return 8;
      }
    }
    else
    {
      v8 = a2[5].i32[0];
      v9 = a2[5].i32[1];
      if (v8 >= -1)
        v10 = v8 + 1;
      else
        v10 = v8 + 2;
      v11 = v10 >> 1;
      if (v9 >= -1)
        v12 = v9 + 1;
      else
        v12 = v9 + 2;
      v13 = (int)(4 * v11 * (v12 >> 1)) / 8;
      v14 = __CFADD__(v13, 1);
      v15 = v13 + 1;
      if (!v14)
      {
        v17 = v15;
        v18 = (void *)((uint64_t (*)(_QWORD, _QWORD))*a1)(v15, a1[2]);
        if (!v18)
        {
          aj_log_error(0, "Could not allocate rotation workmemory");
          return 6;
        }
        v16 = v18;
        bzero(v18, v17);
LABEL_22:
        v19 = 0;
        v20 = (char *)*a2;
        v21 = a2[5].i32[0];
        v22 = a2[5].i32[1];
        v23 = v21 + 2;
        if (v21 >= -1)
          v23 = v21 + 1;
        v24 = v23 >> 1;
        v25 = 2 * v24;
        v26 = v22 + 2;
        if (v22 >= -1)
          v26 = v22 + 1;
        v27 = 2 * (v26 >> 1);
        v28 = a2[6].u32[0];
        if (v28 <= 0xD)
        {
          if (((1 << v28) & 0x300) != 0)
          {
            v19 = (uint64_t)&v20[v25 * (uint64_t)v22];
          }
          else if (((1 << v28) & 0xC00) != 0)
          {
            v19 = (uint64_t)&v20[v27 * (uint64_t)v25];
          }
          else if (((1 << v28) & 0x3000) != 0)
          {
            v19 = (uint64_t)&v20[v27 * v21];
          }
        }
        if ((int)a3 > 179)
        {
          if ((_DWORD)a3 == 270)
          {
            switch(v28)
            {
              case 0u:
              case 6u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_3bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_vertical_3bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 1u:
              case 2u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_2bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                v62 = a2[5].i32[0];
                v63 = a2[5].i32[1];
                v64 = (uint64_t)v20;
                goto LABEL_117;
              case 3u:
              case 4u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_4bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0], v65, v66);
                mirror_vertical_4bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 5u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_vertical_1bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 7u:
LABEL_96:
                aj_log_error(0, "Format not yet supported.");
                v6 = 3;
                goto LABEL_131;
              case 8u:
              case 9u:
                v67 = v27 * v25 / 8 + 1;
                bzero(v16, v67);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], v25);
                mirror_vertical_1bpp((uint64_t)v20, v25, a2[5].i32[1]);
                bzero(v16, v67);
                v68 = a2[5].i32[0];
                if (v68 >= -1)
                  v69 = v68 + 1;
                else
                  v69 = v68 + 2;
                transpose_2bpp(v19, (uint64_t)v16, a2[5].i32[1], (uint64_t)v69 >> 1);
                v70 = a2[5].i32[0];
                if (v70 >= -1)
                  v71 = v70 + 1;
                else
                  v71 = v70 + 2;
                mirror_vertical_2bpp(v19, v71 >> 1, a2[5].i32[1]);
LABEL_104:
                if (a2[6].i32[0] == 8)
                  v72 = 12;
                else
                  v72 = 13;
                goto LABEL_129;
              case 0xAu:
              case 0xBu:
                v73 = v27 * v25 / 8 + 1;
                bzero(v16, v73);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, v25);
                mirror_vertical_1bpp((uint64_t)v20, v25, v27);
                bzero(v16, v73);
                v75 = a2[5].i32[0];
                v74 = a2[5].i32[1];
                if (v74 >= -1)
                  v76 = v74 + 1;
                else
                  v76 = v74 + 2;
                v77 = (uint64_t)v76 >> 1;
                v78 = v75 + 2;
                if (v75 >= -1)
                  v78 = v75 + 1;
                transpose_2bpp(v19, (uint64_t)v16, v77, (uint64_t)v78 >> 1);
                v79 = a2[5].i32[0];
                v80 = a2[5].i32[1];
                if (v79 >= -1)
                  v81 = v79 + 1;
                else
                  v81 = v79 + 2;
                v62 = v81 >> 1;
                v82 = v80 + 2;
                if (v80 >= -1)
                  v82 = v80 + 1;
                v63 = v82 >> 1;
                v64 = v19;
LABEL_117:
                mirror_vertical_2bpp(v64, v62, v63);
                goto LABEL_130;
              case 0xCu:
              case 0xDu:
                v83 = v27 * v25 / 8 + 1;
                bzero(v16, v83);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, a2[5].i32[0]);
                mirror_vertical_1bpp((uint64_t)v20, a2[5].i32[0], v27);
                bzero(v16, v83);
                v84 = a2[5].i32[1];
                if (v84 >= -1)
                  v85 = v84 + 1;
                else
                  v85 = v84 + 2;
                transpose_2bpp(v19, (uint64_t)v16, (uint64_t)v85 >> 1, a2[5].i32[0]);
                v86 = a2[5].i32[1];
                if (v86 >= -1)
                  v87 = v86 + 1;
                else
                  v87 = v86 + 2;
                mirror_vertical_2bpp(v19, a2[5].i32[0], v87 >> 1);
LABEL_125:
                if (a2[6].i32[0] == 12)
                  v72 = 8;
                else
                  v72 = 9;
LABEL_129:
                a2[6].i32[0] = v72;
                goto LABEL_130;
              default:
LABEL_47:
                aj_log_error(0, "Unrecognized or unimplemented format.");
                v6 = 4;
                goto LABEL_131;
            }
          }
          if ((_DWORD)a3 == 180)
          {
            switch(v28)
            {
              case 0u:
              case 6u:
                rotate180_3bpp(*(char **)a2, v22, v21);
                goto LABEL_93;
              case 1u:
              case 2u:
                v54 = (char *)*a2;
                goto LABEL_92;
              case 3u:
              case 4u:
                rotate180_4bpp(*(char **)a2, v22, v21);
                goto LABEL_93;
              case 5u:
                rotate180_1bpp(*(char **)a2, v22, v21);
                goto LABEL_93;
              case 7u:
                rotate180_4bpp(*(char **)a2, v22, v24);
                v88 = a2[5].i32[1];
                if (v88 < 1)
                  goto LABEL_93;
                v89 = 0;
                v90 = a2[5].i32[0];
                v91 = v90 + 2;
                if (v90 >= -1)
                  v91 = v90 + 1;
                v92 = v91 >> 1;
                if (v92 <= 1)
                  v92 = 1;
                do
                {
                  if (v90 >= 1)
                  {
                    v93 = v92;
                    do
                    {
                      v94 = *v20;
                      *v20 = v20[2];
                      v20[2] = v94;
                      v20 += 4;
                      --v93;
                    }
                    while (v93);
                  }
                  v6 = 0;
                  ++v89;
                }
                while (v89 != v88);
                goto LABEL_131;
              case 8u:
              case 9u:
                rotate180_1bpp(*(char **)a2, v22, 2 * v24);
                v55 = a2[5].i32[0];
                v22 = a2[5].i32[1];
                if (v55 >= -1)
                  v56 = v55 + 1;
                else
                  v56 = v55 + 2;
                goto LABEL_86;
              case 0xAu:
              case 0xBu:
                rotate180_1bpp(*(char **)a2, v27, 2 * v24);
                v58 = a2[5].i32[0];
                v57 = a2[5].i32[1];
                if (v57 >= -1)
                  v59 = v57 + 1;
                else
                  v59 = v57 + 2;
                v22 = v59 >> 1;
                v56 = v58 + 2;
                if (v58 >= -1)
                  v56 = v58 + 1;
LABEL_86:
                v21 = v56 >> 1;
                goto LABEL_91;
              case 0xCu:
              case 0xDu:
                rotate180_1bpp(*(char **)a2, v27, v21);
                v21 = a2[5].i32[0];
                v60 = a2[5].i32[1];
                if (v60 >= -1)
                  v61 = v60 + 1;
                else
                  v61 = v60 + 2;
                v22 = v61 >> 1;
LABEL_91:
                v54 = (char *)v19;
LABEL_92:
                rotate180_2bpp(v54, v22, v21);
LABEL_93:
                v6 = 0;
                break;
              default:
                goto LABEL_47;
            }
            goto LABEL_131;
          }
        }
        else
        {
          if (!(_DWORD)a3)
          {
            v6 = a3;
            goto LABEL_131;
          }
          if ((_DWORD)a3 == 90)
          {
            switch(v28)
            {
              case 0u:
              case 6u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_3bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_horizontal_3bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 1u:
              case 2u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_2bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                v29 = a2[5].i32[0];
                v30 = a2[5].i32[1];
                v31 = (uint64_t)v20;
                break;
              case 3u:
              case 4u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_4bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0], v32, v33);
                mirror_horizontal_4bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 5u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_horizontal_1bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 7u:
                goto LABEL_96;
              case 8u:
              case 9u:
                v34 = v27 * v25 / 8 + 1;
                bzero(v16, v34);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], v25);
                mirror_horizontal_1bpp((uint64_t)v20, v25, a2[5].i32[1]);
                bzero(v16, v34);
                v35 = a2[5].i32[0];
                if (v35 >= -1)
                  v36 = v35 + 1;
                else
                  v36 = v35 + 2;
                transpose_2bpp(v19, (uint64_t)v16, a2[5].i32[1], (uint64_t)v36 >> 1);
                v37 = a2[5].i32[0];
                if (v37 >= -1)
                  v38 = v37 + 1;
                else
                  v38 = v37 + 2;
                mirror_horizontal_2bpp(v19, v38 >> 1, a2[5].i32[1]);
                goto LABEL_104;
              case 0xAu:
              case 0xBu:
                v39 = v27 * v25 / 8 + 1;
                bzero(v16, v39);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, v25);
                mirror_horizontal_1bpp((uint64_t)v20, v25, v27);
                bzero(v16, v39);
                v41 = a2[5].i32[0];
                v40 = a2[5].i32[1];
                if (v40 >= -1)
                  v42 = v40 + 1;
                else
                  v42 = v40 + 2;
                v43 = (uint64_t)v42 >> 1;
                v44 = v41 + 2;
                if (v41 >= -1)
                  v44 = v41 + 1;
                transpose_2bpp(v19, (uint64_t)v16, v43, (uint64_t)v44 >> 1);
                v45 = a2[5].i32[0];
                v46 = a2[5].i32[1];
                if (v45 >= -1)
                  v47 = v45 + 1;
                else
                  v47 = v45 + 2;
                v29 = v47 >> 1;
                v48 = v46 + 2;
                if (v46 >= -1)
                  v48 = v46 + 1;
                v30 = v48 >> 1;
                v31 = v19;
                break;
              case 0xCu:
              case 0xDu:
                v49 = v27 * v25 / 8 + 1;
                bzero(v16, v49);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, a2[5].i32[0]);
                mirror_horizontal_1bpp((uint64_t)v20, a2[5].i32[0], v27);
                bzero(v16, v49);
                v50 = a2[5].i32[1];
                if (v50 >= -1)
                  v51 = v50 + 1;
                else
                  v51 = v50 + 2;
                transpose_2bpp(v19, (uint64_t)v16, (uint64_t)v51 >> 1, a2[5].i32[0]);
                v52 = a2[5].i32[1];
                if (v52 >= -1)
                  v53 = v52 + 1;
                else
                  v53 = v52 + 2;
                mirror_horizontal_2bpp(v19, a2[5].i32[0], v53 >> 1);
                goto LABEL_125;
              default:
                goto LABEL_47;
            }
            mirror_horizontal_2bpp(v31, v29, v30);
LABEL_130:
            v6 = 0;
            a2[5] = vrev64_s32(a2[5]);
            goto LABEL_131;
          }
        }
        aj_log_error(0, "Rotation must be 0, 90, 180 or 270 degrees.");
        v6 = 5;
LABEL_131:
        if (v16)
          ((void (*)(void *, _QWORD))a1[1])(v16, a1[2]);
        return v6;
      }
    }
    v16 = 0;
    goto LABEL_22;
  }
  return v6;
}

uint64_t check_rotinput(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char *v4;

  if (!a1 || !*(_QWORD *)a1)
  {
    v3 = 8;
    v4 = "Cannot accept NULL arguments";
LABEL_8:
    aj_log_error(0, v4);
    return v3;
  }
  v3 = 5;
  v4 = "Unsupported rotation";
  if ((int)a2 > 179)
  {
    if ((_DWORD)a2 != 270 && (_DWORD)a2 != 180)
      goto LABEL_8;
    goto LABEL_13;
  }
  if ((_DWORD)a2)
  {
    if ((_DWORD)a2 != 90)
      goto LABEL_8;
LABEL_13:
    if (*(_DWORD *)(a1 + 48) != 7)
      return 0;
    v3 = 3;
    aj_log_error(0, "Unsupported format for rotation");
    return v3;
  }
  return a2;
}

uint64_t applejpeg_bitmap_rotate_to_dst(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t result;
  int *v7;
  int v8;
  char v9;
  int v10;
  int v11;
  char *v12;
  uint64_t v13;
  int v14;
  char *v15;
  int v16;
  char *v17;
  int v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  char *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  int v31;
  int v32;
  char v33;
  int v34;

  v3 = a3;
  result = check_rotinput(a1, a3);
  if (!(_DWORD)result)
  {
    if (a2 && *(_QWORD *)a2)
    {
      v7 = (int *)(a1 + 40);
      v8 = 4;
      switch(*(_DWORD *)(a1 + 48))
      {
        case 0:
          v8 = 3;
          goto LABEL_20;
        case 1:
        case 2:
          v8 = 2;
          goto LABEL_20;
        case 3:
        case 4:
          goto LABEL_20;
        case 5:
          v8 = 1;
LABEL_20:
          v22 = *v7;
          goto LABEL_21;
        case 7:
          v22 = (*v7 & 1) + *v7;
          v8 = 2;
LABEL_21:
          v23 = *(_DWORD *)(a1 + 44);
          if (v23 >= 1)
          {
            v24 = 0;
            v25 = *(char **)a1;
            do
            {
              aj_row_translate(v3, v8, v22, 0, 0, v22, v23, v24, v25, *(_QWORD *)a2);
              v25 += v22 * v8;
              ++v24;
            }
            while (v23 != v24);
          }
          goto LABEL_24;
        case 8:
        case 9:
          v9 = 0;
          v10 = *(_DWORD *)(a1 + 44);
          v11 = (*(_DWORD *)(a1 + 40) & 1) + *(_DWORD *)(a1 + 40);
          v33 = 1;
          goto LABEL_11;
        case 0xA:
        case 0xB:
          v11 = (*v7 & 1) + *v7;
          v33 = 1;
          goto LABEL_10;
        case 0xC:
        case 0xD:
          v33 = 0;
          v11 = *v7;
LABEL_10:
          v10 = (*(_DWORD *)(a1 + 44) & 1) + *(_DWORD *)(a1 + 44);
          v9 = 1;
LABEL_11:
          v12 = *(char **)a1;
          v34 = v11;
          v13 = v11;
          if (v10 >= 1)
          {
            v14 = 0;
            v15 = *(char **)a1;
            do
            {
              aj_row_translate(v3, 0, v13, 0, 0, v13, v10, v14, v15, *(_QWORD *)a2);
              v15 += v13;
              ++v14;
            }
            while (v10 != v14);
          }
          v16 = v10 >> v9;
          if (v10 >> v9 >= 1)
          {
            v17 = 0;
            v18 = 0;
            v19 = (unint64_t)&v12[v34 * (uint64_t)v10];
            v20 = (int)v13 >> v33;
            v21 = 2 * ((int)v13 >> v33);
            do
            {
              aj_row_translate(v3, 2, v20, 0, 0, v20, v16, v18, v17, v19);
              v17 += v21;
              ++v18;
            }
            while (v16 != v18);
          }
LABEL_24:
          v26 = *(_OWORD *)v7;
          v27 = *(_OWORD *)(a1 + 56);
          *(_OWORD *)(a2 + 72) = *(_OWORD *)(a1 + 72);
          *(_OWORD *)(a2 + 56) = v27;
          *(_OWORD *)(a2 + 40) = v26;
          v28 = *(_OWORD *)(a1 + 88);
          v29 = *(_OWORD *)(a1 + 104);
          v30 = *(_OWORD *)(a1 + 120);
          *(_OWORD *)(a2 + 136) = *(_OWORD *)(a1 + 136);
          *(_OWORD *)(a2 + 120) = v30;
          *(_OWORD *)(a2 + 104) = v29;
          *(_OWORD *)(a2 + 88) = v28;
          if (v3 == 180 || v3 == 90)
          {
            result = 0;
            v31 = *(_DWORD *)(a1 + 48);
            *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 44);
            *(_DWORD *)(a2 + 44) = *(_DWORD *)(a1 + 40);
            switch(v31)
            {
              case 8:
                result = 0;
                v32 = 12;
                goto LABEL_32;
              case 9:
                result = 0;
                v32 = 13;
                goto LABEL_32;
              case 12:
                result = 0;
                v32 = 8;
                goto LABEL_32;
              case 13:
                result = 0;
                v32 = 9;
LABEL_32:
                *(_DWORD *)(a2 + 48) = v32;
                break;
              default:
                return result;
            }
          }
          else
          {
            result = 0;
          }
          break;
        default:
          aj_log_error(0, "Unsupported output format");
          result = 5;
          break;
      }
    }
    else
    {
      aj_log_error(0, "Output cannot be NULL");
      return 8;
    }
  }
  return result;
}

uint64_t aj_huffman_decode_ac_s2(uint64_t a1, uint64_t a2, _QWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t result;
  unsigned __int8 *v19;
  int v20;
  int v21;
  int v22;
  BOOL v23;
  int v24;
  unsigned __int8 *v25;
  int v27;
  int v28;
  unsigned int v29;
  signed int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _DWORD *v40;
  uint64_t v41;
  unsigned int *v42;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = 0;
  a3[6] = 0;
  a3[7] = 0;
  LODWORD(v6) = 1;
  v7 = a1 + 48;
  v8 = *(_QWORD *)(a1 + 696);
  v9 = *(_DWORD *)a2;
  v10 = *(_DWORD *)(a2 + 28);
  v11 = *(_QWORD *)(a1 + 40) + 400;
  v12 = *(_DWORD *)(a2 + 24);
  v13 = *(_DWORD *)a2 >> 23;
  v14 = *(unsigned int *)(v11 + 4 * v13);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (v10)
          {
LABEL_38:
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            v41 = v11;
            v42 = (unsigned int *)a2;
            v39 = a3;
            v40 = a4;
            v37 = a6;
            v38 = v7;
            v35 = v13;
            v36 = v8;
            result = aj_huffman_decode_val_slow(v11 - 400, (unsigned int *)a2, v6, 0, (int *)&v33);
            if ((_DWORD)result)
              return result;
            LODWORD(v6) = v33;
            v32 = (int)v33 >> 16;
            v13 = v35;
            v8 = v36;
            v7 = v38;
            a3 = v39;
            a4 = v40;
            v11 = v41;
            a2 = (uint64_t)v42;
            v10 = v42[7];
            v12 = v42[6];
            v9 = *v42;
            goto LABEL_31;
          }
          v15 = (int)v14 >> 18;
          v16 = v6 + v14;
          if ((v14 & 0x20000) != 0)
            break;
          if (v15)
          {
            v17 = *(_DWORD *)(v7 + 4 * v16) * v15;
            a6 = *(unsigned int *)(v8 + 4 * v16);
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            v13 = v9 >> 23;
            v6 = v16 + 1;
            v14 = *(unsigned int *)(v11 + 4 * v13);
            *(_WORD *)((char *)a3 + a6) = v17;
            if (v12 < 0)
              goto LABEL_15;
LABEL_6:
            if ((int)v6 >= 25)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
          else
          {
            if ((_BYTE)v14)
              v6 = v16 + 1;
            else
              v6 = 64;
            a6 = v14 >> 8;
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            if (v12 < 0)
              goto LABEL_15;
            v13 = v9 >> 23;
            v14 = *(unsigned int *)(v11 + 4 * v13);
            if ((int)v6 >= 25)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
        }
        LODWORD(v6) = v16 - v14;
        a6 = v14 & 0x10000;
        if ((v14 & 0x10000) != 0)
          goto LABEL_38;
        v28 = BYTE1(v14);
        v29 = v14 >> 18;
        v12 -= v28;
        v9 <<= v28;
        v6 = v6 + (v29 >> 4);
        v14 = v29 & 0xF;
        if (!(_DWORD)v14)
          goto LABEL_32;
        if (v12 + 9 < (int)v14)
        {
          *(_DWORD *)(a2 + 24) = v12;
          *(_DWORD *)a2 = v9;
          v41 = v11;
          v42 = (unsigned int *)a2;
          v39 = a3;
          v40 = a4;
          v37 = (v12 + 9);
          v38 = v7;
          v35 = v6;
          v36 = v13;
          v33 = v8;
          v34 = v14;
          result = aj_istream_fill_buf(a2, (int)v14 - 9);
          if ((_DWORD)result)
            return result;
          v8 = v33;
          LODWORD(v14) = v34;
          LODWORD(v6) = v35;
          v13 = v36;
          v7 = v38;
          a3 = v39;
          a4 = v40;
          v11 = v41;
          a2 = (uint64_t)v42;
          v10 = v42[7];
          v12 = v42[6];
          v9 = *v42;
        }
        v12 -= v14;
        v30 = v9 >> (32 - v14);
        v9 <<= v14;
        v31 = 1 << (v14 - 1);
        LOWORD(v32) = v30 < v31 ? v30 + 1 - 2 * v31 : (unsigned __int16)v30;
LABEL_31:
        v14 = *(unsigned int *)(v7 + 4 * v6);
        a6 = *(unsigned int *)(v8 + 4 * v6);
        v6 = (v6 + 1);
        *(_WORD *)((char *)a3 + a6) = v14 * v32;
LABEL_32:
        if (v12 < 0)
          break;
        v13 = v9 >> 23;
        v14 = *(unsigned int *)(v11 + 4 * v13);
        if ((int)v6 >= 25)
        {
          *(_DWORD *)a2 = v9;
          *(_DWORD *)(a2 + 24) = v12;
          *a4 = v6;
          return 0;
        }
      }
      if (v10)
        goto LABEL_6;
LABEL_15:
      a6 = *(unsigned int *)(a2 + 32);
      v19 = *(unsigned __int8 **)(a2 + 8);
      if ((int)a6 < 8)
        break;
      v20 = *v19;
      v21 = v19[1];
      v23 = v20 == 255;
      v22 = v21 + (v20 << 8);
      v23 = v23 || v21 == 255;
      v24 = v19[2];
      v25 = v19 + 3;
      a6 = (a6 - 3);
      v14 = (v24 + (v22 << 8));
      if (v23 || v24 == 255)
        break;
      v27 = ~v12;
      *(_DWORD *)(a2 + 32) = a6;
      *(_QWORD *)(a2 + 8) = v25;
      v9 |= (_DWORD)v14 << v27;
      v12 = 23 - v27;
      v13 = v9 >> 23;
      v14 = *(unsigned int *)(v11 + 4 * v13);
      if ((int)v6 >= 25)
      {
        *(_DWORD *)a2 = v9;
        *(_DWORD *)(a2 + 24) = v12;
        *a4 = v6;
        return 0;
      }
    }
    *(_DWORD *)a2 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    v41 = v11;
    v42 = (unsigned int *)a2;
    v39 = a3;
    v40 = a4;
    v37 = a6;
    v38 = v7;
    v35 = v6;
    v36 = v13;
    v33 = v8;
    v34 = v14;
    result = aj_istream_fill_buf(a2, -9);
    if ((_DWORD)result)
      return result;
    v8 = v33;
    LODWORD(v6) = v35;
    a6 = v37;
    v7 = v38;
    a3 = v39;
    a4 = v40;
    v11 = v41;
    a2 = (uint64_t)v42;
    v10 = v42[7];
    v12 = v42[6];
    v9 = *v42;
    v13 = *v42 >> 23;
    v14 = *(unsigned int *)(v41 + 4 * v13);
  }
  while ((int)v35 < 25);
  *v42 = v9;
  *(_DWORD *)(a2 + 24) = v12;
  *a4 = v6;
  return 0;
}

uint64_t sub_20625C6C0(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, int a5, uint64_t a6, int a7)
{
  int v7;

  *a2 = a7;
  a2[6] = a5;
  *a4 = v7;
  return 7;
}

uint64_t aj_fill_coeffblock_from_scan_properties(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v7;
  signed int v8;
  uint64_t v9;
  unsigned int v10;
  _BOOL4 v11;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  _WORD *v19;
  int v20;
  int v21;

  v3 = *a1;
  if ((int)v3 >= 1 && (int)v3 <= a3)
  {
    v7 = 0;
    while (1)
    {
      v8 = a1[v7 + 1];
      if (v8 > 3
        || v7 && (v8 <= (int)a1[1] || v7 >= 2 && (v8 <= (int)a1[2] || v7 >= 3 && v8 <= (int)a1[3])))
      {
        break;
      }
      if (v3 == ++v7)
      {
        v9 = a1[5];
        if (v9 <= 0x3F)
        {
          v10 = a1[6];
          if (v10 <= 0x3F)
          {
            v11 = v10 && (_DWORD)v9 == 0;
            if ((!(_DWORD)v9 || (_DWORD)v3 == 1) && v9 <= v10 && !v11)
            {
              v13 = a1[8];
              if (v13 <= 0xD)
              {
                v14 = a1[7];
                if (v14 <= 0xD && (!v14 || v14 == v13 + 1))
                {
                  v15 = 0;
                  v16 = (unsigned __int16)(0xFFFF << v13);
                  v17 = 1 << v13;
                  if (v14)
                    v18 = v17;
                  else
                    v18 = v16;
                  while (v9 > v10)
                  {
LABEL_39:
                    v5 = 0;
                    if (++v15 == v3)
                      return v5;
                  }
                  v19 = (_WORD *)(a2 + 2 * v9 + ((uint64_t)(int)a1[v15 + 1] << 7));
                  v20 = v10 - v9 + 1;
                  while (1)
                  {
                    v21 = (unsigned __int16)*v19;
                    if ((v18 & v21) != 0)
                      break;
                    *v19++ = v21 | v18;
                    if (!--v20)
                      goto LABEL_39;
                  }
                }
              }
            }
          }
        }
        break;
      }
    }
  }
  aj_log_error((uint64_t)"Utils", "The progressive scan set-up is illegal or contains errors");
  return 4;
}

uint64_t aj_fill_coeffblock_from_scan_info(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v5;
  int32x4_t v6;
  unsigned int v8;
  _QWORD v9[2];
  int32x4_t v10;

  v9[0] = 0;
  v9[1] = 0;
  v5 = *a1;
  v8 = v5;
  v6 = vrev64q_s32(*(int32x4_t *)(a1 + 13));
  v6.i64[0] = *(_QWORD *)(a1 + 13);
  v10 = v6;
  if ((int)v5 >= 1)
    memcpy(v9, a1 + 1, 4 * v5);
  return aj_fill_coeffblock_from_scan_properties(&v8, a2, a3);
}

uint64_t estimate_jpeg_size(int a1, int a2)
{
  unint64_t v2;

  v2 = a2 * (uint64_t)a1;
  if (v2 <= 1)
    return 1;
  else
    return v2 >> 1;
}

void aj_clear_blocks(void *a1, int a2)
{
  bzero(a1, a2 << 7);
}

uint64_t aj_row_translate(unsigned int a1, int a2, int a3, uint64_t a4, signed int a5, int a6, int a7, int a8, char *a9, unint64_t a10)
{
  _BOOL4 v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  char *v17;
  int v18;
  int v19;
  unint64_t v20;
  uint64_t v22;
  int v23;
  _BYTE *v24;
  char v25;
  uint64_t v26;
  uint64_t result;
  int v28;
  _BYTE *v29;
  int v30;
  _BYTE *v31;
  int v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;

  v10 = (a1 & 3) > 1;
  if ((a1 & 2) != 0)
    v11 = 90 * (a1 & 3) - 180;
  else
    v11 = 90 * (a1 & 3);
  if (v11 == 90)
    v12 = a7;
  else
    v12 = a3;
  v13 = v12 * (uint64_t)a2;
  if (a4)
    v13 = a4;
  if (v11 == 90)
    v14 = a3;
  else
    v14 = a7;
  if (a5 < 0 || (LODWORD(v15) = a3 - a6, a3 < a6))
  {
    aj_log_error((uint64_t)"Utils", "%d %d %d", a5, a6, a3);
    return 8;
  }
  v17 = a9;
  v18 = (a1 >> 2) & 1 ^ v10;
  v19 = (a1 >> 3) & 1 ^ v10;
  if (!v11)
  {
    if (v18 && v19)
    {
      a8 = ~a8 + a7;
    }
    else if (!v18)
    {
      if (v19)
        v34 = ~a8 + a7;
      else
        v34 = a8;
      memcpy((void *)(a10 + v13 * v34 + a5 * (uint64_t)a2), a9, (a6 - a5) * a2);
      return 0;
    }
    v22 = v13 * a8 + a3 * a2;
    v13 = -a2;
    goto LABEL_28;
  }
  v20 = a10 + v13 * v14;
  if ((unint64_t)&a9[a3 * (uint64_t)a2] >= a10 && v20 >= (unint64_t)a9)
    return 8;
  if (v11 != 90)
    return 3;
  if (v18 && v19)
  {
    v26 = v13 * (a3 - 1) + a8 * a2;
    goto LABEL_58;
  }
  if (v18)
  {
    v26 = a8 * a2;
    goto LABEL_58;
  }
  v35 = (~a8 + a7) * a2;
  if (v19)
  {
    v26 = v35 + v13 * (a3 - 1);
LABEL_58:
    if (v19)
      v13 = -v13;
    v22 = v26 - v13;
    if (!v19)
      goto LABEL_63;
LABEL_28:
    v15 = (int)v15;
    goto LABEL_29;
  }
  v22 = v35 - v13;
LABEL_63:
  v15 = a5;
LABEL_29:
  switch(a2)
  {
    case 1:
      v23 = a6 - a5;
      if (a6 <= a5)
        return 0;
      v24 = (_BYTE *)(a10 + v13 + v13 * v15 + v22);
      result = 0;
      do
      {
        v25 = *v17++;
        *v24 = v25;
        v24 += v13;
        --v23;
      }
      while (v23);
      break;
    case 2:
      v28 = a6 - a5;
      if (a6 <= a5)
        return 0;
      v29 = (_BYTE *)(v22 + v13 + v13 * v15 + a10 + 1);
      result = 0;
      do
      {
        *(v29 - 1) = *v17;
        *v29 = v17[1];
        v29 += v13;
        v17 += 2;
        --v28;
      }
      while (v28);
      break;
    case 3:
      v30 = a6 - a5;
      if (a6 <= a5)
        return 0;
      v31 = (_BYTE *)(v22 + v13 + v13 * v15 + a10 + 2);
      result = 0;
      do
      {
        *(v31 - 2) = *v17;
        *(v31 - 1) = v17[1];
        *v31 = v17[2];
        v31 += v13;
        v17 += 3;
        --v30;
      }
      while (v30);
      break;
    case 4:
      v32 = a6 - a5;
      if (a6 <= a5)
        return 0;
      v33 = (_BYTE *)(v22 + v13 + v13 * v15 + a10 + 1);
      result = 0;
      do
      {
        *(v33 - 1) = *v17;
        *v33 = v17[1];
        v33[1] = v17[2];
        v33[2] = v17[3];
        v33 += v13;
        v17 += 4;
        --v32;
      }
      while (v32);
      break;
    default:
      return 0;
  }
  return result;
}

void *aj_paint_region(void *result, int a2, char *a3, int a4, int a5, uint64_t a6, int a7, int *a8)
{
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  unint64_t v28;
  int v29;
  int v31;
  size_t v32;
  char *v33;
  char *v34;
  _BYTE *v35;
  uint64_t v36;
  char *v37;
  _BYTE *v38;
  char v39;

  v10 = *a8;
  v11 = a8[1];
  v12 = a8[2] + *a8;
  v13 = a8[3] + v11;
  v14 = a7 - v13;
  v15 = a7 - v11;
  v16 = a5 - v12;
  v17 = a5 - *a8;
  if (a2 == 270)
    v18 = a5 - v12;
  else
    v18 = 0;
  if (a2 == 270)
    v19 = a5 - *a8;
  else
    v19 = 0;
  if (a2 == 270)
    v20 = a8[1];
  else
    v20 = 0;
  if (a2 == 270)
    v21 = a8[3] + v11;
  else
    v21 = 0;
  if (a2 == 180)
  {
    v18 = a7 - v13;
    v19 = a7 - v11;
    v20 = v16;
  }
  else
  {
    v17 = v21;
  }
  if (a2 == 90)
    v22 = *a8;
  else
    v22 = 0;
  if (a2 == 90)
    v23 = a8[2] + *a8;
  else
    v23 = 0;
  if (a2 != 90)
  {
    v14 = 0;
    v15 = 0;
  }
  if (a2)
  {
    v11 = v22;
    v13 = v23;
    v10 = v14;
    v12 = v15;
  }
  if (a2 <= 179)
    LODWORD(v24) = v11;
  else
    LODWORD(v24) = v18;
  if (a2 <= 179)
    v25 = v13;
  else
    v25 = v19;
  if (a2 <= 179)
  {
    v26 = v12;
  }
  else
  {
    v10 = v20;
    v26 = v17;
  }
  if (a4 < 2)
    goto LABEL_42;
  v27 = *a3;
  v28 = 1;
  do
    v29 = a3[v28++];
  while (v28 < a4 && v29 == v27);
  if (v29 == v27)
  {
LABEL_42:
    v31 = v25 - v24;
    if (v25 > (int)v24)
    {
      v32 = (v26 - v10) * a4;
      v33 = (char *)result + a6 * (int)v24 + v10 * a4;
      do
      {
        result = memset(v33, *a3, v32);
        v33 += a6;
        --v31;
      }
      while (v31);
    }
  }
  else if (v25 > (int)v24)
  {
    v24 = (int)v24;
    v34 = (char *)result + a6 * (int)v24 + v10 * (uint64_t)a4;
    do
    {
      v35 = v34;
      result = (void *)v10;
      if (v26 > v10)
      {
        do
        {
          v36 = a4;
          v37 = a3;
          v38 = v35;
          do
          {
            v39 = *v37++;
            *v38++ = v39;
            --v36;
          }
          while (v36);
          result = (char *)result + 1;
          v35 += a4;
        }
        while (result != (void *)v26);
      }
      ++v24;
      v34 += a6;
    }
    while (v24 != v25);
  }
  return result;
}

uint64_t aj_get_texture_size(_DWORD *a1, uint64_t a2, uint64_t a3, int a4, _QWORD *a5, uint64_t a6, _QWORD *a7)
{
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unint64_t v35;
  BOOL v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t result;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  int v44;
  int v45;
  int v46;

  v7 = *(_DWORD *)(a2 + 76);
  v9 = a1[2];
  v8 = a1[3];
  v10 = *(_DWORD *)(a2 + 24);
  if (v10 == -1)
  {
    v12 = *(_DWORD *)(a2 + 20);
    v11 = *(_DWORD *)(a2 + 12);
    if (v12 == -1)
    {
      if (v11 == -1)
      {
        v12 = -1;
        if (*(_DWORD *)(a2 + 16) == -1)
        {
          v16 = 0;
          v11 = 0;
          v13 = -1;
          v14 = a1[2];
          v15 = a1[3];
          goto LABEL_9;
        }
        v11 = -1;
      }
      else
      {
        v12 = -1;
      }
    }
  }
  else
  {
    v11 = *(_DWORD *)(a2 + 12);
    v12 = *(_DWORD *)(a2 + 20);
  }
  v13 = v12;
  v12 = *(_DWORD *)(a2 + 16);
  v14 = v13;
  v15 = *(_DWORD *)(a2 + 24);
  v16 = v12;
LABEL_9:
  v17 = a1[4];
  v18 = 8 * v17;
  v19 = a1[8];
  v20 = 8 * v19;
  v21 = v11 / (8 * v17);
  v22 = v16 / (8 * v19);
  v23 = (v14 + v11 - 1) / (8 * v17) - v21 + 1;
  v24 = (v15 + v16 - 1) / (8 * v19) - v22 + 1;
  if (v7 != 8 && *a1 != 1)
  {
    v17 = 2;
    v19 = 2;
  }
  v25 = v23 * v18 / v7;
  v26 = v24 * v20 / v7;
  *(_QWORD *)a3 = v25;
  *(_QWORD *)(a3 + 8) = v26;
  if (a4)
  {
    v25 = (v25 + 8 * v17 - 1) & (-8 * v17);
    v26 = (v26 + 8 * v19 - 1) & (-8 * v19);
    *(_QWORD *)a3 = v25;
    *(_QWORD *)(a3 + 8) = v26;
  }
  v27 = v25 / v17;
  v28 = v26 / v19;
  *(_QWORD *)(a3 + 32) = v27;
  *(_QWORD *)(a3 + 40) = v28;
  if (v10 != -1)
  {
    v29 = *(_DWORD *)(a2 + 12);
LABEL_16:
    v30 = (v29 - v21 * v18) / v7;
    v31 = (v12 - v22 * v20) / v7;
    *(_DWORD *)(a3 + 16) = v30;
    *(_DWORD *)(a3 + 20) = v31;
    *(_DWORD *)(a3 + 48) = v30 / v17;
    *(_DWORD *)(a3 + 52) = v31 / v19;
    v32 = v13 / v7;
    *(_DWORD *)(a3 + 56) = v13 / v7 / v17;
    v33 = v10 / v7;
    *(_DWORD *)(a3 + 24) = v32;
    *(_DWORD *)(a3 + 28) = v33;
    v34 = v33 / v19;
    goto LABEL_17;
  }
  v29 = *(_DWORD *)(a2 + 12);
  if (v13 != -1 || v29 != -1)
    goto LABEL_16;
  if (v12 != -1)
  {
    v29 = -1;
    goto LABEL_16;
  }
  *(_QWORD *)(a3 + 16) = 0;
  v44 = v9 / v7;
  v34 = v8 / v7;
  *(_DWORD *)(a3 + 24) = v44;
  *(_DWORD *)(a3 + 28) = v34;
  *(_QWORD *)(a3 + 48) = 0;
  if (v17 == 2)
  {
    if (v44 >= -1)
      v45 = v44 + 1;
    else
      v45 = v44 + 2;
    v44 = v45 >> 1;
  }
  *(_DWORD *)(a3 + 56) = v44;
  if (v19 == 2)
  {
    if (v34 >= -1)
      v46 = v34 + 1;
    else
      v46 = v34 + 2;
    v34 = v46 >> 1;
  }
LABEL_17:
  *(_DWORD *)(a3 + 60) = v34;
  v35 = *(_QWORD *)(a2 + 40);
  if (v35)
  {
    v36 = v35 >= v25;
    v25 = *(_QWORD *)(a2 + 40);
    if (!v36)
      return 5;
  }
  v37 = *(_QWORD *)(a2 + 48);
  v38 = v27;
  if (v37)
  {
    v38 = *(_QWORD *)(a2 + 48);
    if (v37 < v27)
      return 5;
  }
  v39 = *(_QWORD *)(a2 + 56);
  if (v39)
  {
    v36 = v39 >= v27;
    v27 = *(_QWORD *)(a2 + 56);
    if (!v36)
      return 5;
  }
  v41 = v25 * v26;
  v42 = v38 * v28;
  v43 = v27 * v28;
  if (a6)
  {
    *(_QWORD *)a6 = v41;
    *(_QWORD *)(a6 + 8) = v42;
    *(_QWORD *)(a6 + 16) = v43;
    *(_DWORD *)(a6 + 32) = 3;
  }
  if (a5)
    *a5 = v42 + v41 + v43;
  result = 0;
  if (a7)
    *a7 = 8 * (v38 + v25 * v19 + v27);
  return result;
}

unsigned int **aj_reset_texture_buffer_ptrs(unsigned int **result, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _DWORD v15[3];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v3 = *result;
  v4 = *((_DWORD *)result + 43);
  v15[0] = v4;
  if (*((_DWORD *)result + 1721))
    v5 = 8 / *((_DWORD *)result + 42);
  else
    v5 = v4 / 2;
  v15[1] = v5;
  v15[2] = v5;
  v6 = *v3;
  if ((int)v6 >= 1)
  {
    v7 = 0;
    v8 = (_QWORD *)(a2 + 8);
    do
    {
      v9 = *(_QWORD *)(a3 + 8 * v7);
      *(_QWORD *)(a2 + (v7 << 7)) = v9;
      v10 = v15[v7];
      if ((int)v10 >= 2)
      {
        v11 = result[v7 + 12];
        v12 = (uint64_t)v11 + v9;
        v13 = v10 - 1;
        v14 = v8;
        do
        {
          *v14++ = v12;
          v12 += (uint64_t)v11;
          --v13;
        }
        while (v13);
      }
      ++v7;
      v8 += 16;
    }
    while (v7 != v6);
  }
  return result;
}

uint64_t aj_get_jpeg_format_from_subsampling(uint64_t a1, int a2)
{
  if (a2 == 1)
    return 4;
  switch(a1)
  {
    case 0x100000001:
      return 0;
    case 0x100000002:
      return 1;
    case 0x200000001:
      return 2;
  }
  if (HIDWORD(a1) == 2 && (_DWORD)a1 == 2)
    return 3;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aj_get_subsampling_from_jpeg_format(signed int a1)
{
  if (a1 > 4)
    return 0;
  else
    return qword_20627BAE0[a1] | qword_20627BAB8[a1];
}

uint64_t aj_transforms_from_orientation(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4;
  uint64_t result;

  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  v4 = a1 - 1;
  result = 0;
  switch(v4)
  {
    case 0:
      return result;
    case 1:
      result = 0;
      goto LABEL_7;
    case 2:
      result = 0;
      goto LABEL_12;
    case 3:
      result = 0;
      goto LABEL_13;
    case 4:
      result = 0;
      *a2 = 90;
LABEL_7:
      *a3 = 1;
      return result;
    case 5:
      result = 0;
      *a2 = 90;
      return result;
    case 6:
      result = 0;
      *a2 = 90;
      goto LABEL_13;
    case 7:
      result = 0;
      *a2 = 90;
LABEL_12:
      *a3 = 1;
LABEL_13:
      *a4 = 1;
      break;
    default:
      aj_log_error((uint64_t)"Utils", "Illegal display orientation option: %d", 0);
      result = 5;
      break;
  }
  return result;
}

__int128 *aj_internal_upsample_422(unint64_t *a1, char *a2, int a3, double a4, double a5, double a6, double a7, int64x2_t a8, int64x2_t a9)
{
  uint64x2_t v9;
  uint64x2_t v10;
  unsigned int v11;
  unsigned int v12;
  __int128 *result;
  int8x8_t i;
  __int128 v15;
  int16x8_t v16;
  int16x8_t v17;
  uint8x8_t v18;
  int8x8_t v19;
  int16x8_t v20;
  int v21;
  uint8x8_t v22;
  uint64x2_t v23;
  int16x8_t v24;
  BOOL v25;
  int8x8x2_t v26;
  int8x16x2_t v27;

  v11 = a3 - 1;
  v12 = v11 >> 4;
  a8.i64[0] = *a1;
  result = (__int128 *)(a1 + 1);
  for (i = (int8x8_t)vshlq_n_s64(a8, 0x38uLL).u64[0]; v12; a2 += 32)
  {
    v15 = *result++;
    a9.i64[0] = *((_QWORD *)&v15 + 1);
    v16 = (int16x8_t)vmull_u8(*(uint8x8_t *)a8.i8, (uint8x8_t)0x303030303030303);
    v17 = (int16x8_t)vmull_u8(*(uint8x8_t *)&v15, (uint8x8_t)0x303030303030303);
    *(uint8x8_t *)v27.val[0].i8 = vqrshrn_n_u16(vaddw_u8((uint16x8_t)v16, (uint8x8_t)vext_s8(i, *(int8x8_t *)a8.i8, 7uLL)), 2uLL);
    *(uint8x8_t *)v27.val[1].i8 = vqshrn_n_u16((uint16x8_t)vaddq_s16(v16, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(*(int8x8_t *)a8.i8, *(int8x8_t *)&v15, 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
    --v12;
    v27.val[0].u64[1] = (unint64_t)vqrshrn_n_u16(vaddw_u8((uint16x8_t)v17, (uint8x8_t)vext_s8(*(int8x8_t *)a8.i8, *(int8x8_t *)&v15, 7uLL)), 2uLL);
    v27.val[1].u64[1] = (unint64_t)vqshrn_n_u16((uint16x8_t)vaddq_s16(v17, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(*(int8x8_t *)&v15, *(int8x8_t *)((char *)&v15 + 8), 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
    i = (int8x8_t)v15;
    a8 = a9;
    vst2q_s8(a2, v27);
  }
  if ((v11 & 8) != 0)
  {
    v18 = (uint8x8_t)vext_s8(i, *(int8x8_t *)a8.i8, 7uLL);
    i = *(int8x8_t *)a8.i8;
    v19 = *(int8x8_t *)result;
    result = (__int128 *)((char *)result + 8);
    *(int8x8_t *)a8.i8 = v19;
    v20 = (int16x8_t)vmull_u8((uint8x8_t)i, (uint8x8_t)0x303030303030303);
    v26.val[0] = (int8x8_t)vqrshrn_n_u16(vaddw_u8((uint16x8_t)v20, v18), 2uLL);
    v26.val[1] = (int8x8_t)vqshrn_n_u16((uint16x8_t)vaddq_s16(v20, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(i, v19, 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
    vst2_s8(a2, v26);
    a2 += 16;
  }
  v21 = v11 - 8 * (v11 >> 3);
  v22 = (uint8x8_t)vext_s8(i, *(int8x8_t *)a8.i8, 7uLL);
  v23 = (uint64x2_t)a8;
  v24 = (int16x8_t)vmull_u8(*(uint8x8_t *)a8.i8, (uint8x8_t)0x303030303030303);
  *(uint8x8_t *)v9.i8 = vqrshrn_n_u16(vaddw_u8((uint16x8_t)v24, v22), 2uLL);
  *(uint8x8_t *)v10.i8 = vqshrn_n_u16((uint16x8_t)vaddq_s16(v24, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(*(int8x8_t *)a8.i8, *(int8x8_t *)a8.i8, 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
  if (v11 != 8 * (v11 >> 3))
  {
    do
    {
      *a2 = v9.i8[0];
      a2[1] = v10.i8[0];
      a2 += 2;
      v9 = vshrq_n_u64(v9, 8uLL);
      v10 = vshrq_n_u64(v10, 8uLL);
      v23 = vshrq_n_u64(v23, 8uLL);
      v25 = __OFSUB__(v21--, 1);
    }
    while (!((v21 < 0) ^ v25 | (v21 == 0)));
  }
  *a2 = v9.i8[0];
  a2[1] = v23.i8[0];
  return result;
}

uint8x16_t **aj_icol_row_420_to_rgba(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint64x2_t v7;
  uint64x2_t v8;
  uint64x2_t v9;
  uint64x2_t v10;
  uint8x8_t v11;
  unint64_t v12;
  uint8x16_t *v13;
  uint8x8_t *v14;
  uint8x8_t *v15;
  unsigned int v16;
  uint8x16_t *j;
  uint8x16_t v18;
  uint8x16_t v19;
  uint8x8_t v20;
  uint8x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  char *v34;
  int16x8_t v35;
  int16x8_t v36;
  char *v37;
  int16x8_t v38;
  unsigned int v39;
  uint64x2_t v40;
  uint64x2_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int16x8_t v56;
  unsigned int i;
  uint8x16_t v58;
  uint8x8_t v59;
  uint8x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  int16x8_t v63;
  int16x8_t v64;
  int16x8_t v65;
  int16x8_t v66;
  char *v67;
  int16x8_t v68;
  unsigned int v69;
  uint64x2_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int8x8x4_t v84;
  int8x8x4_t v85;
  int8x8x4_t v86;
  int8x8x4_t v87;

  v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  v12 = vdupq_n_s8(0xFFu).u64[0];
  if (a6 >= 1)
  {
    v13 = *result;
    v14 = *a2;
    v15 = *a3;
    if (a6 == 1)
    {
      for (i = a7 >> 4; i; --i)
      {
        v58 = *v13++;
        v59 = *v14++;
        v60 = *v15++;
        v61 = (int16x8_t)vsubl_u8(v59, v11);
        v62 = (int16x8_t)vsubl_u8(v60, v11);
        v63 = vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 3);
        v64 = vmulq_n_s16(v62, 179);
        v65 = vqaddq_s16(vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 2));
        v66 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v58.i8, 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v63, v63)), 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v66, vzip1q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v86);
        v67 = a4 + 32;
        v68 = (int16x8_t)vshll_high_n_u8(v58, 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v63, v63)), 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v68, vzip2q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(v67, v86);
        a4 = v67 + 32;
      }
      v69 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v70 = *(uint64x2_t *)v13;
        v71 = (int16x8_t)vsubl_u8(*v14, v11);
        v72 = (int16x8_t)vsubl_u8(*v15, v11);
        v73 = vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 3);
        v74 = vmulq_n_s16(v72, 179);
        v75 = vqaddq_s16(vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v72, (int16x4_t)0xE3005B002C00B3, 2));
        v76 = vzip2q_s16(v73, v73);
        v77 = vzip2q_s16(v74, v74);
        v78 = vzip2q_s16(v75, v75);
        v79 = vzip1q_s16(v73, v73);
        v80 = vzip1q_s16(v74, v74);
        v81 = vzip1q_s16(v75, v75);
        if (!(v69 >> 3))
          goto LABEL_16;
        v82 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
        v87.val[2] = vqrshrun_n_s16(vqaddq_s16(v82, v79), 7uLL);
        v87.val[0] = vqrshrun_n_s16(vqaddq_s16(v82, v80), 7uLL);
        v87.val[1] = vqrshrun_n_s16(vqsubq_s16(v82, v81), 7uLL);
        v87.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v87);
        a4 += 32;
        v79 = v76;
        v80 = v77;
        v81 = v78;
        v70.i64[0] = v70.i64[1];
        v69 -= 8;
        if (v69)
        {
LABEL_16:
          v83 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v79), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v80), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v83, v81), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            v9 = vshrq_n_u64(v9, 8uLL);
            --v69;
          }
          while (v69);
        }
      }
    }
    else
    {
      v16 = a7 >> 4;
      for (j = result[1]; v16; --v16)
      {
        v18 = *v13++;
        v19 = *j++;
        v20 = *v14++;
        v21 = *v15++;
        v22 = (int16x8_t)vsubl_u8(v20, v11);
        v23 = (int16x8_t)vsubl_u8(v21, v11);
        v24 = vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3);
        v25 = vmulq_n_s16(v23, 179);
        v26 = vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2));
        v27 = vzip2q_s16(v24, v24);
        v28 = vzip2q_s16(v25, v25);
        v29 = vzip2q_s16(v26, v26);
        v30 = vzip1q_s16(v24, v24);
        v31 = vzip1q_s16(v25, v25);
        v32 = vzip1q_s16(v26, v26);
        v33 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v18.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v33, v30), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v33, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v33, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v84);
        v34 = a4 + 32;
        v35 = (int16x8_t)vshll_high_n_u8(v18, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v35, v27), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v35, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v35, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v34, v84);
        a4 = v34 + 32;
        v36 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v19.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v36, v30), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v36, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v36, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v84);
        v37 = a5 + 32;
        v38 = (int16x8_t)vshll_high_n_u8(v19, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v38, v27), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v38, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v38, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v37, v84);
        a5 = v37 + 32;
      }
      v39 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v40 = *(uint64x2_t *)v13;
        v41 = *(uint64x2_t *)j;
        v42 = (int16x8_t)vsubl_u8(*v14, v11);
        v43 = (int16x8_t)vsubl_u8(*v15, v11);
        v44 = vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 3);
        v45 = vmulq_n_s16(v43, 179);
        v46 = vqaddq_s16(vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v43, (int16x4_t)0xE3005B002C00B3, 2));
        v47 = vzip2q_s16(v44, v44);
        v48 = vzip2q_s16(v45, v45);
        v49 = vzip2q_s16(v46, v46);
        v50 = vzip1q_s16(v44, v44);
        v51 = vzip1q_s16(v45, v45);
        v52 = vzip1q_s16(v46, v46);
        if (!(v39 >> 3))
          goto LABEL_8;
        v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v53, v50), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v53, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v53, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v85);
        a4 += 32;
        v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v54, v50), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v54, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v54, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v85);
        a5 += 32;
        v50 = v47;
        v51 = v48;
        v52 = v49;
        v40.i64[0] = v40.i64[1];
        v41.i64[0] = v41.i64[1];
        v39 -= 8;
        if (v39)
        {
LABEL_8:
          v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v50), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v51), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v55, v52), 7uLL);
          v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
          *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v50), 7uLL);
          *(int8x8_t *)v40.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v51), 7uLL);
          *(int8x8_t *)v41.i8 = vqrshrun_n_s16(vqsubq_s16(v56, v52), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            v9 = vshrq_n_u64(v9, 8uLL);
            *a5 = v40.i8[0];
            a5[1] = v41.i8[0];
            a5[2] = v10.i8[0];
            a5[3] = v12;
            a5 += 4;
            v40 = vshrq_n_u64(v40, 8uLL);
            v41 = vshrq_n_u64(v41, 8uLL);
            v10 = vshrq_n_u64(v10, 8uLL);
            --v39;
          }
          while (v39);
        }
      }
    }
  }
  return result;
}

uint64_t aj_huffman_encode_val_lkup(uint64_t a1, int a2, int a3, int32x2_t *a4)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t result;
  unsigned int v14;
  unsigned int v15;
  _BYTE *v16;
  _BYTE *v17;
  int v18;

  if (a3)
  {
    if (a3 >= 0)
      v4 = a3;
    else
      v4 = -a3;
    v5 = HIWORD(v4);
    if (!HIWORD(v4))
      v5 = v4;
    if (v5 <= 0xFF)
      v6 = 16 * (HIWORD(v4) != 0);
    else
      v6 = (16 * (HIWORD(v4) != 0)) | 8;
    if (v5 > 0xFF)
      v5 >>= 8;
    if (v5 > 0xF)
    {
      v6 |= 4u;
      v5 >>= 4;
    }
    if (v5 > 3)
    {
      v6 |= 2u;
      v5 >>= 2;
    }
    v7 = v6 | (v5 > 1);
    v8 = v7 + 1;
    v9 = (-2 << v7) | v4;
    if (a3 < 0)
      v4 = ~v9;
  }
  else
  {
    v4 = 0;
    v8 = 0;
  }
  v10 = v8 + HIWORD(*(_DWORD *)(a1 + 4 * (v8 + 16 * a2)));
  v11 = ((unsigned __int16)*(_DWORD *)(a1 + 4 * (v8 + 16 * a2)) << v8) + v4;
  if (a4[2].i32[1] >= 9 && (v12 = a4->i32[1] + v10, v12 < 33))
  {
    v14 = a4->i32[0] | (v11 << -(char)v12);
    a4->i32[0] = v14;
    a4->i32[1] = v12;
    if (v12 >= 8)
    {
      do
      {
        v15 = HIBYTE(v14);
        v16 = (_BYTE *)a4[1];
        a4[1] = (int32x2_t)(v16 + 1);
        *v16 = v15;
        a4[2] = vadd_s32(a4[2], (int32x2_t)0xFFFFFFFF00000001);
        if (v15 == 255)
        {
          v17 = (_BYTE *)a4[1];
          a4[1] = (int32x2_t)(v17 + 1);
          *v17 = 0;
          a4[2] = vadd_s32(a4[2], (int32x2_t)0xFFFFFFFF00000001);
        }
        v18 = a4->i32[1];
        v14 = a4->i32[0] << 8;
        a4->i32[0] = v14;
        a4->i32[1] = v18 - 8;
      }
      while (v18 > 15);
    }
  }
  else
  {
    result = aj_ostream_write((unsigned int *)a4, v11, v10);
    if ((_DWORD)result)
      return result;
  }
  return 0;
}

uint64_t aj_huffman_encode_sym_lkup(uint64_t a1, int a2, int32x2_t *a3)
{
  int v3;
  unsigned int v4;
  int v5;
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  _BYTE *v9;
  _BYTE *v10;
  int v11;

  v3 = HIWORD(*(_DWORD *)(a1 + 4 * a2));
  v4 = (unsigned __int16)*(_DWORD *)(a1 + 4 * a2);
  if (a3[2].i32[1] >= 9 && (v5 = a3->i32[1] + v3, v5 < 33))
  {
    v7 = a3->i32[0] | (v4 << -(char)v5);
    a3->i32[0] = v7;
    a3->i32[1] = v5;
    if (v5 >= 8)
    {
      do
      {
        v8 = HIBYTE(v7);
        v9 = (_BYTE *)a3[1];
        a3[1] = (int32x2_t)(v9 + 1);
        *v9 = v8;
        a3[2] = vadd_s32(a3[2], (int32x2_t)0xFFFFFFFF00000001);
        if (v8 == 255)
        {
          v10 = (_BYTE *)a3[1];
          a3[1] = (int32x2_t)(v10 + 1);
          *v10 = 0;
          a3[2] = vadd_s32(a3[2], (int32x2_t)0xFFFFFFFF00000001);
        }
        v11 = a3->i32[1];
        v7 = a3->i32[0] << 8;
        a3->i32[0] = v7;
        a3->i32[1] = v11 - 8;
      }
      while (v11 > 15);
    }
  }
  else
  {
    result = aj_ostream_write((unsigned int *)a3, v4, v3);
    if ((_DWORD)result)
      return result;
  }
  return 0;
}

void aj_huffman_encode_init_lookups(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t i;
  unsigned int v10;
  uint64_t v11;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int *v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  uint64_t j;
  uint64_t k;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  _DWORD v33[256];
  _DWORD v34[256];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  bzero(v34, 0x400uLL);
  bzero(v33, 0x400uLL);
  v8 = 0;
  for (i = 1; i != 17; ++i)
  {
    v10 = *(unsigned __int8 *)(i + a1 - 1);
    if (*(_BYTE *)(i + a1 - 1) && v8 <= 255)
    {
      v11 = v8;
      do
      {
        v8 = v11 + 1;
        v34[v11] = i;
        if (v10 < 2)
          break;
        --v10;
      }
      while (v11++ < 255);
    }
  }
  v13 = 0;
  LODWORD(v14) = 0;
  v15 = v34[0];
  while (v34[(int)v14])
  {
    v14 = (int)v14;
    v16 = 2 * v13;
    while (v34[v14] == v15)
    {
      v33[v14] = v13++;
      v16 += 2;
      if (++v14 == 256)
        goto LABEL_17;
    }
    ++v15;
    v13 = v16;
    if ((int)v14 >= 256)
      goto LABEL_17;
  }
  if ((int)v14 < 1)
    goto LABEL_19;
LABEL_17:
  v14 = v14;
  v17 = v33;
  v18 = v34;
  do
  {
    v20 = *v18++;
    v19 = v20;
    v21 = *v17++;
    v22 = v21 | (v19 << 16);
    v23 = *a2++;
    *(_DWORD *)(a3 + 4 * v23) = v22;
    --v14;
  }
  while (v14);
LABEL_19:
  if (a4)
  {
    for (j = 0; j != 8; ++j)
    {
      for (k = 0; k != 32; ++k)
      {
        v26 = k - 16;
        if (k == 16)
        {
          v27 = 0;
        }
        else
        {
          v28 = 16 - k;
          if ((int)k - 16 >= 0)
            v28 = k - 16;
          v29 = HIWORD(v28);
          if (!HIWORD(v28))
            v29 = v28;
          if (v29 <= 0xFF)
            v30 = 16 * (HIWORD(v28) != 0);
          else
            v30 = (16 * (HIWORD(v28) != 0)) | 8;
          if (v29 > 0xFF)
            v29 >>= 8;
          if (v29 > 0xF)
          {
            v30 |= 4u;
            v29 >>= 4;
          }
          if (v29 > 3)
          {
            v30 |= 2u;
            v29 >>= 2;
          }
          v31 = v30 | (v29 > 1);
          v27 = v31 + 1;
          v32 = (-2 << v31) | v28;
          if (v26 < 0)
            LODWORD(v26) = ~v32;
          else
            LODWORD(v26) = v28;
        }
        *(_DWORD *)(a4 + 4 * k) = (((unsigned __int16)*(_DWORD *)(a3 + 4 * (16 * j + v27)) << v27) + v26) | ((v27 + HIWORD(*(_DWORD *)(a3 + 4 * (16 * j + v27)))) << 24);
      }
      a4 += 128;
    }
  }
}

uint64_t aj_lossless_decode_all(int **a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  uint64_t result;
  uint64_t v16;
  int v17;
  BOOL v19;
  __int16 v20;
  _DWORD *v21;
  int *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  char *v32;
  int v33;
  uint64_t v34;
  char *v35;
  int v36;
  _DWORD *v37;
  char *v39;
  _DWORD *v40;
  _DWORD *v41;
  uint64_t v42;
  int v43;
  char *v44;
  int v45;
  int **v46;
  int *v47;
  unint64_t v48;
  int *v49;
  int *v50;
  uint64_t v51;
  char *v52;
  int v53;
  int v54;
  int *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  _OWORD *v61;
  _QWORD *v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  unsigned __int8 *v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  _OWORD *v76;
  uint64_t v77;
  uint64_t v78;
  _OWORD *v79;
  __int16 v80;
  __int16 *v81;
  uint64_t v82;
  _WORD *v83;
  uint64_t v84;
  int v85;
  unsigned int v86;
  __int16 v87;
  __int16 v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  unsigned int v99;
  int v100;
  int v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  __int16 v106;
  int v107;
  _OWORD v108[2];
  __int128 v109;
  _OWORD v110[24];
  _QWORD v111[4];
  __int128 v112;
  _OWORD v113[3];
  uint64_t v114;

  v114 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 112);
  v5 = (uint64_t)*a1;
  v6 = **a1;
  v7 = *((_DWORD *)a1 + 1645);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 4;
  v12 = 1;
  switch(v7)
  {
    case 0u:
    case 0x14u:
    case 0x19u:
    case 0x1Au:
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 3;
      break;
    case 3u:
    case 4u:
    case 0x10u:
    case 0x11u:
    case 0x15u:
      break;
    case 5u:
    case 0x12u:
      v8 = 0;
      v10 = 0;
      v9 = 1;
      v11 = 1;
      break;
    case 0x16u:
    case 0x17u:
      v8 = 0;
      v9 = 0;
      v11 = 2;
      v10 = 1;
      break;
    default:
      v9 = 0;
      v10 = 0;
      v12 = 0;
      v11 = 0;
      v8 = 1;
      break;
  }
  if (v7 > 0x1A)
    goto LABEL_12;
  v13 = 1;
  if (((1 << v7) & 0x4B70000) != 0)
  {
    v13 = 2;
    v14 = 1;
    if (!v8)
      goto LABEL_13;
LABEL_12:
    aj_log_error(0, "Unsupported output format for lossless JPEG");
    return 5;
  }
  if (((1 << v7) & 0x2400039) == 0)
    goto LABEL_12;
  v14 = 0;
  if (v8)
    goto LABEL_12;
LABEL_13:
  if ((int)v6 <= 1)
    v9 = 0;
  if (v9 == 1)
  {
    aj_log_error(0, "Decoding lossless RGB JPEG to grayscale not supported");
    return 5;
  }
  if ((_DWORD)v6 == 2)
    v10 = 0;
  if (v10 == 1)
  {
    aj_log_error(0, "Only two-component JPEGs can be decoded to two-component format");
    return 5;
  }
  if (a1[1][23] >= 7)
  {
    aj_log_error(0, "Max 6 blocks per MCU supported");
    return 3;
  }
  if (*(int *)(v5 + 32) >= 3)
  {
    aj_log_error(0, "Vertical subsampling > 2 not yet supported");
    return 3;
  }
  if (*(int *)(v5 + 16) >= 3)
  {
    aj_log_error(0, "Horizontal subsampling > 2 not yet supported");
    return 3;
  }
  if ((_DWORD)v6 == 3)
  {
    v16 = 0;
    while (*(_DWORD *)(v5 + v16 + 36) == 1 && *(_DWORD *)(v5 + v16 + 20) == 1)
    {
      v16 += 4;
      if (v16 == 8)
        goto LABEL_34;
    }
    aj_log_error(0, "Subsampling not yet supported");
    return 3;
  }
LABEL_34:
  result = aj_istream_move_to_position(v4, *(unsigned int *)(v5 + 3420));
  if (!(_DWORD)result)
  {
    v17 = *((_DWORD *)a1 + 1645);
    memset(&v113[1], 0, 32);
    v19 = v17 == 17 || v17 == 4;
    v112 = 0uLL;
    v113[0] = 0uLL;
    if (v14)
      v20 = -1;
    else
      v20 = 255;
    memset(v111, 0, sizeof(v111));
    v109 = 0uLL;
    memset(v110, 0, sizeof(v110));
    memset(v108, 0, sizeof(v108));
    if ((v17 - 25) >= 2)
    {
      v103 = v11;
      v21 = *a1;
      if (v12)
      {
        v48 = 0;
        v49 = a1[12];
        v50 = a1[8];
        if (v11 <= 1)
          v51 = 1;
        else
          v51 = v11;
        v52 = (char *)&v109 + 4;
        v53 = 2;
        do
        {
          if (v19 && v48 < 3)
            v54 = v53;
          else
            v54 = v48;
          *((_DWORD *)v52 - 1) = v13 * v11;
          *(_DWORD *)v52 = v11;
          *((_DWORD *)v52 + 1) = v54 * v13;
          *((_DWORD *)v52 + 2) = (_DWORD)v49;
          *((_QWORD *)v52 + 2) = 0x100000000;
          *((_DWORD *)v52 + 6) = 2;
          *((_DWORD *)v52 + 7) = v21[847];
          if ((uint64_t)v48 >= v6)
            v52[32] = 1;
          else
            *(_QWORD *)(v52 - 12) = *(_QWORD *)&a1[1][4 * v21[v48 + 839] + 2];
          *((_QWORD *)v113 + v48) = v50;
          v111[v48++] = v49;
          --v53;
          v52 += 72;
        }
        while (v51 != v48);
      }
    }
    else
    {
      v21 = *a1;
      v22 = a1[1];
      v23 = v22[23];
      v103 = v23;
      v24 = (*a1)[8];
      if (v24 >= 1)
      {
        v25 = 0;
        v26 = 0;
        v27 = v21[4];
        while (1)
        {
          if (v27 < 1)
            goto LABEL_64;
          v28 = 0;
          v29 = 0;
          v30 = a1[12];
          v31 = *((unsigned __int8 *)a1 + 6904);
          v32 = (char *)a1[8] + (_QWORD)v30 * v26;
          do
          {
            v33 = v25 * v27;
            v34 = v29 + (int)v26 * v27;
            v35 = (char *)v108 + 72 * v34;
            *((_DWORD *)v35 + 10) = v28;
            v36 = v21[4] * v13;
            *((_DWORD *)v35 + 11) = (_DWORD)v30;
            v37 = v35 + 44;
            *(v37 - 3) = v36;
            *(v37 - 2) = 1;
            if (v33 == (_DWORD)v29 && v31 != 0)
              *v37 = v21[8] * (_DWORD)v30;
            *((_QWORD *)v113 + v34) = v32;
            v111[v34] = (_QWORD)v30 * (int)v21[8];
            v39 = (char *)v108 + 72 * v34;
            *(_QWORD *)(v39 + 52) = 0x100000000;
            v40 = v39 + 52;
            v41 = v40 + 1;
            v40[2] = 2;
            v40[3] = v21[847];
            if (v26 && (_DWORD)v29)
            {
              *v40 = v21[847];
              *v41 = v21[847];
LABEL_57:
              v40[2] = v21[847];
              goto LABEL_60;
            }
            if (v26)
            {
              *v40 = 2;
              *v41 = v21[847];
            }
            else if ((_DWORD)v29)
            {
              *v40 = 1;
              goto LABEL_57;
            }
LABEL_60:
            *((_QWORD *)&v108[1] + 9 * v34 + 1) = *(_QWORD *)&v22[4 * v21[839] + 2];
            v27 = v21[4];
            ++v29;
            v28 += v13;
          }
          while ((int)v29 < v27);
          v24 = v21[8];
LABEL_64:
          ++v26;
          --v25;
          if (v26 >= v24)
          {
            v23 = v22[23];
            break;
          }
        }
      }
      v42 = v22[22];
      if ((int)v42 < v23)
      {
        v43 = v42 + 1;
        v44 = (char *)&v108[2] + 72 * (int)v42;
        do
        {
          v45 = v43 - v22[22];
          v46 = &a1[v45];
          v47 = v46[12];
          *((_QWORD *)v113 + v42) = v46[8];
          v111[v42] = v47;
          *((_DWORD *)v44 + 3) = (_DWORD)v47;
          *(_DWORD *)v44 = v13;
          *(_QWORD *)(v44 + 4) = 1;
          *(_QWORD *)(v44 + 20) = 0x100000000;
          *((_DWORD *)v44 + 7) = 2;
          *((_DWORD *)v44 + 8) = v21[847];
          *((_QWORD *)v44 - 1) = *(_QWORD *)&v22[4 * v21[v45 + 839] + 2];
          ++v43;
          v44 += 72;
          ++v42;
        }
        while (v42 < v22[23]);
      }
    }
    v55 = a1[1];
    v98 = v55[21];
    v56 = v103;
    if ((int)v98 < 1)
    {
      return 0;
    }
    else
    {
      v57 = 0;
      v58 = 0;
      v104 = 0;
      v105 = v21[851];
      v59 = v55[20];
      LOBYTE(v102) = 7;
      v106 = v20;
      v99 = v55[20];
      while (1)
      {
        if (v56)
        {
          v60 = *((int *)a1 + 1650);
          v61 = v108;
          v62 = v113;
          v63 = v111;
          v64 = v56;
          do
          {
            v65 = *v63++;
            v66 = *v62 + v65 * v57 + v60 + *((int *)v61 + 10);
            v67 = v66 - *((int *)v61 + 11);
            *(_QWORD *)v61 = v66;
            *((_QWORD *)v61 + 1) = v67;
            *((_QWORD *)v61 + 2) = v66;
            if (!*((_BYTE *)v61 + 68))
              *((_DWORD *)v61 + 12) = *(_DWORD *)((char *)v61 + ((8 * (v104 != 0)) | 0x34));
            v61 = (_OWORD *)((char *)v61 + 72);
            ++v62;
            --v64;
          }
          while (v64);
        }
        if ((int)v59 >= 1)
          break;
LABEL_146:
        ++*(_DWORD *)(a2 + 36);
        ++v57;
        ++v104;
        if (v57 == v98)
          return 0;
      }
      v68 = 0;
      v69 = 0;
      while (1)
      {
        if (!*(_QWORD *)(v4 + 16) && *(int *)(v4 + 24) <= 6)
        {
          v103 = v56;
          v70 = v68;
          v71 = v58;
          result = aj_istream_fill_buf(v4, -9);
          v59 = v99;
          v58 = v71;
          v68 = v70;
          if ((_DWORD)result)
            return result;
        }
        if (v105 < 1 || v58 != v105)
          goto LABEL_107;
        v72 = *(unsigned __int8 **)(v4 + 16);
        if (!v72)
          break;
        v102 = ((_BYTE)v102 + 1) & 7;
        v73 = *v72;
        if ((v102 | 0xD0) != v73)
        {
          aj_log_error(0, "Bitstream corrupt: Wrong marker (%02X) found.", v73);
          return 7;
        }
        v74 = v59;
        *(_DWORD *)v4 = 0;
        *(_DWORD *)(v4 + 24) = -9;
        *(_QWORD *)(v4 + 16) = 0;
        result = aj_istream_fill_buf(v4, -9);
        if ((_DWORD)result)
          return result;
        if (v56)
        {
          v75 = v56;
          v76 = v110;
          v59 = v74;
          do
          {
            if (!*((_BYTE *)v76 + 20))
              *(_DWORD *)v76 = *((_DWORD *)v76 + 1);
            v76 = (_OWORD *)((char *)v76 + 72);
            --v75;
          }
          while (v75);
          v58 = 0;
          v104 = 0;
          v69 = 0;
LABEL_107:
          if (!v56)
            goto LABEL_145;
          v100 = v68;
          v101 = v58;
          v77 = 12;
          if (!v104)
            v77 = 4;
          v78 = v77 + 52;
          v79 = v108;
          while (2)
          {
            v80 = v20;
            if (*((_BYTE *)v79 + 68))
            {
              if (v14)
                goto LABEL_113;
LABEL_139:
              **((_BYTE **)v79 + 2) = v80;
              v81 = (__int16 *)*((_QWORD *)v79 + 2);
            }
            else
            {
              v82 = -(uint64_t)*((int *)v79 + 9);
              v83 = (_WORD *)*((_QWORD *)v79 + 1);
              v84 = *((_QWORD *)v79 + 2);
              v85 = *((_DWORD *)v79 + 12);
              if (v14)
              {
                switch(v85)
                {
                  case 0:
                    goto LABEL_118;
                  case 1:
                    LOWORD(v86) = *(_WORD *)(v84 - 2 * *((int *)v79 + 9));
                    break;
                  case 2:
                    LOWORD(v86) = *v83;
                    break;
                  case 3:
                    LOWORD(v86) = v83[(int)v82];
                    break;
                  case 4:
                    v87 = *v83 + *(_WORD *)(v84 + 2 * (int)v82);
                    v88 = v83[(int)v82];
                    goto LABEL_130;
                  case 5:
                    v89 = *(unsigned __int16 *)(v84 + 2 * (int)v82);
                    v90 = (unsigned __int16)*v83;
                    v91 = (unsigned __int16)v83[(int)v82];
                    goto LABEL_132;
                  case 6:
                    v92 = (unsigned __int16)*v83;
                    v93 = *(unsigned __int16 *)(v84 + 2 * (int)v82);
                    v94 = (unsigned __int16)v83[(int)v82];
                    goto LABEL_134;
                  case 7:
                    v95 = *(unsigned __int16 *)(v84 + 2 * (int)v82);
                    v96 = (unsigned __int16)*v83;
                    goto LABEL_136;
                  default:
                    goto LABEL_119;
                }
              }
              else
              {
                switch(v85)
                {
                  case 0:
LABEL_118:
                    v86 = 1 << (*((_BYTE *)*a1 + 4) - 1);
                    break;
                  case 1:
                    LOWORD(v86) = *(unsigned __int8 *)(v84 - *((int *)v79 + 9));
                    break;
                  case 2:
                    LOWORD(v86) = *(unsigned __int8 *)v83;
                    break;
                  case 3:
                    LOWORD(v86) = *((unsigned __int8 *)v83 - *((int *)v79 + 9));
                    break;
                  case 4:
                    v87 = *(unsigned __int8 *)v83 + *(unsigned __int8 *)(v84 - *((int *)v79 + 9));
                    v88 = *((unsigned __int8 *)v83 - *((int *)v79 + 9));
LABEL_130:
                    LOWORD(v86) = v87 - v88;
                    break;
                  case 5:
                    v89 = *(unsigned __int8 *)(v84 - *((int *)v79 + 9));
                    v90 = *(unsigned __int8 *)v83;
                    v91 = *((unsigned __int8 *)v83 - *((int *)v79 + 9));
LABEL_132:
                    v86 = v89 + ((v90 - v91) >> 1);
                    break;
                  case 6:
                    v92 = *(unsigned __int8 *)v83;
                    v93 = *(unsigned __int8 *)(v84 - *((int *)v79 + 9));
                    v94 = *((unsigned __int8 *)v83 - *((int *)v79 + 9));
LABEL_134:
                    v86 = v92 + ((v93 - v94) >> 1);
                    break;
                  case 7:
                    v95 = *(unsigned __int8 *)(v84 - *((int *)v79 + 9));
                    v96 = *(unsigned __int8 *)v83;
LABEL_136:
                    v86 = (v96 + v95) >> 1;
                    break;
                  default:
LABEL_119:
                    LOWORD(v86) = 0;
                    break;
                }
              }
              v107 = 0;
              result = aj_huffman_decode_val(*((_QWORD *)v79 + 3), v4, 1, &v107);
              if ((_DWORD)result)
                return result;
              v80 = HIWORD(v107) + v86;
              v20 = v106;
              if (!v14)
                goto LABEL_139;
LABEL_113:
              v81 = (__int16 *)*((_QWORD *)v79 + 2);
              *v81 = v80;
            }
            v97 = *((int *)v79 + 8);
            *((_QWORD *)v79 + 1) += v97;
            *((_QWORD *)v79 + 2) = (char *)v81 + v97;
            if (!v69)
              *((_DWORD *)v79 + 12) = *(_DWORD *)((char *)v79 + v78);
            v79 = (_OWORD *)((char *)v79 + 72);
            if (!--v56)
            {
              v56 = v103;
              v59 = v99;
              v68 = v100;
              v58 = v101;
              goto LABEL_145;
            }
            continue;
          }
        }
        v69 = 0;
        v104 = 0;
        v58 = 0;
        v59 = v74;
LABEL_145:
        ++v68;
        ++v58;
        ++v69;
        if (v68 == (_DWORD)v59)
          goto LABEL_146;
      }
      if (*(int *)(v4 + 32) > 1)
        return 7;
      result = 7;
      if (*(_BYTE *)(v4 + 112))
      {
        if (*(_DWORD *)(v4 + 56) == 1)
          return 4294967294;
        else
          return 7;
      }
    }
  }
  return result;
}

uint64_t aj_get_qtable_for_quality(uint64_t result, int a2, int a3, int a4)
{
  uint64_t v4;
  _DWORD *v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;

  v4 = 0;
  v5 = &base_qtable_luma;
  if (!a3)
    v5 = &base_qtable_chroma;
  v6 = 5000 / a2;
  if (a2 >= 51)
    v6 = 200 - 2 * a2;
  if (a2 > 99)
    v6 = 0;
  do
  {
    if (a4)
      v7 = aj_glob_zigzag[v4];
    else
      v7 = v4;
    v8 = 1374389535 * (v5[v7] * v6 + 50);
    v9 = (v8 >> 37) + ((unint64_t)v8 >> 63);
    if (v9 <= 1)
      v9 = 1;
    if (v9 >= 0xFF)
      v9 = 255;
    *(_DWORD *)(result + 4 * v4++) = v9;
  }
  while (v4 != 64);
  return result;
}

uint8x8_t **aj_icol_row_444_to_rgb(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64x2_t a9, uint64_t a10, uint64_t a11, unsigned int a12)
{
  uint8x8_t v12;
  uint8x8_t *v13;
  uint8x8_t *v14;
  uint8x8_t *v15;
  unsigned int i;
  uint8x8_t v17;
  uint8x8_t v18;
  uint8x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int v26;
  int8x8x3_t v27;

  v12 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  v13 = *result;
  v14 = *a2;
  v15 = *a3;
  for (i = a12 >> 3; i; --i)
  {
    v17 = *v13++;
    v18 = *v14++;
    v19 = *v15++;
    v20 = (int16x8_t)vshll_n_u8(v17, 7uLL);
    v21 = (int16x8_t)vsubl_u8(v18, v12);
    v22 = (int16x8_t)vsubl_u8(v19, v12);
    v27.val[2] = vqrshrun_n_s16(vqaddq_s16(v20, vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    v27.val[0] = vqrshrun_n_s16(vqaddq_s16(v20, vmulq_n_s16(v22, 179)), 7uLL);
    v27.val[1] = vqrshrun_n_s16(vqsubq_s16(v20, vqaddq_s16(vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    vst3_s8(a4, v27);
    a4 += 24;
  }
  if ((a12 & 7) != 0)
  {
    v23 = (int16x8_t)vshll_n_u8(*v13, 7uLL);
    v24 = (int16x8_t)vsubl_u8(*v14, v12);
    v25 = (int16x8_t)vsubl_u8(*v15, v12);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v23, vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v23, vmulq_n_s16(v25, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v23, vqaddq_s16(vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v25, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    v26 = a12 & 7;
    do
    {
      *a4 = a7.i8[0];
      a4[1] = a8.i8[0];
      a4[2] = a9.i8[0];
      a4 += 3;
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      a9 = vshrq_n_u64(a9, 8uLL);
      --v26;
    }
    while (v26);
  }
  return result;
}

uint64_t aj_idct_s1_8x16_nearest(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  int16x8_t v59;
  int16x8_t v60;
  int16x8_t v61;
  int16x8_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int16x8_t v70;
  int16x8_t v71;
  int16x8_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int16x8_t v85;
  int16x8_t v86;
  int16x8_t v87;
  int16x8_t v88;
  int16x8_t v89;
  int16x8_t v90;
  int16x8_t v91;
  int16x8_t v92;
  int16x8_t v93;
  int16x8_t v94;
  int16x8_t v95;
  int16x8_t v96;
  int16x8_t v97;
  int16x8_t v98;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = vaddq_s16(v8, v4);
  v10 = vaddq_s16(*a1, v6);
  v11 = vsubq_s16(*a1, v6);
  v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  v13 = vqshlq_n_s16(a1[7], 1uLL);
  v14 = vaddq_s16(v5, v7);
  v15 = vsubq_s16(v7, v5);
  v16 = vaddq_s16(v3, v13);
  v17 = vsubq_s16(v3, v13);
  v18 = vaddq_s16(v16, v14);
  v19 = vaddq_s16(v9, v12);
  v20 = vaddq_s16(v10, v19);
  v21 = vsubq_s16(v10, v19);
  v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  v24 = vsubq_s16(v11, v12);
  v25 = vaddq_s16(v11, v12);
  v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  v28 = vaddq_s16(v18, v26);
  v29 = vaddq_s16(v26, v23);
  v30 = vaddq_s16(v27, v23);
  v31 = vaddq_s16(v20, v28);
  v32 = vaddq_s16(v25, v29);
  v33 = vaddq_s16(v24, v30);
  v34 = vaddq_s16(v21, v27);
  v35 = vsubq_s16(v21, v27);
  v36 = vsubq_s16(v24, v30);
  v37 = vsubq_s16(v25, v29);
  v38 = vsubq_s16(v20, v28);
  v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  v64 = *a2;
  v65 = a2[1];
  v63 = a2 + 2;
  v66 = *v63;
  v67 = v63[1];
  v63 += 2;
  v68 = *v63;
  v69 = v63[1];
  v63 += 2;
  v70 = vaddq_s16(v60, v59);
  v71 = vaddq_s16(v55, v56);
  v72 = vsubq_s16(v55, v56);
  v73 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  v74 = vqshlq_n_s16(v62, 1uLL);
  v75 = vaddq_s16(v61, v58);
  v76 = vsubq_s16(v58, v61);
  v77 = vaddq_s16(v57, v74);
  v78 = vsubq_s16(v57, v74);
  v79 = vaddq_s16(v77, v75);
  v80 = vaddq_s16(v70, v73);
  v81 = vaddq_s16(v71, v80);
  v82 = vsubq_s16(v71, v80);
  v83 = vqrdmulhq_lane_s16(vaddq_s16(v76, v78), (int16x4_t)0x30FC273D5A824546, 3);
  v84 = vqrdmulhq_lane_s16(vsubq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  v85 = vsubq_s16(v72, v73);
  v86 = vaddq_s16(v72, v73);
  v87 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 2), v78), v83);
  v88 = vaddq_s16(vqrdmulhq_lane_s16(v76, (int16x4_t)0x30FC273D5A824546, 0), v83);
  v89 = vaddq_s16(v79, v87);
  v90 = vaddq_s16(v87, v84);
  v91 = vaddq_s16(v88, v84);
  v92 = vaddq_s16(v86, v90);
  v93 = vaddq_s16(v85, v91);
  v94 = vaddq_s16(v82, v88);
  v95 = vsubq_s16(v82, v88);
  v96 = vsubq_s16(v85, v91);
  v97 = vsubq_s16(v86, v90);
  v98 = vsubq_s16(v81, v89);
  *(int8x8_t *)v89.i8 = vqrshrn_n_s16(vaddq_s16(v81, v89), 5uLL);
  *(int8x8_t *)v91.i8 = vqrshrn_n_s16(v92, 5uLL);
  *(int8x8_t *)v86.i8 = vqrshrn_n_s16(v93, 5uLL);
  *(int8x8_t *)v77.i8 = vqrshrn_n_s16(v94, 5uLL);
  *(int8x8_t *)v76.i8 = vqrshrn_n_s16(v95, 5uLL);
  *(int8x8_t *)v81.i8 = vqrshrn_n_s16(v96, 5uLL);
  *(int8x8_t *)v85.i8 = vqrshrn_n_s16(v97, 5uLL);
  *(int8x8_t *)v46.i8 = vqrshrn_n_s16(v98, 5uLL);
  _X3 = (char *)(v64 + a3);
  _X4 = (char *)(v65 + a3);
  _X5 = (char *)(v66 + a3);
  _X6 = (char *)(v67 + a3);
  _X7 = (char *)(v68 + a3);
  _X9 = (char *)(v69 + a3);
  _X10 = (char *)(*v63 + a3);
  _X11 = (char *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *(int8x8_t *)v55.i8 = vadd_s8(*(int8x8_t *)v89.i8, (int8x8_t)0x8080808080808080);
  v92.i64[0] = v55.i64[0];
  *(int8x8_t *)v93.i8 = vadd_s8(*(int8x8_t *)v91.i8, (int8x8_t)0x8080808080808080);
  v94.i64[0] = v93.i64[0];
  *(int8x8_t *)v95.i8 = vadd_s8(*(int8x8_t *)v86.i8, (int8x8_t)0x8080808080808080);
  v96.i64[0] = v95.i64[0];
  *(int8x8_t *)v97.i8 = vadd_s8(*(int8x8_t *)v77.i8, (int8x8_t)0x8080808080808080);
  v98.i64[0] = v97.i64[0];
  *(int8x8_t *)v89.i8 = vadd_s8(*(int8x8_t *)v76.i8, (int8x8_t)0x8080808080808080);
  v91.i64[0] = v89.i64[0];
  *(int8x8_t *)v86.i8 = vadd_s8(*(int8x8_t *)v81.i8, (int8x8_t)0x8080808080808080);
  v77.i64[0] = v86.i64[0];
  *(int8x8_t *)v76.i8 = vadd_s8(*(int8x8_t *)v85.i8, (int8x8_t)0x8080808080808080);
  v81.i64[0] = v76.i64[0];
  *(int8x8_t *)v85.i8 = vadd_s8(*(int8x8_t *)v46.i8, (int8x8_t)0x8080808080808080);
  v46.i64[0] = v85.i64[0];
  vst2_s8(_X3, (int8x8x2_t)v55);
  vst2_s8(_X4, (int8x8x2_t)v93);
  vst2_s8(_X5, (int8x8x2_t)v95);
  vst2_s8(_X6, (int8x8x2_t)v97);
  vst2_s8(_X7, (int8x8x2_t)v89);
  vst2_s8(_X9, *(int8x8x2_t *)((char *)&v77 - 8));
  vst2_s8(_X10, (int8x8x2_t)v76);
  vst2_s8(_X11, *(int8x8x2_t *)((char *)&v46 - 8));
  return 16;
}

uint64_t aj_bufferproc_resize_get_blendrows(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v5 + 1106))
  {
    *a4 = 0;
    *a5 = 0;
  }
  return get_startposition_for_thread(v5, 0, *(_DWORD *)(v5 + 4) + *(_DWORD *)(v5 + 1108), a4, a5);
}

uint64_t get_startposition_for_thread(uint64_t a1, unsigned int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  unsigned int v16;
  BOOL v17;
  int v18;

  if (!a3)
    return 0;
  if (a5)
    *a5 = 0;
  v7 = *(_QWORD *)(a1 + 8 * a2 + 168);
  v8 = (a3 - 1);
  v9 = (v8 << 32) - 0x110000001;
  if ((unint64_t)(v8 << 32) < 0x110000001)
    v9 = 0;
  v10 = v9 / v7 + 1;
  v11 = v7 * v10;
  v12 = (unint64_t)(v11 + 0x10000000) >> 32;
  if (a3 + 2 > (int)v12)
  {
    v13 = v7 * v10;
    do
    {
      if (a5)
        ++*a5;
      v13 += v7;
      ++v10;
      if ((int)v8 > (int)v12)
        v11 = v13;
      v12 = (unint64_t)(v13 + 0x10000000) >> 32;
    }
    while (a3 + 2 > (int)v12);
    if (a2)
      goto LABEL_23;
    goto LABEL_17;
  }
  v13 = v7 * v10;
  if (!a2)
  {
LABEL_17:
    v14 = *(_DWORD *)(a1 + 68);
    if (v14)
    {
      v15 = *(_QWORD *)(a1 + 176);
      if (v15)
      {
        v16 = (get_startposition_for_thread() / v15) << v14;
        v17 = __OFSUB__(v16, v10);
        v18 = v16 - v10;
        if (!((v18 < 0) ^ v17 | (v18 == 0)))
        {
          do
          {
            if (a5)
              ++*a5;
            v13 += v7;
            --v18;
          }
          while (v18);
        }
      }
    }
  }
LABEL_23:
  if (a4)
    *a4 = ((unint64_t)(v13 - v11) >> 32) + 3;
  return v13;
}

void aj_bufferproc_resize(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  __int32 *v12;
  int32x4_t *v13;
  __int32 *v14;
  __int32 v15;
  __int32 v16;
  __int32 v17;
  __int32 v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  _DWORD *v25;
  _DWORD *v26;
  _DWORD *v27;
  uint64_t v28;
  vImage_Error v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  _DWORD *v35;
  _DWORD *v36;
  _DWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  unsigned int v47;
  unint64_t v48;
  int *v49;
  int v50;
  int *v51;
  int v52;
  int v53;
  uint64_t v54;
  _DWORD *v55;
  uint64_t v56;
  int *v57;
  _DWORD *v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v71;
  int v72;
  uint64_t v73;
  _BYTE *v74;
  uint64_t v77;
  _BOOL4 v79;
  vImage_Buffer dest;
  int32x4_t v81;
  _QWORD v82[2];
  _QWORD v83[2];
  _QWORD v84[2];
  vImage_Buffer src;
  uint64_t v86;
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(a3 + 1082))
    *(_BYTE *)(v5 + 264) = 0;
  v79 = a5 + a4 >= *(_DWORD *)(v5 + 4) && *(_BYTE *)(v5 + 1106) != 0;
  v84[0] = 0;
  v84[1] = 0;
  v83[0] = 0;
  v83[1] = 0;
  v6 = *(unsigned int *)(a2 + 6464);
  if ((int)v6 >= 1)
  {
    v7 = 0;
    do
    {
      v8 = a4;
      if (v7)
        v8 = (*(_DWORD *)(v5 + 68) + a4) >> *(_DWORD *)(v5 + 68);
      *(_DWORD *)((char *)v83 + v7) = v8;
      v7 += 4;
    }
    while (4 * v6 != v7);
    v74 = (_BYTE *)(a2 + 6577);
    v73 = a3 + 568;
    while (1)
    {
      v6 = v6;
      if (!LODWORD(v83[0]))
      {
        v9 = 1;
        do
        {
          v10 = v9;
          if (v6 == v9)
            break;
        }
        while (!*((_DWORD *)v83 + v9++));
        if (v10 >= v6)
          return;
      }
      v82[0] = 0;
      v82[1] = 0;
      v81 = 0uLL;
      v81 = vsubq_s32(*(int32x4_t *)(v5 + 976), *(int32x4_t *)(v5 + 960));
      v12 = (__int32 *)v82;
      v13 = &v81;
      v14 = (__int32 *)v83;
      do
      {
        v16 = *v14++;
        v15 = v16;
        v18 = v13->i32[0];
        v13 = (int32x4_t *)((char *)v13 + 4);
        v17 = v18;
        if (v15 >= v18)
          v15 = v17;
        *v12++ = v15;
        --v6;
      }
      while (v6);
      if (*v74)
      {
        v19 = 0;
        *(_OWORD *)&src.data = xmmword_20627BE90;
        *(_OWORD *)&dest.data = xmmword_20627BE90;
        v20 = v73;
        do
        {
          v21 = (int *)(v5 + 8 * v19);
          src.width = *v21;
          src.rowBytes = src.width;
          dest.width = v21[8];
          dest.rowBytes = dest.width;
          v22 = *((unsigned int *)v82 + v19);
          if ((int)v22 >= 1)
          {
            v23 = 0;
            v24 = (_DWORD *)(v5 + 4 * v19);
            v25 = v24 + 240;
            v26 = v24 + 248;
            v27 = v24 + 244;
            v28 = v20 + 8 * *((int *)v84 + v19);
            do
            {
              src.data = *(void **)(v28 + 8 * v23);
              dest.data = *(void **)(v5 + 168 * v19 + 8 * (((int)v23 + *v25 + *v26) % *v27) + 272);
              v29 = vImageHorizontalShear_Planar8(&src, &dest, 0, 0, 0.0, 0.0, *(ResamplingFilter *)(v5 + 1112), 0, 8u);
              if (v29)
                aj_log_error(0, "vImage returned error: %ld\n", v29);
              ++v23;
            }
            while (v22 != v23);
          }
          *(_DWORD *)(v5 + 4 * v19++ + 960) += v22;
          v30 = a2;
          v6 = *(int *)(a2 + 6464);
          v20 += 128;
        }
        while (v19 < v6);
      }
      else
      {
        v31 = 0;
        v77 = v73;
        do
        {
          v32 = *((unsigned int *)v82 + v31);
          if ((int)v32 >= 1)
          {
            v33 = 0;
            v34 = (_DWORD *)(v5 + 4 * v31);
            v35 = v34 + 240;
            v36 = v34 + 248;
            v37 = v34 + 244;
            v38 = v77 + 8 * *((int *)v84 + v31);
            do
            {
              memcpy(*(void **)(v5 + 168 * v31 + 8 * (((int)v33 + *v35 + *v36) % *v37) + 272), *(const void **)(v38 + 8 * v33), *(int *)(v5 + 8 * v31));
              ++v33;
            }
            while (v32 != v33);
          }
          *(_DWORD *)(v5 + 4 * v31++ + 960) += v32;
          v30 = a2;
          v6 = *(int *)(a2 + 6464);
          v77 += 128;
        }
        while (v31 < v6);
      }
      v39 = *(_QWORD *)(a1 + 32);
      v86 = 0;
      memset(&src, 0, sizeof(src));
      if (!*(_BYTE *)(v39 + 264))
        break;
LABEL_36:
      if (v79)
      {
        if ((int)v6 <= 0)
          return;
        if (*(_DWORD *)(v39 + 1072))
        {
LABEL_39:
          if (!*(_BYTE *)(v39 + 264))
          {
            outbuffer_drain(a1, v30, a3);
            LODWORD(v6) = *(_DWORD *)(v30 + 6464);
          }
        }
        else
        {
          v69 = 0;
          while (v6 - 1 != v69)
          {
            if (*(_DWORD *)(v39 + 1076 + 4 * v69++))
            {
              if (v69 < v6)
                goto LABEL_39;
              break;
            }
          }
        }
      }
      if ((int)v6 < 1)
        return;
      v71 = 0;
      do
      {
        v72 = *(_DWORD *)((char *)v82 + v71);
        *(_DWORD *)((char *)v84 + v71) += v72;
        *(_DWORD *)((char *)v83 + v71) -= v72;
        v71 += 4;
      }
      while (4 * v6 != v71);
    }
    while (1)
    {
      LODWORD(v6) = *(_DWORD *)(v30 + 6464);
      if ((int)v6 < 1)
        goto LABEL_36;
      v40 = 0;
      v41 = 0;
      do
      {
        v42 = (int *)(v39 + 4 * v40);
        v43 = v42[268];
        if ((int)v43 < v42[272])
        {
          v44 = v39 + 8 * v40;
          v46 = *(_QWORD *)(v44 + 200);
          v45 = (uint64_t *)(v44 + 200);
          v47 = v46 + 0x10000000;
          v48 = (unint64_t)(v46 + 0x10000000) >> 32;
          v49 = v42 + 236;
          v50 = v42[236];
          v51 = v42 + 240;
          v52 = v42[240];
          v53 = v48 + 2;
          if (v79)
            v53 = v48;
          if (v52 + v50 > v53)
          {
            v54 = 0;
            v55 = v42 + 268;
            v56 = v39 + 4 * v40;
            v57 = (int *)(v56 + 992);
            v58 = (_DWORD *)(v56 + 976);
            v59 = v48 - v50 - 2;
            do
            {
              if (v59 + (_DWORD)v54 < 0)
              {
                v62 = *v57 % *v58;
              }
              else
              {
                v60 = *v57;
                if (v59 + (int)v54 >= v52)
                  v61 = v52 - 1 + v60;
                else
                  v61 = v59 + v54 + v60;
                v62 = v61 % *v58;
              }
              *((_QWORD *)&src.data + v54++) = *(_QWORD *)(v39 + 168 * v40 + 8 * v62 + 272);
            }
            while (v54 != 5);
            v63 = v39 + 8 * v40;
            (*(void (**)(vImage_Buffer *, uint64_t, _QWORD, _QWORD))(v39 + 80))(&src, v39 + 10 * (v47 >> 29) + 88, *(unsigned int *)(v63 + 32), *(_QWORD *)(v39 + 16 * v40 + 8 * v43 + 1008));
            ++*v55;
            v64 = *v45;
            if (*(int *)(v63 + 4) > 1)
            {
              v64 += *(_QWORD *)(v63 + 168);
              *v45 = v64;
            }
            v48 = (unint64_t)(v64 + 0x10000000) >> 32;
            v50 = *v49;
            v52 = *v51;
            v41 = 1;
            v30 = a2;
          }
          v65 = v48 - v50 - 2;
          if (v65 >= v52)
            v65 = v52;
          if (v65 >= 1)
          {
            *(_DWORD *)(v39 + 4 * v40 + 992) = (*(_DWORD *)(v39 + 4 * v40 + 992) + v65)
                                             % *(_DWORD *)(v39 + 4 * v40 + 976);
            *v51 = v52 - v65;
            *v49 = v65 + v50;
          }
        }
        ++v40;
        v6 = *(int *)(v30 + 6464);
      }
      while (v40 < v6);
      if (!v41)
        goto LABEL_36;
      if ((int)v6 < 1)
        goto LABEL_70;
      if (*(_DWORD *)(v39 + 1072) >= *(_DWORD *)(v39 + 1088))
        break;
LABEL_71:
      if (*(_BYTE *)(v39 + 264))
      {
        LODWORD(v6) = *(_DWORD *)(v30 + 6464);
        goto LABEL_36;
      }
    }
    v66 = 0;
    v67 = *(unsigned int *)(v30 + 6464);
    while (v67 - 1 != v66)
    {
      v68 = v39 + 4 * v66++;
      if (*(_DWORD *)(v68 + 1076) < *(_DWORD *)(v68 + 1092))
      {
        if (v66 < v67)
          goto LABEL_71;
        break;
      }
    }
LABEL_70:
    outbuffer_drain(a1, v30, a3);
    goto LABEL_71;
  }
}

uint64_t aj_bufferproc_resize_maxout(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;

  v4 = ((unint64_t)(a4 + 3) << 32) / *(_QWORD *)(*(_QWORD *)(a1 + 32) + 168)
     + *(_DWORD *)(a1 + 44);
  v5 = *(_QWORD *)(a1 + 80);
  if (v5)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v5 + 8))(v5, a2, a3, (v4 + 1));
  else
    return (v4 + 1);
}

uint64_t aj_bufferproc_resize_init(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  void *v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  BOOL v13;
  int v14;
  int v15;
  double v16;
  double v17;
  uint64_t v18;
  _QWORD *v19;
  double v20;
  uint64_t v21;
  double v22;
  double v23;
  BOOL v24;
  double v25;
  double v26;
  long double v27;
  long double v28;
  long double v29;
  long double v30;
  uint64_t v31;
  uint64_t i;
  __int16 v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  double v37;
  __int16 v38;
  void *v39;
  uint64_t v40;
  unsigned int *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unint64_t v46;
  int v47;
  unint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t startposition_for_thread;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  _BOOL4 v65;
  uint64_t v66;
  uint64_t v67;
  _BYTE *buffer;
  int *v69;
  uint64_t v70;
  _BYTE *v71;
  _DWORD *v72;
  uint64_t v73;
  ResamplingFilter v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  _DWORD *v78;
  uint64_t v79;
  __int128 *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v86;
  double v87[8];
  _QWORD v88[42];

  v88[40] = *MEMORY[0x24BDAC8D0];
  v9 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a4)(1120, *(_QWORD *)(a4 + 16));
  if (!v9)
    return 6;
  v10 = (uint64_t)v9;
  bzero(v9, 0x460uLL);
  v11 = *(_DWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 32) = v10;
  *(_DWORD *)(v10 + 64) = aj_highest_set_bit(v11) - 1;
  v81 = (__int128 *)(a1 + 40);
  *(_DWORD *)(v10 + 68) = aj_highest_set_bit(*(_DWORD *)(a1 + 44)) - 1;
  *(_DWORD *)(v10 + 72) = 0;
  v12 = a3[7] == *(_DWORD *)(a2 + 6840);
  v14 = a3[6] - *(_DWORD *)(a2 + 6836);
  v13 = a3[6] == *(_DWORD *)(a2 + 6836);
  *(_BYTE *)(v10 + 1105) = v13;
  *(_BYTE *)(v10 + 1106) = v12;
  v15 = *(_DWORD *)(a2 + 172) * v14;
  *(_DWORD *)(v10 + 1108) = v15;
  if (!v13)
    *(_DWORD *)(v10 + 1108) = v15 - *(_DWORD *)(a2 + 6856);
  v84 = a1;
  v16 = (double)*(int *)(a2 + 6504) / (double)*(int *)(a2 + 6620);
  v17 = 0.5;
  if (v16 >= 0.5)
  {
    v17 = (double)*(int *)(a2 + 6504) / (double)*(int *)(a2 + 6620);
    if (v16 > 1.0)
      v17 = 1.0;
  }
  v82 = a5;
  v18 = 0;
  v19 = v88;
  v20 = 0.125;
  do
  {
    v21 = 0;
    v22 = 0.0;
    do
    {
      v23 = v17 * ((double)((int)v21 - 2) + -(double)(int)v18 * v20);
      v24 = v23 > -2.0 && v23 < 2.0;
      v25 = 0.0;
      if (v24)
      {
        v25 = 1.0;
        if (v23 != 0.0)
        {
          v26 = v23 * 3.14159265;
          v27 = sin(v23 * 3.14159265);
          v28 = v23 * 0.5 * 3.14159265;
          v29 = v27 / v26;
          v30 = sin(v28);
          v20 = 0.125;
          v25 = v29 * (v30 / v28);
        }
      }
      *(double *)&v19[v21] = v25;
      v22 = v22 + v25;
      ++v21;
    }
    while (v21 != 5);
    v87[v18++] = v22;
    v19 += 5;
  }
  while (v18 != 8);
  v31 = 0;
  for (i = 0; i != 8; ++i)
  {
    v33 = 0;
    v34 = v87[i];
    v35 = v31;
    v36 = 5;
    do
    {
      v37 = *(double *)&v88[v35] / v34;
      *(double *)&v88[v35] = v37;
      v38 = llround(v37 * 16384.0);
      *(_WORD *)(v10 + 2 * v35 + 88) = v38;
      v33 += v38;
      ++v35;
      --v36;
    }
    while (v36);
    *(_WORD *)(v10 + 10 * i + 92) = *(_WORD *)(v10 + 10 * i + 92) - v33 + 0x4000;
    v31 += 5;
  }
  if (*(_BYTE *)(a2 + 6576))
    v39 = aj_resize_vertically;
  else
    v39 = aj_memcpy_wrapper;
  *(_QWORD *)(v10 + 80) = v39;
  v40 = *(unsigned int *)(a2 + 6464);
  if ((int)v40 < 1)
  {
LABEL_64:
    v73 = 1;
    *(_BYTE *)(v10 + 1104) = 1;
    v74 = vImageNewResamplingFilter((float)*(int *)(a2 + 6500) / (float)*(int *)(a2 + 6616), 0);
    *(_QWORD *)(v10 + 1112) = v74;
    if (v74)
    {
      v75 = *v81;
      v76 = v81[1];
      *(_QWORD *)(v82 + 32) = *((_QWORD *)v81 + 4);
      *(_OWORD *)v82 = v75;
      *(_OWORD *)(v82 + 16) = v76;
      if (*(int *)(a2 + 6464) >= 1)
      {
        v77 = 0;
        v78 = (_DWORD *)(v10 + 36);
        do
        {
          v79 = v82 + 4 * v77;
          *(_DWORD *)(v79 + 24) = *v78;
          *(_DWORD *)(v79 + 8) = *(v78 - 1);
          ++v77;
          v78 += 2;
        }
        while (v77 < *(int *)(a2 + 6464));
      }
      return 0;
    }
  }
  else
  {
    v41 = a3 + 38;
    v86 = v40 - 1;
    while (1)
    {
      v83 = v40--;
      if ((_DWORD)v40)
      {
        v43 = *(_DWORD *)(v10 + 64);
        v42 = *(_DWORD *)(v10 + 68);
      }
      else
      {
        v43 = 0;
        v42 = 0;
      }
      v44 = (*(_DWORD *)(a2 + 6620) + v42) >> v42;
      v45 = (*(_DWORD *)(a2 + 6504) + v42) >> v42;
      if (v44 <= 2)
        v44 = 2;
      v46 = (unint64_t)(v44 - 1) << 32;
      if (v45 <= 2)
        v47 = 2;
      else
        v47 = (*(_DWORD *)(a2 + 6504) + v42) >> v42;
      v48 = v46 / (v47 - 1);
      v49 = v10 + 8 * v40;
      if (v45 == 1)
        ++v48;
      *(_QWORD *)(v49 + 168) = v48;
      v50 = (_QWORD *)(v49 + 168);
      v51 = ((*(_DWORD *)(v10 + 1108) + v42) >> v42);
      if ((_DWORD)v40 || (v64 = *(_DWORD *)(v10 + 68)) == 0 || *(int *)(a2 + 6464) < 2)
      {
        startposition_for_thread = get_startposition_for_thread(v10, v40, v51, 0, 0);
        *(_QWORD *)(v10 + 8 * v40 + 232) = startposition_for_thread;
      }
      else
      {
        *(_QWORD *)(v10 + 232) = *(_QWORD *)(v10 + 168)
                               * (int)((*(_QWORD *)(v10 + 240) / *(_QWORD *)(v10 + 176)) << v64);
        startposition_for_thread = *(_QWORD *)(v10 + 232 + 8 * v40);
      }
      v53 = v84 + 4 * v40;
      v54 = v10 + 8 * v40;
      *(_DWORD *)v54 = *(_DWORD *)(v53 + 48);
      v55 = *(_DWORD *)(v53 + 64);
      *(_DWORD *)(v54 + 32) = (*(_DWORD *)(a2 + 6500) + v43) >> v43;
      v56 = (int *)(v54 + 32);
      v57 = startposition_for_thread - (v51 << 32);
      *(_QWORD *)(v54 + 200) = v57;
      *(_DWORD *)(v54 + 4) = v55;
      v58 = (v55 - 1);
      if ((_DWORD)v58)
      {
        v59 = v58 << 32;
        v60 = v59 - 0x110000001;
        if (v59 < 0x110000001)
          v60 = 0;
        if (!*(_BYTE *)(v10 + 1106))
          v59 = v60;
        v45 = (v59 - v57) / *v50 + 1;
      }
      *(_DWORD *)(v54 + 36) = v45;
      v61 = ((*(_DWORD *)(a2 + 172) + v42) >> v42) + 5;
      v62 = v10 + 4 * v40;
      *(_DWORD *)(v62 + 976) = v61;
      v63 = (_DWORD)v40 ? 1 : *(_DWORD *)(v84 + 44);
      *(_DWORD *)(v62 + 1088) = v63;
      v65 = *(_DWORD *)(a2 + 24) == 2 && *(_DWORD *)(a2 + 48) > 1;
      v66 = aj_rowbuffer_add_block(v41, (uint64_t (**)(size_t, _QWORD))a4, *v56, v63 + v61 + v65, 0x10uLL);
      if ((_DWORD)v66)
        return v66;
      if (*(int *)(v62 + 976) >= 1)
      {
        v67 = 0;
        do
        {
          buffer = aj_rowbuffer_get_buffer(v41, *v56);
          *(_QWORD *)(v10 + 272 + 168 * v86 + 8 * v67) = buffer;
          if (!buffer)
            return 1;
        }
        while (++v67 < *(int *)(v62 + 976));
      }
      v69 = (int *)(v62 + 1088);
      if (*v69 >= 1)
      {
        v70 = 0;
        do
        {
          v71 = aj_rowbuffer_get_buffer(v41, *v56);
          *(_QWORD *)(v10 + 1008 + 16 * v86 + 8 * v70) = v71;
          if (!v71)
            return 1;
        }
        while (++v70 < *v69);
      }
      v72 = (_DWORD *)(v10 + 4 * v40);
      v72[236] = 0;
      v72[240] = 0;
      v72[248] = 0;
      --v86;
      if (v83 <= 1)
        goto LABEL_64;
    }
  }
  return v73;
}

uint64_t aj_bufferproc_resize_terminate(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  void *v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;

  v4 = *(_QWORD *)(result + 32);
  if (v4)
  {
    v8 = *(void **)(v4 + 1112);
    if (v8)
      vImageDestroyResamplingFilter(v8);
    if (*(_BYTE *)(v4 + 1104))
    {
      if (*(int *)(a2 + 6464) >= 1)
      {
        v9 = 0;
        v10 = (unsigned int *)(a3 + 152);
        v11 = v4 + 272;
        v12 = v4 + 1008;
        do
        {
          v13 = v4 + 4 * v9;
          if (*(int *)(v13 + 976) >= 1)
          {
            v14 = 0;
            do
            {
              aj_rowbuffer_return_buffer(v10, *(_QWORD *)(v11 + 8 * v14));
              *(_QWORD *)(v11 + 8 * v14++) = 0;
            }
            while (v14 < *(int *)(v13 + 976));
          }
          if (*(int *)(v13 + 1088) >= 1)
          {
            v15 = 0;
            v16 = (int *)(v13 + 1088);
            do
            {
              aj_rowbuffer_return_buffer(v10, *(_QWORD *)(v12 + 8 * v15));
              *(_QWORD *)(v12 + 8 * v15++) = 0;
            }
            while (v15 < *v16);
          }
          ++v9;
          v11 += 168;
          v12 += 16;
        }
        while (v9 < *(int *)(a2 + 6464));
      }
      *(_BYTE *)(v4 + 1104) = 0;
    }
    return (*(uint64_t (**)(uint64_t, _QWORD))(a4 + 8))(v4, *(_QWORD *)(a4 + 16));
  }
  return result;
}

_BYTE *outbuffer_drain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t (**v6)(_QWORD, uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t *v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _BYTE *result;
  int v18;
  uint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  int *v24;
  uint64_t v25;
  _BYTE v26[64];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(uint64_t (***)(_QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 80);
  v7 = *(unsigned int *)(a2 + 6464);
  if ((int)v7 >= 1)
  {
    v8 = 0;
    v9 = (_QWORD *)(a3 + 568);
    v10 = (uint64_t *)(v5 + 1008);
    v11 = v26;
    do
    {
      v12 = *(unsigned int *)(v5 + 4 * v8 + 1072);
      v13 = v10;
      v14 = v11;
      v15 = v9;
      if ((int)v12 >= 1)
      {
        do
        {
          *v14++ = *v15;
          v16 = *v13++;
          *v15++ = v16;
          --v12;
        }
        while (v12);
      }
      ++v8;
      v9 += 16;
      v11 += 16;
      v10 += 2;
    }
    while (v8 != v7);
  }
  result = (_BYTE *)(*v6)(v6, a2, a3, *(unsigned int *)(v5 + 1072), *(unsigned int *)(v5 + 72));
  v18 = *(_DWORD *)(v5 + 72) + *(_DWORD *)(v5 + 1072);
  *(_DWORD *)(v5 + 72) = v18;
  if (v18 >= *(_DWORD *)(v5 + 36) && !*(_BYTE *)(a3 + 1082))
    *(_BYTE *)(v5 + 264) = 1;
  if (*(int *)(a2 + 6464) >= 1)
  {
    v19 = 0;
    v20 = (unsigned int *)(a3 + 152);
    v21 = a3 + 568;
    v22 = v5 + 1008;
    v23 = v26;
    do
    {
      v24 = (int *)(v5 + 4 * v19 + 1072);
      if (*v24 >= 1)
      {
        v25 = 0;
        do
        {
          aj_rowbuffer_return_buffer(v20, *(_QWORD *)(v21 + 8 * v25));
          *(_QWORD *)(v21 + 8 * v25) = *(_QWORD *)&v23[8 * v25];
          result = aj_rowbuffer_get_buffer(v20, *(int *)(v5 + 8 * v19 + 32));
          *(_QWORD *)(v22 + 8 * v25++) = result;
        }
        while (v25 < *v24);
      }
      *v24 = 0;
      ++v19;
      v21 += 128;
      v23 += 16;
      v22 += 16;
    }
    while (v19 < *(int *)(a2 + 6464));
  }
  return result;
}

void *aj_memcpy_wrapper(uint64_t a1, int a2, int a3, void *__dst)
{
  return memcpy(__dst, *(const void **)(a1 + 16), a3);
}

uint64_t aj_reduce_init_unpack(uint64_t a1, int *a2, uint64_t a3, int **a4, _QWORD *a5, unsigned int *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result;
  uint64_t v18;
  char v19;
  char v20;
  int **v21;
  uint64_t v22;
  uint64_t v23;

  *a4 = (int *)a6;
  result = aj_imageinfo_init(a6, (uint64_t)a4, a8);
  if (!(_DWORD)result)
  {
    aj_reset_mcustate(a5, a7);
    result = aj_init_huffman(a6, (uint64_t)a4, a8);
    if (!(_DWORD)result)
    {
      result = init_reduce(a2, a4, a3, a1, a8, a9);
      if (!(_DWORD)result)
      {
        v18 = 0;
        v19 = 1;
        do
        {
          v20 = v19;
          v21 = &a4[2 * v18];
          v22 = (uint64_t)v21[1];
          if (v22)
            aj_huffman_encode_init_lookups(v22, (unsigned __int8 *)(v22 + 16), (uint64_t)&a2[512 * v18 + 33898], 0);
          v23 = (uint64_t)v21[2];
          if (v23)
            aj_huffman_encode_init_lookups(v23, (unsigned __int8 *)(v23 + 16), (uint64_t)&a2[512 * v18 + 34154], (uint64_t)&a2[256 * v18 + 34922]);
          v19 = 0;
          v18 = 1;
        }
        while ((v20 & 1) != 0);
        return 0;
      }
    }
  }
  return result;
}

uint64_t init_reduce(int *a1, int **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *v12;
  int v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int **v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  uint64_t v42;
  uint64_t i;
  uint64_t v44;
  int **v45;
  int *v46;
  int v47;
  uint64_t j;
  uint64_t v49;
  uint64_t k;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v59;
  uint64_t v60;
  int *v61;
  _QWORD *v62;
  int *v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  int **v68;
  _DWORD *v69;
  uint64_t v70;
  int *v71;

  v12 = (uint64_t *)(a1 + 33636);
  v13 = *((_DWORD *)a2 + 20) * *((_DWORD *)a2 + 23);
  *((_QWORD *)a1 + 17718) = a2;
  v14 = *(_QWORD *)a1;
  if (v14)
    (*(void (**)(uint64_t, _QWORD))(a5 + 8))(v14, *(_QWORD *)(a5 + 16));
  v15 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a5)(132 * v13, *(_QWORD *)(a5 + 16));
  *(_QWORD *)(a4 + 16) = v15;
  *(_QWORD *)a1 = v15;
  if (!v15 || (bzero(v15, 132 * v13), (v16 = *(_QWORD *)a1) == 0))
  {
    aj_log_error(0, "Could not allocate memory for block buffers.");
    return 6;
  }
  v69 = a1 + 22401;
  v17 = a1 + 11169;
  v18 = *((int *)a2 + 20);
  v19 = v18 * *((_DWORD *)a2 + 22);
  v20 = v16 + 66 * v19;
  v18 *= 33;
  *((_QWORD *)a1 + 1) = v20;
  *((_QWORD *)a1 + 2) = v20 + 2 * v18;
  v21 = v16 + 66 * v13;
  v22 = v21 + 66 * v19;
  *((_QWORD *)a1 + 3) = v21;
  *((_QWORD *)a1 + 4) = v22;
  *((_QWORD *)a1 + 5) = v22 + 2 * v18;
  *((int8x16_t *)v12 + 19) = vextq_s8(*(int8x16_t *)(v12 + 41), *(int8x16_t *)(v12 + 41), 8uLL);
  determine_max_bits(&(*a2)[64 * (uint64_t)(*a2)[12] + 22], a1 + 11172);
  v23 = *a2;
  v24 = a2;
  if (**a2 >= 2)
  {
    v25 = v23[13];
    if ((_DWORD)v25 == v23[14])
    {
      determine_max_bits(&v23[64 * v25 + 22], a1 + 22404);
      *((_OWORD *)a1 + 8421) = *((_OWORD *)a1 + 5613);
      *((_OWORD *)a1 + 8422) = *((_OWORD *)a1 + 5614);
      *((_OWORD *)a1 + 8423) = *((_OWORD *)a1 + 5615);
      *((_OWORD *)a1 + 8424) = *((_OWORD *)a1 + 5616);
      *((_OWORD *)a1 + 8417) = *((_OWORD *)a1 + 5609);
      *((_OWORD *)a1 + 8418) = *((_OWORD *)a1 + 5610);
      *((_OWORD *)a1 + 8419) = *((_OWORD *)a1 + 5611);
      *((_OWORD *)a1 + 8420) = *((_OWORD *)a1 + 5612);
      *((_OWORD *)a1 + 8413) = *((_OWORD *)a1 + 5605);
      *((_OWORD *)a1 + 8414) = *((_OWORD *)a1 + 5606);
      *((_OWORD *)a1 + 8415) = *((_OWORD *)a1 + 5607);
      *((_OWORD *)a1 + 8416) = *((_OWORD *)a1 + 5608);
      *((_OWORD *)a1 + 8409) = *((_OWORD *)a1 + 5601);
      *((_OWORD *)a1 + 8410) = *((_OWORD *)a1 + 5602);
      *((_OWORD *)a1 + 8411) = *((_OWORD *)a1 + 5603);
      *((_OWORD *)a1 + 8412) = *((_OWORD *)a1 + 5604);
    }
    else
    {
      a1[22404] = 11;
      *(_DWORD *)v12 = 11;
      memset_pattern16(a1 + 22405, &unk_20627BEC0, 0xFCuLL);
      memset_pattern16(a1 + 33637, &unk_20627BEC0, 0xFCuLL);
    }
    v24 = a2;
  }
  v71 = a1;
  v26 = 12 * (*(uint64_t (**)(uint64_t))a6)(38);
  v27 = v26 + 16 * (*(uint64_t (**)(uint64_t))a6)(9);
  v28 = v27 + 5544 * (*(uint64_t (**)(uint64_t))a6)(15);
  v68 = v24;
  if (**v24 >= 2)
  {
    v29 = v28 + 12 * (*(uint64_t (**)(uint64_t))a6)(23);
    v30 = v29 + 16 * (*(uint64_t (**)(uint64_t))a6)(9);
    v28 = v30 + 5544 * (*(uint64_t (**)(uint64_t))a6)(15);
  }
  v31 = (char *)(*(uint64_t (**)(_QWORD, _QWORD))a5)(v28, *(_QWORD *)(a5 + 16));
  *(_QWORD *)(a4 + 24) = v31;
  if (!v31)
  {
    aj_log_error(0, "Could not allocate memory for contexts.");
    return 6;
  }
  v32 = v31;
  bzero(v31, v28);
  v33 = **v24;
  if ((int)v33 >= 1)
  {
    v34 = 0;
    v35 = v17 + 1;
    do
    {
      if (v34)
        v36 = 4;
      else
        v36 = 5;
      *((_DWORD *)v35 - 2) = 1 << v36;
      *((_DWORD *)v35 - 1) = v36;
      *v35 = 0x300000008;
      ++v34;
      v35 += 5616;
    }
    while (v33 != v34);
  }
  v37 = 0;
  v38 = v71 + 33708;
  do
  {
    v39 = (v17[3] - *v17 + (1 << *v17));
    *(_QWORD *)&v71[v37 + 24] = v32;
    (*(void (**)(_QWORD *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v39, 1);
    v32 += (*(int (**)(uint64_t))a6)(v39);
    v37 += 2;
  }
  while (v37 != 24);
  v67 = a3;
  v40 = 0;
  v41 = v71;
  do
  {
    *(_QWORD *)&v71[v40 + 48] = v32;
    (*(void (**)(_QWORD *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, 9, 1);
    v32 += (*(int (**)(uint64_t))a6)(9);
    v40 += 2;
  }
  while (v40 != 32);
  v42 = 0;
  do
  {
    ++v42;
    for (i = 80; i != 256; i += 2)
    {
      v44 = (v71[v42 + 11172] - v17[2] + (1 << v17[2]));
      *(_QWORD *)&v41[i] = v32;
      (*(void (**)(_QWORD *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v44, 1);
      v32 += (*(int (**)(uint64_t))a6)(v44);
    }
    v41 += 176;
  }
  while (v42 != 63);
  v45 = v68;
  v46 = *v68;
  v47 = **v68;
  if (v47 <= 1)
  {
    v57 = v67;
  }
  else
  {
    for (j = 0; j != 24; j += 2)
    {
      v49 = (v69[3] - *v69 + (1 << *v69));
      *(_QWORD *)&v71[j + 11256] = v32;
      *(_QWORD *)&v71[j + 22488] = v32;
      (*(void (**)(_QWORD *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v49, 1);
      v32 += (*(int (**)(uint64_t))a6)(v49);
    }
    for (k = 0; k != 32; k += 2)
    {
      *(_QWORD *)&v71[k + 11280] = v32;
      *(_QWORD *)&v71[k + 22512] = v32;
      (*(void (**)(_QWORD *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, 9, 1);
      v32 += (*(int (**)(uint64_t))a6)(9);
    }
    v51 = 0;
    v52 = v71 + 11312;
    v53 = v71 + 22544;
    do
    {
      v54 = 0;
      v70 = v51 + 1;
      v55 = &v71[v51 + 22405];
      do
      {
        v56 = (*v55 - v69[2] + (1 << v69[2]));
        v52[v54] = v32;
        v53[v54] = v32;
        (*(void (**)(_QWORD *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v56, 1);
        v32 += (*(int (**)(uint64_t))a6)(v56);
        ++v54;
      }
      while (v54 != 88);
      v52 += 88;
      v53 += 88;
      v51 = v70;
    }
    while (v70 != 63);
    v57 = v67;
    v45 = v68;
    v46 = *v68;
    v47 = **v68;
  }
  if (v47 >= 1)
  {
    v59 = 0;
    v60 = 1568 * v47;
    v61 = v46 + 843;
    v62 = v71 + 33898;
    v63 = v71;
    do
    {
      v64 = *(v61 - 4);
      v65 = *v61;
      v66 = (_QWORD *)(v57 + v59);
      *((_QWORD *)v63 + 5621) = v57 + v59;
      v66[4] = v45[2 * v64 + 1];
      v66[5] = v45[2 * v65 + 2];
      v66[84] = &v62[256 * v64];
      v66[85] = &v62[256 * v65 + 128];
      v66[86] = &v71[256 * v65 + 34922];
      *((_QWORD *)v63 + 10) = v38;
      *((_QWORD *)v63 + 11) = a6;
      *((_QWORD *)v63 + 5618) = v71 + 33722;
      *((_QWORD *)v63 + 5619) = v71 + 33738;
      *((_QWORD *)v63 + 5620) = v71 + 33866;
      v59 += 1568;
      ++v61;
      v63 += 11232;
    }
    while (v60 != v59);
  }
  return 0;
}

__n128 aj_reduce_init_pack(uint64_t a1, int *a2, uint64_t a3, unsigned int **a4, uint64_t a5, unsigned int *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __n128 result;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _OWORD v36[16];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a3 = a6;
  *a4 = a6;
  aj_reset_mcustate((_QWORD *)(a5 + 112), a7);
  v17 = *(_QWORD *)a3;
  *(_DWORD *)a5 = 0;
  if (!*(_BYTE *)(v17 + 84))
  {
    *(_QWORD *)(a3 + 6892) = 0x100000001;
    *(_QWORD *)(a3 + 6804) = 0;
    *(_DWORD *)(a3 + 168) = 1;
    *(_DWORD *)(a3 + 6612) = 0;
    v18 = *(_DWORD *)(v17 + 8);
    *(_DWORD *)(a3 + 6484) = v18;
    v19 = *(_DWORD *)(v17 + 12);
    *(_DWORD *)(a3 + 6488) = v19;
    *(_DWORD *)(a3 + 6580) = 0;
    *(_DWORD *)(a3 + 6824) = 0;
    *(_QWORD *)(a3 + 6816) = 0;
    *(_DWORD *)(a3 + 6828) = v18;
    *(_DWORD *)(a3 + 6832) = v19;
    *(_DWORD *)(a3 + 6884) = 1;
    if (!aj_compute_helpers(a3))
    {
      v20 = a3 + 192;
      if (!init_reduce(a2, *(int ***)(a3 + 8), a3 + 192, a1, a8, a9)
        && !aj_init_huffman(a6, (uint64_t)a4, a8))
      {
        if ((int)*a6 >= 1)
        {
          v21 = 0;
          do
          {
            aj_init_component(a3, v20, v21++, 1, 0);
            v20 += 1568;
          }
          while (v21 < (int)*a6);
        }
        *(_DWORD *)(a3 + 6948) = 1;
        if (!aj_init_decode_jobs(a3, (_DWORD *)a5, 0, 0, a8, 1))
        {
          v22 = 0;
          v23 = 88;
          do
          {
            v24 = 0;
            v25 = *(_QWORD *)a3;
            v26 = *(_QWORD *)a3 + v23;
            do
            {
              *((_DWORD *)v36 + aj_glob_zigzag[v24]) = *(_DWORD *)(v26 + v24 * 4);
              ++v24;
            }
            while (v24 != 64);
            v27 = v36[9];
            v28 = v25 + (v22 << 8);
            *(_OWORD *)(v28 + 216) = v36[8];
            *(_OWORD *)(v28 + 232) = v27;
            v29 = v36[11];
            *(_OWORD *)(v28 + 248) = v36[10];
            v30 = v36[5];
            *(_OWORD *)(v28 + 152) = v36[4];
            *(_OWORD *)(v28 + 168) = v30;
            v31 = v36[7];
            *(_OWORD *)(v28 + 184) = v36[6];
            *(_OWORD *)(v28 + 200) = v31;
            v32 = v36[1];
            *(_OWORD *)(v28 + 88) = v36[0];
            *(_OWORD *)(v28 + 104) = v32;
            v33 = v36[3];
            *(_OWORD *)(v28 + 120) = v36[2];
            *(_OWORD *)(v28 + 136) = v33;
            v28 += 88;
            result = (__n128)v36[12];
            v34 = v36[14];
            v35 = v36[15];
            *(_OWORD *)(v28 + 208) = v36[13];
            *(_OWORD *)(v28 + 224) = v34;
            *(_OWORD *)(v28 + 240) = v35;
            ++v22;
            v23 += 256;
            *(_OWORD *)(v28 + 176) = v29;
            *(__n128 *)(v28 + 192) = result;
          }
          while (v22 != 4);
        }
      }
    }
  }
  return result;
}

int *determine_max_bits(int *result, int *a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  uint64_t i;
  int v7;
  int v8;
  unsigned int v9;

  if (*result >= 2)
  {
    v3 = 0;
    do
    {
      v4 = v3 + 1;
      if (v3 > 0x1F)
        break;
      v5 = 1 << v3++;
    }
    while (v5 <= *result);
    v2 = 13 - v4;
  }
  else
  {
    v2 = 11;
  }
  *a2 = v2;
  for (i = 1; i != 64; ++i)
  {
    v7 = result[i];
    if (v7 >= 2)
    {
      v8 = -2;
      do
      {
        v9 = v8 + 2;
        ++v8;
      }
      while (v9 <= 0x1F && 1 << v9 <= v7);
    }
    else
    {
      v8 = 0;
    }
    a2[i] = 10 - v8;
  }
  return result;
}

uint64_t *applejpeg_recode_open_file(_QWORD *a1, unint64_t a2, int *a3)
{
  return recode_open(a1, 0, a2, a3);
}

uint64_t *recode_open(_QWORD *a1, uint64_t *a2, unint64_t a3, int *a4)
{
  int v8;
  uint64_t *v9;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  __int128 v14;
  _OWORD *v15;
  int v16;
  uint64_t v17;
  int image_info;
  uint64_t *v19;

  if (!a4)
  {
    aj_log_error((uint64_t)"Recode", "Error pointer cannot be NULL");
    return 0;
  }
  if (!a1 || !*a1 || !a1[1])
  {
    aj_log_error((uint64_t)"Recode", "Memory manager cannot be NULL");
    goto LABEL_9;
  }
  if (!a2 || !a3)
  {
    if (!((unint64_t)a2 | a3))
    {
      aj_log_error((uint64_t)"Recode", "Input cannot be NULL");
      goto LABEL_9;
    }
    if (a3)
    {
      if (!*(_QWORD *)a3 || !*(_QWORD *)(a3 + 16))
      {
        aj_log_error((uint64_t)"Recode", "Read/Skip callback is missing");
        goto LABEL_9;
      }
      v11 = *(_QWORD *)(a3 + 40);
      if (v11)
      {
        if (v11 <= 0x3FF)
        {
          aj_log_error((uint64_t)"Recode", "Read buff must be at least %d bytes");
          goto LABEL_9;
        }
        if (v11 >> 31)
        {
          aj_log_error((uint64_t)"Recode", "Read buff can't be larger than %d");
          goto LABEL_9;
        }
      }
      if (*(_QWORD *)(a3 + 48) >> 31)
      {
        aj_log_error((uint64_t)"Recode", "The file size can't be larger than %d");
        goto LABEL_9;
      }
    }
    else
    {
      if (!*a2 || (v12 = a2[1]) == 0)
      {
        aj_log_error((uint64_t)"Recode", "NULL fields in the memory input struct not allowed");
        goto LABEL_9;
      }
      if (v12 >> 31)
      {
        aj_log_error((uint64_t)"Recode", "Memory input buffer size may not be larger than %d");
        goto LABEL_9;
      }
    }
    v13 = (uint64_t *)((uint64_t (*)(uint64_t, _QWORD))*a1)(1488, a1[2]);
    if (!v13)
    {
      aj_log_error((uint64_t)"Recode", "Could not allocate memory for session object");
      v8 = 6;
      goto LABEL_10;
    }
    v9 = v13;
    bzero(v13, 0x5D0uLL);
    bzero(v9, 0x5D0uLL);
    applejpeg_recode_clear_options((uint64_t)v9);
    v14 = *(_OWORD *)a1;
    v9[2] = a1[2];
    *(_OWORD *)v9 = v14;
    v9[142] = (uint64_t)v9;
    v15 = applejpeg_decode_create(a1);
    v9[3] = (uint64_t)v15;
    if (v15)
    {
      if (a3)
        v16 = applejpeg_decode_open_file((uint64_t)v15, a3, 0);
      else
        v16 = applejpeg_decode_open_mem((uint64_t)v15, a2);
      v8 = v16;
      *a4 = v16;
      v17 = v9[3];
      if (v17)
      {
        if (!v8)
        {
          image_info = applejpeg_decode_get_image_info(v17, (uint64_t)(v9 + 5));
          if (image_info)
          {
            v8 = image_info;
            aj_log_error((uint64_t)"Recode", "Could not extract image information");
          }
          else
          {
            if (*((_DWORD *)v9 + 14) == 2)
            {
              aj_log_error((uint64_t)"Recode", "Recode does not support lossless jpegs");
            }
            else
            {
              if (applejpeg_decode_get_precision(v9[3]) == 8)
              {
                *a4 = 0;
                return v9;
              }
              aj_log_error((uint64_t)"Recode", "Recode only supports 8-bit jpegs");
            }
            v8 = 3;
          }
        }
        goto LABEL_44;
      }
    }
    else
    {
      v8 = *a4;
    }
    if (!v8)
    {
      v8 = 6;
      *a4 = 6;
    }
LABEL_44:
    applejpeg_decode_destroy((_QWORD *)v9[3]);
    v9[3] = 0;
    v19 = v9 + 144;
    do
    {
      if (*v19)
      {
        ((void (*)(uint64_t, _QWORD))a1[1])(*v19, a1[2]);
        *v19 = 0;
      }
      ++v19;
    }
    while (v19 < v9 + 153);
    ((void (*)(uint64_t *, _QWORD))a1[1])(v9, a1[2]);
    goto LABEL_10;
  }
  aj_log_error((uint64_t)"Recode", "Cannot have both file input AND memory input");
LABEL_9:
  v8 = 8;
LABEL_10:
  v9 = 0;
  *a4 = v8;
  return v9;
}

uint64_t *applejpeg_recode_open_mem(_QWORD *a1, uint64_t *a2, int *a3)
{
  return recode_open(a1, a2, 0, a3);
}

uint64_t applejpeg_recode_set_option_outsize(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4;

  if (!a1)
    return 5;
  if (a4 | a3 | a2)
  {
    if (a2 && a4 | a3)
    {
      aj_log_error((uint64_t)"Recode", "Can not set both output scale and width/height");
    }
    else
    {
      if ((a3 != 0) == (a4 != 0))
      {
        v4 = 0;
        *(_DWORD *)(a1 + 228) = a2;
        *(_DWORD *)(a1 + 216) = a3;
        *(_DWORD *)(a1 + 220) = a4;
        *(_BYTE *)(a1 + 1128) = 0;
        return v4;
      }
      aj_log_error((uint64_t)"Recode", "Can not set only one output dimension");
    }
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Must set either output scale or width/height");
  }
  return 5;
}

uint64_t applejpeg_recode_set_option_aspect(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;

  if (!a1)
    return 5;
  if (a2 >= 4)
  {
    aj_log_error((uint64_t)"Recode", "Unknown aspect option: %d", a2);
    return 5;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a1 + 224) = a2;
    *(_DWORD *)(a1 + 232) = a3;
    *(_BYTE *)(a1 + 1128) = 0;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_orientation(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
    return 5;
  if ((a2 - 9) > 0xFFFFFFF7)
  {
    result = 0;
    *(_DWORD *)(a1 + 408) = a2;
    *(_BYTE *)(a1 + 1128) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Orientation out of bounds: %u", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_crop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (!a1)
    return 5;
  if ((a2 & 0x8000000080000000) != 0 || (int)a3 < 1 || a3 <= 0)
  {
    aj_log_error((uint64_t)"Recode", "Invalid cropregion: (%d,%d) %dx%d", a2, HIDWORD(a2), a3, HIDWORD(a3));
    return 5;
  }
  else
  {
    v3 = 0;
    *(_QWORD *)(a1 + 236) = a2;
    *(_QWORD *)(a1 + 244) = a3;
    *(_BYTE *)(a1 + 1128) = 0;
  }
  return v3;
}

uint64_t applejpeg_recode_set_option_skip_app0(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
    return 5;
  result = 0;
  *(_DWORD *)(a1 + 336) = a2;
  *(_BYTE *)(a1 + 1128) = 0;
  return result;
}

uint64_t applejpeg_recode_set_option_jpeg_quality(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
    return 5;
  if ((a2 - 101) > 0xFFFFFF9B)
  {
    result = 0;
    *(_DWORD *)(a1 + 272) = a2;
    *(_BYTE *)(a1 + 252) = 1;
    *(_BYTE *)(a1 + 1128) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Quality out of bounds: %d", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_quantization_tables(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v3;

  if (!a1)
    return 5;
  for (i = 0; i != 32; i += 8)
    *(_QWORD *)(a1 + 280 + i) = *(_QWORD *)(a2 + i);
  v3 = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_BYTE *)(a1 + 252) = 1;
  *(_BYTE *)(a1 + 1128) = 0;
  return v3;
}

uint64_t applejpeg_recode_set_option_jpeg_format(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  if (!a1)
    return 5;
  if (a2 >= 5)
  {
    aj_log_error((uint64_t)"Recode", "Unknown JPEG format: %d", a2);
    return 5;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a1 + 312) = a2;
    *(_BYTE *)(a1 + 253) = 1;
    *(_BYTE *)(a1 + 1128) = 0;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_jpeg_type(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  if (!a1)
    return 5;
  if (a2 < 2)
  {
    result = 0;
    *(_DWORD *)(a1 + 316) = a2;
    *(_BYTE *)(a1 + 1128) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Unknown JPEG type: %d", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_accelerated_resize(_BYTE *a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 5;
  result = 0;
  a1[412] = a2;
  a1[413] = a2;
  a1[1128] = 0;
  return result;
}

uint64_t applejpeg_recode_set_option_hw_accelerated_resize(_BYTE *a1, int a2, int a3)
{
  uint64_t result;
  BOOL v5;
  char v6;

  if (!a1)
    return 5;
  result = 0;
  a1[412] = a2;
  if (a2)
    v5 = a3 == 0;
  else
    v5 = 1;
  v6 = !v5;
  a1[413] = v6;
  a1[1128] = 0;
  return result;
}

uint64_t applejpeg_recode_set_option_converter(uint64_t a1, __int128 *a2)
{
  uint64_t result;
  __int128 v4;

  result = 5;
  if (a1 && a2)
  {
    if (*(_DWORD *)a2 == 1)
    {
      result = 0;
      *(_BYTE *)(a1 + 414) = 1;
      v4 = *a2;
      *(_QWORD *)(a1 + 432) = *((_QWORD *)a2 + 2);
      *(_OWORD *)(a1 + 416) = v4;
      *(_BYTE *)(a1 + 1128) = 0;
    }
    else
    {
      aj_log_error((uint64_t)"Recode", "Unknown converter version: %d", *(_DWORD *)a2);
      return 5;
    }
  }
  return result;
}

void applejpeg_recode_clear_options(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    *(_OWORD *)(a1 + 216) = xmmword_20627BED0;
    v1 = a1 + 216;
    *(_QWORD *)(a1 + 236) = -1;
    *(_QWORD *)(a1 + 244) = -1;
    *(_DWORD *)(a1 + 232) = 0;
    *(_BYTE *)(a1 + 368) = 0;
    *(_OWORD *)(a1 + 376) = 0u;
    *(_OWORD *)(a1 + 392) = 0u;
    applejpeg_encode_options_init(a1 + 256);
    *(_DWORD *)(v1 + 192) = 1;
    *(_WORD *)(v1 + 196) = 0;
    *(_BYTE *)(v1 + 198) = 0;
    *(_BYTE *)(v1 + 912) = 0;
    *(_WORD *)(v1 + 36) = 0;
  }
}

uint64_t applejpeg_recode_get_image_info(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
    return applejpeg_decode_get_image_info(*(_QWORD *)(a1 + 24), a2);
  aj_log_error((uint64_t)"Recode", "Cannot take NULL arguments");
  return 8;
}

uint64_t applejpeg_resize_plugin_set_preferred_format(uint64_t result, unsigned int a2)
{
  if (a2 <= 0xA && ((1 << a2) & 0x518) != 0)
  {
    *(_DWORD *)(result + 928) = a2;
    *(_DWORD *)(result + 932) = 1;
  }
  return result;
}

uint64_t applejpeg_recode_all_file(unint64_t a1, uint64_t a2, _QWORD *a3)
{
  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Recode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_QWORD *)(a2 + 40))
  {
    aj_log_error((uint64_t)"Recode", "File write buffer size may not be larger than %d", a2, a3);
    return 8;
  }
  return recode_all(a1, 0, (__int128 *)a2, a3);
}

uint64_t recode_all(unint64_t a1, uint64_t a2, __int128 *a3, _QWORD *a4)
{
  BOOL v8;
  int v9;
  void (*v10)(_QWORD *);
  void *v11;
  void *v12;
  int *v13;
  int v14;
  int v15;
  unsigned int v16;
  signed int v17;
  int v18;
  int v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  char v24;
  int v25;
  int64x2_t *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  _OWORD *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t *v39;
  int64x2_t *v40;
  __int32 v41;
  __int32 v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  __int128 *v50;
  int v51;
  char *v52;
  char *v53;
  int v54;
  uint64_t v55;
  void *v56;
  void *v57;
  int64x2_t *v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  int64x2_t v62;
  int v63;
  int v64;
  int v65;
  int v66;
  _OWORD *v67;
  _OWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v74;
  int64x2_t v75;
  uint64_t qtables;
  uint64_t i;
  unsigned int v78;
  int v79;
  int v80;
  __int128 *v81;
  _OWORD *v82;
  int v83;
  uint64_t *v84;
  int v85;
  unsigned int v86;
  int v87;
  int v88[3];
  int v89;
  _QWORD v90[2];
  int64x2_t v91;
  int64x2_t v92;
  _BYTE v93[120];
  uint64_t v94;

  v94 = *MEMORY[0x24BDAC8D0];
  kdebug_trace();
  *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4100) = 1;
  if (!*(_BYTE *)(a1 + 1128))
  {
    if ((*(_DWORD *)(a1 + 408) - 9) <= 0xFFFFFFF7)
    {
      aj_log_error((uint64_t)"Recode", "Orientation must be [1..8]. Got %d");
      return 5;
    }
    v13 = (int *)(a1 + 216);
    v14 = *(_DWORD *)(a1 + 228);
    v15 = *(_DWORD *)(a1 + 220);
    if (v14)
    {
      if (v15 || *v13)
      {
        aj_log_error((uint64_t)"Recode", "Set scale OR width and height");
        return 5;
      }
      if ((v14 - 65) > 0xFFFFFFBF)
        goto LABEL_127;
    }
    else
    {
      v63 = *v13;
      if (v15 | *v13)
      {
        if (v63 < 1 || (v15 - 0x10000) < 0xFFFF0001 || v63 >= 0x10000)
        {
          aj_log_error((uint64_t)"Recode", "Illegal dimensions (%dx%d). Dimensions must be 0 < x <= 65535.");
          return 5;
        }
LABEL_127:
        if (*(_DWORD *)(a1 + 224) >= 4u)
        {
          aj_log_error((uint64_t)"Recode", "Illegal preserve aspect ratio option");
          return 5;
        }
        if (*(_BYTE *)(a1 + 368) && (!*(_QWORD *)(a1 + 384) || !*(_QWORD *)(a1 + 392)))
        {
          aj_log_error((uint64_t)"Recode", "A resize plugin must implement create and resize");
          return 5;
        }
        if (*(_BYTE *)(a1 + 414))
        {
          if ((*(_DWORD *)(a1 + 60) - 3) <= 2)
          {
            aj_log_error((uint64_t)"Recode", "Converter requires BGRA data, but the JPEG is CMYK or YCCK. Unable to convert");
            return 3;
          }
          if (*(_DWORD *)(a1 + 416) == 1 && !*(_QWORD *)(a1 + 432))
          {
            aj_log_error((uint64_t)"Recode", "The converter callback is NULL");
            return 5;
          }
        }
        init_decopt(a1, a1 + 216, a1 + 80);
        if (!*(_BYTE *)(a1 + 252))
        {
          v75 = vdupq_n_s64(a1);
          v90[0] = 0;
          v90[1] = 0;
          v88[0] = 0;
          v91 = vaddq_s64(v75, (int64x2_t)xmmword_20627BEE0);
          v92 = vaddq_s64(v75, (int64x2_t)xmmword_20627BEF0);
          qtables = applejpeg_decode_get_qtables(*(_QWORD *)(a1 + 24), (uint64_t)&v91, v88, (uint64_t)v90);
          if ((_DWORD)qtables)
            return qtables;
          for (i = 0; i != 4; ++i)
            *(_QWORD *)(a1 + 280 + 8 * i) = v91.i64[*((int *)v90 + i)];
          *(_DWORD *)(a1 + 272) = 0;
        }
        if (!*(_BYTE *)(a1 + 253))
          *(_DWORD *)(a1 + 312) = applejpeg_decode_get_chroma_subsampling(*(_DWORD **)(a1 + 24));
        *(_BYTE *)(a1 + 1128) = 1;
        if (*(_DWORD *)(a1 + 220))
          goto LABEL_155;
        v74 = *v13;
        if (*v13)
          goto LABEL_155;
        v78 = *(_DWORD *)(a1 + 228);
        if (v78 > 8 || ((1 << v78) & 0x116) == 0)
          goto LABEL_156;
        if (*(_BYTE *)(a1 + 253))
        {
          if (v78 != 8)
            goto LABEL_172;
          v79 = *(_DWORD *)(a1 + 312);
          if (v79 != applejpeg_decode_get_chroma_subsampling(*(_DWORD **)(a1 + 24)))
            goto LABEL_155;
          if (*(_DWORD *)(a1 + 228) != 8)
          {
LABEL_172:
            if (*(_DWORD *)(a1 + 312) != 3)
              goto LABEL_155;
          }
        }
        LOBYTE(v74) = 0;
        v80 = *(_DWORD *)(a1 + 44);
        if (v80 == 1 || v80 > 3)
          goto LABEL_156;
        if (*(_DWORD *)(a1 + 248) == -1)
        {
          LOBYTE(v74) = *(_DWORD *)(a1 + 244) == -1
                     && *(_DWORD *)(a1 + 236) == -1
                     && *(_DWORD *)(a1 + 240) == -1
                     && *(_DWORD *)(a1 + 408) == 1
                     && *(_BYTE *)(a1 + 414) == 0;
          goto LABEL_156;
        }
LABEL_155:
        LOBYTE(v74) = 0;
LABEL_156:
        *(_BYTE *)(a1 + 1129) = v74;
        goto LABEL_2;
      }
    }
    aj_log_error((uint64_t)"Recode", "Unsupported scale. Scale: %d.");
    return 5;
  }
LABEL_2:
  v8 = *(_BYTE *)(a1 + 368) == 0;
  if (*(_BYTE *)(a1 + 412))
  {
    if (*(_BYTE *)(a1 + 368) && *(_QWORD *)(a1 + 384) && *(_QWORD *)(a1 + 392))
    {
      v8 = 0;
    }
    else
    {
      if (*(_BYTE *)(a1 + 413))
      {
        v9 = 4;
        if (*(_DWORD *)(a1 + 408) <= 1u)
        {
          if (*(_DWORD *)(a1 + 160))
            v9 = 4;
          else
            v9 = 8;
        }
        v10 = plugin_iosaccelerator_destroy;
        v11 = plugin_iosaccelerator_resize;
        v12 = plugin_iosaccelerator_create;
      }
      else
      {
        v9 = 4;
        v10 = plugin_vimage_destroy;
        v11 = plugin_vimage_resize;
        v12 = plugin_vimage_create;
      }
      v8 = 0;
      *(_BYTE *)(a1 + 368) = 1;
      *(_QWORD *)(a1 + 376) = 0;
      *(_QWORD *)(a1 + 384) = v12;
      *(_QWORD *)(a1 + 392) = v11;
      *(_QWORD *)(a1 + 400) = v10;
      *(_DWORD *)(a1 + 928) = v9;
      *(_DWORD *)(a1 + 932) = 1;
    }
  }
  v89 = 0;
  LODWORD(v90[0]) = 0;
  v87 = 0;
  v88[0] = 0;
  v85 = 0;
  v91 = 0uLL;
  if (v8)
    goto LABEL_38;
  v16 = *(_DWORD *)(a1 + 156);
  v86 = v16;
  if ((!*(_DWORD *)(a1 + 108) || !*(_DWORD *)(a1 + 112)) && v16 <= 8 && ((1 << v16) & 0x116) != 0)
    goto LABEL_38;
  if (aj_calculate_dimensions((_DWORD *)(a1 + 80), *(_QWORD *)(a1 + 24) + 144, (int *)v90, v88, &v89, &v87, &v91, (int *)&v86, &v85))goto LABEL_38;
  v17 = v86;
  if ((int)v86 >= 2)
    v17 = v86 >> (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 156) / (int)v86 < *(_DWORD *)(a1 + 112));
  v18 = v91.i32[2] / v17;
  if (v91.i32[2] / v17 == v89 && v91.i32[3] / v17 == v87)
    goto LABEL_38;
  if (*(_DWORD *)(a1 + 108) && *(_DWORD *)(a1 + 112) && *(_DWORD *)(a1 + 116) == 1)
  {
    if (v89 != LODWORD(v90[0]))
      goto LABEL_38;
    v19 = v87;
    if (v87 != v88[0] || v18 > 4 * v89)
      goto LABEL_38;
  }
  else
  {
    if (v18 > 4 * v89)
      goto LABEL_38;
    v19 = v87;
  }
  v64 = v91.i32[3] / v17;
  if (v64 > 4 * v19 || v18 < 16 || v89 < 16 || v19 < 16 || v64 <= 15 || *(_QWORD *)(a1 + 264))
    goto LABEL_38;
  v65 = do_recode_plugin(a1, a2, a3, a4);
  if (v65 != 3)
  {
LABEL_184:
    init_decopt(a1, a1 + 216, a1 + 80);
    if (!v65)
    {
      v20 = 0;
      goto LABEL_105;
    }
    goto LABEL_38;
  }
  if (*(int *(**)(uint64_t, int *, uint64_t, int *))(a1 + 384) == plugin_iosaccelerator_create
    && *(uint64_t (**)(uint64_t, int *, _DWORD *, int))(a1 + 392) == plugin_iosaccelerator_resize
    && *(void (**)(_QWORD *))(a1 + 400) == plugin_iosaccelerator_destroy)
  {
    init_decopt(a1, a1 + 216, a1 + 80);
    *(_BYTE *)(a1 + 368) = 1;
    *(_QWORD *)(a1 + 376) = 0;
    *(_QWORD *)(a1 + 384) = plugin_vimage_create;
    *(_QWORD *)(a1 + 392) = plugin_vimage_resize;
    *(_QWORD *)(a1 + 400) = plugin_vimage_destroy;
    *(_QWORD *)(a1 + 928) = 0x100000004;
    v65 = do_recode_plugin(a1, a2, a3, a4);
    goto LABEL_184;
  }
  init_decopt(a1, a1 + 216, a1 + 80);
LABEL_38:
  if (!*(_QWORD *)(a1 + 264) && *(_DWORD *)(a1 + 408) == 1)
  {
    memset(v93, 0, sizeof(v93));
    v91 = 0u;
    v92 = 0u;
    if (*(_BYTE *)(a1 + 1129))
      *(_DWORD *)(a1 + 88) = 14;
    v90[0] = 0;
    *(_QWORD *)v88 = 0;
    v20 = applejpeg_decode_set_options(*(_QWORD *)(a1 + 24), a1 + 80, v88, 0, v90, &v93[8], &v93[12]);
    if ((_DWORD)v20)
      goto LABEL_105;
    v83 = *(_DWORD *)&v93[12];
    *(_QWORD *)(a1 + 448) = v90[0];
    if (*(_QWORD *)(a1 + 1160))
      (*(void (**)(_QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 1160), *(_QWORD *)(a1 + 16));
    v21 = (void *)(*(uint64_t (**)(void))a1)();
    *(_QWORD *)(a1 + 440) = v21;
    *(_QWORD *)(a1 + 1160) = v21;
    if (v21 && (bzero(v21, *(_QWORD *)(a1 + 448)), *(_QWORD *)(a1 + 1160)))
    {
      if (!*(_BYTE *)(a1 + 414))
        goto LABEL_52;
      v22 = *(_QWORD *)(a1 + 976);
      if (v22)
        (*(void (**)(uint64_t, _QWORD))(a1 + 8))(v22, *(_QWORD *)(a1 + 16));
      v23 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a1)(*(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 16));
      *(_QWORD *)(a1 + 1216) = v23;
      *(_QWORD *)(a1 + 976) = v23;
      if (v23)
      {
        bzero(v23, *(_QWORD *)(a1 + 448));
        if (*(_QWORD *)(a1 + 976))
        {
LABEL_52:
          v81 = a3;
          v24 = 0;
          v25 = 0;
          v26 = 0;
          v84 = (uint64_t *)(a1 + 440);
          *(_DWORD *)&v93[16] = *(_DWORD *)(a1 + 88);
          v89 = 1;
          v82 = (_OWORD *)(a1 + 256);
          while (1)
          {
            v27 = *(_QWORD *)(a1 + 24);
            if (*(_BYTE *)(a1 + 1129))
              v28 = applejpeg_decode_image_row_texture(v27, v84, (uint64_t)&v93[8], &v89);
            else
              v28 = applejpeg_decode_image_row(v27, (uint64_t)v84, (uint64_t)&v93[8], &v89);
            v20 = v28;
            if ((_DWORD)v28)
            {
LABEL_159:
              v72 = *(_QWORD *)(a1 + 32);
              if (v72)
              {
LABEL_160:
                applejpeg_encode_destroy(v72);
                *(_QWORD *)(a1 + 32) = 0;
              }
              goto LABEL_105;
            }
            if ((v24 & 1) != 0)
            {
              if (*(_BYTE *)(a1 + 1129))
                goto LABEL_76;
              v29 = *(unsigned __int8 *)(a1 + 414);
            }
            else
            {
              v30 = applejpeg_encode_create((__int128 *)a1);
              *(_QWORD *)(a1 + 32) = v30;
              if (!v30)
              {
                v20 = 6;
                goto LABEL_105;
              }
              *((_DWORD *)v30 + 3328) = 1;
              if (a2)
              {
                v31 = applejpeg_encode_set_options_mem((uint64_t)v30, v82, (uint64_t)&v93[8], a2);
                if ((_DWORD)v31)
                  goto LABEL_158;
              }
              else
              {
                v31 = applejpeg_encode_set_options_file((uint64_t)v30, v82, (uint64_t)&v93[8], v81);
                if ((_DWORD)v31)
                {
LABEL_158:
                  v20 = v31;
                  goto LABEL_159;
                }
              }
              *(_DWORD *)(*(_QWORD *)(a1 + 32) + 3464) = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3560);
              v32 = *(_OWORD *)&v93[88];
              *(_OWORD *)(a1 + 1080) = *(_OWORD *)&v93[72];
              *(_OWORD *)(a1 + 1096) = v32;
              *(_OWORD *)(a1 + 1112) = *(_OWORD *)&v93[104];
              v33 = *(_OWORD *)&v93[24];
              *(_OWORD *)(a1 + 1016) = *(_OWORD *)&v93[8];
              *(_OWORD *)(a1 + 1032) = v33;
              v34 = *(_OWORD *)&v93[56];
              *(_OWORD *)(a1 + 1048) = *(_OWORD *)&v93[40];
              *(_OWORD *)(a1 + 1064) = v34;
              v29 = *(unsigned __int8 *)(a1 + 414);
              if (*(_BYTE *)(a1 + 414))
                v26 = (int64x2_t *)(a1 + 976);
              else
                v26 = &v91;
              v35 = v93;
              if (*(_BYTE *)(a1 + 414))
                v35 = (_DWORD *)(a1 + 1008);
              if (*(_BYTE *)(a1 + 1129))
              {
                *v35 = 3;
                v36 = *v84;
                v26->i64[0] = *v84;
                v37 = v36 + *(_QWORD *)&v93[32] * *(_QWORD *)&v93[24];
                v38 = v29 == 0;
                v39 = &v91.i64[1];
                if (!v38)
                  v39 = (uint64_t *)(a1 + 984);
                *v39 = v37;
                v40 = &v92;
                if (!v38)
                  v40 = (int64x2_t *)(a1 + 992);
                v40->i64[0] = v91.i64[1] + *(_QWORD *)&v93[64] * *(_QWORD *)&v93[56];
LABEL_76:
                v41 = *(_DWORD *)&v93[52];
                if (*(int *)&v93[52] >= v83 - v25)
                  v41 = v83 - v25;
                v26[2].i32[3] = v41;
                goto LABEL_82;
              }
              *v35 = 1;
              v91.i64[0] = *v84;
            }
            v26[2].i32[3] = 1;
            *(_DWORD *)&v93[12] = 1;
            if (v29)
              (*(void (**)(_QWORD, int64x2_t *, int64x2_t *))(a1 + 432))(*(_QWORD *)(a1 + 424), &v91, v26);
LABEL_82:
            v42 = v26[2].i32[3];
            v20 = applejpeg_encode_image_row(*(_QWORD *)(a1 + 32), (unsigned int *)v26, a4);
            if (!(_DWORD)v20)
            {
              v25 += v42;
              v24 = 1;
              if (v89)
                continue;
            }
            goto LABEL_159;
          }
        }
      }
      aj_log_error((uint64_t)"Recode", "Could not allocate the convert buffer");
    }
    else
    {
      aj_log_error((uint64_t)"Recode", "Could not allocate memory for row buffer");
    }
LABEL_104:
    v20 = 6;
    goto LABEL_105;
  }
  v43 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(v43 + 4100) = 1;
  if (*(_BYTE *)(a1 + 1129))
    *(_DWORD *)(a1 + 88) = 14;
  v90[0] = 0;
  v91 = 0u;
  v92 = 0u;
  memset(v93, 0, sizeof(v93));
  v20 = applejpeg_decode_set_options(v43, a1 + 80, (_QWORD *)(a1 + 448), 0, v90, &v93[8], &v93[12]);
  if ((_DWORD)v20)
    goto LABEL_105;
  v44 = *(_QWORD *)(a1 + 1160);
  if (v44)
    (*(void (**)(uint64_t, _QWORD))(a1 + 8))(v44, *(_QWORD *)(a1 + 16));
  v45 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a1)(*(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 440) = v45;
  *(_QWORD *)(a1 + 1160) = v45;
  if (!v45 || (bzero(v45, *(_QWORD *)(a1 + 448)), !*(_QWORD *)(a1 + 1160)))
  {
    aj_log_error((uint64_t)"Recode", "Could not allocate memory for image buffer");
    goto LABEL_104;
  }
  v20 = applejpeg_decode_image_all(*(_QWORD *)(a1 + 24), (uint64_t *)(a1 + 440), 1u, (uint64_t)&v91);
  if ((_DWORD)v20)
    goto LABEL_105;
  if (*(_BYTE *)(a1 + 1129))
  {
    v46 = v91.i64[0];
    if (v91.i64[0])
    {
      if (*(_DWORD *)&v93[16] == 14)
      {
        v47 = *(_DWORD *)&v93[24];
        v48 = *(_DWORD *)&v93[32];
        v49 = *(_DWORD *)&v93[56];
        v50 = a3;
        v51 = *(_DWORD *)&v93[64];
        pad_region((char *)v91.i64[0], *(int *)&v93[24], *(int *)&v93[32], *(int *)&v93[40], *(int *)&v93[44], *(int *)&v93[48], *(int *)&v93[52]);
        v52 = (char *)(v46 + v47 * v48);
        pad_region(v52, v49, v51, *(int *)&v93[72], *(int *)&v93[76], *(int *)&v93[80], *(int *)&v93[84]);
        v53 = &v52[v49 * v51];
        v54 = v51;
        a3 = v50;
        pad_region(v53, v49, v54, *(int *)&v93[72], *(int *)&v93[76], *(int *)&v93[80], *(int *)&v93[84]);
      }
    }
  }
  if (*(_BYTE *)(a1 + 414))
  {
    v55 = *(_QWORD *)(a1 + 1216);
    if (v55)
      (*(void (**)(uint64_t, _QWORD))(a1 + 8))(v55, *(_QWORD *)(a1 + 16));
    v56 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a1)(*(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 16));
    *(_QWORD *)(a1 + 1216) = v56;
    if (!v56 || (v57 = v56, bzero(v56, *(_QWORD *)(a1 + 448)), !*(_QWORD *)(a1 + 1216)))
    {
      aj_log_error((uint64_t)"Recode", "Could not allocate memory for color conversion buffer");
      goto LABEL_104;
    }
    v58 = (int64x2_t *)(a1 + 976);
    v59 = *(_OWORD *)&v93[80];
    *(_OWORD *)(a1 + 1072) = *(_OWORD *)&v93[64];
    *(_OWORD *)(a1 + 1088) = v59;
    *(_OWORD *)(a1 + 1104) = *(_OWORD *)&v93[96];
    *(_QWORD *)(a1 + 1120) = *(_QWORD *)&v93[112];
    v60 = *(_OWORD *)&v93[16];
    *(_OWORD *)(a1 + 1008) = *(_OWORD *)v93;
    *(_OWORD *)(a1 + 1024) = v60;
    v61 = *(_OWORD *)&v93[48];
    *(_OWORD *)(a1 + 1040) = *(_OWORD *)&v93[32];
    *(_OWORD *)(a1 + 1056) = v61;
    v62 = v92;
    *(int64x2_t *)(a1 + 976) = v91;
    *(int64x2_t *)(a1 + 992) = v62;
    *(_QWORD *)(a1 + 976) = v57;
    (*(void (**)(_QWORD, int64x2_t *, unint64_t))(a1 + 432))(*(_QWORD *)(a1 + 424), &v91, a1 + 976);
  }
  else
  {
    v58 = &v91;
  }
  v66 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3560);
  v67 = applejpeg_encode_create((__int128 *)a1);
  *(_QWORD *)(a1 + 32) = v67;
  if (!v67)
    goto LABEL_104;
  *((_DWORD *)v67 + 3328) = 1;
  v68 = (_OWORD *)(a1 + 256);
  v69 = (uint64_t)&v58[2].i64[1];
  if (a2)
    v70 = applejpeg_encode_set_options_mem((uint64_t)v67, v68, v69, a2);
  else
    v70 = applejpeg_encode_set_options_file((uint64_t)v67, v68, v69, a3);
  v20 = v70;
  if (!(_DWORD)v70)
  {
    v71 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)(v71 + 3464) = v66;
    v20 = applejpeg_encode_image_all(v71, (unsigned int *)v58, a4);
    if (!(_DWORD)v20)
    {
      v72 = *(_QWORD *)(a1 + 32);
      goto LABEL_160;
    }
  }
LABEL_105:
  kdebug_trace();
  return v20;
}

uint64_t applejpeg_recode_all_mem(unint64_t a1, uint64_t a2, _QWORD *a3)
{
  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Recode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_QWORD *)(a2 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Recode", "Memory buffer size may not be larger than %d");
    return 8;
  }
  return recode_all(a1, a2, 0, a3);
}

_QWORD *applejpeg_recode_close(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t (*v6)(_QWORD *, uint64_t);

  if (result)
  {
    v1 = result;
    v6 = (uint64_t (*)(_QWORD *, uint64_t))result[1];
    v3 = result[2];
    v2 = (_QWORD *)result[3];
    if (v2)
    {
      applejpeg_decode_destroy(v2);
      v1[3] = 0;
    }
    v4 = v1[4];
    if (v4)
    {
      applejpeg_encode_destroy(v4);
      v1[4] = 0;
    }
    v5 = v1 + 144;
    do
    {
      if (*v5)
      {
        v6((_QWORD *)*v5, v3);
        *v5 = 0;
      }
      ++v5;
    }
    while (v5 < v1 + 153);
    return (_QWORD *)v6(v1, v3);
  }
  return result;
}

uint64_t init_decopt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  uint64_t result;

  applejpeg_decode_options_init(a3);
  *(_OWORD *)(a3 + 12) = *(_OWORD *)(a2 + 20);
  v6 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 76) = *(_DWORD *)(a2 + 12);
  *(_QWORD *)(a3 + 28) = *(_QWORD *)a2;
  *(_DWORD *)(a3 + 36) = v6;
  *(_DWORD *)(a3 + 72) = *(_DWORD *)(a2 + 16);
  if ((*(_DWORD *)(a1 + 60) - 3) > 2)
  {
    if (*(_BYTE *)(a2 + 198))
      v7 = 4;
    else
      v7 = 6;
  }
  else
  {
    v7 = 15;
  }
  *(_DWORD *)(a3 + 8) = v7;
  *(_QWORD *)(a3 + 92) = 0x400000000;
  *(_DWORD *)(a3 + 112) = 0;
  *(_QWORD *)(a3 + 120) = 0;
  result = *(unsigned int *)(a2 + 192);
  if (result >= 2)
    return aj_transforms_from_orientation(result, (_DWORD *)(a3 + 80), (_DWORD *)(a3 + 84), (_DWORD *)(a3 + 88));
  return result;
}

uint64_t do_recode_plugin(uint64_t a1, uint64_t a2, __int128 *a3, _QWORD *a4)
{
  int v8;
  _BOOL4 v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  void (*v28)(_QWORD);
  uint64_t v29;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  int v51;
  unint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  unsigned int v56;
  size_t v57;
  uint64_t v58;
  void *v59;
  __int32 v60;
  int v61;
  _OWORD *v62;
  _OWORD *v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  unsigned int v71;
  __int32 v72;
  __int32 v73;
  unint64_t v74;
  BOOL v75;
  unint64_t v76;
  uint64_t v77;
  BOOL v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  unint64_t v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  uint64_t format_description;
  unint64_t v93;
  int v94;
  unsigned int v95;
  unint64_t v96;
  int v97;
  int v98;
  signed int chroma_subsampling;
  uint64_t subsampling_from_jpeg_format;
  uint64_t v101;
  uint64_t v102;
  BOOL v103;
  unsigned int v104;
  BOOL v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  char v111;
  unint64_t v112;
  int v113;
  int v114;
  int v115;
  int v116;
  unsigned int v117;
  uint64_t v118;
  uint64_t v119;
  _QWORD *v120;
  _QWORD *v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unsigned int *v127;
  uint64_t v128;
  unint64_t v129;
  BOOL v130;
  BOOL v131;
  unint64_t v132;
  __int32 v133;
  int v134;
  int v135;
  int v136;
  int v137;
  unsigned int v138;
  unsigned int v139;
  int *v140;
  __int128 v141;
  int32x2_t v142;
  uint64_t v143;
  _OWORD v144[2];
  uint64_t v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  _QWORD v160[9];

  v160[7] = *MEMORY[0x24BDAC8D0];
  if (a4)
    *a4 = 0;
  if (*(_DWORD *)(a1 + 88) == 15)
  {
    v8 = 15;
  }
  else if (*(_BYTE *)(a1 + 414))
  {
    v8 = 4;
  }
  else
  {
    if (*(_DWORD *)(a1 + 932))
    {
      v8 = *(_DWORD *)(a1 + 928);
      goto LABEL_8;
    }
    v8 = 10;
  }
  *(_DWORD *)(a1 + 928) = v8;
LABEL_8:
  v9 = 1;
  if ((v8 - 10) >= 4)
    v10 = 1;
  else
    v10 = 2;
  *(_DWORD *)(a1 + 936) = v10;
  LODWORD(v144[0]) = 0;
  LODWORD(v158) = 0;
  LODWORD(v157) = 0;
  v11 = *(_DWORD *)(a1 + 408);
  if (v11 < 2 || v11 > 8)
  {
    v13 = 0;
  }
  else if (((1 << v11) & 0x18) != 0)
  {
    v13 = 1;
  }
  else
  {
    v12 = 1 << v11;
    if ((v12 & 0x60) != 0)
    {
      v9 = 0;
      v13 = 2;
    }
    else
    {
      v9 = (v12 & 0x180) == 0;
      if ((v12 & 0x180) != 0)
        v13 = 3;
      else
        v13 = 0;
    }
  }
  v142 = 0;
  v143 = 0;
  v141 = 0uLL;
  *(_QWORD *)&v146 = 0;
  v159 = 0;
  HIDWORD(v156) = 0;
  *(_DWORD *)(a1 + 940) = v13;
  v14 = aj_calculate_dimensions((_DWORD *)(a1 + 80), *(_QWORD *)(a1 + 24) + 144, (int *)&v142, (int *)&v142 + 1, (int *)v144, (int *)&v158, &v141, (int *)&v156 + 1, (int *)&v157);
  if ((_DWORD)v14)
    goto LABEL_53;
  if (!v9)
  {
    v142 = vrev64_s32(v142);
    v15 = v158;
    LODWORD(v158) = v144[0];
    LODWORD(v144[0]) = v15;
  }
  v16 = HIDWORD(v156);
  v17 = *(_QWORD *)(a1 + 24);
  if (SHIDWORD(v156) >= 2 && *(_DWORD *)(v17 + 156) / SHIDWORD(v156) < *(_DWORD *)(a1 + 112))
  {
    v16 = HIDWORD(v156) >> 1;
    HIDWORD(v156) >>= 1;
  }
  v18 = 160;
  if (v9)
    v18 = 176;
  v19 = 8 * *(_DWORD *)(v17 + v18);
  v20 = v16 << 6;
  *(_DWORD *)(a1 + 960) = v16 << 6;
  switch(*(_DWORD *)(a1 + 940))
  {
    case 0:
      v21 = DWORD1(v141);
      goto LABEL_36;
    case 1:
      v22 = DWORD1(v141);
      v23 = HIDWORD(v141);
      goto LABEL_38;
    case 2:
      v21 = v141;
LABEL_36:
      v20 += v21 / v19 * v19 - v21;
      goto LABEL_40;
    case 3:
      v22 = v141;
      v23 = DWORD2(v141);
LABEL_38:
      v24 = (v23 + v22) % v19;
      if (v24)
        v20 = v20 - v19 + v24;
LABEL_40:
      *(_DWORD *)(a1 + 964) = v20;
      break;
    default:
      v20 = *(_DWORD *)(a1 + 964);
      break;
  }
  v25 = 8;
  if (v9)
    v25 = 12;
  v26 = *(_DWORD *)((char *)&v141 + v25);
  if (v20 > v26)
  {
    *(_DWORD *)(a1 + 964) = v26;
    v20 = v26;
  }
  if (*(_DWORD *)(a1 + 936) == 2 && ((v20 / v16) & 1) != 0)
  {
    if (((v19 / v16) & 1) != 0)
    {
      v27 = v20 + v19;
    }
    else
    {
      v27 = (v20 + v16) & -v16;
      DWORD1(v141) += v20 - v27;
    }
    *(_DWORD *)(a1 + 964) = v27;
  }
  *(_DWORD *)(a1 + 156) = v16;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_OWORD *)(a1 + 92) = v141;
  *(_DWORD *)(a1 + 88) = v8;
  v14 = applejpeg_decode_set_options(v17, a1 + 80, &v146, 0, &v159, &v143, (_DWORD *)&v143 + 1);
  if ((_DWORD)v14)
    goto LABEL_53;
  v31 = *(_DWORD *)(a1 + 964);
  v32 = *(_DWORD *)(a1 + 960);
  v33 = (v26 - v31) % v32;
  v34 = v31 / SHIDWORD(v156) + v33 / SHIDWORD(v156);
  v35 = v33 + v31;
  v36 = HIDWORD(v143);
  if (v34 != v35 / SHIDWORD(v156))
    v36 = --HIDWORD(v143);
  if (v32 > v31)
    v31 = v32;
  v37 = v31 / SHIDWORD(v156);
  if (v37 >= v36)
    v37 = v36;
  *(_DWORD *)(a1 + 968) = v37;
  v38 = *(_DWORD *)(a1 + 928);
  LODWORD(v159) = 0;
  *(_QWORD *)&v146 = v143;
  *((int32x2_t *)&v146 + 1) = v142;
  *(_QWORD *)&v147 = __PAIR64__(v37, v38);
  *(_QWORD *)(a1 + 472) = (*(uint64_t (**)(_QWORD, __int128 *, uint64_t, uint64_t *))(a1 + 384))(*(_QWORD *)(a1 + 376), &v146, a1 + 480, &v159);
  v39 = v159;
  *(_DWORD *)(a1 + 972) = v159 == 0;
  if (v39)
  {
    aj_log_error((uint64_t)"Recode", "Resize plugin returned error code %d on init", v39);
    v14 = v159;
    if ((_DWORD)v159)
      goto LABEL_53;
  }
  v40 = *(_DWORD *)(a1 + 928);
  if (v40 <= 9)
  {
    if ((v40 - 3) >= 2)
    {
      if (v40 == 8)
      {
        v41 = 0;
        v42 = 0;
        v43 = 0;
        v44 = 1;
        v45 = 2;
LABEL_74:
        v46 = 1;
        goto LABEL_76;
      }
LABEL_113:
      aj_log_error((uint64_t)"Recode", "Unsupported format");
      v14 = 3;
      goto LABEL_53;
    }
LABEL_73:
    v44 = 0;
    v42 = 0;
    v43 = 4;
    v41 = 1;
    v45 = 1;
    goto LABEL_74;
  }
  if (v40 != 10)
  {
    if (v40 != 15)
      goto LABEL_113;
    goto LABEL_73;
  }
  v41 = 0;
  v43 = 0;
  v45 = 2;
  v44 = 1;
  v42 = 1;
  v46 = 2;
LABEL_76:
  v47 = *(_DWORD *)(a1 + 560);
  *(_DWORD *)(a1 + 956) = v47;
  if (v47)
  {
    *(_DWORD *)(a1 + 808) = v45;
    *(_DWORD *)(a1 + 824) = v40;
    *(_DWORD *)(a1 + 816) = v142.i32[0];
    v48 = v45;
    v49 = (uint64_t *)(a1 + 568);
    do
    {
      v50 = *v49;
      v49[26] = *v49;
      v49[41] = v49[4];
      v49[22] = v50;
      ++v49;
      --v48;
    }
    while (v48);
    goto LABEL_79;
  }
  v70 = *(_DWORD *)(a1 + 480) & 1;
  if (!v42)
    v70 = 0;
  v71 = v70 + *(_DWORD *)(a1 + 480);
  v72 = v142.i32[0];
  v73 = (v142.i8[0] & 1) + v142.i32[0];
  if (v44)
  {
    v74 = v71 * (unint64_t)v73;
    v75 = (v74 & 0xFFFFFFFF00000000) != 0;
    v76 = (2 * ((int)v71 / v46)) * (unint64_t)(v73 / v45);
    v77 = (v74 + v76);
    v78 = __CFADD__((_DWORD)v74, (_DWORD)v76);
    *(_QWORD *)(a1 + 448) = v77;
    if (v75 || (v76 & 0xFFFFFFFF00000000) != 0 || v78)
      goto LABEL_122;
  }
  else
  {
    v84 = v71 * (unint64_t)v142.u32[0];
    v77 = v84 * v43;
    *(_QWORD *)(a1 + 448) = v77;
    if ((v84 & 0xFFFFFFFF00000000) != 0 || ((v84 * (unint64_t)v43) & 0xFFFFFFFF00000000) != 0)
    {
LABEL_122:
      aj_log_error((uint64_t)"Recode", "Warning: Output buffer sizes larger than UINT32_MAX not supported.");
      goto LABEL_133;
    }
  }
  v133 = v73;
  v134 = v46;
  v137 = v42;
  v135 = v41;
  v139 = v43;
  if (*(_QWORD *)(a1 + 1160))
  {
    (*(void (**)(_QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 1160), *(_QWORD *)(a1 + 16));
    v77 = *(_QWORD *)(a1 + 448);
  }
  v85 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a1)(v77, *(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 440) = v85;
  *(_QWORD *)(a1 + 1160) = v85;
  if (!v85 || (bzero(v85, *(_QWORD *)(a1 + 448)), !*(_QWORD *)(a1 + 1160)))
  {
    aj_log_error((uint64_t)"Recode", "Could not allocate memory for the plugin out buffer");
    goto LABEL_133;
  }
  *(_DWORD *)(a1 + 808) = v45;
  v86 = *(_QWORD *)(a1 + 440);
  *(_QWORD *)(a1 + 776) = v86;
  *(_DWORD *)(a1 + 824) = v40;
  *(_DWORD *)(a1 + 816) = v142.i32[0];
  *(_QWORD *)(a1 + 744) = v86;
  v42 = v137;
  if (v44)
  {
    v87 = v86 + (int)(v71 * v133);
    *(_QWORD *)(a1 + 784) = v87;
    *(_QWORD *)(a1 + 752) = v87;
    *(_QWORD *)(a1 + 712) = v133;
    *(_QWORD *)(a1 + 720) = 2 * (v133 / v45);
    v43 = v139;
  }
  else
  {
    v43 = v139;
    *(_QWORD *)(a1 + 712) = (int)(v72 * v139);
  }
  v41 = v135;
  v46 = v134;
LABEL_79:
  v51 = *(_DWORD *)(a1 + 488);
  *(_DWORD *)(a1 + 952) = v51;
  if (v51)
  {
    v52 = (v143 & 1) + (int)v143;
    v53 = v45;
    v54 = (_QWORD *)a1;
    while (1)
    {
      v55 = v54[66];
      if (v55 < v52)
        break;
      v54[85] = v54[62];
      v54[81] = v55;
      v54[15] = v55;
      ++v54;
      if (!--v53)
        goto LABEL_83;
    }
    aj_log_error((uint64_t)"Recode", "The plugin supplied row buffers are too small");
    v14 = 8;
    goto LABEL_53;
  }
  v79 = *(_DWORD *)(a1 + 484) + *(_DWORD *)(a1 + 968);
  v80 = v79 & 1;
  if (!v42)
    v80 = 0;
  v81 = v80 + v79;
  if (v44)
    v82 = (v143 & 1) + v143;
  else
    v82 = v143;
  v138 = v43;
  v136 = v82;
  if (v44)
    v83 = v81 * ((v143 & 1) + v143) + 2 * v81 / v46 * ((int)((v143 & 1) + v143) / v45);
  else
    v83 = v143 * v43 * v81;
  v88 = v41;
  v89 = *(_QWORD *)(a1 + 1208);
  if (v89)
    (*(void (**)(uint64_t, _QWORD))(a1 + 8))(v89, *(_QWORD *)(a1 + 16));
  v90 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a1)(v83, *(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 944) = v90;
  *(_QWORD *)(a1 + 1208) = v90;
  if (!v90 || (bzero(v90, v83), !*(_QWORD *)(a1 + 1208)))
  {
    aj_log_error((uint64_t)"Recode", "Could not allocate memory for the plugin input buffer");
    goto LABEL_133;
  }
  v91 = *(_QWORD *)(a1 + 944);
  *(_QWORD *)(a1 + 680) = v91;
  if (v88)
  {
    v43 = v138;
    *(_QWORD *)(a1 + 648) = (int)(v136 * v138);
  }
  else
  {
    *(_QWORD *)(a1 + 648) = v136;
    *(_QWORD *)(a1 + 688) = v91 + v81 * v136;
    *(_QWORD *)(a1 + 656) = 2 * (v136 / v45);
    v43 = v138;
  }
LABEL_83:
  if (*(_BYTE *)(a1 + 414))
  {
    v56 = v43;
    v57 = (int)(*(_DWORD *)(a1 + 480) * v43 * v142.i32[0]);
    v58 = *(_QWORD *)(a1 + 976);
    if (v58)
      (*(void (**)(uint64_t, _QWORD))(a1 + 8))(v58, *(_QWORD *)(a1 + 16));
    v59 = (void *)(*(uint64_t (**)(size_t, _QWORD))a1)(v57, *(_QWORD *)(a1 + 16));
    *(_QWORD *)(a1 + 1216) = v59;
    *(_QWORD *)(a1 + 976) = v59;
    if (!v59 || (bzero(v59, v57), !*(_QWORD *)(a1 + 976)))
    {
      aj_log_error((uint64_t)"Recode", "Unable to allocate the convert buffer");
      goto LABEL_133;
    }
    *(_DWORD *)(a1 + 1008) = v45;
    *(_DWORD *)(a1 + 1024) = v40;
    *(_DWORD *)(a1 + 1020) = *(_DWORD *)(a1 + 480);
    v60 = v142.i32[0];
    *(_DWORD *)(a1 + 1016) = v142.i32[0];
    *(_QWORD *)(a1 + 1096) = (int)(v60 * v56);
  }
  v61 = *(_DWORD *)(a1 + 928);
  v62 = applejpeg_encode_create((__int128 *)a1);
  *(_QWORD *)(a1 + 32) = v62;
  if (!v62)
  {
LABEL_133:
    v14 = 6;
    goto LABEL_53;
  }
  *((_DWORD *)v62 + 3328) = 1;
  *(_DWORD *)(a1 + 824) = v61;
  *(int32x2_t *)(a1 + 816) = v142;
  if (!*(_BYTE *)(a1 + 253))
  {
    *(_QWORD *)&v148 = 0;
    v146 = 0u;
    v147 = 0u;
    format_description = aj_get_format_description(v61, (uint64_t)&v146);
    if ((_DWORD)format_description)
    {
LABEL_136:
      v14 = format_description;
      goto LABEL_53;
    }
    v97 = DWORD2(v147);
    v98 = HIDWORD(v147);
    chroma_subsampling = applejpeg_decode_get_chroma_subsampling(*(_DWORD **)(a1 + 24));
    subsampling_from_jpeg_format = aj_get_subsampling_from_jpeg_format(chroma_subsampling);
    if (v97 <= (int)subsampling_from_jpeg_format)
      v101 = subsampling_from_jpeg_format;
    else
      v101 = v97;
    if (v98 <= SHIDWORD(subsampling_from_jpeg_format))
      v102 = HIDWORD(subsampling_from_jpeg_format);
    else
      v102 = v98;
    *(_DWORD *)(a1 + 312) = aj_get_jpeg_format_from_subsampling(v101 | (v102 << 32), *(_DWORD *)(*(_QWORD *)(a1 + 24) + 144));
  }
  v63 = (_OWORD *)(a1 + 256);
  v64 = *(_OWORD *)(a1 + 896);
  v150 = *(_OWORD *)(a1 + 880);
  v151 = v64;
  v152 = *(_OWORD *)(a1 + 912);
  v65 = *(_OWORD *)(a1 + 832);
  v146 = *(_OWORD *)(a1 + 816);
  v147 = v65;
  v66 = *(_OWORD *)(a1 + 864);
  v148 = *(_OWORD *)(a1 + 848);
  v149 = v66;
  if (*(_BYTE *)(a1 + 414))
  {
    v67 = *(_OWORD *)(a1 + 1112);
    v151 = *(_OWORD *)(a1 + 1096);
    v152 = v67;
  }
  v68 = *(_QWORD *)(a1 + 32);
  if (a2)
    v69 = applejpeg_encode_set_options_mem(v68, v63, (uint64_t)&v146, a2);
  else
    v69 = applejpeg_encode_set_options_file(v68, v63, (uint64_t)&v146, a3);
  v14 = v69;
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 3464) = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3560);
  if (!(_DWORD)v69)
  {
    v93 = DWORD1(v141);
    v94 = *(_DWORD *)(a1 + 940);
    switch(v94)
    {
      case 0:
        v95 = *(_DWORD *)(a1 + 964);
        v96 = DWORD2(v141) | ((unint64_t)v95 << 32);
        goto LABEL_152;
      case 1:
        v95 = *(_DWORD *)(a1 + 964);
        v96 = DWORD2(v141) | ((unint64_t)v95 << 32);
        LODWORD(v93) = HIDWORD(v141) + DWORD1(v141) - v95;
LABEL_152:
        v105 = (int)v95 < SHIDWORD(v141);
        goto LABEL_154;
      case 2:
        v106 = *(unsigned int *)(a1 + 964);
        v96 = *((_QWORD *)&v141 + 1) & 0xFFFFFFFF00000000 | v106;
        v105 = (int)v106 < SDWORD2(v141);
LABEL_154:
        v103 = !v105;
        v104 = v141;
        break;
      case 3:
        v107 = *(unsigned int *)(a1 + 964);
        v96 = *((_QWORD *)&v141 + 1) & 0xFFFFFFFF00000000 | v107;
        v104 = DWORD2(v141) + v141 - v107;
        v103 = (int)v107 >= SDWORD2(v141);
        break;
      default:
        v103 = 0;
        v96 = *((_QWORD *)&v141 + 1);
        v104 = v141;
        break;
    }
    v108 = aj_limit_region(v104 | ((unint64_t)v93 << 32), v96, v141);
    v110 = v109;
    v111 = 0;
    v140 = (int *)(a1 + 632);
    while (1)
    {
      v155 = 0;
      v153 = 0u;
      v154 = 0u;
      v151 = 0u;
      v152 = 0u;
      v149 = 0u;
      v150 = 0u;
      v147 = 0u;
      v148 = 0u;
      v146 = 0u;
      *(_QWORD *)(a1 + 92) = v108;
      v112 = HIDWORD(v110);
      *(_QWORD *)(a1 + 100) = v110;
      if (!v103 || (v113 = *(_DWORD *)(a1 + 156), (int)v110 / v113) && SHIDWORD(v110) / v113)
      {
        if (v111 & 1 | (v94 == 0))
        {
          *(_QWORD *)(a1 + 184) = 0;
          *(_DWORD *)(a1 + 180) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 180) = 1;
          if ((v94 - 1) > 2)
          {
            v116 = 0;
            v115 = 0;
          }
          else
          {
            v115 = dword_20627BF1C[v94 - 1];
            v116 = 1;
          }
          *(_DWORD *)(a1 + 184) = v116;
          *(_DWORD *)(a1 + 188) = v115;
        }
        v157 = 0;
        v158 = 0;
        v156 = 0;
        memset(v144, 0, sizeof(v144));
        v145 = 0;
        format_description = applejpeg_decode_set_options(*(_QWORD *)(a1 + 24), a1 + 80, &v158, (uint64_t)v144, &v157, (_DWORD *)&v156 + 1, &v156);
        if ((_DWORD)format_description)
          goto LABEL_136;
        v117 = v145;
        if ((int)v145 >= 1)
        {
          v118 = 0;
          v119 = 8 * v145;
          v120 = v160;
          do
          {
            if (v118)
            {
              v121 = (_QWORD *)(a1 + v118 + 648);
              v122 = *(_DWORD *)(a1 + 636) / *(_DWORD *)(a1 + 936);
            }
            else
            {
              v122 = *(_DWORD *)(a1 + 636);
              v121 = (_QWORD *)(a1 + 648);
            }
            *(v120 - 1) = *(_QWORD *)(a1 + v118 + 680) + *v121 * v122;
            *v120 = *(_QWORD *)((char *)v144 + v118);
            v120 += 2;
            v118 += 8;
          }
          while (v119 != v118);
        }
        v123 = applejpeg_decode_image_all(*(_QWORD *)(a1 + 24), &v159, v117, (uint64_t)&v146);
        if ((_DWORD)v123)
        {
          v14 = v123;
          aj_log_error((uint64_t)"Recode", "Decoder returned error code %d", v123);
          *(_DWORD *)(a1 + 644) = *(_DWORD *)(a1 + 636);
          *(_DWORD *)(a1 + 640) = HIDWORD(v148);
          break;
        }
        v114 = HIDWORD(v148);
      }
      else
      {
        v114 = 0;
      }
      *(_DWORD *)(a1 + 644) = *(_DWORD *)(a1 + 636);
      *(_DWORD *)(a1 + 640) = v114;
      v124 = (*(uint64_t (**)(_QWORD, uint64_t, int *, BOOL))(a1 + 392))(*(_QWORD *)(a1 + 472), a1 + 640, v140, v103);
      if ((_DWORD)v124)
      {
        v14 = v124;
        aj_log_error((uint64_t)"Recode", "Resize plugin returned error code %d on resize()", v124);
        break;
      }
      v125 = *(_DWORD *)(a1 + 636);
      if (*(int *)(a1 + 936) >= 2)
      {
        if (!v103 && (v125 & 1) != 0)
        {
          aj_log_error((uint64_t)"Recode", "Resize-plugin can't save an odd number of rows when the data fromat is 420f");
          goto LABEL_214;
        }
        if (!v103 && (*v140 & 1) != 0)
        {
          aj_log_error((uint64_t)"Recode", "Plugin wrote an uneven nbrof rows");
          goto LABEL_214;
        }
      }
      if (v125 > *(_DWORD *)(a1 + 484))
      {
        aj_log_error((uint64_t)"Recode", "Resize-plugin saved more more rows than allowed");
LABEL_214:
        v14 = 1;
        break;
      }
      if (v103 && v125)
      {
        aj_log_error((uint64_t)"Recode", "Resize-plugin saved rows on the last call");
        goto LABEL_214;
      }
      v126 = *v140;
      if (*v140)
      {
        *(_DWORD *)(a1 + 820) = v126;
        v127 = (unsigned int *)(a1 + 776);
        if (*(_BYTE *)(a1 + 414))
        {
          *(_DWORD *)(a1 + 1020) = v126;
          (*(void (**)(_QWORD, uint64_t, uint64_t))(a1 + 432))(*(_QWORD *)(a1 + 424), a1 + 776, a1 + 976);
          v127 = (unsigned int *)(a1 + 976);
        }
        v128 = applejpeg_encode_image_row(*(_QWORD *)(a1 + 32), v127, a4);
        v14 = v128;
        if (v103 || (_DWORD)v128)
          break;
      }
      else if (v103)
      {
        v14 = 0;
        break;
      }
      v129 = HIDWORD(v108);
      v94 = *(_DWORD *)(a1 + 940);
      switch(v94)
      {
        case 0:
          v129 = (HIDWORD(v108) + HIDWORD(v110));
          v112 = *(unsigned int *)(a1 + 960);
          v130 = (int)v112 + (int)v129 < HIDWORD(v141) + DWORD1(v141);
          goto LABEL_200;
        case 1:
          v112 = *(unsigned int *)(a1 + 960);
          v129 = (HIDWORD(v108) - v112);
          v131 = (int)v129 <= SDWORD1(v141);
          goto LABEL_204;
        case 2:
          LODWORD(v108) = v108 + v110;
          LODWORD(v110) = *(_DWORD *)(a1 + 960);
          v130 = (int)v110 + (int)v108 < DWORD2(v141) + (int)v141;
LABEL_200:
          v103 = !v130;
          break;
        case 3:
          LODWORD(v110) = *(_DWORD *)(a1 + 960);
          LODWORD(v108) = v108 - v110;
          v131 = (int)v108 <= (int)v141;
LABEL_204:
          v103 = v131;
          break;
        default:
          v103 = 0;
          break;
      }
      v108 = aj_limit_region(v108 | (v129 << 32), v110 | (v112 << 32), v141);
      v110 = v132;
      v111 = 1;
    }
  }
LABEL_53:
  v28 = *(void (**)(_QWORD))(a1 + 400);
  if (v28 && *(_DWORD *)(a1 + 972))
  {
    v28(*(_QWORD *)(a1 + 472));
    *(_QWORD *)(a1 + 472) = 0;
  }
  *(_DWORD *)(a1 + 972) = 0;
  v29 = *(_QWORD *)(a1 + 32);
  if (v29)
  {
    applejpeg_encode_destroy(v29);
    *(_QWORD *)(a1 + 32) = 0;
  }
  return v14;
}

uint64_t aj_limit_region(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  if ((int)a1 < (int)a3)
    v3 = a3;
  else
    v3 = a1;
  if (SHIDWORD(a1) <= SHIDWORD(a3))
    v4 = HIDWORD(a3);
  else
    v4 = HIDWORD(a1);
  return v3 | (v4 << 32);
}

char *pad_region(char *result, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char *v11;
  char *v12;
  size_t v13;
  int v14;
  int v15;
  int v16;
  size_t v17;
  char *v18;
  char *v19;

  if (result)
  {
    v11 = result;
    if (a2 > a6 + a4 && a7 >= 1)
    {
      v12 = &result[a5 * (uint64_t)a2 + a6 + a4];
      v13 = a2 - (a6 + a4);
      v14 = a7;
      do
      {
        result = (char *)memset(v12, *(v12 - 1), v13);
        v12 += a2;
        --v14;
      }
      while (v14);
    }
    v15 = a7 + a5;
    v16 = a3 - (a7 + a5);
    if (a3 > v15 && v16 >= 1)
    {
      v17 = a2;
      v18 = &v11[v15 * (uint64_t)a2];
      v19 = &v18[-a2];
      do
      {
        result = (char *)memcpy(v18, v19, v17);
        v18 += v17;
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

uint64_t aj_encode_release_scan_buffers(uint64_t result, uint64_t a2)
{
  _DWORD *v2;
  int v4;
  _QWORD *v5;
  uint64_t v6;

  v2 = (_DWORD *)(result + 19808);
  if (*(int *)(result + 19808) >= 1)
  {
    v4 = 0;
    v5 = (_QWORD *)(*(_QWORD *)(result + 19816) + 184);
    do
    {
      if (*v5)
      {
        (*(void (**)(_QWORD, _QWORD))(a2 + 8))(*v5, *(_QWORD *)(a2 + 16));
        *v5 = 0;
      }
      v6 = *(v5 - 2);
      if (v6)
      {
        (*(void (**)(uint64_t, _QWORD))(a2 + 8))(v6, *(_QWORD *)(a2 + 16));
        *(v5 - 2) = 0;
      }
      result = *(v5 - 9);
      if (result)
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 8))(result, *(_QWORD *)(a2 + 16));
        *(v5 - 9) = 0;
      }
      ++v4;
      v5 += 38;
    }
    while (v4 < *v2);
  }
  return result;
}

unsigned int *aj_reset_row_ptrs(unsigned int *result, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  uint64_t v7;
  uint64_t i;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  if (result[3340] == 14)
  {
    v3 = *((_QWORD *)result + 2471);
    v4 = *((_QWORD *)result + 2472);
    v5 = *((_QWORD *)result + 2473);
  }
  else
  {
    v3 = (int)result[3354];
    v6 = result[4];
    v4 = (int)(result[5] * v3) / v6;
    v5 = (int)(result[6] * v3) / v6;
    v14[3] = (int)(result[7] * v3) / v6;
  }
  v14[0] = v3;
  v14[1] = v4;
  v14[2] = v5;
  v7 = *result;
  if ((int)v7 >= 1)
  {
    for (i = 0; i != v7; ++i)
    {
      v9 = result[i + 8];
      if (v9 >= 1)
      {
        v10 = 0;
        LODWORD(v11) = 8 * v9;
        v12 = v14[i];
        if ((int)v11 <= 1)
          v11 = 1;
        else
          v11 = v11;
        v13 = a2;
        do
        {
          *v13++ = *(_QWORD *)(a3 + 8 * i) + v10;
          v10 += v12;
          --v11;
        }
        while (v11);
      }
      a2 += 16;
    }
  }
  return result;
}

uint64_t aj_allocate_enc_buffers(unsigned int *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  _QWORD *v16;
  _DWORD *v17;

  v6 = *a1;
  if ((int)v6 < 1)
  {
    v9 = 0;
  }
  else
  {
    v7 = 0;
    v8 = a1 + 3370;
    do
    {
      v7 += *v8;
      v8 += 392;
      --v6;
    }
    while (v6);
    v9 = v7 << 6;
  }
  v10 = (int)(v9 * a1[3358]);
  *((_QWORD *)a1 + 1681) = v10;
  v11 = a2 + 224;
  if (a2[224])
  {
    (*(void (**)(_QWORD, _QWORD))(a3 + 8))(a2[224], *(_QWORD *)(a3 + 16));
    v10 = *((_QWORD *)a1 + 1681);
  }
  v12 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a3)(v10, *(_QWORD *)(a3 + 16));
  *v11 = (uint64_t)v12;
  if (v12 && (bzero(v12, *((_QWORD *)a1 + 1681)), (v13 = *v11) != 0))
  {
    v14 = *a1;
    if ((int)v14 >= 1)
    {
      v15 = a1[3358];
      v16 = a2 + 224;
      v17 = a1 + 3370;
      do
      {
        *v16++ = v13;
        v13 += (int)((*v17 * v15) << 6);
        v17 += 392;
        --v14;
      }
      while (v14);
    }
    aj_reset_row_ptrs(a1, a2, (uint64_t)(a2 + 224));
    return 0;
  }
  else
  {
    aj_log_error((uint64_t)"EncodeInit", "Could not allocate memory for mcu buffer");
    return 6;
  }
}

uint64_t aj_init_out_stream(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = *a3;
  v4 = *((_DWORD *)a3 + 2);
  *(_DWORD *)(result + 64) = v4;
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 24) = v3;
  *(_QWORD *)(result + 32) = v5;
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = v3;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = v4;
  return result;
}

uint64_t aj_encode_init(uint64_t *a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  _DWORD *v14;
  int v15;
  int v16;
  void *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  _DWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  int v30;
  uint64_t (*v31)();
  uint64_t v32;
  uint64_t result;
  uint64_t v34;
  uint64_t (**v35)();
  int v36;
  unint64_t v37;
  int v38;
  int v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  int v48;
  int v49;
  char *v50;
  int v51;
  BOOL v52;
  char *v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  _DWORD *v59;
  char *v60;
  char *v61;
  uint64_t *v62;
  char *v63;
  int *v64;
  int v65;
  int *v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  _BOOL4 v71;
  uint64_t v72;
  uint64_t *v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  _BOOL4 v80;
  int v81;
  int v82;
  char *v83;
  int v84;
  uint64_t v85;
  BOOL v86;
  size_t v87;
  uint64_t v88;
  void *v89;
  size_t v90;
  void *v91;
  void *v92;
  int v93;
  uint64_t *v94;
  _DWORD *v95;
  int v96;
  int v97;
  __int128 v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  void *v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unsigned __int8 *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  size_t v134;
  uint64_t v135;
  uint64_t v136;
  void *v137;
  uint64_t v138;
  uint64_t v139;
  _QWORD *v140;
  int v141;
  int v142;
  int v143;
  int v144;
  uint64_t v145;
  int v146;
  uint64_t v148;
  int v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t *v152;
  uint64_t v153;
  uint64_t v154;
  _DWORD *v155;
  _DWORD *v156;
  int v157;
  size_t v158;
  char *v159;
  _DWORD *v160;
  uint64_t *v161;

  v14 = (_DWORD *)(a2 + 13440);
  *(_QWORD *)(a2 + 13284) = 0;
  *(_OWORD *)(a2 + 13268) = xmmword_20627BF30;
  v15 = a4[2];
  *(_DWORD *)(a2 + 13360) = v15;
  v16 = *(_DWORD *)(a5 + 60);
  *(_DWORD *)(a2 + 19800) = v16 == 1;
  *(_DWORD *)(a2 + 19804) = v16 == 2;
  v17 = aj_encode_buffers_progressive;
  if (v16 != 1)
    v17 = aj_encode_buffers_baseline;
  *(_QWORD *)(a2 + 19752) = v17;
  v160 = (_DWORD *)(a2 + 13440);
  if (v15 != 14)
  {
    v27 = (_DWORD *)(a2 + 19832);
    *(_DWORD *)(a2 + 19848) = 1;
    *(_OWORD *)(a2 + 19832) = xmmword_20627BF40;
    v28 = (_QWORD *)(a2 + 19844);
    v29 = (_QWORD *)(a2 + 19836);
    switch(v15)
    {
      case 0:
        *(_DWORD *)(a2 + 13444) = 3;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBCC8;
        goto LABEL_54;
      case 1:
        *(_DWORD *)(a2 + 13444) = 2;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBD40;
        goto LABEL_54;
      case 2:
        *(_DWORD *)(a2 + 13444) = 2;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBD68;
        goto LABEL_54;
      case 3:
        *(_DWORD *)(a2 + 13444) = 4;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBCF0;
        goto LABEL_54;
      case 4:
        *(_DWORD *)(a2 + 13444) = 4;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBD18;
        goto LABEL_54;
      case 5:
        v36 = 1;
        goto LABEL_52;
      case 6:
        *(_DWORD *)(a2 + 13444) = 3;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBDB8;
        goto LABEL_54;
      case 8:
      case 9:
        *v27 = 1;
        if (v15 == 9)
          *v29 = 0x100000002;
        *(_DWORD *)(a2 + 19848) = 2;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBDE0;
        goto LABEL_54;
      case 10:
      case 11:
        *v27 = 1;
        if (v15 == 11)
          *v29 = 0x100000002;
        *v28 = 0x200000002;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBE08;
        goto LABEL_54;
      case 12:
      case 13:
        *v27 = 1;
        if (v15 == 13)
          *v29 = 0x100000002;
        *(_DWORD *)v28 = 2;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
          goto LABEL_55;
        v35 = &off_24BEFBE30;
        goto LABEL_54;
      case 15:
        *(_DWORD *)(a2 + 13444) = 4;
        v31 = (uint64_t (*)())aj_deinterleave_8888;
        goto LABEL_56;
      case 16:
      case 17:
      case 20:
        if (v15 == 20)
          v30 = 6;
        else
          v30 = 8;
        *(_DWORD *)(a2 + 13444) = v30;
        *(_QWORD *)(a2 + 19744) = 0;
        if (v16 != 2)
        {
          aj_log_error((uint64_t)"EncodeInit", "16-bit RGB only supported for lossless encoding");
          return 3;
        }
        v31 = 0;
LABEL_60:
        if (*v27)
        {
          v38 = v14[1602];
          v39 = *a4 & 1;
          if (v38 != 2)
            v39 = 0;
          v40 = v39 + *a4;
          v41 = *((_QWORD *)a4 + 10);
          v42 = v40;
          if (v41)
          {
            v42 = *((_QWORD *)a4 + 10);
            if (v41 < v40)
              goto LABEL_78;
          }
          *(_QWORD *)(a2 + 19768) = v42;
          v43 = *((_QWORD *)a4 + 11);
          v44 = 2 * (v40 / v38);
          if (v43)
          {
            if (v43 < v44)
              goto LABEL_78;
          }
          else
          {
            v43 = v44;
          }
          *(_QWORD *)(a2 + 19776) = v43;
          if (v31)
            goto LABEL_87;
        }
        else
        {
          v47 = *((_QWORD *)a4 + 10);
          v48 = *(_DWORD *)(a2 + 13444);
          if (v47)
          {
            if (v47 < v48 * (uint64_t)*a4)
              goto LABEL_78;
          }
          else
          {
            v47 = v48 * (uint64_t)*a4;
          }
          *(_QWORD *)(a2 + 19768) = v47;
          if (v31)
            goto LABEL_87;
        }
        if (v14[1591])
          goto LABEL_87;
        aj_log_error((uint64_t)"EncodeInit", "Colortransform function pointer is NULL.");
        return 5;
      case 18:
        v36 = 2;
LABEL_52:
        *(_DWORD *)(a2 + 13444) = v36;
        v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
        {
LABEL_55:
          aj_log_error((uint64_t)"EncodeInit", "Unsupported output format.");
          v14 = v160;
          v31 = 0;
        }
        else
        {
          v35 = &off_24BEFBD90;
LABEL_54:
          v31 = v35[v34];
        }
LABEL_56:
        *(_QWORD *)(a2 + 19744) = v31;
        v15 = *(_DWORD *)(a2 + 13360);
        if (v15 == 14)
          goto LABEL_57;
        goto LABEL_60;
      default:
        aj_log_error((uint64_t)"EncodeInit", "Unsupported input format");
        return 3;
    }
  }
  v19 = *((_OWORD *)a4 + 3);
  v18 = *((_OWORD *)a4 + 4);
  v20 = *((_OWORD *)a4 + 2);
  *(_OWORD *)(a2 + 13296) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a2 + 13328) = v19;
  *(_OWORD *)(a2 + 13344) = v18;
  *(_OWORD *)(a2 + 13312) = v20;
  v21 = *(_QWORD *)(a2 + 13304);
  v22 = (unint64_t)(v21 + 1) >> 1;
  v23 = *(_QWORD *)(a2 + 13296);
  v24 = *(_QWORD *)(a2 + 13328);
  if (v23 == v24)
  {
    v25 = *(_QWORD *)(a2 + 13336);
    if (v21 == v25)
    {
      v26 = 0;
      goto LABEL_20;
    }
    if (v22 == v25)
    {
      v26 = 2;
      goto LABEL_20;
    }
LABEL_21:
    aj_log_error((uint64_t)"EncodeInit", "Unknown input decimation");
    return 3;
  }
  if (v24 != (unint64_t)(v23 + 1) >> 1)
    goto LABEL_21;
  v32 = *(_QWORD *)(a2 + 13336);
  if (v21 == v32)
  {
    v26 = 1;
    goto LABEL_20;
  }
  if (v22 != v32)
    goto LABEL_21;
  v26 = 3;
LABEL_20:
  *(_DWORD *)(a5 + 56) = v26;
  v27 = (_DWORD *)(a2 + 19832);
  v28 = (_QWORD *)(a2 + 19844);
  *(_DWORD *)(a2 + 19848) = 1;
  *(_OWORD *)(a2 + 19832) = xmmword_20627BF40;
LABEL_57:
  v37 = *((_QWORD *)a4 + 10);
  if (v37)
  {
    if (v37 < *((_QWORD *)a4 + 2))
      goto LABEL_78;
  }
  else
  {
    v37 = *((_QWORD *)a4 + 2);
  }
  *(_QWORD *)(a2 + 19768) = v37;
  v45 = *((_QWORD *)a4 + 11);
  if (v45)
  {
    if (v45 < *((_QWORD *)a4 + 6))
      goto LABEL_78;
  }
  else
  {
    v45 = *((_QWORD *)a4 + 6);
  }
  *(_QWORD *)(a2 + 19776) = v45;
  v46 = *((_QWORD *)a4 + 12);
  if (v46)
  {
    if (v46 < *((_QWORD *)a4 + 6))
    {
LABEL_78:
      aj_log_error((uint64_t)"EncodeInit", "Set stride is smaller than the image data");
      return 8;
    }
  }
  else
  {
    v46 = *((_QWORD *)a4 + 6);
  }
  *(_QWORD *)(a2 + 19784) = v46;
  v15 = 14;
LABEL_87:
  if (v14[1590])
  {
    if (*(_QWORD *)(a5 + 72))
    {
      v49 = *(_DWORD *)(a5 + 64);
      if (v49 < 1)
        return 1;
      v159 = *(char **)(a5 + 72);
    }
    else
    {
      v49 = 10;
      if (v15 == 15)
      {
        v159 = (char *)&prog_scan_cmyk;
      }
      else
      {
        v51 = *(_DWORD *)(a5 + 56);
        v52 = v51 == 4;
        if (v51 == 4)
          v53 = (char *)&prog_scan_gray;
        else
          v53 = (char *)&prog_scan_yuv;
        v159 = v53;
        if (v52)
          v49 = 6;
        else
          v49 = 10;
      }
    }
  }
  else
  {
    if (v15 == 15)
    {
      v50 = (char *)&base_scan_cmyk;
    }
    else
    {
      v50 = (char *)&base_scan_yuv;
      if (*(_DWORD *)(a5 + 56) == 4)
        v50 = (char *)&base_scan_gray;
    }
    v159 = v50;
    v49 = 1;
  }
  if (*(_QWORD *)(a2 + 19816))
    aj_encode_release_scan_buffers(a2, *a1);
  v156 = v28;
  v54 = a1[5];
  if (v54)
    (*(void (**)(uint64_t, _QWORD))(*a1 + 8))(v54, *(_QWORD *)(*a1 + 16));
  v55 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))*a1)(304 * v49, *(_QWORD *)(*a1 + 16));
  *(_QWORD *)(a2 + 19816) = v55;
  a1[5] = (uint64_t)v55;
  if (!v55 || (bzero(v55, 304 * v49), (v56 = *(_QWORD *)(a2 + 19816)) == 0))
  {
    aj_log_error((uint64_t)"EncodeInit", "Unable to allocate scan info");
    return 6;
  }
  v155 = v27;
  v152 = a7;
  v153 = a6;
  v161 = a1;
  v57 = 0;
  v58 = *(_DWORD *)(a2 + 12) * *(_DWORD *)(a2 + 8) / (2 * v49);
  v154 = a3;
  v59 = v160;
  v160[1592] = v49;
  if (v58 <= 0x1000)
    v58 = 4096;
  v157 = v58;
  v158 = v58;
  v60 = v159;
  v61 = v159 + 4;
  v62 = (uint64_t *)(v56 + 272);
  do
  {
    v63 = &v60[36 * v57];
    v64 = (int *)(v63 + 20);
    v65 = *((_DWORD *)v63 + 5);
    v68 = *((_DWORD *)v63 + 7);
    v66 = (int *)(v63 + 28);
    v67 = v68;
    v69 = *(unsigned int *)&v60[36 * v57];
    *(_DWORD *)v56 = v69;
    if ((int)v69 < 1)
    {
      v82 = v67;
      v81 = v65;
    }
    else
    {
      v70 = 0;
      if (v67)
        v71 = v65 != 0;
      else
        v71 = 1;
      v72 = 4 * v69;
      v73 = v62;
      do
      {
        v74 = *(_DWORD *)&v61[v70];
        v75 = v56 + v70;
        *(_DWORD *)(v56 + v70 + 4) = v74;
        *(v73 - 9) = a2 + 1568 * *(int *)&v61[v70] + 13472;
        if (v71)
        {
          v76 = v74 != 0;
          v77 = a2 + 548 * v76 + 274 * (v65 != 0) + 3424;
          if (v67)
            v77 = a2 + 274 * v76 + 10664;
          *(v73 - 4) = v77;
          v78 = a2 + (v76 << 11) + ((unint64_t)(v65 != 0) << 10) + 4520;
          v79 = a2 + (v76 << 10) + 11212;
          if (!v67)
            v79 = v78;
          *v73 = v79;
        }
        v70 += 4;
        v80 = v74 != 0;
        *(_DWORD *)(v75 + 20) = v80;
        *(_DWORD *)(v75 + 36) = v80;
        ++v73;
      }
      while (v72 != v70);
      v81 = *v64;
      v82 = *v66;
    }
    v83 = &v60[36 * v57];
    v84 = *((_DWORD *)v83 + 6);
    *(_DWORD *)(v56 + 52) = v81;
    *(_DWORD *)(v56 + 56) = v84;
    *(_DWORD *)(v56 + 60) = *((_DWORD *)v83 + 8);
    *(_DWORD *)(v56 + 64) = v82;
    *(_OWORD *)(v56 + 68) = xmmword_20627BF50;
    v85 = *v161;
    *(_QWORD *)(v56 + 160) = *v161;
    if (v59[1590])
    {
      if (v65)
        v86 = v67 == 0;
      else
        v86 = 1;
      if (v86)
      {
        v87 = v158;
      }
      else
      {
        v88 = *(_QWORD *)(v56 + 184);
        if (v88)
        {
          (*(void (**)(uint64_t, _QWORD))(v85 + 8))(v88, *(_QWORD *)(v85 + 16));
          v85 = *v161;
        }
        v89 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))v85)(1024, *(_QWORD *)(v85 + 16));
        *(_QWORD *)(v56 + 184) = v89;
        if (!v89 || (bzero(v89, 0x400uLL), !*(_QWORD *)(v56 + 184)))
        {
          aj_log_error((uint64_t)"EncodeInit", "Unable to allocate the correction-bit buffer");
          return 6;
        }
        *(_QWORD *)(v56 + 192) = 1024;
        v85 = *v161;
        v87 = v158;
      }
      *(_QWORD *)(v56 + 232) = *(&off_24BEFBCA8 + 2 * (v65 != 0) + (v67 != 0));
      *(_QWORD *)(v56 + 168) = 0;
      *(_QWORD *)(v56 + 176) = 0;
      v90 = v87;
      v91 = (void *)(*(uint64_t (**)(void))v85)();
      if (!v91)
      {
        aj_log_error((uint64_t)"EncodeInit", "Unable to allocate %zd bytes for scan #%d out-stream");
        return 6;
      }
      v92 = v91;
      bzero(v91, v90);
      *(_DWORD *)(v56 + 152) = v157;
      *(_QWORD *)(v56 + 120) = v56;
      *(_QWORD *)(v56 + 128) = progscan_write_callback;
      *(_QWORD *)(v56 + 112) = v92;
      *(_QWORD *)(v56 + 88) = 0;
      *(_QWORD *)(v56 + 96) = v92;
      *(_DWORD *)(v56 + 104) = 0;
      *(_DWORD *)(v56 + 108) = v157;
      v59 = v160;
      v60 = v159;
    }
    ++v57;
    v56 += 304;
    v61 += 36;
    v62 += 38;
  }
  while (v57 != v49);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)a4;
  v93 = *(_DWORD *)(a5 + 60);
  if (v93 == 2)
  {
    LOBYTE(v93) = 0;
    v96 = 195;
    v94 = v161;
    v95 = v155;
  }
  else
  {
    v94 = v161;
    v95 = v155;
    if (v93 == 1)
    {
      v96 = 194;
    }
    else
    {
      LOBYTE(v93) = 0;
      v96 = 192;
    }
  }
  *(_DWORD *)(a2 + 80) = v96;
  *(_BYTE *)(a2 + 84) = v93;
  if (*(_DWORD *)(a2 + 13360) == 15)
  {
    v97 = 4;
    *(_DWORD *)a2 = 4;
    *(_QWORD *)&v98 = 0x100000001;
    *((_QWORD *)&v98 + 1) = 0x100000001;
    *(_OWORD *)(a2 + 16) = v98;
    *(_OWORD *)(a2 + 32) = v98;
  }
  else
  {
    v99 = *(unsigned int *)(a5 + 56);
    if (v99 == 4)
      v97 = 1;
    else
      v97 = 3;
    *(_DWORD *)a2 = v97;
    switch((int)v99)
    {
      case 0:
        *(_DWORD *)(a2 + 24) = 1;
        v100 = 0x100000001;
        goto LABEL_165;
      case 1:
        *(_DWORD *)(a2 + 24) = 1;
        *(_QWORD *)(a2 + 16) = 0x100000002;
        *(_DWORD *)(a2 + 40) = 1;
        v100 = 0x100000001;
        goto LABEL_166;
      case 2:
        *(_DWORD *)(a2 + 13272) = 1;
        *(_DWORD *)(a2 + 24) = 1;
        *(_DWORD *)(a2 + 40) = 1;
        *(_QWORD *)(a2 + 32) = 0x100000002;
        *(_QWORD *)(a2 + 16) = 0x100000001;
        break;
      case 3:
        *(_DWORD *)(a2 + 13272) = 1;
        *(_DWORD *)(a2 + 24) = 1;
        v100 = 0x100000002;
LABEL_165:
        *(_QWORD *)(a2 + 16) = v100;
        *(_DWORD *)(a2 + 40) = 1;
        goto LABEL_166;
      default:
        *(_DWORD *)(a2 + 24) = 0;
        v100 = 1;
        *(_QWORD *)(a2 + 16) = 1;
        *(_DWORD *)(a2 + 40) = 0;
LABEL_166:
        *(_QWORD *)(a2 + 32) = v100;
        break;
    }
  }
  *(_DWORD *)(a2 + 4) = 8;
  if (*(_DWORD *)(a5 + 16))
  {
    *(_OWORD *)(a2 + 48) = xmmword_20627BF60;
    aj_get_qtable_for_quality(a2 + 88, *(_DWORD *)(a5 + 16), 1, 0);
    aj_get_qtable_for_quality(a2 + 344, *(_DWORD *)(a5 + 16), 0, 0);
    v59 = v160;
  }
  else
  {
    v101 = 0;
    v102 = a2 + 88;
    do
    {
      if (v101)
      {
        v103 = 0;
        v104 = *(_QWORD *)(a5 + 8 * v101 + 24);
        while (v104 != *(_QWORD *)(a5 + 24 + 8 * v103))
        {
          if (v101 == ++v103)
            goto LABEL_176;
        }
        *(_DWORD *)(a2 + 4 * v101 + 48) = v103;
      }
      else
      {
        v104 = *(_QWORD *)(a5 + 24);
LABEL_176:
        v105 = 0;
        *(_DWORD *)(a2 + 4 * v101 + 48) = v101;
        do
        {
          *(_DWORD *)(v102 + 4 * v105) = *(unsigned __int8 *)(v104 + v105);
          ++v105;
        }
        while (v105 != 64);
      }
      ++v101;
      v102 += 256;
    }
    while (v101 != v97);
  }
  *(_OWORD *)(a2 + 64) = xmmword_20627BF80;
  *(_OWORD *)(a2 + 3340) = xmmword_20627BF70;
  *(_OWORD *)(a2 + 3356) = xmmword_20627BF60;
  *(_OWORD *)(a2 + 3372) = xmmword_20627BF60;
  v106 = *(_QWORD *)(a2 + 19816);
  *(_DWORD *)(a2 + 3336) = *(_DWORD *)v106;
  *(_OWORD *)(a2 + 3388) = *(_OWORD *)(v106 + 52);
  v107 = *(_DWORD *)(a2 + 13360);
  if ((*(_DWORD *)(a5 + 56) & 0xFFFFFFFE) != 2)
  {
    v108 = 0;
    goto LABEL_185;
  }
  if (v107 == 14)
  {
    v108 = 0;
    v109 = *(_DWORD *)(a2 + 32);
    v110 = 8 * v109;
LABEL_186:
    v111 = v110;
    goto LABEL_187;
  }
  if (!*v95 || *v156 == 1)
  {
    v134 = vaddvq_s64(vaddq_s64(*(int64x2_t *)(v59 + 1586), *(int64x2_t *)(v59 + 1582)));
    v135 = v94[2];
    v136 = *v94;
    if (v135)
    {
      (*(void (**)(uint64_t, _QWORD))(v136 + 8))(v135, *(_QWORD *)(v136 + 16));
      v136 = *v94;
    }
    v137 = (void *)(*(uint64_t (**)(size_t, _QWORD))v136)(v134, *(_QWORD *)(v136 + 16));
    v94[2] = (uint64_t)v137;
    if (!v137)
    {
      aj_log_error((uint64_t)"EncodeInit", "Could not allocate input buffer memory");
      return 6;
    }
    v108 = v137;
    bzero(v137, v134);
    v107 = *(_DWORD *)(a2 + 13360);
    v59 = v160;
LABEL_185:
    v109 = *(_DWORD *)(a2 + 32);
    v110 = 8 * v109;
    v111 = v109;
    if (v107 != 14)
      goto LABEL_187;
    goto LABEL_186;
  }
  v108 = 0;
  v109 = *(_DWORD *)(a2 + 32);
  v110 = 8 * v109;
  v111 = v109;
LABEL_187:
  *(_DWORD *)(a2 + 13292) = v111;
  v112 = *(_DWORD *)(a2 + 8);
  v113 = *(_DWORD *)(a2 + 12);
  v114 = v113 / 8;
  if ((v113 & 7) != 0)
    ++v114;
  v115 = v114 / v109;
  if (v114 % v109)
    ++v115;
  *(_DWORD *)(a2 + 13436) = v115;
  v116 = v112 / 8;
  if ((v112 & 7) != 0)
    ++v116;
  v117 = *(_DWORD *)(a2 + 16);
  if (v116 % v117)
    v118 = v116 / v117 + 1;
  else
    v118 = v116 / v117;
  *(_DWORD *)(a2 + 13432) = v118;
  *(_DWORD *)(a2 + 13428) = v110;
  *(_DWORD *)(a2 + 13424) = 8 * v117;
  v119 = v115 * v110;
  *(_DWORD *)(a2 + 13420) = v119;
  *(_DWORD *)(a2 + 13416) = v118 * 8 * v117;
  if (v113 <= v119 - 8)
    *(_BYTE *)v59 = 1;
  if (v109 != 2 || !v59[1590])
    goto LABEL_205;
  v120 = v94[6];
  v121 = *v94;
  if (v120)
  {
    (*(void (**)(uint64_t, _QWORD))(v121 + 8))(v120, *(_QWORD *)(v121 + 16));
    v121 = *v94;
    v118 = *(_DWORD *)(a2 + 13432);
    v117 = *(_DWORD *)(a2 + 16);
  }
  v122 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))v121)((uint64_t)(v117 * v118) << 7, *(_QWORD *)(v121 + 16));
  *(_QWORD *)(a2 + 19824) = v122;
  v94[6] = (uint64_t)v122;
  if (!v122 || (bzero(v122, (uint64_t)(*(_DWORD *)(a2 + 16) * *(_DWORD *)(a2 + 13432)) << 7), !*(_QWORD *)(a2 + 19824)))
  {
    aj_log_error((uint64_t)"EncodeInit", "Unable to allocate progressive coeff buffer");
    return 6;
  }
  v107 = *(_DWORD *)(a2 + 13360);
  v59 = v160;
LABEL_205:
  if (v107 == 14)
  {
    v123 = *(_QWORD *)(a2 + 19768);
    *(_QWORD *)(a2 + 13368) = *(_QWORD *)(a2 + 13304) * v123;
    v124 = *(_QWORD *)(a2 + 19776);
    v125 = *(_QWORD *)(a2 + 13336);
    *(_QWORD *)(a2 + 13376) = v125 * v124;
    v126 = *(_QWORD *)(a2 + 19784);
    *(_QWORD *)(a2 + 13384) = v126 * v125;
    *(_QWORD *)(a2 + 13392) = *(int *)(a2 + 13312) + v123 * *(int *)(a2 + 13316);
    v127 = *(int *)(a2 + 13348);
    v128 = *(int *)(a2 + 13344);
    *(_QWORD *)(a2 + 13400) = v128 + v124 * v127;
    *(_QWORD *)(a2 + 13408) = v128 + v126 * v127;
  }
  v129 = a2 + 3424;
  if (v59[1590])
  {
    aj_huffman_encode_init_progressive(v129, 1, 1, 1);
    aj_huffman_encode_init_progressive(a2 + 3698, 1, 0, 1);
    aj_huffman_encode_init_progressive(a2 + 3972, 0, 1, 1);
    aj_huffman_encode_init_progressive(a2 + 4246, 0, 0, 1);
    aj_huffman_encode_init_progressive(a2 + 10664, 1, 0, 0);
    aj_huffman_encode_init_progressive(a2 + 10938, 0, 0, 0);
    aj_huffman_encode_init_lookups(a2 + 3424, (unsigned __int8 *)(a2 + 3440), a2 + 4520, 0);
    aj_huffman_encode_init_lookups(a2 + 3698, (unsigned __int8 *)(a2 + 3714), a2 + 5544, 0);
    aj_huffman_encode_init_lookups(a2 + 3972, (unsigned __int8 *)(a2 + 3988), a2 + 6568, 0);
    aj_huffman_encode_init_lookups(a2 + 4246, (unsigned __int8 *)(a2 + 4262), a2 + 7592, 0);
    aj_huffman_encode_init_lookups(a2 + 10664, (unsigned __int8 *)(a2 + 10680), a2 + 11212, 0);
    v130 = (unsigned __int8 *)(a2 + 10954);
    v131 = a2 + 12236;
    v132 = a2 + 10938;
    v133 = 0;
  }
  else
  {
    aj_huffman_encode_init_baseline(v129, 1, 1);
    aj_huffman_encode_init_baseline(a2 + 3698, 1, 0);
    aj_huffman_encode_init_baseline(a2 + 3972, 0, 1);
    aj_huffman_encode_init_baseline(a2 + 4246, 0, 0);
    aj_huffman_encode_init_lookups(a2 + 3424, (unsigned __int8 *)(a2 + 3440), a2 + 4520, 0);
    aj_huffman_encode_init_lookups(a2 + 3698, (unsigned __int8 *)(a2 + 3714), a2 + 5544, a2 + 8616);
    aj_huffman_encode_init_lookups(a2 + 3972, (unsigned __int8 *)(a2 + 3988), a2 + 6568, 0);
    v130 = (unsigned __int8 *)(a2 + 4262);
    v131 = a2 + 7592;
    v133 = a2 + 9640;
    v132 = a2 + 4246;
  }
  aj_huffman_encode_init_lookups(v132, v130, v131, v133);
  v138 = 0;
  *(_QWORD *)(v154 + 1896) = v108;
  v139 = 1832;
  do
  {
    v140 = (_QWORD *)(v154 + v139);
    *v140 = 0;
    v140[1] = 0;
    if (v108 && v138)
      *(_QWORD *)(v154 + 8 * v138 + 1896) = *(_QWORD *)(v154 + 8 * (v138 - 1) + 1896)
                                          + *(_QWORD *)(a2 + 8 * (v138 - 1) + 19768);
    *(_DWORD *)(v154 + 4 * v138++ + 2000) = 0;
    v139 += 16;
  }
  while (v138 != 4);
  v141 = *(_DWORD *)(a5 + 96);
  *(_DWORD *)(v154 + 2024) = v141;
  *(_QWORD *)(v154 + 2032) = *(_QWORD *)(a5 + 88);
  *(_QWORD *)(v154 + 2040) = *(_QWORD *)(a5 + 104);
  *(_DWORD *)(v154 + 2048) = v141;
  *(_DWORD *)(v154 + 1824) = 0;
  v142 = *(_DWORD *)(a2 + 13436);
  *(_DWORD *)(v154 + 1828) = v142;
  *(_QWORD *)(v154 + 2016) = 0;
  *(_QWORD *)(v154 + 2056) = 0;
  v143 = *(unsigned __int8 *)(a5 + 122);
  *(_DWORD *)(v154 + 2068) = v143;
  *(_DWORD *)(v154 + 2064) = v143 + 7;
  *(_QWORD *)(v154 + 2072) = *(_QWORD *)(a5 + 152);
  *(_DWORD *)(v154 + 2080) = *(_DWORD *)(a5 + 160);
  *(_QWORD *)(v154 + 2084) = 0;
  *(_BYTE *)(v154 + 2096) = *(_BYTE *)(a5 + 121);
  v144 = *(_DWORD *)(a5 + 4);
  if (v144)
  {
    v145 = v153;
    if ((*(_DWORD *)(a5 + 60) - 1) >= 2)
    {
      if (v144 == 2)
      {
        v144 = *(_DWORD *)(a2 + 13432);
        if (v144 >= 16)
        {
          v146 = v144 - 1;
          if (v144 >= 0x40)
            v146 = 64;
          if (v146 >= 0x10)
          {
            while (v144 % v146)
            {
              if (v146-- <= 16)
                goto LABEL_241;
            }
            v144 = v146;
          }
        }
      }
      else
      {
        if (v144 != 1)
        {
          aj_log_error((uint64_t)"EncodeInit", "Invalid interval units.");
          return 5;
        }
        v144 = *(_DWORD *)(a2 + 13432);
      }
LABEL_241:
      *(_DWORD *)(v154 + 2056) = v144;
    }
    else
    {
      v144 = 0;
    }
  }
  else
  {
    v145 = v153;
  }
  v148 = *v152;
  *(_QWORD *)(v154 + 1952) = *v152;
  v149 = *((_DWORD *)v152 + 2);
  *(_DWORD *)(v154 + 1992) = v149;
  v150 = *(_QWORD *)(v145 + 8);
  *(_QWORD *)(v154 + 1968) = v150;
  *(_QWORD *)(v154 + 1960) = *(_QWORD *)(v145 + 32);
  *(_QWORD *)(v154 + 1928) = 0;
  *(_DWORD *)(v154 + 1948) = v149;
  *(_QWORD *)(v154 + 1936) = v148;
  *(_DWORD *)(v154 + 1944) = 0;
  if (!v150)
  {
    aj_log_error((uint64_t)"EncodeInit", "Invalid output callback function.");
    return 5;
  }
  v151 = *(unsigned int *)(a5 + 144);
  if ((_DWORD)v151 && v144 >= 1 && v151 < v142 * *(_DWORD *)(a2 + 13432) / v144 - 1)
  {
    aj_log_error((uint64_t)"EncodeInit", "Restart marker offset table size does not match number of restart markers");
    return 5;
  }
  init_component((int *)a2);
  if (*(_DWORD *)(a2 + 13360) == 14)
    return 0;
  result = aj_allocate_enc_buffers((unsigned int *)a2, (_QWORD *)v154, *v94);
  if (!(_DWORD)result)
    v94[3] = *(_QWORD *)(v154 + 1792);
  return result;
}

int *init_component(int *result)
{
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int *v7;
  int v8;
  int *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  if (*result >= 1)
  {
    v1 = result;
    v2 = 0;
    v3 = 0;
    v4 = 3503;
    v5 = 843;
    v6 = result + 1130;
    do
    {
      v7 = &v1[v3];
      v8 = v7[4];
      v9 = &v1[v2];
      v9[3368] = v8;
      v10 = v7[8];
      v9[3369] = v10;
      v9[3370] = v10 * v8;
      v11 = v1[v5 - 4];
      *((_QWORD *)v9 + 1686) = &v1[137 * (int)v11 + 856];
      v12 = v1[v5];
      *((_QWORD *)v9 + 1687) = (char *)&v1[137 * (int)v12 + 924] + 2;
      *((_QWORD *)v9 + 1768) = &v6[512 * v11];
      *((_QWORD *)v9 + 1769) = &v6[512 * v12 + 256];
      *((_QWORD *)v9 + 1770) = &v1[256 * v12 + 2154];
      v9[3371] = 0;
      *(_OWORD *)(v9 + 3494) = 0u;
      result = (int *)aj_dct_prescale_qtable((uint64_t)&v1[64 * (uint64_t)v7[12] + 22], (uint64_t)&v1[v4]);
      ++v3;
      v2 += 392;
      v4 += 392;
      ++v5;
    }
    while (v3 < *v1);
  }
  return result;
}

uint64_t aj_encode_reset_session(int *a1, uint64_t a2, uint64_t a3)
{
  int *v6;
  _BYTE *v7;
  uint64_t v8;
  int v9;
  int v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int *v21;

  v6 = a1 + 3317;
  v7 = (char *)a1 + 4245;
  *(_OWORD *)(a2 + 1864) = 0u;
  *(_OWORD *)(a2 + 1880) = 0u;
  *(_OWORD *)(a2 + 1832) = 0u;
  *(_OWORD *)(a2 + 1848) = 0u;
  *(_QWORD *)(a1 + 3321) = 0;
  *(_OWORD *)(a1 + 3317) = xmmword_20627BF30;
  *(_QWORD *)(a2 + 1928) = 0;
  *(_DWORD *)(a2 + 1944) = 0;
  *(_DWORD *)(a2 + 1948) = *(_DWORD *)(a2 + 1992);
  *(_DWORD *)(a2 + 2048) = *(_DWORD *)(a3 + 96);
  *(_QWORD *)(a2 + 2060) = 0x700000000;
  aj_get_qtable_for_quality((uint64_t)(a1 + 22), *(_DWORD *)(a3 + 16), 1, 0);
  aj_get_qtable_for_quality((uint64_t)(a1 + 86), *(_DWORD *)(a3 + 16), 0, 0);
  *((_BYTE *)a1 + 3697) = 0;
  *((_BYTE *)a1 + 3971) = 0;
  *v7 = 0;
  v7[274] = 0;
  v8 = *(_QWORD *)(a2 + 1792);
  v9 = v6[1635];
  if (v9 >= 1)
  {
    v10 = 0;
    v11 = (unsigned int *)*((_QWORD *)a1 + 2477);
    do
    {
      *(_OWORD *)(v11 + 17) = xmmword_20627BF50;
      v11[45] = 0;
      v11[49] = 0;
      v12 = *((_QWORD *)v11 + 14);
      v13 = v11[38];
      *((_QWORD *)v11 + 11) = 0;
      *((_QWORD *)v11 + 12) = v12;
      v11[26] = 0;
      v11[27] = v13;
      v14 = *v11;
      if ((int)v14 >= 1)
      {
        v15 = 0;
        v16 = 8 * v14;
        do
        {
          v17 = *(_QWORD *)&v11[v15 / 4 + 60];
          if (v17)
            *(_BYTE *)(v17 + 273) = 0;
          v15 += 8;
        }
        while (v16 != v15);
      }
      ++v10;
      v11 += 76;
    }
    while (v10 != v9);
  }
  init_component(a1);
  *(_DWORD *)(a2 + 1824) = 0;
  *(_DWORD *)(a2 + 1828) = a1[3359];
  if (*a1 >= 1)
  {
    v18 = 0;
    v19 = a1[3340];
    v20 = a2 + 1792;
    v21 = a1 + 3370;
    do
    {
      *(_DWORD *)(v20 + 4 * v18 + 208) = 0;
      if (v19 != 14)
      {
        *((_QWORD *)v21 + 45) = v8;
        *(_QWORD *)(v20 + 8 * v18) = v8;
        v8 += (*v21 * a1[3358]) << 6;
      }
      ++v18;
      v21 += 392;
    }
    while (v18 < *a1);
  }
  aj_reset_row_ptrs((unsigned int *)a1, (_QWORD *)a2, a2 + 1792);
  return 0;
}

uint64_t progscan_write_callback(const void *a1, int a2, uint64_t a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  char *v10;
  char *v11;
  const void *v12;
  uint64_t v13;
  uint64_t result;

  v7 = *(_DWORD *)(a3 + 176);
  v6 = *(_DWORD *)(a3 + 180);
  if (v7 - v6 >= a2)
  {
    v11 = *(char **)(a3 + 168);
LABEL_13:
    memcpy(&v11[v6], a1, a2);
    result = 0;
    *(_DWORD *)(a3 + 180) += a2;
    return result;
  }
  v8 = 2 * v7;
  if (!v7)
    v8 = 0x2000;
  if (v8 <= a2)
    v9 = a2;
  else
    v9 = v8;
  v10 = (char *)(**(uint64_t (***)(_QWORD, _QWORD))(a3 + 160))(v9, *(_QWORD *)(*(_QWORD *)(a3 + 160) + 16));
  if (v10)
  {
    v11 = v10;
    bzero(v10, v9);
    v12 = *(const void **)(a3 + 168);
    if (v12)
    {
      memcpy(v11, v12, *(int *)(a3 + 180));
      v13 = *(_QWORD *)(a3 + 168);
      if (v13)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a3 + 160) + 8))(v13, *(_QWORD *)(*(_QWORD *)(a3 + 160) + 16));
    }
    *(_QWORD *)(a3 + 168) = v11;
    *(_DWORD *)(a3 + 176) = v9;
    v6 = *(_DWORD *)(a3 + 180);
    goto LABEL_13;
  }
  return 6;
}

uint64_t aj_istream_get_error_code_eod(uint64_t a1)
{
  uint64_t result;

  if (*(_QWORD *)(a1 + 16) && *(int *)(a1 + 32) >= 1)
  {
    aj_log_error((uint64_t)"Istream", "Corrupt marker in bitstream, cannot read more data.");
    return 7;
  }
  else
  {
    result = 7;
    if (*(_BYTE *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t read_bytes_with_callback(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  int v5;
  int v9;
  int v10;
  uint64_t result;
  int v12;
  int v13;

  if (*(_DWORD *)(a1 + 56) == 2)
  {
    v5 = 0;
LABEL_11:
    result = 0;
    goto LABEL_21;
  }
  v5 = 0;
  while (1)
  {
    v9 = *(_DWORD *)(a1 + 52);
    if (v9)
    {
      v10 = *(_DWORD *)(a1 + 48);
      if (v10 >= v9)
      {
        *(_DWORD *)(a1 + 56) = 2;
        if ((v10 & 0x80000000) == 0)
          goto LABEL_11;
        goto LABEL_16;
      }
    }
    if (*(_DWORD *)(a1 + 56) == 1)
      *(_DWORD *)(a1 + 56) = 0;
    result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a1 + 80))(a2 + v5, (a3 - v5), *(_QWORD *)(a1 + 64));
    if ((int)result <= 0)
      break;
    v12 = *(_DWORD *)(a1 + 48) + result;
    *(_DWORD *)(a1 + 48) = v12;
    v5 += result;
    if (v5 >= 8)
    {
      if ((v12 & 0x80000000) == 0)
        goto LABEL_11;
LABEL_16:
      aj_log_error((uint64_t)"Istream", "File is larger than %d bytes, aborting");
      goto LABEL_20;
    }
  }
  if ((_DWORD)result == -1)
  {
    result = 0;
    v13 = 2;
    goto LABEL_18;
  }
  if (!(_DWORD)result)
  {
    v13 = 1;
LABEL_18:
    *(_DWORD *)(a1 + 56) = v13;
    goto LABEL_21;
  }
  aj_log_error((uint64_t)"Istream", "File read error");
LABEL_20:
  result = 9;
LABEL_21:
  *a4 = v5;
  return result;
}

uint64_t aj_istream_find_next_val(uint64_t a1, int __c)
{
  uint64_t v2;
  int *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  void *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  if (*(_QWORD *)(a1 + 104) || *(_QWORD *)(a1 + 16))
    return 7;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -9;
  if (*(int *)(a1 + 32) > 1)
    goto LABEL_10;
  v2 = aj_istream_move_forward(a1);
  if ((_DWORD)v2)
    return v2;
  if (*(int *)(a1 + 32) > 1)
  {
LABEL_10:
    v6 = (int *)(a1 + 56);
    while (1)
    {
      v7 = *(unsigned int *)(a1 + 32);
      if ((int)v7 < 1)
        break;
      v8 = *(unsigned __int8 **)(a1 + 8);
      if (*v8 == __c)
        goto LABEL_28;
      v9 = memchr(*(void **)(a1 + 8), __c, *(unsigned int *)(a1 + 32));
      v10 = (uint64_t)&v8[v7 - 1];
      if (v9)
        v10 = (uint64_t)v9;
      *(_QWORD *)(a1 + 8) = v10;
      v11 = v7 + (_DWORD)v8 - v10;
      *(_DWORD *)(a1 + 32) = v11;
      if (v11 <= 7)
      {
        v12 = aj_istream_move_forward(a1);
        if ((_DWORD)v12)
        {
          v13 = 1;
          v2 = v12;
LABEL_25:
          if (v13 == 1)
            return v2;
          LODWORD(v7) = *(_DWORD *)(a1 + 32);
          break;
        }
        if (*(int *)(a1 + 32) <= 1)
        {
          if (!*(_QWORD *)(a1 + 80) || (v13 = *v6) != 0)
            v13 = 3;
          if (v13)
            goto LABEL_25;
        }
      }
    }
    if (!(_DWORD)v7)
      goto LABEL_30;
LABEL_28:
    if (**(unsigned __int8 **)(a1 + 8) == __c)
      return 0;
LABEL_30:
    if (!*(_BYTE *)(a1 + 112))
      return 7;
  }
  else
  {
    if (!*(_BYTE *)(a1 + 112))
      return 7;
    v6 = (int *)(a1 + 56);
  }
  if (*v6 == 1)
    return 4294967294;
  else
    return 7;
}

uint64_t aj_istream_read_bytes_le(uint64_t a1, unsigned int *a2, int a3)
{
  int v3;
  int v6;
  uint64_t result;
  char v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  unint64_t v12;

  v3 = a3;
  v6 = *(_DWORD *)(a1 + 32);
  if (v6 < a3)
  {
    result = aj_istream_move_forward(a1);
    if ((_DWORD)result)
      return result;
    v6 = *(_DWORD *)(a1 + 32);
  }
  if (v6 >= v3)
  {
    v8 = 32 - 8 * v3;
    v9 = 0;
    if (v3)
    {
      v10 = *(_QWORD *)(a1 + 8) + 1;
      v11 = v6 - 1;
      do
      {
        *(_DWORD *)(a1 + 32) = v11;
        *(_QWORD *)(a1 + 8) = v10;
        HIDWORD(v12) = *(unsigned __int8 *)(v10 - 1);
        LODWORD(v12) = v9;
        v9 = v12 >> 8;
        ++v10;
        --v11;
        --v3;
      }
      while (v3);
    }
    result = 0;
    *a2 = v9 >> v8;
  }
  else
  {
    result = 7;
    if (*(_BYTE *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t aj_istream_peek_byte(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  if (*(int *)(a1 + 32) > 0)
    goto LABEL_2;
  result = aj_istream_move_forward(a1);
  if (!(_DWORD)result)
  {
    if (*(int *)(a1 + 32) > 0)
    {
LABEL_2:
      result = 0;
      *a2 = **(_BYTE **)(a1 + 8);
      return result;
    }
    result = 7;
    if (*(_BYTE *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t aj_istream_peek_bytes(uint64_t a1, void *__dst, int a3)
{
  int v6;
  uint64_t result;

  v6 = *(_DWORD *)(a1 + 32);
  if (v6 < a3)
  {
    result = aj_istream_move_forward(a1);
    if ((_DWORD)result)
      return result;
    v6 = *(_DWORD *)(a1 + 32);
  }
  if (v6 >= a3)
  {
    memcpy(__dst, *(const void **)(a1 + 8), a3);
    return 0;
  }
  else
  {
    result = 7;
    if (*(_BYTE *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t aj_istream_memcpy(uint64_t a1, char *__dst, int a3, _DWORD *a4)
{
  int v8;
  int v9;
  size_t v10;
  uint64_t result;

  if (*(int *)(a1 + 32) > 0 || (result = aj_istream_move_forward(a1), !(_DWORD)result))
  {
    v8 = a3;
    while (v8 >= 1)
    {
      v9 = *(_DWORD *)(a1 + 32);
      if (v9 <= 0)
      {
        *a4 = a3 - v8;
        goto LABEL_15;
      }
      if (v9 >= v8)
        v10 = v8;
      else
        v10 = v9;
      memcpy(__dst, *(const void **)(a1 + 8), v10);
      __dst += v10;
      v8 -= v10;
      result = aj_istream_move_to_position(a1, (*(_DWORD *)(a1 + 48) + v10 - *(_DWORD *)(a1 + 32)));
      if ((_DWORD)result)
        return result;
    }
    *a4 = a3 - v8;
    if (!v8)
      return 0;
LABEL_15:
    result = 7;
    if (*(_BYTE *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        return 4294967294;
      else
        return 7;
    }
  }
  return result;
}

uint64_t aj_istream_state_restore(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t result;

  if (*(_QWORD *)(a1 + 16))
    *(_QWORD *)(a1 + 16) = 0;
  v4 = *(unsigned __int8 *)(a2 + 16);
  result = aj_istream_move_to_position(a1, (*(_DWORD *)a2 - *(_DWORD *)(a1 + 96)));
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a1 + 24) = v4 - 9;
    *(_DWORD *)a1 = *(_DWORD *)(a2 + 4);
    return secure_fill_buf(a1, -9);
  }
  return result;
}

uint64_t aj_istream_state_deserialize(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = 0;
  *(_DWORD *)result = *(_DWORD *)a2;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  do
  {
    *(_WORD *)(result + 8 + v2) = *(_WORD *)(a2 + 8 + v2);
    v2 += 2;
  }
  while (v2 != 8);
  *(_BYTE *)(result + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(result + 17) = 1;
  return result;
}

_QWORD *aj_icol_row_420_to_bgra_12bit(_QWORD *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 1, 1);
}

_QWORD *aj_icol_row_420_rgb_12bit_generic(_QWORD *result, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, char a9)
{
  uint64_t v9;
  int v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned __int16 *v25;
  _WORD *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  __int16 v35;
  __int16 v36;
  __int16 v37;
  __int16 v38;
  __int16 v39;
  _QWORD v40[2];
  _QWORD v41[3];

  v41[2] = *MEMORY[0x24BDAC8D0];
  v41[0] = a4;
  v41[1] = a5;
  v40[0] = *result;
  if (a6 == 1)
    v9 = 0;
  else
    v9 = result[1];
  v40[1] = v9;
  if (a7 >= 1)
  {
    v10 = 0;
    v11 = *a3;
    v12 = *a2;
    result = v41;
    v13 = a7;
    do
    {
      if (v13 <= 1)
        v14 = 1;
      else
        v14 = 2;
      v16 = *v12++;
      v15 = v16;
      v18 = *v11++;
      v17 = v18;
      if (a6 >= 1)
      {
        v19 = 0;
        v20 = v15 - 2048;
        v21 = v17 - 2048;
        v22 = 227 * (v15 - 2048);
        v23 = -44 * v20 - 91 * (v17 - 2048);
        v24 = 179 * v21;
        do
        {
          if (v10 < a7)
          {
            v25 = (unsigned __int16 *)v40[v19];
            v26 = (_WORD *)v41[v19];
            v27 = v14;
            do
            {
              v28 = *v25++;
              v29 = v22 + (v28 << 7);
              v30 = v23 + (v28 << 7);
              v31 = v24 + (v28 << 7);
              v32 = (v29 + 64) >> 7;
              v33 = v31 + 64;
              v34 = (v31 + 64) >> 7;
              if (v31 <= -65)
                v35 = 0;
              else
                v35 = 4095;
              if (v33 >= 0x80000)
                LOWORD(v34) = v35;
              if (v30 <= -65)
                v36 = 0;
              else
                v36 = 4095;
              if ((v30 + 64) >= 0x80000)
                v37 = v36;
              else
                v37 = (v30 + 64) >> 7;
              if (v29 <= -65)
                v38 = 0;
              else
                v38 = 4095;
              if ((v29 + 64) >= 0x80000)
                LOWORD(v32) = v38;
              if (a8)
                v39 = v32;
              else
                v39 = v34;
              *v26 = v39;
              if (!a8)
                LOWORD(v34) = v32;
              v26[1] = v37;
              v26[2] = v34;
              if (a9)
              {
                v26[3] = 4095;
                v26 += 4;
              }
              else
              {
                v26 += 3;
              }
              --v27;
            }
            while (v27);
            v40[v19] = v25;
            v41[v19] = v26;
          }
          ++v19;
        }
        while (v19 != a6);
      }
      v10 += 2;
      v13 -= 2;
    }
    while (v10 < a7);
  }
  return result;
}

_QWORD *aj_icol_row_420_to_rgba_12bit(_QWORD *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 0, 1);
}

unsigned __int16 **aj_icol_row_444_to_bgra_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 1, 1);
}

unsigned __int16 **aj_icol_row_444_rgb_12bit_generic(unsigned __int16 **result, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, int a5, int a6, int a7)
{
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  __int16 v24;
  __int16 v25;
  unsigned int v26;
  __int16 v27;

  if (a5 >= 1)
  {
    v7 = *a3;
    v8 = *a2;
    v9 = *result;
    do
    {
      v11 = *v9++;
      v10 = v11;
      v12 = *v8++;
      v13 = v12 - 2048;
      v14 = *v7++;
      v15 = 227 * v13 + (v10 << 7);
      v16 = -44 * v13 + (v10 << 7) - 91 * (v14 - 2048);
      v17 = 179 * (v14 - 2048) + (v10 << 7);
      v18 = v15 + 64;
      v19 = (v15 + 64) >> 7;
      v20 = v16 + 64;
      v21 = (v16 + 64) >> 7;
      v22 = v17 + 64;
      v23 = (v17 + 64) >> 7;
      if (v17 <= -65)
        v24 = 0;
      else
        v24 = 4095;
      if (v22 < 0x80000)
        v24 = v23;
      if (v16 <= -65)
        v25 = 0;
      else
        v25 = 4095;
      if (v20 < 0x80000)
        v25 = v21;
      if (v15 <= -65)
        v26 = 0;
      else
        v26 = 4095;
      if (v18 >= 0x80000)
        result = (unsigned __int16 **)v26;
      else
        result = (unsigned __int16 **)v19;
      if (a6)
        v27 = (__int16)result;
      else
        v27 = v24;
      *a4 = v27;
      if (!a6)
        v24 = (__int16)result;
      a4[1] = v25;
      a4[2] = v24;
      if (a7)
      {
        a4[3] = 4095;
        a4 += 4;
      }
      else
      {
        a4 += 3;
      }
      --a5;
    }
    while (a5);
  }
  return result;
}

unsigned __int16 **aj_icol_row_444_to_rgba_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 0, 1);
}

_QWORD *aj_icol_row_420_to_bgr_12bit(_QWORD *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 1, 0);
}

_QWORD *aj_icol_row_420_to_rgb_12bit(_QWORD *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 0, 0);
}

unsigned __int16 **aj_icol_row_444_to_bgr_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 1, 0);
}

unsigned __int16 **aj_icol_row_444_to_rgb_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 0, 0);
}

unint64_t aj_icol_row_444_to_yuyv(unint64_t result, char **a2, char **a3, _BYTE *a4, uint64_t a5, uint64_t a6, int a7)
{
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  _BYTE *v16;
  char v17;
  char v18;
  char v19;

  v7 = *(char **)result;
  v8 = *a2;
  v9 = *a3;
  if (a7 < 2)
  {
    if ((a7 & 1) == 0)
      return result;
LABEL_7:
    v17 = *v7;
    v18 = *v8;
    v19 = *v9;
    *a4 = v17;
    a4[1] = v18;
    a4[2] = v17;
    a4[3] = v19;
    return result;
  }
  v10 = 0;
  do
  {
    v11 = v7[v10 + 1];
    v12 = v8[v10];
    v13 = v8[v10 + 1];
    result = v9[v10];
    v14 = v9[v10 + 1];
    *a4 = v7[v10];
    a4[1] = (v13 + v12) >> 1;
    a4[2] = v11;
    v15 = (v14 + result) >> 1;
    v16 = a4 + 4;
    a4[3] = v15;
    v10 += 2;
    a4 += 4;
  }
  while ((int)v10 < a7 - 1);
  v9 += v10;
  v8 += v10;
  v7 += v10;
  a4 = v16;
  if ((a7 & 1) != 0)
    goto LABEL_7;
  return result;
}

char **aj_icol_row_420_to_yuyv(char **result, char **a2, char **a3, _BYTE *a4, _BYTE *a5, int a6, int a7)
{
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char v11;
  char v12;
  char v13;
  char v14;
  _BYTE *v15;
  char v16;
  char v17;
  char v18;
  char *v19;
  uint64_t v20;
  char v21;
  char v22;
  char v23;
  unsigned int v24;
  _BYTE *v25;
  _BYTE *v26;
  char v27;
  char v28;
  char v29;
  char v30;

  v7 = *result;
  v8 = *a2;
  v9 = *a3;
  if (a6 == 1)
  {
    if (a7 >= 2)
    {
      v10 = 0;
      do
      {
        v11 = v7[v10 + 1];
        v13 = *v8++;
        v12 = v13;
        v14 = *v9++;
        *a4 = v7[v10];
        a4[1] = v12;
        a4[2] = v11;
        v15 = a4 + 4;
        a4[3] = v14;
        v10 += 2;
        a4 += 4;
      }
      while ((int)v10 < a7 - 1);
      v7 += v10;
      a4 = v15;
    }
    if ((a7 & 1) != 0)
    {
      v16 = *v7;
      v17 = *v8;
      v18 = *v9;
      *a4 = v16;
      a4[1] = v17;
      a4[2] = v16;
      a4[3] = v18;
    }
  }
  else
  {
    v19 = result[1];
    if (a7 >= 2)
    {
      v20 = 0;
      do
      {
        v21 = v7[v20 + 1];
        v22 = v19[v20];
        v23 = v19[v20 + 1];
        v24 = *v8++;
        result = (char **)v24;
        LOBYTE(v24) = *v9++;
        *a4 = v7[v20];
        a4[1] = (_BYTE)result;
        a4[2] = v21;
        v25 = a4 + 4;
        a4[3] = v24;
        *a5 = v22;
        a5[1] = (_BYTE)result;
        v26 = a5 + 4;
        v20 += 2;
        a5[2] = v23;
        a5[3] = v24;
        a5 += 4;
        a4 += 4;
      }
      while ((int)v20 < a7 - 1);
      v19 += v20;
      v7 += v20;
      a4 = v25;
      a5 = v26;
    }
    if ((a7 & 1) != 0)
    {
      v27 = *v7;
      v28 = *v19;
      v29 = *v8;
      v30 = *v9;
      *a4 = v27;
      a4[1] = v29;
      a4[2] = v27;
      a4[3] = v30;
      *a5 = v28;
      a5[1] = v29;
      a5[2] = v28;
      a5[3] = v30;
    }
  }
  return result;
}

char **aj_icol_row_444_to_yuv(char **result, char **a2, char **a3, _BYTE *a4, uint64_t a5, uint64_t a6, int a7)
{
  char *v7;
  char *v8;
  char *v9;
  char v10;
  char v11;
  char v12;

  if (a7)
  {
    v7 = *a3;
    v8 = *a2;
    v9 = *result;
    do
    {
      v10 = *v9++;
      *a4 = v10;
      v11 = *v8++;
      a4[1] = v11;
      v12 = *v7++;
      a4[2] = v12;
      a4 += 3;
      --a7;
    }
    while (a7);
  }
  return result;
}

uint64_t aj_icol_row_420_to_yuv(uint64_t result, char **a2, char **a3, _BYTE *a4, _BYTE *a5, int a6, int a7)
{
  _BYTE *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char v11;
  char v12;
  char v13;
  _BYTE *v14;
  _BYTE *v15;
  uint64_t v16;
  char v17;
  char v18;
  char v19;
  _BYTE *v20;
  _BYTE *v21;
  char v22;
  char v23;

  v7 = *(_BYTE **)result;
  v8 = *a2;
  v9 = *a3;
  if (a6 == 1)
  {
    if (a7 >= 2)
    {
      v10 = 0;
      do
      {
        v12 = *v8++;
        v11 = v12;
        v13 = *v9++;
        *a4 = v7[v10];
        a4[1] = v11;
        a4[2] = v13;
        a4[3] = v7[v10 + 1];
        a4[4] = v11;
        v14 = a4 + 6;
        a4[5] = v13;
        v10 += 2;
        a4 += 6;
      }
      while ((int)v10 < a7 - 1);
      v7 += v10;
      a4 = v14;
    }
    if ((a7 & 1) != 0)
    {
      *a4 = *v7;
      a4[1] = *v8;
      a4[2] = *v9;
    }
  }
  else
  {
    v15 = *(_BYTE **)(result + 8);
    if (a7 >= 2)
    {
      v16 = 0;
      do
      {
        v18 = *v8++;
        v17 = v18;
        v19 = *v9++;
        *a4 = v7[v16];
        a4[1] = v17;
        a4[2] = v19;
        a4[3] = v7[v16 + 1];
        a4[4] = v17;
        v20 = a4 + 6;
        a4[5] = v19;
        result = v15[v16];
        *a5 = result;
        a5[1] = v17;
        a5[2] = v19;
        a5[3] = v15[v16 + 1];
        a5[4] = v17;
        v21 = a5 + 6;
        a5[5] = v19;
        v16 += 2;
        a4 += 6;
        a5 += 6;
      }
      while ((int)v16 < a7 - 1);
      v7 += v16;
      v15 += v16;
      a5 = v21;
      a4 = v20;
    }
    if ((a7 & 1) != 0)
    {
      v22 = *v8;
      v23 = *v9;
      *a4 = *v7;
      a4[1] = v22;
      a4[2] = v23;
      *a5 = *v15;
      a5[1] = v22;
      a5[2] = v23;
    }
  }
  return result;
}

void *aj_icol_row_444_to_biplanar(void *__src, int a2, char *a3, int a4, char *a5, int a6, void *__dst, int a8, _BYTE *a9, int a10)
{
  int v12;
  void *result;
  char v15;
  char v16;

  v12 = a10;
  result = memcpy(__dst, __src, a10);
  if (a10 >= 1)
  {
    do
    {
      v15 = *a3++;
      *a9 = v15;
      v16 = *a5++;
      a9[1] = v16;
      a9 += 2;
      --v12;
    }
    while (v12);
  }
  return result;
}

void *aj_icol_row_422_to_biplanar(void *__src, int a2, char *a3, int a4, char *a5, int a6, char *__dst, int a8, _BYTE *a9, int a10, int a11, unsigned __int8 a12)
{
  int v15;
  _BYTE *v16;
  void *result;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  _BYTE *v23;
  unsigned int v24;
  char v25;
  char v26;
  int v27;

  v15 = a12;
  v16 = a9;
  result = memcpy(__dst, __src, a10);
  if ((a10 & 1) != 0)
    __dst[a10] = __dst[a10 - 1];
  if (a11 != 1 || a12 != 0)
  {
    v19 = a10 - 1 + a12;
    if (v19 <= a12)
    {
      v23 = a9;
      if ((a10 & 1) == 0)
        return result;
    }
    else
    {
      do
      {
        v20 = (unint64_t)v15 >> a11;
        v21 = (unint64_t)(v15 + 1) >> a11;
        *v16 = (a3[v21] + a3[v20]) >> 1;
        v22 = (a5[v21] + a5[v20]) >> 1;
        v23 = v16 + 2;
        v16[1] = v22;
        v15 += 2;
        v16 += 2;
      }
      while (v15 < v19);
      if ((a10 & 1) == 0)
        return result;
    }
    v27 = (a10 - 1) >> a11;
    *v23 = a3[v27];
    v23[1] = a5[v27];
    return result;
  }
  if (a10 >= 1)
  {
    v24 = (a10 + 1) >> 1;
    do
    {
      v25 = *a3++;
      *v16 = v25;
      v26 = *a5++;
      v16[1] = v26;
      v16 += 2;
      --v24;
    }
    while (v24);
  }
  return result;
}

void *aj_icol_row_420_to_biplanar(void *__src, const void *a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned __int8 *a5, unsigned __int8 *a6, void *__dst, void *a8, _BYTE *a9, int a10, int a11, unsigned __int8 a12)
{
  int v17;
  _BYTE *v18;
  void *result;
  BOOL v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  _BYTE *v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  char v39;
  char v40;
  int v41;
  signed int v42;

  v17 = a12;
  v18 = a9;
  memcpy(__dst, __src, a10);
  result = memcpy(a8, a2, a10);
  if ((a10 & 1) != 0)
  {
    *((_BYTE *)__dst + a10) = *((_BYTE *)__dst + a10 - 1);
    *((_BYTE *)a8 + a10) = *((_BYTE *)a8 + a10 - 1);
  }
  v21 = a11 != 1 || a12 != 0;
  if (a3 == a4 && a5 == a6)
  {
    if (v21)
    {
      v22 = a10 - 1 + a12;
      if (v22 <= a12)
      {
        v26 = a9;
        if ((a10 & 1) == 0)
          return result;
      }
      else
      {
        do
        {
          v23 = (unint64_t)v17 >> a11;
          v24 = (unint64_t)(v17 + 1) >> a11;
          *v18 = (a3[v23] + a3[v24] + 1) >> 1;
          v25 = (a5[v23] + a5[v24] + 1) >> 1;
          v26 = v18 + 2;
          v18[1] = v25;
          v17 += 2;
          v18 += 2;
        }
        while (v17 < v22);
        if ((a10 & 1) == 0)
          return result;
      }
      v42 = (a10 - 1) >> a11;
      *v26 = a3[v42];
      LOBYTE(v42) = a5[v42];
LABEL_33:
      v26[1] = v42;
      return result;
    }
    if (a10 >= 1)
    {
      v38 = (a10 + 1) >> 1;
      do
      {
        v39 = *a3++;
        *v18 = v39;
        v40 = *a5++;
        v18[1] = v40;
        v18 += 2;
        --v38;
      }
      while (v38);
    }
  }
  else
  {
    if (v21)
    {
      v27 = a10 - 1 + a12;
      if (v27 <= a12)
      {
        v26 = a9;
        if ((a10 & 1) == 0)
          return result;
      }
      else
      {
        do
        {
          v28 = (unint64_t)v17 >> a11;
          v29 = (unint64_t)(v17 + 1) >> a11;
          *v18 = (a3[v28] + a4[v28] + a3[v29] + a4[v29] + 2) >> 2;
          v30 = (a5[v28] + a6[v28] + a5[v29] + a6[v29] + 2) >> 2;
          v26 = v18 + 2;
          v18[1] = v30;
          v17 += 2;
          v18 += 2;
        }
        while (v17 < v27);
        if ((a10 & 1) == 0)
          return result;
      }
      v41 = (a10 - 1) >> a11;
      *v26 = (a4[v41] + a3[v41]) >> 1;
      v42 = (a6[v41] + a5[v41]) >> 1;
      goto LABEL_33;
    }
    if (a10 >= 1)
    {
      v31 = (a10 + 1) >> 1;
      do
      {
        v33 = *a3++;
        v32 = v33;
        v34 = *a4++;
        *v18 = (v34 + v32) >> 1;
        v36 = *a5++;
        v35 = v36;
        v37 = *a6++;
        v18[1] = (v37 + v35) >> 1;
        v18 += 2;
        --v31;
      }
      while (v31);
    }
  }
  return result;
}

void *aj_icol_row_420_to_biplanar_12bit(void *__src, const void *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6, char *__dst, char *a8, _WORD *a9, int a10, int a11, unsigned __int8 a12)
{
  unsigned int v17;
  void *result;
  uint64_t v20;
  BOOL v22;
  int v23;
  unsigned int v24;
  _WORD *v25;
  signed int v26;
  int v27;
  unsigned int v28;
  _WORD *v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  __int16 v39;
  __int16 v40;

  v17 = a12;
  memcpy(__dst, __src, 2 * a10);
  result = memcpy(a8, a2, 2 * a10);
  if ((a10 & 1) != 0)
  {
    v20 = 2 * a10 - 2;
    *(_WORD *)&__dst[2 * a10] = *(_WORD *)&__dst[v20];
    *(_WORD *)&a8[2 * a10] = *(_WORD *)&a8[v20];
  }
  v22 = a11 != 1 || a12 != 0;
  if (a3 == a4 && a5 == a6)
  {
    if (v22)
    {
      v23 = a10 - 1 + a12;
      if (v23 > a12)
      {
        do
        {
          v24 = (v17 + 1) >> a11;
          *a9 = (a3[v17 >> a11] + a3[v24] + 1) >> 1;
          v25 = a9 + 2;
          a9[1] = (a5[v17 >> a11] + a5[v24] + 1) >> 1;
          v17 += 2;
          a9 += 2;
        }
        while ((int)v17 < v23);
        a9 = v25;
      }
      if ((a10 & 1) != 0)
      {
        v26 = (a10 - 1) >> a11;
        *a9 = a3[v26];
        LOWORD(v26) = a5[v26];
LABEL_23:
        a9[1] = v26;
      }
    }
    else if (a10 >= 1)
    {
      v38 = (a10 + 1) >> 1;
      do
      {
        v39 = *a3++;
        *a9 = v39;
        v40 = *a5++;
        a9[1] = v40;
        a9 += 2;
        --v38;
      }
      while (v38);
    }
  }
  else if (v22)
  {
    v27 = a10 - 1 + a12;
    if (v27 > a12)
    {
      do
      {
        v28 = (v17 + 1) >> a11;
        *a9 = (a3[v17 >> a11] + a4[v17 >> a11] + a3[v28] + a4[v28] + 2) >> 2;
        v29 = a9 + 2;
        a9[1] = (a5[v17 >> a11] + a6[v17 >> a11] + a5[v28] + a6[v28] + 2) >> 2;
        v17 += 2;
        a9 += 2;
      }
      while ((int)v17 < v27);
      a9 = v29;
    }
    if ((a10 & 1) != 0)
    {
      v30 = (a10 - 1) >> a11;
      *a9 = (a4[v30] + a3[v30]) >> 1;
      v26 = (a6[v30] + a5[v30]) >> 1;
      goto LABEL_23;
    }
  }
  else if (a10 >= 1)
  {
    v31 = (a10 + 1) >> 1;
    do
    {
      v33 = *a3++;
      v32 = v33;
      v34 = *a4++;
      *a9 = (v34 + v32) >> 1;
      v36 = *a5++;
      v35 = v36;
      v37 = *a6++;
      a9[1] = (v37 + v35) >> 1;
      a9 += 2;
      --v31;
    }
    while (v31);
  }
  return result;
}

void *aj_icol_row_440_to_biplanar(void *__src, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *__dst, void *a8, _BYTE *a9, int a10, char a11)
{
  void *result;
  unsigned int i;
  unint64_t v20;

  memcpy(__dst, __src, a10);
  result = memcpy(a8, a2, a10);
  if (a10 >= 1)
  {
    for (i = 0; i != a10; ++i)
    {
      v20 = (unint64_t)i >> a11;
      *a9 = (*(unsigned __int8 *)(a4 + v20) + *(unsigned __int8 *)(a3 + v20)) >> 1;
      a9[1] = (*(unsigned __int8 *)(a6 + v20) + *(unsigned __int8 *)(a5 + v20)) >> 1;
      a9 += 2;
    }
  }
  return result;
}

const void **aj_icol_row_all_to_gray(const void **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  const void **v7;
  size_t v8;
  void **v9;
  uint64_t v10;
  void *v11;
  void *v12;
  const void *v13;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x24BDAC8D0];
  v14[0] = a4;
  v14[1] = a5;
  if (a6 >= 1)
  {
    v7 = result;
    v8 = a7;
    v9 = (void **)v14;
    v10 = a6;
    do
    {
      v12 = *v9++;
      v11 = v12;
      v13 = *v7++;
      result = (const void **)memcpy(v11, v13, v8);
      --v10;
    }
    while (v10);
  }
  return result;
}

const void **aj_icol_row_all_to_gray_12bit(const void **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  const void **v7;
  size_t v8;
  void **v9;
  uint64_t v10;
  void *v11;
  void *v12;
  const void *v13;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x24BDAC8D0];
  v14[0] = a4;
  v14[1] = a5;
  if (a6 >= 1)
  {
    v7 = result;
    v8 = 2 * a7;
    v9 = (void **)v14;
    v10 = a6;
    do
    {
      v12 = *v9++;
      v11 = v12;
      v13 = *v7++;
      result = (const void **)memcpy(v11, v13, v8);
      --v10;
    }
    while (v10);
  }
  return result;
}

void *aj_icol_row_gray_to_444biplanar(void *__src, int a2, int a3, int a4, int a5, int a6, void *__dst, int a8, void *a9, size_t __n)
{
  memcpy(__dst, __src, (int)__n);
  return memset(a9, 128, 2 * (int)__n);
}

void *aj_icol_row_gray_to_422biplanar(void *__src, int a2, int a3, int a4, int a5, int a6, char *__dst, int a8, void *a9, int a10)
{
  memcpy(__dst, __src, a10);
  if ((a10 & 1) != 0)
    __dst[a10] = __dst[a10 - 1];
  return memset(a9, 128, (a10 & 1) + a10);
}

void *aj_icol_row_gray_to_420biplanar(void *__src, const void *a2, int a3, int a4, int a5, int a6, char *__dst, char *a8, void *a9, int a10)
{
  memcpy(__dst, __src, a10);
  memcpy(a8, a2, a10);
  if ((a10 & 1) != 0)
  {
    __dst[a10] = __dst[a10 - 1];
    a8[a10] = a8[a10 - 1];
  }
  return memset(a9, 128, (a10 & 1) + a10);
}

void aj_icol_row_gray_to_420biplanar_12bit(void *__src, const void *a2, int a3, int a4, int a5, int a6, void *__dst, void *a8, void *a9, int a10)
{
  int v13;
  BOOL v14;
  int v15;

  memcpy(__dst, __src, 2 * a10);
  memcpy(a8, a2, 2 * a10);
  if ((a10 & 1) != 0)
  {
    *((_WORD *)__dst + a10) = *((_WORD *)__dst + a10 - 1);
    *((_WORD *)a8 + a10) = *((_WORD *)a8 + a10 - 1);
  }
  v13 = (a10 & 1) + a10;
  v14 = __OFSUB__(v13, 1);
  v15 = v13 - 1;
  if (v15 < 0 == v14)
    memset_pattern16(a9, &unk_20627C3F0, 2 * v15 + 2);
}

void *aj_icol_row_gray_to_440biplanar(void *__src, const void *a2, int a3, int a4, int a5, int a6, void *__dst, void *a8, void *a9, size_t __n)
{
  memcpy(__dst, __src, (int)__n);
  memcpy(a8, a2, (int)__n);
  return memset(a9, 128, 2 * (int)__n);
}

uint64_t aj_icol_row_gray_to_yuyv(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t i;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  _BYTE *v11;
  _QWORD v12[3];

  v12[2] = *MEMORY[0x24BDAC8D0];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (i = 0; i != a6; ++i)
    {
      v8 = *(_BYTE **)(result + 8 * i);
      v9 = (_BYTE *)v12[i];
      if (a7 >= 2)
      {
        v10 = 0;
        do
        {
          *v9 = v8[v10];
          v9[1] = 0x80;
          v9[2] = v8[v10 + 1];
          v11 = v9 + 4;
          v9[3] = 0x80;
          v10 += 2;
          v9 += 4;
        }
        while ((int)v10 < a7 - 1);
        v8 += v10;
        v9 = v11;
      }
      if ((a7 & 1) != 0)
      {
        *v9 = *v8;
        v9[1] = 0x80;
        v9[2] = *v8;
        v9[3] = 0x80;
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_yuv(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t i;
  uint64_t v8;
  char *v9;
  int v10;
  char v11;
  _QWORD v12[3];

  v12[2] = *MEMORY[0x24BDAC8D0];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        v8 = v12[i];
        v9 = *(char **)(result + 8 * i);
        v10 = a7;
        do
        {
          v11 = *v9++;
          *(_BYTE *)v8 = v11;
          *(_WORD *)(v8 + 1) = -32640;
          v8 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgb565(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_gray_to_color_generic(a1, a4, a5, a6, a7, 2, 1);
}

uint64_t aj_icol_row_gray_to_color_generic(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  uint64_t i;
  __int16 *v8;
  int16x4_t *v9;
  int v10;
  __int8 v11;
  int v12;
  int16x4_t v13;
  int16x4_t v14;
  int v15;
  unsigned int v16;
  int v17;
  __int8 v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x24BDAC8D0];
  v19[0] = a2;
  v19[1] = a3;
  if (a4 >= 1)
  {
    for (i = 0; i != a4; ++i)
    {
      v8 = *(__int16 **)(result + 8 * i);
      v9 = (int16x4_t *)v19[i];
      switch(a6)
      {
        case 2:
          if (a5 >= 1)
          {
            v15 = a5;
            do
            {
              v16 = *(unsigned __int8 *)v8;
              v8 = (__int16 *)((char *)v8 + 1);
              v9->i8[0] = (v16 >> 3) & 0x1F | (32 * ((v16 >> 2) & 7));
              v9->i8[1] = (unsigned __int16)((8 * v16) | ((unsigned __int16)(v16 >> 3) << 11)) >> 8;
              v9 = (int16x4_t *)((char *)v9 + 2);
              --v15;
            }
            while (v15);
          }
          break;
        case 4:
          if (a7 == 2)
          {
            if (a5 >= 1)
            {
              v12 = a5;
              do
              {
                v13.i16[1] = -4096;
                v13.i32[1] = -268374016;
                v13.i16[0] = *v8++;
                v14 = vzip1_s16(v13, v13);
                v14.i16[2] = v13.i16[0];
                *v9++ = v14;
                --v12;
              }
              while (v12);
            }
          }
          else
          {
            v17 = a5;
            if (a5 >= 1)
            {
              do
              {
                v18 = *(_BYTE *)v8;
                v8 = (__int16 *)((char *)v8 + 1);
                v9->i8[0] = v18;
                v9->i8[1] = v18;
                v9->i8[2] = v18;
                v9->i8[3] = -1;
                v9 = (int16x4_t *)((char *)v9 + 4);
                --v17;
              }
              while (v17);
            }
          }
          break;
        case 3:
          v10 = a5;
          if (a5 >= 1)
          {
            do
            {
              v11 = *(_BYTE *)v8;
              v8 = (__int16 *)((char *)v8 + 1);
              v9->i8[0] = v11;
              v9->i8[1] = v11;
              v9->i8[2] = v11;
              v9 = (int16x4_t *)((char *)v9 + 3);
              --v10;
            }
            while (v10);
          }
          break;
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgb(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t i;
  _BYTE *v8;
  char *v9;
  int v10;
  char v11;
  _QWORD v12[3];

  v12[2] = *MEMORY[0x24BDAC8D0];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        v8 = (_BYTE *)v12[i];
        v9 = *(char **)(result + 8 * i);
        v10 = a7;
        do
        {
          v11 = *v9++;
          *v8 = v11;
          v8[1] = v11;
          v8[2] = v11;
          v8 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgb_12bit(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t i;
  _BYTE *v8;
  char *v9;
  int v10;
  char v11;
  _QWORD v12[3];

  v12[2] = *MEMORY[0x24BDAC8D0];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        v8 = (_BYTE *)v12[i];
        v9 = *(char **)(result + 8 * i);
        v10 = a7;
        do
        {
          v11 = *v9++;
          *v8 = v11;
          v8[1] = v11;
          v8[2] = v11;
          v8 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgba(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t i;
  _BYTE *v8;
  char *v9;
  int v10;
  char v11;
  _QWORD v12[3];

  v12[2] = *MEMORY[0x24BDAC8D0];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        v8 = (_BYTE *)v12[i];
        v9 = *(char **)(result + 8 * i);
        v10 = a7;
        do
        {
          v11 = *v9++;
          *v8 = v11;
          v8[1] = v11;
          v8[2] = v11;
          v8[3] = -1;
          v8 += 4;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgba_12bit(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t i;
  int16x4_t *v8;
  __int16 *v9;
  int v10;
  int16x4_t v11;
  int16x4_t v12;
  _QWORD v13[3];

  v13[2] = *MEMORY[0x24BDAC8D0];
  v13[0] = a4;
  v13[1] = a5;
  if (a6 >= 1)
  {
    for (i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        v8 = (int16x4_t *)v13[i];
        v9 = *(__int16 **)(result + 8 * i);
        v10 = a7;
        do
        {
          v11.i16[1] = -4096;
          v11.i32[1] = -268374016;
          v11.i16[0] = *v9++;
          v12 = vzip1_s16(v11, v11);
          v12.i16[2] = v11.i16[0];
          *v8++ = v12;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t invcol_wrapper(uint64_t a1, _QWORD *a2, unsigned __int8 **a3, unsigned __int8 **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t *v15;
  _BYTE **v16;
  _BYTE *v17;
  unsigned __int8 v18;
  uint64_t result;
  _BOOL4 v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t *v29;
  _QWORD *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  _BYTE *v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  __int16 v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;

  v12 = a2;
  v57 = *MEMORY[0x24BDAC8D0];
  if (!a9)
    return (*(uint64_t (**)(_QWORD *, unsigned __int8 **, unsigned __int8 **, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 6912))(a2, a3, a4, a5, a6, a7, a8);
  v55 = a5;
  v56 = a6;
  v13 = *(_DWORD *)(a1 + 6580);
  if (v13 == 2)
  {
    v20 = 0;
    goto LABEL_11;
  }
  if (v13 != 6)
  {
    v20 = v13 != 4;
LABEL_11:
    v21 = **a3;
    v22 = **a4;
    ++*a3;
    ++*a4;
    if ((int)a7 >= 1)
    {
      v23 = v22 - 128;
      v24 = v21 - 128;
      v25 = 227 * (v21 - 128);
      v26 = -44 * v24 - 91 * v23;
      v27 = 179 * v23;
      v28 = a7;
      v29 = &v55;
      v30 = a2;
      do
      {
        v31 = *(unsigned __int8 *)*v30;
        v32 = v25 + (v31 << 7);
        v33 = v26 + (v31 << 7);
        v34 = v27 + (v31 << 7);
        v35 = *(_DWORD *)(a1 + 28);
        v36 = (_BYTE *)*v29;
        v37 = v32 + 64;
        v38 = (v32 + 64) >> 7;
        v39 = v33 + 64;
        v40 = (v33 + 64) >> 7;
        v41 = v34 + 64;
        v42 = (v34 + 64) >> 7;
        if (v34 <= -65)
          v43 = 0;
        else
          v43 = 255;
        if (v41 < 0x8000)
          v43 = v42;
        if (v33 <= -65)
          v44 = 0;
        else
          v44 = 255;
        if (v39 < 0x8000)
          v44 = v40;
        if (v32 <= -65)
          v45 = 0;
        else
          v45 = 255;
        if (v37 < 0x8000)
          v45 = v38;
        switch(v35)
        {
          case 4:
            if (v20)
              v53 = v45;
            else
              v53 = v43;
            if (v20)
              LOBYTE(v45) = v43;
            *v36 = v45;
            v36[1] = v44;
            v36[2] = v53;
            v36[3] = -1;
            v36 += 4;
            break;
          case 3:
            *v36 = v43;
            v36[1] = v44;
            v36[2] = v45;
            v36 += 3;
            break;
          case 2:
            if (v43 >= 0xFC)
              v46 = 255;
            else
              v46 = v43 + 4;
            v47 = v44 + 2;
            if (v44 >= 0xFE)
              v47 = 255;
            v48 = v46 >> 3;
            if (v45 >= 0xFC)
              v49 = 255;
            else
              v49 = v45 + 4;
            v50 = v49 >> 3;
            v51 = 32 * (v47 >> 2);
            if (v20)
              v52 = v51 | ((_WORD)v50 << 11) | v48;
            else
              v52 = v51 | ((_WORD)v48 << 11) | v50;
            *(_WORD *)v36 = v52;
            v36 += 2;
            break;
        }
        *v29++ = (uint64_t)v36;
        ++*v30++;
        --v28;
      }
      while (v28);
    }
    goto LABEL_52;
  }
  if ((int)a7 >= 1)
  {
    v14 = a7;
    v15 = &v55;
    v16 = (_BYTE **)a2;
    do
    {
      v17 = (_BYTE *)*v15;
      *v17 = **v16;
      v17[1] = **a3;
      v18 = **a4;
      *v15++ = (uint64_t)(v17 + 3);
      v17[2] = v18;
      ++*v16++;
      --v14;
    }
    while (v14);
  }
  ++*a3;
  ++*a4;
LABEL_52:
  result = (*(uint64_t (**)(_QWORD *, unsigned __int8 **, unsigned __int8 **, uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 6912))(v12, a3, a4, v55, v56, a7, (a8 - 1));
  --*a3;
  --*a4;
  if ((int)a7 >= 1)
  {
    v54 = a7;
    do
    {
      --*v12++;
      --v54;
    }
    while (v54);
  }
  return result;
}

void aj_icol_mcurow_cmyk(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6;
  int64x2_t v7;
  int v8;
  char *buffer;
  char *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  int v13;
  char *v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  char v30;
  char v31;
  char v32;
  char v33;
  char v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  int v39;
  char *v40;
  char v41;
  char v42;
  char v43;
  char v44;
  unsigned int v45;
  int v46;
  int64x2_t v47;
  int64x2_t v48;
  uint64_t v49;
  _BYTE *v50;
  unsigned int *v51;

  if (a4 > 0)
  {
    v6 = 0;
    v7 = vdupq_n_s64(a3);
    v50 = (_BYTE *)(a2 + 6936);
    v51 = (unsigned int *)(a3 + 152);
    v48 = vaddq_s64(v7, (int64x2_t)xmmword_20627C3D0);
    v47 = vaddq_s64(v7, (int64x2_t)xmmword_20627C3E0);
    v49 = a4;
    v8 = *(_DWORD *)(a1 + 48);
    do
    {
      if (*(_DWORD *)(a2 + 6804))
        buffer = aj_rowbuffer_get_buffer(v51, *(_QWORD *)(a2 + 6776));
      else
        buffer = (char *)(*(_QWORD *)(a2 + 64) + *(_QWORD *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
      if (*v50)
      {
        if (v8)
        {
          v10 = *(char **)(v48.i64[1] + 8 * v6);
          v11 = *(unsigned __int8 **)(v48.i64[0] + 8 * v6);
          v12 = *(unsigned __int8 **)(v47.i64[1] + 8 * v6);
          v13 = v8;
          v14 = buffer;
          v15 = *(unsigned __int8 **)(v47.i64[0] + 8 * v6);
          do
          {
            v17 = *v15++;
            v16 = v17;
            v18 = *v12++;
            v19 = v18 - 128;
            v20 = *v11++;
            v21 = 179 * (v20 - 128) + (v16 << 7);
            v22 = -44 * v19 + (v16 << 7) - 91 * (v20 - 128);
            v23 = 227 * v19 + (v16 << 7);
            v24 = v21 + 64;
            v25 = (v21 + 64) >> 7;
            v26 = v22 + 64;
            v27 = (v22 + 64) >> 7;
            v28 = v23 + 64;
            v29 = (v23 + 64) >> 7;
            if (v21 <= -65)
              v30 = 0;
            else
              v30 = -1;
            if (v24 >= 0x8000)
              v31 = v30;
            else
              v31 = v25;
            if (v22 <= -65)
              v32 = 0;
            else
              v32 = -1;
            if (v26 < 0x8000)
              v32 = v27;
            if (v23 <= -65)
              v33 = 0;
            else
              v33 = -1;
            if (v28 < 0x8000)
              v33 = v29;
            *v14 = ~v31;
            v14[1] = ~v32;
            v14[2] = ~v33;
            v34 = *v10++;
            v14[3] = v34;
            v14 += 4;
            --v13;
          }
          while (v13);
        }
      }
      else if (v8)
      {
        v35 = *(char **)(v48.i64[1] + 8 * v6);
        v36 = *(char **)(v48.i64[0] + 8 * v6);
        v37 = *(char **)(v47.i64[1] + 8 * v6);
        v38 = buffer;
        v39 = v8;
        v40 = *(char **)(v47.i64[0] + 8 * v6);
        do
        {
          v41 = *v40++;
          *v38 = v41;
          v42 = *v37++;
          v38[1] = v42;
          v43 = *v36++;
          v38[2] = v43;
          v44 = *v35++;
          v38[3] = v44;
          v38 += 4;
          --v39;
        }
        while (v39);
      }
      v45 = *(_DWORD *)(a2 + 6804);
      v46 = *(_DWORD *)(a3 + 36);
      if (v45)
      {
        aj_row_translate(v45, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), v46, buffer, *(_QWORD *)(a2 + 64));
        aj_rowbuffer_return_buffer(v51, (unint64_t)buffer);
        v46 = *(_DWORD *)(a3 + 36);
      }
      *(_DWORD *)(a3 + 36) = v46 + 1;
      ++v6;
    }
    while (v6 != v49);
  }
}

void aj_icol_mcurow_semiplanar444(_DWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v7;
  int v8;
  unsigned int v9;
  char *buffer;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  unsigned int *v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;

  v8 = a1[10];
  v7 = a1[11];
  v29 = a1[12];
  v9 = *(unsigned __int8 *)(a3 + 1080);
  if (*(_DWORD *)(a2 + 6804))
  {
    buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a2 + 6776));
    v11 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a2 + 6792));
  }
  else
  {
    buffer = 0;
    v11 = 0;
  }
  if (a4 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v27 = v7 >> 1;
    v28 = v8 >> 1;
    v14 = (_QWORD *)(a3 + 568);
    v15 = a4;
    do
    {
      if (**(_DWORD **)a2 == 3)
      {
        v13 = *(_QWORD *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 52) << 7) + 8 * (v9 >> v27));
        v12 = *(_QWORD *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 56) << 7) + 8 * (v9 >> v27));
      }
      if (!*(_DWORD *)(a2 + 6804))
      {
        v16 = *(int *)(a3 + 36);
        v17 = *(int *)(a2 + 6592);
        buffer = (char *)(*(_QWORD *)(a2 + 64) + *(_QWORD *)(a2 + 96) * v16 + v17);
        v11 = (char *)(*(_QWORD *)(a2 + 72) + *(_QWORD *)(a2 + 104) * v16 + v17);
      }
      LOBYTE(v26) = *(_BYTE *)(a3 + 1081);
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, char *, _QWORD, char *, unint64_t, int))(a2 + 6920))(*v14, 0, v13, 0, v12, 0, buffer, 0, v11, __PAIR64__(v28, v29), v26);
      v18 = *(_DWORD *)(a2 + 6804);
      if (v18)
      {
        v30 = v12;
        v19 = v13;
        v20 = *(_QWORD *)(a2 + 72);
        v21 = *(_DWORD *)(a2 + 6492);
        v22 = *(_DWORD *)(a2 + 6596);
        v23 = v21 - v22;
        aj_row_translate(v18, 1, v21, *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), v21 - v22, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), buffer, *(_QWORD *)(a2 + 64));
        v25 = v20;
        v13 = v19;
        v12 = v30;
        aj_row_translate(*(_DWORD *)(a2 + 6804), 2, *(_DWORD *)(a2 + 6492), *(_QWORD *)(a2 + 136), *(_DWORD *)(a2 + 6592), v23, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v11, v25);
      }
      ++*(_DWORD *)(a3 + 36);
      ++v9;
      ++v14;
      --v15;
    }
    while (v15);
  }
  if (*(_DWORD *)(a2 + 6804))
  {
    v24 = (unsigned int *)(a3 + 152);
    aj_rowbuffer_return_buffer(v24, (unint64_t)buffer);
    aj_rowbuffer_return_buffer(v24, (unint64_t)v11);
  }
}

void aj_icol_mcurow_semiplanar422(_DWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v7;
  int v8;
  unsigned int v9;
  char *buffer;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  unsigned int *v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;

  v8 = a1[10];
  v7 = a1[11];
  v29 = a1[12];
  v9 = *(unsigned __int8 *)(a3 + 1080);
  if (*(_DWORD *)(a2 + 6804))
  {
    buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a2 + 6776));
    v11 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a2 + 6792));
  }
  else
  {
    buffer = 0;
    v11 = 0;
  }
  if (a4 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v27 = v7 >> 1;
    v28 = v8 >> 1;
    v14 = (_QWORD *)(a3 + 568);
    v15 = a4;
    do
    {
      if (**(_DWORD **)a2 == 3)
      {
        v13 = *(_QWORD *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 52) << 7) + 8 * (v9 >> v27));
        v12 = *(_QWORD *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 56) << 7) + 8 * (v9 >> v27));
      }
      if (!*(_DWORD *)(a2 + 6804))
      {
        v16 = *(int *)(a3 + 36);
        v17 = *(int *)(a2 + 6592);
        buffer = (char *)(*(_QWORD *)(a2 + 64) + *(_QWORD *)(a2 + 96) * v16 + v17);
        v11 = (char *)(*(_QWORD *)(a2 + 72) + *(_QWORD *)(a2 + 104) * v16 + v17);
      }
      LOBYTE(v26) = *(_BYTE *)(a3 + 1081);
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, char *, _QWORD, char *, unint64_t, int))(a2 + 6920))(*v14, 0, v13, 0, v12, 0, buffer, 0, v11, __PAIR64__(v28, v29), v26);
      v18 = *(_DWORD *)(a2 + 6804);
      if (v18)
      {
        v30 = v12;
        v19 = v13;
        v20 = *(_QWORD *)(a2 + 72);
        v21 = *(_DWORD *)(a2 + 6492);
        v22 = ((v21 - *(_DWORD *)(a2 + 6596)) & 1) + v21 - *(_DWORD *)(a2 + 6596);
        aj_row_translate(v18, 1, v21, *(_QWORD *)(a2 + 128), *(_DWORD *)(a2 + 6592), v22, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), buffer, *(_QWORD *)(a2 + 64));
        if (v22 >= 0)
          v23 = v22;
        else
          v23 = v22 + 1;
        v25 = v20;
        v13 = v19;
        v12 = v30;
        aj_row_translate(*(_DWORD *)(a2 + 6804), 2, *(_DWORD *)(a2 + 6492) / 2, *(_QWORD *)(a2 + 136), *(_DWORD *)(a2 + 6592) / 2, v23 >> 1, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v11, v25);
      }
      ++*(_DWORD *)(a3 + 36);
      ++v9;
      ++v14;
      --v15;
    }
    while (v15);
  }
  if (*(_DWORD *)(a2 + 6804))
  {
    v24 = (unsigned int *)(a3 + 152);
    aj_rowbuffer_return_buffer(v24, (unint64_t)buffer);
    aj_rowbuffer_return_buffer(v24, (unint64_t)v11);
  }
}

void aj_icol_mcurow_semiplanar4X0(_DWORD *a1, int **a2, uint64_t a3, signed int a4, int a5)
{
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  signed int v13;
  char *v14;
  char *v15;
  char *v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned int *v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  int v50;
  unsigned int v51;
  char v52;
  int v53;
  uint64_t v54;
  char *buffer;

  v44 = *((_DWORD *)a2 + 11);
  v52 = v44 == 2;
  if (*(_BYTE *)(a3 + 1083))
    v7 = a5 + a4 >= a1[16];
  else
    v7 = 0;
  v8 = a1[10];
  v9 = a1[11];
  v48 = (unint64_t)a2[8];
  v49 = (unint64_t)a2[9];
  v51 = a1[12];
  v46 = *((int *)a2 + 14);
  v47 = *((int *)a2 + 13);
  v10 = *(_DWORD *)(a3 + 32);
  if ((v10 & 1) != 0 && *(_DWORD *)(a3 + 36) == v10)
  {
    *(_DWORD *)(a3 + 36) = v10 + 1;
    v11 = 1;
  }
  else
  {
    v11 = 0;
  }
  v12 = *(unsigned __int8 *)(a3 + 1080);
  if (*((_DWORD *)a2 + 1701))
  {
    v13 = a4;
    buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), (uint64_t)a2[847]);
    v14 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), (uint64_t)a2[847]);
    v15 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), (uint64_t)a2[849]);
    a4 = v13;
    v16 = v15;
  }
  else
  {
    buffer = 0;
    v14 = 0;
    v16 = 0;
  }
  v50 = v8 >> 1;
  if ((int)v11 < a4)
  {
    HIDWORD(v43) = v7;
    v54 = 0;
    v17 = 0;
    v45 = v9 >> 1;
    v18 = (unsigned int *)(a3 + 152);
    v19 = v11 + v12;
    v20 = (unint64_t *)(a3 + 8 * v11 + 568);
    v21 = a4 - (unint64_t)v11;
    v22 = 1;
    do
    {
      v23 = **a2;
      if (v23 == 3)
      {
        v17 = *(_QWORD *)(a3 + 568 + (v47 << 7) + 8 * (v19 >> v45));
        v54 = *(_QWORD *)(a3 + 568 + (v46 << 7) + 8 * (v19 >> v45));
      }
      v24 = *v20;
      if (*(_DWORD *)(a3 + 1480))
      {
        if (!*((_DWORD *)a2 + 1701))
        {
          v25 = *(int *)(a3 + 36);
          v26 = a2[12];
          v27 = *((int *)a2 + 1648);
          buffer = (char *)(v48 + (_QWORD)v26 * v25 + v27);
          v14 = (char *)v26 + (_QWORD)buffer;
          v16 = (char *)(v49 + (_QWORD)a2[13] * ((uint64_t)(int)(v25 + ((int)v25 < 0)) >> 1) + ((2 * (int)v27) >> v52));
        }
        LOBYTE(v43) = *(_BYTE *)(a3 + 1081);
        ((void (*)(_QWORD, unint64_t, _QWORD, unint64_t, _QWORD, uint64_t, char *, char *, char *, unint64_t, uint64_t))a2[865])(*(_QWORD *)(a3 + 1456), v24, *(_QWORD *)(a3 + 1464), v17, *(_QWORD *)(a3 + 1472), v54, buffer, v14, v16, __PAIR64__(v50, v51), v43);
        if (v22)
        {
          aj_rowbuffer_return_buffer(v18, *(_QWORD *)(a3 + 1456));
          if (**a2 == 3)
          {
            aj_rowbuffer_return_buffer(v18, *(_QWORD *)(a3 + 1464));
            aj_rowbuffer_return_buffer(v18, *(_QWORD *)(a3 + 1472));
          }
        }
        *(_DWORD *)(a3 + 1480) = 0;
        v28 = *((_DWORD *)a2 + 1701);
        if (v28)
        {
          v29 = *((_DWORD *)a2 + 1623);
          v30 = v29 - *((_DWORD *)a2 + 1649);
          v31 = v30 & 1;
          if (v44 != 2)
            v31 = 0;
          v53 = v22;
          v32 = v31 + v30;
          aj_row_translate(v28, 1, v29, (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v31 + v30, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36), buffer, v48);
          aj_row_translate(*((_DWORD *)a2 + 1701), 1, *((_DWORD *)a2 + 1623), (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v32, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36) + 1, v14, v48);
          v33 = v32 >> v52;
          v22 = v53;
          aj_row_translate(*((_DWORD *)a2 + 1701), 2, *((int *)a2 + 1623) >> v52, (uint64_t)a2[17], *((int *)a2 + 1648) >> v52, v33, *((_DWORD *)a2 + 1624) / 2, *(_DWORD *)(a3 + 36) / 2, v16, v49);
        }
        *(_DWORD *)(a3 + 36) += 2;
      }
      else
      {
        *(_DWORD *)(a3 + 1480) = 1;
        *(_QWORD *)(a3 + 1456) = v24;
        if (!*(_BYTE *)(a3 + 1082) || *((_BYTE *)a2 + 6577) || *((_BYTE *)a2 + 6576))
        {
          aj_rowbuffer_lock_buffer(v18, v24);
          if (**a2 == 3)
          {
            *(_QWORD *)(a3 + 1464) = v17;
            *(_QWORD *)(a3 + 1472) = v54;
            aj_rowbuffer_lock_buffer(v18, v17);
            aj_rowbuffer_lock_buffer(v18, *(_QWORD *)(a3 + 1472));
          }
          v22 = 1;
        }
        else
        {
          v22 = 0;
          if (v23 == 3)
          {
            *(_QWORD *)(a3 + 1464) = v17;
            *(_QWORD *)(a3 + 1472) = v54;
          }
        }
      }
      ++v19;
      ++v20;
      --v21;
    }
    while (v21);
    v7 = HIDWORD(v43);
    if (!v22 && *(_DWORD *)(a3 + 1480))
      *(_DWORD *)(a3 + 1480) = 0;
  }
  if (v7 && *(_DWORD *)(a3 + 1480))
  {
    if (!*((_DWORD *)a2 + 1701))
    {
      v34 = *(int *)(a3 + 36);
      v35 = a2[12];
      v36 = *((int *)a2 + 1648);
      buffer = (char *)a2[8] + (_QWORD)v35 * v34 + v36;
      v14 = (char *)v35 + (_QWORD)buffer;
      v16 = (char *)a2[9] + (_QWORD)a2[13] * ((uint64_t)(int)(v34 + ((int)v34 < 0)) >> 1) + ((2 * (int)v36) >> v52);
    }
    LOBYTE(v43) = *(_BYTE *)(a3 + 1081);
    ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, char *, char *, char *, unint64_t, uint64_t))a2[865])(*(_QWORD *)(a3 + 1456), *(_QWORD *)(a3 + 1456), *(_QWORD *)(a3 + 1464), *(_QWORD *)(a3 + 1464), *(_QWORD *)(a3 + 1472), *(_QWORD *)(a3 + 1472), buffer, v14, v16, __PAIR64__(v50, v51), v43);
    aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a3 + 1456));
    if (**a2 == 3)
    {
      aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a3 + 1464));
      aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), *(_QWORD *)(a3 + 1472));
    }
    v37 = *((_DWORD *)a2 + 1701);
    if (v37)
    {
      v38 = *((_DWORD *)a2 + 1623);
      v39 = v38 - *((_DWORD *)a2 + 1649);
      v40 = v39 & 1;
      if (v44 != 2)
        v40 = 0;
      v41 = v40 + v39;
      aj_row_translate(v37, 1, v38, (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v40 + v39, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36), buffer, v48);
      aj_row_translate(*((_DWORD *)a2 + 1701), 1, *((_DWORD *)a2 + 1623), (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v41, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36) + 1, v14, v48);
      aj_row_translate(*((_DWORD *)a2 + 1701), 2, *((int *)a2 + 1623) >> v52, (uint64_t)a2[17], *((int *)a2 + 1648) >> v52, v41 >> v52, *((_DWORD *)a2 + 1624) / 2, *(_DWORD *)(a3 + 36) / 2, v16, v49);
    }
    *(_DWORD *)(a3 + 36) += 2;
    *(_DWORD *)(a3 + 1480) = 0;
  }
  if (*((_DWORD *)a2 + 1701))
  {
    v42 = (unsigned int *)(a3 + 152);
    aj_rowbuffer_return_buffer(v42, (unint64_t)buffer);
    aj_rowbuffer_return_buffer(v42, (unint64_t)v14);
    aj_rowbuffer_return_buffer(v42, (unint64_t)v16);
  }
}

uint64_t aj_icol_max_rows_out(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
    return (*(uint64_t (**)(void))(v4 + 8))();
  else
    return (a4 + *(_DWORD *)(a2 + 48) - 1);
}

uint64_t (**aj_select_adaptive_coder(uint64_t (**result)(int a1)))(int a1)
{
  result[2] = (uint64_t (*)(int))arithmetic_decode_init_0;
  result[3] = (uint64_t (*)(int))arithmetic_context_init_0;
  result[9] = (uint64_t (*)(int))arithmetic_encode_close_0;
  result[10] = (uint64_t (*)(int))arithmetic_decode_close_0;
  result[7] = (uint64_t (*)(int))arithmetic_encode_static_data_0;
  result[8] = (uint64_t (*)(int))arithmetic_decode_static_data_0;
  result[4] = (uint64_t (*)(int))arithmetic_context_init_prob_0;
  result[5] = (uint64_t (*)(int))arithmetic_encode_symbols_0;
  result[6] = (uint64_t (*)(int))arithmetic_decode_symbols_0;
  *result = arithmetic_prob_table_size_0;
  result[1] = (uint64_t (*)(int))arithmetic_encode_init_0;
  return result;
}

int *arithmetic_context_init_0(uint64_t a1, int *a2, int a3, int a4)
{
  return init_cum_prob_0(a2, a3, 0, a4);
}

int *arithmetic_context_init_prob_0(uint64_t a1, int *a2, int a3, int a4, unsigned __int8 *a5)
{
  return init_cum_prob_0(a2, a3, a5, a4);
}

uint64_t arithmetic_decode_close_0()
{
  return 0;
}

uint64_t arithmetic_decode_static_data_0(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  char v3;
  uint64_t result;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;

  v3 = a3;
  if (a3 - 33 <= 0xFFFFFFDF)
  {
    aj_log_error(0, "Illegal number of data bits: %d", a3);
    return 7;
  }
  *a2 = 0;
  if (a3 < 0x11)
    goto LABEL_9;
  v7 = HIWORD(*(_DWORD *)a1);
  if (*(_DWORD *)(a1 + 8) / v7 >= 0xFFFF)
    v8 = 0xFFFF;
  else
    v8 = *(_DWORD *)(a1 + 8) / v7;
  result = arithmetic_decode_0((int *)a1, *(_QWORD *)(a1 + 24), v8, v8 + 1, v7);
  if (!(_DWORD)result)
  {
    v3 -= 16;
    *a2 = v8 << v3;
LABEL_9:
    v9 = *(_DWORD *)a1 >> v3;
    if (*(_DWORD *)(a1 + 8) / v9 >= ~(-1 << v3))
      v10 = ~(-1 << v3);
    else
      v10 = *(_DWORD *)(a1 + 8) / v9;
    result = arithmetic_decode_0((int *)a1, *(_QWORD *)(a1 + 24), v10, v10 + 1, v9);
    if (!(_DWORD)result)
      *a2 |= v10;
  }
  return result;
}

uint64_t arithmetic_decode_init_0(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  int v4;
  uint64_t result;
  unsigned int v6;

  v2 = 0;
  v3 = *(_QWORD *)(a1 + 24);
  v6 = 0;
  *(_QWORD *)a1 = 0xFFFFFFFFLL;
  v4 = 4;
  do
  {
    *(_DWORD *)(a1 + 8) = v2 << 8;
    result = aj_istream_read_bytes_le(v3, &v6, 1);
    if ((_DWORD)result)
      break;
    v2 = *(_DWORD *)(a1 + 8) | v6;
    *(_DWORD *)(a1 + 8) = v2;
    --v4;
  }
  while (v4);
  return result;
}

uint64_t arithmetic_decode_symbols_0(uint64_t a1, int **a2, _BYTE *a3, int a4)
{
  int i;
  uint64_t v7;
  int *v8;
  int v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  char v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t result;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int *v32;
  int v33;
  int v34;
  int v35;

  if (a4)
  {
    for (i = a4; i; --i)
    {
      v7 = 0;
      v8 = *a2;
      v10 = *a2 + 1;
      v9 = **a2;
      v11 = v10[v9 + 2];
      v12 = v9 + 1;
      v13 = v10[v12];
      v14 = v13 - 1;
      v15 = *(_DWORD *)a1 / v13;
      if (v13 - 1 >= *(_DWORD *)(a1 + 8) / v15)
        v14 = *(_DWORD *)(a1 + 8) / v15;
      do
        v16 = v8[v9 + v7--];
      while (v16 > v14);
      v17 = ~(_BYTE)v7;
      if (~(_DWORD)v7 >= (int)v11)
      {
        v25 = v10[v9 + (v7 | 0xFFFFFF00)];
        result = arithmetic_decode_0((int *)a1, *(_QWORD *)(a1 + 24), v25, v25 + 1, v15);
        if ((_DWORD)result)
          return result;
        v26 = -1;
        do
          ++v26;
        while (v26 <= 0x1F && 1 << v26 < v9);
        v27 = *(_DWORD *)a1 >> v26;
        v28 = *(_DWORD *)(a1 + 8) / v27 >= ~(-1 << v26) ? ~(-1 << v26) : *(_DWORD *)(a1 + 8) / v27;
        result = arithmetic_decode_0((int *)a1, *(_QWORD *)(a1 + 24), v28, v28 + 1, v27);
        if ((_DWORD)result)
          return result;
        v35 = i;
        *a3 = v28;
        v29 = v28;
        if (v28 >= v9)
        {
          aj_log_error(0, "Symbol is too large. %d > %d", v28, v9);
          return 7;
        }
        cum_to_probs((uint64_t)v10, v9);
        v30 = v28 + 1;
        if ((int)v11 < v29)
        {
          v31 = v11 + 1;
          v32 = &v8[v11 + 3];
          do
          {
            ++*v32++;
            ++v10[v12];
            ++v31;
          }
          while (v30 != v31);
        }
        v33 = v29 + 2;
        if (v30 < v9)
        {
          ++v10[v33];
          ++v10[v12];
        }
        ++v10[v30];
        ++v10[v12];
        probs_to_cum(v10, v9);
        if (v9 == v33)
          v34 = v9;
        else
          v34 = v29 + 1;
        v10[v9 + 2] = v34;
        i = v35;
      }
      else
      {
        v18 = v9 + v7;
        v19 = v8[v9 + 2 + (int)v7];
        v20 = v9 + v7 + 1;
        v21 = v8[v9 + 1 + (int)v7];
        if (v20 <= v9)
        {
          v22 = v18;
          do
            ++v8[v22++ + 2];
          while (v9 != (_DWORD)v22);
          v13 = v10[v12];
        }
        v23 = *(_QWORD *)(a1 + 24);
        v10[v12] = v13 + 1;
        result = arithmetic_decode_0((int *)a1, v23, v16, v19 + v16 - v21, v15);
        if ((_DWORD)result)
          return result;
        *a3 = v17;
        if (v10[v12] >= 0x800)
          scale_cumprob(v10, v9);
      }
      ++a2;
      ++a3;
    }
  }
  return 0;
}

uint64_t arithmetic_encode_close_0(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  uint64_t result;
  int v6;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 4);
  v4 = 4;
  while (1)
  {
    result = byte_plus_prev(a1, v2, HIBYTE(v3));
    if ((_DWORD)result)
      return result;
    v3 = *(_DWORD *)(a1 + 4) << 8;
    *(_DWORD *)(a1 + 4) = v3;
    if (!--v4)
    {
      result = aj_ostream_write_bytes(v2, *(unsigned __int8 *)(a1 + 33), 1);
      if (!(_DWORD)result)
      {
        if (*(_DWORD *)(a1 + 12))
        {
          while (1)
          {
            result = aj_ostream_write_bytes(v2, 255, 1);
            if ((_DWORD)result)
              break;
            v6 = *(_DWORD *)(a1 + 12) - 1;
            *(_DWORD *)(a1 + 12) = v6;
            if (!v6)
              goto LABEL_8;
          }
        }
        else
        {
LABEL_8:
          result = 0;
          *(_BYTE *)(a1 + 33) = 0;
        }
      }
      return result;
    }
  }
}

uint64_t arithmetic_encode_static_data_0(uint64_t a1, unsigned int a2, int a3)
{
  char v3;
  int v4;
  uint64_t result;

  v3 = a3;
  v4 = a2;
  if (a3 >= 17)
  {
    v3 = a3 - 16;
    result = arithmetic_encode_static((int *)a1, *(_QWORD *)(a1 + 16), a2 >> (a3 - 16), (a2 >> (a3 - 16)) + 1, 16);
    if ((_DWORD)result)
      return result;
    v4 &= ~(-1 << v3);
  }
  return arithmetic_encode_static((int *)a1, *(_QWORD *)(a1 + 16), v4, v4 + 1, v3);
}

uint64_t arithmetic_encode_init_0(uint64_t a1)
{
  *(_QWORD *)a1 = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = 0;
  return 0;
}

uint64_t arithmetic_encode_symbols_0(uint64_t a1, int **a2, unsigned __int8 *a3, int a4)
{
  int v4;
  int *v7;
  int *v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t result;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  int *v26;
  uint64_t v27;
  int v28;
  int v29;

  if (!a4)
    return 0;
  v4 = a4;
  while (1)
  {
    v8 = *a2++;
    v7 = v8;
    v10 = v8 + 1;
    v9 = *v8;
    LODWORD(v8) = *a3++;
    v11 = v8;
    if ((int)v9 <= (int)v8)
      break;
    v12 = v10[v9 + 2];
    if ((int)v11 >= (int)v12)
    {
      v21 = v10[(int)v9 + ~(_DWORD)v12];
      v22 = v9 + 1;
      result = arithmetic_encode_0((int *)a1, *(_QWORD *)(a1 + 16), v21, v21 + 1, v10[v9 + 1]);
      if ((_DWORD)result)
        return result;
      v29 = v4;
      v23 = -1;
      do
        ++v23;
      while (v23 <= 0x1F && 1 << v23 < (int)v9);
      v24 = v11 + 1;
      result = arithmetic_encode_static((int *)a1, *(_QWORD *)(a1 + 16), v11, (int)v11 + 1, v23);
      if ((_DWORD)result)
        return result;
      cum_to_probs((uint64_t)v10, v9);
      if ((int)v11 > (int)v12)
      {
        v25 = v11 - v12;
        v26 = &v7[v12 + 3];
        do
        {
          ++*v26++;
          ++v10[v22];
          --v25;
        }
        while (v25);
      }
      v27 = v11 + 2;
      if ((int)v24 < (int)v9)
      {
        ++v10[v27];
        ++v10[v22];
      }
      ++v10[v24];
      ++v10[v22];
      probs_to_cum(v10, v9);
      if ((_DWORD)v9 == (_DWORD)v27)
        v28 = v9;
      else
        v28 = v11 + 1;
      v10[v9 + 2] = v28;
      v4 = v29;
    }
    else
    {
      v13 = v9 + ~(_DWORD)v11;
      v14 = v10[v13];
      v15 = v7[v13 + 2];
      if (v13 < (int)v9)
      {
        v16 = &v7[v13 + 2];
        v17 = v11 + 1;
        do
        {
          ++*v16++;
          --v17;
        }
        while (v17);
      }
      v18 = *(_QWORD *)(a1 + 16);
      v19 = v10[(int)v9 + 1];
      v10[(int)v9 + 1] = v19 + 1;
      result = arithmetic_encode_0((int *)a1, v18, v14, v15, v19);
      if ((_DWORD)result)
        return result;
      if (v10[(int)v9 + 1] >= 0x800)
        scale_cumprob(v10, v9);
    }
    if (!--v4)
      return 0;
  }
  aj_log_error(0, "Illegal symbol to be encoded (%d). Num syms in this context is %d.", v11, v9);
  return 7;
}

uint64_t arithmetic_prob_table_size_0(int a1)
{
  return (4 * a1 + 16);
}

int *init_cum_prob_0(int *a1, int a2, unsigned __int8 *a3, int a4)
{
  int *v8;
  uint64_t v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  int v13;

  bzero(a1, 4 * a2 + 16);
  *a1 = a2;
  v8 = a1 + 1;
  if (a2 - 1 <= a4)
    v9 = a2;
  else
    v9 = a4;
  v8[a2 + 2] = v9;
  if (a3)
  {
    v10 = 0;
    if ((int)v9 >= 1)
    {
      v11 = a1 + 2;
      v12 = v9;
      do
      {
        *v11++ = *a3;
        v13 = *a3++;
        v10 += v13;
        --v12;
      }
      while (v12);
    }
    if ((int)v9 < a2)
    {
      v8[(int)v9 + 1] = 1;
      ++v10;
    }
  }
  else
  {
    if ((int)v9 >= 1)
      memset_pattern16(a1 + 2, &unk_20627C400, 4 * v9);
    v10 = v9;
    if ((int)v9 < a2)
    {
      bzero(&a1[(int)v9 + 2], 4 * (a2 - 1 - v9) + 4);
      v10 = v9 + 1;
      v8[(int)v9 + 1] = 1;
    }
  }
  v8[a2 + 1] = v10;
  return probs_to_cum(a1 + 1, a2);
}

int *probs_to_cum(int *result, int a2)
{
  _DWORD *v2;
  int v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  int v8;

  v2 = result + 1;
  v3 = a2 - 1;
  if (a2 > 1)
  {
    v4 = a2 >> 1;
    v5 = result + 1;
    do
    {
      v6 = *v5;
      *v5++ = v2[v3];
      v2[v3--] = v6;
      --v4;
    }
    while (v4);
  }
  if (a2 >= 1)
  {
    v7 = a2;
    v8 = *result;
    do
    {
      v8 += *v2;
      *v2++ = v8;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t arithmetic_decode_0(int *a1, uint64_t a2, int a3, int a4, int a5)
{
  int v6;
  unsigned int v7;
  uint64_t result;
  int v10;
  unsigned int v11;

  v6 = (a4 - a3) * a5;
  *a1 = v6;
  v7 = a1[2] - a5 * a3;
  a1[2] = v7;
  if ((v6 - 16777217) >> 24 == 255)
  {
    v11 = 0;
    while (1)
    {
      a1[2] = v7 << 8;
      result = aj_istream_read_bytes_le(a2, &v11, 1);
      if ((_DWORD)result)
        break;
      v7 = a1[2] | v11;
      a1[2] = v7;
      v10 = *a1;
      v6 = *a1 << 8;
      *a1 = v6;
      if (((v10 << 8) - 16777217) >> 24 != 255)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    result = 0;
    if (!v6)
      *a1 = -1;
  }
  return result;
}

int *scale_cumprob(int *a1, int a2)
{
  int v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int v7;

  cum_to_probs((uint64_t)a1, a2);
  if (a2 < 1)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = (unsigned int *)(a1 + 1);
    v6 = a2;
    do
    {
      v7 = *v5 + 1;
      *v5++ = v7 >> 1;
      v4 += v7 >> 1;
      --v6;
    }
    while (v6);
  }
  a1[a2 + 1] = v4;
  return probs_to_cum(a1, a2);
}

uint64_t cum_to_probs(uint64_t result, int a2)
{
  int *v2;
  int v3;
  unint64_t v4;
  _DWORD *v5;
  int v6;
  uint64_t v8;
  int *v9;
  int v10;

  if (a2 >= 1)
  {
    v2 = (int *)(result + 4);
    v3 = *(_DWORD *)(result + 4 * a2);
    v4 = a2;
    do
    {
      v5 = (_DWORD *)(result + 4 * v4);
      v6 = *(v5 - 1);
      *v5 = v3 - v6;
      v3 = v6;
    }
    while (v4-- > 1);
    if (a2 >= 2)
    {
      v8 = a2 >> 1;
      v9 = (int *)(result + 4 * (a2 - 1) + 4);
      do
      {
        v10 = *v2;
        *v2++ = *v9;
        *v9-- = v10;
        --v8;
      }
      while (v8);
    }
  }
  return result;
}

uint64_t arithmetic_encode_static(int *a1, uint64_t a2, int a3, int a4, char a5)
{
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t result;
  int v13;

  v7 = a1[1];
  v8 = *a1 >> a5;
  v9 = v8 * (a4 - a3);
  *a1 = v9;
  v10 = v8 * a3;
  v11 = v10 + v7;
  if (__CFADD__(v10, v7))
  {
    result = byte_carry((uint64_t)a1, a2);
    if ((_DWORD)result)
      return result;
    v9 = *a1;
  }
  a1[1] = v11;
  if ((v9 - 16777217) >> 24 == 255)
  {
    while (1)
    {
      result = byte_plus_prev((uint64_t)a1, a2, HIBYTE(v11));
      if ((_DWORD)result)
        break;
      v13 = *a1;
      v11 = a1[1] << 8;
      v9 = *a1 << 8;
      *a1 = v9;
      a1[1] = v11;
      if (((v13 << 8) - 16777217) >> 24 != 255)
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    result = 0;
    if (!v9)
      *a1 = -1;
  }
  return result;
}

uint64_t byte_carry(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2;
  int v5;
  uint64_t result;
  int v7;

  v2 = *(_BYTE *)(a1 + 33) + 1;
  *(_BYTE *)(a1 + 33) = v2;
  if (!*(_DWORD *)(a1 + 12))
    return 0;
  v5 = v2;
  do
  {
    result = aj_ostream_write_bytes(a2, v5, 1);
    if ((_DWORD)result)
      break;
    v5 = 0;
    *(_BYTE *)(a1 + 33) = 0;
    v7 = *(_DWORD *)(a1 + 12) - 1;
    *(_DWORD *)(a1 + 12) = v7;
  }
  while (v7);
  return result;
}

uint64_t arithmetic_encode_0(int *a1, uint64_t a2, int a3, int a4, unsigned int a5)
{
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t result;
  int v13;

  v7 = a1[1];
  v8 = *a1 / a5;
  v9 = v8 * (a4 - a3);
  *a1 = v9;
  v10 = v8 * a3;
  v11 = v7 + v10;
  if (__CFADD__(v7, v10))
  {
    result = byte_carry((uint64_t)a1, a2);
    if ((_DWORD)result)
      return result;
    v9 = *a1;
  }
  a1[1] = v11;
  if ((v9 - 16777217) >> 24 == 255)
  {
    while (1)
    {
      result = byte_plus_prev((uint64_t)a1, a2, HIBYTE(v11));
      if ((_DWORD)result)
        break;
      v13 = *a1;
      v11 = a1[1] << 8;
      v9 = *a1 << 8;
      *a1 = v9;
      a1[1] = v11;
      if (((v13 << 8) - 16777217) >> 24 != 255)
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    result = 0;
    if (!v9)
      *a1 = -1;
  }
  return result;
}

uint64_t aj_init_QT_as_no_op(uint64_t result, int a2)
{
  uint64_t v2;
  unsigned int v3;
  int32x4_t v4;

  v2 = 0;
  if (a2 == 1)
    v3 = 4096;
  else
    v3 = 1;
  v4 = vdupq_n_s32(v3);
  do
  {
    *(int32x4_t *)(result + v2) = v4;
    v2 += 16;
  }
  while (v2 != 256);
  return result;
}

uint64_t aj_idct_s8(__int16 *a1, _QWORD *a2, int a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  char v6;

  v3 = *a1;
  v4 = v3 + 1028;
  v5 = (v3 + 1028) >> 3;
  if (v3 <= -1029)
    v6 = 0;
  else
    v6 = -1;
  if (v4 < 0x800)
    v6 = v5;
  *(_BYTE *)(*a2 + a3) = v6;
  return 1;
}

uint64_t aj_idct_s8_1x2_nearest(__int16 *a1, _QWORD *a2, int a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  char v6;
  char *v7;

  v3 = *a1;
  v4 = v3 + 1028;
  v5 = (v3 + 1028) >> 3;
  if (v3 <= -1029)
    v6 = 0;
  else
    v6 = -1;
  if (v4 < 0x800)
    v6 = v5;
  v7 = (char *)(*a2 + a3);
  *v7 = v6;
  v7[1] = v6;
  return 2;
}

uint64_t aj_idct_s4_1x2(__int16 *a1, _QWORD *a2, int a3)
{
  _BYTE *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  char v11;
  char v12;
  int v13;
  unsigned int v14;
  char v15;

  v3 = (_BYTE *)(*a2 + a3);
  v4 = *a1;
  v5 = a1[1];
  v6 = v4 - v5;
  v7 = a1[8];
  v8 = a1[9];
  v9 = v7 - v8;
  v10 = v5 + v4 + v7 + v8;
  if (v10 <= -1029)
    v11 = 0;
  else
    v11 = -1;
  if ((v10 + 1028) >= 0x800)
    v12 = v11;
  else
    v12 = (v10 + 1028) >> 3;
  *v3 = v12;
  v13 = v9 + v6;
  v14 = v9 + v6 + 1028;
  if (v13 <= -1029)
    v15 = 0;
  else
    v15 = -1;
  if (v14 < 0x800)
    v15 = v14 >> 3;
  v3[1] = v15;
  return 2;
}

uint64_t aj_idct_s4_2x1(__int16 *a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  char v12;
  char v13;
  int v14;
  int v15;
  unsigned int v16;
  char v17;

  v3 = a2[1];
  v4 = *a1;
  v5 = a1[8];
  v6 = a1[9];
  v7 = v6 + v5;
  v8 = v5 - v6;
  v9 = v7 + 2 * v4 + v8;
  v10 = v9 + 2;
  if (v9 >= -1)
    v10 = v9 + 1;
  v11 = (v10 >> 1) + 1028;
  if (v9 <= -2059)
    v12 = 0;
  else
    v12 = -1;
  if (v11 >= 0x800)
    v13 = v12;
  else
    v13 = v11 >> 3;
  *(_BYTE *)(*a2 + a3) = v13;
  v14 = v4 - v7 + v4 - v8;
  v15 = v14 + 2;
  if (v14 >= -1)
    v15 = v14 + 1;
  v16 = (v15 >> 1) + 1028;
  if (v14 <= -2059)
    v17 = 0;
  else
    v17 = -1;
  if (v16 < 0x800)
    v17 = v16 >> 3;
  *(_BYTE *)(v3 + a3) = v17;
  return 1;
}

uint64_t aj_idct_s2_2x4(int16x4_t *a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int16x4_t v5;
  int32x4_t v6;
  char v7;
  char v8;
  int *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  char v19;
  char *v20;
  unsigned int v21;
  char v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  char v26;
  unsigned int v27;
  char v28;
  _QWORD v30[4];
  _OWORD v31[2];
  uint64_t v32;

  v3 = 0;
  v32 = *MEMORY[0x24BDAC8D0];
  v4 = a2[1] + a3;
  v30[0] = *a2 + a3;
  v30[1] = v4;
  v5 = a1[2];
  v6 = vsubl_s16(*a1, v5);
  v7 = 1;
  v31[0] = vaddl_s16(v5, *a1);
  v31[1] = v6;
  do
  {
    v8 = v7;
    v9 = (int *)&v31[v3];
    v10 = *v9;
    v11 = v9[1];
    v12 = v9[2];
    LODWORD(v9) = v9[3];
    v13 = v12 + v10;
    v14 = v10 - v12;
    v15 = (17734 * ((int)v9 + v11) + 0x4000) >> 15;
    v16 = v15 + ((25080 * v11 + 0x4000) >> 15);
    v17 = v15 - ((_DWORD)v9 + ((27779 * (int)v9 + 0x4000) >> 15));
    v18 = v16 + v13 + 1028;
    if (v16 + v13 <= -1029)
      v19 = 0;
    else
      v19 = -1;
    if (v18 < 0x800)
      v19 = v18 >> 3;
    v20 = (char *)v30[v3];
    *v20 = v19;
    v21 = v17 + v14 + 1028;
    if (v17 + v14 <= -1029)
      v22 = 0;
    else
      v22 = -1;
    if (v21 < 0x800)
      v22 = v21 >> 3;
    v20[1] = v22;
    v23 = v14 - v17;
    v24 = v23 + 1028;
    v25 = (v23 + 1028) >> 3;
    if (v23 <= -1029)
      v26 = 0;
    else
      v26 = -1;
    if (v24 < 0x800)
      v26 = v25;
    v20[2] = v26;
    v27 = v13 - v16 + 1028;
    if (v13 - v16 <= -1029)
      v28 = 0;
    else
      v28 = -1;
    if (v27 < 0x800)
      v28 = v27 >> 3;
    v20[3] = v28;
    v30[v3] = v20 + 4;
    v3 = 1;
    v7 = 0;
  }
  while ((v8 & 1) != 0);
  return 4;
}

uint64_t aj_idct_s2_4x2(int16x4_t *a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int16x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int16x4_t v9;
  int16x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  char *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  char v27;
  char *v28;
  int v29;
  int v30;
  unsigned int v31;
  char v32;
  _QWORD v34[4];
  _OWORD v35[4];
  uint64_t v36;

  v3 = 0;
  v36 = *MEMORY[0x24BDAC8D0];
  v4 = a2[1] + a3;
  v34[0] = *a2 + a3;
  v34[1] = v4;
  v5 = a2[3] + a3;
  v34[2] = a2[2] + a3;
  v34[3] = v5;
  v6 = a1[4];
  v7 = vaddl_s16(v6, *a1);
  v8 = vsubl_s16(*a1, v6);
  v9 = a1[2];
  v10 = a1[6];
  v11.i64[0] = 0x400000004000;
  v11.i64[1] = 0x400000004000;
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  v13 = vshrq_n_s32(vmlaq_s32(v12, vaddl_s16(v10, v9), vdupq_n_s32(0x4546u)), 0xFuLL);
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  v14 = vmlal_s16(v12, v9, vdup_n_s16(0x61F8u));
  v15 = vsubq_s32(v13, vsraq_n_s32(vmovl_s16(v10), vmlal_s16(v11, v10, vdup_n_s16(0x6C83u)), 0xFuLL));
  v16 = vsraq_n_s32(v13, v14, 0xFuLL);
  v35[0] = vaddq_s32(v16, v7);
  v35[1] = vaddq_s32(v15, v8);
  v35[2] = vsubq_s32(v8, v15);
  v35[3] = vsubq_s32(v7, v16);
  v17 = (char *)v35 + 8;
  do
  {
    v18 = *((_DWORD *)v17 - 2);
    v19 = *((_DWORD *)v17 - 1);
    v20 = *((_DWORD *)v17 + 1);
    v17 += 16;
    v21 = (17734 * (v20 + v19) + 0x4000) >> 15;
    v22 = v21 + ((25080 * v19 + 0x4000) >> 15);
    v23 = v21 - (v20 + ((27779 * v20 + 0x4000) >> 15));
    v24 = v22 + 2 * v18 + v23;
    v25 = v24 + 2;
    if (v24 >= -1)
      v25 = v24 + 1;
    v26 = (v25 >> 1) + 1028;
    if (v24 <= -2059)
      v27 = 0;
    else
      v27 = -1;
    if (v26 < 0x800)
      v27 = v26 >> 3;
    v28 = (char *)v34[v3];
    *v28 = v27;
    v29 = v18 - v23 + v18 - v22;
    v30 = v29 + 2;
    if (v29 >= -1)
      v30 = v29 + 1;
    v31 = (v30 >> 1) + 1028;
    if (v29 <= -2059)
      v32 = 0;
    else
      v32 = -1;
    if (v31 < 0x800)
      v32 = v31 >> 3;
    v28[1] = v32;
    v34[v3++] = v28 + 2;
  }
  while (v3 != 4);
  return 2;
}

uint64_t aj_idct_s1_12bit(int *a1, uint64_t *a2, int a3)
{
  uint64_t i;
  uint64_t v6;
  _BYTE v8[128];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  basic_idct_s1_12bit(a1, (uint64_t)v8);
  for (i = 0; i != 128; i += 16)
  {
    v6 = *a2++;
    *(_OWORD *)(v6 + a3) = *(_OWORD *)&v8[i];
  }
  return 16;
}

uint64_t basic_idct_s1_12bit(int *a1, uint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  int *v6;
  int *v7;
  int *v8;
  uint64_t v9;
  int *v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int16 *v16;
  uint64_t result;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  __int16 v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  __int16 v33;
  unsigned int v34;
  __int16 v35;
  unsigned int v36;
  __int16 v37;
  unint64_t i;
  uint64_t v39;
  uint64_t v40;
  __int16 v41;
  __int16 v42;
  int *v43;
  int *v44;
  _BYTE v45[256];
  _DWORD v46[8];
  uint64_t v47;

  v4 = 0;
  v47 = *MEMORY[0x24BDAC8D0];
  v5 = v45;
  v6 = a1;
  do
  {
    v7 = &a1[v4];
    if (v7[8] || v7[24] | v7[16] || (v8 = &a1[v4], v8[40] | v8[32]) || v8[56] | v8[48])
    {
      v9 = 0;
      v10 = v6;
      do
      {
        v11 = *v10;
        v10 += 8;
        v46[v9++] = v11;
      }
      while (v9 != 8);
      v12 = &v45[4 * v4];
      idct_aan(v46, v12, v12 + 8, v12 + 16, v12 + 24, v12 + 32, v12 + 40, v12 + 48, v12 + 56);
    }
    else
    {
      v13 = 0;
      v14 = a1[v4];
      do
      {
        *(_DWORD *)&v5[v13] = v14;
        v13 += 32;
      }
      while (v13 != 256);
    }
    ++v4;
    ++v6;
    v5 += 4;
  }
  while (v4 != 8);
  v15 = 0;
  v16 = (__int16 *)(a2 + 8);
  do
  {
    v43 = (int *)&v45[v15 + 24];
    v44 = (int *)&v45[v15 + 28];
    result = idct_aan(&v45[v15], &v45[v15], &v45[v15 + 4], &v45[v15 + 8], &v45[v15 + 12], &v45[v15 + 16], &v45[v15 + 20], v43, v44);
    v18 = *(_DWORD *)&v45[v15];
    if ((v18 + 65552) >= 0x20000)
    {
      if (v18 <= -65553)
        LOWORD(v19) = 0;
      else
        LOWORD(v19) = 4095;
    }
    else
    {
      v19 = (v18 + 65552) >> 5;
    }
    *(v16 - 4) = v19;
    v20 = *(_DWORD *)&v45[v15 + 4];
    if ((v20 + 65552) >= 0x20000)
    {
      if (v20 <= -65553)
        LOWORD(v21) = 0;
      else
        LOWORD(v21) = 4095;
    }
    else
    {
      v21 = (v20 + 65552) >> 5;
    }
    *(v16 - 3) = v21;
    v22 = *(_DWORD *)&v45[v15 + 8];
    if ((v22 + 65552) >= 0x20000)
    {
      if (v22 <= -65553)
        LOWORD(v23) = 0;
      else
        LOWORD(v23) = 4095;
    }
    else
    {
      v23 = (v22 + 65552) >> 5;
    }
    *(v16 - 2) = v23;
    v24 = *(_DWORD *)&v45[v15 + 12];
    if ((v24 + 65552) >= 0x20000)
    {
      if (v24 <= -65553)
        LOWORD(v25) = 0;
      else
        LOWORD(v25) = 4095;
    }
    else
    {
      v25 = (v24 + 65552) >> 5;
    }
    *(v16 - 1) = v25;
    v26 = *(_DWORD *)&v45[v15 + 16];
    v27 = v26 + 65552;
    v28 = (v26 + 65552) >> 5;
    if (v26 <= -65553)
      v29 = 0;
    else
      v29 = 4095;
    if (v27 < 0x20000)
      v29 = v28;
    *v16 = v29;
    v30 = *(_DWORD *)&v45[v15 + 20];
    v31 = v30 + 65552;
    v32 = (v30 + 65552) >> 5;
    if (v30 <= -65553)
      v33 = 0;
    else
      v33 = 4095;
    if (v31 < 0x20000)
      v33 = v32;
    v16[1] = v33;
    v34 = *v43 + 65552;
    if (*v43 <= -65553)
      v35 = 0;
    else
      v35 = 4095;
    if (v34 < 0x20000)
      v35 = v34 >> 5;
    v16[2] = v35;
    v36 = *v44 + 65552;
    if (*v44 <= -65553)
      v37 = 0;
    else
      v37 = 4095;
    if (v36 < 0x20000)
      v37 = v36 >> 5;
    v16[3] = v37;
    v15 += 32;
    v16 += 8;
  }
  while (v15 != 256);
  for (i = 0; i != 8; ++i)
  {
    if (i <= 6)
    {
      v39 = 1;
      v40 = 16;
      do
      {
        v41 = *(_WORD *)(a2 + 2 * v39) ^ *(_WORD *)(a2 + v40);
        *(_WORD *)(a2 + 2 * v39) = v41;
        v42 = *(_WORD *)(a2 + v40) ^ v41;
        *(_WORD *)(a2 + v40) = v42;
        *(_WORD *)(a2 + 2 * v39) ^= v42;
        v40 += 16;
        ++v39;
      }
      while (i + v39 != 8);
    }
    a2 += 18;
  }
  return result;
}

uint64_t aj_idct_s1_16x16_bilinear_12bit(int *a1, _QWORD *a2, int a3)
{
  uint64_t v5;
  _WORD *v6;
  int v7;
  _WORD *v8;
  int v9;
  _WORD *v10;
  int v11;
  unsigned __int16 *v12;
  uint64_t v13;
  _WORD *v14;
  uint64_t v15;
  int v16;
  _QWORD *v17;
  _WORD *v18;
  _WORD *v19;
  int v20;
  int v21;
  _WORD *v22;
  _WORD *v23;
  _WORD *v24;
  _WORD *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unint64_t v30;
  _WORD *v31;
  _WORD *v32;
  _WORD *v33;
  int v34;
  _WORD v36[8];
  _QWORD v37[15];

  v37[14] = *MEMORY[0x24BDAC8D0];
  basic_idct_s1_12bit(a1, (uint64_t)v36);
  v5 = 0;
  v6 = (_WORD *)(*a2 + a3);
  v7 = v36[0];
  *v6 = v36[0];
  v8 = v6 + 1;
  v9 = v7;
  do
  {
    v10 = &v8[v5 * 2];
    v11 = (unsigned __int16)v36[v5 + 1];
    *v10 = (3 * v9 + v11 + 2) >> 2;
    v10[1] = (v9 + 3 * v11 + 1) >> 2;
    ++v5;
    v9 = v11;
  }
  while (v5 != 7);
  v12 = (unsigned __int16 *)v37;
  v8[14] = v11;
  v13 = 1;
  v14 = v36;
  do
  {
    v15 = 0;
    v16 = v7;
    v17 = &a2[2 * v13];
    v18 = (_WORD *)(*(v17 - 1) + a3);
    v19 = (_WORD *)(*v17 + a3);
    v7 = *v12;
    v20 = 3 * v16 + v7;
    v21 = 3 * v7 + v16;
    *v18 = (v20 + 1) >> 2;
    v22 = v18 + 1;
    *v19 = (v21 + 1) >> 2;
    v23 = v19 + 1;
    do
    {
      v24 = &v23[v15 * 2];
      v25 = &v22[v15 * 2];
      v26 = (unsigned __int16)v14[v15 + 1];
      v27 = (unsigned __int16)v14[v15 + 9];
      v28 = 3 * v26 + v27;
      v29 = 3 * v27 + v26;
      *v25 = (3 * v20 + v28 + 8) >> 4;
      v25[1] = (v20 + 3 * v28 + 7) >> 4;
      *v24 = (3 * v21 + v29 + 8) >> 4;
      v24[1] = (v21 + 3 * v29 + 7) >> 4;
      ++v15;
      v21 = v29;
      v20 = v28;
    }
    while (v15 != 7);
    v22[14] = (v28 + 2) >> 2;
    v23[14] = (v29 + 2) >> 2;
    ++v13;
    v12 = &v36[8 * v13];
    v14 += 8;
  }
  while (v13 != 8);
  v30 = 0;
  v31 = (_WORD *)(a2[15] + a3);
  *v31 = v7;
  v32 = v31 + 1;
  do
  {
    v33 = &v32[v30];
    v34 = (unsigned __int16)v14[v30 / 2 + 1];
    *v33 = (3 * v7 + v34 + 2) >> 2;
    v33[1] = (v7 + 3 * v34 + 1) >> 2;
    v30 += 2;
    v7 = v34;
  }
  while ((_DWORD)v30 != 14);
  v32[v30] = v34;
  return 32;
}

uint64_t aj_idct_s1_16x8_bilinear_12bit(int *a1, _QWORD *a2, int a3)
{
  _QWORD *v5;
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  _OWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  __int128 v16;
  _QWORD v17[15];

  v17[14] = *MEMORY[0x24BDAC8D0];
  v5 = v17;
  basic_idct_s1_12bit(a1, (uint64_t)&v16);
  *(_OWORD *)(*a2 + a3) = v16;
  v6 = 1;
  v7 = &v16;
  do
  {
    v8 = 0;
    v9 = v5;
    v10 = &a2[2 * v6];
    v11 = *(v10 - 1) + a3;
    v12 = *v10 + a3;
    do
    {
      v13 = *(unsigned __int16 *)((char *)v7 + v8);
      v14 = *(unsigned __int16 *)((char *)v7 + v8 + 16);
      *(_WORD *)(v11 + v8) = (v14 + 3 * v13 + 1) >> 2;
      *(_WORD *)(v12 + v8) = (v13 + 3 * v14 + 2) >> 2;
      v8 += 2;
    }
    while (v8 != 16);
    ++v6;
    v5 = &v17[2 * v6 - 2];
    ++v7;
  }
  while (v6 != 8);
  *(_OWORD *)(a2[15] + a3) = *v9;
  return 16;
}

uint64_t aj_idct_s1_8x4_12bit(int *a1, uint64_t a2, int a3)
{
  uint64_t i;
  const __int16 *v6;
  _OWORD v8[8];
  uint64_t v9;
  int16x4x2_t v10;

  v9 = *MEMORY[0x24BDAC8D0];
  basic_idct_s1_12bit(a1, (uint64_t)v8);
  for (i = 0; i != 8; ++i)
  {
    v6 = (const __int16 *)&v8[i];
    v10 = vld2_s16(v6);
    *(uint16x4_t *)(*(_QWORD *)(a2 + 8 * i) + a3) = vrhadd_u16((uint16x4_t)v10.val[0], (uint16x4_t)v10.val[1]);
  }
  return 8;
}

uint64_t aj_idct_s1_4x8_12bit(int *a1, uint64_t *a2, int a3)
{
  uint64_t i;
  uint64_t v6;
  _BYTE v8[128];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  basic_idct_s1_12bit(a1, (uint64_t)v8);
  for (i = 0; i != 128; i += 32)
  {
    v6 = *a2++;
    *(_OWORD *)(v6 + a3) = *(_OWORD *)&v8[i];
  }
  return 16;
}

uint64_t aj_idct_s2_12bit(int32x4_t *a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  __int16 v28;
  __int16 *v29;
  unsigned int v30;
  __int16 v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  __int16 v35;
  int v36;
  unsigned int v37;
  __int16 v38;
  _QWORD v40[4];
  _OWORD v41[4];
  uint64_t v42;

  v3 = 0;
  v42 = *MEMORY[0x24BDAC8D0];
  v4 = a2[1] + a3;
  v40[0] = *a2 + a3;
  v40[1] = v4;
  v5 = a2[3] + a3;
  v40[2] = a2[2] + a3;
  v40[3] = v5;
  v6 = a1[4];
  v7 = vaddq_s32(v6, *a1);
  v8 = vsubq_s32(*a1, v6);
  v9 = a1[2];
  v10 = a1[6];
  v11.i64[0] = 0x400000004000;
  v11.i64[1] = 0x400000004000;
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  v13 = vshrq_n_s32(vmlaq_s32(v12, vaddq_s32(v10, v9), vdupq_n_s32(0x4546u)), 0xFuLL);
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  v14 = vmlaq_s32(v12, v9, vdupq_n_s32(0x61F8u));
  v15 = vsubq_s32(v13, vsraq_n_s32(v10, vmlaq_s32(v11, v10, vdupq_n_s32(0x6C83u)), 0xFuLL));
  v16 = vsraq_n_s32(v13, v14, 0xFuLL);
  v41[0] = vaddq_s32(v16, v7);
  v41[1] = vaddq_s32(v15, v8);
  v17 = (int *)v41 + 2;
  v41[2] = vsubq_s32(v8, v15);
  v41[3] = vsubq_s32(v7, v16);
  do
  {
    v18 = *(v17 - 2);
    v19 = *(v17 - 1);
    v20 = *v17;
    v21 = v17[1];
    v17 += 4;
    v22 = v20 + v18;
    v23 = v18 - v20;
    v24 = (17734 * (v21 + v19) + 0x4000) >> 15;
    v25 = v24 + ((25080 * v19 + 0x4000) >> 15);
    v26 = v24 - (v21 + ((27779 * v21 + 0x4000) >> 15));
    v27 = v25 + v22 + 16388;
    if (v25 + v22 <= -16389)
      v28 = 0;
    else
      v28 = 4095;
    if (v27 < 0x8000)
      v28 = v27 >> 3;
    v29 = (__int16 *)v40[v3];
    *v29 = v28;
    v30 = v26 + v23 + 16388;
    if (v26 + v23 <= -16389)
      v31 = 0;
    else
      v31 = 4095;
    if (v30 < 0x8000)
      v31 = v30 >> 3;
    v29[1] = v31;
    v32 = v23 - v26;
    v33 = v32 + 16388;
    v34 = (v32 + 16388) >> 3;
    if (v32 <= -16389)
      v35 = 0;
    else
      v35 = 4095;
    if (v33 < 0x8000)
      v35 = v34;
    v29[2] = v35;
    v36 = v22 - v25;
    v37 = v22 - v25 + 16388;
    if (v36 <= -16389)
      v38 = 0;
    else
      v38 = 4095;
    if (v37 < 0x8000)
      v38 = v37 >> 3;
    v29[3] = v38;
    v40[v3++] = v29 + 4;
  }
  while (v3 != 4);
  return 8;
}

uint64_t aj_idct_s2_2x4_12bit(int32x4_t *a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  char v8;
  char v9;
  int *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  __int16 v20;
  __int16 *v21;
  unsigned int v22;
  __int16 v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  __int16 v27;
  unsigned int v28;
  __int16 v29;
  _QWORD v31[4];
  _OWORD v32[2];
  uint64_t v33;

  v3 = 0;
  v33 = *MEMORY[0x24BDAC8D0];
  v4 = a2[1] + a3;
  v31[0] = *a2 + a3;
  v31[1] = v4;
  v5 = *a1;
  v6 = a1[2];
  v7 = vaddq_s32(v6, *a1);
  v8 = 1;
  v32[0] = v7;
  v32[1] = vsubq_s32(v5, v6);
  do
  {
    v9 = v8;
    v10 = (int *)&v32[v3];
    v11 = *v10;
    v12 = v10[1];
    v13 = v10[2];
    LODWORD(v10) = v10[3];
    v14 = v13 + v11;
    v15 = v11 - v13;
    v16 = (17734 * ((int)v10 + v12) + 0x4000) >> 15;
    v17 = v16 + ((25080 * v12 + 0x4000) >> 15);
    v18 = v16 - ((_DWORD)v10 + ((27779 * (int)v10 + 0x4000) >> 15));
    v19 = v17 + v14 + 16388;
    if (v17 + v14 <= -16389)
      v20 = 0;
    else
      v20 = 4095;
    if (v19 < 0x8000)
      v20 = v19 >> 3;
    v21 = (__int16 *)v31[v3];
    *v21 = v20;
    v22 = v18 + v15 + 16388;
    if (v18 + v15 <= -16389)
      v23 = 0;
    else
      v23 = 4095;
    if (v22 < 0x8000)
      v23 = v22 >> 3;
    v21[1] = v23;
    v24 = v15 - v18;
    v25 = v24 + 16388;
    v26 = (v24 + 16388) >> 3;
    if (v24 <= -16389)
      v27 = 0;
    else
      v27 = 4095;
    if (v25 < 0x8000)
      v27 = v26;
    v21[2] = v27;
    v28 = v14 - v17 + 16388;
    if (v14 - v17 <= -16389)
      v29 = 0;
    else
      v29 = 4095;
    if (v28 < 0x8000)
      v29 = v28 >> 3;
    v21[3] = v29;
    v31[v3] = v21 + 4;
    v3 = 1;
    v8 = 0;
  }
  while ((v9 & 1) != 0);
  return 8;
}

uint64_t aj_idct_s2_4x2_12bit(int32x4_t *a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  char *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  __int16 v27;
  __int16 *v28;
  int v29;
  int v30;
  unsigned int v31;
  __int16 v32;
  _QWORD v34[4];
  _OWORD v35[4];
  uint64_t v36;

  v3 = 0;
  v36 = *MEMORY[0x24BDAC8D0];
  v4 = a2[1] + a3;
  v34[0] = *a2 + a3;
  v34[1] = v4;
  v5 = a2[3] + a3;
  v34[2] = a2[2] + a3;
  v34[3] = v5;
  v6 = a1[4];
  v7 = vaddq_s32(v6, *a1);
  v8 = vsubq_s32(*a1, v6);
  v9 = a1[2];
  v10 = a1[6];
  v11.i64[0] = 0x400000004000;
  v11.i64[1] = 0x400000004000;
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  v13 = vshrq_n_s32(vmlaq_s32(v12, vaddq_s32(v10, v9), vdupq_n_s32(0x4546u)), 0xFuLL);
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  v14 = vmlaq_s32(v12, v9, vdupq_n_s32(0x61F8u));
  v15 = vsubq_s32(v13, vsraq_n_s32(v10, vmlaq_s32(v11, v10, vdupq_n_s32(0x6C83u)), 0xFuLL));
  v16 = vsraq_n_s32(v13, v14, 0xFuLL);
  v35[0] = vaddq_s32(v16, v7);
  v35[1] = vaddq_s32(v15, v8);
  v17 = (char *)v35 + 8;
  v35[2] = vsubq_s32(v8, v15);
  v35[3] = vsubq_s32(v7, v16);
  do
  {
    v18 = *((_DWORD *)v17 - 2);
    v19 = *((_DWORD *)v17 - 1);
    v20 = *((_DWORD *)v17 + 1);
    v17 += 16;
    v21 = (17734 * (v20 + v19) + 0x4000) >> 15;
    v22 = v21 + ((25080 * v19 + 0x4000) >> 15);
    v23 = v21 - (v20 + ((27779 * v20 + 0x4000) >> 15));
    v24 = v22 + 2 * v18 + v23;
    v25 = v24 + 2;
    if (v24 >= -1)
      v25 = v24 + 1;
    v26 = (v25 >> 1) + 16388;
    if (v24 <= -32779)
      v27 = 0;
    else
      v27 = 4095;
    if (v26 < 0x8000)
      v27 = v26 >> 3;
    v28 = (__int16 *)v34[v3];
    *v28 = v27;
    v29 = v18 - v23 + v18 - v22;
    v30 = v29 + 2;
    if (v29 >= -1)
      v30 = v29 + 1;
    v31 = (v30 >> 1) + 16388;
    if (v29 <= -32779)
      v32 = 0;
    else
      v32 = 4095;
    if (v31 < 0x8000)
      v32 = v31 >> 3;
    v28[1] = v32;
    v34[v3++] = v28 + 2;
  }
  while (v3 != 4);
  return 4;
}

uint64_t aj_idct_s4_12bit(_DWORD *a1, _QWORD *a2, int a3)
{
  _WORD *v3;
  __int16 *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  __int16 v13;
  __int16 v14;
  unsigned int v15;
  __int16 v16;
  int v17;
  unsigned int v18;
  __int16 v19;
  int v20;
  unsigned int v21;
  __int16 v22;

  v3 = (_WORD *)(*a2 + a3);
  v4 = (__int16 *)(a2[1] + a3);
  v5 = a1[1];
  v6 = v5 + *a1;
  v7 = *a1 - v5;
  v8 = a1[8];
  v9 = a1[9];
  v10 = v9 + v8;
  v11 = v8 - v9;
  v12 = v10 + v6 + 16388;
  if (v10 + v6 <= -16389)
    v13 = 0;
  else
    v13 = 4095;
  if (v12 >= 0x8000)
    v14 = v13;
  else
    v14 = v12 >> 3;
  *v3 = v14;
  v15 = v11 + v7 + 16388;
  if (v11 + v7 <= -16389)
    v16 = 0;
  else
    v16 = 4095;
  if (v15 < 0x8000)
    v16 = v15 >> 3;
  v3[1] = v16;
  v17 = v6 - v10;
  v18 = v6 - v10 + 16388;
  if (v17 <= -16389)
    v19 = 0;
  else
    v19 = 4095;
  if (v18 < 0x8000)
    v19 = v18 >> 3;
  *v4 = v19;
  v20 = v7 - v11;
  v21 = v7 - v11 + 16388;
  if (v20 <= -16389)
    v22 = 0;
  else
    v22 = 4095;
  if (v21 < 0x8000)
    v22 = v21 >> 3;
  v4[1] = v22;
  return 4;
}

uint64_t aj_idct_s4_1x2_12bit(int32x2_t *a1, _QWORD *a2, int a3)
{
  int32x4_t v3;
  _WORD *v4;
  int32x2_t v5;
  int32x2_t v6;
  int v7;
  __int16 v8;
  __int16 v9;
  int v10;
  __int16 v11;

  *(int32x2_t *)v3.i8 = *a1;
  v4 = (_WORD *)(*a2 + a3);
  v5 = vsub_s32(*a1, vdup_lane_s32(*a1, 1));
  v6 = vsub_s32(a1[4], vdup_lane_s32(a1[4], 1));
  v3.u64[1] = (unint64_t)a1[4];
  v7 = vaddvq_s32(v3);
  if (v7 <= -16389)
    v8 = 0;
  else
    v8 = 4095;
  if ((v7 + 16388) >= 0x8000)
    v9 = v8;
  else
    v9 = (v7 + 16388) >> 3;
  *v4 = v9;
  v10 = vadd_s32(v6, v5).u32[0];
  if (v10 <= -16389)
    v11 = 0;
  else
    v11 = 4095;
  if ((v10 + 16388) < 0x8000)
    v11 = (v10 + 16388) >> 3;
  v4[1] = v11;
  return 4;
}

uint64_t aj_idct_s4_2x1_12bit(int *a1, _QWORD *a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  __int16 v14;
  __int16 v15;
  int v16;
  int v17;
  unsigned int v18;
  __int16 v19;

  v3 = a2[1];
  v4 = *a1;
  v5 = a1[1];
  v6 = v5 + *a1;
  v7 = a1[8];
  v8 = a1[9];
  v9 = v8 + v7;
  v10 = v7 - v8;
  v11 = v9 + 2 * *a1 + v10;
  v12 = v11 + 2;
  if (v11 >= -1)
    v12 = v11 + 1;
  v13 = (v12 >> 1) + 16388;
  if (v11 <= -32779)
    v14 = 0;
  else
    v14 = 4095;
  if (v13 >= 0x8000)
    v15 = v14;
  else
    v15 = v13 >> 3;
  *(_WORD *)(*a2 + a3) = v15;
  v16 = v6 - v9 + v4 - v5 - v10;
  v17 = v16 + 2;
  if (v16 >= -1)
    v17 = v16 + 1;
  v18 = (v17 >> 1) + 16388;
  if (v16 <= -32779)
    v19 = 0;
  else
    v19 = 4095;
  if (v18 < 0x8000)
    v19 = v18 >> 3;
  *(_WORD *)(v3 + a3) = v19;
  return 2;
}

uint64_t aj_idct_s8_12bit(int *a1, _QWORD *a2, int a3)
{
  unsigned int v3;
  __int16 v4;

  v3 = *a1 + 16388;
  if (*a1 <= -16389)
    v4 = 0;
  else
    v4 = 4095;
  if (v3 < 0x8000)
    v4 = v3 >> 3;
  *(_WORD *)(*a2 + a3) = v4;
  return 2;
}

uint64_t idct_aan(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9)
{
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t result;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;

  v9 = a1[2];
  v10 = a1[3];
  v11 = a1[6];
  v12 = a1[7];
  v13 = v9 + v11;
  v14 = v9 - v11;
  v15 = a1[4];
  v16 = a1[5];
  v17 = a1[1];
  v18 = v15 + *a1;
  v19 = *a1 - v15;
  v20 = 23170 * v14 + 0x4000;
  v21 = v16 + v10;
  v22 = v16 - v10;
  v23 = v17 + 2 * v12;
  v24 = 17734 * v22 + 0x4000;
  v25 = v17 - 2 * v12;
  v26 = v23 + v21;
  v27 = v13 + (v20 >> 15);
  v28 = v27 + v18;
  v29 = 23170 * (v23 - v21) + 0x4000;
  v30 = (12540 * (v25 + v22) + 0x4000) >> 15;
  result = (v19 - (v20 >> 15));
  v32 = v19 + (v20 >> 15);
  v33 = v25 + ((10045 * v25 + 0x4000) >> 15) - v30;
  v34 = v30 + (v24 >> 15);
  v35 = v26 + v33;
  v36 = v33 + (v29 >> 15);
  *a2 = v35 + v27 + v18;
  *a3 = v36 + v32;
  v37 = v34 + (v29 >> 15);
  *a4 = v37 + result;
  v38 = v18 - v27;
  *a5 = v34 + v38;
  *a6 = v38 - v34;
  *a7 = result - v37;
  *a8 = v32 - v36;
  *a9 = v28 - v35;
  return result;
}

uint64_t aj_RGB888_YUV444(double a1, int64x2_t a2, int64x2_t a3, int64x2_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unsigned int a8, int a9)
{
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  unsigned int i;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int v20;
  int v21;
  int v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  uint64_t result;
  char v27;
  char v28;
  char v29;
  int8x8x3_t v30;

  v9 = *a6;
  v10 = *(_BYTE **)a7;
  v11 = *(_BYTE **)(a7 + 16);
  v12 = *(_BYTE **)(a7 + 32);
  v13.i64[0] = 0x80008000800080;
  v13.i64[1] = 0x80008000800080;
  v14 = vshlq_n_s16(v13, 7uLL);
  v15.i64[0] = 0x15980E984B232646;
  v15.i64[1] = 0xA6835982A68;
  for (i = a8 >> 3; i; --i)
  {
    v30 = vld3_s8((const char *)v9);
    v9 += 24;
    v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[0], 7uLL);
    v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[1], 7uLL);
    v19 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[2], 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v19, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v18, v15, 4)), vrshrq_n_s16(v19, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v17, 1uLL), vqrdmulhq_laneq_s16(v18, v15, 5)), vqrdmulhq_laneq_s16(v19, v15, 6)), v14), 7uLL);
    *(_QWORD *)v10 = a2.i64[0];
    v10 += 8;
    *(_QWORD *)v11 = a3.i64[0];
    v11 += 8;
    *(_QWORD *)v12 = a4.i64[0];
    v12 += 8;
  }
  v20 = a8 & 7;
  if ((a8 & 7) != 0)
  {
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      a2.i8[0] = *(_BYTE *)v9;
      a3.i8[0] = *(_BYTE *)(v9 + 1);
      a4.i8[0] = *(_BYTE *)(v9 + 2);
      v9 += 3;
      --v20;
    }
    while (v20);
    v21 = a8 & 7;
    v22 = 8 - v21;
    v23 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a2.i8, 7uLL);
    v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a3.i8, 7uLL);
    v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a4.i8, 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v24, v15, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v15, 5)), vqrdmulhq_laneq_s16(v25, v15, 6)), v14), 7uLL);
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v22;
    }
    while (v22);
    do
    {
      *v10++ = a2.i8[7];
      *v11++ = a3.i8[7];
      *v12++ = a4.i8[7];
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v21;
    }
    while (v21);
  }
  result = a9 - a8;
  if (a9 != a8)
  {
    v27 = *(v10 - 1);
    v28 = *(v11 - 1);
    v29 = *(v12 - 1);
    do
    {
      *v10++ = v27;
      *v11++ = v28;
      *v12++ = v29;
      result = (result - 1);
    }
    while ((_DWORD)result);
  }
  return result;
}

unint64_t aj_RGB888_YUV420(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4, size_t a5)
{
  int64x2_t v5;
  int64x2_t v6;
  int64x2_t v7;
  int64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  unint64_t result;
  const char *v12;
  const char *v13;
  int8x8_t *v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  unsigned int i;
  const char *v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  uint8x16_t v29;
  uint8x16_t v30;
  int8x8_t *v31;
  const char *v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint8x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  int16x8_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  unsigned int v59;
  __int8 v60;
  char v61;
  char v62;
  char v63;
  int8x8x3_t v66;
  int8x8x3_t v67;
  int8x8x3_t v68;
  int8x8x3_t v69;
  int8x8x3_t v70;

  if ((_DWORD)a1 == 1)
  {
    aj_RGB888_YUV422(a1, a2, a3, a4);
    return (unint64_t)memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    v12 = a2[1];
    v13 = *a2;
    v14 = *(int8x8_t **)a3;
    v15 = *(_BYTE **)(a3 + 8);
    v16 = *(_BYTE **)(a3 + 16);
    v17 = *(_BYTE **)(a3 + 32);
    v18.i64[0] = 0x80008000800080;
    v18.i64[1] = 0x80008000800080;
    v19 = vshlq_n_s16(v18, 7uLL);
    v20.i64[0] = 0x15980E984B232646;
    v20.i64[1] = 0xA6835982A68;
    for (i = a4 >> 4; i; --i)
    {
      v66 = vld3_s8(v13);
      v22 = v13 + 24;
      v68 = vld3_s8(v22);
      v13 = v22 + 24;
      v23 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[0], 7uLL);
      v24 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[1], 7uLL);
      v25 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[2], 7uLL);
      v66.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v66.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v24, v20, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
      v66.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v20, 5)), vqrdmulhq_laneq_s16(v25, v20, 6)), v19), 7uLL);
      v26 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[0], 7uLL);
      v27 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[1], 7uLL);
      v28 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[2], 7uLL);
      v29.i64[0] = (uint64_t)v66.val[1];
      v29.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v27, v20, 4)), vrshrq_n_s16(v28, 1uLL)), 7uLL);
      v30.i64[0] = (uint64_t)v66.val[2];
      v30.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v26, 1uLL), vqrdmulhq_laneq_s16(v27, v20, 5)), vqrdmulhq_laneq_s16(v28, v20, 6)), v19), 7uLL);
      *v14 = v66.val[0];
      v31 = v14 + 1;
      *v31 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v27, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v28, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v14 = v31 + 1;
      v67 = vld3_s8(v12);
      v32 = v12 + 24;
      v69 = vld3_s8(v32);
      v12 = v32 + 24;
      v33 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[0], 7uLL);
      v34 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[1], 7uLL);
      v35 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[2], 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v34, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v35, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v67.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v34, v20, 4)), vrshrq_n_s16(v35, 1uLL)), 7uLL);
      v67.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v33, 1uLL), vqrdmulhq_laneq_s16(v34, v20, 5)), vqrdmulhq_laneq_s16(v35, v20, 6)), v19), 7uLL);
      v36 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[0], 7uLL);
      v37 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[1], 7uLL);
      v38 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v37, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v38, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v37, v20, 4)), vrshrq_n_s16(v38, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v36, 1uLL), vqrdmulhq_laneq_s16(v37, v20, 5)), vqrdmulhq_laneq_s16(v38, v20, 6)), v19), 7uLL);
      *(_QWORD *)v15 = v5.i64[0];
      v39 = v15 + 8;
      *v39 = v8.i64[0];
      v15 = v39 + 1;
      v40 = v9.i64[0];
      v41 = v10.i64[0];
      v6 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[1].i8), (int16x8_t)vpaddlq_u8(v29));
      v7 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[2].i8), (int16x8_t)vpaddlq_u8(v30));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(_QWORD *)v16 = v6.i64[0];
      v16 += 8;
      *(_QWORD *)v17 = v7.i64[0];
      v17 += 8;
    }
    if ((a4 & 8) != 0)
    {
      *(int8x8x3_t *)((char *)&v6 - 8) = vld3_s8(v13);
      v13 += 24;
      v70 = vld3_s8(v12);
      v12 += 24;
      v43 = (int16x8_t)vshll_n_u8(v42, 7uLL);
      v44 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      v45 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v44, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v45, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v44, v20, 4)), vrshrq_n_s16(v45, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v43, 1uLL), vqrdmulhq_laneq_s16(v44, v20, 5)), vqrdmulhq_laneq_s16(v45, v20, 6)), v19), 7uLL);
      v46 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[0], 7uLL);
      v47 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[1], 7uLL);
      v48 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v47, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v48, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *v14++ = *(int8x8_t *)v5.i8;
      *(_QWORD *)v15 = v8.i64[0];
      v15 += 8;
      *(uint16x4_t *)v9.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v47, v20, 4)), vrshrq_n_s16(v48, 1uLL)), 7uLL));
      *(uint16x4_t *)v10.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v46, 1uLL), vqrdmulhq_laneq_s16(v47, v20, 5)), vqrdmulhq_laneq_s16(v48, v20, 6)), v19), 7uLL));
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), *(int16x4_t *)v9.i8);
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), *(int16x4_t *)v10.i8);
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(_DWORD *)v16 = v6.i32[0];
      v16 += 4;
      *(_DWORD *)v17 = v7.i32[0];
      v17 += 4;
    }
    v49 = a4 & 7;
    if ((a4 & 7) != 0)
    {
      do
      {
        v5 = vshlq_n_s64(v5, 8uLL);
        v6 = vshlq_n_s64(v6, 8uLL);
        v7 = vshlq_n_s64(v7, 8uLL);
        v8 = vshlq_n_s64(v8, 8uLL);
        v9 = vshlq_n_s64(v9, 8uLL);
        v10 = vshlq_n_s64(v10, 8uLL);
        v5.i8[0] = *v13;
        v6.i8[0] = v13[1];
        v7.i8[0] = v13[2];
        v13 += 3;
        v8.i8[0] = *v12;
        v9.i8[0] = v12[1];
        v10.i8[0] = v12[2];
        v12 += 3;
        --v49;
      }
      while (v49);
      v50 = a4 & 7;
      v51 = 8 - v50;
      v52 = (v50 + 1) >> 1;
      v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v54, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v55, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v54, v20, 4)), vrshrq_n_s16(v55, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v53, 1uLL), vqrdmulhq_laneq_s16(v54, v20, 5)), vqrdmulhq_laneq_s16(v55, v20, 6)), v19), 7uLL);
      v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v8.i8, 7uLL);
      v57 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
      v58 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v57, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v58, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v57, v20, 4)), vrshrq_n_s16(v58, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v56, 1uLL), vqrdmulhq_laneq_s16(v57, v20, 5)), vqrdmulhq_laneq_s16(v58, v20, 6)), v19), 7uLL);
      do
      {
        v5 = vsliq_n_s64(v5, v5, 8uLL);
        v6 = vsliq_n_s64(v6, v6, 8uLL);
        v7 = vsliq_n_s64(v7, v7, 8uLL);
        v8 = vsliq_n_s64(v8, v8, 8uLL);
        v9 = vsliq_n_s64(v9, v9, 8uLL);
        v10 = vsliq_n_s64(v10, v10, 8uLL);
        --v51;
      }
      while (v51);
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v9.i8));
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v10.i8));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      do
      {
        v14->i8[0] = v5.i8[7];
        v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v8.i8[7];
        v5 = vshlq_n_s64(v5, 8uLL);
        v8 = vshlq_n_s64(v8, 8uLL);
        --v50;
      }
      while (v50);
      do
      {
        *v16++ = v6.i8[3];
        *v17++ = v7.i8[3];
        v6 = vshlq_n_s64(v6, 8uLL);
        v7 = vshlq_n_s64(v7, 8uLL);
        --v52;
      }
      while (v52);
    }
    result = a5 - a4;
    if ((_DWORD)a5 != a4)
    {
      v59 = result >> 1;
      v60 = v14[-1].i8[7];
      v61 = *(v15 - 1);
      v62 = *(v16 - 1);
      v63 = *(v17 - 1);
      do
      {
        v14->i8[0] = v60;
        v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v61;
        result = (result - 1);
      }
      while ((_DWORD)result);
      for (; v59; --v59)
      {
        *v16++ = v62;
        *v17++ = v63;
      }
    }
  }
  return result;
}

uint64_t handle_suspension(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, int *a5, int a6, int a7, int a8, unsigned int a9)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v14;
  uint64_t v15;
  uint64_t result;

  if (!a2)
    return 7;
  v9 = *(_QWORD *)(a3 + 104);
  v10 = v9 - *(_QWORD *)(a4 + 104);
  v11 = *(_DWORD *)(a4 + 48);
  v12 = *(_DWORD *)(a3 + 48);
  if ((_DWORD)v9 != *(_DWORD *)(a4 + 104) || v11 != v12)
  {
    v14 = v11 - v12;
    *(_QWORD *)(a3 + 104) = v9 - (int)v10;
    v15 = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a3 + 8) -= (int)v10;
    if (v15)
      *(_QWORD *)(a3 + 16) = v15 - (int)v10;
    *(_DWORD *)(a3 + 48) = v11;
    *(_DWORD *)(a3 + 32) += v14;
    return 4294967294;
  }
  if (*(_DWORD *)(a3 + 32) + *(_DWORD *)(a3 + 8) - *(_DWORD *)(a3 + 40) != *(_DWORD *)(a3 + 36))
    return 4294967294;
  *(_QWORD *)(a3 + 104) = 0;
  result = aj_istream_move_to_position(a3, a9);
  if (!(_DWORD)result)
  {
    result = add_segment_info(a1, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return 4294967294;
  }
  return result;
}

uint64_t aj_rowbuffer_retain_count(unsigned int *a1, unint64_t a2)
{
  unsigned __int8 *rowbuffer_for_pointer;

  rowbuffer_for_pointer = (unsigned __int8 *)find_rowbuffer_for_pointer(a1, a2);
  if (rowbuffer_for_pointer)
    return *rowbuffer_for_pointer;
  aj_log_error(0, "Requesting retain count for a pointer that is not in the list\n");
  return 0xFFFFFFFFLL;
}

unint64_t aj_rowbuffer_lock_buffer(unsigned int *a1, unint64_t a2)
{
  _BYTE *rowbuffer_for_pointer;

  rowbuffer_for_pointer = (_BYTE *)find_rowbuffer_for_pointer(a1, a2);
  if (rowbuffer_for_pointer)
    ++*rowbuffer_for_pointer;
  return a2;
}

BOOL applejpeg_reduce_is_reduced_jpeg(_DWORD *a1, unint64_t a2)
{
  return a2 >= 4 && *a1 == 1196444242;
}

BOOL *applejpeg_reduce_open_file(_QWORD *a1, unint64_t a2, uint64_t a3, int *a4)
{
  return reduce_open(a1, a2, 0, a3, a4);
}

BOOL *reduce_open(_QWORD *a1, unint64_t a2, uint64_t *a3, uint64_t a4, int *a5)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  BOOL *v13;
  BOOL *v14;
  __int128 v15;
  unint64_t v16;
  double inited;
  uint64_t v18;
  int v19;
  int v20;
  BOOL v22;
  int v23;
  _OWORD *v24;
  int v25;
  _OWORD *v26;
  _BOOL4 v27;
  uint64_t v28;
  int v29;
  int v30;
  int __dst;

  __dst = 0;
  if (a2 && a3)
  {
    aj_log_error((uint64_t)"Reduce", "Cannot have both file input AND memory input");
LABEL_36:
    v14 = 0;
    goto LABEL_37;
  }
  if (!(a2 | (unint64_t)a3))
  {
    aj_log_error((uint64_t)"Reduce", "Input cannot be NULL");
    goto LABEL_36;
  }
  if (a2)
  {
    if (!*(_QWORD *)a2 || !*(_QWORD *)(a2 + 16))
    {
      aj_log_error((uint64_t)"Reduce", "Read/Skip callback is missing");
      goto LABEL_36;
    }
    v10 = *(_QWORD *)(a2 + 40);
    if (v10)
    {
      if (v10 <= 0xFFF)
      {
        aj_log_error((uint64_t)"Reduce", "The read buffer size must be larger than %d");
        goto LABEL_36;
      }
      if (v10 >> 31)
      {
        aj_log_error((uint64_t)"Reduce", "The read buffer size can't be larger than %d");
        goto LABEL_36;
      }
    }
    v12 = *(_QWORD *)(a2 + 48);
    if (v12 >> 31)
    {
      aj_log_error((uint64_t)"Reduce", "The file size can't be larger than %d");
      goto LABEL_36;
    }
    if (!v12)
    {
      aj_log_error((uint64_t)"Reduce", "The file size may not be zero");
      goto LABEL_36;
    }
  }
  else
  {
    if (!*a3 || (v11 = a3[1]) == 0)
    {
      aj_log_error((uint64_t)"Reduce", "NULL fields in the memory input struct not allowed");
      goto LABEL_36;
    }
    if (v11 >> 31)
    {
      aj_log_error((uint64_t)"Reduce", "The input buffer size can't be larger than %d");
      goto LABEL_36;
    }
  }
  v13 = (BOOL *)((uint64_t (*)(uint64_t, _QWORD))*a1)(160576, a1[2]);
  v14 = v13;
  if (!v13)
  {
    aj_log_error((uint64_t)"Reduce", "Unable to allocate memory");
    v18 = 0;
    goto LABEL_28;
  }
  bzero(v13, 0x27340uLL);
  v15 = *(_OWORD *)a1;
  *((_QWORD *)v14 + 20063) = a1[2];
  *(_OWORD *)(v14 + 160488) = v15;
  *((_QWORD *)v14 + 20064) = v14 + 160488;
  if (a2)
  {
    if (!*(_QWORD *)(a2 + 24))
    {
      aj_log_error((uint64_t)"Reduce", "No rewind callback specified", *(double *)&v15);
      goto LABEL_37;
    }
    v16 = *(_QWORD *)(a2 + 48);
    inited = aj_istream_init_file((uint64_t)(v14 + 152136), (_QWORD *)a2, (uint64_t)(v14 + 156352), 4096, 0, 0);
  }
  else
  {
    v16 = a3[1];
    inited = aj_istream_init_mem((uint64_t)(v14 + 152136), a3, 0, 0);
  }
  if (v16 <= 0x2E)
  {
    aj_log_error((uint64_t)"Reduce", "File/buffer size is too small to fit image", inited);
LABEL_37:
    v18 = 0;
    v19 = 8;
    goto LABEL_38;
  }
  v20 = aj_istream_peek_bytes((uint64_t)(v14 + 152136), &__dst, 4);
  if (v20)
    goto LABEL_33;
  v22 = __dst == 1196444242;
  if (__dst == 1196444242)
  {
    v20 = aj_istream_move_to_position((uint64_t)(v14 + 152136), 4);
    if (v20)
    {
LABEL_33:
      v19 = v20;
LABEL_34:
      v18 = 0;
      goto LABEL_38;
    }
    v23 = parse_reduced_file((uint64_t)(v14 + 152136), (char *)v14);
    if (v23)
    {
      v19 = v23;
      aj_log_error((uint64_t)"Reduce", "Error %d while parsing RJPEG headers", v23);
      goto LABEL_34;
    }
    *v14 = v22;
    if (a4)
    {
      *(_BYTE *)a4 = v22;
      v27 = v14[10];
      v28 = *((unsigned int *)v14 + 11);
      v29 = *((unsigned __int16 *)v14 + 7);
      v30 = *((unsigned __int16 *)v14 + 6);
      goto LABEL_59;
    }
    goto LABEL_60;
  }
  if (a2)
  {
    (*((void (**)(_QWORD))v14 + 19028))(*((_QWORD *)v14 + 19025));
    v24 = applejpeg_decode_create(a1);
    v18 = (uint64_t)v24;
    if (v24)
    {
      v25 = applejpeg_decode_open_file((uint64_t)v24, a2, 0);
      goto LABEL_52;
    }
LABEL_28:
    v19 = 6;
LABEL_38:
    if (a5)
      *a5 = v19;
    applejpeg_decode_destroy((_QWORD *)v18);
    applejpeg_reduce_close(v14);
    return 0;
  }
  v26 = applejpeg_decode_create(a1);
  v18 = (uint64_t)v26;
  if (!v26)
    goto LABEL_28;
  v25 = applejpeg_decode_open_mem((uint64_t)v26, a3);
LABEL_52:
  v19 = v25;
  if (v25)
  {
    aj_log_error((uint64_t)"Reduce", "Decode open failed");
    goto LABEL_38;
  }
  if (!can_jpeg_be_reduced(v18))
  {
    v19 = 3;
    goto LABEL_38;
  }
  *((_QWORD *)v14 + 17732) = v18;
  *v14 = v22;
  if (a4)
  {
    v27 = 0;
    v28 = 0;
    *(_BYTE *)a4 = v22;
    v29 = *(_DWORD *)(v18 + 152);
    v30 = *(_DWORD *)(v18 + 156);
LABEL_59:
    *(_DWORD *)(a4 + 4) = v27;
    *(_QWORD *)(a4 + 8) = v28;
    *(_DWORD *)(a4 + 16) = v29;
    *(_DWORD *)(a4 + 20) = v30;
    *(_DWORD *)(a4 + 24) = 0;
  }
LABEL_60:
  if (a5)
    *a5 = 0;
  return v14;
}

BOOL *applejpeg_reduce_open_mem(_QWORD *a1, uint64_t *a2, uint64_t a3, int *a4)
{
  return reduce_open(a1, 0, a2, a3, a4);
}

uint64_t applejpeg_reduce_options_init(uint64_t result)
{
  *(_DWORD *)result = 0;
  *(_BYTE *)(result + 4) = 0;
  return result;
}

uint64_t applejpeg_reduce_set_options(uint64_t a1, uint64_t a2)
{
  int v3;

  if (*(_BYTE *)a1)
    return 0;
  if (*(_DWORD *)a2)
  {
    if (*(_DWORD *)a2 != 1)
    {
      aj_log_error((uint64_t)"Reduce", "Unsupported compression option");
      return 3;
    }
    v3 = 3;
  }
  else
  {
    v3 = 2;
  }
  *(_DWORD *)(a1 + 4) = v3;
  if (!*(_BYTE *)(a2 + 4))
    return 0;
  return 3;
}

uint64_t applejpeg_reduce_pack_file(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  if (!a2 || !(*(_QWORD *)(a2 + 40) >> 31))
    return reduce_pack(a1, a2, 0, a3);
  aj_log_error((uint64_t)"Reduce", "File write buffer size may not be larger than %d", 0x7FFFFFFF);
  return 8;
}

uint64_t reduce_pack(uint64_t a1, unint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v8;
  _QWORD *v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t (*v18)(int, _QWORD *);
  uint64_t (*v19)(uint64_t);
  uint64_t (*v20)(void *, int, uint64_t);
  int v21;
  int v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  double v26;
  uint64_t v27;
  double v28;
  unsigned __int8 *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  _QWORD v34[2];
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t (*v39)(void *, int, uint64_t);
  uint64_t (*v40)(uint64_t);
  uint64_t (*v41)(int, _QWORD *);
  uint64_t v42;

  v42 = 0;
  if (!a1 || !(a2 | a3) || !a4)
  {
    aj_log_error((uint64_t)"Reduce", "Input arguments may not be null");
    return 8;
  }
  if (*(_BYTE *)a1)
  {
    aj_log_error((uint64_t)"Reduce", "Input is already packed");
    return 8;
  }
  v10 = (_QWORD *)(a1 + 134984);
  v11 = *(_QWORD *)(a1 + 141856);
  if (!v11)
  {
    aj_log_error((uint64_t)"Reduce", "Reducer session object is corrupt");
    return 8;
  }
  v12 = (_DWORD *)(a1 + 160472);
  if (a2 && (v13 = *(_QWORD *)(a2 + 40)) != 0)
  {
    if (*(_QWORD *)(a1 + 160552))
    {
      (*(void (**)(_QWORD, _QWORD))(a1 + 160496))(*(_QWORD *)(a1 + 160552), *(_QWORD *)(a1 + 160504));
      v13 = *(_QWORD *)(a2 + 40);
    }
    v14 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))(a1 + 160488))(v13, *(_QWORD *)(a1 + 160504));
    *(_QWORD *)(a1 + 160552) = v14;
    if (!v14 || (bzero(v14, *(_QWORD *)(a2 + 40)), (v15 = *(_QWORD *)(a1 + 160552)) == 0))
    {
      aj_log_error((uint64_t)"Reduce", "Could not allocate memory for write buffer");
      return 6;
    }
    v16 = *(_DWORD *)(a2 + 40);
  }
  else
  {
    v15 = a1 + 152256;
    v16 = 4096;
  }
  if (a3)
  {
    v17 = a1 + 160448;
    *(_OWORD *)(a1 + 160448) = *(_OWORD *)a3;
    *v12 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)(a1 + 160464) = *(_QWORD *)a3;
    v18 = red_mem_skip_callback;
    v19 = red_mem_rewind_callback;
    v20 = red_mem_write_callback;
  }
  else
  {
    v20 = *(uint64_t (**)(void *, int, uint64_t))(a2 + 8);
    v18 = *(uint64_t (**)(int, _QWORD *))(a2 + 16);
    v19 = *(uint64_t (**)(uint64_t))(a2 + 24);
    v17 = *(_QWORD *)(a2 + 32);
  }
  v39 = v20;
  v40 = v19;
  v41 = v18;
  LODWORD(v42) = v16;
  v37 = v15;
  v38 = v17;
  v34[0] = 0;
  v34[1] = v15;
  v35 = 0;
  v36 = v16;
  if (!v19 || !v18)
  {
    aj_log_error((uint64_t)"Reduce", "Cannot use pack without rewind and skip callbacks");
    return 8;
  }
  *v10 = v34;
  v21 = *(_DWORD *)(v11 + 76);
  *(_WORD *)(a1 + 8) = 47;
  *(_BYTE *)(a1 + 10) = 1;
  *(_WORD *)(a1 + 12) = *(_DWORD *)(v11 + 156);
  *(_WORD *)(a1 + 14) = *(_DWORD *)(v11 + 152);
  *(_WORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 44) = v21;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  v22 = *(unsigned __int8 *)(a1 + 4);
  *(_WORD *)(a1 + 64) = 9;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 72) = 1;
  *(_BYTE *)(a1 + 74) = v22;
  if (v22 == 3)
  {
    aj_select_semistatic_coder((uint64_t (**)(int))(a1 + 141864));
  }
  else
  {
    if (v22 != 2)
      return 5;
    aj_select_adaptive_coder((uint64_t (**)(int))(a1 + 141864));
  }
  *(_QWORD *)(v11 + 4200) = v11 + 3744;
  *(_QWORD *)&v24 = aj_reduce_init_pack(a1 + 160512, (int *)(a1 + 104), v11 + 4192, (unsigned int **)(v11 + 3744), v11 + 11168, (unsigned int *)(v11 + 144), v11 + 24, v11, a1 + 141864).n128_u64[0];
  if ((_DWORD)v23)
  {
    v8 = v23;
    aj_log_error((uint64_t)"Reduce", "Failed to initialize reducer for packing", v24);
    return v8;
  }
  v25 = write_pre_rimg_headers(a1, v11 + 24, (uint64_t)v34);
  if ((_DWORD)v25)
  {
    v8 = v25;
    aj_log_error((uint64_t)"Reduce", "Failed to write pre RIMG headers", v26);
    return v8;
  }
  *(_QWORD *)(a1 + 88) = v35;
  v27 = write_rimg_segment_and_data(a1, v11, v11 + 4192, (uint64_t)v34);
  if ((_DWORD)v27)
  {
    v8 = v27;
    aj_log_error((uint64_t)"Reduce", "Failed to write RIMG segment and data", v28);
    return v8;
  }
  v29 = *(unsigned __int8 **)(v11 + 40);
  if (!v29 || *v29 != 217)
  {
    aj_log_error((uint64_t)"Reduce", "No EOI marker in image");
    return 7;
  }
  v30 = *(_DWORD *)(v11 + 48);
  if (v30 != -9 && *(_DWORD *)(v11 + 24) != ~(-1 << (v30 + 9)) << (23 - v30))
  {
    aj_log_error((uint64_t)"Reduce", "Padding before EOI not all ones, dbits is 0x%08X, expected 0x%08X");
    return 7;
  }
  v8 = aj_ostream_write_bytes((uint64_t)v34, 65497, 2);
  if (!(_DWORD)v8)
  {
    *(_QWORD *)(v11 + 40) = 0;
    v31 = applejpeg_decode_get_bytes_read(v11);
    v32 = *(_DWORD *)(v11 + 76);
    if (v31 == v32
      || (v33 = applejpeg_decode_get_bytes_read(v11),
          *(_QWORD *)(a1 + 96) = v35,
          v8 = write_rblob_segment_and_data((unsigned __int16 *)(a1 + 76), v11 + 24, (uint64_t)v34, v32 - v33),
          !(_DWORD)v8))
    {
      v8 = aj_ostream_write_bytes((uint64_t)v34, 65455, 2);
      if (!(_DWORD)v8)
      {
        v8 = aj_ostream_flush_buffer((uint64_t)v34);
        if (!(_DWORD)v8)
        {
          *a4 = v35;
          return finalize_rjpeg_header((unsigned int *)a1, (uint64_t)v34);
        }
      }
    }
  }
  return v8;
}

uint64_t applejpeg_reduce_pack_mem(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2 || !(*(_QWORD *)(a2 + 8) >> 31))
    return reduce_pack(a1, 0, a2, a3);
  aj_log_error((uint64_t)"Reduce", "Destination buffer size may not be larger than %d", 0x7FFFFFFF);
  return 8;
}

uint64_t applejpeg_reduce_unpack_file(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  if (!a2 || !(*(_QWORD *)(a2 + 40) >> 31))
    return reduce_unpack(a1, a2, 0, a3);
  aj_log_error((uint64_t)"Reduce", "File write buffer size may not be larger than %d", 0x7FFFFFFF);
  return 8;
}

uint64_t reduce_unpack(uint64_t a1, unint64_t a2, uint64_t a3, _DWORD *a4)
{
  _QWORD *v8;
  uint64_t v9;
  void *v10;
  int32x2_t v11;
  int v12;
  uint64_t (*v13)(int, _QWORD *);
  uint64_t (*v14)(void *, int, uint64_t);
  uint64_t v15;
  uint64_t (*v16)(uint64_t);
  uint64_t v17;
  char *v19;
  char *v20;
  int v21;
  _DWORD *v22;
  char *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  double inited;
  uint64_t sos;
  int pos;
  char v34;
  unint64_t v35;
  uint64_t i;
  char v37;
  char v38;
  int v39;
  int v40;
  int v41;
  int v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  int v47;
  uint64_t v48;
  int *v49;
  char *v50;
  int32x2_t v51[2];
  int v52;
  int v53;
  int32x2_t v54;
  uint64_t v55;
  uint64_t (*v56)(void *, int, uint64_t);
  uint64_t (*v57)(uint64_t);
  uint64_t (*v58)(int, _QWORD *);
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  unsigned __int16 v63;
  _OWORD v64[7];
  uint64_t v65;
  uint64_t __dst;
  int v67;
  char *v68;
  uint64_t v69;
  _DWORD v70[3];

  v59 = 0;
  if (!a1 || !(a2 | a3) || !a4)
  {
    aj_log_error((uint64_t)"Reduce", "Input arguments may not be null");
    return 8;
  }
  if (!*(_BYTE *)a1)
  {
    aj_log_error((uint64_t)"Reduce", "Input is not packed");
    return 8;
  }
  v8 = (_QWORD *)(a1 + 160464);
  if (a2)
  {
    v9 = *(_QWORD *)(a2 + 40);
    if (v9)
    {
      if (*(_QWORD *)(a1 + 160552))
      {
        (*(void (**)(_QWORD, _QWORD))(a1 + 160496))(*(_QWORD *)(a1 + 160552), *(_QWORD *)(a1 + 160504));
        v9 = *(_QWORD *)(a2 + 40);
      }
      v10 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))(a1 + 160488))(v9, *(_QWORD *)(a1 + 160504));
      *(_QWORD *)(a1 + 160552) = v10;
      if (!v10 || (bzero(v10, *(_QWORD *)(a2 + 40)), v11 = *(int32x2_t *)(a1 + 160552), !*(_QWORD *)&v11))
      {
        aj_log_error((uint64_t)"Reduce", "Could not allocate memory for write buffer");
        return 6;
      }
      v12 = *(_DWORD *)(a2 + 40);
      if (!a3)
        goto LABEL_12;
LABEL_17:
      v15 = a1 + 160448;
      *(_OWORD *)(a1 + 160448) = *(_OWORD *)a3;
      *(_DWORD *)(a1 + 160472) = *(_QWORD *)(a3 + 8);
      *v8 = *(_QWORD *)a3;
      v13 = red_mem_skip_callback;
      v16 = red_mem_rewind_callback;
      v14 = red_mem_write_callback;
      goto LABEL_18;
    }
  }
  v11 = (int32x2_t)(a1 + 152256);
  v12 = 4096;
  if (a3)
    goto LABEL_17;
LABEL_12:
  v14 = *(uint64_t (**)(void *, int, uint64_t))(a2 + 8);
  v13 = *(uint64_t (**)(int, _QWORD *))(a2 + 16);
  v16 = *(uint64_t (**)(uint64_t))(a2 + 24);
  v15 = *(_QWORD *)(a2 + 32);
LABEL_18:
  v56 = v14;
  v57 = v16;
  v58 = v13;
  LODWORD(v59) = v12;
  v54 = v11;
  v55 = v15;
  v51[0] = 0;
  v51[1] = v11;
  v52 = 0;
  v53 = v12;
  v68 = 0;
  v69 = 0;
  v67 = 0;
  __dst = 0;
  v63 = -40;
  v17 = aj_ostream_write_bytes((uint64_t)v51, 65496, 2);
  if ((_DWORD)v17)
    goto LABEL_19;
  v19 = (char *)(*(uint64_t (**)(uint64_t, _QWORD))(a1 + 160488))(65537, *(_QWORD *)(a1 + 160504));
  *(_QWORD *)(a1 + 160544) = v19;
  if (!v19)
  {
    v17 = 6;
    goto LABEL_19;
  }
  v20 = v19;
  v65 = 0;
  memset(v64, 0, sizeof(v64));
  bzero(v19, 0x10001uLL);
  v62 = 0;
  v60 = 0;
  v61 = 0;
  v17 = aj_istream_peek_short(a1 + 152136, &v63);
  if ((_DWORD)v17)
    goto LABEL_19;
  v47 = 0;
  v21 = 0;
  v50 = v20 + 2;
  v48 = 0;
  v49 = (int *)(a1 + 148264);
  v22 = (_DWORD *)(a1 + 68);
  v46 = (char *)(a1 + 64);
  v45 = (char *)(a1 + 72);
  v23 = (char *)(a1 + 73);
  v44 = (char *)(a1 + 74);
  while (1)
  {
    if (v63 != 255)
    {
      aj_log_error((uint64_t)"Reduce", "Expected 0xFF while parsing, got 0x%02X");
LABEL_106:
      v17 = 7;
      goto LABEL_19;
    }
    LODWORD(v61) = HIBYTE(v63);
    if ((_DWORD)v61 == 217 || HIBYTE(v63) == 175)
    {
      v62 = 0;
      HIDWORD(v60) = aj_istream_get_pos(a1 + 152136) + 2;
      v24 = aj_istream_move_to_position(a1 + 152136, HIDWORD(v60));
      if ((_DWORD)v24)
        goto LABEL_104;
    }
    else if (aj_get_segment_id_and_length(a1 + 152136, &v62, (_DWORD *)&v61 + 1, &v61, (_DWORD *)&v60 + 1, 1))
    {
      goto LABEL_109;
    }
    if ((int)v61 > 193)
    {
      switch((int)v61)
      {
        case 217:
          v24 = aj_ostream_write_bytes((uint64_t)v51, 65497, 2);
          if ((_DWORD)v24)
            goto LABEL_104;
          v24 = aj_ostream_flush_buffer((uint64_t)v51);
          if ((_DWORD)v24)
            goto LABEL_104;
          goto LABEL_94;
        case 218:
          aj_log_error((uint64_t)"Reduce", "Unexpected marker in reduced file");
          goto LABEL_106;
        case 219:
          v21 = 1;
          goto LABEL_55;
        case 220:
          break;
        case 221:
          goto LABEL_55;
        default:
          if ((_DWORD)v61 == 196)
          {
            v47 = 1;
            goto LABEL_55;
          }
          if ((_DWORD)v61 == 194)
          {
            aj_log_error((uint64_t)"Reduce", "Unreduce of progressive images not supported");
            goto LABEL_120;
          }
          break;
      }
LABEL_99:
      *v20 = -1;
      v20[1] = v61;
      v30 = aj_istream_memcpy(a1 + 152136, v50, v62, &v60);
      if (!(_DWORD)v30)
      {
        v42 = v62;
        if (v62 != (_DWORD)v60)
          goto LABEL_101;
LABEL_93:
        v24 = aj_ostream_write_buf((uint64_t)v51, v20, (v42 + 2));
        if ((_DWORD)v24)
          goto LABEL_104;
        goto LABEL_94;
      }
LABEL_107:
      v17 = v30;
LABEL_108:
      aj_log_error((uint64_t)"Reduce", "Error %d while copying headers to memory", v30);
      goto LABEL_19;
    }
    if ((int)v61 > 162)
    {
      switch((_DWORD)v61)
      {
        case 0xA3:
          LODWORD(v61) = 218;
          HIDWORD(v48) = 1;
          goto LABEL_55;
        case 0xC0:
          LODWORD(v48) = 1;
LABEL_55:
          *v20 = -1;
          v20[1] = v61;
          v30 = aj_istream_memcpy(a1 + 152136, v50, v62, &v60);
          if ((_DWORD)v30)
            goto LABEL_107;
          if (v62 == (_DWORD)v60)
          {
            v68 = v20 + 2;
            v69 = 0xFFFFLL;
            inited = aj_istream_init_mem((uint64_t)v64, (uint64_t *)&v68, 0, 0);
            if ((int)v61 > 217)
            {
              switch((_DWORD)v61)
              {
                case 0xDA:
                  sos = aj_read_sos((uint64_t)v64, v49);
                  break;
                case 0xDB:
                  sos = aj_read_dqt((uint64_t)v64, (uint64_t)v49);
                  break;
                case 0xDD:
                  sos = aj_read_dri((uint64_t)v64, (uint64_t)v49);
                  break;
                default:
LABEL_117:
                  aj_log_error((uint64_t)"Reduce", "Asked to parse unknown marker", inited);
                  v17 = 4;
                  goto LABEL_19;
              }
            }
            else if ((_DWORD)v61 == 192 || (_DWORD)v61 == 194)
            {
              sos = aj_read_sof((uint64_t)v64, (unsigned int *)v49, v61);
            }
            else
            {
              if ((_DWORD)v61 != 196)
                goto LABEL_117;
              sos = aj_read_dht((uint64_t)v64, (uint64_t)v49);
            }
            v17 = sos;
            if ((_DWORD)sos)
              goto LABEL_19;
            v24 = aj_check_huffman_tables((uint64_t)v49);
            if ((_DWORD)v24)
            {
LABEL_104:
              v17 = v24;
              goto LABEL_19;
            }
            v42 = v62;
            goto LABEL_93;
          }
LABEL_101:
          v17 = 9;
          goto LABEL_108;
        case 0xAF:
LABEL_109:
          v17 = 0;
          *a4 = v52;
          return v17;
      }
      goto LABEL_99;
    }
    if ((_DWORD)v61 == 161)
      break;
    if ((_DWORD)v61 != 162)
      goto LABEL_99;
    v70[0] = 0;
    v24 = aj_istream_memcpy(a1 + 152136, (char *)&__dst, 2, v70);
    if ((_DWORD)v24)
      goto LABEL_104;
    v25 = BYTE1(__dst);
    BYTE1(__dst) = __dst;
    LOBYTE(__dst) = v25;
    if ((unsigned __int16)__dst != 7)
    {
      aj_log_error((uint64_t)"Reduce", "Bad RBLOB segment length: %u");
      goto LABEL_122;
    }
    v70[0] = 0;
    v24 = aj_istream_memcpy(a1 + 152136, (char *)&__dst + 4, 4, v70);
    if ((_DWORD)v24)
      goto LABEL_104;
    v26 = 0;
    v27 = 0x300000000;
    do
    {
      v28 = *((_BYTE *)&__dst + v26 + 4) ^ *((_BYTE *)&__dst + HIDWORD(v27) + 4);
      *((_BYTE *)&__dst + v26 + 4) = v28;
      v29 = *((_BYTE *)&__dst + HIDWORD(v27) + 4) ^ v28;
      *((_BYTE *)&__dst + HIDWORD(v27) + 4) = v29;
      *((_BYTE *)&__dst + v26++ + 4) ^= v29;
      v27 -= 0x100000000;
    }
    while (v26 != 2);
    if (!HIDWORD(__dst))
    {
      aj_log_error((uint64_t)"Reduce", "Bad RBLOB data size: %u");
      goto LABEL_122;
    }
    v70[0] = 0;
    v24 = aj_istream_memcpy(a1 + 152136, (char *)&v67, 1, v70);
    if ((_DWORD)v24)
      goto LABEL_104;
    if ((_BYTE)v67)
    {
      aj_log_error((uint64_t)"Reduce", "RBLOB compression method unsupported: %u");
      goto LABEL_120;
    }
    v24 = copy_input_to_output(a1 + 152136, (uint64_t)v51, SHIDWORD(__dst));
    if ((_DWORD)v24)
      goto LABEL_104;
LABEL_94:
    v62 = 0;
    v60 = 0;
    v61 = 0;
    v24 = aj_istream_peek_short(a1 + 152136, &v63);
    if ((_DWORD)v24)
      goto LABEL_104;
  }
  if (!v47 || !v21 || !HIDWORD(v48) || !(_DWORD)v48)
  {
    aj_log_error((uint64_t)"Reduce", "File is missing SOF, DQT, DHT or RSOS. Cannot unpack.");
    goto LABEL_106;
  }
  v24 = aj_check_components_and_decimation(v49);
  if ((_DWORD)v24)
    goto LABEL_104;
  *(_QWORD *)(a1 + 88) = (int)(aj_istream_get_pos(a1 + 152136) - 2);
  pos = aj_istream_get_pos(a1 + 152136);
  v70[0] = 0;
  v24 = aj_istream_memcpy(a1 + 152136, v46, 2, v70);
  if ((_DWORD)v24)
    goto LABEL_104;
  v34 = *(_BYTE *)(a1 + 65);
  *(_BYTE *)(a1 + 65) = *(_BYTE *)(a1 + 64);
  *(_BYTE *)(a1 + 64) = v34;
  if (*(_WORD *)(a1 + 64) != 9)
  {
    aj_log_error((uint64_t)"Reduce", "Bad/unsupported RIMG segment length: %u");
    goto LABEL_120;
  }
  v70[0] = 0;
  v24 = aj_istream_memcpy(a1 + 152136, (char *)(a1 + 68), 4, v70);
  if ((_DWORD)v24)
    goto LABEL_104;
  v35 = 0x300000000;
  for (i = 68; i != 70; ++i)
  {
    v37 = *(_BYTE *)(a1 + i) ^ *((_BYTE *)v22 + HIDWORD(v35));
    *(_BYTE *)(a1 + i) = v37;
    v38 = *((_BYTE *)v22 + HIDWORD(v35)) ^ v37;
    *((_BYTE *)v22 + HIDWORD(v35)) = v38;
    *(_BYTE *)(a1 + i) ^= v38;
    v35 -= 0x100000000;
  }
  if (!*v22)
  {
    aj_log_error((uint64_t)"Reduce", "Bad RIMG data size: %u");
    goto LABEL_122;
  }
  v43 = v23;
  v70[0] = 0;
  v24 = aj_istream_memcpy(a1 + 152136, v45, 1, v70);
  if ((_DWORD)v24)
    goto LABEL_104;
  if (*v45 != 1)
  {
    aj_log_error((uint64_t)"Reduce", "Unsupported number of scans: %d");
    goto LABEL_120;
  }
  v70[0] = 0;
  v24 = aj_istream_memcpy(a1 + 152136, v23, 1, v70);
  if ((_DWORD)v24)
    goto LABEL_104;
  v70[0] = 0;
  v24 = aj_istream_memcpy(a1 + 152136, v44, 1, v70);
  if ((_DWORD)v24)
    goto LABEL_104;
  if ((*v44 & 0xFE) == 2)
  {
    v39 = pos + *(unsigned __int16 *)v46;
    if (v39 != aj_istream_get_pos(a1 + 152136))
    {
      aj_log_error((uint64_t)"Reduce", "Segment length did not match number of bytes read");
LABEL_122:
      v17 = 11;
      goto LABEL_19;
    }
    v24 = initialize_unreduce(a1, a1 + 152136);
    if ((_DWORD)v24)
      goto LABEL_104;
    v40 = aj_istream_get_pos(a1 + 152136);
    v41 = *(_DWORD *)(a1 + 68);
    v24 = unpack_rimg_data(a1, a1 + 148224, a1 + 152136, v51);
    if ((_DWORD)v24)
      goto LABEL_104;
    if (v41 + v40 != aj_istream_get_pos(a1 + 152136))
    {
      aj_istream_get_pos(a1 + 152136);
      aj_log_error((uint64_t)"Reduce", "RIMG size does not match amount of data read. Image is corrupt. (%d != %d)");
      goto LABEL_106;
    }
    v47 = 1;
    v48 = 0x100000001;
    v21 = 1;
    v23 = v43;
    goto LABEL_94;
  }
  aj_log_error((uint64_t)"Reduce", "RIMG compression scheme not supported: %u");
LABEL_120:
  v17 = 3;
LABEL_19:
  aj_log_error((uint64_t)"Reduce", "Unpacking of headers failed.");
  return v17;
}

uint64_t applejpeg_reduce_unpack_mem(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2 || !(*(_QWORD *)(a2 + 8) >> 31))
    return reduce_unpack(a1, 0, a2, a3);
  aj_log_error((uint64_t)"Reduce", "Destination buffer size may not be larger than %d", 0x7FFFFFFF);
  return 8;
}

_QWORD *applejpeg_reduce_close(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t (*v12)(_QWORD *, uint64_t);

  if (result)
  {
    v1 = result;
    v2 = result + 17732;
    v12 = (uint64_t (*)(_QWORD *, uint64_t))result[20062];
    v3 = result[20063];
    v4 = (_QWORD *)result[17732];
    if (v4)
    {
      applejpeg_decode_destroy(v4);
      *v2 = 0;
    }
    else
    {
      v5 = 0;
      v6 = 1;
      do
      {
        v7 = 0;
        v8 = v6;
        v9 = (uint64_t)&v1[v5 + 18962];
        do
        {
          if (!aj_huffman_decode_is_static_table(*(char **)(v9 + v7)))
          {
            v10 = *(_QWORD **)(v9 + v7);
            if (v10)
            {
              v12(v10, v3);
              *(_QWORD *)(v9 + v7) = 0;
            }
          }
          v7 += 16;
        }
        while (v7 != 64);
        v6 = 0;
        v5 = 1;
      }
      while ((v8 & 1) != 0);
    }
    v11 = v2 + 2334;
    do
    {
      if (*v11)
      {
        v12((_QWORD *)*v11, v3);
        *v11 = 0;
      }
      ++v11;
    }
    while (v11 < v1 + 20070);
    return (_QWORD *)v12(v1, v3);
  }
  return result;
}

uint64_t applejpeg_reduce_dump_contexts()
{
  return 3;
}

uint64_t parse_reduced_file(uint64_t a1, char *a2)
{
  uint64_t result;
  char v5;
  unsigned __int16 *v6;
  int pos;
  char v8;
  char v9;
  char v10;
  char v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  char v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  char v20;
  char v21;
  char v22;
  _DWORD *v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  char v27;
  uint64_t v28;
  char *v29;
  unsigned __int8 *v30;
  int v31;
  __int16 __dst;
  int v33;

  __dst = 0;
  v33 = 0;
  result = aj_istream_memcpy(a1, (char *)&__dst, 2, &v33);
  if ((_DWORD)result)
    return result;
  v5 = HIBYTE(__dst);
  HIBYTE(__dst) = __dst;
  LOBYTE(__dst) = v5;
  if (__dst != -96)
    return 4;
  v6 = (unsigned __int16 *)(a2 + 8);
  pos = aj_istream_get_pos(a1);
  v33 = 0;
  result = aj_istream_memcpy(a1, a2 + 8, 2, &v33);
  if ((_DWORD)result)
    return result;
  v8 = a2[9];
  a2[9] = a2[8];
  a2[8] = v8;
  if (*((_WORD *)a2 + 4) != 47)
    return 11;
  v33 = 0;
  result = aj_istream_memcpy(a1, a2 + 10, 1, &v33);
  if (!(_DWORD)result)
  {
    if (a2[10] > 1u)
      return 3;
    v33 = 0;
    result = aj_istream_memcpy(a1, a2 + 12, 2, &v33);
    if (!(_DWORD)result)
    {
      v9 = a2[13];
      a2[13] = a2[12];
      a2[12] = v9;
      v33 = 0;
      result = aj_istream_memcpy(a1, a2 + 14, 2, &v33);
      if (!(_DWORD)result)
      {
        v10 = a2[15];
        a2[15] = a2[14];
        a2[14] = v10;
        if (*((_WORD *)a2 + 7) && *((_WORD *)a2 + 6))
        {
          v33 = 0;
          result = aj_istream_memcpy(a1, a2 + 16, 2, &v33);
          if ((_DWORD)result)
            return result;
          v11 = a2[17];
          a2[17] = a2[16];
          a2[16] = v11;
          v33 = 0;
          result = aj_istream_memcpy(a1, a2 + 24, 8, &v33);
          if ((_DWORD)result)
            return result;
          v13 = 0;
          v14 = 0x700000000;
          v12 = a2 + 24;
          do
          {
            v15 = v12[v13] ^ v12[HIDWORD(v14)];
            v12[v13] = v15;
            v16 = v12[HIDWORD(v14)] ^ v15;
            v12[HIDWORD(v14)] = v16;
            v12[v13++] ^= v16;
            v14 -= 0x100000000;
          }
          while (v13 != 4);
          v33 = 0;
          result = aj_istream_memcpy(a1, a2 + 32, 8, &v33);
          if ((_DWORD)result)
            return result;
          v18 = 0;
          v19 = 0x700000000;
          v17 = a2 + 32;
          do
          {
            v20 = v17[v18] ^ v17[HIDWORD(v19)];
            v17[v18] = v20;
            v21 = v17[HIDWORD(v19)] ^ v20;
            v17[HIDWORD(v19)] = v21;
            v17[v18++] ^= v21;
            v19 -= 0x100000000;
          }
          while (v18 != 4);
          v33 = 0;
          result = aj_istream_memcpy(a1, a2 + 40, 2, &v33);
          if ((_DWORD)result)
            return result;
          v22 = a2[41];
          a2[41] = a2[40];
          a2[40] = v22;
          v33 = 0;
          result = aj_istream_memcpy(a1, a2 + 44, 4, &v33);
          if ((_DWORD)result)
            return result;
          v24 = 0;
          v25 = 0x300000000;
          v23 = a2 + 44;
          do
          {
            v26 = *((_BYTE *)v23 + v24) ^ *((_BYTE *)v23 + HIDWORD(v25));
            *((_BYTE *)v23 + v24) = v26;
            v27 = *((_BYTE *)v23 + HIDWORD(v25)) ^ v26;
            *((_BYTE *)v23 + HIDWORD(v25)) = v27;
            *((_BYTE *)v23 + v24++) ^= v27;
            v25 -= 0x100000000;
          }
          while (v24 != 2);
          if (*v23)
          {
            v28 = 0;
            v29 = a2 + 48;
            while (1)
            {
              v30 = (unsigned __int8 *)&v29[v28];
              v33 = 0;
              result = aj_istream_memcpy(a1, &v29[v28], 1, &v33);
              if ((_DWORD)result)
                break;
              if (*v30)
              {
                aj_log_error((uint64_t)"Reduce", "Unsupported capability flag: capability[%i] = 0x%02X", v28, *v30);
                return 3;
              }
              if (++v28 == 16)
              {
                v31 = pos + *v6;
                if (v31 == aj_istream_get_pos(a1))
                  return 0;
                aj_log_error((uint64_t)"Reduce", "Segment length did not match number of bytes read");
                return 11;
              }
            }
            return result;
          }
          aj_log_error((uint64_t)"Reduce", "Illegal original size: %u");
        }
        else
        {
          aj_log_error((uint64_t)"Reduce", "Illegal image dimensions: %dx%d");
        }
        return 11;
      }
    }
  }
  return result;
}

uint64_t can_jpeg_be_reduced(uint64_t a1)
{
  int v1;

  if ((*(_DWORD *)(a1 + 144) | 2) != 3)
    goto LABEL_8;
  v1 = *(_DWORD *)(a1 + 160);
  if (*(int *)(a1 + 176) > 2 || v1 >= 3)
  {
    aj_log_error((uint64_t)"Reduce", "Unsupported decimation (VF|HF): %d|%d", *(_DWORD *)(a1 + 176), v1);
    return 3;
  }
  if (!*(_BYTE *)(a1 + 228))
  {
    if (!*(_BYTE *)(a1 + 230))
      return 1;
    aj_log_error((uint64_t)"Reduce", "Lossless not yet supported.");
  }
  else
  {
LABEL_8:
    aj_log_error((uint64_t)"Reduce", "Image not yet supported.");
  }
  return 0;
}

uint64_t write_pre_rimg_headers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  int pos;
  uint64_t v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  unsigned __int16 v25;

  result = aj_ostream_write_bytes(a3, 1380601927, 4);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a3, 65440, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 8), 2);
      if (!(_DWORD)result)
      {
        result = aj_ostream_write_bytes(a3, *(unsigned __int8 *)(a1 + 10), 1);
        if (!(_DWORD)result)
        {
          result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 12), 2);
          if (!(_DWORD)result)
          {
            result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 14), 2);
            if (!(_DWORD)result)
            {
              result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 16), 2);
              if (!(_DWORD)result)
              {
                result = write_variable_size_data(a3, *(_QWORD *)(a1 + 24), 8);
                if (!(_DWORD)result)
                {
                  result = write_variable_size_data(a3, *(_QWORD *)(a1 + 32), 8);
                  if (!(_DWORD)result)
                  {
                    result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 40), 2);
                    if (!(_DWORD)result)
                    {
                      result = aj_ostream_write_bytes(a3, *(_DWORD *)(a1 + 44), 4);
                      if (!(_DWORD)result)
                      {
                        v7 = 0;
                        v8 = a1 + 160488;
                        v9 = a1 + 48;
                        do
                        {
                          result = aj_ostream_write_bytes(a3, *(unsigned __int8 *)(v9 + v7), 1);
                          if ((_DWORD)result)
                            return result;
                          ++v7;
                        }
                        while (v7 != 16);
                        result = aj_istream_move_to_position(a2, 2);
                        if (!(_DWORD)result)
                        {
                          v10 = (char *)(*(uint64_t (**)(uint64_t, _QWORD))v8)(65537, *(_QWORD *)(v8 + 16));
                          *(_QWORD *)(v8 + 56) = v10;
                          if (!v10)
                            return 6;
                          v11 = v10;
                          bzero(v10, 0x10001uLL);
                          while (1)
                          {
                            v25 = 0;
                            v12 = aj_istream_peek_short(a2, &v25);
                            if ((_DWORD)v12)
                              return v12;
                            if (v25 != 255)
                            {
                              aj_log_error((uint64_t)"Reduce", "Expected 0xFF while parsing, got 0x%02X", v25);
                              return 11;
                            }
                            v24 = 0;
                            v23 = 0;
                            v13 = HIBYTE(v25);
                            v21 = v13;
                            v22 = 0;
                            switch(v13)
                            {
                              case 208:
                              case 209:
                              case 210:
                              case 211:
                              case 212:
                              case 213:
                              case 214:
                              case 215:
                              case 217:
                                aj_log_error((uint64_t)"Reduce", "EOI or RST marker encountered while parsing headers (marker = 0x%02X", v13);
                                return 11;
                              case 216:
                                pos = aj_istream_get_pos(a2);
                                v15 = aj_istream_move_to_position(a2, (pos + 2));
                                if ((_DWORD)v15)
                                  return v15;
                                v16 = 0;
                                goto LABEL_32;
                              case 218:
                                v16 = 1;
                                goto LABEL_26;
                              default:
                                v16 = 0;
LABEL_26:
                                if (aj_get_segment_id_and_length(a2, &v24, (_DWORD *)&v23 + 1, &v21, &v23, 1))goto LABEL_32;
                                v17 = v21;
                                if (v21 == 218)
                                {
                                  v17 = -93;
                                  v21 = 163;
                                }
                                *v11 = -1;
                                v11[1] = v17;
                                v18 = aj_istream_memcpy(a2, v11 + 2, v24, &v22);
                                if ((_DWORD)v18)
                                {
                                  v19 = v18;
                                  goto LABEL_43;
                                }
                                if (v24 != v22)
                                {
                                  v19 = 9;
LABEL_43:
                                  aj_log_error((uint64_t)"Reduce", "Error %d while copying headers to memory", v18);
                                  return v19;
                                }
                                v15 = aj_ostream_write_buf(a3, v11, v24 + 2);
                                if ((_DWORD)v15)
                                  return v15;
LABEL_32:
                                result = 0;
                                if (v16)
                                  return result;
                                break;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_rimg_segment_and_data(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  int v9;

  result = aj_ostream_write_bytes(a4, 65441, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a4, *(unsigned __int16 *)(a1 + 64), 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a4, *(_DWORD *)(a1 + 68), 4);
      if (!(_DWORD)result)
      {
        result = aj_ostream_write_bytes(a4, *(unsigned __int8 *)(a1 + 72), 1);
        if (!(_DWORD)result)
        {
          result = aj_ostream_write_bytes(a4, *(unsigned __int8 *)(a1 + 73), 1);
          if (!(_DWORD)result)
          {
            result = aj_ostream_write_bytes(a4, *(unsigned __int8 *)(a1 + 74), 1);
            if (!(_DWORD)result)
            {
              v9 = *(_DWORD *)(a4 + 16);
              result = aj_istream_move_to_position(*(_QWORD *)(a2 + 11280), *(unsigned int *)(*(_QWORD *)a3 + 3420));
              if (!(_DWORD)result)
              {
                result = (*(uint64_t (**)(uint64_t))(a1 + 141872))(a1 + 134936);
                if (!(_DWORD)result)
                {
                  result = aj_pack_all(a3, (uint64_t *)(a1 + 104), a2 + 11280);
                  if (!(_DWORD)result)
                  {
                    result = (*(uint64_t (**)(uint64_t))(a1 + 141936))(a1 + 134936);
                    if (!(_DWORD)result)
                      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a4 + 16) - v9;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_variable_size_data(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  int v4;
  uint64_t result;

  v3 = a3;
  v4 = a2;
  if (a3 >= 5)
  {
    result = aj_ostream_write_bytes(a1, SHIDWORD(a2), 4);
    if ((_DWORD)result)
      return result;
    v3 -= 4;
  }
  return aj_ostream_write_bytes(a1, v4, v3);
}

uint64_t write_rblob_segment_and_data(unsigned __int16 *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  int v9;

  *a1 = 7;
  *((_DWORD *)a1 + 1) = 0;
  *((_BYTE *)a1 + 8) = 0;
  result = aj_ostream_write_bytes(a3, 65442, 2);
  if (!(_DWORD)result)
  {
    result = aj_ostream_write_bytes(a3, *a1, 2);
    if (!(_DWORD)result)
    {
      result = aj_ostream_write_bytes(a3, *((_DWORD *)a1 + 1), 4);
      if (!(_DWORD)result)
      {
        result = aj_ostream_write_bytes(a3, *((unsigned __int8 *)a1 + 8), 1);
        if (!(_DWORD)result)
        {
          v9 = *(_DWORD *)(a3 + 16);
          result = copy_input_to_output(a2, a3, a4);
          if (!(_DWORD)result)
            *((_DWORD *)a1 + 1) = *(_DWORD *)(a3 + 16) - v9;
        }
      }
    }
  }
  return result;
}

uint64_t finalize_rjpeg_header(unsigned int *a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t result;
  unsigned int v6;
  unsigned int v7;

  v4 = *(_DWORD *)(a2 + 16);
  v7 = v4;
  result = overwrite_uint32(a2, &v7, 0x21u, a1[11]);
  if (!(_DWORD)result)
  {
    result = overwrite_uint32(a2, &v7, a1[22] + 4, a1[17]);
    if (!(_DWORD)result)
    {
      v6 = a1[20];
      if (!v6 || (result = overwrite_uint32(a2, &v7, a1[24] + 4, v6), !(_DWORD)result))
      {
        (*(void (**)(_QWORD, _QWORD))(a2 + 56))(v4 - v7, *(_QWORD *)(a2 + 32));
        return 0;
      }
    }
  }
  return result;
}

uint64_t red_mem_write_callback(void *__src, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  if (*(_QWORD *)(a3 + 8) < (unint64_t)a2)
    return 1;
  v5 = a2;
  memcpy(*(void **)a3, __src, a2);
  result = 0;
  v6 = *(_QWORD *)(a3 + 8) - v5;
  *(_QWORD *)a3 += v5;
  *(_QWORD *)(a3 + 8) = v6;
  return result;
}

uint64_t red_mem_rewind_callback(uint64_t a1)
{
  uint64_t v1;

  v1 = *(int *)(a1 + 24);
  *(_QWORD *)a1 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = v1;
  return 0;
}

uint64_t red_mem_skip_callback(int a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = a2[1] - a1;
  *a2 += a1;
  a2[1] = v2;
  return 0;
}

uint64_t copy_input_to_output(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  int v6;
  uint64_t result;
  unsigned int v8;
  char __src[1024];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    return 0;
  v3 = a3;
  while (1)
  {
    v8 = 0;
    v6 = v3 >= 1024 ? 1024 : v3;
    result = aj_istream_memcpy(a1, __src, v6, &v8);
    if ((_DWORD)result)
      break;
    result = aj_ostream_write_buf(a2, __src, v8);
    if ((_DWORD)result)
      break;
    v3 -= v8;
    if (!v3)
      return 0;
  }
  return result;
}

uint64_t overwrite_uint32(uint64_t a1, unsigned int *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v7;
  uint64_t v8;
  uint64_t result;
  unsigned int v10;

  v10 = bswap32(a4);
  v7 = *a2;
  if (*a2 > a3)
  {
    (*(void (**)(_QWORD))(a1 + 48))(*(_QWORD *)(a1 + 32));
    v7 = 0;
    *a2 = 0;
  }
  v8 = a3 - v7;
  (*(void (**)(uint64_t, _QWORD))(a1 + 56))(v8, *(_QWORD *)(a1 + 32));
  *a2 += v8;
  result = (*(uint64_t (**)(unsigned int *, uint64_t, _QWORD))(a1 + 40))(&v10, 4, *(_QWORD *)(a1 + 32));
  if (!(_DWORD)result)
    *a2 += 4;
  return result;
}

uint64_t initialize_unreduce(uint64_t a1, uint64_t a2)
{
  int v4;

  *(_QWORD *)(a1 + 134976) = a1 + 152136;
  v4 = *(unsigned __int8 *)(a1 + 74);
  if (v4 == 3)
  {
    aj_select_semistatic_coder((uint64_t (**)(int))(a1 + 141864));
    return aj_reduce_init_unpack(a1 + 160512, (int *)(a1 + 104), a1 + 141952, (int **)(a1 + 151688), (_QWORD *)(a1 + 148224), (unsigned int *)(a1 + 148264), a2, a1 + 160488, a1 + 141864);
  }
  if (v4 == 2)
  {
    aj_select_adaptive_coder((uint64_t (**)(int))(a1 + 141864));
    return aj_reduce_init_unpack(a1 + 160512, (int *)(a1 + 104), a1 + 141952, (int **)(a1 + 151688), (_QWORD *)(a1 + 148224), (unsigned int *)(a1 + 148264), a2, a1 + 160488, a1 + 141864);
  }
  return 5;
}

uint64_t unpack_rimg_data(uint64_t a1, uint64_t a2, uint64_t a3, int32x2_t *a4)
{
  uint64_t result;

  result = aj_istream_move_to_position(a3, (*(_DWORD *)(a1 + 88) + 11));
  if (!(_DWORD)result)
  {
    result = (*(uint64_t (**)(uint64_t))(a1 + 141880))(a1 + 134936);
    if (!(_DWORD)result)
    {
      result = aj_unpack_all((uint64_t *)(a1 + 104), a2, a4);
      if (!(_DWORD)result)
        return (*(uint64_t (**)(uint64_t))(a1 + 141944))(a1 + 134936);
    }
  }
  return result;
}

uint64_t aj_RGB888_YUV440(uint64_t result, uint64_t *a2, _QWORD *a3, signed int a4, int a5, double a6, int64x2_t a7, int64x2_t a8, int64x2_t a9)
{
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  size_t v26;

  v11 = (_BYTE *)*a3;
  v10 = (_BYTE *)a3[1];
  if ((_DWORD)result == 1)
  {
    aj_RGB888_YUV444(a6, a7, a8, a9, result, a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v10, v11, a5);
  }
  else
  {
    v12 = (_BYTE *)a3[4];
    v13 = (_BYTE *)a3[2];
    if (a4 >= 1)
    {
      v14 = (unsigned __int8 *)*a2;
      v15 = (unsigned __int8 *)a2[1];
      LODWORD(result) = a4;
      do
      {
        v16 = *v14;
        v17 = v14[1];
        v18 = v14[2];
        *v11++ = (((1254144 * v16 + 0x4000) >> 15)
                + ((2462080 * v17 + 0x4000) >> 15)
                + ((478208 * v18 + 0x4000) >> 15)
                + 64) >> 7;
        v19 = *v15;
        v20 = v15[1];
        v21 = v15[2];
        v22 = (((v21 << 6)
              - (((707584 * v19 + 0x4000) >> 15)
               + ((1389568 * v20 + 0x4000) >> 15))
              + 16448) >> 7)
            + (((v18 << 6)
              - (((707584 * v16 + 0x4000) >> 15)
               + ((1389568 * v17 + 0x4000) >> 15))
              + 16448) >> 7);
        *v10++ = (((1254144 * v19 + 0x4000) >> 15)
                + ((2462080 * v20 + 0x4000) >> 15)
                + ((478208 * v21 + 0x4000) >> 15)
                + 64) >> 7;
        if (v22 >= 0x1FF)
          LOBYTE(v23) = -1;
        else
          v23 = (v22 + 1) >> 1;
        v24 = (((v19 << 6)
              - (((1756160 * v20 + 0x4000) >> 15)
               + ((340992 * v21 + 0x4000) >> 15))
              + 16448) >> 7)
            + (((v16 << 6)
              - (((1756160 * v17 + 0x4000) >> 15)
               + ((340992 * v18 + 0x4000) >> 15))
              + 16448) >> 7);
        if (v24 >= 0x1FF)
          LOBYTE(v25) = -1;
        else
          v25 = (v24 + 1) >> 1;
        *v13++ = v23;
        *v12++ = v25;
        v14 += 3;
        v15 += 3;
        result = (result - 1);
      }
      while ((_DWORD)result);
    }
    v26 = (a5 - a4);
    if ((int)v26 >= 1)
    {
      memset(v11, *(v11 - 1), v26);
      memset(v10, *(v10 - 1), v26);
      memset(v13, *(v13 - 1), v26);
      return (uint64_t)memset(v12, *(v12 - 1), v26);
    }
  }
  return result;
}

_BYTE *aj_RGB888_to_gray(uint64_t a1, unsigned __int8 **a2, _BYTE **a3, int a4, int a5)
{
  _BYTE *result;
  unsigned __int8 *v6;
  int v7;

  result = *a3;
  if (a4 >= 1)
  {
    v6 = *a2;
    v7 = a4;
    do
    {
      *result++ = (((1254144 * *v6 + 0x4000) >> 15)
                 + ((2462080 * v6[1] + 0x4000) >> 15)
                 + ((478208 * v6[2] + 0x4000) >> 15)
                 + 64) >> 7;
      v6 += 3;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4)
    return memset(result, *(result - 1), a5 - a4);
  return result;
}

_BYTE *aj_RGBA8888_YUV440(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, int a5, double a6, int64x2_t a7, int64x2_t a8, int64x2_t a9)
{
  if ((_DWORD)a1 != 1)
    return XXXA8888_YUV440(a2, a3, a4, a5, 0);
  aj_RGBA8888_YUV444(a6, a7, a8, a9, a1, a2, a3, a4, a5);
  return memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
}

_BYTE *XXXA8888_YUV440(_QWORD *a1, uint64_t a2, int a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  _QWORD *v12;
  int v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  int v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  size_t v28;

  result = *(_BYTE **)a2;
  v7 = *(_BYTE **)(a2 + 8);
  v8 = *(_BYTE **)(a2 + 16);
  v9 = *(_BYTE **)(a2 + 32);
  if (a3 >= 1)
  {
    v12 = a1;
    v10 = (unsigned __int8 *)*a1;
    v11 = (unsigned __int8 *)v12[1];
    v13 = a3;
    do
    {
      v14 = v10 + 2;
      if (a5)
        v15 = v10 + 2;
      else
        v15 = v10;
      if (a5)
        v14 = v10;
      v16 = *v14;
      v17 = v10[1];
      v18 = *v15;
      if (a5)
        v19 = v11 + 2;
      else
        v19 = v11;
      if (a5)
        v20 = v11;
      else
        v20 = v11 + 2;
      *result++ = (((478208 * v16 + 0x4000) >> 15)
                 + ((2462080 * v17 + 0x4000) >> 15)
                 + ((1254144 * v18 + 0x4000) >> 15)
                 + 64) >> 7;
      v21 = *v19;
      v22 = v11[1];
      v23 = *v20;
      v24 = (((v23 << 6)
            - (((707584 * v21 + 0x4000) >> 15)
             + ((1389568 * v22 + 0x4000) >> 15))
            + 16448) >> 7)
          + (((v16 << 6)
            - (((1389568 * v17 + 0x4000) >> 15)
             + ((707584 * v18 + 0x4000) >> 15))
            + 16448) >> 7);
      *v7++ = (((1254144 * v21 + 0x4000) >> 15)
             + ((2462080 * v22 + 0x4000) >> 15)
             + ((478208 * v23 + 0x4000) >> 15)
             + 64) >> 7;
      if (v24 >= 0x1FF)
        LOBYTE(v25) = -1;
      else
        v25 = (v24 + 1) >> 1;
      v26 = (((v21 << 6)
            - (((1756160 * v22 + 0x4000) >> 15)
             + ((340992 * v23 + 0x4000) >> 15))
            + 16448) >> 7)
          + (((v18 << 6)
            - (((340992 * v16 + 0x4000) >> 15)
             + ((1756160 * v17 + 0x4000) >> 15))
            + 16448) >> 7);
      if (v26 >= 0x1FF)
        LOBYTE(v27) = -1;
      else
        v27 = (v26 + 1) >> 1;
      *v8++ = v25;
      *v9++ = v27;
      v10 += 4;
      v11 += 4;
      --v13;
    }
    while (v13);
  }
  v28 = (a4 - a3);
  if ((int)v28 >= 1)
  {
    memset(result, *(result - 1), (a4 - a3));
    memset(v7, *(v7 - 1), v28);
    memset(v8, *(v8 - 1), v28);
    return memset(v9, *(v9 - 1), v28);
  }
  return result;
}

_BYTE *aj_RGBA8888_to_gray(uint64_t a1, unsigned __int8 **a2, _BYTE **a3, int a4, int a5)
{
  return XXXA8888_to_gray(a2, a3, a4, a5, 0);
}

_BYTE *XXXA8888_to_gray(unsigned __int8 **a1, _BYTE **a2, int a3, int a4, int a5)
{
  _BYTE *result;
  unsigned __int8 *v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;

  result = *a2;
  if (a3 >= 1)
  {
    v7 = *a1;
    v8 = a3;
    do
    {
      v9 = v7 + 2;
      if (a5)
        v10 = v7 + 2;
      else
        v10 = v7;
      if (a5)
        v9 = v7;
      *result++ = (((1254144 * *v10 + 0x4000) >> 15)
                 + ((2462080 * v7[1] + 0x4000) >> 15)
                 + ((478208 * *v9 + 0x4000) >> 15)
                 + 64) >> 7;
      v7 += 4;
      --v8;
    }
    while (v8);
  }
  if (a4 > a3)
    return memset(result, *(result - 1), a4 - a3);
  return result;
}

_BYTE *aj_BGRA8888_YUV440(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, int a5, double a6, int64x2_t a7, int64x2_t a8, int64x2_t a9)
{
  if ((_DWORD)a1 != 1)
    return XXXA8888_YUV440(a2, a3, a4, a5, 1);
  aj_BGRA8888_YUV444(a6, a7, a8, a9, a1, a2, a3, a4, a5);
  return memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
}

_BYTE *aj_BGRA8888_to_gray(uint64_t a1, unsigned __int8 **a2, _BYTE **a3, int a4, int a5)
{
  return XXXA8888_to_gray(a2, a3, a4, a5, 1);
}

_BYTE *aj_RGB565_YUV444(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v6;
  _BYTE *v7;
  unsigned __int8 *v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  size_t v15;

  result = *(_BYTE **)a3;
  v6 = *(_BYTE **)(a3 + 16);
  v7 = *(_BYTE **)(a3 + 32);
  if (a4 >= 1)
  {
    v8 = *a2;
    v9 = a4;
    do
    {
      v10 = *v8;
      v11 = v8[1];
      v12 = (v10 >> 5) & 0xFFFFFFC7 | (8 * (v11 & 7));
      v13 = (v11 << 7) & 0x7C00;
      *result++ = (((10033152 * (v10 & 0x1F) + 0x4000) >> 15)
                 + ((3736 * v13 + 0x4000) >> 15)
                 + ((9848320 * v12 + 0x4000) >> 15)
                 + 64) >> 7;
      *v6++ = (((v13 >> 1) | 0x40404040) - (((5660672 * (v10 & 0x1F) + 0x4000) >> 15) + ((5558272 * v12 + 0x4000) >> 15))) >> 7;
      *v7++ = (((v10 << 9) | 0x40404040) - (((2664 * v13 + 0x4000) >> 15) + ((7024640 * v12 + 0x4000) >> 15))) >> 7;
      v8 += 2;
      --v9;
    }
    while (v9);
  }
  v14 = a5 - a4;
  if (a5 > a4)
  {
    v15 = v14;
    memset(result, *(result - 1), v14);
    memset(v6, *(v6 - 1), v15);
    return memset(v7, *(v7 - 1), v15);
  }
  return result;
}

_BYTE *aj_RGB565_YUV422(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  unsigned __int8 *v5;
  _BYTE *result;
  _BYTE *v7;
  _BYTE *v8;
  int v9;
  uint64_t v10;
  signed int v11;
  _BYTE *v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  size_t v31;

  v5 = *a2;
  result = *(_BYTE **)a3;
  v7 = *(_BYTE **)(a3 + 16);
  v8 = *(_BYTE **)(a3 + 32);
  v9 = a4 - 1;
  if (a4 < 2)
  {
    v11 = 0;
  }
  else
  {
    v10 = 0;
    v11 = a4 & 0xFFFFFFFE;
    do
    {
      v12 = &result[v10];
      v13 = *v5;
      v14 = (v13 & 0x1F) << 10;
      v15 = v5[1];
      v16 = (v13 >> 5) & 0xFFFFFFC7 | (8 * (v15 & 7));
      v17 = (v15 << 7) & 0x7C00;
      v18 = (((v14 >> 1) | 0x40404040) - (((2664 * v17 + 0x4000) >> 15) + ((7024640 * v16 + 0x4000) >> 15))) >> 7;
      v19 = (((v17 >> 1) | 0x40404040) - (((5528 * v14 + 0x4000) >> 15) + ((5558272 * v16 + 0x4000) >> 15))) >> 7;
      *v12 = (((9798 * v14 + 0x4000) >> 15) + ((3736 * v17 + 0x4000) >> 15) + ((9848320 * v16 + 0x4000) >> 15) + 64) >> 7;
      v20 = v5[2];
      v21 = (v20 & 0x1F) << 10;
      v22 = v5[3];
      v23 = (v20 >> 5) & 0xFFFFFFC7 | (8 * (v22 & 7));
      v5 += 4;
      v24 = (v22 << 7) & 0x7C00;
      v12[1] = (((9798 * v21 + 0x4000) >> 15) + ((3736 * v24 + 0x4000) >> 15) + ((9848320 * v23 + 0x4000) >> 15) + 64) >> 7;
      *v7++ = (v19
             + ((((v24 >> 1) | 0x40404040) - (((5528 * v21 + 0x4000) >> 15) + ((5558272 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      *v8++ = (v18
             + ((((v21 >> 1) | 0x40404040) - (((2664 * v24 + 0x4000) >> 15) + ((7024640 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      v10 += 2;
    }
    while ((int)v10 < v9);
    result += v10;
  }
  if (v11 == v9)
  {
    v25 = *v5;
    v26 = v5[1];
    v27 = (v25 >> 5) & 0xFFFFFFC7 | (8 * (v26 & 7));
    v28 = (v26 << 7) & 0x7C00;
    v29 = (((10033152 * (v25 & 0x1F) + 0x4000) >> 15)
         + ((3736 * v28 + 0x4000) >> 15)
         + ((9848320 * v27 + 0x4000) >> 15)
         + 64) >> 7;
    *result = v29;
    result[1] = v29;
    result += 2;
    *v7++ = (((v28 >> 1) | 0x40404040) - (((5660672 * (v25 & 0x1F) + 0x4000) >> 15) + ((5558272 * v27 + 0x4000) >> 15))) >> 7;
    *v8++ = (((v25 << 9) | 0x40404040) - (((2664 * v28 + 0x4000) >> 15) + ((7024640 * v27 + 0x4000) >> 15))) >> 7;
    v11 = a4 + 1;
  }
  v30 = a5 - v11;
  if (a5 > v11)
  {
    memset(result, *(result - 1), v30);
    v31 = (uint64_t)v30 >> 1;
    memset(v7, *(v7 - 1), v31);
    return memset(v8, *(v8 - 1), v31);
  }
  return result;
}

uint64_t aj_RGB565_YUV440(uint64_t result, uint64_t a2, _QWORD *a3, int a4, int a5)
{
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  size_t v23;

  v7 = (_BYTE *)*a3;
  v6 = (_BYTE *)a3[1];
  if ((_DWORD)result == 1)
  {
    aj_RGB565_YUV444(result, (unsigned __int8 **)a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v6, v7, a5);
  }
  else
  {
    v8 = (_BYTE *)a3[4];
    v9 = (_BYTE *)a3[2];
    if (a4 >= 1)
    {
      v10 = *(unsigned __int8 **)a2;
      v11 = *(unsigned __int8 **)(a2 + 8);
      v12 = a4;
      do
      {
        v13 = *v10;
        v14 = (v13 & 0x1F) << 10;
        v15 = v10[1];
        v16 = (v13 >> 5) & 0xFFFFFFC7 | (8 * (v15 & 7));
        v17 = (v15 << 7) & 0x7C00;
        *v7++ = (((9798 * v14 + 0x4000) >> 15) + ((3736 * v17 + 0x4000) >> 15) + ((9848320 * v16 + 0x4000) >> 15) + 64) >> 7;
        v18 = *v11;
        v19 = (v18 & 0x1F) << 10;
        v20 = v11[1];
        v21 = (v18 >> 5) & 0xFFFFFFC7 | (8 * (v20 & 7));
        v22 = (v20 << 7) & 0x7C00;
        *v6++ = (((9798 * v19 + 0x4000) >> 15) + ((3736 * v22 + 0x4000) >> 15) + ((9848320 * v21 + 0x4000) >> 15) + 64) >> 7;
        *v9++ = (((((v17 >> 1) | 0x40404040) - (((5528 * v14 + 0x4000) >> 15) + ((5558272 * v16 + 0x4000) >> 15))) >> 7)
               + ((((v22 >> 1) | 0x40404040) - (((5528 * v19 + 0x4000) >> 15) + ((5558272 * v21 + 0x4000) >> 15))) >> 7)
               + 1) >> 1;
        result = (((((v14 >> 1) | 0x40404040) - (((2664 * v17 + 0x4000) >> 15) + ((7024640 * v16 + 0x4000) >> 15))) >> 7)
                + ((((v19 >> 1) | 0x40404040) - (((2664 * v22 + 0x4000) >> 15) + ((7024640 * v21 + 0x4000) >> 15))) >> 7)
                + 1) >> 1;
        *v8++ = result;
        v10 += 2;
        v11 += 2;
        --v12;
      }
      while (v12);
    }
    v23 = (a5 - a4);
    if ((int)v23 >= 1)
    {
      memset(v7, *(v7 - 1), v23);
      memset(v6, *(v6 - 1), v23);
      memset(v9, *(v9 - 1), v23);
      return (uint64_t)memset(v8, *(v8 - 1), v23);
    }
  }
  return result;
}

uint64_t aj_RGB565_YUV420(uint64_t result, unsigned __int8 **a2, _QWORD *a3, int a4, int a5)
{
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  int v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  uint64_t v14;
  signed int v15;
  int32x4_t v16;
  uint16x4_t v17;
  uint32x4_t v18;
  uint16x4_t v19;
  int32x4_t v20;
  _BYTE *v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  _BYTE *v27;
  unsigned __int8 *v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  int v34;
  unsigned __int8 *v35;
  __int32 v36;
  int v37;
  int v38;
  unsigned int v39;
  uint32x4_t v40;
  int v41;
  int32x4_t v42;
  unsigned int v43;
  int32x4_t v44;
  int32x4_t v45;
  uint32x4_t v46;
  uint32x4_t v47;
  int32x4_t v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;

  v7 = (_BYTE *)*a3;
  v6 = (_BYTE *)a3[1];
  if ((_DWORD)result == 1)
  {
    aj_RGB565_YUV422(result, a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v6, v7, a5);
  }
  else
  {
    v8 = (_BYTE *)a3[4];
    v9 = (_BYTE *)a3[2];
    v10 = a4 - 1;
    v11 = *a2;
    v12 = a2[1];
    if (a4 < 2)
    {
      v15 = 0;
    }
    else
    {
      v14 = 0;
      v15 = a4 & 0xFFFFFFFE;
      v16 = vdupq_n_s32(0x6B3000u);
      v17 = (uint16x4_t)vdup_n_s16(0xA68u);
      v18 = (uint32x4_t)vdupq_n_s32(0x4040u);
      v19 = (uint16x4_t)vdup_n_s16(0x1598u);
      v20 = vdupq_n_s32(0x54D000u);
      do
      {
        v21 = &v7[v14];
        v22 = *v11;
        v23 = v11[1];
        v24 = (v22 & 0x1F) << 10;
        v25 = (v22 >> 5) & 0xFFFFFFC7 | (8 * (v23 & 7));
        v26 = (v23 << 7) & 0x7C00;
        v27 = &v6[v14];
        *v21 = (((10033152 * (v22 & 0x1F) + 0x4000) >> 15)
              + ((3736 * v26 + 0x4000) >> 15)
              + ((9848320 * v25 + 0x4000) >> 15)
              + 64) >> 7;
        v28 = v11 + 4;
        v29 = v11[2];
        v30 = (v29 & 0x1F) << 10;
        v31 = v29 >> 5;
        v32 = v11[3];
        v33 = v31 & 0xFFFFFFC7 | (8 * (v32 & 7));
        v34 = (v32 << 7) & 0x7C00;
        v35 = v12 + 4;
        v21[1] = (((9798 * v30 + 0x4000) >> 15)
                + ((3736 * v34 + 0x4000) >> 15)
                + ((9848320 * v33 + 0x4000) >> 15)
                + 64) >> 7;
        LODWORD(v21) = *v12;
        v36 = (v21 & 0x1F) << 10;
        v37 = v12[1];
        LODWORD(v21) = (v21 >> 5) & 0xFFFFFFC7 | (8 * (v37 & 7));
        v38 = (v37 << 7) & 0x7C00;
        *v27 = (((9798 * v36 + 0x4000) >> 15)
              + ((3736 * v38 + 0x4000) >> 15)
              + ((9848320 * (_DWORD)v21 + 0x4000) >> 15)
              + 64) >> 7;
        v39 = v12[2];
        v40.i64[0] = __PAIR64__(v30, v24);
        v40.i32[2] = v36;
        v40.i32[3] = (v39 & 0x1F) << 10;
        v41 = v12[3];
        v42.i64[0] = __PAIR64__(v33, v25);
        v43 = (v39 >> 5) & 0xFFFFFFC7 | (8 * (v41 & 7));
        v42.i64[1] = __PAIR64__(v43, v21);
        v44.i64[0] = 0x400000004000;
        v44.i64[1] = 0x400000004000;
        v45.i64[0] = __PAIR64__(v34, v26);
        v45.i32[2] = v38;
        v45.i32[3] = (v41 << 7) & 0x7C00;
        v46.i64[0] = 0x400000004000;
        v46.i64[1] = 0x400000004000;
        v47.i64[0] = 0x400000004000;
        v47.i64[1] = 0x400000004000;
        v48 = (int32x4_t)vsraq_n_u32(vshrq_n_u32(vmlal_u16(v46, (uint16x4_t)vmovn_s32(v45), v17), 0xFuLL), (uint32x4_t)vmlaq_s32(v44, v42, v16), 0xFuLL);
        v44.i64[0] = 0x400000004000;
        v44.i64[1] = 0x400000004000;
        v27[1] = (((10033152 * (v39 & 0x1F) + 0x4000) >> 15)
                + ((3736 * v45.i32[3] + 0x4000) >> 15)
                + ((9848320 * v43 + 0x4000) >> 15)
                + 64) >> 7;
        result = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vsraq_n_u32(v18, v40, 1uLL), v48), 7uLL))+ 2) >> 2;
        *v9++ = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vsraq_n_u32(v18, (uint32x4_t)v45, 1uLL), (int32x4_t)vsraq_n_u32(vshrq_n_u32(vmlal_u16(v47, (uint16x4_t)vmovn_s32((int32x4_t)v40), v19), 0xFuLL), (uint32x4_t)vmlaq_s32(v44, v42, v20), 0xFuLL)), 7uLL))+ 2) >> 2;
        *v8++ = result;
        v14 += 2;
        v11 = v28;
        v12 = v35;
      }
      while ((int)v14 < v10);
      v7 += v14;
      v6 += v14;
      v12 = v35;
      v11 = v28;
    }
    if (v15 == v10)
    {
      v49 = *v11;
      v50 = (v49 & 0x1F) << 10;
      v51 = v11[1];
      v52 = (v49 >> 5) & 0xFFFFFFC7 | (8 * (v51 & 7));
      v53 = (v51 << 7) & 0x7C00;
      v54 = (((9798 * v50 + 0x4000) >> 15) + ((3736 * v53 + 0x4000) >> 15) + ((9848320 * v52 + 0x4000) >> 15) + 64) >> 7;
      *v7 = v54;
      v7[1] = v54;
      v7 += 2;
      v55 = *v12;
      v56 = (v55 & 0x1F) << 10;
      v57 = v12[1];
      v58 = (v55 >> 5) & 0xFFFFFFC7 | (8 * (v57 & 7));
      v59 = (v57 << 7) & 0x7C00;
      result = ((v56 >> 1) | 0x40404040) - (((2664 * v59 + 0x4000) >> 15) + ((7024640 * v58 + 0x4000) >> 15));
      v60 = (((9798 * v56 + 0x4000) >> 15) + ((3736 * v59 + 0x4000) >> 15) + ((9848320 * v58 + 0x4000) >> 15) + 64) >> 7;
      *v6 = v60;
      v6[1] = v60;
      v6 += 2;
      *v9++ = (((((v53 >> 1) | 0x40404040) - (((5528 * v50 + 0x4000) >> 15) + ((5558272 * v52 + 0x4000) >> 15))) >> 7)
             + ((((v59 >> 1) | 0x40404040) - (((5528 * v56 + 0x4000) >> 15) + ((5558272 * v58 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      *v8++ = (((((v50 >> 1) | 0x40404040) - (((2664 * v53 + 0x4000) >> 15) + ((7024640 * v52 + 0x4000) >> 15))) >> 7)
             + (result >> 7)
             + 1) >> 1;
      v15 = a4 + 1;
    }
    v61 = a5 - v15;
    if (a5 > v15)
    {
      memset(v7, *(v7 - 1), v61);
      memset(v6, *(v6 - 1), v61);
      memset(v9, *(v9 - 1), (uint64_t)v61 >> 1);
      return (uint64_t)memset(v8, *(v8 - 1), (uint64_t)v61 >> 1);
    }
  }
  return result;
}

_BYTE *aj_RGB565_to_gray(uint64_t a1, unsigned __int8 **a2, _BYTE **a3, int a4, int a5)
{
  _BYTE *result;
  unsigned __int8 *v6;
  int v7;

  result = *a3;
  if (a4 >= 1)
  {
    v6 = *a2;
    v7 = a4;
    do
    {
      *result++ = (((10033152 * (*v6 & 0x1Fu) + 0x4000) >> 15)
                 + ((3736 * ((v6[1] << 7) & 0x7C00u) + 0x4000) >> 15)
                 + ((9848320 * ((*v6 >> 5) & 0xFFFFFFC7 | (8 * (v6[1] & 7))) + 0x4000) >> 15)
                 + 64) >> 7;
      v6 += 2;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4)
    return memset(result, *(result - 1), a5 - a4);
  return result;
}

_BYTE *aj_BGR565_YUV444(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v6;
  _BYTE *v7;
  unsigned __int8 *v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  size_t v15;

  result = *(_BYTE **)a3;
  v6 = *(_BYTE **)(a3 + 16);
  v7 = *(_BYTE **)(a3 + 32);
  if (a4 >= 1)
  {
    v8 = *a2;
    v9 = a4;
    do
    {
      v10 = *v8;
      v11 = v8[1];
      v12 = (v10 >> 5) & 0xFFFFFFC7 | (8 * (v11 & 7));
      v13 = (v11 << 7) & 0x7C00;
      *result++ = (((3825664 * (v10 & 0x1F) + 0x4000) >> 15)
                 + ((9798 * v13 + 0x4000) >> 15)
                 + ((9848320 * v12 + 0x4000) >> 15)
                 + 64) >> 7;
      *v6++ = (((v10 << 9) | 0x40404040) - (((5528 * v13 + 0x4000) >> 15) + ((5558272 * v12 + 0x4000) >> 15))) >> 7;
      *v7++ = (((v13 >> 1) | 0x40404040) - (((2727936 * (v10 & 0x1F) + 0x4000) >> 15) + ((7024640 * v12 + 0x4000) >> 15))) >> 7;
      v8 += 2;
      --v9;
    }
    while (v9);
  }
  v14 = a5 - a4;
  if (a5 > a4)
  {
    v15 = v14;
    memset(result, *(result - 1), v14);
    memset(v6, *(v6 - 1), v15);
    return memset(v7, *(v7 - 1), v15);
  }
  return result;
}

_BYTE *aj_BGR565_YUV422(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  unsigned __int8 *v5;
  _BYTE *result;
  _BYTE *v7;
  _BYTE *v8;
  int v9;
  uint64_t v10;
  signed int v11;
  _BYTE *v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  size_t v31;

  v5 = *a2;
  result = *(_BYTE **)a3;
  v7 = *(_BYTE **)(a3 + 16);
  v8 = *(_BYTE **)(a3 + 32);
  v9 = a4 - 1;
  if (a4 < 2)
  {
    v11 = 0;
  }
  else
  {
    v10 = 0;
    v11 = a4 & 0xFFFFFFFE;
    do
    {
      v12 = &result[v10];
      v13 = v5[1];
      v14 = (v13 << 7) & 0x7C00;
      v15 = *v5;
      v16 = (v15 >> 5) & 0xFFFFFFC7 | (8 * (v13 & 7));
      v17 = (v15 & 0x1F) << 10;
      v18 = (((v14 >> 1) | 0x40404040) - (((2664 * v17 + 0x4000) >> 15) + ((7024640 * v16 + 0x4000) >> 15))) >> 7;
      v19 = (((v17 >> 1) | 0x40404040) - (((5528 * v14 + 0x4000) >> 15) + ((5558272 * v16 + 0x4000) >> 15))) >> 7;
      *v12 = (((9798 * v14 + 0x4000) >> 15) + ((9848320 * v16 + 0x4000) >> 15) + ((3736 * v17 + 0x4000) >> 15) + 64) >> 7;
      v20 = v5[2];
      v21 = (v20 & 0x1F) << 10;
      v22 = v5[3];
      v23 = (v20 >> 5) & 0xFFFFFFC7 | (8 * (v22 & 7));
      v5 += 4;
      v24 = (v22 << 7) & 0x7C00;
      v12[1] = (((3736 * v21 + 0x4000) >> 15) + ((9798 * v24 + 0x4000) >> 15) + ((9848320 * v23 + 0x4000) >> 15) + 64) >> 7;
      *v7++ = (v19
             + ((((v21 >> 1) | 0x40404040) - (((5528 * v24 + 0x4000) >> 15) + ((5558272 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      *v8++ = (v18
             + ((((v24 >> 1) | 0x40404040) - (((2664 * v21 + 0x4000) >> 15) + ((7024640 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      v10 += 2;
    }
    while ((int)v10 < v9);
    result += v10;
  }
  if (v11 == v9)
  {
    v25 = *v5;
    v26 = v5[1];
    v27 = (v25 >> 5) & 0xFFFFFFC7 | (8 * (v26 & 7));
    v28 = (v26 << 7) & 0x7C00;
    v29 = (((3825664 * (v25 & 0x1F) + 0x4000) >> 15)
         + ((9798 * v28 + 0x4000) >> 15)
         + ((9848320 * v27 + 0x4000) >> 15)
         + 64) >> 7;
    *result = v29;
    result[1] = v29;
    result += 2;
    *v7++ = (((v25 << 9) | 0x40404040) - (((5528 * v28 + 0x4000) >> 15) + ((5558272 * v27 + 0x4000) >> 15))) >> 7;
    *v8++ = (((v28 >> 1) | 0x40404040) - (((2727936 * (v25 & 0x1F) + 0x4000) >> 15) + ((7024640 * v27 + 0x4000) >> 15))) >> 7;
    v11 = a4 + 1;
  }
  v30 = a5 - v11;
  if (a5 > v11)
  {
    memset(result, *(result - 1), v30);
    v31 = (uint64_t)v30 >> 1;
    memset(v7, *(v7 - 1), v31);
    return memset(v8, *(v8 - 1), v31);
  }
  return result;
}

uint64_t aj_BGR565_YUV440(uint64_t result, uint64_t a2, _QWORD *a3, int a4, int a5)
{
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  size_t v21;

  v7 = (_BYTE *)*a3;
  v6 = (_BYTE *)a3[1];
  if ((_DWORD)result == 1)
  {
    aj_BGR565_YUV444(result, (unsigned __int8 **)a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v6, v7, a5);
  }
  else
  {
    v8 = (_BYTE *)a3[4];
    v9 = (_BYTE *)a3[2];
    if (a4 >= 1)
    {
      v10 = (unsigned __int8 *)(*(_QWORD *)a2 + 1);
      v11 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8) + 1);
      v12 = a4;
      do
      {
        v13 = *v10;
        v14 = (v13 << 7) & 0x7C00;
        v15 = *(v10 - 1);
        v16 = (v15 >> 5) & 0xFFFFFFC7 | (8 * (v13 & 7));
        *v7++ = (((9798 * v14 + 0x4000) >> 15)
               + ((9848320 * v16 + 0x4000) >> 15)
               + ((3825664 * (v15 & 0x1F) + 0x4000) >> 15)
               + 64) >> 7;
        v17 = *v11;
        v18 = (v17 << 7) & 0x7C00;
        v19 = *(v11 - 1);
        v20 = (v19 >> 5) & 0xFFFFFFC7 | (8 * (v17 & 7));
        *v6++ = (((9798 * v18 + 0x4000) >> 15)
               + ((9848320 * v20 + 0x4000) >> 15)
               + ((3825664 * (v19 & 0x1F) + 0x4000) >> 15)
               + 64) >> 7;
        *v9++ = ((((((v15 & 0x1F) << 10 >> 1) | 0x40404040)
                 - (((5528 * v14 + 0x4000) >> 15)
                  + ((5558272 * v16 + 0x4000) >> 15))) >> 7)
               + (((((v19 & 0x1F) << 10 >> 1) | 0x40404040)
                 - (((5528 * v18 + 0x4000) >> 15)
                  + ((5558272 * v20 + 0x4000) >> 15))) >> 7)
               + 1) >> 1;
        result = (((((v14 >> 1) | 0x40404040)
                  - (((2727936 * (v15 & 0x1F) + 0x4000) >> 15)
                   + ((7024640 * v16 + 0x4000) >> 15))) >> 7)
                + ((((v18 >> 1) | 0x40404040)
                  - (((2727936 * (v19 & 0x1F) + 0x4000) >> 15)
                   + ((7024640 * v20 + 0x4000) >> 15))) >> 7)
                + 1) >> 1;
        *v8++ = result;
        v10 += 2;
        v11 += 2;
        --v12;
      }
      while (v12);
    }
    v21 = (a5 - a4);
    if ((int)v21 >= 1)
    {
      memset(v7, *(v7 - 1), v21);
      memset(v6, *(v6 - 1), v21);
      memset(v9, *(v9 - 1), v21);
      return (uint64_t)memset(v8, *(v8 - 1), v21);
    }
  }
  return result;
}

_BYTE *aj_BGR565_YUV420(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  signed int v15;
  int32x4_t v16;
  uint16x4_t v17;
  uint32x4_t v18;
  uint16x4_t v19;
  int32x4_t v20;
  int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  int v25;
  _BYTE *v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  _BYTE *v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  uint32x4_t v36;
  unsigned int v37;
  int32x4_t v38;
  unsigned int v39;
  int32x4_t v40;
  int32x4_t v41;
  uint32x4_t v42;
  uint32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  uint32x4_t v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  int v58;

  if ((_DWORD)a1 == 1)
  {
    aj_BGR565_YUV422(a1, a2, a3, a4, a5);
    return memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    v8 = *(_BYTE **)(a3 + 32);
    v10 = *(_BYTE **)(a3 + 8);
    v9 = *(_BYTE **)(a3 + 16);
    result = *(_BYTE **)a3;
    v11 = a4 - 1;
    v13 = *a2;
    v12 = a2[1];
    if (a4 < 2)
    {
      v15 = 0;
    }
    else
    {
      v14 = 0;
      v15 = a4 & 0xFFFFFFFE;
      v16 = vdupq_n_s32(0x6B3000u);
      v17 = (uint16x4_t)vdup_n_s16(0xA68u);
      v18 = (uint32x4_t)vdupq_n_s32(0x4040u);
      v19 = (uint16x4_t)vdup_n_s16(0x1598u);
      v20 = vdupq_n_s32(0x54D000u);
      do
      {
        v21 = v13[1];
        v22 = *v13;
        v23 = (v21 << 7) & 0x7C00;
        v24 = (v22 >> 5) & 0xFFFFFFC7 | (8 * (v21 & 7));
        v25 = (v22 & 0x1F) << 10;
        v26 = &result[v14];
        *v26 = (((9798 * v23 + 0x4000) >> 15)
              + ((9848320 * v24 + 0x4000) >> 15)
              + ((3825664 * (v22 & 0x1F) + 0x4000) >> 15)
              + 64) >> 7;
        v27 = v13[3];
        v28 = (v27 << 7) & 0x7C00;
        v29 = v13[2];
        v30 = (v29 >> 5) & 0xFFFFFFC7 | (8 * (v27 & 7));
        v31 = (v29 & 0x1F) << 10;
        v32 = &v10[v14];
        v26[1] = (((9798 * v28 + 0x4000) >> 15)
                + ((9848320 * v30 + 0x4000) >> 15)
                + ((3736 * v31 + 0x4000) >> 15)
                + 64) >> 7;
        v13 += 4;
        LODWORD(v26) = v12[1];
        v33 = ((_DWORD)v26 << 7) & 0x7C00;
        v34 = *v12;
        v35 = (v34 >> 5) & 0xFFFFFFC7 | (8 * (v26 & 7));
        LODWORD(v26) = (v34 & 0x1F) << 10;
        *v32 = (((9798 * v33 + 0x4000) >> 15)
              + ((9848320 * v35 + 0x4000) >> 15)
              + ((3825664 * (v34 & 0x1F) + 0x4000) >> 15)
              + 64) >> 7;
        v36.i64[0] = __PAIR64__(v28, v23);
        LOWORD(v23) = v12[3];
        v36.i32[2] = v33;
        v37 = v12[2];
        v12 += 4;
        v38.i64[0] = __PAIR64__(v30, v24);
        v39 = (v37 >> 5) & 0xFFFFFFC7 | (8 * (v23 & 7));
        v38.i64[1] = __PAIR64__(v39, v35);
        v40.i64[0] = 0x400000004000;
        v40.i64[1] = 0x400000004000;
        v36.i32[3] = ((_WORD)v23 << 7) & 0x7C00;
        v41.i64[0] = __PAIR64__(v31, v25);
        v41.i32[2] = (int)v26;
        v41.i32[3] = (v37 & 0x1F) << 10;
        v42.i64[0] = 0x400000004000;
        v42.i64[1] = 0x400000004000;
        v43 = vshrq_n_u32(vmlal_u16(v42, (uint16x4_t)vmovn_s32(v41), v17), 0xFuLL);
        v44 = (int32x4_t)vsraq_n_u32(v18, v36, 1uLL);
        v45 = (int32x4_t)vsraq_n_u32(v43, (uint32x4_t)vmlaq_s32(v40, v38, v16), 0xFuLL);
        v40.i64[0] = 0x400000004000;
        v40.i64[1] = 0x400000004000;
        v46 = vshrq_n_u32(vmlal_u16((uint32x4_t)v40, (uint16x4_t)vmovn_s32((int32x4_t)v36), v19), 0xFuLL);
        v40.i64[0] = 0x400000004000;
        v40.i64[1] = 0x400000004000;
        v32[1] = (((9798 * (((_WORD)v23 << 7) & 0x7C00u) + 0x4000) >> 15)
                + ((9848320 * v39 + 0x4000) >> 15)
                + ((3825664 * (v37 & 0x1F) + 0x4000) >> 15)
                + 64) >> 7;
        *v9++ = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vsraq_n_u32(v18, (uint32x4_t)v41, 1uLL), (int32x4_t)vsraq_n_u32(v46, (uint32x4_t)vmlaq_s32(v40, v38, v20), 0xFuLL)), 7uLL))+ 2) >> 2;
        *v8++ = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32(v44, v45), 7uLL)) + 2) >> 2;
        v14 += 2;
      }
      while ((int)v14 < v11);
      v10 += v14;
      result += v14;
    }
    if (v15 == v11)
    {
      v47 = v13[1];
      v48 = (v47 << 7) & 0x7C00;
      v49 = *v13;
      v50 = (v49 >> 5) & 0xFFFFFFC7 | (8 * (v47 & 7));
      v51 = (((9798 * v48 + 0x4000) >> 15)
           + ((9848320 * v50 + 0x4000) >> 15)
           + ((3825664 * (v49 & 0x1F) + 0x4000) >> 15)
           + 64) >> 7;
      *result = v51;
      result[1] = v51;
      result += 2;
      v52 = v12[1];
      v53 = (v52 << 7) & 0x7C00;
      v54 = *v12;
      v55 = (v54 >> 5) & 0xFFFFFFC7 | (8 * (v52 & 7));
      v56 = (v54 & 0x1F) << 10;
      v57 = (((9798 * v53 + 0x4000) >> 15) + ((9848320 * v55 + 0x4000) >> 15) + ((3736 * v56 + 0x4000) >> 15) + 64) >> 7;
      *v10 = v57;
      v10[1] = v57;
      v10 += 2;
      *v9++ = ((((((v49 & 0x1F) << 10 >> 1) | 0x40404040)
               - (((5528 * v48 + 0x4000) >> 15)
                + ((5558272 * v50 + 0x4000) >> 15))) >> 7)
             + ((((v56 >> 1) | 0x40404040) - (((5528 * v53 + 0x4000) >> 15) + ((5558272 * v55 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      *v8++ = (((((v48 >> 1) | 0x40404040)
               - (((2727936 * (v49 & 0x1F) + 0x4000) >> 15)
                + ((7024640 * v50 + 0x4000) >> 15))) >> 7)
             + ((((v53 >> 1) | 0x40404040) - (((2664 * v56 + 0x4000) >> 15) + ((7024640 * v55 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      v15 = a4 + 1;
    }
    v58 = a5 - v15;
    if (a5 > v15)
    {
      memset(result, *(result - 1), v58);
      memset(v10, *(v10 - 1), v58);
      memset(v9, *(v9 - 1), (uint64_t)v58 >> 1);
      return memset(v8, *(v8 - 1), (uint64_t)v58 >> 1);
    }
  }
  return result;
}

_BYTE *aj_BGR565_to_gray(uint64_t a1, _QWORD *a2, _BYTE **a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v6;
  int v7;

  result = *a3;
  if (a4 >= 1)
  {
    v6 = (_BYTE *)(*a2 + 1);
    v7 = a4;
    do
    {
      *result++ = (((9798 * ((*v6 << 7) & 0x7C00u) + 0x4000) >> 15)
                 + ((9848320 * ((*(v6 - 1) >> 5) & 0xFFFFFFC7 | (8 * (*v6 & 7))) + 0x4000) >> 15)
                 + ((3825664 * (*(v6 - 1) & 0x1Fu) + 0x4000) >> 15)
                 + 64) >> 7;
      v6 += 2;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4)
    return memset(result, *(result - 1), a5 - a4);
  return result;
}

void *aj_gray_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v8;
  char *v9;
  uint64_t v10;

  v8 = (char *)*a2;
  v9 = (char *)*a3;
  v10 = a4;
  memcpy(*a3, *a2, a4);
  if (a5 > a4)
    memset(&v9[v10], v8[v10 - 1], a5 - a4);
  memset(a3[2], 128, a5);
  return memset(a3[4], 128, a5);
}

void *aj_gray_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v8;
  char *v9;
  uint64_t v10;
  int v11;
  size_t v12;

  v8 = (char *)*a2;
  v9 = (char *)*a3;
  v10 = a4;
  memcpy(*a3, *a2, a4);
  if (a5 > a4)
    memset(&v9[v10], v8[v10 - 1], a5 - a4);
  if (a5 >= 0)
    v11 = a5;
  else
    v11 = a5 + 1;
  v12 = ((v11 >> 1) & 1) + (v11 >> 1);
  memset(a3[2], 128, v12);
  return memset(a3[4], 128, v12);
}

void *aj_gray_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  unsigned __int8 *v10;
  char *v11;
  size_t v12;
  int v13;
  char *v14;
  size_t v15;
  unsigned __int8 *v16;
  char *v17;

  if ((_DWORD)a1 == 1)
  {
    aj_gray_YUV444(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (unsigned __int8 *)*a2;
    v11 = (char *)*a3;
    v12 = a4;
    memcpy(*a3, *a2, a4);
    v13 = a5 - a4;
    if (a5 <= a4)
    {
      memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v14 = &v11[a4];
      v15 = v13;
      memset(v14, v10[v12 - 1], v13);
      v16 = (unsigned __int8 *)a2[1];
      v17 = (char *)a3[1];
      memcpy(v17, v16, v12);
      memset(&v17[v12], v16[v12 - 1], v15);
    }
    memset(a3[2], 128, a5);
    return memset(a3[4], 128, a5);
  }
}

void *aj_gray_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  unsigned __int8 *v10;
  char *v11;
  size_t v12;
  int v13;
  char *v14;
  size_t v15;
  unsigned __int8 *v16;
  char *v17;
  int v18;
  size_t v19;

  if ((_DWORD)a1 == 1)
  {
    aj_gray_YUV422(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (unsigned __int8 *)*a2;
    v11 = (char *)*a3;
    v12 = a4;
    memcpy(*a3, *a2, a4);
    v13 = a5 - a4;
    if (a5 <= a4)
    {
      memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v14 = &v11[a4];
      v15 = v13;
      memset(v14, v10[v12 - 1], v13);
      v16 = (unsigned __int8 *)a2[1];
      v17 = (char *)a3[1];
      memcpy(v17, v16, v12);
      memset(&v17[v12], v16[v12 - 1], v15);
    }
    if (a5 >= 0)
      v18 = a5;
    else
      v18 = a5 + 1;
    v19 = ((v18 >> 1) & 1) + (v18 >> 1);
    memset(a3[2], 128, v19);
    return memset(a3[4], 128, v19);
  }
}

void *aj_gray_to_gray(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  uint64_t v9;
  void *result;

  v7 = (char *)*a2;
  v8 = (char *)*a3;
  v9 = a4;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    return memset(&v8[v9], v7[v9 - 1], a5 - a4);
  return result;
}

_BYTE *aj_YUV_YUV444(uint64_t a1, _BYTE **a2, uint64_t a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  int v9;
  int v10;
  size_t v11;

  result = *(_BYTE **)a3;
  v6 = *(_BYTE **)(a3 + 16);
  v7 = *(_BYTE **)(a3 + 32);
  if (a4 >= 1)
  {
    v8 = *a2;
    v9 = a4;
    do
    {
      *result++ = *v8;
      *v6++ = v8[1];
      *v7++ = v8[2];
      v8 += 3;
      --v9;
    }
    while (v9);
  }
  v10 = a5 - a4;
  if (a5 > a4)
  {
    v11 = v10;
    memset(result, *(result - 1), v10);
    memset(v6, *(v6 - 1), v11);
    return memset(v7, *(v7 - 1), v11);
  }
  return result;
}

_BYTE *aj_YUV_YUV422(uint64_t a1, _BYTE **a2, uint64_t a3, int a4, int a5)
{
  _BYTE *v5;
  _BYTE *result;
  _BYTE *v7;
  _BYTE *v8;
  int v9;
  uint64_t v10;
  signed int v11;
  _BYTE *v12;
  int v13;
  int v14;
  _BYTE *v15;
  char v16;
  char v17;
  int v18;
  size_t v19;

  v5 = *a2;
  result = *(_BYTE **)a3;
  v7 = *(_BYTE **)(a3 + 16);
  v8 = *(_BYTE **)(a3 + 32);
  v9 = a4 - 1;
  if (a4 < 2)
  {
    v11 = 0;
  }
  else
  {
    v10 = 0;
    v11 = a4 & 0xFFFFFFFE;
    do
    {
      v12 = &result[v10];
      *v12 = *v5;
      v13 = v5[1];
      v14 = v5[2];
      v12[1] = v5[3];
      *v7++ = (v5[4] + v13) >> 1;
      v15 = v5 + 6;
      *v8++ = (v5[5] + v14) >> 1;
      v10 += 2;
      v5 += 6;
    }
    while ((int)v10 < v9);
    result += v10;
    v5 = v15;
  }
  if (v11 == v9)
  {
    *result = *v5;
    v16 = v5[1];
    v17 = v5[2];
    result[1] = *v5;
    result += 2;
    *v7++ = v16;
    *v8++ = v17;
    v11 = a4 + 1;
  }
  v18 = a5 - v11;
  if (a5 > v11)
  {
    memset(result, *(result - 1), v18);
    v19 = (uint64_t)v18 >> 1;
    memset(v7, *(v7 - 1), v19);
    return memset(v8, *(v8 - 1), v19);
  }
  return result;
}

_BYTE *aj_YUV_YUV440(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  int v13;
  size_t v14;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV_YUV444(a1, (_BYTE **)a2, a3, a4, a5);
    return memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    v8 = *(_BYTE **)(a3 + 32);
    v10 = *(_BYTE **)(a3 + 8);
    v9 = *(_BYTE **)(a3 + 16);
    result = *(_BYTE **)a3;
    if (a4 >= 1)
    {
      v11 = *(_BYTE **)a2;
      v12 = *(_BYTE **)(a2 + 8);
      v13 = a4;
      do
      {
        *result++ = *v11;
        *v10++ = *v12;
        *v9++ = (v12[1] + v11[1]) >> 1;
        *v8++ = (v12[2] + v11[2]) >> 1;
        v11 += 3;
        v12 += 3;
        --v13;
      }
      while (v13);
    }
    v14 = (a5 - a4);
    if ((int)v14 >= 1)
    {
      memset(result, *(result - 1), v14);
      memset(v10, *(v10 - 1), v14);
      memset(v9, *(v9 - 1), v14);
      return memset(v8, *(v8 - 1), v14);
    }
  }
  return result;
}

_BYTE *aj_YUV_YUV420(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  int v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  signed int v15;
  _BYTE *v16;
  _BYTE *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  _BYTE *v22;
  int v23;
  int v24;
  _BYTE *v25;
  unsigned int v26;
  unsigned int v27;
  int v28;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV_YUV422(a1, (_BYTE **)a2, a3, a4, a5);
    return memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    v8 = *(_BYTE **)(a3 + 32);
    v10 = *(_BYTE **)(a3 + 8);
    v9 = *(_BYTE **)(a3 + 16);
    result = *(_BYTE **)a3;
    v11 = a4 - 1;
    v13 = *(_BYTE **)a2;
    v12 = *(_BYTE **)(a2 + 8);
    if (a4 < 2)
    {
      v15 = 0;
    }
    else
    {
      v14 = 0;
      v15 = a4 & 0xFFFFFFFE;
      do
      {
        v16 = &v10[v14];
        v17 = &result[v14];
        *v17 = *v13;
        *v16 = *v12;
        v18 = v13[1];
        v19 = v12[1];
        v20 = v13[2];
        v21 = v12[2];
        v17[1] = v13[3];
        v16[1] = v12[3];
        LODWORD(v17) = v13[4];
        v22 = v13 + 6;
        v23 = v13[5];
        v24 = v12[5];
        *v9++ = (v18 + v19 + v17 + v12[4] + 2) >> 2;
        v25 = v12 + 6;
        *v8++ = (v20 + v21 + v23 + v24 + 2) >> 2;
        v14 += 2;
        v12 += 6;
        v13 = v22;
      }
      while ((int)v14 < v11);
      v10 += v14;
      result += v14;
      v13 = v22;
      v12 = v25;
    }
    if (v15 == v11)
    {
      *result = *v13;
      *v10 = *v12;
      v26 = v12[1] + v13[1];
      v27 = v12[2] + v13[2];
      result[1] = *result;
      result += 2;
      v10[1] = *v10;
      v10 += 2;
      *v9++ = v26 >> 1;
      *v8++ = v27 >> 1;
      v15 = a4 + 1;
    }
    v28 = a5 - v15;
    if (a5 > v15)
    {
      memset(result, *(result - 1), v28);
      memset(v10, *(v10 - 1), v28);
      memset(v9, *(v9 - 1), (uint64_t)v28 >> 1);
      return memset(v8, *(v8 - 1), (uint64_t)v28 >> 1);
    }
  }
  return result;
}

_BYTE *aj_YUV_to_gray(uint64_t a1, char **a2, _BYTE **a3, int a4, int a5)
{
  _BYTE *result;
  char *v6;
  int v7;
  char v8;

  result = *a3;
  if (a4 >= 1)
  {
    v6 = *a2;
    v7 = a4;
    do
    {
      v8 = *v6;
      v6 += 3;
      *result++ = v8;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4)
    return memset(result, *(result - 1), a5 - a4);
  return result;
}

void *aj_YUV422SEMIP_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  void *result;
  unsigned int v14;
  char *v15;
  char *v16;
  char *v17;
  size_t v18;

  v7 = (char *)a2[2];
  v8 = (char *)a3[2];
  v9 = (char *)a3[4];
  v10 = (char *)*a2;
  v11 = a4;
  v12 = (char *)*a3;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  if (a4 >= 1)
  {
    v14 = (a4 + 1) >> 1;
    do
    {
      *v8 = *v7;
      v15 = v8 + 2;
      v8[1] = *v7;
      *v9 = v7[1];
      v16 = v7 + 2;
      v17 = v9 + 2;
      v9[1] = v7[1];
      v9 += 2;
      v8 += 2;
      v7 += 2;
      --v14;
    }
    while (v14);
    v7 = v16;
    v8 = v15;
    v9 = v17;
  }
  if (a5 > a4)
  {
    v18 = a5 - a4 - (a4 & 1);
    memset(v8, *(v7 - 2), v18);
    return memset(v9, *(v7 - 1), v18);
  }
  return result;
}

void *aj_YUV422SEMIP_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  void *result;
  int v14;
  int v15;
  int v16;
  char *v17;
  int v18;
  size_t v19;

  v7 = (char *)a2[2];
  v8 = (char *)a3[2];
  v9 = (char *)a3[4];
  v10 = (char *)*a2;
  v11 = a4;
  v12 = (char *)*a3;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  v14 = a4 + 2;
  if (a4 >= -1)
    v14 = a4 + 1;
  v15 = v14 >> 1;
  if (a4 >= 1)
  {
    if (v15 <= 1)
      v16 = 1;
    else
      v16 = v15;
    do
    {
      *v8++ = *v7;
      v17 = v7 + 2;
      *v9++ = v7[1];
      v7 += 2;
      --v16;
    }
    while (v16);
    v7 = v17;
  }
  if (a5 > a4)
  {
    v18 = a5 + 2;
    if (a5 >= -1)
      v18 = a5 + 1;
    v19 = (v18 >> 1) - v15;
    memset(v8, *(v7 - 2), v19);
    return memset(v9, *(v7 - 1), v19);
  }
  return result;
}

void *aj_YUV422SEMIP_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  void *result;
  char *v10;
  char *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  char *v14;
  int v15;
  size_t v16;
  unsigned __int8 *v17;
  char *v18;
  int v19;
  int v20;
  int v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  int v24;
  size_t v25;
  unsigned __int8 *v26;
  int v27;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV422SEMIP_YUV422(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (char *)a3[4];
    v11 = (char *)a3[2];
    v12 = (unsigned __int8 *)a2[2];
    v13 = (unsigned __int8 *)a2[3];
    v14 = (char *)*a3;
    v26 = (unsigned __int8 *)*a2;
    memcpy(*a3, *a2, a4);
    v27 = a5;
    v15 = a5 - a4;
    if (a5 <= a4)
    {
      result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v16 = v15;
      memset(&v14[a4], v26[a4 - 1], v15);
      v17 = (unsigned __int8 *)a2[1];
      v18 = (char *)a3[1];
      memcpy(v18, v17, a4);
      result = memset(&v18[a4], v17[a4 - 1], v16);
    }
    v19 = a4 + 2;
    if (a4 >= -1)
      v19 = a4 + 1;
    v20 = v19 >> 1;
    if (a4 >= 1)
    {
      if (v20 <= 1)
        v21 = 1;
      else
        v21 = v20;
      do
      {
        *v11++ = (*v13 + *v12) >> 1;
        v22 = v12 + 2;
        v23 = v13 + 2;
        *v10++ = (v13[1] + v12[1]) >> 1;
        v13 += 2;
        v12 += 2;
        --v21;
      }
      while (v21);
      v12 = v22;
      v13 = v23;
    }
    if (v27 > a4)
    {
      v24 = v27 + 2;
      if (v27 >= -1)
        v24 = v27 + 1;
      v25 = (v24 >> 1) - v20;
      memset(v11, (*(v13 - 2) + *(v12 - 2)) >> 1, v25);
      return memset(v10, (*(v13 - 1) + *(v12 - 1)) >> 1, v25);
    }
  }
  return result;
}

void *aj_YUV422SEMIP_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  void *result;
  char *v10;
  char *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  char *v14;
  int v15;
  size_t v16;
  unsigned __int8 *v17;
  char *v18;
  unsigned int v19;
  unsigned int v20;
  char *v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unsigned int v24;
  char *v25;
  unsigned __int8 *v26;
  int v27;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV422SEMIP_YUV444(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (char *)a3[4];
    v11 = (char *)a3[2];
    v12 = (unsigned __int8 *)a2[2];
    v13 = (unsigned __int8 *)a2[3];
    v14 = (char *)*a3;
    v26 = (unsigned __int8 *)*a2;
    memcpy(*a3, *a2, a4);
    v27 = a5;
    v15 = a5 - a4;
    if (a5 <= a4)
    {
      result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v16 = v15;
      memset(&v14[a4], v26[a4 - 1], v15);
      v17 = (unsigned __int8 *)a2[1];
      v18 = (char *)a3[1];
      memcpy(v18, v17, a4);
      result = memset(&v18[a4], v17[a4 - 1], v16);
    }
    if (a4 >= 1)
    {
      v19 = (a4 + 1) >> 1;
      do
      {
        v20 = (*v13 + *v12) >> 1;
        *v11 = v20;
        v21 = v11 + 2;
        v11[1] = v20;
        v22 = v12 + 2;
        v23 = v13 + 2;
        v24 = (v13[1] + v12[1]) >> 1;
        *v10 = v24;
        v25 = v10 + 2;
        v10[1] = v24;
        v10 += 2;
        v11 += 2;
        v13 += 2;
        v12 += 2;
        --v19;
      }
      while (v19);
      v12 = v22;
      v13 = v23;
      v11 = v21;
      v10 = v25;
    }
    if (v27 > a4)
    {
      memset(v11, (*(v13 - 2) + *(v12 - 2)) >> 1, v27 - a4 - (a4 & 1));
      return memset(v10, (*(v13 - 1) + *(v12 - 1)) >> 1, v27 - a4 - (a4 & 1));
    }
  }
  return result;
}

void *aj_YUV420SEMIP_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  void *result;
  unsigned int v14;
  char *v15;
  char *v16;
  char *v17;
  size_t v18;

  v7 = (char *)a2[2];
  v8 = (char *)a3[2];
  v9 = (char *)a3[4];
  v10 = (char *)*a2;
  v11 = a4;
  v12 = (char *)*a3;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  if (a4 >= 1)
  {
    v14 = (a4 + 1) >> 1;
    do
    {
      *v8 = *v7;
      v15 = v8 + 2;
      v8[1] = *v7;
      *v9 = v7[1];
      v16 = v7 + 2;
      v17 = v9 + 2;
      v9[1] = v7[1];
      v9 += 2;
      v8 += 2;
      v7 += 2;
      --v14;
    }
    while (v14);
    v7 = v16;
    v8 = v15;
    v9 = v17;
  }
  if (a5 > a4)
  {
    v18 = a5 - a4 - (a4 & 1);
    memset(v8, *(v7 - 2), v18);
    return memset(v9, *(v7 - 1), v18);
  }
  return result;
}

void *aj_YUV420SEMIP_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  void *result;
  int v14;
  int v15;
  int v16;
  char *v17;
  int v18;
  size_t v19;

  v7 = (char *)a2[2];
  v8 = (char *)a3[2];
  v9 = (char *)a3[4];
  v10 = (char *)*a2;
  v11 = a4;
  v12 = (char *)*a3;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  v14 = a4 + 2;
  if (a4 >= -1)
    v14 = a4 + 1;
  v15 = v14 >> 1;
  if (a4 >= 1)
  {
    if (v15 <= 1)
      v16 = 1;
    else
      v16 = v15;
    do
    {
      *v8++ = *v7;
      v17 = v7 + 2;
      *v9++ = v7[1];
      v7 += 2;
      --v16;
    }
    while (v16);
    v7 = v17;
  }
  if (a5 > a4)
  {
    v18 = a5 + 2;
    if (a5 >= -1)
      v18 = a5 + 1;
    v19 = (v18 >> 1) - v15;
    memset(v8, *(v7 - 2), v19);
    return memset(v9, *(v7 - 1), v19);
  }
  return result;
}

void *aj_YUV420SEMIP_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  void *result;
  char *v10;
  char *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  char *v14;
  int v15;
  int v16;
  size_t v17;
  unsigned __int8 *v18;
  char *v19;
  int v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  size_t v25;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV420SEMIP_YUV422(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (char *)a3[4];
    v11 = (char *)a3[2];
    v12 = (unsigned __int8 *)a2[2];
    v13 = (unsigned __int8 *)*a2;
    v14 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    v15 = a5 - a4;
    if (a5 <= a4)
    {
      result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v16 = v13[a4 - 1];
      v17 = v15;
      memset(&v14[a4], v16, v15);
      v18 = (unsigned __int8 *)a2[1];
      v19 = (char *)a3[1];
      memcpy(v19, v18, a4);
      result = memset(&v19[a4], v18[a4 - 1], v17);
    }
    v20 = a4 + 2;
    if (a4 >= -1)
      v20 = a4 + 1;
    v21 = v20 >> 1;
    if (a4 >= 1)
    {
      if (v21 <= 1)
        v22 = 1;
      else
        v22 = v21;
      do
      {
        *v11++ = *v12;
        v23 = v12 + 2;
        *v10++ = v12[1];
        v12 += 2;
        --v22;
      }
      while (v22);
      v12 = v23;
    }
    if (a5 > a4)
    {
      v24 = a5 + 2;
      if (a5 >= -1)
        v24 = a5 + 1;
      v25 = (v24 >> 1) - v21;
      memset(v11, *(v12 - 2), v25);
      return memset(v10, *(v12 - 1), v25);
    }
  }
  return result;
}

void *aj_YUV420SEMIP_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  void *result;
  char *v10;
  char *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  char *v14;
  int v15;
  int v16;
  size_t v17;
  unsigned __int8 *v18;
  char *v19;
  unsigned int v20;
  unsigned __int8 v21;
  char *v22;
  unsigned __int8 *v23;
  char v24;
  char *v25;
  size_t v26;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV420SEMIP_YUV444(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (char *)a3[4];
    v11 = (char *)a3[2];
    v12 = (unsigned __int8 *)a2[2];
    v13 = (unsigned __int8 *)*a2;
    v14 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    v15 = a5 - a4;
    if (a5 <= a4)
    {
      result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v16 = v13[a4 - 1];
      v17 = v15;
      memset(&v14[a4], v16, v15);
      v18 = (unsigned __int8 *)a2[1];
      v19 = (char *)a3[1];
      memcpy(v19, v18, a4);
      result = memset(&v19[a4], v18[a4 - 1], v17);
    }
    if (a4 >= 1)
    {
      v20 = (a4 + 1) >> 1;
      do
      {
        v21 = *v12;
        *v11 = *v12;
        v22 = v11 + 2;
        v11[1] = v21;
        v23 = v12 + 2;
        v24 = v12[1];
        v25 = v10 + 2;
        *v10 = v24;
        v10[1] = v24;
        v10 += 2;
        v11 += 2;
        v12 += 2;
        --v20;
      }
      while (v20);
      v12 = v23;
      v11 = v22;
      v10 = v25;
    }
    if (a5 > a4)
    {
      v26 = a5 - a4 - (a4 & 1);
      memset(v11, *(v12 - 2), v26);
      return memset(v10, *(v12 - 1), v26);
    }
  }
  return result;
}

void *aj_YUV440SEMIP_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  void *result;
  int v14;
  char *v15;
  int v16;
  size_t v17;

  v7 = (char *)a2[2];
  v8 = (char *)a3[2];
  v9 = (char *)a3[4];
  v10 = (char *)*a2;
  v11 = a4;
  v12 = (char *)*a3;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  if (a4 >= 1)
  {
    v14 = a4;
    do
    {
      *v8++ = *v7;
      v15 = v7 + 2;
      *v9++ = v7[1];
      v7 += 2;
      --v14;
    }
    while (v14);
    v7 = v15;
  }
  v16 = a5 - a4;
  if (a5 > a4)
  {
    v17 = v16;
    memset(v8, *(v7 - 2), v16);
    return memset(v9, *(v7 - 1), v17);
  }
  return result;
}

void *aj_YUV440SEMIP_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  void *result;
  int v14;
  int v15;
  size_t v16;

  v7 = (char *)a2[2];
  v8 = (char *)a3[2];
  v9 = (char *)a3[4];
  v10 = (char *)*a2;
  v11 = a4;
  v12 = (char *)*a3;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  if (a4 >= 0)
    v14 = a4;
  else
    v14 = a4 + 1;
  if (a4 >= 2)
  {
    v15 = v14 >> 1;
    do
    {
      *v8++ = (v7[2] + *v7) >> 1;
      *v9++ = (v7[3] + v7[1]) >> 1;
      v7 += 4;
      --v15;
    }
    while (v15);
  }
  if ((a4 & 1) != 0)
  {
    *v8++ = *v7;
    *v9++ = v7[1];
    v7 += 2;
  }
  if (a5 > a4)
  {
    v16 = (uint64_t)(a5 - a4 + (a5 - a4 < 0)) >> 1;
    memset(v8, *(v7 - 2), v16);
    return memset(v9, *(v7 - 1), v16);
  }
  return result;
}

void *aj_YUV440SEMIP_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  void *result;
  char *v10;
  char *v11;
  char *v12;
  unsigned __int8 *v13;
  char *v14;
  int v15;
  int v16;
  size_t v17;
  unsigned __int8 *v18;
  char *v19;
  int v20;
  int v21;
  size_t v22;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV440SEMIP_YUV422(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (char *)a3[4];
    v11 = (char *)a3[2];
    v12 = (char *)a2[2];
    v13 = (unsigned __int8 *)*a2;
    v14 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    v15 = a5 - a4;
    if (a5 <= a4)
    {
      result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v16 = v13[a4 - 1];
      v17 = v15;
      memset(&v14[a4], v16, v15);
      v18 = (unsigned __int8 *)a2[1];
      v19 = (char *)a3[1];
      memcpy(v19, v18, a4);
      result = memset(&v19[a4], v18[a4 - 1], v17);
    }
    if (a4 >= 0)
      v20 = a4;
    else
      v20 = a4 + 1;
    if (a4 >= 2)
    {
      v21 = v20 >> 1;
      do
      {
        *v11++ = (v12[2] + *v12) >> 1;
        *v10++ = (v12[3] + v12[1]) >> 1;
        v12 += 4;
        --v21;
      }
      while (v21);
    }
    if ((a4 & 1) != 0)
    {
      *v11++ = *v12;
      *v10++ = v12[1];
      v12 += 2;
    }
    if (a5 > a4)
    {
      v22 = (uint64_t)(a5 - a4 + (a5 - a4 < 0)) >> 1;
      memset(v11, *(v12 - 2), v22);
      return memset(v10, *(v12 - 1), v22);
    }
  }
  return result;
}

void *aj_YUV440SEMIP_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  void *result;
  char *v10;
  char *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  char *v14;
  int v15;
  int v16;
  size_t v17;
  unsigned __int8 *v18;
  char *v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  size_t v23;

  if ((_DWORD)a1 == 1)
  {
    aj_YUV440SEMIP_YUV444(a1, a2, a3, a4, a5);
    return memcpy(a3[1], *a3, a5);
  }
  else
  {
    v10 = (char *)a3[4];
    v11 = (char *)a3[2];
    v12 = (unsigned __int8 *)a2[2];
    v13 = (unsigned __int8 *)*a2;
    v14 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    v15 = a5 - a4;
    if (a5 <= a4)
    {
      result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      v16 = v13[a4 - 1];
      v17 = v15;
      memset(&v14[a4], v16, v15);
      v18 = (unsigned __int8 *)a2[1];
      v19 = (char *)a3[1];
      memcpy(v19, v18, a4);
      result = memset(&v19[a4], v18[a4 - 1], v17);
    }
    if (a4 >= 1)
    {
      v20 = a4;
      do
      {
        *v11++ = *v12;
        v21 = v12 + 2;
        *v10++ = v12[1];
        v12 += 2;
        --v20;
      }
      while (v20);
      v12 = v21;
    }
    v22 = a5 - a4;
    if (a5 > a4)
    {
      v23 = v22;
      memset(v11, *(v12 - 2), v22);
      return memset(v10, *(v12 - 1), v23);
    }
  }
  return result;
}

void *aj_SEMIP_to_gray(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  char *v7;
  char *v8;
  uint64_t v9;
  void *result;

  v7 = (char *)*a2;
  v8 = (char *)*a3;
  v9 = a4;
  result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
    return memset(&v8[v9], v7[v9 - 1], a5 - a4);
  return result;
}

_BYTE *aj_deinterleave_8888(uint64_t a1, _BYTE **a2, uint64_t a3, int a4, int a5)
{
  _BYTE *result;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  int v10;
  int v11;
  size_t v12;

  result = *(_BYTE **)a3;
  v6 = *(_BYTE **)(a3 + 16);
  v7 = *(_BYTE **)(a3 + 32);
  v8 = *(_BYTE **)(a3 + 48);
  if (a4 >= 1)
  {
    v9 = *a2;
    v10 = a4;
    do
    {
      *result++ = *v9;
      *v6++ = v9[1];
      *v7++ = v9[2];
      *v8++ = v9[3];
      v9 += 4;
      --v10;
    }
    while (v10);
  }
  v11 = a5 - a4;
  if (a5 > a4)
  {
    v12 = v11;
    memset(result, *(result - 1), v11);
    memset(v6, *(v6 - 1), v12);
    memset(v7, *(v7 - 1), v12);
    return memset(v8, *(v8 - 1), v12);
  }
  return result;
}

int *aj_col_trans_row(int *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v12;
  int v13;
  int v14;
  void **v15;
  const void **v16;
  uint64_t v17;
  void *v18;
  void *v19;
  const void *v20;
  __int128 v21;
  _QWORD v22[8];

  v5 = result;
  v22[7] = *MEMORY[0x24BDAC8D0];
  v6 = result[8];
  v7 = result[4960];
  v8 = a3 + 8 * a5;
  v9 = *(_QWORD *)(v8 + ((uint64_t)result[4959] << 7));
  v21 = *(_OWORD *)(a3 + 8 * v6 * a5);
  v22[0] = v9;
  v22[1] = 0;
  v22[2] = *(_QWORD *)(v8 + (v7 << 7));
  v22[3] = 0;
  v22[4] = *(_QWORD *)(v8 + 384);
  v22[5] = 0;
  if ((int)a4 > 0)
    return (int *)(*((uint64_t (**)(uint64_t, uint64_t, __int128 *, _QWORD, _QWORD))result + 2468))(a4, a2 + 1832, &v21, result[2], result[3354]);
  if (v6 >= 1)
  {
    v12 = 0;
    v13 = v6 * a5 - 1;
    do
    {
      result = (int *)memcpy((void *)v22[v12 - 2], *(const void **)(a3 + 8 * (v13 + (int)v12)), v5[3354]);
      ++v12;
    }
    while (v12 < v5[8]);
  }
  if (*v5 > 1)
  {
    v14 = a5 - 1;
    v15 = (void **)v22;
    v16 = (const void **)(a3 + 8 * v14 + 128);
    v17 = 1;
    do
    {
      v19 = *v15;
      v15 += 2;
      v18 = v19;
      v20 = *v16;
      v16 += 16;
      result = (int *)memcpy(v18, v20, v5[3354] / v5[4]);
      ++v17;
    }
    while (v17 < *v5);
  }
  return result;
}

uint8x8_t **aj_resize_vertically(uint8x8_t **result, const __int16 *a2, unint64_t a3, int8x8_t *a4)
{
  uint8x8_t *v4;
  uint8x8_t *v5;
  uint8x8_t *v6;
  uint8x8_t *v7;
  uint8x8_t *v8;
  const __int16 *v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  __int16 *v15;
  uint64_t v16;
  uint8x8_t v17;
  uint8x8_t v18;
  uint8x8_t v19;
  uint8x8_t v20;
  uint8x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  BOOL v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;

  if (a3)
  {
    v4 = *result;
    v5 = result[1];
    v6 = result[2];
    v7 = result[3];
    v8 = result[4];
    v10 = vld1q_dup_s16(a2);
    v9 = a2 + 1;
    v11 = vld1q_dup_s16(v9++);
    v12 = vld1q_dup_s16(v9++);
    v13 = vld1q_dup_s16(v9++);
    v14 = vld1q_dup_s16(v9++);
    v15 = (__int16 *)(v9 - 5);
    v16 = a3 >> 3;
    if (a3 >> 3)
    {
      do
      {
        v17 = *v4++;
        v18 = *v5++;
        v19 = *v6++;
        v20 = *v7++;
        v21 = *v8++;
        v22 = (int16x8_t)vmovl_u8(v17);
        v23 = (int16x8_t)vmovl_u8(v18);
        v24 = (int16x8_t)vmovl_u8(v19);
        v25 = (int16x8_t)vmovl_u8(v20);
        v26 = (int16x8_t)vmovl_u8(v21);
        *a4++ = vqmovun_s16(vqrshrn_high_n_s32(vqrshrn_n_s32(vqaddq_s32(vqaddq_s32(vqaddq_s32(vqaddq_s32(vmull_s16(*(int16x4_t *)v22.i8, *(int16x4_t *)v10.i8), vmull_s16(*(int16x4_t *)v23.i8, *(int16x4_t *)v11.i8)), vmull_s16(*(int16x4_t *)v24.i8, *(int16x4_t *)v12.i8)), vmull_s16(*(int16x4_t *)v25.i8, *(int16x4_t *)v13.i8)), vmull_s16(*(int16x4_t *)v26.i8, *(int16x4_t *)v14.i8)), 0xEuLL), vqaddq_s32(vqaddq_s32(vqaddq_s32(vqaddq_s32(vmull_high_s16(v22, v10), vmull_high_s16(v23, v11)), vmull_high_s16(v24, v12)), vmull_high_s16(v25, v13)), vmull_high_s16(v26, v14)),
                    0xEuLL));
        v27 = v16-- <= 1;
      }
      while (!v27);
    }
    v28 = a3 & 7;
    if ((a3 & 7) != 0)
    {
      do
      {
        v29 = v4->u8[0];
        v4 = (uint8x8_t *)((char *)v4 + 1);
        v30 = v29 * *v15;
        v31 = v5->u8[0];
        v5 = (uint8x8_t *)((char *)v5 + 1);
        v32 = v30 + v31 * v15[1];
        v33 = v6->u8[0];
        v6 = (uint8x8_t *)((char *)v6 + 1);
        v34 = v32 + v33 * v15[2];
        v35 = v7->u8[0];
        v7 = (uint8x8_t *)((char *)v7 + 1);
        v36 = v34 + v35 * v15[3];
        v37 = v8->u8[0];
        v8 = (uint8x8_t *)((char *)v8 + 1);
        v38 = (v36 + v37 * v15[4] + 0x2000) >> 14;
        if (v38 <= 0)
          v38 = 0;
        if (v38 >= 255)
          LOBYTE(v38) = -1;
        a4->i8[0] = v38;
        a4 = (int8x8_t *)((char *)a4 + 1);
        v27 = v28-- <= 1;
      }
      while (!v27);
    }
  }
  return result;
}

uint64_t aj_read_com(uint64_t a1)
{
  uint64_t result;
  int v3;
  int v4;

  v4 = 0;
  result = aj_istream_read_bytes_be(a1, &v4, 2);
  if (!(_DWORD)result)
  {
    if (v4 < 3)
    {
      return 0;
    }
    else
    {
      v3 = v4 - 2;
      while (1)
      {
        result = aj_istream_read_bytes_be(a1, &v4, 1);
        if ((_DWORD)result)
          break;
        if (!--v3)
          return 0;
      }
    }
  }
  return result;
}

uint64_t getw_little(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  unsigned int v4;

  v4 = 0;
  result = aj_istream_read_bytes_le(a1, &v4, 4);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t geth_little(uint64_t a1, _WORD *a2)
{
  uint64_t result;
  unsigned int v4;

  v4 = 0;
  result = aj_istream_read_bytes_le(a1, &v4, 2);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t aj_idct_s2(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int16x8_t v6;
  int16x8_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  int16x8_t v11;
  int16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;

  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = vqrdmulhq_lane_s16(vaddq_s16(v3, v5), (int16x4_t)0x6C8361F84546, 0);
  v7 = vaddq_s16(*a1, v4);
  v8 = vsubq_s16(*a1, v4);
  v9 = vaddq_s16(vqrdmulhq_lane_s16(v3, (int16x4_t)0x6C8361F84546, 1), v6);
  v10 = vsubq_s16(vsubq_s16(v6, vqrdmulhq_lane_s16(v5, (int16x4_t)0x6C8361F84546, 2)), v5);
  v11 = vaddq_s16(v7, v9);
  v12 = vaddq_s16(v8, v10);
  v13 = vsubq_s16(v8, v10);
  v14 = vsubq_s16(v7, v9);
  v15 = (int32x4_t)vtrn1q_s16(v11, v12);
  v16 = (int32x4_t)vtrn2q_s16(v11, v12);
  v17 = (int32x4_t)vtrn1q_s16(v13, v14);
  v18 = (int32x4_t)vtrn2q_s16(v13, v14);
  v19 = (int16x8_t)vtrn1q_s32(v15, v17);
  v20 = (int16x8_t)vtrn2q_s32(v15, v17);
  v21 = (int16x8_t)vtrn1q_s32(v16, v18);
  v22 = (int16x8_t)vtrn2q_s32(v16, v18);
  v23 = vqrdmulhq_lane_s16(vaddq_s16(v21, v22), (int16x4_t)0x6C8361F84546, 0);
  v24 = vaddq_s16(v19, v20);
  v25 = vsubq_s16(v19, v20);
  v26 = vaddq_s16(vqrdmulhq_lane_s16(v21, (int16x4_t)0x6C8361F84546, 1), v23);
  v27 = vsubq_s16(vsubq_s16(v23, vqrdmulhq_lane_s16(v22, (int16x4_t)0x6C8361F84546, 2)), v22);
  v28 = vaddq_s16(v24, v26);
  v29 = vaddq_s16(v25, v27);
  v30 = vsubq_s16(v25, v27);
  v31 = vsubq_s16(v24, v26);
  v32 = (int32x4_t)vtrn1q_s16(v28, v29);
  v33 = (int32x4_t)vtrn2q_s16(v28, v29);
  v34 = (int32x4_t)vtrn1q_s16(v30, v31);
  v35 = (int32x4_t)vtrn2q_s16(v30, v31);
  v37 = *a2;
  v38 = a2[1];
  v36 = a2 + 2;
  _X3 = (_DWORD *)(v37 + a3);
  _X4 = (_DWORD *)(v38 + a3);
  _X5 = (_DWORD *)(*v36 + a3);
  _X6 = (_DWORD *)(v36[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  *_X3 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  *_X4 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  *_X5 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  *_X6 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  return 4;
}

uint64_t applejpeg_get_api_number()
{
  return 31;
}

const char *applejpeg_get_git_hash()
{
  return "<APPLEJPEG_GIT_HASH>";
}

const char *applejpeg_get_framework_version()
{
  return "EmbeddedAppleJPEG-220.7";
}

const char *applejpeg_get_build_timestamp()
{
  return "Wed Dec 31 16:00:00 1969";
}

uint64_t aj_extract_info_struct(uint64_t a1)
{
  return a1 + 144;
}

uint64_t aj_extract_istream_struct(uint64_t a1)
{
  return a1 + 24;
}

uint64_t applejpeg_decode_get_headersize(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 3564);
  return result;
}

uint64_t applejpeg_decode_set_parse_option_use_first_sof(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 8;
  if (*(_DWORD *)(a1 + 12928))
  {
    aj_log_error((uint64_t)"Decode", "applejpeg_decode_set_parse_option_use_first_sof must be called before any file is opened");
    return 5;
  }
  else
  {
    result = 0;
    *(_BYTE *)(a1 + 12696) = a2;
  }
  return result;
}

uint64_t applejpeg_decode_open_jpeg_dib(uint64_t a1, uint64_t *a2)
{
  return decode_open(a1, 0, a2, 0, 1);
}

uint64_t applejpeg_decode_open_mem(uint64_t a1, uint64_t *a2)
{
  return decode_open(a1, 0, a2, 0, 0);
}

_OWORD *applejpeg_decode_clone_session(uint64_t a1)
{
  _OWORD *v2;
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  if (*(_DWORD *)(a1 + 12928) == 2 && !*(_DWORD *)(a1 + 12992) && !*(_QWORD *)(a1 + 13064) && !*(_QWORD *)(a1 + 104))
  {
    v4 = applejpeg_decode_create((_QWORD *)a1);
    v2 = v4;
    if (!v4)
      return v2;
    v5 = *(_OWORD *)(a1 + 24);
    v6 = *(_OWORD *)(a1 + 40);
    v7 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)((char *)v4 + 72) = *(_OWORD *)(a1 + 72);
    *(_OWORD *)((char *)v4 + 56) = v7;
    *(_OWORD *)((char *)v4 + 40) = v6;
    *(_OWORD *)((char *)v4 + 24) = v5;
    v8 = *(_OWORD *)(a1 + 88);
    v9 = *(_OWORD *)(a1 + 104);
    v10 = *(_OWORD *)(a1 + 120);
    *((_QWORD *)v4 + 17) = *(_QWORD *)(a1 + 136);
    *(_OWORD *)((char *)v4 + 120) = v10;
    *(_OWORD *)((char *)v4 + 104) = v9;
    *(_OWORD *)((char *)v4 + 88) = v8;
    memcpy(v4 + 9, (const void *)(a1 + 144), 0xD60uLL);
    if (!copy_imagesession((uint64_t)(v2 + 234), (const void **)(a1 + 3744), (_QWORD *)v2 + 1631))
    {
      *((_DWORD *)v2 + 3232) = *(_DWORD *)(a1 + 12928);
      return v2;
    }
    applejpeg_decode_destroy(v2);
  }
  return 0;
}

uint64_t copy_imagesession(uint64_t a1, const void **a2, _QWORD *a3)
{
  int v6;
  int v7;
  void *v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  const void **v19;
  char v20;
  uint64_t v21;
  char v22;
  const void **v23;
  char *v24;
  char *v25;
  uint64_t v26;
  void *v27;
  void *v28;

  memcpy((void *)a1, a2, 0x1B8uLL);
  if (a2[12])
  {
    *(_QWORD *)(a1 + 96) = 0;
    v6 = *(_DWORD *)(a1 + 128);
    v7 = 20 * *(_DWORD *)(a1 + 132);
    v8 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))*a3)((v7 + 8) * v6, *(_QWORD *)(*a3 + 16));
    a3[4] = v8;
    *(_QWORD *)(a1 + 96) = v8;
    if (!v8)
      return 6;
    v9 = 8 * v6;
    bzero(v8, v9 + *(_DWORD *)(a1 + 128) * v7);
    v10 = *(void **)(a1 + 96);
    if (!v10)
      return 6;
    memcpy(v10, a2[12], v9 + *(_DWORD *)(a1 + 128) * v7);
    v11 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 104) = v11;
    v12 = *(unsigned int *)(a1 + 128);
    if ((int)v12 >= 1)
    {
      v13 = 0;
      v14 = v11 + v9;
      v15 = 8 * v12;
      v16 = 20 * *(int *)(a1 + 132);
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 104) + v13) = v14;
        v13 += 8;
        v14 += v16;
      }
      while (v15 != v13);
    }
  }
  v17 = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  v18 = (_OWORD *)(a1 + 8);
  v18[2] = 0u;
  v18[3] = 0u;
  v18[1] = 0u;
  v19 = a2 + 1;
  v20 = 1;
  while (2)
  {
    v21 = 0;
    v22 = v20;
    v23 = &v19[v17];
    v24 = (char *)v18 + 8 * v17;
    do
    {
      v25 = (char *)v23[v21];
      if (v25)
      {
        if (aj_huffman_decode_is_static_table(v25))
        {
          *(_QWORD *)&v24[v21 * 8] = v23[v21];
        }
        else
        {
          v26 = *(_QWORD *)&v24[v21 * 8];
          if (v26)
            (*(void (**)(uint64_t, _QWORD))(*a3 + 8))(v26, *(_QWORD *)(*a3 + 16));
          v27 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))*a3)(4500, *(_QWORD *)(*a3 + 16));
          *(_QWORD *)&v24[v21 * 8] = v27;
          if (!v27 || (bzero(v27, 0x1194uLL), (v28 = *(void **)&v24[v21 * 8]) == 0))
          {
            aj_log_error((uint64_t)"Decode", "Could not allocate memory for huffman table");
            return 6;
          }
          memcpy(v28, v23[v21], 0x1194uLL);
        }
      }
      v21 += 2;
    }
    while (v21 != 8);
    v20 = 0;
    v17 = 1;
    if ((v22 & 1) != 0)
      continue;
    break;
  }
  return 0;
}

uint64_t applejpeg_decode_build_index(uint64_t a1)
{
  uint64_t inited;
  NSObject *os_log_object;

  if (!a1)
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  if (*(_BYTE *)(a1 + 230))
  {
    aj_log_error((uint64_t)"Decode", "Random access table is not supported for lossless JPEGs");
    return 3;
  }
  if ((*(_DWORD *)(a1 + 3688) - 0x10000) < 0xFFFF0001
    || (*(_DWORD *)(a1 + 3692) - 0x10000) <= 0xFFFF0000)
  {
    aj_log_error((uint64_t)"Decode", "Unsupported sampling interval");
    return 8;
  }
  if (*(_BYTE *)(a1 + 228))
    return 0;
  if (*(_QWORD *)(a1 + 104) && (!*(_QWORD *)(a1 + 112) || !*(_QWORD *)(a1 + 96)))
  {
    aj_log_error((uint64_t)"Decode", "rewind or skip callback not provided");
    return 8;
  }
  log_basic_decode_info(OS_LOG_TYPE_DEBUG, a1, 0, (_DWORD *)(a1 + 3744), a1 + 144, a1 + 3584);
  *(_DWORD *)(a1 + 4108) = 0;
  inited = aj_decode_init_index(a1 + 13000, a1 + 13048, (_QWORD *)(a1 + 4192), a1 + 3744, a1 + 11168, (int *)(a1 + 144), a1 + 24, a1 + 3584, a1, *(_DWORD *)(a1 + 3564));
  if ((_DWORD)inited)
    goto LABEL_18;
  if (!*(_DWORD *)(a1 + 11168))
  {
    dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
    return 0;
  }
  inited = aj_create_ra_table_mt(a1 + 4192, (_DWORD *)(a1 + 11168));
  os_log_object = aj_get_os_log_object();
  if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_DEBUG))
  {
    applejpeg_decode_build_index_cold_1();
    if (!(_DWORD)inited)
    {
LABEL_28:
      inited = aj_istream_move_to_position(a1 + 24, *(unsigned int *)(a1 + 3564));
      dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
      if (!(_DWORD)inited)
        return inited;
      goto LABEL_19;
    }
  }
  else if (!(_DWORD)inited)
  {
    goto LABEL_28;
  }
LABEL_18:
  dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
LABEL_19:
  if (*(_QWORD *)(a1 + 3840) && *(_QWORD *)(a1 + 13080))
  {
    (*(void (**)(void))(a1 + 8))();
    *(_QWORD *)(a1 + 3840) = 0;
    *(_QWORD *)(a1 + 13080) = 0;
  }
  *(_DWORD *)(a1 + 3880) = 0;
  if ((_DWORD)inited == -2)
  {
    aj_log_error((uint64_t)"Decode", "IO suspension is not supported for building an index table separately");
    return 9;
  }
  return inited;
}

__n128 applejpeg_decode_build_index_table(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __n128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  if (a1 && a2)
  {
    if (*(_BYTE *)(a1 + 230))
    {
      aj_log_error((uint64_t)"Decode", "Random access table is not supported for lossless JPEGs");
    }
    else
    {
      v16 = *(_OWORD *)(a1 + 3680);
      v17 = *(_OWORD *)(a1 + 3696);
      v18 = *(_QWORD *)(a1 + 3712);
      v12 = *(__n128 *)(a1 + 3616);
      v13 = *(_OWORD *)(a1 + 3632);
      v14 = *(_OWORD *)(a1 + 3648);
      v15 = *(_OWORD *)(a1 + 3664);
      v10 = *(_OWORD *)(a1 + 3584);
      v11 = *(_OWORD *)(a1 + 3600);
      *(_OWORD *)(a1 + 3584) = *(_OWORD *)a2;
      v4 = *(_OWORD *)(a2 + 16);
      v5 = *(_OWORD *)(a2 + 32);
      v6 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 3648) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 3632) = v6;
      *(_OWORD *)(a1 + 3616) = v5;
      *(_OWORD *)(a1 + 3600) = v4;
      v7 = *(_OWORD *)(a2 + 80);
      v8 = *(_OWORD *)(a2 + 96);
      v9 = *(_OWORD *)(a2 + 112);
      *(_QWORD *)(a1 + 3712) = *(_QWORD *)(a2 + 128);
      *(_OWORD *)(a1 + 3696) = v9;
      *(_OWORD *)(a1 + 3680) = v8;
      *(_OWORD *)(a1 + 3664) = v7;
      applejpeg_decode_build_index(a1);
      *(_OWORD *)(a1 + 3664) = v15;
      *(_OWORD *)(a1 + 3680) = v16;
      *(_OWORD *)(a1 + 3696) = v17;
      *(_OWORD *)(a1 + 3600) = v11;
      result = v12;
      *(__n128 *)(a1 + 3616) = v12;
      *(_OWORD *)(a1 + 3632) = v13;
      *(_OWORD *)(a1 + 3648) = v14;
      *(_QWORD *)(a1 + 3712) = v18;
      *(_OWORD *)(a1 + 3584) = v10;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
  }
  return result;
}

uint64_t applejpeg_decode_set_ra_table(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;
  int v7;
  unsigned int v9;
  int v10;
  unsigned __int8 *v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int *v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t i;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  _OWORD v50[11];
  __int128 v51;
  _QWORD v52[2];
  int v53;

  v51 = 0u;
  memset(v50, 0, sizeof(v50));
  if (!a1)
    return 8;
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  if (*(_BYTE *)(a1 + 230))
  {
    aj_log_error((uint64_t)"Decode", "Random access table is not supported for lossless JPEGs");
    return 3;
  }
  if (!a2 || !a3)
  {
    aj_log_error((uint64_t)"Decode", "Table or table size may not be NULL");
    return 8;
  }
  if (a3 >= 0x2800001)
  {
    aj_log_error((uint64_t)"Decode", "Table size may not be larger than %d");
    return 8;
  }
  if ((int)(2 * aj_istream_state_serialized_size()) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Illegal or corrupt RA-table: Table too small to be a RA-table");
    return 8;
  }
  v7 = *(_DWORD *)(a1 + 76);
  if (!v7)
  {
    aj_log_error((uint64_t)"Decode", "File size must be known in order to set a RA-table");
    return 8;
  }
  if (*(_QWORD *)a2 != 0x47504A454C505041 || *(_QWORD *)(a2 + 8) != 0x454843414355434DLL)
  {
    aj_log_error((uint64_t)"Decode", "Illegal or corrupt RA-table: Wrong magic string");
    return 12;
  }
  if (*(_DWORD *)(a2 + 16) != 4)
  {
    aj_log_error((uint64_t)"Decode", "Cache file version is not supported");
    return 12;
  }
  if (*(int *)(a2 + 20) + 24 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Size is smaller than indicated in table header.");
    return 12;
  }
  if (*(_DWORD *)(a2 + 24))
  {
    aj_log_error((uint64_t)"Decode", "Table checksums do not match.");
    return 12;
  }
  if (*(_DWORD *)(a1 + 120) + v7 != *(_DWORD *)(a2 + 28))
  {
    aj_log_error((uint64_t)"Decode", "RA-table image size does not match image");
    return 12;
  }
  v9 = *(_DWORD *)(a2 + 32);
  LODWORD(v50[0]) = v9;
  if (v9 >= 0xA)
  {
    aj_log_error((uint64_t)"Decode", "Illegal number of check states: %u");
    return 12;
  }
  v10 = aj_istream_state_serialized_size();
  if ((unint64_t)(v10 + v10 * v9) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Table size too small to contain expected data");
    return 12;
  }
  v52[0] = 0;
  v52[1] = 0;
  v53 = 0;
  v11 = *(unsigned __int8 **)(a1 + 40);
  if (v11 && *v11 == 217 && *(_DWORD *)(a1 + 48) == -9)
  {
    v12 = 1;
  }
  else
  {
    v13 = aj_istream_state_save(a1 + 24, (uint64_t)v52);
    if ((_DWORD)v13)
    {
      v14 = v13;
      v15 = "Could not save state when setting RA-table";
LABEL_40:
      aj_log_error((uint64_t)"Decode", v15);
      return v14;
    }
    v12 = 0;
  }
  v16 = (int *)(a2 + 36);
  v17 = aj_istream_state_serialized_size();
  if (v9)
  {
    v18 = 0;
    LODWORD(v19) = 0;
    v20 = v17;
    v21 = (char *)v50 + 4;
    do
    {
      aj_istream_state_deserialize((uint64_t)v21, (uint64_t)v16);
      v16 = (int *)((char *)v16 + v20);
      if (check_mcu_table((uint64_t)v21, a1 + 24))
        v19 = 12;
      else
        v19 = v19;
      ++v18;
      v21 += 20;
    }
    while (v18 < v9);
  }
  else
  {
    v19 = 0;
  }
  if ((v12 & 1) != 0)
  {
    aj_reset_mcustate((_QWORD *)(a1 + 11280), a1 + 24);
    v22 = *(unsigned int *)(a1 + 3564);
    if (*(_BYTE *)(a1 + 228))
    {
      if (*(_QWORD *)(a1 + 104))
        v22 = 0;
      else
        v22 = v22;
    }
    v23 = aj_istream_move_to_position(a1 + 24, v22);
  }
  else
  {
    v23 = aj_istream_state_restore(a1 + 24, (uint64_t)v52);
  }
  v14 = v23;
  if ((_DWORD)v23)
    return v14;
  v14 = v19;
  if ((_DWORD)v19)
    return v14;
  v24 = *v16;
  v25 = v16[1];
  v46 = *v16;
  v47 = v25;
  v26 = v16[2];
  v27 = v16[3];
  v48 = v26;
  v49 = v27;
  v14 = 12;
  v15 = "Table data is corrupt";
  if ((*v16 - 0x10000) < 0xFFFF0001
    || (v25 - 0x10000) < 0xFFFF0001
    || (v26 - 0x10000) < 0xFFFF0001
    || v27 < 1
    || v27 >= 0x10000
    || v24 != (v26 + *(_DWORD *)(a1 + 3824) - 1) / v26
    || v25 != (v27 + *(_DWORD *)(a1 + 3828) - 1) / v27)
  {
    goto LABEL_40;
  }
  if ((unint64_t)((v9 + v25 * v24) * aj_istream_state_serialized_size()) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Table size too small to contain expected data");
    return v14;
  }
  *((_QWORD *)&v51 + 1) = v16 + 4;
  v28 = aj_istream_state_serialized_size();
  *(_QWORD *)(a1 + 3864) = 0;
  *(_DWORD *)(a1 + 3860) = v48;
  *(_DWORD *)(a1 + 3856) = v49;
  v29 = v47;
  *(_DWORD *)(a1 + 3876) = v46;
  *(_DWORD *)(a1 + 3872) = v47;
  v30 = 8 * v47;
  v31 = 20 * v46;
  v32 = *(_QWORD *)(a1 + 3840);
  if (v32)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 13048) + 8))(v32, *(_QWORD *)(*(_QWORD *)(a1 + 13048) + 16));
    v29 = *(_DWORD *)(a1 + 3872);
  }
  v33 = (void *)(**(uint64_t (***)(_QWORD, _QWORD))(a1 + 13048))(v30 + v29 * v31, *(_QWORD *)(*(_QWORD *)(a1 + 13048) + 16));
  *(_QWORD *)(a1 + 13080) = v33;
  *(_QWORD *)(a1 + 3840) = v33;
  if (v33 && (bzero(v33, v30 + *(_DWORD *)(a1 + 3872) * v31), (v34 = *(_QWORD *)(a1 + 3840)) != 0))
  {
    *(_QWORD *)(a1 + 3848) = v34;
    v35 = *(unsigned int *)(a1 + 3872);
    if ((int)v35 >= 1)
    {
      v36 = 0;
      v37 = v34 + v30;
      v38 = *(int *)(a1 + 3876);
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 3848) + v36) = v37;
        v36 += 8;
        v37 += 20 * v38;
      }
      while (8 * v35 != v36);
      v39 = 0;
      v40 = *((_QWORD *)&v51 + 1);
      do
      {
        if ((int)v38 >= 1)
        {
          v41 = 0;
          for (i = 0; i < v38; ++i)
          {
            aj_istream_state_deserialize(*(_QWORD *)(*(_QWORD *)(a1 + 3848) + 8 * v39) + v41, v40);
            v40 += v28;
            v38 = *(int *)(a1 + 3876);
            v41 += 20;
          }
          LODWORD(v35) = *(_DWORD *)(a1 + 3872);
        }
        ++v39;
      }
      while (v39 < (int)v35);
    }
    v43 = LODWORD(v50[0]);
    if (LODWORD(v50[0]))
    {
      v44 = a1 + 3888;
      v45 = (char *)v50 + 4;
      do
      {
        *(_OWORD *)v44 = *(_OWORD *)v45;
        *(_DWORD *)(v44 + 16) = *((_DWORD *)v45 + 4);
        v44 += 24;
        v45 += 20;
        --v43;
      }
      while (v43);
    }
    result = 0;
    *(_DWORD *)(a1 + 3880) = 3;
    *(_DWORD *)(a1 + 11168) = 0;
    *(_QWORD *)(a1 + 11184) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Could not allocate memory for RA-table");
    return 6;
  }
  return result;
}

uint64_t applejpeg_decode_get_bytes_read(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 11280);
  if (result)
    return aj_istream_get_pos(result);
  return result;
}

uint64_t applejpeg_decode_get_qtables(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  return _get_qtables_helper(a1, a2, 0, a3, a4);
}

uint64_t _get_qtables_helper(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t result;
  unint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  int v13;
  uint64_t v14;
  _QWORD v15[2];
  _QWORD v16[3];

  v16[2] = *MEMORY[0x24BDAC8D0];
  v16[0] = 0;
  v16[1] = 0;
  v15[0] = 0;
  v15[1] = 0;
  if (!a1 || !a4 || !a5)
  {
    aj_log_error((uint64_t)"Decode", "Function cannot take NULL arguments");
    return 8;
  }
  if (!(a2 | a3))
  {
    aj_log_error((uint64_t)"Decode", "qtable argument may not be NULL");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  if (*(_BYTE *)(a1 + 230))
  {
    result = 0;
    *a4 = 0;
    return result;
  }
  if (*(int *)(a1 + 144) < 1)
  {
    v8 = 0;
LABEL_34:
    result = 0;
    *a4 = v8;
    return result;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  while (1)
  {
    v9 = *(unsigned int *)(a1 + 4 * v6 + 192);
    if (v9 > 3 || !*(_DWORD *)(a1 + 4 * v9 + 1256))
    {
      aj_log_error((uint64_t)"Decode", "The file is referencing an undefined Q table");
      return 4;
    }
    if (!*((_DWORD *)v16 + v9))
      break;
    *(_DWORD *)(a5 + 4 * v6) = *((_DWORD *)v15 + v9);
LABEL_29:
    if (v6 <= 2 && (uint64_t)++v6 < *(int *)(a1 + 144))
      continue;
    goto LABEL_34;
  }
  if (a2)
  {
    v10 = 0;
    v11 = *(_QWORD *)(a2 + 8 * v7);
  }
  else
  {
    v11 = 0;
    v10 = *(_QWORD *)(a3 + 8 * v7);
  }
  if (v11 | v10)
  {
    for (i = 0; i != 64; ++i)
    {
      v13 = *(_DWORD *)(a1 + (v9 << 8) + 232 + i * 4);
      v14 = aj_glob_zigzag[i];
      if (a2)
        *(_BYTE *)(v11 + v14) = v13;
      else
        *(_WORD *)(v10 + 2 * v14) = v13;
    }
    *(_DWORD *)(a5 + 4 * v6) = v7;
    *((_DWORD *)v15 + v9) = v7++;
    ++v8;
    *((_DWORD *)v16 + v9) = 1;
    goto LABEL_29;
  }
  aj_log_error((uint64_t)"Decode", "Null pointer passed as quantization table");
  return 8;
}

uint64_t applejpeg_decode_get_qtables16(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  return _get_qtables_helper(a1, 0, a2, a3, a4);
}

uint64_t applejpeg_decode_get_segment_info(uint64_t a1, unsigned int a2, _OWORD *a3)
{
  uint64_t result;

  if (a1 && a3)
  {
    if (*(_DWORD *)(a1 + 12928) == 2)
    {
      if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 3572) <= (signed int)a2)
      {
        aj_log_error((uint64_t)"Decode", "Index out of bounds");
        return 5;
      }
      else
      {
        result = 0;
        *a3 = *(_OWORD *)(*(_QWORD *)(a1 + 3576) + 16 * a2);
      }
    }
    else
    {
      aj_log_error((uint64_t)"Decode", "Image session not opened");
      return 1;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t applejpeg_decode_get_precision(uint64_t a1)
{
  if (a1 && *(_DWORD *)(a1 + 12928) == 2)
    return *(unsigned int *)(a1 + 148);
  aj_log_error((uint64_t)"Decode", "Invalid session");
  return 0;
}

uint64_t applejpeg_decode_set_option_aspect(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;

  if (!a1)
    return 8;
  if (a2 >= 4)
  {
    aj_log_error((uint64_t)"Decode", "Unknown aspect ratio option: %d", a2);
    return 5;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a1 + 3620) = a2;
    *(_DWORD *)(a1 + 3656) = a3;
    *(_BYTE *)(a1 + 12697) = 0;
  }
  return result;
}

uint64_t applejpeg_decode_set_option_orientation(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
    return 8;
  result = aj_transforms_from_orientation(a2, (_DWORD *)(a1 + 3664), (_DWORD *)(a1 + 3668), (_DWORD *)(a1 + 3672));
  *(_BYTE *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_crop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (!a1)
    return 8;
  if ((a2 & 0x8000000080000000) != 0 || (int)a3 < 1 || a3 <= 0)
  {
    aj_log_error((uint64_t)"Decode", "Invalid cropregion: (%d,%d) %dx%d", a2, HIDWORD(a2), a3, HIDWORD(a3));
    return 5;
  }
  else
  {
    v3 = 0;
    *(_QWORD *)(a1 + 3596) = a2;
    *(_QWORD *)(a1 + 3604) = a3;
    *(_BYTE *)(a1 + 12697) = 0;
  }
  return v3;
}

uint64_t applejpeg_decode_set_option_upsampling(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;

  if (!a1)
    return 8;
  if (*(int *)(a1 + 148) > 8)
    return 0;
  if (a2)
  {
    if (a2 != 1)
    {
      aj_log_error((uint64_t)"Decode", "Unknown upsampling method: %d", a2);
      return 5;
    }
    v3 = 4;
  }
  else
  {
    v3 = 3;
  }
  v2 = 0;
  *(_DWORD *)(a1 + 3680) = v3;
  *(_BYTE *)(a1 + 12697) = 0;
  return v2;
}

uint64_t applejpeg_decode_set_option_callback(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (!a1)
    return 8;
  result = 0;
  *(_QWORD *)(a1 + 3704) = a3;
  *(_QWORD *)(a1 + 3712) = a4;
  *(_DWORD *)(a1 + 3696) = a2;
  *(_BYTE *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_force_app14(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  if (!a1)
    return 8;
  if (a2 < 3)
  {
    result = 0;
    *(_BYTE *)(a1 + 3720) = 1;
    *(_DWORD *)(a1 + 3724) = a2;
    *(_BYTE *)(a1 + 12697) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Unknown App14 transform: %d", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_decode_set_option_alternate_420_prediction(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 8;
  result = 0;
  *(_BYTE *)(a1 + 3736) = a2;
  *(_BYTE *)(a1 + 12697) = 0;
  return result;
}

double applejpeg_decode_options_init(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0x100000001;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 12) = -1;
  *(_QWORD *)(a1 + 20) = -1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = 0x1FF000000;
  *(_OWORD *)(a1 + 96) = xmmword_20627C5A0;
  result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  return result;
}

uint64_t applejpeg_decode_get_planar_output_buffer_size(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t result;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  if (!a1 || *(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 8;
  }
  result = commit_decode_options_if_needed(a1);
  if ((_DWORD)result)
    return result;
  if ((*(_DWORD *)(a1 + 10772) - 25) >= 2)
  {
    aj_log_error((uint64_t)"Decode", "Function can only be called for tri-planar output");
    return 8;
  }
  if (a2)
    *a2 = *(_QWORD *)(a1 + 12816);
  if (a3)
    *a3 = *(int *)(a1 + 4220);
  if (a4)
  {
    v13 = *(_OWORD *)(a1 + 12832);
    v14 = *(_OWORD *)(a1 + 12848);
    *(_QWORD *)(a4 + 32) = *(_QWORD *)(a1 + 12864);
    *(_OWORD *)a4 = v13;
    *(_OWORD *)(a4 + 16) = v14;
  }
  if (a5)
  {
    v15 = *(int *)(a1 + 3824);
    *a5 = *(int *)(a1 + 3816) * (uint64_t)(int)v15;
    a5[1] = v15;
    a5[2] = v15;
    a5[3] = 0;
  }
  result = 0;
  if (a6)
  {
    v16 = *(int *)(a1 + 3828);
    *a6 = *(int *)(a1 + 3820) * (uint64_t)(int)v16;
    a6[1] = v16;
    a6[2] = v16;
    a6[3] = 0;
  }
  return result;
}

uint64_t applejpeg_decode_set_options(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, _DWORD *a6, _DWORD *a7)
{
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t result;

  if (a1 && a2 && a3)
  {
    if (*(_DWORD *)(a1 + 12928) == 2)
    {
      *(_OWORD *)(a1 + 3584) = *(_OWORD *)a2;
      v11 = *(_OWORD *)(a2 + 16);
      v12 = *(_OWORD *)(a2 + 32);
      v13 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 3648) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 3632) = v13;
      *(_OWORD *)(a1 + 3616) = v12;
      *(_OWORD *)(a1 + 3600) = v11;
      v14 = *(_OWORD *)(a2 + 80);
      v15 = *(_OWORD *)(a2 + 96);
      v16 = *(_OWORD *)(a2 + 112);
      *(_QWORD *)(a1 + 3712) = *(_QWORD *)(a2 + 128);
      *(_OWORD *)(a1 + 3696) = v16;
      *(_OWORD *)(a1 + 3680) = v15;
      *(_OWORD *)(a1 + 3664) = v14;
      *(_BYTE *)(a1 + 3720) = 0;
      *(_DWORD *)(a1 + 3724) = 0;
      *(_BYTE *)(a1 + 3728) = 1;
      *(_DWORD *)(a1 + 3732) = 2;
      *(_BYTE *)(a1 + 3736) = 0;
      if (*(int *)(a1 + 148) >= 9)
        *(_DWORD *)(a1 + 3680) = 4;
      *(_BYTE *)(a1 + 12697) = 0;
      if (a4)
      {
        *(_QWORD *)(a4 + 32) = 0;
        *(_OWORD *)a4 = 0u;
        *(_OWORD *)(a4 + 16) = 0u;
      }
      if (a6)
        *a6 = 0;
      if (a7)
        *a7 = 0;
      result = applejpeg_decode_get_output_dimensions((_DWORD *)a1, a6, a7);
      if (!(_DWORD)result)
        return applejpeg_decode_get_output_buffer_size(a1, a3, a5, a4);
    }
    else
    {
      aj_log_error((uint64_t)"Decode", "Image session not opened");
      return 1;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t applejpeg_decode_get_rows_written(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 11208);
  else
    return 0xFFFFFFFFLL;
}

uint64_t applejpeg_decode_image_row_texture(uint64_t a1, uint64_t *a2, uint64_t a3, int *a4)
{
  uint64_t result;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  size_t v17;
  size_t v18;
  uint64_t v19;
  size_t v20;
  size_t v21;
  int v22;
  int v23;
  size_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  size_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  size_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int **v46;
  int v47;
  size_t v48;
  int v49;
  uint64_t v50;
  unint64_t v51;
  _QWORD v52[5];

  v52[4] = *MEMORY[0x24BDAC8D0];
  if (a1 && a2 && *a2 && a4 && a3 && a2[1])
  {
    if (!*(_DWORD *)(a1 + 4100))
    {
      aj_log_error((uint64_t)"Decode", "decode_row_texture is only allowed when recoding.");
      return 3;
    }
    if (*(int *)(a1 + 148) >= 9)
    {
      aj_log_error((uint64_t)"Decode", "Row decoding does not support 12-bit jpeg");
      return 3;
    }
    if (*(_BYTE *)(a1 + 230))
    {
      aj_log_error((uint64_t)"Decode", "Row-wise decompression for LOSSLESS is not implemented.");
      return 3;
    }
    result = commit_decode_options_if_needed(a1);
    if (!(_DWORD)result)
    {
      if (check_decode_row_options(a1 + 3584))
      {
        aj_log_error((uint64_t)"Decode", "Illegal options for row decoding.");
        return 5;
      }
      else if (*(_BYTE *)(a1 + 12904) || (LODWORD(result) = aj_decode_row_init(a1, a3, a2), !(_DWORD)result))
      {
        LODWORD(v9) = 0;
        v10 = 0;
        v46 = (unsigned int **)(a1 + 4192);
        v45 = a1 + 11168;
        v11 = *(int *)(a1 + 10760) + (uint64_t)*(int *)(a1 + 10752);
        v12 = *a2;
        v44 = v12;
        v13 = v11 - 1;
        v14 = *(_DWORD *)(a1 + 4240);
        v15 = *(_DWORD *)(a1 + 12924);
        LODWORD(v16) = *(_DWORD *)(a1 + 4364);
        v50 = *(int *)(a1 + 10728) + (uint64_t)*(int *)(a1 + 10720) - 1;
        v51 = *(int *)(a1 + 10728) + (uint64_t)*(int *)(a1 + 10720);
        while (1)
        {
          v17 = *(_QWORD *)(a1 + 10704);
          v18 = v17 * v10;
          v19 = *(_QWORD *)(a1 + 10736);
          v49 = v9;
          v20 = v12 + 8 * v17 * v14 + v19 * (int)v9;
          v21 = v20 + 8 * v19;
          v22 = *(_DWORD *)(a1 + 10680);
          v23 = v16 * v15;
          if (v15 >= *(_DWORD *)(a1 + 11032) - *(_DWORD *)(a1 + 11028) || v23 >= v22)
            break;
          v25 = v12 + v18;
          v52[0] = v12 + v18;
          v52[1] = v20;
          v48 = v21;
          v52[2] = v21;
          v52[3] = 0;
          if (*(_DWORD *)(a1 + 10772) == 14)
            aj_reset_texture_buffer_ptrs(v46, a1 + 11736, (uint64_t)v52);
          LODWORD(result) = aj_decode_row((uint64_t)v46, v45);
          if ((_DWORD)result)
            goto LABEL_50;
          LODWORD(v16) = *(_DWORD *)(a1 + 4364);
          v26 = v51;
          v47 = v10;
          if (*(_QWORD *)(a1 + 10704) > v51)
          {
            v27 = v50;
            if ((int)v16 >= 1)
            {
              v28 = 0;
              do
              {
                memset((void *)(v25 + v51 + *(_QWORD *)(a1 + 10704) * v28), *(unsigned __int8 *)(v25 + v27 + *(_QWORD *)(a1 + 10704) * v28), *(_QWORD *)(a1 + 10704) - v26);
                v27 = v50;
                v26 = v51;
                ++v28;
                v16 = *(int *)(a1 + 4364);
              }
              while (v28 < v16);
              v10 = v47;
              v12 = v44;
            }
          }
          v14 = *(_DWORD *)(a1 + 4240);
          v29 = (int)v16 / v14;
          if (*(_QWORD *)(a1 + 10736) > v11 && v29 >= 1)
          {
            v30 = 0;
            do
            {
              memset((void *)(v20 + v11 + *(_QWORD *)(a1 + 10736) * v30), *(unsigned __int8 *)(v20 + v13 + *(_QWORD *)(a1 + 10736) * v30), *(_QWORD *)(a1 + 10736) - v11);
              memset((void *)(v48 + v11 + *(_QWORD *)(a1 + 10736) * v30), *(unsigned __int8 *)(v48 + v13 + *(_QWORD *)(a1 + 10736) * v30), *(_QWORD *)(a1 + 10736) - v11);
              ++v30;
              LODWORD(v16) = *(_DWORD *)(a1 + 4364);
              v14 = *(_DWORD *)(a1 + 4240);
              v29 = (int)v16 / v14;
            }
            while (v30 < (int)v16 / v14);
            v10 = v47;
            v12 = v44;
          }
          v10 += v16;
          v9 = (v29 + v49);
          v15 = *(_DWORD *)(a1 + 12924) + 1;
          *(_DWORD *)(a1 + 12924) = v15;
          if ((int)v9 >= 8)
          {
            v23 = v15 * v16;
            v22 = *(_DWORD *)(a1 + 10680);
            if (v23 < v22)
              goto LABEL_55;
            v17 = *(_QWORD *)(a1 + 10704);
            v18 = v17 * v10;
            v19 = *(_QWORD *)(a1 + 10736);
            v49 = v9;
            v20 = v12 + 8 * v14 * v17 + v19 * v9;
            v21 = v20 + 8 * v19;
            break;
          }
        }
        v31 = v21;
        v32 = v23 - v22;
        v33 = v10 - v32;
        v34 = v32 / v14;
        v35 = v49 - v32 / v14;
        v36 = v33;
        if (v33 < 8 * v14)
        {
          v37 = (char *)(v12 + v18 - v17 * v32);
          do
          {
            memcpy(v37, &v37[-v17], v17);
            ++v36;
            v17 = *(_QWORD *)(a1 + 10704);
            v37 += v17;
          }
          while (v36 < 8 * *(_DWORD *)(a1 + 4240));
        }
        if (v35 > 7)
        {
          LODWORD(v9) = v35;
        }
        else
        {
          v38 = v19 * v34;
          v39 = (char *)(v20 - v38);
          v40 = (char *)(v31 - v38);
          v41 = *(_QWORD *)(a1 + 10736);
          v42 = v34 - v49 + 8;
          do
          {
            memcpy(v39, &v39[-v41], v41);
            memcpy(v40, &v40[-*(_QWORD *)(a1 + 10736)], *(_QWORD *)(a1 + 10736));
            v41 = *(_QWORD *)(a1 + 10736);
            v39 += v41;
            v40 += v41;
            --v42;
          }
          while (v42);
          LODWORD(v9) = 8;
        }
        v10 = v36;
LABEL_55:
        result = 0;
        *(_DWORD *)(a3 + 44) = v10;
        *(_QWORD *)(a3 + 24) = v10;
        *(_DWORD *)(a3 + 76) = v9;
        *(_QWORD *)(a3 + 56) = v9;
        v43 = *(_DWORD *)(a1 + 11032) - (*(_DWORD *)(a1 + 11028) + *(_DWORD *)(a1 + 12924));
        *a4 = v43;
        if (*(_DWORD *)(a1 + 4364) * *(_DWORD *)(a1 + 12924) >= *(_DWORD *)(a1 + 10680))
          v43 = 0;
        *a4 = v43;
        if (!v43)
        {
          dec_free_allocations((uint64_t)v46, a1, a1 + 13000, v45);
          result = 0;
          *(_BYTE *)(a1 + 12904) = 0;
        }
      }
      else
      {
LABEL_50:
        if ((_DWORD)result == -2)
          return 9;
        else
          return result;
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t check_decode_row_options(uint64_t a1)
{
  unsigned int v2;
  unint64_t v3;

  if (!*(_DWORD *)(a1 + 80) && !*(_DWORD *)(a1 + 88) && !*(_QWORD *)(a1 + 120))
  {
    v2 = *(_DWORD *)(a1 + 8);
    if (v2 < 7 || v2 - 14 <= 1)
    {
      v3 = 0;
      while (!*(_QWORD *)(a1 + 40 + 8 * v3))
      {
        if (v2 == 14 && v3++ <= 1)
          continue;
        if (*(_DWORD *)(a1 + 100))
          return 5;
        else
          return 0;
      }
    }
  }
  return 5;
}

uint64_t aj_decode_row_init(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  int v19;
  int v20;
  void *v21;
  uint64_t v22;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v6 = (int *)(a1 + 144);
  v7 = a1 + 24;
  *(_DWORD *)(a1 + 4108) = *(_DWORD *)(a1 + 12996);
  *(_QWORD *)(a1 + 12904) = 0;
  *(_QWORD *)(a1 + 12920) = 0;
  *(_QWORD *)(a1 + 12912) = 0;
  v8 = *(_DWORD *)(a1 + 3564);
  if (*(_BYTE *)(a1 + 228) && *(_QWORD *)(a1 + 104))
  {
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v24 = 0u;
    v9 = mmap_multiscan((_QWORD *)(a1 + 13048), a1 + 4112, (uint64_t)&v24, v7, (uint64_t)v6);
    if ((_DWORD)v9)
      return v9;
    v8 = 0;
    *(_QWORD *)(v7 + 112) = v31;
    v11 = v29;
    *(_OWORD *)(v7 + 64) = v28;
    *(_OWORD *)(v7 + 80) = v11;
    *(_OWORD *)(v7 + 96) = v30;
    v12 = v25;
    *(_OWORD *)v7 = v24;
    *(_OWORD *)(v7 + 16) = v12;
    v13 = v27;
    *(_OWORD *)(v7 + 32) = v26;
    *(_OWORD *)(v7 + 48) = v13;
  }
  v14 = aj_decode_init(a1 + 13000, a1 + 13048, a1 + 4192, a1 + 3744, a1 + 11168, v6, v7, a1 + 3584, a1, a3, 1, 1, v8);
  if ((_DWORD)v14)
  {
    v10 = v14;
    dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
  }
  else
  {
    if (*(_DWORD *)(a1 + 10772) == 14)
    {
      v15 = *(_OWORD *)(a1 + 10704);
      v16 = *(_OWORD *)(a1 + 10720);
      v17 = *(_OWORD *)(a1 + 10752);
      *(_OWORD *)(a2 + 48) = *(_OWORD *)(a1 + 10736);
      *(_OWORD *)(a2 + 64) = v17;
      *(_OWORD *)(a2 + 16) = v15;
      *(_OWORD *)(a2 + 32) = v16;
      v18 = *(int *)(a1 + 4364);
      *(_QWORD *)(a2 + 24) = v18;
      v19 = (int)v18 / *(_DWORD *)(a1 + 4240);
      *(_QWORD *)(a2 + 56) = v19;
      *(_DWORD *)(a2 + 44) = v18;
      *(_DWORD *)(a2 + 76) = v19;
    }
    else
    {
      v20 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 12656) + 8))();
      *(_DWORD *)(a1 + 12920) = v20;
      if (*(_QWORD *)(a1 + 13016))
      {
        (*(void (**)(_QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 13016), *(_QWORD *)(a1 + 16));
        v20 = *(_DWORD *)(a1 + 12920);
      }
      v21 = (void *)(*(uint64_t (**)(_QWORD, _QWORD))a1)(*(_QWORD *)(a1 + 12824) * v20, *(_QWORD *)(a1 + 16));
      *(_QWORD *)(a1 + 13016) = v21;
      if (!v21 || (bzero(v21, *(_QWORD *)(a1 + 12824) * *(int *)(a1 + 12920)), (v22 = *(_QWORD *)(a1 + 13016)) == 0))
      {
        aj_log_error((uint64_t)"Decode", "Could not allocate memory for row buffer");
        return 6;
      }
      *(_QWORD *)(a1 + 4256) = v22;
      paint_row_buffer((void *)a1, a1 + 4192, *(_DWORD *)(a1 + 12920));
    }
    v10 = 0;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 3592);
    *(_QWORD *)a2 = *(_QWORD *)(a1 + 10676);
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_BYTE *)(a1 + 12904) = 1;
  }
  return v10;
}

uint64_t applejpeg_decode_image_row(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int32x2_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;

  if (!a1 || !a2 || !*(_QWORD *)a2 || !a4 || !a3 || !*(_QWORD *)(a2 + 8))
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  result = commit_decode_options_if_needed(a1);
  if ((_DWORD)result)
    return result;
  if (*(_QWORD *)(a2 + 8) < *(_QWORD *)(a1 + 12824))
  {
    aj_log_error((uint64_t)"Decode", "Destination buffer size too small (or destination buffer NULL)");
    return 8;
  }
  if (*(_DWORD *)(a1 + 3592) == 14 && !*(_DWORD *)(a1 + 4100))
  {
    aj_log_error((uint64_t)"Decode", "Illegal options for texture format");
    return 3;
  }
  if (*(_BYTE *)(a1 + 230))
  {
    aj_log_error((uint64_t)"Decode", "Row-wise decompression for LOSSLESS is not implemented.");
    return 3;
  }
  if (*(int *)(a1 + 148) >= 9)
  {
    aj_log_error((uint64_t)"Decode", "Row decoding does not support 12-bit jpeg");
    return 3;
  }
  if (check_decode_row_options(a1 + 3584))
  {
    aj_log_error((uint64_t)"Decode", "Illegal options for row decoding.");
    return 5;
  }
  if (*(_BYTE *)(a1 + 12904) || (LODWORD(result) = aj_decode_row_init(a1, a3, (uint64_t *)a2), !(_DWORD)result))
  {
    v9 = *(_DWORD *)(a1 + 12908);
    if (v9 < *(_DWORD *)(a1 + 10680))
    {
      v10 = *(_DWORD *)(a1 + 10776);
      v11 = *(_DWORD *)(a1 + 10696) + v10;
      if (v9 < v10 || v9 >= v11)
      {
        if (!v9 || v9 == v11)
          paint_row_buffer((void *)a1, a1 + 4192, 1);
        v12 = 0;
        *(_QWORD *)(a1 + 12912) = 1;
      }
      else
      {
        if (!*(_DWORD *)(a1 + 12912))
        {
          *(_DWORD *)(a1 + 11204) = 0;
          while (1)
          {
            v16 = aj_decode_row(a1 + 4192, a1 + 11168);
            if (v16)
              break;
            v17 = *(_DWORD *)(a1 + 11204);
            if (v17)
            {
              v12 = 0;
              *(_DWORD *)(a1 + 12912) = v17;
              *(_DWORD *)(a1 + 12916) = 0;
              goto LABEL_41;
            }
          }
          v13 = v16;
          goto LABEL_42;
        }
        v12 = *(int *)(a1 + 12916);
      }
LABEL_41:
      memcpy(*(void **)a2, (const void *)(*(_QWORD *)(a1 + 13016) + *(_QWORD *)(a1 + 12824) * v12), *(_QWORD *)(a1 + 12824));
      v13 = 0;
      result = 0;
      v14 = vadd_s32(*(int32x2_t *)(a1 + 12908), (int32x2_t)0xFFFFFFFF00000001);
      *(int32x2_t *)(a1 + 12908) = v14;
      ++*(_DWORD *)(a1 + 12916);
      if (v14.i32[0] < *(_DWORD *)(a1 + 10680))
      {
LABEL_50:
        *a4 = *(_DWORD *)(a1 + 10680) - *(_DWORD *)(a1 + 12908);
        return result;
      }
LABEL_42:
      if (*(_BYTE *)(a1 + 4144))
        v13 = aj_handle_partial_progressive_decode(a1 + 4192);
      dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
      *(_BYTE *)(a1 + 12904) = 0;
      if (v13 == -2)
        v15 = 9;
      else
        v15 = v13;
      if (v13)
        result = v15;
      else
        result = 0;
      goto LABEL_50;
    }
    aj_log_error((uint64_t)"Decode", "No more rows to write");
    return 1;
  }
  if ((_DWORD)result == -2)
    return 9;
  else
    return result;
}

void *paint_row_buffer(void *result, uint64_t a2, int a3)
{
  void *v5;
  int v6;
  int v7;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15[4];
  uint64_t v16;
  int v17;
  int v18;
  int v19;

  v19 = 0;
  v5 = (void *)*((_QWORD *)result + 1627);
  v6 = *(_DWORD *)(a2 + 6580);
  if (v6 == 15)
  {
    v7 = *((_DWORD *)result + 1025);
    result = (void *)aj_get_internal_format(*((_DWORD *)result + 36), *(unsigned __int8 *)(a2 + 6937), *(_DWORD *)(a2 + 6940));
    if ((_DWORD)result == 5 && v7 == 0)
      v9 = 4;
    else
      v9 = (int)result;
    if (v9 == 5)
    {
      v19 = 8421631;
    }
    else if (v9 == 3)
    {
      v19 = -1;
    }
  }
  else if (v6 == 6)
  {
    *(_WORD *)((char *)&v19 + 1) = -32640;
  }
  v10 = *(_DWORD *)(a2 + 28);
  v11 = *(_DWORD *)(a2 + 6492);
  v12 = v11 * v10;
  v13 = *(_DWORD *)(a2 + 6592);
  v14 = *(_DWORD *)(a2 + 6596);
  if (*(_QWORD *)(a2 + 6592))
  {
    v16 = 0;
    v17 = v13;
    v18 = a3;
    v15[0] = v11 - v14;
    v15[1] = 0;
    v15[2] = v14;
    v15[3] = a3;
    aj_paint_region(v5, *(_DWORD *)(a2 + 6808), (char *)&v19, v10, v11, v11 * v10, a3, (int *)&v16);
    result = aj_paint_region(v5, *(_DWORD *)(a2 + 6808), (char *)&v19, v10, *(_DWORD *)(a2 + 6492), v12, a3, v15);
  }
  if (*(_DWORD *)(a2 + 6584) || *(_DWORD *)(a2 + 6588))
  {
    v16 = 0;
    v17 = *(_DWORD *)(a2 + 6492);
    v18 = a3;
    return aj_paint_region(v5, *(_DWORD *)(a2 + 6808), (char *)&v19, v10, v17, v12, a3, (int *)&v16);
  }
  return result;
}

uint64_t check_mcu_table(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  if (*(unsigned __int8 *)(a1 + 12) >= 5u)
  {
    aj_log_error((uint64_t)"Decode", "Too many check state stream bytes (%d > %d)");
    return 12;
  }
  result = aj_istream_state_restore(a2, a1);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 12))
    {
      v5 = 0;
      while (*(unsigned __int8 *)(a1 + 8 + v5) == *(unsigned __int8 *)(*(_QWORD *)(a2 + 8) + v5))
      {
        if (*(unsigned __int8 *)(a1 + 12) == ++v5)
          return 0;
      }
      aj_log_error((uint64_t)"Decode", "Image data does not match data in supplied RA-table: Stream byte %d differs, 0x%X != 0x%X");
      return 12;
    }
    return 0;
  }
  return result;
}

uint64_t handle_error_from_decode(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (*a5)
  {
    *a5 = 0;
    if (*(_QWORD *)(a3 + 96) && *(_QWORD *)(a2 + 32))
    {
      (*(void (**)(void))(a4 + 8))();
      *(_QWORD *)(a3 + 96) = 0;
      *(_QWORD *)(a2 + 32) = 0;
    }
    *(_DWORD *)(a3 + 136) = 0;
  }
  if ((int)a5[9] >= 1)
    return 0xFFFFFFFFLL;
  else
    return a1;
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

uint8x16_t **aj_icol_row_420_to_bgr565(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint64x2_t v7;
  uint64x2_t v8;
  uint8x8_t v9;
  uint8x16_t *v10;
  uint8x8_t *v11;
  uint8x8_t *v12;
  unsigned int v13;
  uint8x16_t *j;
  uint8x16_t v15;
  uint8x16_t v16;
  uint8x8_t v17;
  uint8x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int16x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int8x8_t v31;
  char *v32;
  int16x8_t v33;
  int16x8_t v34;
  char *v35;
  int16x8_t v36;
  unsigned int v37;
  uint64x2_t v38;
  uint64x2_t v39;
  int16x8_t v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int16x8_t v49;
  int16x8_t v50;
  int16x8_t v51;
  int8x8_t v52;
  int16x8_t v53;
  int16x8_t v54;
  int8x8_t v55;
  int16x8_t v56;
  int8x8_t v57;
  unsigned int i;
  uint8x16_t v59;
  uint8x8_t v60;
  uint8x8_t v61;
  int16x8_t v62;
  int16x8_t v63;
  int16x8_t v64;
  int16x8_t v65;
  int16x8_t v66;
  int16x8_t v67;
  int8x8_t v68;
  char *v69;
  int16x8_t v70;
  unsigned int v71;
  uint64x2_t v72;
  int16x8_t v73;
  int16x8_t v74;
  int16x8_t v75;
  int16x8_t v76;
  int16x8_t v77;
  int16x8_t v78;
  int16x8_t v79;
  int16x8_t v80;
  int16x8_t v81;
  int16x8_t v82;
  int16x8_t v83;
  int16x8_t v84;
  int8x8_t v85;
  int16x8_t v86;
  int8x8_t v87;
  int8x8x2_t v88;
  int8x8x2_t v89;
  int8x8x2_t v90;
  int8x8x2_t v91;

  v9 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  if (a6 >= 1)
  {
    v10 = *result;
    v11 = *a2;
    v12 = *a3;
    if (a6 == 1)
    {
      for (i = a7 >> 4; i; --i)
      {
        v59 = *v10++;
        v60 = *v11++;
        v61 = *v12++;
        v62 = (int16x8_t)vsubl_u8(v60, v9);
        v63 = (int16x8_t)vsubl_u8(v61, v9);
        v64 = vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 3);
        v65 = vmulq_n_s16(v63, 179);
        v66 = vqaddq_s16(vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v63, (int16x4_t)0xE3005B002C00B3, 2));
        v67 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v59.i8, 7uLL);
        v68 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v67, vzip1q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v68, 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v68, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v90);
        v69 = a4 + 16;
        v70 = (int16x8_t)vshll_high_n_u8(v59, 7uLL);
        v90.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v70, vzip2q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v90.val[1], 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v90.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v69, v90);
        a4 = v69 + 16;
      }
      v71 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v72 = *(uint64x2_t *)v10;
        v73 = (int16x8_t)vsubl_u8(*v11, v9);
        v74 = (int16x8_t)vsubl_u8(*v12, v9);
        v75 = vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 3);
        v76 = vmulq_n_s16(v74, 179);
        v77 = vqaddq_s16(vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v74, (int16x4_t)0xE3005B002C00B3, 2));
        v78 = vzip2q_s16(v75, v75);
        v79 = vzip2q_s16(v76, v76);
        v80 = vzip2q_s16(v77, v77);
        v81 = vzip1q_s16(v75, v75);
        v82 = vzip1q_s16(v76, v76);
        v83 = vzip1q_s16(v77, v77);
        if (!(v71 >> 3))
          goto LABEL_16;
        v84 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
        v85 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v84, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v91.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v85, 5uLL));
        v91.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v85, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v91);
        a4 += 16;
        v81 = v78;
        v82 = v79;
        v83 = v80;
        v72.i64[0] = v72.i64[1];
        v71 -= 8;
        if (v71)
        {
LABEL_16:
          v86 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
          v87 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v86, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v87, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v87, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            --v71;
          }
          while (v71);
        }
      }
    }
    else
    {
      v13 = a7 >> 4;
      for (j = result[1]; v13; --v13)
      {
        v15 = *v10++;
        v16 = *j++;
        v17 = *v11++;
        v18 = *v12++;
        v19 = (int16x8_t)vsubl_u8(v17, v9);
        v20 = (int16x8_t)vsubl_u8(v18, v9);
        v21 = vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 3);
        v22 = vmulq_n_s16(v20, 179);
        v23 = vqaddq_s16(vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 2));
        v24 = vzip2q_s16(v21, v21);
        v25 = vzip2q_s16(v22, v22);
        v26 = vzip2q_s16(v23, v23);
        v27 = vzip1q_s16(v21, v21);
        v28 = vzip1q_s16(v22, v22);
        v29 = vzip1q_s16(v23, v23);
        v30 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v15.i8, 7uLL);
        v31 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v30, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v31, 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v31, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v88);
        v32 = a4 + 16;
        v33 = (int16x8_t)vshll_high_n_u8(v15, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v33, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v32, v88);
        a4 = v32 + 16;
        v34 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v16.i8, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v34, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v88);
        v35 = a5 + 16;
        v36 = (int16x8_t)vshll_high_n_u8(v16, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v36, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v35, v88);
        a5 = v35 + 16;
      }
      v37 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        v38 = *(uint64x2_t *)v10;
        v39 = *(uint64x2_t *)j;
        v40 = (int16x8_t)vsubl_u8(*v11, v9);
        v41 = (int16x8_t)vsubl_u8(*v12, v9);
        v42 = vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 3);
        v43 = vmulq_n_s16(v41, 179);
        v44 = vqaddq_s16(vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 2));
        v45 = vzip2q_s16(v42, v42);
        v46 = vzip2q_s16(v43, v43);
        v47 = vzip2q_s16(v44, v44);
        v48 = vzip1q_s16(v42, v42);
        v49 = vzip1q_s16(v43, v43);
        v50 = vzip1q_s16(v44, v44);
        if (!(v37 >> 3))
          goto LABEL_8;
        v51 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
        v52 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v51, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v52, 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v52, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v89);
        a4 += 16;
        v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
        v89.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v53, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v89.val[1], 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v89.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v89);
        a5 += 16;
        v48 = v45;
        v49 = v46;
        v50 = v47;
        v38.i64[0] = v38.i64[1];
        v39.i64[0] = v39.i64[1];
        v37 -= 8;
        if (v37)
        {
LABEL_8:
          v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
          v55 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v54, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v55, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v55, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
          v57 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v56, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v38.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v57, 5uLL));
          *(int8x8_t *)v39.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v57, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            v7 = vshrq_n_u64(v7, 8uLL);
            v8 = vshrq_n_u64(v8, 8uLL);
            *a5 = v38.i8[0];
            a5[1] = v39.i8[0];
            a5 += 2;
            v38 = vshrq_n_u64(v38, 8uLL);
            v39 = vshrq_n_u64(v39, 8uLL);
            --v37;
          }
          while (v37);
        }
      }
    }
  }
  return result;
}

uint64_t aj_BGRA8888_YUV422(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4)
{
  const char *v4;
  int8x8_t *v5;
  uint8x8_t *v6;
  uint8x8_t *v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  unsigned int i;
  const char *v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int8x8_t *v19;
  int8x8x4_t v21;
  int8x8x4_t v22;

  v4 = *a2;
  v5 = *(int8x8_t **)a3;
  v6 = *(uint8x8_t **)(a3 + 16);
  v7 = *(uint8x8_t **)(a3 + 32);
  v8.i64[0] = 0x80008000800080;
  v8.i64[1] = 0x80008000800080;
  v9 = vshlq_n_s16(v8, 7uLL);
  v10.i64[0] = 0x15980E984B232646;
  v10.i64[1] = 0xA6835982A68;
  for (i = a4 >> 4; i; --i)
  {
    v21 = vld4_s8(v4);
    v12 = v4 + 32;
    v22 = vld4_s8(v12);
    v4 = v12 + 32;
    v13 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[2], 7uLL);
    v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[1], 7uLL);
    v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[0], 7uLL);
    v21.val[2] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v14, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v15, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v21.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v14, v10, 4)), vrshrq_n_s16(v15, 1uLL)), 7uLL);
    v21.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v13, 1uLL), vqrdmulhq_laneq_s16(v14, v10, 5)), vqrdmulhq_laneq_s16(v15, v10, 6)), v9), 7uLL);
    v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[2], 7uLL);
    v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[1], 7uLL);
    v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[0], 7uLL);
    v22.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v17, v10, 4)), vrshrq_n_s16(v18, 1uLL)), 7uLL);
    v22.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v16, 1uLL), vqrdmulhq_laneq_s16(v17, v10, 5)), vqrdmulhq_laneq_s16(v18, v10, 6)), v9), 7uLL);
    *v5 = v21.val[2];
    v19 = v5 + 1;
    *v19 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v17, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v5 = v19 + 1;
    *v6++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[1], v22.val[1]), (uint8x8_t)vuzp2_s8(v21.val[1], v22.val[1]));
    *v7++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[0], v22.val[0]), (uint8x8_t)vuzp2_s8(v21.val[0], v22.val[0]));
  }
  if ((a4 & 8) == 0)
    JUMPOUT(0x2062724E0);
  return sub_20627245C();
}

uint64_t sub_20627245C(int16x8_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5, int a6, _DWORD *a7, _DWORD *a8, _QWORD *a9)
{
  int64x2_t v9;
  int64x2_t v10;
  int64x2_t v11;
  int16x8_t v12;
  __int8 *v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  uint64_t result;
  unsigned int v28;
  char v29;
  char v30;
  char v31;
  int8x8x4_t v32;

  v32 = vld4_s8(a3);
  v13 = (__int8 *)(a3 + 32);
  v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[2], 7uLL);
  v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[1], 7uLL);
  v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[0], 7uLL);
  *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v15, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v16, *(int16x4_t *)a1.i8, 2)), 7uLL);
  v32.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v15, a1, 4)), vrshrq_n_s16(v16, 1uLL)), 7uLL);
  v32.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v14, 1uLL), vqrdmulhq_laneq_s16(v15, a1, 5)), vqrdmulhq_laneq_s16(v16, a1, 6)), v12), 7uLL);
  *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[1], v32.val[1]), (uint8x8_t)vuzp2_s8(v32.val[1], v32.val[1]));
  *(uint8x8_t *)v9.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[0], v32.val[0]), (uint8x8_t)vuzp2_s8(v32.val[0], v32.val[0]));
  *a9 = v11.i64[0];
  v17 = a9 + 1;
  *a7 = v10.i32[0];
  v18 = a7 + 1;
  *a8 = v9.i32[0];
  v19 = a8 + 1;
  v20 = a5 & 7;
  if ((a5 & 7) != 0)
  {
    do
    {
      v11 = vshlq_n_s64(v11, 8uLL);
      v10 = vshlq_n_s64(v10, 8uLL);
      v9 = vshlq_n_s64(v9, 8uLL);
      v9.i8[0] = *v13;
      v10.i8[0] = v13[1];
      v11.i8[0] = v13[2];
      v13 += 4;
      --v20;
    }
    while (v20);
    v21 = a5 & 7;
    v22 = 8 - v21;
    v23 = (v21 + 1) >> 1;
    v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v11.i8, 7uLL);
    v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
    v26 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
    *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v25, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v26, *(int16x4_t *)a1.i8, 2)), 7uLL);
    *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v25, a1, 4)), vrshrq_n_s16(v26, 1uLL)), 7uLL);
    *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v24, 1uLL), vqrdmulhq_laneq_s16(v25, a1, 5)), vqrdmulhq_laneq_s16(v26, a1, 6)), v12), 7uLL);
    do
    {
      v11 = vsliq_n_s64(v11, v11, 8uLL);
      v10 = vsliq_n_s64(v10, v10, 8uLL);
      v9 = vsliq_n_s64(v9, v9, 8uLL);
      --v22;
    }
    while (v22);
    *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8));
    *(uint8x8_t *)v9.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v9.i8, *(int8x8_t *)v9.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v9.i8, *(int8x8_t *)v9.i8));
    do
    {
      *v17++ = v11.i8[7];
      v11 = vshlq_n_s64(v11, 8uLL);
      --v21;
    }
    while (v21);
    do
    {
      *v18++ = v10.i8[3];
      *v19++ = v9.i8[3];
      v10 = vshlq_n_s64(v10, 8uLL);
      v9 = vshlq_n_s64(v9, 8uLL);
      --v23;
    }
    while (v23);
  }
  result = (a6 - a5);
  if (a6 != a5)
  {
    v28 = result >> 1;
    v29 = *(v17 - 1);
    v30 = *(v18 - 1);
    v31 = *(v19 - 1);
    do
    {
      *v17++ = v29;
      result = (result - 1);
    }
    while ((_DWORD)result);
    for (; v28; --v28)
    {
      *v18++ = v30;
      *v19++ = v31;
    }
  }
  return result;
}

uint64_t aj_mcu_dct(int *a1, _DWORD *a2)
{
  _DWORD *v2;
  int v4;
  int v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  int8x16_t *v13;
  int32x2_t *v14;
  int *v15;
  int v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v20;
  _DWORD *v21;
  uint64_t v22;
  _DWORD *v23;
  int v24;
  uint8x8_t **v25;
  _DWORD *v26;
  int *v27;
  _DWORD *v28;
  _DWORD *v29;
  int *v30;

  v2 = a2;
  v4 = a2[514];
  if (v4 && v4 == a2[515])
  {
    v5 = (a2[516] + 1) & 7;
    a2[516] = v5;
    result = aj_ostream_write_bytes((uint64_t)(a2 + 482), v5 | 0xFFD0u, 2);
    if ((_DWORD)result)
      return result;
    v7 = *((_QWORD *)v2 + 259);
    if (v7)
    {
      v8 = v2[520] + v2[486] - v2[505] - 2;
      v9 = (int)v2[522];
      v2[522] = v9 + 1;
      *(_DWORD *)(v7 + 4 * v9) = v8;
    }
    v2[515] = 0;
    *((_OWORD *)v2 + 125) = 0u;
  }
  v10 = *a1;
  if (*a1 < 1)
  {
LABEL_19:
    result = 0;
    ++v2[515];
  }
  else
  {
    v11 = 0;
    v12 = a1 + 3368;
    v13 = (int8x16_t *)(v2 + 128);
    v14 = (int32x2_t *)(v2 + 482);
    v27 = a1;
    v28 = v2;
    v26 = a1 + 3368;
    while (1)
    {
      v15 = &a1[v11];
      v16 = v15[8];
      v30 = v15 + 8;
      if (v16 >= 1)
        break;
LABEL_18:
      if (++v11 >= v10)
        goto LABEL_19;
    }
    v17 = 0;
    v20 = v15[4];
    v19 = v15 + 4;
    v18 = v20;
    v21 = &v2[32 * v11];
    v22 = (uint64_t)&v12[392 * v11];
    v23 = &v2[v11 + 500];
    v29 = v21;
    while (v18 < 1)
    {
LABEL_16:
      if (++v17 >= v16)
      {
        a1 = v27;
        v2 = v28;
        v10 = *v27;
        v12 = v26;
        goto LABEL_18;
      }
    }
    v24 = 0;
    v25 = (uint8x8_t **)&v21[2 * (8 * v17)];
    while (1)
    {
      aj_block_dct(v25, v13, (int16x8_t *)(v22 + 540));
      result = aj_block_encode(v22, v13->i16, v14, v23);
      if ((_DWORD)result)
        break;
      v13 += 8;
      ++v24;
      v18 = *v19;
      if (v24 >= *v19)
      {
        v21 = v29;
        v16 = *v30;
        goto LABEL_16;
      }
    }
  }
  return result;
}

uint64_t (*aj_fill_prog_coeff_buf(uint64_t (*result)(), uint8x8_t **a2))()
{
  uint64_t (*v3)();
  int v4;
  int8x16_t *v5;
  int16x8_t *v6;

  if (*((_DWORD *)result + 4) * *((_DWORD *)result + 3358) >= 1)
  {
    v3 = result;
    v4 = 0;
    v5 = (int8x16_t *)*((_QWORD *)result + 2478);
    v6 = (int16x8_t *)((char *)result + 14012);
    do
    {
      result = aj_block_dct(a2, v5, v6);
      ++v4;
      v5 += 8;
    }
    while (v4 < *((_DWORD *)v3 + 4) * *((_DWORD *)v3 + 3358));
  }
  return result;
}

uint64_t aj_bufferproc_savefirst(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned int a4)
{
  _DWORD *v5;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  _DWORD *v11;
  _DWORD *v12;
  unint64_t v13;
  _DWORD *v14;
  int v15;
  unint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v24;
  uint64_t v25;
  _DWORD *v26;
  unsigned int v27;
  int v28;

  v5 = a3;
  if (a3[279] < a3[275] || a3[280] < a3[276])
  {
    v7 = aj_highest_set_bit(*(_DWORD *)(a1 + 44));
    if (*(int *)(a2 + 6464) >= 1)
    {
      v8 = 0;
      v9 = (int)(v7 - 1 + a4) >> (v7 - 1);
      v10 = v5 + 38;
      v11 = v5 + 284;
      v12 = v5 + 142;
      v27 = a4;
      v25 = a2;
      v26 = v5;
      v24 = v9;
      do
      {
        if (v8)
          v13 = v9;
        else
          v13 = a4;
        v14 = &v5[v8];
        v15 = v14[279];
        if (v15 < v14[275] && (int)v13 >= 1)
        {
          v17 = 0;
          v28 = v14[279];
          v18 = &v11[2 * v15];
          v19 = v15 + 1;
          do
          {
            v20 = v17;
            *(_QWORD *)&v18[2 * v17] = aj_rowbuffer_lock_buffer(v10, *(_QWORD *)&v12[2 * v17]);
            v17 = v20 + 1;
          }
          while ((uint64_t)(v19 + v20) < (int)v14[275] && v17 < v13);
          v15 = v28 + v17;
          a4 = v27;
          a2 = v25;
          v5 = v26;
          v9 = v24;
        }
        v14[279] = v15;
        ++v8;
        v11 += 20;
        v12 += 32;
      }
      while (v8 < *(int *)(a2 + 6464));
    }
  }
  return (**(uint64_t (***)(void))(a1 + 80))();
}

uint64_t aj_bufferproc_rgb2yuv(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  BOOL v4;
  uint64_t v5;
  int v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;

  if (*(_BYTE *)(a3 + 1082))
    v4 = 1;
  else
    v4 = a4 < 1;
  if (!v4)
  {
    v5 = 0;
    do
    {
      v6 = *(_DWORD *)(a1 + 48);
      if (v6 >= 1)
      {
        v7 = *(unsigned __int8 **)(a3 + 824 + 8 * v5);
        v8 = *(unsigned __int8 **)(a3 + 696 + 8 * v5);
        v9 = *(unsigned __int8 **)(a3 + 568 + 8 * v5);
        do
        {
          v10 = *v9;
          v11 = *v8;
          v12 = *v7;
          v13 = (v12 << 6)
              - (((707584 * v10 + 0x4000) >> 15)
               + ((1389568 * v11 + 0x4000) >> 15))
              + 16448;
          if (v13 >= 0x8000)
            LOBYTE(v14) = -1;
          else
            v14 = v13 >> 7;
          v15 = (v10 << 6)
              - (((1756160 * v11 + 0x4000) >> 15)
               + ((340992 * v12 + 0x4000) >> 15))
              + 16448;
          if (v15 >= 0x8000)
            LOBYTE(v16) = -1;
          else
            v16 = v15 >> 7;
          *v9++ = (((1254144 * v10 + 0x4000) >> 15)
                 + ((2462080 * v11 + 0x4000) >> 15)
                 + ((478208 * v12 + 0x4000) >> 15)
                 + 64) >> 7;
          *v8++ = v14;
          *v7++ = v16;
          --v6;
        }
        while (v6);
      }
      ++v5;
    }
    while (v5 != a4);
  }
  return (**(uint64_t (***)(void))(a1 + 80))();
}

void aj_bufferproc_upsample_422(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v6;
  void (**v7)(void);
  void *v8;
  uint64_t v10;
  _BYTE *buffer;
  _BYTE *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  void (**v20)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

  v6 = a1;
  v7 = *(void (***)(void))(a1 + 80);
  if (*(_DWORD *)(*a2 + 4) == 12)
    v8 = aj_internal_upsample_422_12bit;
  else
    v8 = aj_internal_upsample_422;
  if (a4)
  {
    v20 = (void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v7;
    if (a4 >= 1)
    {
      v10 = 0;
      v18 = a4;
      v19 = v6;
      do
      {
        buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), a2[839]);
        v12 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), a2[839]);
        v13 = (_QWORD *)(a3 + 8 * v10);
        ((void (*)(_QWORD, _BYTE *, _QWORD))v8)(v13[87], buffer, *(unsigned int *)(v6 + 52));
        ((void (*)(_QWORD, _BYTE *, _QWORD))v8)(v13[103], v12, *(unsigned int *)(v6 + 56));
        v14 = *(_QWORD *)(a3 + 568);
        *(_QWORD *)(a3 + 568) = v13[71];
        v15 = *(_QWORD *)(a3 + 696);
        *(_QWORD *)(a3 + 696) = buffer;
        v16 = *(_QWORD *)(a3 + 824);
        *(_QWORD *)(a3 + 824) = v12;
        (*v20)(v20, a2, a3, 1, (a5 + v10));
        *(_QWORD *)(a3 + 568) = v14;
        v6 = v19;
        *(_QWORD *)(a3 + 696) = v15;
        *(_QWORD *)(a3 + 824) = v16;
        aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)buffer);
        aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v12);
        ++v10;
      }
      while (v18 != v10);
    }
  }
  else
  {
    (*v7)();
  }
}

uint64_t aj_bufferproc_upsample422_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  int v8;

  if (*(_DWORD *)(a1 + 40) == 2 && *(_DWORD *)(a1 + 44) == 1)
  {
    v5 = 0;
    v7 = *(_OWORD *)(a1 + 40);
    v6 = *(_OWORD *)(a1 + 56);
    *(_QWORD *)(a5 + 32) = *(_QWORD *)(a1 + 72);
    *(_OWORD *)a5 = v7;
    *(_OWORD *)(a5 + 16) = v6;
    *(_DWORD *)a5 = 1;
    v8 = *(_DWORD *)(a5 + 8);
    do
    {
      *(_DWORD *)(a5 + 12 + v5) = v8;
      v5 += 4;
    }
    while (v5 != 12);
    return 0;
  }
  else
  {
    aj_log_error(0, "Input format to upsample422, is not 4:2:2");
    return 1;
  }
}

unsigned __int16 *aj_internal_upsample_422_12bit(unsigned __int16 *result, _WORD *a2, int a3)
{
  int v3;
  _WORD *v4;
  int v5;
  unsigned __int16 *v6;
  __int16 v7;
  int v8;
  _WORD *v9;

  v3 = *result;
  *a2 = v3;
  v4 = a2 + 1;
  v5 = a3 - 1;
  if (a3 != 1)
  {
    v6 = result + 1;
    do
    {
      v8 = *v6++;
      v7 = v8;
      *v4 = (3 * v3 + v8 + 1) >> 2;
      v9 = v4 + 2;
      v4[1] = (v3 + 3 * v8 + 2) >> 2;
      v4 += 2;
      v3 = v8;
      --v5;
    }
    while (v5);
    LOWORD(v3) = v7;
    v4 = v9;
  }
  *v4 = v3;
  return result;
}

uint64_t aj_block_encode_ac(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  __int16 *v6;
  int v7;
  unsigned int *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  _BYTE *v18;
  int j;
  uint64_t result;
  unsigned int v21;
  int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  _BYTE *v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  BOOL v34;
  int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  _BYTE *v41;
  int n;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  int v47;
  unsigned int v48;
  _BYTE *v49;
  int i;
  unsigned int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  _BYTE *v56;
  int k;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  int v62;
  int v63;
  _BYTE *v64;
  int m;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  unsigned int v75;
  int v76;
  int v77;
  int v78;
  unsigned int *v79;
  unsigned int *v80;
  unsigned int *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;

  v3 = 62;
  v4 = *(_QWORD *)(a1 + 680);
  v5 = *(_QWORD *)(a1 + 688);
  v6 = (__int16 *)(a2 + 2);
  v9 = *v6;
  v8 = (unsigned int *)(v6 + 1);
  v7 = v9;
  v10 = v9 == 0;
  if (v9)
  {
    v11 = v7 + 16;
    if (v11 >= 0x20)
    {
      if ((int)(v11 - 16) >= 0)
        v43 = v11 - 16;
      else
        v43 = 16 - v11;
      v44 = 32 - __clz(v43);
      if ((int)(v11 - 16) < 0)
        v43 = ~v43;
      v45 = v44 + 16 * v10;
      v15 = (v43 << (32 - v44) >> (32 - v44)) + ((unsigned __int16)*(_DWORD *)(v4 + 4 * v45) << v44);
      v14 = v44 + HIWORD(*(_DWORD *)(v4 + 4 * v45));
      if (v14 > 24)
        goto LABEL_76;
      v46 = *(_DWORD *)(a3 + 20);
      if (v46 <= 8)
        goto LABEL_76;
      v47 = v14 + *(_DWORD *)(a3 + 4);
      v48 = *(_DWORD *)a3 | (v15 << (32 - v47));
      v49 = *(_BYTE **)(a3 + 8);
      for (i = *(_DWORD *)(a3 + 16); v47 >= 8; v48 <<= 8)
      {
        *v49++ = HIBYTE(v48);
        --v46;
        ++i;
        if (HIBYTE(v48) == 255)
        {
          *v49++ = 0;
          --v46;
          ++i;
        }
        v47 -= 8;
      }
      *(_DWORD *)a3 = v48;
      *(_DWORD *)(a3 + 4) = v47;
      *(_QWORD *)(a3 + 8) = v49;
      *(_DWORD *)(a3 + 16) = i;
      *(_DWORD *)(a3 + 20) = v46;
    }
    else
    {
      v12 = *(_DWORD *)(a3 + 20);
      v13 = *(_DWORD *)(v5 + 4 * v11);
      v14 = HIBYTE(v13);
      v15 = v13 & 0xFFFFFF;
      if (v12 <= 8)
        goto LABEL_76;
      v16 = v14 + *(_DWORD *)(a3 + 4);
      v17 = *(_DWORD *)a3 | (v15 << (32 - v16));
      v18 = *(_BYTE **)(a3 + 8);
      for (j = *(_DWORD *)(a3 + 16); v16 >= 8; v17 <<= 8)
      {
        *v18++ = HIBYTE(v17);
        --v12;
        ++j;
        if (HIBYTE(v17) == 255)
        {
          *v18++ = 0;
          --v12;
          ++j;
        }
        v16 -= 8;
      }
      *(_DWORD *)a3 = v17;
      *(_DWORD *)(a3 + 4) = v16;
      *(_QWORD *)(a3 + 8) = v18;
      *(_DWORD *)(a3 + 16) = j;
      *(_DWORD *)(a3 + 20) = v12;
    }
  }
LABEL_12:
  v21 = *v8++;
  result = v21;
  if (!v21)
  {
    v10 += 2;
LABEL_10:
    --v3;
    goto LABEL_11;
  }
  if ((_DWORD)result << 16)
    v22 = (_DWORD)result << 16;
  else
    v22 = result;
  --v3;
  v23 = v22 >> 16;
  if ((_DWORD)result << 16)
    ++v3;
  else
    ++v10;
  if (v10 >> 4)
  {
LABEL_54:
    while (1)
    {
      v10 -= 16;
      v51 = (unsigned __int16)*(_DWORD *)(v4 + 960);
      v52 = HIWORD(*(_DWORD *)(v4 + 960));
      v53 = *(_DWORD *)(a3 + 20);
      if (v53 <= 8)
        goto LABEL_83;
      v54 = v52 + *(_DWORD *)(a3 + 4);
      v55 = *(_DWORD *)a3 | (v51 << (32 - v54));
      v56 = *(_BYTE **)(a3 + 8);
      for (k = *(_DWORD *)(a3 + 16); v54 >= 8; v55 <<= 8)
      {
        *v56++ = HIBYTE(v55);
        --v53;
        ++k;
        if (HIBYTE(v55) == 255)
        {
          *v56++ = 0;
          --v53;
          ++k;
        }
        v54 -= 8;
      }
      *(_DWORD *)a3 = v55;
      *(_DWORD *)(a3 + 4) = v54;
      *(_QWORD *)(a3 + 8) = v56;
      *(_DWORD *)(a3 + 16) = k;
      *(_DWORD *)(a3 + 20) = v53;
      if (!(v10 >> 4))
      {
        v23 = (__int16)result;
        if ((v3 & 1) != 0)
          v23 = (int)result >> 16;
        goto LABEL_20;
      }
    }
  }
  do
  {
LABEL_20:
    while (1)
    {
      v24 = v23 + 16;
      if (v24 < 0x20 && v10 < 8)
        break;
      if ((int)(v24 - 16) >= 0)
        v58 = v24 - 16;
      else
        v58 = 16 - v24;
      v59 = 32 - __clz(v58);
      if ((int)(v24 - 16) < 0)
        v58 = ~v58;
      v60 = v59 + 16 * v10;
      v10 = 0;
      v61 = (v58 << (32 - v59) >> (32 - v59)) + ((unsigned __int16)*(_DWORD *)(v4 + 4 * v60) << v59);
      v62 = v59 + HIWORD(*(_DWORD *)(v4 + 4 * v60));
      v29 = v62;
      v30 = v61;
      if (v62 > 24 || (v63 = *(_DWORD *)(a3 + 20), v63 <= 8))
      {
LABEL_78:
        v80 = v8;
        v83 = a3;
        v77 = v3;
        v69 = v5;
        v72 = result;
        v66 = v4;
        v34 = aj_ostream_write((unsigned int *)a3, v30, v29) == 0;
        v4 = v66;
        v5 = v69;
        result = v72;
        v10 = 0;
        v3 = v77;
        v8 = v80;
        a3 = v83;
        if (!v34)
          return result;
        if ((v77 & 1) != 0)
        {
LABEL_11:
          if (!--v3)
            goto LABEL_29;
          goto LABEL_12;
        }
        v23 = (int)v72 >> 16;
        v10 = (int)v72 >> 16 == 0;
        if (!((int)v72 >> 16))
          goto LABEL_10;
        v3 = v77 - 1;
        if (v77 == 1)
        {
LABEL_83:
          v81 = v8;
          v84 = a3;
          v75 = v10;
          v78 = v3;
          v70 = v5;
          v73 = result;
          v67 = v4;
          v34 = aj_ostream_write((unsigned int *)a3, v51, v52) == 0;
          v4 = v67;
          v5 = v70;
          result = v73;
          v10 = v75;
          v3 = v78;
          v8 = v81;
          a3 = v84;
          if (!v34)
            return result;
          if (v75 >> 4)
            goto LABEL_54;
          v23 = (__int16)v73;
          if ((v78 & 1) != 0)
            v23 = (int)v73 >> 16;
        }
      }
      else
      {
        v14 = v62 + *(_DWORD *)(a3 + 4);
        v15 = *(_DWORD *)a3 | (v61 << (32 - v14));
        v64 = *(_BYTE **)(a3 + 8);
        for (m = *(_DWORD *)(a3 + 16); v14 >= 8; v15 <<= 8)
        {
          *v64++ = HIBYTE(v15);
          --v63;
          ++m;
          if (HIBYTE(v15) == 255)
          {
            *v64++ = 0;
            --v63;
            ++m;
          }
          v14 -= 8;
        }
        *(_DWORD *)a3 = v15;
        *(_DWORD *)(a3 + 4) = v14;
        *(_QWORD *)(a3 + 8) = v64;
        *(_DWORD *)(a3 + 16) = m;
        *(_DWORD *)(a3 + 20) = v63;
        if ((v3 & 1) != 0)
          goto LABEL_11;
        v23 = (int)result >> 16;
        v10 = (int)result >> 16 == 0;
        if (!((int)result >> 16))
          goto LABEL_10;
        if (!--v3)
        {
LABEL_76:
          v79 = v8;
          v82 = a3;
          v74 = v10;
          v76 = v3;
          v68 = v5;
          v71 = v4;
          result = aj_ostream_write((unsigned int *)a3, v15, v14);
          v5 = v68;
          v4 = v71;
          v10 = v74;
          v3 = v76;
          v8 = v79;
          a3 = v82;
          if (result)
            return result;
          goto LABEL_12;
        }
      }
    }
    v25 = *(_DWORD *)(v5 + 4 * (v24 + 32 * v10));
    v26 = *(_BYTE **)(a3 + 8);
    v27 = *(_DWORD *)(a3 + 16);
    v28 = *(_DWORD *)(a3 + 20);
    v10 = 0;
    v29 = HIBYTE(v25);
    v30 = v25 & 0xFFFFFF;
    if (v28 <= 8)
      goto LABEL_78;
    v31 = *(_DWORD *)(a3 + 4) + v29;
    v32 = *(_DWORD *)a3 | (v30 << (32 - v31));
    while (v31 >= 8)
    {
      while (1)
      {
        v33 = HIBYTE(v32);
        ++v27;
        --v28;
        *v26++ = HIBYTE(v32);
        v34 = HIBYTE(v32) == 255;
        v31 -= 8;
        v32 <<= 8;
        if (v33 == 255)
          break;
        if (v31 < 8)
          goto LABEL_26;
      }
      if (v34)
      {
        *v26++ = 0;
        --v28;
        ++v27;
      }
    }
LABEL_26:
    *(_DWORD *)a3 = v32;
    *(_DWORD *)(a3 + 4) = v31;
    *(_QWORD *)(a3 + 8) = v26;
    *(_DWORD *)(a3 + 16) = v27;
    *(_DWORD *)(a3 + 20) = v28;
    if ((v3 & 1) != 0)
      goto LABEL_11;
    v23 = (int)result >> 16;
    v10 = (int)result >> 16 == 0;
    if (!((int)result >> 16))
      goto LABEL_10;
    --v3;
  }
  while (v3);
LABEL_29:
  if (!v10)
    return 0;
  v35 = *(_DWORD *)(a3 + 20);
  v36 = *(_DWORD *)(v5 + 64);
  v37 = HIBYTE(v36);
  v38 = v36 & 0xFFFFFF;
  if (v35 <= 8)
  {
    result = aj_ostream_write((unsigned int *)a3, v38, v37);
    if (!result)
      return 0;
  }
  else
  {
    v39 = v37 + *(_DWORD *)(a3 + 4);
    v40 = *(_DWORD *)a3 | (v38 << (32 - v39));
    v41 = *(_BYTE **)(a3 + 8);
    for (n = *(_DWORD *)(a3 + 16); v39 >= 8; v40 <<= 8)
    {
      *v41++ = HIBYTE(v40);
      --v35;
      ++n;
      if (HIBYTE(v40) == 255)
      {
        *v41++ = 0;
        --v35;
        ++n;
      }
      v39 -= 8;
    }
    *(_DWORD *)a3 = v40;
    *(_DWORD *)(a3 + 4) = v39;
    *(_QWORD *)(a3 + 8) = v41;
    *(_DWORD *)(a3 + 16) = n;
    *(_DWORD *)(a3 + 20) = v35;
    return 0;
  }
  return result;
}

unint64_t aj_BGRA8888_YUV420(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4, size_t a5)
{
  int64x2_t v5;
  int64x2_t v6;
  int64x2_t v7;
  int64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  unint64_t result;
  const char *v12;
  const char *v13;
  int8x8_t *v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  unsigned int i;
  const char *v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  int16x8_t v27;
  int16x8_t v28;
  uint8x16_t v29;
  uint8x16_t v30;
  int8x8_t *v31;
  const char *v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint8x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x8_t v47;
  int16x8_t v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  int16x8_t v53;
  int16x8_t v54;
  int16x8_t v55;
  int16x8_t v56;
  int16x8_t v57;
  int16x8_t v58;
  unsigned int v59;
  __int8 v60;
  char v61;
  char v62;
  char v63;
  int8x8x4_t v66;
  int8x8x4_t v67;
  int8x8x4_t v68;
  int8x8x4_t v69;
  int8x8x4_t v70;

  if ((_DWORD)a1 == 1)
  {
    aj_BGRA8888_YUV422(a1, a2, a3, a4);
    return (unint64_t)memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    v12 = a2[1];
    v13 = *a2;
    v14 = *(int8x8_t **)a3;
    v15 = *(_BYTE **)(a3 + 8);
    v16 = *(_BYTE **)(a3 + 16);
    v17 = *(_BYTE **)(a3 + 32);
    v18.i64[0] = 0x80008000800080;
    v18.i64[1] = 0x80008000800080;
    v19 = vshlq_n_s16(v18, 7uLL);
    v20.i64[0] = 0x15980E984B232646;
    v20.i64[1] = 0xA6835982A68;
    for (i = a4 >> 4; i; --i)
    {
      v66 = vld4_s8(v13);
      v22 = v13 + 32;
      v68 = vld4_s8(v22);
      v13 = v22 + 32;
      v23 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[2], 7uLL);
      v24 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[1], 7uLL);
      v25 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[0], 7uLL);
      v66.val[2] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v66.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v24, v20, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
      v66.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v20, 5)), vqrdmulhq_laneq_s16(v25, v20, 6)), v19), 7uLL);
      v26 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[2], 7uLL);
      v27 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[1], 7uLL);
      v28 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[0], 7uLL);
      v29.i64[0] = (uint64_t)v66.val[1];
      v29.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v27, v20, 4)), vrshrq_n_s16(v28, 1uLL)), 7uLL);
      v30.i64[0] = (uint64_t)v66.val[0];
      v30.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v26, 1uLL), vqrdmulhq_laneq_s16(v27, v20, 5)), vqrdmulhq_laneq_s16(v28, v20, 6)), v19), 7uLL);
      *v14 = v66.val[2];
      v31 = v14 + 1;
      *v31 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v27, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v28, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v14 = v31 + 1;
      v67 = vld4_s8(v12);
      v32 = v12 + 32;
      v69 = vld4_s8(v32);
      v12 = v32 + 32;
      v33 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[2], 7uLL);
      v34 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[1], 7uLL);
      v35 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[0], 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v34, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v35, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v67.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v34, v20, 4)), vrshrq_n_s16(v35, 1uLL)), 7uLL);
      v67.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v33, 1uLL), vqrdmulhq_laneq_s16(v34, v20, 5)), vqrdmulhq_laneq_s16(v35, v20, 6)), v19), 7uLL);
      v36 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[2], 7uLL);
      v37 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[1], 7uLL);
      v38 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[0], 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v37, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v38, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v37, v20, 4)), vrshrq_n_s16(v38, 1uLL)), 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v36, 1uLL), vqrdmulhq_laneq_s16(v37, v20, 5)), vqrdmulhq_laneq_s16(v38, v20, 6)), v19), 7uLL);
      *(_QWORD *)v15 = v7.i64[0];
      v39 = v15 + 8;
      *v39 = v10.i64[0];
      v15 = v39 + 1;
      v40 = v9.i64[0];
      v41 = v8.i64[0];
      v6 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[1].i8), (int16x8_t)vpaddlq_u8(v29));
      v5 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[0].i8), (int16x8_t)vpaddlq_u8(v30));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v5.i8 = vqrshrn_n_u16((uint16x8_t)v5, 2uLL);
      *(_QWORD *)v16 = v6.i64[0];
      v16 += 8;
      *(_QWORD *)v17 = v5.i64[0];
      v17 += 8;
    }
    if ((a4 & 8) != 0)
    {
      *(int8x8x4_t *)v5.i8 = vld4_s8(v13);
      v13 += 32;
      v70 = vld4_s8(v12);
      v12 += 32;
      v43 = (int16x8_t)vshll_n_u8(v42, 7uLL);
      v44 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      v45 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v44, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v45, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v44, v20, 4)), vrshrq_n_s16(v45, 1uLL)), 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v43, 1uLL), vqrdmulhq_laneq_s16(v44, v20, 5)), vqrdmulhq_laneq_s16(v45, v20, 6)), v19), 7uLL);
      v46 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[2], 7uLL);
      v47 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[1], 7uLL);
      v48 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[0], 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v47, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v48, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *v14++ = *(int8x8_t *)v7.i8;
      *(_QWORD *)v15 = v10.i64[0];
      v15 += 8;
      *(uint16x4_t *)v9.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v47, v20, 4)), vrshrq_n_s16(v48, 1uLL)), 7uLL));
      *(uint16x4_t *)v8.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v46, 1uLL), vqrdmulhq_laneq_s16(v47, v20, 5)), vqrdmulhq_laneq_s16(v48, v20, 6)), v19), 7uLL));
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), *(int16x4_t *)v9.i8);
      *(int16x4_t *)v5.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v5.i8), *(int16x4_t *)v8.i8);
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v5.i8 = vqrshrn_n_u16((uint16x8_t)v5, 2uLL);
      *(_DWORD *)v16 = v6.i32[0];
      v16 += 4;
      *(_DWORD *)v17 = v5.i32[0];
      v17 += 4;
    }
    v49 = a4 & 7;
    if ((a4 & 7) != 0)
    {
      do
      {
        v7 = vshlq_n_s64(v7, 8uLL);
        v6 = vshlq_n_s64(v6, 8uLL);
        v5 = vshlq_n_s64(v5, 8uLL);
        v10 = vshlq_n_s64(v10, 8uLL);
        v9 = vshlq_n_s64(v9, 8uLL);
        v8 = vshlq_n_s64(v8, 8uLL);
        v5.i8[0] = *v13;
        v6.i8[0] = v13[1];
        v7.i8[0] = v13[2];
        v13 += 4;
        v8.i8[0] = *v12;
        v9.i8[0] = v12[1];
        v10.i8[0] = v12[2];
        v12 += 4;
        --v49;
      }
      while (v49);
      v50 = a4 & 7;
      v51 = 8 - v50;
      v52 = (v50 + 1) >> 1;
      v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v54, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v55, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v54, v20, 4)), vrshrq_n_s16(v55, 1uLL)), 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v53, 1uLL), vqrdmulhq_laneq_s16(v54, v20, 5)), vqrdmulhq_laneq_s16(v55, v20, 6)), v19), 7uLL);
      v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
      v57 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
      v58 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v8.i8, 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v57, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v58, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v57, v20, 4)), vrshrq_n_s16(v58, 1uLL)), 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v56, 1uLL), vqrdmulhq_laneq_s16(v57, v20, 5)), vqrdmulhq_laneq_s16(v58, v20, 6)), v19), 7uLL);
      do
      {
        v7 = vsliq_n_s64(v7, v7, 8uLL);
        v6 = vsliq_n_s64(v6, v6, 8uLL);
        v5 = vsliq_n_s64(v5, v5, 8uLL);
        v10 = vsliq_n_s64(v10, v10, 8uLL);
        v9 = vsliq_n_s64(v9, v9, 8uLL);
        v8 = vsliq_n_s64(v8, v8, 8uLL);
        --v51;
      }
      while (v51);
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v9.i8));
      *(int16x4_t *)v5.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v5.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v8.i8));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v5.i8 = vqrshrn_n_u16((uint16x8_t)v5, 2uLL);
      do
      {
        v14->i8[0] = v7.i8[7];
        v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v10.i8[7];
        v7 = vshlq_n_s64(v7, 8uLL);
        v10 = vshlq_n_s64(v10, 8uLL);
        --v50;
      }
      while (v50);
      do
      {
        *v16++ = v6.i8[3];
        *v17++ = v5.i8[3];
        v6 = vshlq_n_s64(v6, 8uLL);
        v5 = vshlq_n_s64(v5, 8uLL);
        --v52;
      }
      while (v52);
    }
    result = a5 - a4;
    if ((_DWORD)a5 != a4)
    {
      v59 = result >> 1;
      v60 = v14[-1].i8[7];
      v61 = *(v15 - 1);
      v62 = *(v16 - 1);
      v63 = *(v17 - 1);
      do
      {
        v14->i8[0] = v60;
        v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v61;
        result = (result - 1);
      }
      while ((_DWORD)result);
      for (; v59; --v59)
      {
        *v16++ = v62;
        *v17++ = v63;
      }
    }
  }
  return result;
}

uint64_t aj_RGB888_YUV422(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4)
{
  const char *v4;
  int8x8_t *v5;
  uint8x8_t *v6;
  uint8x8_t *v7;
  int16x8_t v8;
  int16x8_t v9;
  int16x8_t v10;
  unsigned int i;
  const char *v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int8x8_t *v19;
  int8x8x3_t v21;
  int8x8x3_t v22;

  v4 = *a2;
  v5 = *(int8x8_t **)a3;
  v6 = *(uint8x8_t **)(a3 + 16);
  v7 = *(uint8x8_t **)(a3 + 32);
  v8.i64[0] = 0x80008000800080;
  v8.i64[1] = 0x80008000800080;
  v9 = vshlq_n_s16(v8, 7uLL);
  v10.i64[0] = 0x15980E984B232646;
  v10.i64[1] = 0xA6835982A68;
  for (i = a4 >> 4; i; --i)
  {
    v21 = vld3_s8(v4);
    v12 = v4 + 24;
    v22 = vld3_s8(v12);
    v4 = v12 + 24;
    v13 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[0], 7uLL);
    v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[1], 7uLL);
    v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[2], 7uLL);
    v21.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v14, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v15, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v21.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v14, v10, 4)), vrshrq_n_s16(v15, 1uLL)), 7uLL);
    v21.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v13, 1uLL), vqrdmulhq_laneq_s16(v14, v10, 5)), vqrdmulhq_laneq_s16(v15, v10, 6)), v9), 7uLL);
    v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[0], 7uLL);
    v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[1], 7uLL);
    v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[2], 7uLL);
    v22.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v17, v10, 4)), vrshrq_n_s16(v18, 1uLL)), 7uLL);
    v22.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v16, 1uLL), vqrdmulhq_laneq_s16(v17, v10, 5)), vqrdmulhq_laneq_s16(v18, v10, 6)), v9), 7uLL);
    *v5 = v21.val[0];
    v19 = v5 + 1;
    *v19 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v17, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v5 = v19 + 1;
    *v6++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[1], v22.val[1]), (uint8x8_t)vuzp2_s8(v21.val[1], v22.val[1]));
    *v7++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[2], v22.val[2]), (uint8x8_t)vuzp2_s8(v21.val[2], v22.val[2]));
  }
  if ((a4 & 8) == 0)
    JUMPOUT(0x206273A1CLL);
  return sub_206273998();
}

uint64_t sub_206273998(int16x8_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5, int a6, _DWORD *a7, _DWORD *a8, _QWORD *a9)
{
  int64x2_t v9;
  int64x2_t v10;
  int64x2_t v11;
  int16x8_t v12;
  __int8 *v13;
  int16x8_t v14;
  int16x8_t v15;
  int16x8_t v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int16x8_t v24;
  int16x8_t v25;
  int16x8_t v26;
  uint64_t result;
  unsigned int v28;
  char v29;
  char v30;
  char v31;
  int8x8x3_t v32;

  v32 = vld3_s8(a3);
  v13 = (__int8 *)(a3 + 24);
  v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[0], 7uLL);
  v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[1], 7uLL);
  v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[2], 7uLL);
  *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v15, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v16, *(int16x4_t *)a1.i8, 2)), 7uLL);
  v32.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v15, a1, 4)), vrshrq_n_s16(v16, 1uLL)), 7uLL);
  v32.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v14, 1uLL), vqrdmulhq_laneq_s16(v15, a1, 5)), vqrdmulhq_laneq_s16(v16, a1, 6)), v12), 7uLL);
  *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[1], v32.val[1]), (uint8x8_t)vuzp2_s8(v32.val[1], v32.val[1]));
  *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[2], v32.val[2]), (uint8x8_t)vuzp2_s8(v32.val[2], v32.val[2]));
  *a9 = v9.i64[0];
  v17 = a9 + 1;
  *a7 = v10.i32[0];
  v18 = a7 + 1;
  *a8 = v11.i32[0];
  v19 = a8 + 1;
  v20 = a5 & 7;
  if ((a5 & 7) != 0)
  {
    do
    {
      v9 = vshlq_n_s64(v9, 8uLL);
      v10 = vshlq_n_s64(v10, 8uLL);
      v11 = vshlq_n_s64(v11, 8uLL);
      v9.i8[0] = *v13;
      v10.i8[0] = v13[1];
      v11.i8[0] = v13[2];
      v13 += 3;
      --v20;
    }
    while (v20);
    v21 = a5 & 7;
    v22 = 8 - v21;
    v23 = (v21 + 1) >> 1;
    v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
    v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
    v26 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v11.i8, 7uLL);
    *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v25, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v26, *(int16x4_t *)a1.i8, 2)), 7uLL);
    *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v25, a1, 4)), vrshrq_n_s16(v26, 1uLL)), 7uLL);
    *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v24, 1uLL), vqrdmulhq_laneq_s16(v25, a1, 5)), vqrdmulhq_laneq_s16(v26, a1, 6)), v12), 7uLL);
    do
    {
      v9 = vsliq_n_s64(v9, v9, 8uLL);
      v10 = vsliq_n_s64(v10, v10, 8uLL);
      v11 = vsliq_n_s64(v11, v11, 8uLL);
      --v22;
    }
    while (v22);
    *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8));
    *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8));
    do
    {
      *v17++ = v9.i8[7];
      v9 = vshlq_n_s64(v9, 8uLL);
      --v21;
    }
    while (v21);
    do
    {
      *v18++ = v10.i8[3];
      *v19++ = v11.i8[3];
      v10 = vshlq_n_s64(v10, 8uLL);
      v11 = vshlq_n_s64(v11, 8uLL);
      --v23;
    }
    while (v23);
  }
  result = (a6 - a5);
  if (a6 != a5)
  {
    v28 = result >> 1;
    v29 = *(v17 - 1);
    v30 = *(v18 - 1);
    v31 = *(v19 - 1);
    do
    {
      *v17++ = v29;
      result = (result - 1);
    }
    while ((_DWORD)result);
    for (; v28; --v28)
    {
      *v18++ = v30;
      *v19++ = v31;
    }
  }
  return result;
}

uint64_t aj_mcu_pack(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  int32x2_t v8;

  v6 = *(_QWORD *)a3;
  result = aj_find_and_handle_markers((int **)a2, (uint64_t *)a3, 0);
  if (!(_DWORD)result)
  {
    result = process_blocks(a1, (int *)a3, *(_DWORD *)(*(_QWORD *)(a2 + 8) + 88), **(_DWORD **)a2, *(_DWORD *)(a2 + 196), *(_DWORD *)(a2 + 192), v6, 0);
    if (!(_DWORD)result)
    {
      v8 = vadd_s32(*(int32x2_t *)(a3 + 28), (int32x2_t)0x100000001);
      *(int32x2_t *)(a3 + 28) = v8;
      result = 0;
      if (v8.i32[0] >= *(_DWORD *)(*(_QWORD *)(a2 + 8) + 80))
        *(_QWORD *)(a3 + 24) = (*(_DWORD *)(a3 + 24) + 1);
    }
  }
  return result;
}

uint64_t process_blocks(uint64_t *a1, int *a2, int a3, int a4, int a5, int a6, uint64_t a7, int32x2_t *a8)
{
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int *v31;
  int v32;
  uint64_t result;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  uint64_t *v40;
  uint64_t *v41;
  int v44;
  int v45;
  int v46;

  v13 = a2[6];
  v14 = a2[7];
  v15 = (a5 - 1) * a6;
  v16 = *a1 + 66 * (int)v14 * a3 + 66 * v15;
  a1[8] = v16;
  v17 = a1 + 8;
  v18 = a1 + 11238;
  v19 = a1 + 5622;
  v20 = a1[4];
  v21 = a1[3] + 66 * (int)v14 * a3;
  a1[6] = v21;
  v22 = a1 + 6;
  v23 = v20 + 66 * v14;
  v24 = a1[5];
  v26 = a1[1];
  v25 = a1[2];
  v27 = v26 + 66 * v14;
  v19[2] = v27;
  v28 = v25 + 66 * v14;
  *(v17 - 1) = v21 + 66 * ~v15;
  v18[2] = v28;
  v29 = v24 + 66 * v14;
  *v19 = v23;
  v19[1] = v23 - 66;
  *v18 = v29;
  v18[1] = v29 - 66;
  v17[1] = v16 + 66 * ~v15;
  v19[3] = v27 - 66;
  v18[3] = v28 - 66;
  if (!(_DWORD)v14)
  {
    a1[7] = 0;
    v19[1] = 0;
    v18[1] = 0;
    a1[9] = 0;
    v19[3] = 0;
    v18[3] = 0;
  }
  v40 = v18;
  v41 = v19;
  if (!v13)
  {
    *v17 = 0;
    v17[1] = 0;
    v19[2] = 0;
    v19[3] = 0;
    v18[2] = 0;
    v18[3] = 0;
  }
  if (a5 >= 1)
  {
    v30 = 0;
    v46 = v14 * a3;
    v44 = v14;
    v45 = ~v15;
    v31 = a2 + 2;
    do
    {
      if (a6 >= 1)
      {
        v32 = a6;
        do
        {
          if (a7)
          {
            aj_block_pack(v22, a7, v31);
          }
          else
          {
            result = aj_block_unpack(v22, a8, v31);
            if ((_DWORD)result)
              return result;
          }
          if (a6 <= 1)
          {
            v35 = *v22;
          }
          else
          {
            v34 = *v17;
            if (*v17)
            {
              a1[8] = v34 + 66;
              a1[9] = v34;
            }
            v35 = a1[6];
            a1[7] = v35;
          }
          v21 = v35 + 66;
          *v22 = v21;
          --v32;
        }
        while (v32);
        LODWORD(v14) = v44;
      }
      v36 = v21 - 66 * a6;
      *v17 = v36;
      if ((int)v14 < 1)
      {
        v37 = 0;
        v38 = 0;
      }
      else
      {
        v37 = a1[3] + 66 * v46 - 66;
        v38 = v36 + 66 * v45;
      }
      a1[7] = v37;
      a1[9] = v38;
      ++v30;
    }
    while (v30 != a5);
  }
  if (a4 != 3)
    return 0;
  v39 = a2 + 3;
  if (a7)
  {
    aj_block_pack(v41, a7, v39);
    aj_block_pack(v40, a7, a2 + 4);
    return 0;
  }
  result = aj_block_unpack(v41, a8, v39);
  if (!(_DWORD)result)
  {
    result = aj_block_unpack(v40, a8, a2 + 4);
    if (!(_DWORD)result)
      return 0;
  }
  return result;
}

uint64_t aj_mcu_unpack(uint64_t *a1, uint64_t a2, int32x2_t *a3)
{
  int ***v6;
  _DWORD *v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t result;
  int32x2_t v15;

  v6 = (int ***)(a1 + 17718);
  v7 = (_DWORD *)a1[17718];
  v8 = *(int **)v7;
  v9 = *(_DWORD *)(*(_QWORD *)v7 + 32);
  v10 = *(_DWORD *)(*(_QWORD *)v7 + 16);
  v11 = v7[22];
  v12 = *(_DWORD *)(*(_QWORD *)v7 + 3404);
  if (v12 && *(_DWORD *)(a2 + 32) == v12)
  {
    v13 = (*(_DWORD *)(a2 + 36) + 1) & 7;
    *(_DWORD *)(a2 + 36) = v13;
    result = aj_ostream_write_bytes((uint64_t)a3, v13 | 0xFFD0u, 2);
    if ((_DWORD)result)
      return result;
    *(_DWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    v8 = **v6;
  }
  result = process_blocks(a1, (int *)a2, v11, *v8, v9, v10, 0, a3);
  if (!(_DWORD)result)
  {
    v15 = vadd_s32(*(int32x2_t *)(a2 + 28), (int32x2_t)0x100000001);
    *(int32x2_t *)(a2 + 28) = v15;
    result = 0;
    if (v15.i32[0] >= *((_DWORD *)*v6 + 20))
      *(_QWORD *)(a2 + 24) = (*(_DWORD *)(a2 + 24) + 1);
  }
  return result;
}

uint8x8_t **aj_icol_row_444_to_rgb565(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64_t a9, uint64_t a10, unsigned int a11)
{
  uint8x8_t v11;
  uint8x8_t *v12;
  uint8x8_t *v13;
  uint8x8_t *v14;
  unsigned int i;
  uint8x8_t v16;
  uint8x8_t v17;
  uint8x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int16x8_t v21;
  int8x8_t v22;
  int16x8_t v23;
  int16x8_t v24;
  int16x8_t v25;
  int8x8_t v26;
  int v27;
  int8x8x2_t v28;

  v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  v12 = *result;
  v13 = *a2;
  v14 = *a3;
  for (i = a11 >> 3; i; --i)
  {
    v16 = *v12++;
    v17 = *v13++;
    v18 = *v14++;
    v19 = (int16x8_t)vshll_n_u8(v16, 7uLL);
    v20 = (int16x8_t)vsubl_u8(v17, v11);
    v21 = (int16x8_t)vsubl_u8(v18, v11);
    v22 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v19, vqaddq_s16(vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    v28.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_n_s16(v21, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v22, 5uLL));
    v28.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v22, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    vst2_s8(a4, v28);
    a4 += 16;
  }
  if ((a11 & 7) != 0)
  {
    v23 = (int16x8_t)vshll_n_u8(*v12, 7uLL);
    v24 = (int16x8_t)vsubl_u8(*v13, v11);
    v25 = (int16x8_t)vsubl_u8(*v14, v11);
    v26 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v23, vqaddq_s16(vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v25, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    *(int8x8_t *)a7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_n_s16(v25, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v26, 5uLL));
    *(int8x8_t *)a8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v26, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    v27 = a11 & 7;
    do
    {
      *a4 = a7.i8[0];
      a4[1] = a8.i8[0];
      a4 += 2;
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      --v27;
    }
    while (v27);
  }
  return result;
}

_OWORD *applejpeg_encode_create(__int128 *a1)
{
  char *v2;
  _OWORD *v3;
  _DWORD *v4;
  __int128 v5;

  if (a1 && *(_QWORD *)a1 && *((_QWORD *)a1 + 1))
  {
    v2 = (char *)(*(uint64_t (**)(uint64_t, _QWORD))a1)(26736, *((_QWORD *)a1 + 2));
    v3 = v2;
    if (v2)
    {
      v4 = v2 + 19920;
      bzero(v2, 0x6870uLL);
      bzero(v3, 0x6870uLL);
      v5 = *a1;
      *((_QWORD *)v3 + 2) = *((_QWORD *)a1 + 2);
      *v3 = v5;
      *((_QWORD *)v3 + 3333) = v3;
      *((_QWORD *)v3 + 2488) = 0x100000001;
      *((_QWORD *)v3 + 2489) = 0;
      *v4 = 95;
      *(_OWORD *)((char *)v3 + 19928) = 0u;
      *(_OWORD *)((char *)v3 + 19944) = 0u;
      *((_QWORD *)v3 + 2495) = 3;
      *((_DWORD *)v3 + 4992) = 0;
      *((_QWORD *)v3 + 2497) = 0;
      *((_DWORD *)v3 + 4996) = 0;
      *((_QWORD *)v3 + 2499) = 0;
      *((_DWORD *)v3 + 5000) = 0;
      *((_DWORD *)v3 + 5007) = 0;
      *((_DWORD *)v3 + 5008) = 0;
      *((_QWORD *)v3 + 2505) = 0;
      *((_DWORD *)v3 + 5012) = 0;
      *((_QWORD *)v3 + 2507) = 0;
      *((_DWORD *)v3 + 5016) = 0;
      *((_QWORD *)v3 + 2502) = 0;
      *((_QWORD *)v3 + 2501) = 0;
      *(_DWORD *)((char *)v3 + 20023) = 0;
    }
    else
    {
      aj_log_error((uint64_t)"Encode", "Could not allocate memory for session");
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Memory manager cannot be NULL");
    return 0;
  }
  return v3;
}

double applejpeg_encode_options_init(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0x100000001;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 95;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)&result = 3;
  *(_QWORD *)(a1 + 56) = 3;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  return result;
}

uint64_t applejpeg_encode_set_options_mem(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  _OWORD v8[11];

  if (!a1 || !a2 || !a3 || !a4)
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_QWORD *)(a4 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Encode", "Memory output buffer may not be larger than %d");
    return 8;
  }
  memset(&v8[7], 0, 56);
  v5 = a2[5];
  v8[4] = a2[4];
  v8[5] = v5;
  v8[6] = a2[6];
  v6 = a2[1];
  v8[0] = *a2;
  v8[1] = v6;
  v7 = a2[3];
  v8[2] = a2[2];
  v8[3] = v7;
  return encode_set_options(a1, (uint64_t)v8, a3, (_OWORD *)a4, 0);
}

uint64_t encode_set_options(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, __int128 *a5)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  v10 = a1 + 20072;
  *(_DWORD *)(a1 + 26656) = 0;
  v11 = encode_check_options(a2, a3);
  if (!(_DWORD)v11)
  {
    if (a3)
    {
      if (*(int *)a3 < 1 || (v12 = *(_DWORD *)(a3 + 4), v12 < 1))
      {
        v11 = 8;
        aj_log_error((uint64_t)"Encode", "Width and height must be > 0");
      }
      else if ((v12 | *(_DWORD *)a3) >> 16)
      {
        v11 = 8;
        aj_log_error((uint64_t)"Encode", "Width and height must be <= 0xFFFF");
      }
      else
      {
        v13 = *(_DWORD *)(a3 + 8);
        if (v13 < 0x13 || v13 == 20)
        {
          *(_QWORD *)(a1 + 20408) = a1 + 22544;
          *(_QWORD *)(a1 + 20416) = 4096;
          if (a4)
          {
            *(_OWORD *)(a1 + 24) = *a4;
            *(_QWORD *)(a1 + 20384) = a1 + 24;
            *(_QWORD *)(a1 + 20360) = enc_mem_callback;
          }
          else
          {
            v15 = *a5;
            v16 = a5[1];
            v17 = a5[2];
            *(_QWORD *)(a1 + 20400) = *((_QWORD *)a5 + 6);
            *(_OWORD *)(a1 + 20384) = v17;
            *(_OWORD *)(a1 + 20368) = v16;
            *(_OWORD *)(a1 + 20352) = v15;
          }
          v18 = *(_OWORD *)a2;
          v19 = *(_OWORD *)(a2 + 32);
          *(_OWORD *)(v10 + 16) = *(_OWORD *)(a2 + 16);
          *(_OWORD *)(v10 + 32) = v19;
          *(_OWORD *)v10 = v18;
          v20 = *(_OWORD *)(a2 + 48);
          v21 = *(_OWORD *)(a2 + 64);
          v22 = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(v10 + 80) = *(_OWORD *)(a2 + 80);
          *(_OWORD *)(v10 + 96) = v22;
          *(_OWORD *)(v10 + 48) = v20;
          *(_OWORD *)(v10 + 64) = v21;
          v23 = *(_OWORD *)(a2 + 112);
          v24 = *(_OWORD *)(a2 + 128);
          v25 = *(_OWORD *)(a2 + 144);
          *(_QWORD *)(v10 + 160) = *(_QWORD *)(a2 + 160);
          *(_OWORD *)(v10 + 128) = v24;
          *(_OWORD *)(v10 + 144) = v25;
          *(_OWORD *)(v10 + 112) = v23;
          v26 = *(_OWORD *)a3;
          v27 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)(a1 + 20272) = *(_OWORD *)(a3 + 32);
          *(_OWORD *)(a1 + 20256) = v27;
          *(_OWORD *)(a1 + 20240) = v26;
          v28 = *(_OWORD *)(a3 + 48);
          v29 = *(_OWORD *)(a3 + 64);
          v30 = *(_OWORD *)(a3 + 80);
          *(_OWORD *)(a1 + 20336) = *(_OWORD *)(a3 + 96);
          *(_OWORD *)(a1 + 20320) = v30;
          *(_OWORD *)(a1 + 20304) = v29;
          *(_OWORD *)(a1 + 20288) = v28;
          if (*(int *)v10 >= 17)
            *(_DWORD *)v10 = 16;
          v11 = aj_encode_init((uint64_t *)(a1 + 26664), a1 + 48, a1 + 20432, (int *)(a1 + 20240), v10, a1 + 20352, (uint64_t *)(a1 + 20408));
          if (!(_DWORD)v11)
            *(_DWORD *)(v10 + 6584) = 1;
        }
        else
        {
          v11 = 3;
          aj_log_error((uint64_t)"Encode", "Unsupported format");
        }
      }
    }
    else
    {
      v11 = 8;
      aj_log_error((uint64_t)"Encode", "Bitmap info struct cannot be NULL");
    }
  }
  return v11;
}

uint64_t applejpeg_encode_set_options_file(uint64_t a1, _OWORD *a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  _OWORD v8[11];

  if (a1 && a2 && a3 && a4)
  {
    memset(&v8[7], 0, 56);
    v4 = a2[5];
    v8[4] = a2[4];
    v8[5] = v4;
    v8[6] = a2[6];
    v5 = a2[1];
    v8[0] = *a2;
    v8[1] = v5;
    v6 = a2[3];
    v8[2] = a2[2];
    v8[3] = v6;
    return encode_set_options(a1, (uint64_t)v8, a3, 0, a4);
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_num_threads(uint64_t a1, uint64_t a2, int a3)
{
  _DWORD *v3;

  if (a1 && a2)
  {
    v3 = (_DWORD *)(a1 + 19904);
    if (v3[1688])
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *v3 = a3;
      return encode_check_options((uint64_t)v3, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t encode_check_options(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  int v19;
  int v20;
  int v21;

  if (!a1)
  {
    aj_log_error((uint64_t)"Encode", "Option pointer is NULL");
    return 8;
  }
  if (*(int *)a1 <= 0)
  {
    aj_log_error((uint64_t)"Encode", "Number of threads cannot be zero or smaller.");
  }
  else if (*(_QWORD *)(a1 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Encode", "max_filesize must be less than %d");
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (v4 < 0x65)
    {
      if (*(unsigned __int8 *)(a1 + 122) < 8u)
      {
        v5 = *(_DWORD *)(a1 + 124);
        if (v5 && v5 < *(_DWORD *)(a2 + 4))
        {
          aj_log_error((uint64_t)"Encode", "Strip encoding height override must be 0 or larger/equal to input height");
        }
        else
        {
          v6 = *(_DWORD *)(a1 + 128);
          if (*(_BYTE *)(a1 + 120))
          {
            if (v6)
            {
              aj_log_error((uint64_t)"Encode", "Can't both skip all headers and insert custom header segment");
              return 5;
            }
          }
          else if (v6)
          {
            if (!*(_QWORD *)(a1 + 136))
            {
              aj_log_error((uint64_t)"Encode", "Can't have NULL for inserted segment data");
              return 5;
            }
            if (*(_DWORD *)(a1 + 80))
            {
              aj_log_error((uint64_t)"Encode", "Can't skip App0 segment if inserting custom segment");
              return 5;
            }
          }
          v7 = *(_DWORD *)(a1 + 144);
          if (!v7)
            goto LABEL_29;
          if (!*(_QWORD *)(a1 + 152))
          {
            aj_log_error((uint64_t)"Encode", "Can't have NULL for RST offset table");
            return 5;
          }
          if (*(_DWORD *)(a1 + 4) != 1)
          {
            aj_log_error((uint64_t)"Encode", "Can't have marker offset table unless restart marker interval is set to sparse");
            return 5;
          }
          v8 = (*(_DWORD *)(a1 + 56) & 0xFFFFFFFE) == 2 ? 16 : 8;
          if (v7 < (*(_DWORD *)(a2 + 4) + v8 - 1) / v8 - 1)
          {
            aj_log_error((uint64_t)"Encode", "Restart marker offset table size does not match number of restart markers");
          }
          else
          {
LABEL_29:
            v9 = *(_DWORD *)(a2 + 8);
            if (v9 == 15)
            {
              v10 = 4;
            }
            else
            {
              v11 = *(_DWORD *)(a1 + 56);
              if (v11 >= 5)
              {
                aj_log_error((uint64_t)"Encode", "Unsupported subsampling");
                return 5;
              }
              if (v11 == 4)
                v10 = 1;
              else
                v10 = 3;
            }
            if (!v4)
            {
              v16 = 0;
              while (2)
              {
                v17 = *(_QWORD *)(a1 + 8 * v16 + 24);
                if (!v17)
                {
                  aj_log_error((uint64_t)"Encode", "Component %d is missing custom quantization table");
                  return 5;
                }
                for (i = 0; i != 64; ++i)
                {
                  if (!*(_BYTE *)(v17 + i))
                  {
                    aj_log_error((uint64_t)"Encode", "Quantization value %d in table %d is 0 which is not allowed");
                    return 5;
                  }
                }
                if (++v16 != v10)
                  continue;
                break;
              }
            }
            v12 = *(_DWORD *)(a1 + 96);
            if (v12 < 0)
            {
              aj_log_error((uint64_t)"Encode", "Negative callback interval");
            }
            else if (v12 && !*(_QWORD *)(a1 + 88))
            {
              aj_log_error((uint64_t)"Encode", "Callback interval specified, but no callback function");
            }
            else
            {
              if (*(_DWORD *)(a1 + 4) < 3u)
              {
                v13 = *(_DWORD *)(a1 + 60);
                if (v13 == 2)
                {
                  v19 = *(_DWORD *)(a1 + 56);
                  if (v19)
                  {
                    if (v19 != 4)
                    {
                      aj_log_error((uint64_t)"Encode", "Unsupported: LLJPEG can only take GRAY or RGB");
                      return 5;
                    }
                    if (v9 != 5 && v9 != 18)
                    {
                      aj_log_error((uint64_t)"Encode", "Unsupported LLJPEG: GRAY to GRAY please");
                      return 5;
                    }
                  }
                  else if (v9 > 0x14 || ((1 << v9) & 0x130019) == 0)
                  {
                    aj_log_error((uint64_t)"Encode", "Unsupported LLJPEG: RGB to RGB please");
                    return 5;
                  }
                  v20 = *(_DWORD *)(a1 + 112);
                  if (v20)
                  {
                    if (v20 <= 7)
                    {
                      aj_log_error((uint64_t)"Encode", "Bitdepth must be >= 8");
                      return 5;
                    }
                    if (((1 << v9) & 0x170000) != 0)
                    {
                      v21 = *(_DWORD *)(a1 + 116);
                      if (v21 < 0)
                      {
                        aj_log_error((uint64_t)"Encode", "Downshift can't be <0 if input is 16 bit");
                        return 5;
                      }
                      if ((v21 + v20) >= 0x11)
                      {
                        aj_log_error((uint64_t)"Encode", "Bitdepth plus Downshift can't be >16 if input is 16 bit");
                        return 5;
                      }
                    }
                    else
                    {
                      if (*(_DWORD *)(a1 + 116))
                      {
                        aj_log_error((uint64_t)"Encode", "Downshift must be 0 if input is 8 bit");
                        return 5;
                      }
                      if (v20 >= 9)
                      {
                        aj_log_error((uint64_t)"Encode", "Bitdepth can't be >8 if input is 8 bit");
                        return 5;
                      }
                    }
                  }
                }
                else if (v13 == 1)
                {
                  v14 = *(unsigned int **)(a1 + 72);
                  if (v14)
                  {
                    v15 = *(_DWORD *)(a1 + 64);
                    if (v15 <= v10 || v15 > 896 * v10)
                    {
                      aj_log_error((uint64_t)"Encode", "Illegal number of progressive scans for a %d component JPEG: %d");
                      return 5;
                    }
                    result = verify_pscan_setup(v14, v15, v10);
                    if ((_DWORD)result)
                      return result;
                    v9 = *(_DWORD *)(a2 + 8);
                  }
                }
                if (v9 != 18 || *(_DWORD *)(a1 + 60) == 2)
                  return 0;
                aj_log_error((uint64_t)"Encode", "Unsupported: 16 bit gray is only for lossless jpeg");
                return 5;
              }
              aj_log_error((uint64_t)"Encode", "Illegal restart marker setting");
            }
          }
        }
      }
      else
      {
        aj_log_error((uint64_t)"Encode", "restart_marker_offset must be >=0 and <8");
      }
    }
    else
    {
      aj_log_error((uint64_t)"Encode", "Unsupported quality setting");
    }
  }
  return 5;
}

uint64_t applejpeg_encode_set_option_restart_markers(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 19908) = a3;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_max_filesize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_QWORD *)(a1 + 19912) = a3;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_quality(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 19920) = a3;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_q_tables(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  uint64_t v7;
  _QWORD *v8;

  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_DWORD *)(a1 + 26656))
  {
    aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
    return 5;
  }
  if (!a3 || a3 >= 5)
  {
    aj_log_error((uint64_t)"Encode", "Invalid num_tables");
    return 8;
  }
  *(_DWORD *)(a1 + 19920) = 0;
  if (a3 >= 1)
  {
    v7 = a3;
    v8 = (_QWORD *)(a1 + 19928);
    do
    {
      if (!*a4)
      {
        aj_log_error((uint64_t)"Encode", "Table may not be NULL");
        return 8;
      }
      *v8++ = *a4++;
      --v7;
    }
    while (v7);
    if (a3 > 3)
      return encode_check_options(a1 + 19904, a2);
  }
  bzero((void *)(a1 + 8 * a3 + 19928), 8 * (3 - a3) + 8);
  return encode_check_options(a1 + 19904, a2);
}

uint64_t applejpeg_encode_set_option_format(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 19960) = a3;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_type_baseline(_DWORD *a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    if (a1[6664])
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      a1[4990] = a3;
      a1[4991] = 0;
      return encode_check_options((uint64_t)(a1 + 4976), a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_type_progressive(uint64_t a1, uint64_t a2, int a3, int a4, const void *a5)
{
  _DWORD *v9;
  uint64_t v12;
  void *v13;
  void *v14;

  if (a1 && a2 && a4 && a5)
  {
    v9 = (_DWORD *)(a1 + 19960);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      v12 = *(_QWORD *)(a1 + 26648);
      if (v12)
      {
        (*(void (**)(uint64_t, _QWORD))(a1 + 8))(v12, *(_QWORD *)(a1 + 16));
        *(_QWORD *)(a1 + 26648) = 0;
        v9[1670] = 0;
      }
      v13 = (void *)(*(uint64_t (**)(uint64_t, _QWORD))a1)(36 * a4, *(_QWORD *)(a1 + 16));
      *(_QWORD *)(a1 + 26720) = v13;
      *(_QWORD *)(a1 + 26648) = v13;
      if (v13 && (bzero(v13, 36 * a4), (v14 = *(void **)(a1 + 26648)) != 0))
      {
        memcpy(v14, a5, 36 * a4);
        *v9 = a3;
        v9[1] = 1;
        v9[2] = a4;
        *(_QWORD *)(a1 + 19976) = *(_QWORD *)(a1 + 26648);
        return encode_check_options(a1 + 19904, a2);
      }
      else
      {
        aj_log_error((uint64_t)"Encode", "Could not allocate scans");
        return 6;
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_type_lossless(_DWORD *a1, uint64_t a2, int a3, int a4, int a5)
{
  if (a1 && a2)
  {
    if (a1[6664])
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      a1[4990] = a3;
      a1[4991] = 2;
      a1[5004] = a4;
      a1[5005] = a5;
      return encode_check_options((uint64_t)(a1 + 4976), a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_skip_app0_header(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 19984) = a3;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if (a1 && a2 && a3 && a4)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_QWORD *)(a1 + 19992) = a3;
      *(_DWORD *)(a1 + 20000) = a4;
      *(_QWORD *)(a1 + 20008) = a5;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_strip_encode(uint64_t a1, uint64_t a2, char a3, char a4, char a5, int a6)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_BYTE *)(a1 + 20024) = a3;
      *(_BYTE *)(a1 + 20025) = a4;
      *(_BYTE *)(a1 + 20026) = a5;
      *(_DWORD *)(a1 + 20028) = a6;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_insert_segment(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _QWORD *a5)
{
  if (a1 && a2 && a5)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 20032) = a3;
      *(_QWORD *)(a1 + 20040) = a4;
      *a5 = 20;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_record_rst_offsets(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 20048) = a3;
      *(_QWORD *)(a1 + 20056) = a4;
      *(_DWORD *)(a1 + 20064) = a5;
      return encode_check_options(a1 + 19904, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

double applejpeg_encode_reset_options(uint64_t a1)
{
  double result;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
    }
    else
    {
      *(_QWORD *)(a1 + 20072) = 0x100000001;
      *(_DWORD *)(a1 + 20088) = 95;
      *(_OWORD *)(a1 + 20096) = 0u;
      *(_OWORD *)(a1 + 20112) = 0u;
      *(_QWORD *)&result = 3;
      *(_QWORD *)(a1 + 20080) = 0;
      *(_QWORD *)(a1 + 20128) = 3;
      *(_DWORD *)(a1 + 20136) = 0;
      *(_QWORD *)(a1 + 20144) = 0;
      *(_DWORD *)(a1 + 20152) = 0;
      *(_QWORD *)(a1 + 20160) = 0;
      *(_DWORD *)(a1 + 20168) = 0;
      *(_DWORD *)(a1 + 20196) = 0;
      *(_DWORD *)(a1 + 20200) = 0;
      *(_QWORD *)(a1 + 20208) = 0;
      *(_DWORD *)(a1 + 20216) = 0;
      *(_QWORD *)(a1 + 20224) = 0;
      *(_DWORD *)(a1 + 20232) = 0;
      *(_QWORD *)(a1 + 20184) = 0;
      *(_QWORD *)(a1 + 20176) = 0;
      *(_DWORD *)(a1 + 20191) = 0;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
  }
  return result;
}

uint64_t applejpeg_encode_commit_options_for_mem(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  return encode_set_options(a1, a1 + 19904, a2, a3, 0);
}

uint64_t applejpeg_encode_commit_options_for_file(uint64_t a1, uint64_t a2, __int128 *a3)
{
  return encode_set_options(a1, a1 + 19904, a2, 0, a3);
}

uint64_t applejpeg_encode_image_row(uint64_t a1, unsigned int *a2, _QWORD *a3)
{
  uint64_t v6;
  int v7;
  _DWORD *v8;
  uint64_t v10;
  _BOOL4 v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;

  v19 = 0;
  if (a1 && a2)
  {
    v6 = check_input((_DWORD *)a1, a2, 0, &v19);
    if (!(_DWORD)v6)
    {
      if (*(_DWORD *)(a1 + 26656))
      {
        v8 = a2 + 11;
        v7 = a2[11];
        if (v7 >= 16)
          kdebug_trace();
        if (*(_DWORD *)(a1 + 13408) == 14 && !*(_DWORD *)(a1 + 13312))
        {
          aj_log_error((uint64_t)"Encode", "Illegal settings for texture format.");
          return 3;
        }
        if (*(_DWORD *)(a1 + 20132) == 2)
        {
          aj_log_error((uint64_t)"Encode", "Row-wise compression for LOSSLESS is not implemented.");
          return 3;
        }
        if (*v8 + *(_DWORD *)(a1 + 13336) > *(_DWORD *)(a1 + 60))
        {
          aj_log_error((uint64_t)"Encode", "Image height is %d but %d rows have been passed in.");
          return 1;
        }
        if (*(_QWORD *)(a1 + 20080))
        {
          aj_log_error((uint64_t)"Encode", "Max filesize not supported for row-by-row encoding");
          return 1;
        }
        v10 = a1 + 48;
        if (!*(_DWORD *)(a1 + 13316))
        {
          v17 = aj_write_jpeg_headers((int *)(a1 + 48), a1 + 22360, a1 + 3472, *(int **)(a1 + 19864), *(_DWORD *)(a1 + 22488), *(unsigned __int8 *)(a1 + 20152), *(unsigned int *)(a1 + 20200), *(char **)(a1 + 20208), 0);
          if ((_DWORD)v17)
          {
            v6 = v17;
            aj_log_error((uint64_t)"Encode", "Failed to write JPEG headers");
            return v6;
          }
          *(_DWORD *)(a1 + 13316) = 1;
        }
        v11 = v19;
        if (v19 && *(_DWORD *)(a1 + 13408) == 14)
          v8 = (_DWORD *)(a1 + 13476);
        v12 = *(_DWORD *)(a1 + 13324) + *v8;
        if (v12 >= *(_DWORD *)(a1 + 13340))
        {
          v18 = a1 + 48;
          v13 = 0;
          while (1)
          {
            setup_input((_QWORD *)(a1 + 20432), v18, (uint64_t)a2, v13);
            v14 = aj_encode_row(v18, (_QWORD *)(a1 + 20432), *(_DWORD *)(a1 + 13336) >= (*(_DWORD *)(a1 + 13484) - 1) * *(_DWORD *)(a1 + 13476));
            if ((_DWORD)v14)
              break;
            v15 = *(_DWORD *)(a1 + 13340);
            if (*(_DWORD *)(a1 + 13324))
              v16 = 1;
            else
              v16 = *(_DWORD *)(a1 + 13340);
            v13 += v16;
            *(_DWORD *)(a1 + 13336) += v15;
            *(_DWORD *)(a1 + 13324) = 0;
            v12 -= v15;
            if (v12 < v15)
            {
              v11 = v19;
              v10 = a1 + 48;
              goto LABEL_34;
            }
          }
          v6 = v14;
          aj_log_error((uint64_t)"Encode", "Failed to encode row");
        }
        else
        {
          v13 = 0;
LABEL_34:
          if (v11)
          {
            if (v12 && *(_DWORD *)(a1 + 13408) != 14)
            {
              setup_input((_QWORD *)(a1 + 20432), v10, (uint64_t)a2, v13);
              *(_DWORD *)(a1 + 13324) = 1;
            }
            v6 = aj_encode_row_close(v10, a1 + 20432);
            *(_DWORD *)(a1 + 13324) = 0;
            *(_DWORD *)(a1 + 26656) = 0;
          }
          else
          {
            if (v12)
            {
              setup_input((_QWORD *)(a1 + 20432), v10, (uint64_t)a2, v13);
              buffer_input_row(v10, a1 + 20432);
            }
            v6 = 0;
          }
          if (v7 >= 16)
            kdebug_trace();
          *a3 = *(int *)(a1 + 22448);
        }
      }
      else
      {
        aj_log_error((uint64_t)"Encode", "Options not set");
        return 5;
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot accept NULL arguments");
    return 8;
  }
  return v6;
}

uint64_t check_input(_DWORD *a1, unsigned int *a2, int a3, _BOOL4 *a4)
{
  uint64_t v4;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t result;
  int v11;
  _BOOL4 v12;

  v4 = a2[8];
  if ((v4 - 5) < 0xFFFFFFFC)
  {
    aj_log_error((uint64_t)"Encode", "Invalid number of planes: %d");
    return 8;
  }
  v6 = 0;
  do
  {
    if (!*(_QWORD *)&a2[2 * v6])
    {
      aj_log_error((uint64_t)"Encode", "Plane pointer #%d is NULL");
      return 8;
    }
    ++v6;
  }
  while (v4 != v6);
  v7 = a1[5062];
  if (v7 != a2[12])
  {
    aj_log_error((uint64_t)"Encode", "Format differs from what previously set");
    return 8;
  }
  if (a2[10] != a1[5060])
    goto LABEL_15;
  v8 = a2[11];
  if (a3)
  {
    v9 = a2[11];
    if (v8 == a1[5061])
      goto LABEL_18;
LABEL_15:
    aj_log_error((uint64_t)"Encode", "Invalid data dimensions");
    return 8;
  }
  if (v8 < 1)
    goto LABEL_15;
  v9 = a1[5061];
  if (v8 > v9)
    goto LABEL_15;
LABEL_18:
  v11 = a1[3334] + v8 + a1[3331];
  v12 = v11 >= v9;
  if ((v7 - 10) >= 4)
  {
    if (v7 == 14 && memcmp(a1 + 5064, a2 + 14, 0x40uLL))
    {
      aj_log_error((uint64_t)"Encode", "Texture info structs differ");
      return 8;
    }
  }
  else if ((v8 & 1) != 0 && v11 < v9)
  {
    aj_log_error((uint64_t)"Encode", "An even number of rows is required for vertically decimated input");
    return 8;
  }
  result = 0;
  if (a4)
    *a4 = v12;
  return result;
}

_QWORD *setup_input(_QWORD *result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  if (*(_DWORD *)(a3 + 48) == 14)
  {
    result[230] = *(_QWORD *)a3 + *(_QWORD *)(a2 + 19768) * a4 + *(_QWORD *)(a2 + 13392);
    if (*(_DWORD *)(a3 + 32) == 3)
    {
      result[232] = *(_QWORD *)(a3 + 8) + *(_QWORD *)(a2 + 19776) * a4 + *(_QWORD *)(a2 + 13400);
      v4 = *(_QWORD *)(a3 + 16);
    }
    else
    {
      v9 = *(_QWORD *)a3 + *(_QWORD *)(a2 + 13368);
      result[232] = v9 + *(_QWORD *)(a2 + 19776) * a4 + *(_QWORD *)(a2 + 13400);
      v4 = v9 + *(_QWORD *)(a2 + 13376);
    }
    result[234] = v4 + *(_QWORD *)(a2 + 19784) * a4 + *(_QWORD *)(a2 + 13408);
    v10 = 3;
  }
  else if (*(_DWORD *)(a2 + 19832))
  {
    v5 = *(_DWORD *)(a3 + 44);
    v6 = *(_DWORD *)(a2 + 19844);
    v7 = *(_QWORD *)(a2 + 19768);
    result[230] = *(_QWORD *)a3 + v7 * a4;
    if (*(_DWORD *)(a3 + 32) == 2)
    {
      v8 = *(_QWORD *)(a3 + 8);
    }
    else
    {
      v11 = v5 & 1;
      if (v6 != 2)
        v11 = 0;
      v8 = *(_QWORD *)a3 + v7 * (v11 + v5);
    }
    result[232] = v8;
    result[232] = v8 + *(_QWORD *)(a2 + 19776) * (a4 >> (v6 - 1));
    v10 = 2;
  }
  else
  {
    result[230] = *(_QWORD *)a3 + *(_QWORD *)(a2 + 19768) * a4;
    v10 = 1;
  }
  if (*(_DWORD *)(a2 + 13276))
  {
    v12 = result + 237;
    v13 = result + 229;
    do
    {
      v14 = *v12++;
      *v13 = v14;
      v13 += 2;
      --v10;
    }
    while (v10);
  }
  else
  {
    v15 = result + 230;
    v16 = (uint64_t *)(a2 + 19768);
    do
    {
      v17 = *v15;
      *(v15 - 1) = *v15;
      v18 = *v16++;
      *v15 = v17 + v18;
      v15 += 2;
      --v10;
    }
    while (v10);
  }
  return result;
}

void *buffer_input_row(uint64_t a1, uint64_t a2)
{
  void *result;

  result = memcpy(*(void **)(a2 + 1896), *(const void **)(a2 + 1832), *(_QWORD *)(a1 + 19768));
  if (*(_DWORD *)(a1 + 19832))
    result = memcpy(*(void **)(a2 + 1904), *(const void **)(a2 + 1848), *(_QWORD *)(a1 + 19776));
  *(_DWORD *)(a1 + 13276) = 1;
  return result;
}

uint64_t applejpeg_encode_image_all(uint64_t a1, unsigned int *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Encode", "Cannot accept NULL arguments");
    return 8;
  }
  v6 = check_input((_DWORD *)a1, a2, 1, 0);
  if (!(_DWORD)v6)
  {
    if (!*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Options not set");
      return 5;
    }
    kdebug_trace();
    if (*(_DWORD *)(a1 + 19852))
    {
      setup_input((_QWORD *)(a1 + 20432), a1 + 48, (uint64_t)a2, 0);
      v7 = do_encode_lossless(a1);
LABEL_7:
      v6 = v7;
LABEL_8:
      *a3 = *(int *)(a1 + 22448);
      *(_DWORD *)(a1 + 26656) = 0;
      kdebug_trace();
      return v6;
    }
    v9 = *(_QWORD *)(a1 + 20080);
    if (!v9)
    {
      v7 = do_encode(a1, (uint64_t)a2);
      goto LABEL_7;
    }
    v10 = a1 + 20072;
    v29 = *(_QWORD *)(a1 + 22424);
    v27 = *(_OWORD *)(a1 + 22392);
    v28 = *(_OWORD *)(a1 + 22408);
    v25 = *(_OWORD *)(a1 + 22360);
    v26 = *(_OWORD *)(a1 + 22376);
    *(_QWORD *)(a1 + 22400) = dummy_callback2;
    *(_QWORD *)(a1 + 20080) = 0;
    aj_encode_reset_session((int *)(a1 + 48), a1 + 20432, a1 + 20072);
    v6 = do_encode(a1, (uint64_t)a2);
    if ((_DWORD)v6)
      return v6;
    v24 = v9;
    v11 = *(_DWORD *)(a1 + 22448);
    if (v11 < (int)v9)
    {
      v12 = a1 + 20432;
      v13 = a1 + 22360;
LABEL_17:
      if (v11 < v24)
      {
        aj_encode_reset_session((int *)(a1 + 48), v12, v10);
        *(_OWORD *)(v13 + 32) = v27;
        *(_OWORD *)(v13 + 48) = v28;
        *(_QWORD *)(v13 + 64) = v29;
        *(_OWORD *)v13 = v25;
        *(_OWORD *)(v13 + 16) = v26;
        v6 = do_encode(a1, (uint64_t)a2);
        if ((_DWORD)v6)
          return v6;
        goto LABEL_8;
      }
      aj_log_error((uint64_t)"Encode", "Unable to produce smaller image", a1 + 22360);
      return 5;
    }
    v23 = a1 + 20072;
    v14 = *(_DWORD *)(a1 + 20088);
    if (v14 >= 0)
      v15 = *(_DWORD *)(a1 + 20088);
    else
      v15 = v14 + 1;
    v12 = a1 + 20432;
    if (v14 < 2)
    {
      v16 = v15 >> 1;
LABEL_36:
      if (v11 < v24)
      {
        v13 = a1 + 22360;
        v10 = a1 + 20072;
      }
      else
      {
        v13 = a1 + 22360;
        v10 = a1 + 20072;
        if (v16 >= 2)
        {
          *(_DWORD *)(a1 + 20088) = v16 - 1;
          v22 = v12;
          aj_encode_reset_session((int *)(a1 + 48), v12, v23);
          v6 = do_encode(a1, (uint64_t)a2);
          if ((_DWORD)v6)
            return v6;
          v11 = *(_DWORD *)(a1 + 22448);
          v12 = v22;
          v13 = a1 + 22360;
        }
      }
      goto LABEL_17;
    }
    v17 = v14 - 1;
    v18 = (int)v9 / 20;
    v19 = 1;
    while (1)
    {
      v20 = v19 + v17;
      if (v19 + v17 < 0 != __OFADD__(v19, v17))
        ++v20;
      v16 = v20 >> 1;
      *(_DWORD *)(a1 + 20088) = v20 >> 1;
      aj_encode_reset_session((int *)(a1 + 48), v12, v23);
      v21 = do_encode(a1, (uint64_t)a2);
      if ((_DWORD)v21)
        return v21;
      v11 = *(_DWORD *)(a1 + 22448);
      if (v24 <= v11)
      {
        v17 = v16 - 1;
        v12 = a1 + 20432;
      }
      else
      {
        v12 = a1 + 20432;
        if (v24 - v11 < v18)
          goto LABEL_36;
        v19 = v16 + 1;
      }
      if (v19 > v17)
        goto LABEL_36;
    }
  }
  return v6;
}

uint64_t do_encode(uint64_t a1, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  signed int v7;
  int v8;
  int v9;
  signed int v10;
  int v11;
  int v12;
  uint64_t result;

  v3 = (int *)(a1 + 22488);
  v4 = a1 + 20072;
  v5 = (int *)(a1 + 48);
  v6 = a1 + 20432;
  setup_input((_QWORD *)(a1 + 20432), a1 + 48, a2, 0);
  if (aj_allow_multithread_encode(v5, v6, *(_DWORD *)v4))
  {
    v7 = *(_DWORD *)v4;
    v8 = *(_DWORD *)(a1 + 13480);
    v9 = *(_DWORD *)(a1 + 13484);
    v10 = *(_DWORD *)v4;
    do
    {
      v11 = v9 / v10;
      if (v9 % v10)
        ++v11;
      v10 *= 2;
    }
    while (v11 > 0xFFFF / v8);
    *(_DWORD *)(a1 + 19808) = v11;
    v12 = *v3;
    if (*v3)
    {
      if (v12 == v8 * v11 || !(v8 % v12))
        goto LABEL_14;
    }
    else
    {
      v8 *= v11;
    }
    *v3 = v8;
    v12 = v8;
LABEL_14:
    if (!*(_BYTE *)(v4 + 120))
    {
      result = aj_write_jpeg_headers(v5, a1 + 22360, a1 + 3472, *(int **)(a1 + 19864), v12, *(unsigned __int8 *)(v4 + 80), *(unsigned int *)(v4 + 128), *(char **)(a1 + 20208), *(_DWORD *)(v4 + 124));
      if ((_DWORD)result)
        return result;
      *(_DWORD *)(v4 + 2380) = *(_DWORD *)(v4 + 2304);
      v7 = *(_DWORD *)v4;
    }
    result = aj_encode_all_mt((uint64_t)v5, v6, v7, a1);
    goto LABEL_16;
  }
  if (!*(_BYTE *)(v4 + 120))
  {
    result = aj_write_jpeg_headers(v5, a1 + 22360, a1 + 3472, *(int **)(a1 + 19864), *v3, *(unsigned __int8 *)(v4 + 80), *(unsigned int *)(v4 + 128), *(char **)(a1 + 20208), *(_DWORD *)(v4 + 124));
    if ((_DWORD)result)
      return result;
    *(_DWORD *)(v4 + 2380) = *(_DWORD *)(v4 + 2304);
  }
  result = aj_encode_all((uint64_t)v5, v6, 217);
LABEL_16:
  if ((_DWORD)result == 9)
  {
    if (*(uint64_t (**)(void *, int, uint64_t))(a1 + 22400) == enc_mem_callback)
      aj_log_error((uint64_t)"Encode", "Output buffer too small");
    result = 9;
  }
  else if (!(_DWORD)result)
  {
    result = aj_ostream_flush_buffer(a1 + 22360);
  }
  *(_DWORD *)(v4 + 2376) = *(_DWORD *)(v4 + 2304);
  return result;
}

uint64_t dummy_callback2()
{
  return 0;
}

uint64_t applejpeg_encode_image_all_with_bitstream_offset(uint64_t a1, unsigned int *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t result;

  if (a4)
  {
    result = applejpeg_encode_image_all(a1, a2, a3);
    if (!(_DWORD)result)
      *a4 = *(int *)(a1 + 22452);
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot accept NULL arguments");
    return 8;
  }
  return result;
}

uint64_t applejpeg_encode_destroy(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;
  __int128 v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v3 = *(_OWORD *)result;
    v4 = *(_QWORD *)(result + 16);
    aj_encode_release_scan_buffers(result + 48, (uint64_t)&v3);
    v2 = (_QWORD *)(v1 + 26680);
    do
    {
      if (*v2)
      {
        (*((void (**)(_QWORD, uint64_t))&v3 + 1))(*v2, v4);
        *v2 = 0;
      }
      ++v2;
    }
    while ((unint64_t)v2 < v1 + 26728);
    return (*((uint64_t (**)(uint64_t, uint64_t))&v3 + 1))(v1, v4);
  }
  return result;
}

uint64_t enc_mem_callback(void *__src, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  if (*(_QWORD *)(a3 + 8) < (unint64_t)a2)
    return 1;
  v5 = a2;
  memcpy(*(void **)a3, __src, a2);
  result = 0;
  v6 = *(_QWORD *)(a3 + 8) - v5;
  *(_QWORD *)a3 += v5;
  *(_QWORD *)(a3 + 8) = v6;
  return result;
}

uint64_t verify_pscan_setup(unsigned int *a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  if (a2 >= 1)
  {
    v5 = a2;
    while (!aj_fill_coeffblock_from_scan_properties(a1, (uint64_t)&v10, a3))
    {
      a1 += 9;
      if (!--v5)
        goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_5:
  if (a3 >= 1)
  {
    v6 = 0;
    v7 = &v10;
LABEL_7:
    v8 = 0;
    while (*(__int16 *)((char *)v7 + v8) == -1)
    {
      v8 += 2;
      if (v8 == 128)
      {
        result = 0;
        ++v6;
        v7 += 8;
        if (v6 != a3)
          goto LABEL_7;
        return result;
      }
    }
LABEL_12:
    aj_log_error((uint64_t)"Encode", "The progressive scan set-up is illegal or contains errors", v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      (_QWORD)v40);
    return 5;
  }
  return 0;
}

void applejpeg_decode_create_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0(&dword_20623C000, a2, a3, "[%p] Created session", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1();
}

void applejpeg_decode_destroy_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0(&dword_20623C000, a2, a3, "[%p] Releasing session", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1();
}

void applejpeg_decode_build_index_cold_1()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x24BDAC8D0];
  OUTLINED_FUNCTION_2();
  _os_log_debug_impl(&dword_20623C000, v0, OS_LOG_TYPE_DEBUG, "[%p] Index-table finished with code %d", v1, 0x12u);
  OUTLINED_FUNCTION_1();
}

void applejpeg_decode_image_all_cold_1()
{
  NSObject *v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x24BDAC8D0];
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_3(&dword_20623C000, v0, (uint64_t)v0, "[%p] Decoding failed with error code %d", v1);
  OUTLINED_FUNCTION_1();
}

void applejpeg_decode_image_all_cold_2(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0(&dword_20623C000, a2, a3, "[%p] Decoding completed without errors", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1();
}

void applejpeg_decode_image_all_cold_3(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = 134218240;
  v4 = a1;
  v5 = 1024;
  v6 = -1;
  OUTLINED_FUNCTION_3(&dword_20623C000, a2, a3, "Warning! [%p] Decoding incomplete with error code %d. This is expected if the image has not been fully downloaded.", (uint8_t *)&v3);
  OUTLINED_FUNCTION_1();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x24BDBBC88](theData, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x24BDBBCB0](allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
  MEMORY[0x24BDBBD18](theData, range.location, range.length, newBytes, newLength);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDD8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC160](key, applicationID);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x24BDBC650](str);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x24BDBC898](url, resolveAgainstBase, buffer, maxBufLen);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x24BDD86F8](*(_QWORD *)&object);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x24BDD8928](*(_QWORD *)&entry, plane, key, allocator, *(_QWORD *)&options);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x24BDD8988](*(_QWORD *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDD89A8](name);
}

uint64_t IOSurfaceAcceleratorCreate()
{
  return MEMORY[0x24BE51728]();
}

uint64_t IOSurfaceAcceleratorTransformSurface()
{
  return MEMORY[0x24BE51748]();
}

IOSurfaceRef IOSurfaceCreate(CFDictionaryRef properties)
{
  return (IOSurfaceRef)MEMORY[0x24BDD8B50](properties);
}

void *__cdecl IOSurfaceGetBaseAddressOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return (void *)MEMORY[0x24BDD8BA8](buffer, planeIndex);
}

size_t IOSurfaceGetBytesPerRowOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x24BDD8BE0](buffer, planeIndex);
}

size_t IOSurfaceGetPlaneCount(IOSurfaceRef buffer)
{
  return MEMORY[0x24BDD8C88](buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x24BDD8D08](buffer, *(_QWORD *)&options, seed);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x24BDD8DD0](buffer, *(_QWORD *)&options, seed);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB68](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

int access(const char *a1, int a2)
{
  return MEMORY[0x24BDAD038](a1, *(_QWORD *)&a2);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

int feof(FILE *a1)
{
  return MEMORY[0x24BDAE328](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x24BDAE330](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE448](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x24BDAE4D8](a1, a2, *(_QWORD *)&a3);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x24BDAE530](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x24BDAE958]();
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x24BDAF368](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x24BDAF818](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x24BDAF880](a1, a2);
}

long double sin(long double __x)
{
  long double result;

  MEMORY[0x24BDAFE18](__x);
  return result;
}

void vImageDestroyResamplingFilter(ResamplingFilter filter)
{
  MEMORY[0x24BDB38B8](filter);
}

vImage_Error vImageHorizontalShear_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, float xTranslate, float shearSlope, ResamplingFilter filter, Pixel_8 backColor, vImage_Flags flags)
{
  return MEMORY[0x24BDB3908](src, dest, srcOffsetToROI_X, srcOffsetToROI_Y, filter, backColor, *(_QWORD *)&flags, xTranslate, shearSlope);
}

ResamplingFilter vImageNewResamplingFilter(float scale, vImage_Flags flags)
{
  return (ResamplingFilter)MEMORY[0x24BDB3930](*(_QWORD *)&flags, scale);
}

vImage_Error vImageScale_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x24BDB3A10](src, dest, tempBuffer, *(_QWORD *)&flags);
}

