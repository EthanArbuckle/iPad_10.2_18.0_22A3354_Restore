id as::GetServerXPCListenerEndpoint(as *this)
{
}

id sessionManagerXPCCallbackInterface()
{
  unsigned __int8 v0;

  {
    objc_msgSend(MEMORY[0x24BDD1990], "interfaceWithProtocol:", &unk_254516640);
    sessionManagerXPCCallbackInterface::intf = objc_claimAutoreleasedReturnValue();
  }
  return (id)sessionManagerXPCCallbackInterface::intf;
}

void sub_2067F314C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sessionManagerXPCInterface()
{
  unsigned __int8 v0;

  {
    sessionManagerXPCInterface::$_0::operator()();
    sessionManagerXPCInterface::intf = objc_claimAutoreleasedReturnValue();
  }
  return (id)sessionManagerXPCInterface::intf;
}

void sub_2067F31C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sessionManagerXPCInterface::$_0::operator()()
{
  void *v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  objc_msgSend(MEMORY[0x24BDD1990], "interfaceWithProtocol:", &unk_254516A00);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = (void *)MEMORY[0x24BDBCF20];
  v16 = objc_opt_class();
  v15 = objc_opt_class();
  v14 = objc_opt_class();
  v13 = objc_opt_class();
  v2 = objc_opt_class();
  v3 = objc_opt_class();
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  objc_msgSend(v1, "setWithObjects:", v16, v15, v14, v13, v2, v3, v4, v5, v6, v7, v8, v9, objc_opt_class(), 0);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setXPCType:forSelector:argumentIndex:ofReply:", MEMORY[0x24BDACFE8], sel_createSession_sourceAuditToken_sourceSessionID_nameOrDeviceUID_clientProcessName_useCaseIdentifier_reply_, 2, 1);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v10, sel_getProperty_propertyName_MXProperty_reply_, 1, 1);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v10, sel_setApplicationProperty_clientID_propertyID_propertyValue_reply_, 3, 0);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v10, sel_updateApplicationProperty_clientID_propertyID_propertyValue_context_reply_, 3, 0);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v10, sel_getApplicationProperty_clientID_propertyID_isMXProperty_reply_, 1, 1);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v10, sel_setMXPropertyOnAllSessions_clientID_MXProperty_values_reply_, 3, 0);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v10, sel_getMXPropertyGenericPipe_propertyName_reply_, 1, 1);
  objc_msgSend(MEMORY[0x24BDBCF20], "setWithObject:", objc_opt_class());
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v11, sel_getEnhanceDialogueLevelWithReply_, 1, 1);

  return v0;
}

void sub_2067F345C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t as::IsStandardMXNotificationName(as *this, NSString *a2)
{
  as *v2;
  __int128 *MXNotificationNames;
  as *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  v2 = this;
  MXNotificationNames = as::GetMXNotificationNames(v2);
  v4 = v2;
  v5 = *((_QWORD *)MXNotificationNames + 1);
  if (*(_QWORD *)MXNotificationNames == v5)
  {
    v8 = 0;
  }
  else
  {
    v6 = *(_QWORD *)MXNotificationNames + 8;
    do
    {
      v7 = -[as isEqualToString:](v4, "isEqualToString:", *(_QWORD *)(v6 - 8));
      v8 = v7;
      if (v6 == v5)
        v9 = 1;
      else
        v9 = v7;
      v6 += 8;
    }
    while ((v9 & 1) == 0);
  }

  return v8;
}

void sub_2067F3508(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__int128 *as::GetSpecialMXNotificationNames(as *this)
{
  unsigned __int8 v1;
  __int128 v3;
  uint64_t v4;
  void **v5;

  if ((v1 & 1) == 0
  {
    as::GetSpecialMXNotificationNames(void)::mxNotificationNames = v3;
    qword_2545148C0 = v4;
    v4 = 0;
    v3 = 0uLL;
    v5 = (void **)&v3;
    std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
  return &as::GetSpecialMXNotificationNames(void)::mxNotificationNames;
}

void sub_2067F35B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__int128 *as::GetMXNotificationNames(as *this)
{
  unsigned __int8 v1;
  __int128 v3;
  uint64_t v4;
  void **v5;

  {
    as::GetMXNotificationNames(void)::mxNotificationNames = v3;
    qword_253E50B60 = v4;
    v4 = 0;
    v3 = 0uLL;
    v5 = (void **)&v3;
    std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
  return &as::GetMXNotificationNames(void)::mxNotificationNames;
}

void sub_2067F365C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void `virtual thunk to'CAException::~CAException(CAException *this)
{
  std::exception::~exception((std::exception *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24)));
}

{
  std::exception::~exception((std::exception *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24)));
  JUMPOUT(0x20BCFDE58);
}

void CAException::~CAException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x20BCFDE58);
}

void CAXException::~CAXException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x20BCFDE58);
}

const char *CAException::what(CAException *this)
{
  return "CAException";
}

uint64_t CAXException::what(CAXException *this)
{
  return (uint64_t)this + 8;
}

id NSErrorWithString(NSString *a1, int a2)
{
  NSString *v3;
  NSString *v4;
  void *v5;
  void *v6;
  uint64_t v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v8 = *MEMORY[0x24BDD0FC8];
    v9[0] = v3;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v9, &v8, 1);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v5 = (void *)MEMORY[0x24BDBD1B8];
  }
  objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("AVAudioSessionErrorDomain"), a2, v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

void sub_2067F37F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id NSErrorUnimplemented(void)
{
  return NSErrorWithString(CFSTR("not yet implemented"), -4);
}

BOOL FormatNSErrorForReturn(int a1, void *a2, _QWORD *a3)
{
  __CFString *v5;
  __CFString *v6;
  uint64_t v7;
  int v8;
  void *v9;
  uint64_t v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  v6 = v5;
  if (!a1)
    goto LABEL_35;
  if (a1 <= 1768386161)
  {
    if (a1 > 561145202)
    {
      if (a1 != 561145203)
      {
        if (a1 != 561211770 && a1 != 1063477620)
        {
LABEL_36:
          v7 = a1;
          if (!a3)
            goto LABEL_35;
LABEL_31:
          if (!v6)
          {
            v9 = (void *)MEMORY[0x24BDBD1B8];
            goto LABEL_34;
          }
LABEL_32:
          v11 = *MEMORY[0x24BDD0FC8];
          v12[0] = v6;
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v12, &v11, 1);
          v9 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_34:
          objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", *MEMORY[0x24BDD1100], v7, v9);
          *a3 = (id)objc_claimAutoreleasedReturnValue();

          goto LABEL_35;
        }
        goto LABEL_13;
      }
      goto LABEL_23;
    }
    if (a1 != 560030580)
    {
      v8 = 560557673;
      goto LABEL_19;
    }
LABEL_26:
    v7 = 560030580;
    if (!v5 && a3)
    {
      v6 = CFSTR("Operation not permitted while session has running audio I/Os");
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  if (a1 <= 1852794998)
  {
    if (a1 == 1768386162)
    {
      v7 = 0;
      goto LABEL_30;
    }
    v8 = 1768843583;
LABEL_19:
    if (a1 != v8)
      goto LABEL_36;
    v7 = 1836282486;
    if (!v5 && a3)
    {
      v6 = CFSTR("Session initialization error. Recent media server termination?");
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  if (a1 != 1852794999)
  {
    if (a1 == 1886681407)
    {
LABEL_13:
      v7 = 2003329396;
      if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_FAULT))
        FormatNSErrorForReturn(a1);
      goto LABEL_30;
    }
    if (a1 != 1919839847)
      goto LABEL_36;
    goto LABEL_26;
  }
LABEL_23:
  v7 = 561145203;
  if (!v5 && a3)
  {
    v6 = CFSTR("Resource not available");
    goto LABEL_32;
  }
LABEL_30:
  if (a3)
    goto LABEL_31;
LABEL_35:

  return a1 == 0;
}

void sub_2067F3A78(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL FormatNSErrorForReturn(int a1, _QWORD *a2)
{
  return FormatNSErrorForReturn(a1, 0, a2);
}

BOOL FormatNSErrorForReturn(id a1, _QWORD *a2)
{
  if (a1 && a2)
    *a2 = objc_retainAutorelease(a1);
  return a1 == 0;
}

void `anonymous namespace'::BuildSpecialMXNotificationNames(_QWORD *a1@<X8>)
{
  char *v3;
  uint64_t v4;
  uint64_t i;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x24BDAC8D0];
  v6[0] = (id)*MEMORY[0x24BE64A80];
  v6[1] = (id)*MEMORY[0x24BE64AA8];
  v6[2] = (id)*MEMORY[0x24BE64AC8];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  v3 = (char *)operator new(0x18uLL);
  v4 = 0;
  *a1 = v3;
  a1[1] = v3;
  a1[2] = v3 + 24;
  do
  {
    *(_QWORD *)&v3[v4 * 8] = (id)v6[v4];
    ++v4;
  }
  while (v4 != 3);
  a1[1] = v3 + 24;
  for (i = 2; i != -1; --i)

}

void sub_2067F3BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, char a11)
{
  uint64_t i;

  std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a9);
  for (i = 16; i != -8; i -= 8)

  _Unwind_Resume(a1);
}

void `anonymous namespace'::BuildMXNotificationsForPlatform(char **a1@<X8>)
{
  char *v3;
  uint64_t v4;
  uint64_t i;
  unsigned __int8 v6;
  id v7;
  id v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  int64x2_t v22;
  char *v23;
  char **v24;
  int64x2_t v25;
  char *v26;
  _QWORD *v27;
  _QWORD v28[32];

  v28[31] = *MEMORY[0x24BDAC8D0];
  v28[0] = (id)*MEMORY[0x24BE64A18];
  v28[1] = (id)*MEMORY[0x24BE64A58];
  v28[2] = (id)*MEMORY[0x24BE64A70];
  v28[3] = (id)*MEMORY[0x24BE64A20];
  v28[4] = (id)*MEMORY[0x24BE64A10];
  v28[5] = (id)*MEMORY[0x24BE64A68];
  v28[6] = (id)*MEMORY[0x24BE64A60];
  v28[7] = (id)*MEMORY[0x24BE649A0];
  v28[8] = (id)*MEMORY[0x24BE64A40];
  v28[9] = (id)*MEMORY[0x24BE64A38];
  v28[10] = (id)*MEMORY[0x24BE64AE0];
  v28[11] = (id)*MEMORY[0x24BE64A98];
  v28[12] = (id)*MEMORY[0x24BE64A88];
  v28[13] = (id)*MEMORY[0x24BE64A90];
  v28[14] = (id)*MEMORY[0x24BE64B50];
  v28[15] = (id)*MEMORY[0x24BE64AC0];
  v28[16] = (id)*MEMORY[0x24BE64AA0];
  v28[17] = (id)*MEMORY[0x24BE64A48];
  v28[18] = (id)*MEMORY[0x24BE64AB8];
  v28[19] = (id)*MEMORY[0x24BE64B48];
  v28[20] = CFSTR("CurrentInputDeviceBufferSizeDidChange");
  v28[21] = CFSTR("CurrentOutputDeviceBufferSizeDidChange");
  v28[22] = CFSTR("CurrentInputSampleRateDidChange");
  v28[23] = CFSTR("CurrentOutputSampleRateDidChange");
  v28[24] = (id)*MEMORY[0x24BE64A30];
  v28[25] = (id)*MEMORY[0x24BE64A28];
  v28[26] = (id)*MEMORY[0x24BE64AD8];
  v28[27] = (id)*MEMORY[0x24BE64AB0];
  v28[28] = (id)*MEMORY[0x24BE64A50];
  v28[29] = (id)*MEMORY[0x24BE64AD0];
  v28[30] = CFSTR("RouteControlFeaturesDidChange");
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v24 = a1;
  v25.i8[0] = 0;
  v3 = (char *)operator new(0xF8uLL);
  v4 = 0;
  *a1 = v3;
  a1[1] = v3;
  a1[2] = v3 + 248;
  do
  {
    *(_QWORD *)&v3[v4 * 8] = (id)v28[v4];
    ++v4;
  }
  while (v4 != 31);
  a1[1] = v3 + 248;
  for (i = 30; i != -1; --i)

  {
    as::AudioSessionMuteEnabled(void)::enabled = _os_feature_enabled_impl();
  }
  if (as::AudioSessionMuteEnabled(void)::enabled)
  {
    v7 = (id)*MEMORY[0x24BE64A78];
    v8 = v7;
    v10 = a1[1];
    v9 = (unint64_t)a1[2];
    if ((unint64_t)v10 >= v9)
    {
      v12 = (v10 - *a1) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v13 = v9 - (_QWORD)*a1;
      v14 = v13 >> 2;
      if (v13 >> 2 <= (unint64_t)(v12 + 1))
        v14 = v12 + 1;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      v27 = a1 + 2;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 2), v15);
      else
        v16 = 0;
      v17 = &v16[8 * v12];
      v18 = &v16[8 * v15];
      v26 = v18;
      *(_QWORD *)v17 = v8;
      v11 = v17 + 8;
      v25.i64[1] = (uint64_t)(v17 + 8);
      v20 = *a1;
      v19 = a1[1];
      if (v19 == *a1)
      {
        v22 = vdupq_n_s64((unint64_t)v19);
      }
      else
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *(_QWORD *)v19 = 0;
          *((_QWORD *)v17 - 1) = v21;
          v17 -= 8;
        }
        while (v19 != v20);
        v22 = *(int64x2_t *)a1;
        v11 = (char *)v25.i64[1];
        v18 = v26;
      }
      *a1 = v17;
      a1[1] = v11;
      v25 = v22;
      v23 = a1[2];
      a1[2] = v18;
      v26 = v23;
      v24 = (char **)v22.i64[0];
      std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v24);
    }
    else
    {
      *(_QWORD *)v10 = v7;
      v11 = v10 + 8;
    }
    a1[1] = v11;
  }
}

void sub_2067F4068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_2067F4150(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 1);
        v4 -= 8;

      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<NSString * {__strong}>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;

  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_2067F4310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2067F4444(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t as::client::SessionState::default_instance(as::client::SessionState *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3D00;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(_OWORD *)(v3 + 168) = 0u;
    *(_OWORD *)(v3 + 184) = 0u;
    *(_OWORD *)(v3 + 200) = 0u;
    *(_OWORD *)(v3 + 216) = 0u;
    *(_OWORD *)(v3 + 232) = 0u;
    *(_OWORD *)(v3 + 248) = 0u;
    *(_OWORD *)(v3 + 8) = 0u;
    *(_OWORD *)(v3 + 264) = 0u;
    *(_OWORD *)(v3 + 280) = 0u;
    *(_OWORD *)(v3 + 296) = 0u;
    *(_QWORD *)(v3 + 309) = 0;
    as::client::SessionState::default_instance(void)::gInstance = v3;
  }
  return as::client::SessionState::default_instance(void)::gInstance;
}

void sub_2067F45C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::client::SessionState::SessionState(as::client::SessionState *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3D00;
  result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_QWORD *)((char *)this + 309) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3D00;
  result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_QWORD *)((char *)this + 309) = 0;
  return result;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

as::client::SessionState *as::client::SessionState::SessionState(as::client::SessionState *this, const as::client::SessionState *a2)
{
  *(_QWORD *)this = &off_24BFE3D00;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  as::client::SessionState::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3D00;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  as::client::SessionState::copy_from(this, a2);
  return this;
}

__n128 as::client::SessionState::copy_from(as::client::SessionState *this, const as::client::SessionState *a2)
{
  const as::ActivationContext *v4;
  as::ActivationContext *v5;
  const as::client::TurnByTurnPref *v6;
  as::client::TurnByTurnPref *v7;
  uint64_t **v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  const as::client::PortPrefs **v13;
  const as::client::PortPrefs **i;
  uint64_t v15;
  const as::client::PortPrefs *v16;
  unint64_t v17;
  uint64_t *v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t *v26;
  char *v27;
  uint64_t v28;
  __int128 v29;
  char *v30;
  uint64_t **v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  const as::client::IOControllerPrefs **v36;
  const as::client::IOControllerPrefs **j;
  uint64_t v38;
  const as::client::IOControllerPrefs *v39;
  unint64_t v40;
  uint64_t *v41;
  _QWORD *v42;
  uint64_t *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t *v49;
  char *v50;
  uint64_t v51;
  __int128 v52;
  char *v53;
  __int128 v54;
  __n128 result;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  __int128 v59;
  char *v60;
  char *v61;

  caulk::xstring::assign((as::client::SessionState *)((char *)this + 64), (const as::client::SessionState *)((char *)a2 + 64));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 80), (const as::client::SessionState *)((char *)a2 + 80));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 96), (const as::client::SessionState *)((char *)a2 + 96));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 112), (const as::client::SessionState *)((char *)a2 + 112));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 128), (const as::client::SessionState *)((char *)a2 + 128));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 144), (const as::client::SessionState *)((char *)a2 + 144));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 160), (const as::client::SessionState *)((char *)a2 + 160));
  v4 = (const as::ActivationContext *)*((_QWORD *)a2 + 26);
  if (v4)
  {
    v5 = (as::ActivationContext *)as::client::SessionState::mutableActivationContext(this);
    as::ActivationContext::operator=(v5, v4);
  }
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 176), (const as::client::SessionState *)((char *)a2 + 176));
  v6 = (const as::client::TurnByTurnPref *)*((_QWORD *)a2 + 27);
  if (v6)
  {
    v7 = (as::client::TurnByTurnPref *)as::client::SessionState::mutableTurnByTurnPref(this);
    as::client::TurnByTurnPref::copy_from(v7, v6);
  }
  v9 = (_QWORD *)*((_QWORD *)this + 2);
  v10 = (_QWORD *)*((_QWORD *)this + 3);
  v8 = (uint64_t **)((char *)this + 16);
  while (v10 != v9)
  {
    v12 = *--v10;
    v11 = v12;
    *v10 = 0;
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  }
  *((_QWORD *)this + 3) = v9;
  v13 = (const as::client::PortPrefs **)*((_QWORD *)a2 + 2);
  for (i = (const as::client::PortPrefs **)*((_QWORD *)a2 + 3); v13 != i; ++v13)
  {
    v15 = operator new();
    v16 = *v13;
    *(_QWORD *)v15 = &off_24BFE3DE0;
    *(_OWORD *)(v15 + 16) = 0u;
    *(_OWORD *)(v15 + 32) = 0u;
    *(_QWORD *)(v15 + 48) = 0;
    as::client::PortPrefs::copy_from((as::client::PortPrefs *)v15, v16);
    v18 = (uint64_t *)*((_QWORD *)this + 3);
    v17 = *((_QWORD *)this + 4);
    if ((unint64_t)v18 >= v17)
    {
      v20 = *v8;
      v21 = v18 - *v8;
      v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v23 = v17 - (_QWORD)v20;
      if (v23 >> 2 > v22)
        v22 = v23 >> 2;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v24 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v24 = v22;
      v61 = (char *)this + 32;
      if (v24)
      {
        v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v24);
        v20 = (uint64_t *)*((_QWORD *)this + 2);
        v18 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v25 = 0;
      }
      v26 = (uint64_t *)&v25[8 * v21];
      v27 = &v25[8 * v24];
      v60 = v27;
      *v26 = v15;
      *((_QWORD *)&v59 + 1) = v26 + 1;
      if (v18 == v20)
      {
        v19 = v26 + 1;
      }
      else
      {
        do
        {
          v28 = *--v18;
          *v18 = 0;
          *--v26 = v28;
        }
        while (v18 != v20);
        v19 = (_QWORD *)*((_QWORD *)&v59 + 1);
        v27 = v60;
      }
      v29 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v26;
      *((_QWORD *)this + 3) = v19;
      v59 = v29;
      v30 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v27;
      v60 = v30;
      v58 = v29;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v58);
    }
    else
    {
      *v18 = v15;
      v19 = v18 + 1;
    }
    *((_QWORD *)this + 3) = v19;
  }
  v32 = (_QWORD *)*((_QWORD *)this + 5);
  v33 = (_QWORD *)*((_QWORD *)this + 6);
  v31 = (uint64_t **)((char *)this + 40);
  while (v33 != v32)
  {
    v35 = *--v33;
    v34 = v35;
    *v33 = 0;
    if (v35)
      (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
  }
  *((_QWORD *)this + 6) = v32;
  v36 = (const as::client::IOControllerPrefs **)*((_QWORD *)a2 + 5);
  for (j = (const as::client::IOControllerPrefs **)*((_QWORD *)a2 + 6); v36 != j; ++v36)
  {
    v38 = operator new();
    v39 = *v36;
    *(_QWORD *)v38 = &off_24BFE3DA8;
    *(_OWORD *)(v38 + 16) = 0u;
    *(_OWORD *)(v38 + 32) = 0u;
    *(_OWORD *)(v38 + 48) = 0u;
    *(_OWORD *)(v38 + 64) = 0u;
    as::client::IOControllerPrefs::copy_from((__n128 *)v38, v39);
    v41 = (uint64_t *)*((_QWORD *)this + 6);
    v40 = *((_QWORD *)this + 7);
    if ((unint64_t)v41 >= v40)
    {
      v43 = *v31;
      v44 = v41 - *v31;
      v45 = v44 + 1;
      if ((unint64_t)(v44 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v46 = v40 - (_QWORD)v43;
      if (v46 >> 2 > v45)
        v45 = v46 >> 2;
      if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
        v47 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v47 = v45;
      v61 = (char *)this + 56;
      if (v47)
      {
        v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 56, v47);
        v43 = (uint64_t *)*((_QWORD *)this + 5);
        v41 = (uint64_t *)*((_QWORD *)this + 6);
      }
      else
      {
        v48 = 0;
      }
      v49 = (uint64_t *)&v48[8 * v44];
      v50 = &v48[8 * v47];
      v60 = v50;
      *v49 = v38;
      *((_QWORD *)&v59 + 1) = v49 + 1;
      if (v41 == v43)
      {
        v42 = v49 + 1;
      }
      else
      {
        do
        {
          v51 = *--v41;
          *v41 = 0;
          *--v49 = v51;
        }
        while (v41 != v43);
        v42 = (_QWORD *)*((_QWORD *)&v59 + 1);
        v50 = v60;
      }
      v52 = *(_OWORD *)((char *)this + 40);
      *((_QWORD *)this + 5) = v49;
      *((_QWORD *)this + 6) = v42;
      v59 = v52;
      v53 = (char *)*((_QWORD *)this + 7);
      *((_QWORD *)this + 7) = v50;
      v60 = v53;
      v58 = v52;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v58);
    }
    else
    {
      *v41 = v38;
      v42 = v41 + 1;
    }
    *((_QWORD *)this + 6) = v42;
  }
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 192), (const as::client::SessionState *)((char *)a2 + 192));
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  v54 = *((_OWORD *)a2 + 15);
  *((_OWORD *)this + 14) = *((_OWORD *)a2 + 14);
  *((_OWORD *)this + 15) = v54;
  result = *((__n128 *)a2 + 16);
  v56 = *((_OWORD *)a2 + 17);
  v57 = *((_OWORD *)a2 + 18);
  *(_OWORD *)((char *)this + 301) = *(_OWORD *)((char *)a2 + 301);
  *((_OWORD *)this + 17) = v56;
  *((_OWORD *)this + 18) = v57;
  *((__n128 *)this + 16) = result;
  return result;
}

as::client::SessionState *as::client::SessionState::operator=(as::client::SessionState *a1, const as::client::SessionState *a2)
{
  as::client::SessionState::copy_from(a1, a2);
  return a1;
}

uint64_t as::client::SessionState::activationContext(as::client::SessionState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 26);
  if (!result)
    return as::ActivationContext::default_instance(0);
  return result;
}

uint64_t as::client::SessionState::mutableActivationContext(as::client::SessionState *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 26);
  if (!v1)
  {
    v1 = operator new();
    as::ActivationContext::ActivationContext(v1);
    v3 = *((_QWORD *)this + 26);
    *((_QWORD *)this + 26) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::client::SessionState::turnByTurnPref(as::client::SessionState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 27);
  if (!result)
    return as::client::TurnByTurnPref::default_instance(0);
  return result;
}

uint64_t as::client::SessionState::mutableTurnByTurnPref(as::client::SessionState *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 27);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3D38;
    *(_DWORD *)(v1 + 8) = 0;
    *(_QWORD *)(v1 + 16) = 0;
    *(_QWORD *)(v1 + 24) = 0;
    *(_BYTE *)(v1 + 32) = 0;
    v3 = *((_QWORD *)this + 27);
    *((_QWORD *)this + 27) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

as::client::TurnByTurnPref *as::client::TurnByTurnPref::operator=(as::client::TurnByTurnPref *a1, const as::client::TurnByTurnPref *a2)
{
  as::client::TurnByTurnPref::copy_from(a1, a2);
  return a1;
}

as::client::PortPrefs *as::client::PortPrefs::PortPrefs(as::client::PortPrefs *this, const as::client::PortPrefs *a2)
{
  *(_QWORD *)this = &off_24BFE3DE0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  as::client::PortPrefs::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3DE0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  as::client::PortPrefs::copy_from(this, a2);
  return this;
}

as::client::IOControllerPrefs *as::client::IOControllerPrefs::IOControllerPrefs(as::client::IOControllerPrefs *this, const as::client::IOControllerPrefs *a2)
{
  *(_QWORD *)this = &off_24BFE3DA8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  as::client::IOControllerPrefs::copy_from((__n128 *)this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3DA8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  as::client::IOControllerPrefs::copy_from((__n128 *)this, a2);
  return this;
}

uint64_t as::client::SessionState::SessionState(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE3D00;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  as::client::SessionState::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3D00;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  as::client::SessionState::move_from(a1, a2);
  return a1;
}

__n128 as::client::SessionState::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __n128 result;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v4 = *(_QWORD *)(a1 + 208);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a2 + 208) = v4;
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v5 = *(_QWORD *)(a1 + 216);
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
  *(_QWORD *)(a2 + 216) = v5;
  v6 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v6;
  v7 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v7;
  v8 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v8;
  v9 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v9;
  v10 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v10;
  v11 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v11;
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v12 = *(_OWORD *)(a2 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
  *(_OWORD *)(a1 + 240) = v12;
  result = *(__n128 *)(a2 + 256);
  v14 = *(_OWORD *)(a2 + 272);
  v15 = *(_OWORD *)(a2 + 288);
  *(_OWORD *)(a1 + 301) = *(_OWORD *)(a2 + 301);
  *(_OWORD *)(a1 + 272) = v14;
  *(_OWORD *)(a1 + 288) = v15;
  *(__n128 *)(a1 + 256) = result;
  return result;
}

uint64_t as::client::SessionState::operator=(uint64_t a1, uint64_t a2)
{
  as::client::SessionState::move_from(a1, a2);
  return a1;
}

double as::client::SessionState::clear(as::client::SessionState *this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  double result;
  _OWORD *v13;

  caulk::xstring::clear((as::client::SessionState *)((char *)this + 64));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 80));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 96));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 112));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 128));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 144));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 160));
  v2 = *((_QWORD *)this + 26);
  *((_QWORD *)this + 26) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 176));
  v3 = *((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (_QWORD *)*((_QWORD *)this + 2);
  v5 = (_QWORD *)*((_QWORD *)this + 3);
  while (v5 != v4)
  {
    v7 = *--v5;
    v6 = v7;
    *v5 = 0;
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  *((_QWORD *)this + 3) = v4;
  v8 = (_QWORD *)*((_QWORD *)this + 5);
  v9 = (_QWORD *)*((_QWORD *)this + 6);
  while (v9 != v8)
  {
    v11 = *--v9;
    v10 = v11;
    *v9 = 0;
    if (v11)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  }
  *((_QWORD *)this + 6) = v8;
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 192));
  result = 0.0;
  *((_OWORD *)this + 14) = 0u;
  v13 = (_OWORD *)((char *)this + 224);
  *((_QWORD *)v13 - 27) = 0;
  v13[1] = 0u;
  v13[2] = 0u;
  v13[3] = 0u;
  v13[4] = 0u;
  *(_OWORD *)((char *)v13 + 77) = 0u;
  return result;
}

BOOL as::client::SessionState::isInitialized(as::client::SessionState *this)
{
  uint64_t i;
  uint64_t j;
  as::client::IOControllerPrefs **v4;
  as::client::IOControllerPrefs **v5;

  for (i = *((_QWORD *)this + 2); i != *((_QWORD *)this + 3); i += 8)
  {
    for (j = *(_QWORD *)(*(_QWORD *)i + 16); j != *(_QWORD *)(*(_QWORD *)i + 24); j += 8)
    {
      if ((*(_BYTE *)(*(_QWORD *)j + 8) & 1) == 0)
        return 0;
    }
    if ((*(_BYTE *)(*(_QWORD *)i + 8) & 1) == 0)
      return 0;
  }
  v4 = (as::client::IOControllerPrefs **)*((_QWORD *)this + 5);
  v5 = (as::client::IOControllerPrefs **)*((_QWORD *)this + 6);
  while (v4 != v5)
  {
    if (!as::client::IOControllerPrefs::isInitialized(*v4))
      return 0;
    ++v4;
  }
  if ((~*((_DWORD *)this + 2) & 0x1EF) == 0)
    return (~*((_DWORD *)this + 3) & 0x38) == 0;
  return 0;
}

uint64_t as::client::PortPrefs::isInitialized(as::client::PortPrefs *this)
{
  uint64_t i;

  for (i = *((_QWORD *)this + 2); ; i += 8)
  {
    if (i == *((_QWORD *)this + 3))
      return *((_BYTE *)this + 8) & 1;
    if ((*(_BYTE *)(*(_QWORD *)i + 8) & 1) == 0)
      break;
  }
  return 0;
}

BOOL as::client::IOControllerPrefs::isInitialized(as::client::IOControllerPrefs *this)
{
  uint64_t i;
  uint64_t j;

  for (i = *((_QWORD *)this + 2); i != *((_QWORD *)this + 3); i += 8)
  {
    if ((*(_BYTE *)(*(_QWORD *)i + 8) & 1) == 0)
      return 0;
  }
  for (j = *((_QWORD *)this + 5); j != *((_QWORD *)this + 6); j += 8)
  {
    if ((*(_BYTE *)(*(_QWORD *)j + 8) & 1) == 0)
      return 0;
  }
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::client::SessionState::readFrom(uint64_t a1, uint64_t *a2)
{
  __int16 *v2;
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  BOOL v21;
  char v22;
  unsigned int v23;
  unint64_t v24;
  unint64_t v25;
  char v26;
  BOOL v27;
  unint64_t v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  _QWORD *v38;
  int v39;
  BOOL v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  int v46;
  int v47;
  BOOL v48;
  __int16 *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  unsigned int v60;
  uint64_t v61;
  unint64_t v62;
  char v63;
  int v64;
  BOOL v65;
  int v66;
  BOOL v67;
  int v68;
  BOOL v69;
  int v70;
  BOOL v71;
  int v72;
  BOOL v73;
  int v74;
  BOOL v75;
  char v76;
  unsigned int v77;
  uint64_t v78;
  unint64_t v79;
  char v80;
  char v81;
  unsigned int v82;
  uint64_t v83;
  unint64_t v84;
  char v85;
  char v86;
  unsigned int v87;
  uint64_t v88;
  unint64_t v89;
  char v90;
  char v91;
  unsigned int v92;
  uint64_t v93;
  unint64_t v94;
  char v95;
  char v96;
  unsigned int v97;
  uint64_t v98;
  unint64_t v99;
  char v100;
  char v101;
  unsigned int v102;
  uint64_t v103;
  unint64_t v104;
  char v105;
  int v106;
  BOOL v107;
  char v108;
  unsigned int v109;
  uint64_t v110;
  unint64_t v111;
  char v112;
  char v113;
  unsigned int v114;
  uint64_t v115;
  unint64_t v116;
  char v117;
  int v118;
  BOOL v119;
  int v120;
  BOOL v121;
  int v122;
  BOOL v123;
  int v124;
  BOOL v125;
  int v126;
  BOOL v127;
  int v128;
  BOOL v129;
  int v130;
  BOOL v131;
  char v132;
  unsigned int v133;
  uint64_t v134;
  unint64_t v135;
  char v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t *v140;
  _QWORD *v141;
  int v142;
  BOOL v143;
  char v144;
  unsigned int v145;
  uint64_t v146;
  unint64_t v147;
  char v148;
  unsigned int v149;
  char v150;
  unsigned int v151;
  unint64_t v152;
  char v153;
  int v154;
  char v155;
  unsigned int v156;
  unint64_t v157;
  char v158;
  char v159;
  unsigned int v160;
  unint64_t v161;
  char v162;
  char v163;
  unsigned int v164;
  unint64_t v165;
  char v166;
  char v167;
  unsigned int v168;
  unint64_t v169;
  char v170;
  char v171;
  unsigned int v172;
  unint64_t v173;
  char v174;
  char v175;
  unsigned int v176;
  unint64_t v177;
  char v178;
  char v179;
  unsigned int v180;
  unint64_t v181;
  char v182;
  char v183;
  unsigned int v184;
  unint64_t v185;
  char v186;
  char v187;
  unsigned int v188;
  unint64_t v189;
  char v190;
  char v191;
  unsigned int v192;
  unint64_t v193;
  char v194;
  char v195;
  unsigned int v196;
  unint64_t v197;
  char v198;
  char v199;
  unsigned int v200;
  unint64_t v201;
  char v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  char *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  unint64_t v211;
  char *v212;
  uint64_t *v213;
  char *v214;
  _QWORD *v215;
  _QWORD *v216;
  uint64_t v217;
  int64x2_t v218;
  uint64_t *v219;
  char *v220;
  _QWORD *v221;
  _QWORD *v222;
  uint64_t v223;
  int64x2_t v224;
  char *v225;
  uint64_t v226;
  char *v227;
  uint64_t v228;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  int64x2_t *v235;
  int64x2_t *v236;
  void *__p;
  int64x2_t v238;
  char *v239;
  uint64_t v240;

  v4 = a2[1];
  v3 = a2[2];
  v5 = *((unsigned __int8 *)a2 + 24);
  if (v4 < v3 && v5 == 0)
  {
    v236 = (int64x2_t *)(a1 + 40);
    v234 = a1 + 56;
    v235 = (int64x2_t *)(a1 + 16);
    v233 = a1 + 32;
    v9 = a1 + 144;
    v10 = a1 + 128;
    v11 = a1 + 112;
    v12 = a1 + 96;
    v13 = a1 + 80;
    v14 = a1 + 64;
    do
    {
      v15 = *a2;
      if (v4 > 0xFFFFFFFFFFFFFFF5 || v4 + 10 > v3)
      {
        v22 = 0;
        v23 = 0;
        v18 = 0;
        if (v4 <= v3)
          v24 = v3;
        else
          v24 = v4;
        while (v24 != v4)
        {
          v25 = v4++;
          v26 = *(_BYTE *)(v15 + v25);
          a2[1] = v4;
          v18 |= (unint64_t)(v26 & 0x7F) << v22;
          if ((v26 & 0x80) == 0)
            goto LABEL_22;
          v22 += 7;
          v27 = v23++ >= 9;
          if (v27)
          {
            v18 = 0;
LABEL_22:
            v19 = v25 + 1;
            goto LABEL_23;
          }
        }
        v5 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v5 == 0;
      }
      v16 = 0;
      v17 = 0;
      v18 = 0;
      while (1)
      {
        v19 = v4 + 1;
        a2[1] = v4 + 1;
        v20 = *(_BYTE *)(v15 + v4);
        v18 |= (unint64_t)(v20 & 0x7F) << v16;
        if ((v20 & 0x80) == 0)
          break;
        v16 += 7;
        v4 = v19;
        v21 = v17++ > 8;
        if (v21)
        {
          v18 = 0;
          break;
        }
      }
LABEL_23:
      if ((v18 & 7) == 4)
      {
        v5 = 0;
        return v5 == 0;
      }
      v28 = v18 >> 3;
      if ((int)(v18 >> 3) <= 99)
      {
        switch((int)v28)
        {
          case 1:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v29 = 0;
              v30 = 0;
              v31 = 0;
              do
              {
                v32 = v19 + 1;
                a2[1] = v19 + 1;
                v33 = *(_BYTE *)(v15 + v19);
                v31 |= (unint64_t)(v33 & 0x7F) << v29;
                if ((v33 & 0x80) == 0)
                  goto LABEL_372;
                v29 += 7;
                v19 = v32;
                v21 = v30++ > 8;
              }
              while (!v21);
LABEL_277:
              LODWORD(v31) = 0;
              goto LABEL_372;
            }
            v187 = 0;
            v188 = 0;
            v31 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v189 = v19 + 1;
              v190 = *(_BYTE *)(v15 + v19);
              a2[1] = v189;
              v31 |= (unint64_t)(v190 & 0x7F) << v187;
              if ((v190 & 0x80) == 0)
                goto LABEL_372;
              v187 += 7;
              v19 = v189;
              v27 = v188++ >= 9;
              if (v27)
                goto LABEL_277;
            }
            LODWORD(v31) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_372:
            *(_DWORD *)(a1 + 256) = v31;
            v149 = *(_DWORD *)(a1 + 8) | 1;
            goto LABEL_375;
          case 2:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v101 = 0;
              v102 = 0;
              v103 = 0;
              do
              {
                v104 = v19 + 1;
                a2[1] = v19 + 1;
                v105 = *(_BYTE *)(v15 + v19);
                v103 |= (unint64_t)(v105 & 0x7F) << v101;
                if ((v105 & 0x80) == 0)
                  goto LABEL_366;
                v101 += 7;
                v19 = v104;
                v21 = v102++ > 8;
              }
              while (!v21);
LABEL_254:
              LODWORD(v103) = 0;
              goto LABEL_366;
            }
            v175 = 0;
            v176 = 0;
            v103 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v177 = v19 + 1;
              v178 = *(_BYTE *)(v15 + v19);
              a2[1] = v177;
              v103 |= (unint64_t)(v178 & 0x7F) << v175;
              if ((v178 & 0x80) == 0)
                goto LABEL_366;
              v175 += 7;
              v19 = v177;
              v27 = v176++ >= 9;
              if (v27)
                goto LABEL_254;
            }
            LODWORD(v103) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_366:
            *(_DWORD *)(a1 + 260) = v103;
            v149 = *(_DWORD *)(a1 + 8) | 2;
            goto LABEL_375;
          case 3:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v96 = 0;
              v97 = 0;
              v98 = 0;
              do
              {
                v99 = v19 + 1;
                a2[1] = v19 + 1;
                v100 = *(_BYTE *)(v15 + v19);
                v98 |= (unint64_t)(v100 & 0x7F) << v96;
                if ((v100 & 0x80) == 0)
                  goto LABEL_364;
                v96 += 7;
                v19 = v99;
                v21 = v97++ > 8;
              }
              while (!v21);
LABEL_247:
              LODWORD(v98) = 0;
              goto LABEL_364;
            }
            v171 = 0;
            v172 = 0;
            v98 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v173 = v19 + 1;
              v174 = *(_BYTE *)(v15 + v19);
              a2[1] = v173;
              v98 |= (unint64_t)(v174 & 0x7F) << v171;
              if ((v174 & 0x80) == 0)
                goto LABEL_364;
              v171 += 7;
              v19 = v173;
              v27 = v172++ >= 9;
              if (v27)
                goto LABEL_247;
            }
            LODWORD(v98) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_364:
            *(_DWORD *)(a1 + 264) = v98;
            v149 = *(_DWORD *)(a1 + 8) | 4;
            goto LABEL_375;
          case 4:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v86 = 0;
              v87 = 0;
              v88 = 0;
              do
              {
                v89 = v19 + 1;
                a2[1] = v19 + 1;
                v90 = *(_BYTE *)(v15 + v19);
                v88 |= (unint64_t)(v90 & 0x7F) << v86;
                if ((v90 & 0x80) == 0)
                  goto LABEL_360;
                v86 += 7;
                v19 = v89;
                v21 = v87++ > 8;
              }
              while (!v21);
LABEL_233:
              LODWORD(v88) = 0;
              goto LABEL_360;
            }
            v163 = 0;
            v164 = 0;
            v88 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v165 = v19 + 1;
              v166 = *(_BYTE *)(v15 + v19);
              a2[1] = v165;
              v88 |= (unint64_t)(v166 & 0x7F) << v163;
              if ((v166 & 0x80) == 0)
                goto LABEL_360;
              v163 += 7;
              v19 = v165;
              v27 = v164++ >= 9;
              if (v27)
                goto LABEL_233;
            }
            LODWORD(v88) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_360:
            *(_DWORD *)(a1 + 268) = v88;
            v149 = *(_DWORD *)(a1 + 8) | 8;
            goto LABEL_375;
          case 10:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x10;
            goto LABEL_156;
          case 11:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x20;
            goto LABEL_156;
          case 12:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v113 = 0;
              v114 = 0;
              v115 = 0;
              do
              {
                v116 = v19 + 1;
                a2[1] = v19 + 1;
                v117 = *(_BYTE *)(v15 + v19);
                v115 |= (unint64_t)(v117 & 0x7F) << v113;
                if ((v117 & 0x80) == 0)
                  goto LABEL_370;
                v113 += 7;
                v19 = v116;
                v21 = v114++ > 8;
              }
              while (!v21);
LABEL_268:
              v115 = 0;
              goto LABEL_370;
            }
            v183 = 0;
            v184 = 0;
            v115 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v185 = v19 + 1;
              v186 = *(_BYTE *)(v15 + v19);
              a2[1] = v185;
              v115 |= (unint64_t)(v186 & 0x7F) << v183;
              if ((v186 & 0x80) == 0)
                goto LABEL_370;
              v183 += 7;
              v19 = v185;
              v27 = v184++ >= 9;
              if (v27)
                goto LABEL_268;
            }
            v115 = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_370:
            *(_QWORD *)(a1 + 240) = v115;
            v149 = *(_DWORD *)(a1 + 8) | 0x40;
            goto LABEL_375;
          case 13:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v91 = 0;
              v92 = 0;
              v93 = 0;
              do
              {
                v94 = v19 + 1;
                a2[1] = v19 + 1;
                v95 = *(_BYTE *)(v15 + v19);
                v93 |= (unint64_t)(v95 & 0x7F) << v91;
                if ((v95 & 0x80) == 0)
                  goto LABEL_362;
                v91 += 7;
                v19 = v94;
                v21 = v92++ > 8;
              }
              while (!v21);
LABEL_240:
              LODWORD(v93) = 0;
              goto LABEL_362;
            }
            v167 = 0;
            v168 = 0;
            v93 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v169 = v19 + 1;
              v170 = *(_BYTE *)(v15 + v19);
              a2[1] = v169;
              v93 |= (unint64_t)(v170 & 0x7F) << v167;
              if ((v170 & 0x80) == 0)
                goto LABEL_362;
              v167 += 7;
              v19 = v169;
              v27 = v168++ >= 9;
              if (v27)
                goto LABEL_240;
            }
            LODWORD(v93) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_362:
            *(_DWORD *)(a1 + 272) = v93;
            v149 = *(_DWORD *)(a1 + 8) | 0x80;
            goto LABEL_375;
          case 14:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x100;
            goto LABEL_156;
          case 15:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v76 = 0;
              v77 = 0;
              v78 = 0;
              do
              {
                v79 = v19 + 1;
                a2[1] = v19 + 1;
                v80 = *(_BYTE *)(v15 + v19);
                v78 |= (unint64_t)(v80 & 0x7F) << v76;
                if ((v80 & 0x80) == 0)
                  goto LABEL_356;
                v76 += 7;
                v19 = v79;
                v21 = v77++ > 8;
              }
              while (!v21);
LABEL_219:
              LODWORD(v78) = 0;
              goto LABEL_356;
            }
            v155 = 0;
            v156 = 0;
            v78 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v157 = v19 + 1;
              v158 = *(_BYTE *)(v15 + v19);
              a2[1] = v157;
              v78 |= (unint64_t)(v158 & 0x7F) << v155;
              if ((v158 & 0x80) == 0)
                goto LABEL_356;
              v155 += 7;
              v19 = v157;
              v27 = v156++ >= 9;
              if (v27)
                goto LABEL_219;
            }
            LODWORD(v78) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_356:
            *(_DWORD *)(a1 + 276) = v78;
            v149 = *(_DWORD *)(a1 + 8) | 0x200;
            goto LABEL_375;
          case 16:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x400;
            goto LABEL_156;
          case 17:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x800;
            goto LABEL_156;
          case 18:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x1000;
            goto LABEL_156;
          case 19:
            if (v19 >= v3)
            {
              v73 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v72 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v73 = v72 != 0;
            }
            *(_BYTE *)(a1 + 300) = v73;
            v149 = *(_DWORD *)(a1 + 8) | 0x2000;
            goto LABEL_375;
          case 20:
            if (v19 >= v3)
            {
              v121 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v120 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v121 = v120 != 0;
            }
            *(_BYTE *)(a1 + 301) = v121;
            v149 = *(_DWORD *)(a1 + 8) | 0x4000;
            goto LABEL_375;
          case 24:
            if (v19 >= v3)
            {
              v71 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v70 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v71 = v70 != 0;
            }
            *(_BYTE *)(a1 + 302) = v71;
            v149 = *(_DWORD *)(a1 + 8) | 0x8000;
            goto LABEL_375;
          case 25:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v59 = 0;
              v60 = 0;
              v61 = 0;
              do
              {
                v62 = v19 + 1;
                a2[1] = v19 + 1;
                v63 = *(_BYTE *)(v15 + v19);
                v61 |= (unint64_t)(v63 & 0x7F) << v59;
                if ((v63 & 0x80) == 0)
                  goto LABEL_354;
                v59 += 7;
                v19 = v62;
                v21 = v60++ > 8;
              }
              while (!v21);
LABEL_200:
              LODWORD(v61) = 0;
              goto LABEL_354;
            }
            v150 = 0;
            v151 = 0;
            v61 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v152 = v19 + 1;
              v153 = *(_BYTE *)(v15 + v19);
              a2[1] = v152;
              v61 |= (unint64_t)(v153 & 0x7F) << v150;
              if ((v153 & 0x80) == 0)
                goto LABEL_354;
              v150 += 7;
              v19 = v152;
              v27 = v151++ >= 9;
              if (v27)
                goto LABEL_200;
            }
            LODWORD(v61) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_354:
            *(_DWORD *)(a1 + 280) = v61;
            v149 = *(_DWORD *)(a1 + 8) | 0x10000;
            goto LABEL_375;
          case 30:
            if (v19 >= v3)
            {
              v69 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v68 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v69 = v68 != 0;
            }
            *(_BYTE *)(a1 + 303) = v69;
            v149 = *(_DWORD *)(a1 + 8) | 0x20000;
            goto LABEL_375;
          case 31:
            if (v19 >= v3)
            {
              v67 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v66 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v67 = v66 != 0;
            }
            *(_BYTE *)(a1 + 304) = v67;
            v149 = *(_DWORD *)(a1 + 8) | 0x40000;
            goto LABEL_375;
          case 32:
            if (v19 >= v3)
            {
              v123 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v122 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v123 = v122 != 0;
            }
            *(_BYTE *)(a1 + 305) = v123;
            v149 = *(_DWORD *)(a1 + 8) | 0x80000;
            goto LABEL_375;
          case 33:
            if (v19 >= v3)
            {
              v127 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v126 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v127 = v126 != 0;
            }
            *(_BYTE *)(a1 + 306) = v127;
            v149 = *(_DWORD *)(a1 + 8) | 0x100000;
            goto LABEL_375;
          case 34:
            if (v19 >= v3)
            {
              v129 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v128 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v129 = v128 != 0;
            }
            *(_BYTE *)(a1 + 307) = v129;
            v149 = *(_DWORD *)(a1 + 8) | 0x200000;
            goto LABEL_375;
          case 35:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x400000;
            goto LABEL_156;
          case 36:
            v49 = v2;
            v50 = v14;
            v51 = v13;
            v52 = v12;
            v53 = v11;
            v54 = v10;
            v55 = v9;
            v56 = operator new();
            as::ActivationContext::ActivationContext(v56);
            v58 = *(_QWORD *)(a1 + 208);
            *(_QWORD *)(a1 + 208) = v56;
            if (v58)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v58 + 8))(v58);
              v56 = *(_QWORD *)(a1 + 208);
            }
            goto LABEL_64;
          case 37:
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            v46 = *(_DWORD *)(a1 + 8) | 0x800000;
LABEL_156:
            *(_DWORD *)(a1 + 8) = v46;
            goto LABEL_157;
          case 38:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v81 = 0;
              v82 = 0;
              v83 = 0;
              do
              {
                v84 = v19 + 1;
                a2[1] = v19 + 1;
                v85 = *(_BYTE *)(v15 + v19);
                v83 |= (unint64_t)(v85 & 0x7F) << v81;
                if ((v85 & 0x80) == 0)
                  goto LABEL_358;
                v81 += 7;
                v19 = v84;
                v21 = v82++ > 8;
              }
              while (!v21);
LABEL_226:
              LODWORD(v83) = 0;
              goto LABEL_358;
            }
            v159 = 0;
            v160 = 0;
            v83 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v161 = v19 + 1;
              v162 = *(_BYTE *)(v15 + v19);
              a2[1] = v161;
              v83 |= (unint64_t)(v162 & 0x7F) << v159;
              if ((v162 & 0x80) == 0)
                goto LABEL_358;
              v159 += 7;
              v19 = v161;
              v27 = v160++ >= 9;
              if (v27)
                goto LABEL_226;
            }
            LODWORD(v83) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_358:
            *(_DWORD *)(a1 + 284) = v83;
            v149 = *(_DWORD *)(a1 + 8) | 0x1000000;
            goto LABEL_375;
          case 39:
            if (v19 >= v3)
            {
              v107 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v106 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v107 = v106 != 0;
            }
            *(_BYTE *)(a1 + 308) = v107;
            v149 = *(_DWORD *)(a1 + 8) | 0x2000000;
            goto LABEL_375;
          case 40:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v108 = 0;
              v109 = 0;
              v110 = 0;
              do
              {
                v111 = v19 + 1;
                a2[1] = v19 + 1;
                v112 = *(_BYTE *)(v15 + v19);
                v110 |= (unint64_t)(v112 & 0x7F) << v108;
                if ((v112 & 0x80) == 0)
                  goto LABEL_368;
                v108 += 7;
                v19 = v111;
                v21 = v109++ > 8;
              }
              while (!v21);
LABEL_261:
              v110 = 0;
              goto LABEL_368;
            }
            v179 = 0;
            v180 = 0;
            v110 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v181 = v19 + 1;
              v182 = *(_BYTE *)(v15 + v19);
              a2[1] = v181;
              v110 |= (unint64_t)(v182 & 0x7F) << v179;
              if ((v182 & 0x80) == 0)
                goto LABEL_368;
              v179 += 7;
              v19 = v181;
              v27 = v180++ >= 9;
              if (v27)
                goto LABEL_261;
            }
            v110 = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_368:
            *(_QWORD *)(a1 + 248) = v110;
            v149 = *(_DWORD *)(a1 + 8) | 0x4000000;
            goto LABEL_375;
          case 50:
            if (v19 <= 0xFFFFFFFFFFFFFFF5 && v19 + 10 <= v3)
            {
              v132 = 0;
              v133 = 0;
              v134 = 0;
              do
              {
                v135 = v19 + 1;
                a2[1] = v19 + 1;
                v136 = *(_BYTE *)(v15 + v19);
                v134 |= (unint64_t)(v136 & 0x7F) << v132;
                if ((v136 & 0x80) == 0)
                  goto LABEL_374;
                v132 += 7;
                v19 = v135;
                v21 = v133++ > 8;
              }
              while (!v21);
LABEL_296:
              LODWORD(v134) = 0;
              goto LABEL_374;
            }
            v191 = 0;
            v192 = 0;
            v134 = 0;
            if (v3 <= v19)
              v3 = v19;
            while (v3 != v19)
            {
              v193 = v19 + 1;
              v194 = *(_BYTE *)(v15 + v19);
              a2[1] = v193;
              v134 |= (unint64_t)(v194 & 0x7F) << v191;
              if ((v194 & 0x80) == 0)
                goto LABEL_374;
              v191 += 7;
              v19 = v193;
              v27 = v192++ >= 9;
              if (v27)
                goto LABEL_296;
            }
            LODWORD(v134) = 0;
            *((_BYTE *)a2 + 24) = 1;
LABEL_374:
            *(_DWORD *)(a1 + 288) = v134;
            v149 = *(_DWORD *)(a1 + 8) | 0x8000000;
LABEL_375:
            *(_DWORD *)(a1 + 8) = v149;
            break;
          case 51:
            if (v19 >= v3)
            {
              v131 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v130 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v131 = v130 != 0;
            }
            *(_BYTE *)(a1 + 309) = v131;
            v149 = *(_DWORD *)(a1 + 8) | 0x10000000;
            goto LABEL_375;
          case 52:
            v49 = v2;
            v50 = v14;
            v51 = v13;
            v52 = v12;
            v53 = v11;
            v54 = v10;
            v55 = v9;
            v56 = operator new();
            *(_QWORD *)v56 = &off_24BFE3D38;
            *(_DWORD *)(v56 + 8) = 0;
            *(_QWORD *)(v56 + 16) = 0;
            *(_QWORD *)(v56 + 24) = 0;
            *(_BYTE *)(v56 + 32) = 0;
            v57 = *(_QWORD *)(a1 + 216);
            *(_QWORD *)(a1 + 216) = v56;
            if (v57)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v57 + 8))(v57);
              v56 = *(_QWORD *)(a1 + 216);
            }
LABEL_64:
            if (!PB::Reader::placeMark()
              || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v56 + 16))(v56, a2) & 1) == 0)
            {
              return 0;
            }
            PB::Reader::recallMark();
            v9 = v55;
            v10 = v54;
            v11 = v53;
            v12 = v52;
            v13 = v51;
            v14 = v50;
            v2 = v49;
            goto LABEL_381;
          case 53:
            if (v19 >= v3)
            {
              v65 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v64 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v65 = v64 != 0;
            }
            *(_BYTE *)(a1 + 310) = v65;
            v149 = *(_DWORD *)(a1 + 8) | 0x20000000;
            goto LABEL_375;
          case 54:
            if (v19 >= v3)
            {
              v48 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v47 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v48 = v47 != 0;
            }
            *(_BYTE *)(a1 + 311) = v48;
            v149 = *(_DWORD *)(a1 + 8) | 0x40000000;
            goto LABEL_375;
          case 55:
            if (v19 > 0xFFFFFFFFFFFFFFFBLL || v19 + 4 > v3)
            {
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              *(_DWORD *)(a1 + 232) = *(_DWORD *)(v15 + v19);
              a2[1] += 4;
            }
            v149 = *(_DWORD *)(a1 + 8) | 0x80000000;
            goto LABEL_375;
          case 56:
            if (v19 >= v3)
            {
              v75 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v74 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v75 = v74 != 0;
            }
            *(_BYTE *)(a1 + 312) = v75;
            v154 = *(_DWORD *)(a1 + 12) | 1;
            goto LABEL_380;
          case 57:
            if (v19 >= v3)
            {
              v119 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v118 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v119 = v118 != 0;
            }
            *(_BYTE *)(a1 + 313) = v119;
            v154 = *(_DWORD *)(a1 + 12) | 2;
            goto LABEL_380;
          case 58:
            if (v19 >= v3)
            {
              v125 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v124 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v125 = v124 != 0;
            }
            *(_BYTE *)(a1 + 314) = v125;
            v154 = *(_DWORD *)(a1 + 12) | 4;
            goto LABEL_380;
          default:
            goto LABEL_381;
        }
        goto LABEL_381;
      }
      if ((int)v28 > 111)
      {
        if ((int)v28 > 150)
        {
          if ((_DWORD)v28 == 151)
          {
            if (v19 > 0xFFFFFFFFFFFFFFF5 || v19 + 10 > v3)
            {
              v195 = 0;
              v196 = 0;
              v146 = 0;
              if (v3 <= v19)
                v3 = v19;
              while (v3 != v19)
              {
                v197 = v19 + 1;
                v198 = *(_BYTE *)(v15 + v19);
                a2[1] = v197;
                v146 |= (unint64_t)(v198 & 0x7F) << v195;
                if ((v198 & 0x80) == 0)
                  goto LABEL_377;
                v195 += 7;
                v19 = v197;
                v27 = v196++ >= 9;
                if (v27)
                {
LABEL_305:
                  LODWORD(v146) = 0;
                  goto LABEL_377;
                }
              }
              LODWORD(v146) = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v144 = 0;
              v145 = 0;
              v146 = 0;
              while (1)
              {
                v147 = v19 + 1;
                a2[1] = v19 + 1;
                v148 = *(_BYTE *)(v15 + v19);
                v146 |= (unint64_t)(v148 & 0x7F) << v144;
                if ((v148 & 0x80) == 0)
                  break;
                v144 += 7;
                v19 = v147;
                v21 = v145++ > 8;
                if (v21)
                  goto LABEL_305;
              }
            }
LABEL_377:
            *(_DWORD *)(a1 + 292) = v146;
            v154 = *(_DWORD *)(a1 + 12) | 0x80;
            goto LABEL_380;
          }
          if ((_DWORD)v28 == 152)
          {
            if (v19 > 0xFFFFFFFFFFFFFFF5 || v19 + 10 > v3)
            {
              v199 = 0;
              v200 = 0;
              v43 = 0;
              if (v3 <= v19)
                v3 = v19;
              while (v3 != v19)
              {
                v201 = v19 + 1;
                v202 = *(_BYTE *)(v15 + v19);
                a2[1] = v201;
                v43 |= (unint64_t)(v202 & 0x7F) << v199;
                if ((v202 & 0x80) == 0)
                  goto LABEL_379;
                v199 += 7;
                v19 = v201;
                v27 = v200++ >= 9;
                if (v27)
                {
LABEL_314:
                  LODWORD(v43) = 0;
                  goto LABEL_379;
                }
              }
              LODWORD(v43) = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v41 = 0;
              v42 = 0;
              v43 = 0;
              while (1)
              {
                v44 = v19 + 1;
                a2[1] = v19 + 1;
                v45 = *(_BYTE *)(v15 + v19);
                v43 |= (unint64_t)(v45 & 0x7F) << v41;
                if ((v45 & 0x80) == 0)
                  break;
                v41 += 7;
                v19 = v44;
                v21 = v42++ > 8;
                if (v21)
                  goto LABEL_314;
              }
            }
LABEL_379:
            *(_DWORD *)(a1 + 296) = v43;
            v154 = *(_DWORD *)(a1 + 12) | 0x100;
            goto LABEL_380;
          }
        }
        else
        {
          if ((_DWORD)v28 == 112)
          {
            if (v19 >= v3)
            {
              v143 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v142 = *(unsigned __int8 *)(v15 + v19);
              a2[1] = v19 + 1;
              v143 = v142 != 0;
            }
            *(_BYTE *)(a1 + 316) = v143;
            v154 = *(_DWORD *)(a1 + 12) | 0x20;
LABEL_380:
            *(_DWORD *)(a1 + 12) = v154;
            goto LABEL_381;
          }
          if ((_DWORD)v28 == 150)
          {
            if (v19 > 0xFFFFFFFFFFFFFFF7 || v19 + 8 > v3)
            {
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              *(_QWORD *)(a1 + 224) = *(_QWORD *)(v15 + v19);
              a2[1] += 8;
            }
            v154 = *(_DWORD *)(a1 + 12) | 0x40;
            goto LABEL_380;
          }
        }
      }
      else
      {
        if ((int)v28 > 109)
        {
          if ((_DWORD)v28 == 110)
          {
            __p = 0;
            v238 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            *(_DWORD *)(a1 + 12) |= 8u;
LABEL_157:
            if (v238.i8[15] < 0)
              operator delete(__p);
            goto LABEL_381;
          }
          if (v19 >= v3)
          {
            v40 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v39 = *(unsigned __int8 *)(v15 + v19);
            a2[1] = v19 + 1;
            v40 = v39 != 0;
          }
          *(_BYTE *)(a1 + 315) = v40;
          v154 = *(_DWORD *)(a1 + 12) | 0x10;
          goto LABEL_380;
        }
        v232 = v9;
        v231 = v14;
        if ((_DWORD)v28 == 100)
        {
          v137 = operator new();
          v138 = v137;
          *(_QWORD *)v137 = &off_24BFE3DE0;
          *(_DWORD *)(v137 + 8) = 0;
          *(_OWORD *)(v137 + 16) = 0u;
          *(_OWORD *)(v137 + 32) = 0u;
          *(_OWORD *)(v137 + 44) = 0u;
          v140 = *(uint64_t **)(a1 + 24);
          v139 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v140 >= v139)
          {
            v203 = ((uint64_t)v140 - v235->i64[0]) >> 3;
            if ((unint64_t)(v203 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v204 = v139 - v235->i64[0];
            v205 = v204 >> 2;
            if (v204 >> 2 <= (unint64_t)(v203 + 1))
              v205 = v203 + 1;
            if ((unint64_t)v204 >= 0x7FFFFFFFFFFFFFF8)
              v206 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v206 = v205;
            v240 = v233;
            if (v206)
              v207 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v233, v206);
            else
              v207 = 0;
            v213 = (uint64_t *)&v207[8 * v203];
            v214 = &v207[8 * v206];
            v239 = v214;
            *v213 = v138;
            v141 = v213 + 1;
            v238.i64[1] = (uint64_t)(v213 + 1);
            v216 = *(_QWORD **)(a1 + 16);
            v215 = *(_QWORD **)(a1 + 24);
            if (v215 == v216)
            {
              v218 = vdupq_n_s64((unint64_t)v215);
            }
            else
            {
              do
              {
                v217 = *--v215;
                *v215 = 0;
                *--v213 = v217;
              }
              while (v215 != v216);
              v218 = *v235;
              v141 = (_QWORD *)v238.i64[1];
              v214 = v239;
            }
            *(_QWORD *)(a1 + 16) = v213;
            *(_QWORD *)(a1 + 24) = v141;
            v238 = v218;
            v225 = *(char **)(a1 + 32);
            *(_QWORD *)(a1 + 32) = v214;
            v239 = v225;
            __p = (void *)v218.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v140 = v137;
            v141 = v140 + 1;
          }
          *(_QWORD *)(a1 + 24) = v141;
          v226 = *(v141 - 1);
          if ((PB::Reader::placeMark() & 1) == 0
            || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v226 + 16))(v226, a2) & 1) == 0)
          {
            return 0;
          }
          goto LABEL_347;
        }
        if ((_DWORD)v28 == 101)
        {
          v34 = operator new();
          v35 = v34;
          *(_QWORD *)v34 = &off_24BFE3DA8;
          *(_DWORD *)(v34 + 8) = 0;
          *(_OWORD *)(v34 + 16) = 0u;
          *(_OWORD *)(v34 + 32) = 0u;
          *(_OWORD *)(v34 + 48) = 0u;
          *(_OWORD *)(v34 + 64) = 0u;
          *(_OWORD *)(v34 + 80) = 0u;
          *(_OWORD *)(v34 + 96) = 0u;
          v37 = *(uint64_t **)(a1 + 48);
          v36 = *(_QWORD *)(a1 + 56);
          if ((unint64_t)v37 >= v36)
          {
            v208 = ((uint64_t)v37 - v236->i64[0]) >> 3;
            if ((unint64_t)(v208 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v209 = v36 - v236->i64[0];
            v210 = v209 >> 2;
            if (v209 >> 2 <= (unint64_t)(v208 + 1))
              v210 = v208 + 1;
            if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFF8)
              v211 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v211 = v210;
            v240 = v234;
            if (v211)
              v212 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v234, v211);
            else
              v212 = 0;
            v219 = (uint64_t *)&v212[8 * v208];
            v220 = &v212[8 * v211];
            v239 = v220;
            *v219 = v35;
            v38 = v219 + 1;
            v238.i64[1] = (uint64_t)(v219 + 1);
            v222 = *(_QWORD **)(a1 + 40);
            v221 = *(_QWORD **)(a1 + 48);
            if (v221 == v222)
            {
              v224 = vdupq_n_s64((unint64_t)v221);
            }
            else
            {
              do
              {
                v223 = *--v221;
                *v221 = 0;
                *--v219 = v223;
              }
              while (v221 != v222);
              v224 = *v236;
              v38 = (_QWORD *)v238.i64[1];
              v220 = v239;
            }
            *(_QWORD *)(a1 + 40) = v219;
            *(_QWORD *)(a1 + 48) = v38;
            v238 = v224;
            v227 = *(char **)(a1 + 56);
            *(_QWORD *)(a1 + 56) = v220;
            v239 = v227;
            __p = (void *)v224.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v37 = v34;
            v38 = v37 + 1;
          }
          *(_QWORD *)(a1 + 48) = v38;
          v228 = *(v38 - 1);
          if ((PB::Reader::placeMark() & 1) == 0
            || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v228 + 16))(v228, a2) & 1) == 0)
          {
            return 0;
          }
LABEL_347:
          PB::Reader::recallMark();
          v9 = v232;
          v14 = v231;
          v2 = &jpt_2067F54E4;
        }
      }
LABEL_381:
      v4 = a2[1];
      v3 = a2[2];
      v5 = *((unsigned __int8 *)a2 + 24);
    }
    while (v4 < v3 && v5 == 0);
  }
  return v5 == 0;
}

void sub_2067F6A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;

  (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  _Unwind_Resume(a1);
}

void as::client::SessionState::writeTo(as::client::SessionState *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  const PB::Base *v12;
  int v13;
  char *v14;
  const PB::Base *v15;
  int v16;
  int v17;
  const PB::Base **v18;
  const PB::Base **v19;
  const PB::Base *v20;
  const PB::Base **v21;
  const PB::Base **v22;
  const PB::Base *v23;
  int v24;
  char *v25;
  void *__p[2];
  char v27;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_37;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_38;
  }
LABEL_37:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_39;
  }
LABEL_38:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_42;
  }
LABEL_39:
  v8 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(__p, v8);
  PB::Writer::write();
  if (v27 < 0)
    operator delete(__p[0]);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_45;
  }
LABEL_42:
  v9 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 80));
  std::string::basic_string[abi:ne180100]<0>(__p, v9);
  PB::Writer::write();
  if (v27 < 0)
    operator delete(__p[0]);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_46;
  }
LABEL_45:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x80) == 0)
  {
LABEL_9:
    if ((v4 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_47;
  }
LABEL_46:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x100) == 0)
  {
LABEL_10:
    if ((v4 & 0x200) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_47:
  v10 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 96));
  std::string::basic_string[abi:ne180100]<0>(__p, v10);
  PB::Writer::write();
  if (v27 < 0)
    operator delete(__p[0]);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x200) != 0)
  {
LABEL_11:
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
LABEL_12:
  if ((v4 & 0x400) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 112));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v27 < 0)
      operator delete(__p[0]);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 0x800) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 128));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::Writer::write();
    if (v27 < 0)
      operator delete(__p[0]);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 0x1000) != 0)
  {
    v7 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 144));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::Writer::write();
    if (v27 < 0)
      operator delete(__p[0]);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 0x2000) != 0)
  {
    PB::Writer::write(a2);
    v4 = *((_DWORD *)this + 2);
    if ((v4 & 0x4000) == 0)
    {
LABEL_26:
      if ((v4 & 0x8000) == 0)
        goto LABEL_27;
      goto LABEL_53;
    }
  }
  else if ((v4 & 0x4000) == 0)
  {
    goto LABEL_26;
  }
  PB::Writer::write(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x8000) == 0)
  {
LABEL_27:
    if ((v4 & 0x10000) == 0)
      goto LABEL_28;
    goto LABEL_54;
  }
LABEL_53:
  PB::Writer::write(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10000) == 0)
  {
LABEL_28:
    if ((v4 & 0x20000) == 0)
      goto LABEL_29;
    goto LABEL_55;
  }
LABEL_54:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20000) == 0)
  {
LABEL_29:
    if ((v4 & 0x40000) == 0)
      goto LABEL_30;
    goto LABEL_56;
  }
LABEL_55:
  PB::Writer::write(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x40000) == 0)
  {
LABEL_30:
    if ((v4 & 0x80000) == 0)
      goto LABEL_31;
    goto LABEL_57;
  }
LABEL_56:
  PB::Writer::write(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x80000) == 0)
  {
LABEL_31:
    if ((v4 & 0x100000) == 0)
      goto LABEL_32;
    goto LABEL_58;
  }
LABEL_57:
  PB::Writer::write(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x100000) == 0)
  {
LABEL_32:
    if ((v4 & 0x200000) == 0)
      goto LABEL_33;
    goto LABEL_59;
  }
LABEL_58:
  PB::Writer::write(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x200000) == 0)
  {
LABEL_33:
    if ((v4 & 0x400000) == 0)
      goto LABEL_62;
    goto LABEL_60;
  }
LABEL_59:
  PB::Writer::write(a2);
  if ((*((_DWORD *)this + 2) & 0x400000) == 0)
    goto LABEL_62;
LABEL_60:
  v11 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 160));
  std::string::basic_string[abi:ne180100]<0>(__p, v11);
  PB::Writer::write();
  if (v27 < 0)
    operator delete(__p[0]);
LABEL_62:
  v12 = (const PB::Base *)*((_QWORD *)this + 26);
  if (v12)
    PB::Writer::writeSubmessage(a2, v12);
  v13 = *((_DWORD *)this + 2);
  if ((v13 & 0x800000) != 0)
  {
    v14 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 176));
    std::string::basic_string[abi:ne180100]<0>(__p, v14);
    PB::Writer::write();
    if (v27 < 0)
      operator delete(__p[0]);
    v13 = *((_DWORD *)this + 2);
  }
  if ((v13 & 0x1000000) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v13 = *((_DWORD *)this + 2);
    if ((v13 & 0x2000000) == 0)
    {
LABEL_70:
      if ((v13 & 0x4000000) == 0)
        goto LABEL_71;
      goto LABEL_102;
    }
  }
  else if ((v13 & 0x2000000) == 0)
  {
    goto LABEL_70;
  }
  PB::Writer::write(a2);
  v13 = *((_DWORD *)this + 2);
  if ((v13 & 0x4000000) == 0)
  {
LABEL_71:
    if ((v13 & 0x8000000) == 0)
      goto LABEL_72;
    goto LABEL_103;
  }
LABEL_102:
  PB::Writer::writeVarInt(a2);
  v13 = *((_DWORD *)this + 2);
  if ((v13 & 0x8000000) == 0)
  {
LABEL_72:
    if ((v13 & 0x10000000) == 0)
      goto LABEL_74;
    goto LABEL_73;
  }
LABEL_103:
  PB::Writer::writeVarInt(a2);
  if ((*((_DWORD *)this + 2) & 0x10000000) != 0)
LABEL_73:
    PB::Writer::write(a2);
LABEL_74:
  v15 = (const PB::Base *)*((_QWORD *)this + 27);
  if (v15)
    PB::Writer::writeSubmessage(a2, v15);
  v16 = *((_DWORD *)this + 2);
  if ((v16 & 0x20000000) == 0)
  {
    if ((v16 & 0x40000000) == 0)
      goto LABEL_78;
LABEL_106:
    PB::Writer::write(a2);
    if ((*((_DWORD *)this + 2) & 0x80000000) == 0)
      goto LABEL_79;
    goto LABEL_107;
  }
  PB::Writer::write(a2);
  v16 = *((_DWORD *)this + 2);
  if ((v16 & 0x40000000) != 0)
    goto LABEL_106;
LABEL_78:
  if ((v16 & 0x80000000) == 0)
    goto LABEL_79;
LABEL_107:
  PB::Writer::write(a2, *((float *)this + 58));
LABEL_79:
  v17 = *((_DWORD *)this + 3);
  if ((v17 & 1) == 0)
  {
    if ((v17 & 2) == 0)
      goto LABEL_81;
LABEL_109:
    PB::Writer::write(a2);
    if ((*((_DWORD *)this + 3) & 4) == 0)
      goto LABEL_83;
    goto LABEL_82;
  }
  PB::Writer::write(a2);
  v17 = *((_DWORD *)this + 3);
  if ((v17 & 2) != 0)
    goto LABEL_109;
LABEL_81:
  if ((v17 & 4) != 0)
LABEL_82:
    PB::Writer::write(a2);
LABEL_83:
  v18 = (const PB::Base **)*((_QWORD *)this + 2);
  v19 = (const PB::Base **)*((_QWORD *)this + 3);
  while (v18 != v19)
  {
    v20 = *v18++;
    PB::Writer::writeSubmessage(a2, v20);
  }
  v21 = (const PB::Base **)*((_QWORD *)this + 5);
  v22 = (const PB::Base **)*((_QWORD *)this + 6);
  while (v21 != v22)
  {
    v23 = *v21++;
    PB::Writer::writeSubmessage(a2, v23);
  }
  v24 = *((_DWORD *)this + 3);
  if ((v24 & 8) != 0)
  {
    v25 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 192));
    std::string::basic_string[abi:ne180100]<0>(__p, v25);
    PB::Writer::write();
    if (v27 < 0)
      operator delete(__p[0]);
    v24 = *((_DWORD *)this + 3);
  }
  if ((v24 & 0x10) != 0)
  {
    PB::Writer::write(a2);
    v24 = *((_DWORD *)this + 3);
    if ((v24 & 0x20) == 0)
    {
LABEL_95:
      if ((v24 & 0x40) == 0)
        goto LABEL_96;
      goto LABEL_113;
    }
  }
  else if ((v24 & 0x20) == 0)
  {
    goto LABEL_95;
  }
  PB::Writer::write(a2);
  v24 = *((_DWORD *)this + 3);
  if ((v24 & 0x40) == 0)
  {
LABEL_96:
    if ((v24 & 0x80) == 0)
      goto LABEL_97;
    goto LABEL_114;
  }
LABEL_113:
  PB::Writer::write(a2, *((double *)this + 28));
  v24 = *((_DWORD *)this + 3);
  if ((v24 & 0x80) == 0)
  {
LABEL_97:
    if ((v24 & 0x100) == 0)
      return;
    goto LABEL_98;
  }
LABEL_114:
  PB::Writer::writeVarInt(a2);
  if ((*((_DWORD *)this + 3) & 0x100) == 0)
    return;
LABEL_98:
  PB::Writer::writeVarInt(a2);
}

void sub_2067F70C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::client::SessionState::formatText(as::client::SessionState *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  int v14;
  char *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  char *v26;
  void *__p[2];
  char v29;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "sessionToken");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_37;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "generationCount");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
    goto LABEL_38;
  }
LABEL_37:
  PB::TextFormatter::format(a2, "originatingProcessToken");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_39;
  }
LABEL_38:
  PB::TextFormatter::format(a2, "processOwningIOResources");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_42;
  }
LABEL_39:
  v9 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(__p, v9);
  PB::TextFormatter::format();
  if (v29 < 0)
    operator delete(__p[0]);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_45;
  }
LABEL_42:
  v10 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 80));
  std::string::basic_string[abi:ne180100]<0>(__p, v10);
  PB::TextFormatter::format();
  if (v29 < 0)
    operator delete(__p[0]);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40) == 0)
  {
LABEL_8:
    if ((v5 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_46;
  }
LABEL_45:
  PB::TextFormatter::format(a2, "categoryOptions");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x80) == 0)
  {
LABEL_9:
    if ((v5 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_47;
  }
LABEL_46:
  PB::TextFormatter::format(a2, "routeSharingPolicy");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x100) == 0)
  {
LABEL_10:
    if ((v5 & 0x200) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_47:
  v11 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 96));
  std::string::basic_string[abi:ne180100]<0>(__p, v11);
  PB::TextFormatter::format();
  if (v29 < 0)
    operator delete(__p[0]);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x200) != 0)
  {
LABEL_11:
    PB::TextFormatter::format(a2, "outputPortOverride");
    v5 = *((_DWORD *)this + 2);
  }
LABEL_12:
  if ((v5 & 0x400) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 112));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v29 < 0)
      operator delete(__p[0]);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 0x800) != 0)
  {
    v7 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 128));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v29 < 0)
      operator delete(__p[0]);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 0x1000) != 0)
  {
    v8 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 144));
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::TextFormatter::format();
    if (v29 < 0)
      operator delete(__p[0]);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 0x2000) != 0)
  {
    PB::TextFormatter::format(a2, "allowHapticsAndSystemSoundsDuringRecording");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 0x4000) == 0)
    {
LABEL_26:
      if ((v5 & 0x8000) == 0)
        goto LABEL_27;
      goto LABEL_53;
    }
  }
  else if ((v5 & 0x4000) == 0)
  {
    goto LABEL_26;
  }
  PB::TextFormatter::format(a2, "prefersNoInterruptionsFromSystemAlerts");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x8000) == 0)
  {
LABEL_27:
    if ((v5 & 0x10000) == 0)
      goto LABEL_28;
    goto LABEL_54;
  }
LABEL_53:
  PB::TextFormatter::format(a2, "microphoneFollowsCamera");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10000) == 0)
  {
LABEL_28:
    if ((v5 & 0x20000) == 0)
      goto LABEL_29;
    goto LABEL_55;
  }
LABEL_54:
  PB::TextFormatter::format(a2, "aggregatedIOPreference");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20000) == 0)
  {
LABEL_29:
    if ((v5 & 0x40000) == 0)
      goto LABEL_30;
    goto LABEL_56;
  }
LABEL_55:
  PB::TextFormatter::format(a2, "forceSoundCheck");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40000) == 0)
  {
LABEL_30:
    if ((v5 & 0x80000) == 0)
      goto LABEL_31;
    goto LABEL_57;
  }
LABEL_56:
  PB::TextFormatter::format(a2, "usingLongFormAudio");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x80000) == 0)
  {
LABEL_31:
    if ((v5 & 0x100000) == 0)
      goto LABEL_32;
    goto LABEL_58;
  }
LABEL_57:
  PB::TextFormatter::format(a2, "allowAllBuiltInDataSources");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x100000) == 0)
  {
LABEL_32:
    if ((v5 & 0x200000) == 0)
      goto LABEL_33;
    goto LABEL_59;
  }
LABEL_58:
  PB::TextFormatter::format(a2, "fixHardwareFormatToMultiChannel");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x200000) == 0)
  {
LABEL_33:
    if ((v5 & 0x400000) == 0)
      goto LABEL_62;
    goto LABEL_60;
  }
LABEL_59:
  PB::TextFormatter::format(a2, "iAmTheAssistant");
  if ((*((_DWORD *)this + 2) & 0x400000) == 0)
    goto LABEL_62;
LABEL_60:
  v12 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 160));
  std::string::basic_string[abi:ne180100]<0>(__p, v12);
  PB::TextFormatter::format();
  if (v29 < 0)
    operator delete(__p[0]);
LABEL_62:
  v13 = *((_QWORD *)this + 26);
  if (v13)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v13 + 32))(v13, a2, "activationContext");
  v14 = *((_DWORD *)this + 2);
  if ((v14 & 0x800000) != 0)
  {
    v15 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 176));
    std::string::basic_string[abi:ne180100]<0>(__p, v15);
    PB::TextFormatter::format();
    if (v29 < 0)
      operator delete(__p[0]);
    v14 = *((_DWORD *)this + 2);
  }
  if ((v14 & 0x1000000) != 0)
  {
    PB::TextFormatter::format(a2, "interruptionPriority");
    v14 = *((_DWORD *)this + 2);
    if ((v14 & 0x2000000) == 0)
    {
LABEL_70:
      if ((v14 & 0x4000000) == 0)
        goto LABEL_71;
      goto LABEL_100;
    }
  }
  else if ((v14 & 0x2000000) == 0)
  {
    goto LABEL_70;
  }
  PB::TextFormatter::format(a2, "bypassRingerSwitchPolicy");
  v14 = *((_DWORD *)this + 2);
  if ((v14 & 0x4000000) == 0)
  {
LABEL_71:
    if ((v14 & 0x8000000) == 0)
      goto LABEL_72;
    goto LABEL_101;
  }
LABEL_100:
  PB::TextFormatter::format(a2, "hardwareControlFlags");
  v14 = *((_DWORD *)this + 2);
  if ((v14 & 0x8000000) == 0)
  {
LABEL_72:
    if ((v14 & 0x10000000) == 0)
      goto LABEL_74;
    goto LABEL_73;
  }
LABEL_101:
  PB::TextFormatter::format(a2, "reporterID");
  if ((*((_DWORD *)this + 2) & 0x10000000) != 0)
LABEL_73:
    PB::TextFormatter::format(a2, "selectIndependentRoutingContext");
LABEL_74:
  v16 = *((_QWORD *)this + 27);
  if (v16)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v16 + 32))(v16, a2, "turnByTurnPref");
  v17 = *((_DWORD *)this + 2);
  if ((v17 & 0x20000000) == 0)
  {
    if ((v17 & 0x40000000) == 0)
      goto LABEL_78;
LABEL_104:
    PB::TextFormatter::format(a2, "requiresNoAudioResources");
    if ((*((_DWORD *)this + 2) & 0x80000000) == 0)
      goto LABEL_79;
    goto LABEL_105;
  }
  PB::TextFormatter::format(a2, "voiceProcessingRoutingEnabled");
  v17 = *((_DWORD *)this + 2);
  if ((v17 & 0x40000000) != 0)
    goto LABEL_104;
LABEL_78:
  if ((v17 & 0x80000000) == 0)
    goto LABEL_79;
LABEL_105:
  PB::TextFormatter::format(a2, "interruptionFadeDuration", *((float *)this + 58));
LABEL_79:
  v18 = *((_DWORD *)this + 3);
  if ((v18 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "allowMixableAudioWhileRecording");
    v18 = *((_DWORD *)this + 3);
    if ((v18 & 2) == 0)
    {
LABEL_81:
      if ((v18 & 4) == 0)
        goto LABEL_83;
      goto LABEL_82;
    }
  }
  else if ((v18 & 2) == 0)
  {
    goto LABEL_81;
  }
  PB::TextFormatter::format(a2, "recordingFromRemoteInput");
  if ((*((_DWORD *)this + 3) & 4) != 0)
LABEL_82:
    PB::TextFormatter::format(a2, "prefersNoDucking");
LABEL_83:
  v19 = (uint64_t *)*((_QWORD *)this + 2);
  v20 = (uint64_t *)*((_QWORD *)this + 3);
  while (v19 != v20)
  {
    v21 = *v19++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v21 + 32))(v21, a2, "portPrefs");
  }
  v22 = (uint64_t *)*((_QWORD *)this + 5);
  v23 = (uint64_t *)*((_QWORD *)this + 6);
  while (v22 != v23)
  {
    v24 = *v22++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v24 + 32))(v24, a2, "ioControllerPrefs");
  }
  v25 = *((_DWORD *)this + 3);
  if ((v25 & 8) != 0)
  {
    v26 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 192));
    std::string::basic_string[abi:ne180100]<0>(__p, v26);
    PB::TextFormatter::format();
    if (v29 < 0)
      operator delete(__p[0]);
    v25 = *((_DWORD *)this + 3);
  }
  if ((v25 & 0x10) != 0)
  {
    PB::TextFormatter::format(a2, "wantsBackgroundAudio");
    v25 = *((_DWORD *)this + 3);
    if ((v25 & 0x20) == 0)
    {
LABEL_93:
      if ((v25 & 0x40) == 0)
        goto LABEL_94;
      goto LABEL_111;
    }
  }
  else if ((v25 & 0x20) == 0)
  {
    goto LABEL_93;
  }
  PB::TextFormatter::format(a2, "wantsMicrophonePermission");
  v25 = *((_DWORD *)this + 3);
  if ((v25 & 0x40) == 0)
  {
LABEL_94:
    if ((v25 & 0x80) == 0)
      goto LABEL_95;
LABEL_112:
    PB::TextFormatter::format(a2, "preferredInputNumberOfChannels");
    if ((*((_DWORD *)this + 3) & 0x100) == 0)
      return PB::TextFormatter::endObject(a2);
    goto LABEL_96;
  }
LABEL_111:
  PB::TextFormatter::format(a2, "preferredSampleRate", *((double *)this + 28));
  v25 = *((_DWORD *)this + 3);
  if ((v25 & 0x80) != 0)
    goto LABEL_112;
LABEL_95:
  if ((v25 & 0x100) != 0)
LABEL_96:
    PB::TextFormatter::format(a2, "preferredOutputNumberOfChannels");
  return PB::TextFormatter::endObject(a2);
}

void sub_2067F7844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::client::SessionState::operator==(_QWORD *a1, _QWORD *a2)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;

  if (a1[1] != a2[1]
    || memcmp(a1 + 28, a2 + 28, 0x5DuLL)
    || caulk::xstring::compare((caulk::xstring *)(a1 + 8), (const caulk::xstring *)(a2 + 8))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 10), (const caulk::xstring *)(a2 + 10))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 12), (const caulk::xstring *)(a2 + 12))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 14), (const caulk::xstring *)(a2 + 14))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 18), (const caulk::xstring *)(a2 + 18))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 20), (const caulk::xstring *)(a2 + 20)))
  {
    return 0;
  }
  v5 = a1[26];
  v6 = a2[26];
  if (v5 && v6)
  {
    if (!as::ActivationContext::operator==(v5, v6))
      return 0;
  }
  else if (v5 | v6)
  {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 22), (const caulk::xstring *)(a2 + 22)))
    return 0;
  v7 = a1[27];
  v8 = a2[27];
  if (v7 && v8)
  {
    if (as::client::TurnByTurnPref::operator==(v7, v8))
      goto LABEL_22;
    return 0;
  }
  if (v7 | v8)
    return 0;
LABEL_22:
  v10 = a1[2];
  v9 = a1[3];
  v11 = (v9 - v10) >> 3;
  if (v11 != (uint64_t)(a2[3] - a2[2]) >> 3)
    return 0;
  if (v9 != v10)
  {
    v12 = 0;
    if (v11 <= 1)
      v13 = 1;
    else
      v13 = v11;
    do
    {
      v14 = *(_QWORD *)(a1[2] + 8 * v12);
      v15 = v12;
      v16 = *(_QWORD *)(a2[2] + 8 * v12);
      if (v14)
        v17 = v16 == 0;
      else
        v17 = 1;
      if (v17)
      {
        if (v14 | v16)
          return 0;
      }
      else if (!as::client::PortPrefs::operator==(v14, v16))
      {
        return 0;
      }
      v12 = v15 + 1;
    }
    while (v13 != v15 + 1);
  }
  v19 = a1[5];
  v18 = a1[6];
  v20 = (v18 - v19) >> 3;
  if (v20 != (uint64_t)(a2[6] - a2[5]) >> 3)
    return 0;
  if (v18 != v19)
  {
    v21 = 0;
    if (v20 <= 1)
      v22 = 1;
    else
      v22 = (v18 - v19) >> 3;
    do
    {
      v23 = *(_QWORD *)(a1[5] + 8 * v21);
      v24 = *(_QWORD *)(a2[5] + 8 * v21);
      if (v23)
        v25 = v24 == 0;
      else
        v25 = 1;
      if (v25)
      {
        if (v23 | v24)
          return 0;
      }
      else if (!as::client::IOControllerPrefs::operator==(v23, v24))
      {
        return 0;
      }
      ++v21;
    }
    while (v22 != v21);
  }
  return caulk::xstring::compare((caulk::xstring *)(a1 + 24), (const caulk::xstring *)(a2 + 24)) == 0;
}

uint64_t as::client::SessionState::clearActivationContext(as::client::SessionState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 26);
  *((_QWORD *)this + 26) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::client::TurnByTurnPref::default_instance(as::client::TurnByTurnPref *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3D38;
    *(_DWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 24) = 0;
    *(_BYTE *)(v3 + 32) = 0;
    as::client::TurnByTurnPref::default_instance(void)::gInstance = v3;
  }
  return as::client::TurnByTurnPref::default_instance(void)::gInstance;
}

void sub_2067F7B34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::client::TurnByTurnPref::TurnByTurnPref(uint64_t this)
{
  *(_QWORD *)this = &off_24BFE3D38;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 32) = 0;
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3D38;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 32) = 0;
  return this;
}

uint64_t as::client::SessionState::clearTurnByTurnPref(as::client::SessionState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::client::SessionState::addPortPrefs(as::client::SessionState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3DE0;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 44) = 0u;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::client::SessionState::addIoControllerPrefs(as::client::SessionState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3DA8;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::client::PortPrefs::default_instance(as::client::PortPrefs *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3DE0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 44) = 0u;
    as::client::PortPrefs::default_instance(void)::gInstance = v3;
  }
  return as::client::PortPrefs::default_instance(void)::gInstance;
}

void sub_2067F7ECC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::client::PortPrefs::PortPrefs(as::client::PortPrefs *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3DE0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3DE0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

uint64_t as::client::PortPrefs::copy_from(as::client::PortPrefs *this, const as::client::PortPrefs *a2)
{
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  uint64_t v24;
  __int128 v25;
  char *v26;
  const as::client::PortPrefs *i;
  uint64_t v28;
  __int128 v29;
  char *v30;
  char *v31;

  result = caulk::xstring::assign((as::client::PortPrefs *)((char *)this + 40), (const as::client::PortPrefs *)((char *)a2 + 40));
  v5 = (_QWORD *)*((_QWORD *)this + 2);
  v7 = (_QWORD *)*((_QWORD *)this + 3);
  v6 = (_QWORD *)((char *)this + 16);
  while (v7 != v5)
  {
    v8 = *--v7;
    result = v8;
    *v7 = 0;
    if (v8)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 3) = v5;
  v9 = (uint64_t *)*((_QWORD *)a2 + 2);
  v10 = (uint64_t *)*((_QWORD *)a2 + 3);
  for (i = a2; v9 != v10; ++v9)
  {
    result = operator new();
    v11 = result;
    v12 = *v9;
    *(_QWORD *)result = &off_24BFE3D70;
    *(_DWORD *)(result + 8) = *(_DWORD *)(v12 + 8);
    *(_QWORD *)(result + 12) = *(_QWORD *)(v12 + 12);
    v14 = (_QWORD *)*((_QWORD *)this + 3);
    v13 = *((_QWORD *)this + 4);
    if ((unint64_t)v14 >= v13)
    {
      v16 = (_QWORD *)*v6;
      v17 = ((uint64_t)v14 - *v6) >> 3;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v31 = (char *)this + 32;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v20);
        v16 = (_QWORD *)*((_QWORD *)this + 2);
        v14 = (_QWORD *)*((_QWORD *)this + 3);
      }
      else
      {
        v21 = 0;
      }
      v22 = (uint64_t *)&v21[8 * v17];
      v23 = &v21[8 * v20];
      v30 = v23;
      *v22 = v11;
      *((_QWORD *)&v29 + 1) = v22 + 1;
      if (v14 == v16)
      {
        v15 = v22 + 1;
      }
      else
      {
        do
        {
          v24 = *--v14;
          *v14 = 0;
          *--v22 = v24;
        }
        while (v14 != v16);
        v15 = (_QWORD *)*((_QWORD *)&v29 + 1);
        v23 = v30;
      }
      v25 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v22;
      *((_QWORD *)this + 3) = v15;
      v29 = v25;
      v26 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v23;
      v30 = v26;
      v28 = v25;
      result = std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v28);
    }
    else
    {
      *v14 = result;
      v15 = v14 + 1;
    }
    *((_QWORD *)this + 3) = v15;
  }
  *((_DWORD *)this + 2) = *((_DWORD *)i + 2);
  *((_DWORD *)this + 14) = *((_DWORD *)i + 14);
  return result;
}

as::client::PortPrefs *as::client::PortPrefs::operator=(as::client::PortPrefs *a1, const as::client::PortPrefs *a2)
{
  as::client::PortPrefs::copy_from(a1, a2);
  return a1;
}

uint64_t as::client::PolarPatternPref::PolarPatternPref(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = &off_24BFE3D70;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 12) = *(_QWORD *)(a2 + 12);
  return result;
}

{
  *(_QWORD *)result = &off_24BFE3D70;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 12) = *(_QWORD *)(a2 + 12);
  return result;
}

{
  *(_QWORD *)result = &off_24BFE3D70;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 12) = *(_QWORD *)(a2 + 12);
  return result;
}

uint64_t as::client::PortPrefs::PortPrefs(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE3DE0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0;
  as::client::PortPrefs::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3DE0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0;
  as::client::PortPrefs::move_from(a1, a2);
  return a1;
}

uint64_t as::client::PortPrefs::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[2];

  v8[0] = 0;
  v8[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)v8);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v5;
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v6;
  v7 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v7;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  return result;
}

uint64_t as::client::PortPrefs::operator=(uint64_t a1, uint64_t a2)
{
  as::client::PortPrefs::move_from(a1, a2);
  return a1;
}

uint64_t as::client::PortPrefs::clear(as::client::PortPrefs *this)
{
  uint64_t result;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  result = caulk::xstring::clear((as::client::PortPrefs *)((char *)this + 40));
  v3 = (_QWORD *)*((_QWORD *)this + 2);
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  while (v4 != v3)
  {
    v5 = *--v4;
    result = v5;
    *v4 = 0;
    if (v5)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 3) = v3;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 14) = 0;
  return result;
}

uint64_t as::client::PolarPatternPref::isInitialized(as::client::PolarPatternPref *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::client::PortPrefs::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  BOOL v16;
  char v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  char v21;
  BOOL v22;
  unint64_t v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t *v32;
  _QWORD *v33;
  char v34;
  unsigned int v35;
  unint64_t v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t *v43;
  char *v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  int64x2_t v48;
  char *v49;
  uint64_t v50;
  void *__p;
  int64x2_t v54;
  char *v55;
  uint64_t v56;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v8 = (int64x2_t *)(a1 + 16);
    v9 = a1 + 32;
    while (1)
    {
      v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        break;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v3 + 1;
        a2[1] = v3 + 1;
        v15 = *(_BYTE *)(v10 + v3);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v3 = v14;
        v16 = v12++ > 8;
        if (v16)
        {
          v13 = 0;
          break;
        }
      }
LABEL_23:
      if ((v13 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v23 = v13 >> 3;
      if ((v13 >> 3) == 3)
      {
        v29 = operator new();
        v30 = v29;
        *(_QWORD *)v29 = &off_24BFE3D70;
        *(_DWORD *)(v29 + 8) = 0;
        *(_QWORD *)(v29 + 12) = 0;
        v32 = *(uint64_t **)(a1 + 24);
        v31 = *(_QWORD *)(a1 + 32);
        if ((unint64_t)v32 >= v31)
        {
          v38 = ((uint64_t)v32 - v8->i64[0]) >> 3;
          if ((unint64_t)(v38 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v39 = v31 - v8->i64[0];
          v40 = v39 >> 2;
          if (v39 >> 2 <= (unint64_t)(v38 + 1))
            v40 = v38 + 1;
          if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
            v41 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v41 = v40;
          v56 = v9;
          if (v41)
            v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v41);
          else
            v42 = 0;
          v43 = (uint64_t *)&v42[8 * v38];
          v44 = &v42[8 * v41];
          v55 = v44;
          *v43 = v30;
          v33 = v43 + 1;
          v54.i64[1] = (uint64_t)(v43 + 1);
          v46 = *(_QWORD **)(a1 + 16);
          v45 = *(_QWORD **)(a1 + 24);
          if (v45 == v46)
          {
            v48 = vdupq_n_s64((unint64_t)v45);
          }
          else
          {
            do
            {
              v47 = *--v45;
              *v45 = 0;
              *--v43 = v47;
            }
            while (v45 != v46);
            v48 = *v8;
            v33 = (_QWORD *)v54.i64[1];
            v44 = v55;
          }
          *(_QWORD *)(a1 + 16) = v43;
          *(_QWORD *)(a1 + 24) = v33;
          v54 = v48;
          v49 = *(char **)(a1 + 32);
          *(_QWORD *)(a1 + 32) = v44;
          v55 = v49;
          __p = (void *)v48.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v32 = v29;
          v33 = v32 + 1;
        }
        *(_QWORD *)(a1 + 24) = v33;
        v50 = *(v33 - 1);
        if ((PB::Reader::placeMark() & 1) == 0
          || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v50 + 16))(v50, a2) & 1) == 0)
        {
          return 0;
        }
        PB::Reader::recallMark();
      }
      else if ((_DWORD)v23 == 2)
      {
        if (v14 > 0xFFFFFFFFFFFFFFF5 || v14 + 10 > v2)
        {
          v34 = 0;
          v35 = 0;
          v26 = 0;
          if (v2 <= v14)
            v2 = v14;
          while (v2 != v14)
          {
            v36 = v14 + 1;
            v37 = *(_BYTE *)(v10 + v14);
            a2[1] = v36;
            v26 |= (unint64_t)(v37 & 0x7F) << v34;
            if ((v37 & 0x80) == 0)
              goto LABEL_63;
            v34 += 7;
            v14 = v36;
            v22 = v35++ >= 9;
            if (v22)
            {
LABEL_44:
              LODWORD(v26) = 0;
              goto LABEL_63;
            }
          }
          LODWORD(v26) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v24 = 0;
          v25 = 0;
          v26 = 0;
          while (1)
          {
            v27 = v14 + 1;
            a2[1] = v14 + 1;
            v28 = *(_BYTE *)(v10 + v14);
            v26 |= (unint64_t)(v28 & 0x7F) << v24;
            if ((v28 & 0x80) == 0)
              break;
            v24 += 7;
            v14 = v27;
            v16 = v25++ > 8;
            if (v16)
              goto LABEL_44;
          }
        }
LABEL_63:
        *(_DWORD *)(a1 + 56) = v26;
        *(_DWORD *)(a1 + 8) |= 2u;
      }
      else if ((_DWORD)v23 == 1)
      {
        __p = 0;
        v54 = 0uLL;
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 1u;
        if (v54.i8[15] < 0)
          operator delete(__p);
      }
      v3 = a2[1];
      v2 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || v4 != 0)
        return v4 == 0;
    }
    v17 = 0;
    v18 = 0;
    v13 = 0;
    if (v3 <= v2)
      v19 = v2;
    else
      v19 = v3;
    while (v19 != v3)
    {
      v20 = v3++;
      v21 = *(_BYTE *)(v10 + v20);
      a2[1] = v3;
      v13 |= (unint64_t)(v21 & 0x7F) << v17;
      if ((v21 & 0x80) == 0)
        goto LABEL_22;
      v17 += 7;
      v22 = v18++ >= 9;
      if (v22)
      {
        v13 = 0;
LABEL_22:
        v14 = v20 + 1;
        goto LABEL_23;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_2067F8714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::client::PortPrefs::writeTo(as::client::PortPrefs *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  const PB::Base **v6;
  const PB::Base **v7;
  const PB::Base *v8;
  void *__p;
  char v10;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::client::PortPrefs *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v10 < 0)
      operator delete(__p);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
    PB::Writer::writeVarInt(a2);
  v7 = (const PB::Base **)*((_QWORD *)this + 2);
  v6 = (const PB::Base **)*((_QWORD *)this + 3);
  while (v7 != v6)
  {
    v8 = *v7++;
    PB::Writer::writeSubmessage(a2, v8);
  }
}

void sub_2067F87F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::client::PortPrefs::formatText(as::client::PortPrefs *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  void *__p;
  char v12;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::client::PortPrefs *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v12 < 0)
      operator delete(__p);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "dataSourceID");
  v7 = (uint64_t *)*((_QWORD *)this + 2);
  v8 = (uint64_t *)*((_QWORD *)this + 3);
  while (v7 != v8)
  {
    v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v9 + 32))(v9, a2, "polarPatterns");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_2067F88E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::client::PortPrefs::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a2 + 56)
    && !caulk::xstring::compare((caulk::xstring *)(a1 + 40), (const caulk::xstring *)(a2 + 40))
    && (v6 = a1 + 16,
        v5 = *(_QWORD *)(a1 + 16),
        v4 = *(_QWORD *)(v6 + 8),
        v7 = (v4 - v5) >> 3,
        v8 = *(_QWORD *)(a2 + 16),
        v7 == (*(_QWORD *)(a2 + 24) - v8) >> 3))
  {
    if (v4 == v5)
    {
      return 1;
    }
    else
    {
      v9 = 0;
      v10 = 0;
      if (v7 <= 1)
        v11 = 1;
      else
        v11 = (v4 - v5) >> 3;
      do
      {
        v12 = *(_QWORD *)(v5 + 8 * v10);
        v13 = *(_QWORD *)(v8 + 8 * v10);
        if (v12)
          v14 = v13 == 0;
        else
          v14 = 1;
        if (v14)
        {
          if (v12 | v13)
            return v9;
        }
        else if (!as::client::PolarPatternPref::operator==(v12, v13))
        {
          return v9;
        }
        v9 = ++v10 >= v7;
      }
      while (v11 != v10);
    }
  }
  else
  {
    return 0;
  }
  return v9;
}

uint64_t as::client::PortPrefs::addPolarPatterns(as::client::PortPrefs *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3D70;
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 12) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::client::PolarPatternPref::default_instance(as::client::PolarPatternPref *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3D70;
    *(_DWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 12) = 0;
    as::client::PolarPatternPref::default_instance(void)::gInstance = v3;
  }
  return as::client::PolarPatternPref::default_instance(void)::gInstance;
}

void sub_2067F8BB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::client::PolarPatternPref::PolarPatternPref(uint64_t this)
{
  *(_QWORD *)this = &off_24BFE3D70;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 12) = 0;
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3D70;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 12) = 0;
  return this;
}

uint64_t as::client::PolarPatternPref::PolarPatternPref(uint64_t this, const as::client::PolarPatternPref *a2)
{
  *(_QWORD *)this = &off_24BFE3D70;
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)(this + 12) = *(_QWORD *)((char *)a2 + 12);
  return this;
}

uint64_t as::client::PolarPatternPref::copy_from(uint64_t this, const as::client::PolarPatternPref *a2)
{
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)(this + 12) = *(_QWORD *)((char *)a2 + 12);
  return this;
}

uint64_t as::client::PolarPatternPref::operator=(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 12) = *(_QWORD *)(a2 + 12);
  return result;
}

{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 12) = *(_QWORD *)(a2 + 12);
  return result;
}

uint64_t as::client::PolarPatternPref::move_from(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 12) = *(_QWORD *)(a2 + 12);
  return result;
}

uint64_t as::client::PolarPatternPref::clear(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 12) = 0;
  return this;
}

BOOL as::client::PolarPatternPref::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v6;
  char v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  BOOL v12;
  char v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  unint64_t v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  _DWORD *v26;
  char v27;
  unsigned int v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  char v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  char v39;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v6 = *a2;
  while (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    while (1)
    {
      v10 = v3 + 1;
      a2[1] = v3 + 1;
      v11 = *(_BYTE *)(v6 + v3);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0)
        break;
      v7 += 7;
      v3 = v10;
      v12 = v8++ > 8;
      if (v12)
      {
        v9 = 0;
        break;
      }
    }
    v3 = v10;
LABEL_24:
    if ((v9 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    v20 = v9 >> 3;
    if ((v9 >> 3) == 2)
    {
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v27 = 0;
        v28 = 0;
        v23 = 0;
        while (1)
        {
          v24 = v3 + 1;
          a2[1] = v3 + 1;
          v29 = *(_BYTE *)(v6 + v3);
          v23 |= (unint64_t)(v29 & 0x7F) << v27;
          if ((v29 & 0x80) == 0)
            break;
          v27 += 7;
          v3 = v24;
          v12 = v28++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
            break;
          }
        }
        LODWORD(v20) = 2;
        v26 = a1 + 4;
LABEL_64:
        v3 = v24;
LABEL_65:
        *v26 = v23;
        a1[2] |= v20;
        goto LABEL_66;
      }
      v35 = 0;
      v36 = 0;
      v23 = 0;
      v37 = *a2;
      if (v3 <= v2)
        v24 = v2;
      else
        v24 = v3;
      while (v24 != v3)
      {
        v38 = v3++;
        v39 = *(_BYTE *)(v37 + v38);
        a2[1] = v3;
        v23 |= (unint64_t)(v39 & 0x7F) << v35;
        if ((v39 & 0x80) == 0)
          goto LABEL_60;
        v35 += 7;
        v12 = v36++ > 8;
        if (v12)
        {
          LODWORD(v23) = 0;
LABEL_60:
          v3 = v38 + 1;
          LODWORD(v20) = 2;
          v26 = a1 + 4;
          goto LABEL_65;
        }
      }
      v26 = a1 + 4;
LABEL_63:
      LODWORD(v23) = 0;
      *((_BYTE *)a2 + 24) = 1;
      goto LABEL_64;
    }
    if ((_DWORD)v20 == 1)
    {
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v21 = 0;
        v22 = 0;
        v23 = 0;
        while (1)
        {
          v24 = v3 + 1;
          a2[1] = v3 + 1;
          v25 = *(_BYTE *)(v6 + v3);
          v23 |= (unint64_t)(v25 & 0x7F) << v21;
          if ((v25 & 0x80) == 0)
            break;
          v21 += 7;
          v3 = v24;
          v12 = v22++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
            break;
          }
        }
        LODWORD(v20) = 1;
        v26 = a1 + 3;
        goto LABEL_64;
      }
      v30 = 0;
      v31 = 0;
      v23 = 0;
      v32 = *a2;
      if (v3 <= v2)
        v24 = v2;
      else
        v24 = v3;
      while (v24 != v3)
      {
        v33 = v3++;
        v34 = *(_BYTE *)(v32 + v33);
        a2[1] = v3;
        v23 |= (unint64_t)(v34 & 0x7F) << v30;
        if ((v34 & 0x80) == 0)
          goto LABEL_51;
        v30 += 7;
        v12 = v31++ > 8;
        if (v12)
        {
          LODWORD(v23) = 0;
LABEL_51:
          v3 = v33 + 1;
          LODWORD(v20) = 1;
          v26 = a1 + 3;
          goto LABEL_65;
        }
      }
      v26 = a1 + 3;
      goto LABEL_63;
    }
LABEL_66:
    v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((_BYTE *)a2 + 24))
      return v4 == 0;
  }
  v13 = 0;
  v14 = 0;
  v9 = 0;
  v15 = *a2;
  if (v3 <= v2)
    v16 = v2;
  else
    v16 = v3;
  while (v16 != v3)
  {
    v17 = v3++;
    v18 = *(_BYTE *)(v15 + v17);
    a2[1] = v3;
    v9 |= (unint64_t)(v18 & 0x7F) << v13;
    if ((v18 & 0x80) == 0)
      goto LABEL_23;
    v13 += 7;
    if (v14++ >= 9)
    {
      v9 = 0;
LABEL_23:
      v3 = v17 + 1;
      goto LABEL_24;
    }
  }
  v4 = 1;
  *((_BYTE *)a2 + 24) = 1;
  return v4 == 0;
}

uint64_t as::client::PolarPatternPref::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0)
    return PB::Writer::writeVarInt(a2);
  return this;
}

uint64_t as::client::PolarPatternPref::formatText(as::client::PolarPatternPref *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "dataSourceID");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "polarPattern");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::client::PolarPatternPref::operator==(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8) && *(_QWORD *)(a1 + 12) == *(_QWORD *)(a2 + 12);
}

uint64_t as::client::IOControllerPrefs::default_instance(as::client::IOControllerPrefs *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3DA8;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    as::client::IOControllerPrefs::default_instance(void)::gInstance = v3;
  }
  return as::client::IOControllerPrefs::default_instance(void)::gInstance;
}

void sub_2067F9120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::client::IOControllerPrefs::IOControllerPrefs(as::client::IOControllerPrefs *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3DA8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3DA8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  return result;
}

__n128 as::client::IOControllerPrefs::copy_from(__n128 *this, const as::client::IOControllerPrefs *a2)
{
  _QWORD *v4;
  __n128 *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  const as::client::StreamPrefs **v9;
  const as::client::StreamPrefs **v10;
  as::client::StreamPrefs *v11;
  const as::client::StreamPrefs *v12;
  unint64_t v13;
  as::client::StreamPrefs **v14;
  _QWORD *v15;
  as::client::StreamPrefs **v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  as::client::StreamPrefs **v22;
  char *v23;
  as::client::StreamPrefs *v24;
  __n128 v25;
  unint64_t v26;
  _QWORD *v27;
  unint64_t *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  const as::client::StreamPrefs **v32;
  const as::client::StreamPrefs **j;
  as::client::StreamPrefs *v34;
  const as::client::StreamPrefs *v35;
  unint64_t v36;
  as::client::StreamPrefs **v37;
  _QWORD *v38;
  as::client::StreamPrefs **v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  as::client::StreamPrefs **v45;
  char *v46;
  as::client::StreamPrefs *v47;
  __int128 v48;
  unint64_t v49;
  __n128 result;
  __n128 v51;
  const as::client::IOControllerPrefs *i;
  unint64_t v53;
  __n128 v54;
  char *v55;
  __n128 *v56;

  caulk::xstring::assign((caulk::xstring *)&this[4], (const as::client::IOControllerPrefs *)((char *)a2 + 64));
  v4 = (_QWORD *)this[1].n128_u64[0];
  v6 = (_QWORD *)this[1].n128_u64[1];
  v5 = this + 1;
  while (v6 != v4)
  {
    v8 = *--v6;
    v7 = v8;
    *v6 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  this[1].n128_u64[1] = (unint64_t)v4;
  v9 = (const as::client::StreamPrefs **)*((_QWORD *)a2 + 2);
  v10 = (const as::client::StreamPrefs **)*((_QWORD *)a2 + 3);
  for (i = a2; v9 != v10; ++v9)
  {
    v11 = (as::client::StreamPrefs *)operator new();
    v12 = *v9;
    *(_QWORD *)v11 = &off_24BFE3CC8;
    *((_OWORD *)v11 + 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    as::client::StreamPrefs::copy_from(v11, v12);
    v14 = (as::client::StreamPrefs **)this[1].n128_u64[1];
    v13 = this[2].n128_u64[0];
    if ((unint64_t)v14 >= v13)
    {
      v16 = (as::client::StreamPrefs **)v5->n128_u64[0];
      v17 = (uint64_t)((uint64_t)v14 - v5->n128_u64[0]) >> 3;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
LABEL_46:
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v56 = this + 2;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)&this[2], v20);
        v16 = (as::client::StreamPrefs **)this[1].n128_u64[0];
        v14 = (as::client::StreamPrefs **)this[1].n128_u64[1];
      }
      else
      {
        v21 = 0;
      }
      v22 = (as::client::StreamPrefs **)&v21[8 * v17];
      v23 = &v21[8 * v20];
      v55 = v23;
      *v22 = v11;
      v54.n128_u64[1] = (unint64_t)(v22 + 1);
      if (v14 == v16)
      {
        v15 = v22 + 1;
      }
      else
      {
        do
        {
          v24 = *--v14;
          *v14 = 0;
          *--v22 = v24;
        }
        while (v14 != v16);
        v15 = (_QWORD *)v54.n128_u64[1];
        v23 = v55;
      }
      v25 = this[1];
      this[1].n128_u64[0] = (unint64_t)v22;
      this[1].n128_u64[1] = (unint64_t)v15;
      v54 = v25;
      v26 = this[2].n128_u64[0];
      this[2].n128_u64[0] = (unint64_t)v23;
      v55 = (char *)v26;
      v53 = v25.n128_u64[0];
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v53);
    }
    else
    {
      *v14 = v11;
      v15 = v14 + 1;
    }
    this[1].n128_u64[1] = (unint64_t)v15;
  }
  v27 = (_QWORD *)this[2].n128_u64[1];
  v29 = (_QWORD *)this[3].n128_u64[0];
  v28 = &this[2].n128_u64[1];
  while (v29 != v27)
  {
    v31 = *--v29;
    v30 = v31;
    *v29 = 0;
    if (v31)
      (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  }
  this[3].n128_u64[0] = (unint64_t)v27;
  v32 = (const as::client::StreamPrefs **)*((_QWORD *)i + 5);
  for (j = (const as::client::StreamPrefs **)*((_QWORD *)i + 6); v32 != j; ++v32)
  {
    v34 = (as::client::StreamPrefs *)operator new();
    v35 = *v32;
    *(_QWORD *)v34 = &off_24BFE3CC8;
    *((_OWORD *)v34 + 1) = 0u;
    *((_OWORD *)v34 + 2) = 0u;
    as::client::StreamPrefs::copy_from(v34, v35);
    v37 = (as::client::StreamPrefs **)this[3].n128_u64[0];
    v36 = this[3].n128_u64[1];
    if ((unint64_t)v37 >= v36)
    {
      v39 = (as::client::StreamPrefs **)*v28;
      v40 = (uint64_t)((uint64_t)v37 - *v28) >> 3;
      v41 = v40 + 1;
      if ((unint64_t)(v40 + 1) >> 61)
        goto LABEL_46;
      v42 = v36 - (_QWORD)v39;
      if (v42 >> 2 > v41)
        v41 = v42 >> 2;
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
        v43 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v43 = v41;
      v56 = (__n128 *)((char *)this + 56);
      if (v43)
      {
        v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)&this[3].n128_i64[1], v43);
        v39 = (as::client::StreamPrefs **)this[2].n128_u64[1];
        v37 = (as::client::StreamPrefs **)this[3].n128_u64[0];
      }
      else
      {
        v44 = 0;
      }
      v45 = (as::client::StreamPrefs **)&v44[8 * v40];
      v46 = &v44[8 * v43];
      v55 = v46;
      *v45 = v34;
      v54.n128_u64[1] = (unint64_t)(v45 + 1);
      if (v37 == v39)
      {
        v38 = v45 + 1;
      }
      else
      {
        do
        {
          v47 = *--v37;
          *v37 = 0;
          *--v45 = v47;
        }
        while (v37 != v39);
        v38 = (_QWORD *)v54.n128_u64[1];
        v46 = v55;
      }
      v48 = *(__int128 *)((char *)&this[2] + 8);
      this[2].n128_u64[1] = (unint64_t)v45;
      this[3].n128_u64[0] = (unint64_t)v38;
      v54 = (__n128)v48;
      v49 = this[3].n128_u64[1];
      this[3].n128_u64[1] = (unint64_t)v46;
      v55 = (char *)v49;
      v53 = v48;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v53);
    }
    else
    {
      *v37 = v34;
      v38 = v37 + 1;
    }
    this[3].n128_u64[0] = (unint64_t)v38;
  }
  this->n128_u32[2] = *((_DWORD *)i + 2);
  result = *((__n128 *)i + 5);
  v51 = *((__n128 *)i + 6);
  this[5] = result;
  this[6] = v51;
  return result;
}

__n128 *as::client::IOControllerPrefs::operator=(__n128 *a1, const as::client::IOControllerPrefs *a2)
{
  as::client::IOControllerPrefs::copy_from(a1, a2);
  return a1;
}

as::client::StreamPrefs *as::client::StreamPrefs::StreamPrefs(as::client::StreamPrefs *this, const as::client::StreamPrefs *a2)
{
  *(_QWORD *)this = &off_24BFE3CC8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::client::StreamPrefs::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3CC8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::client::StreamPrefs::copy_from(this, a2);
  return this;
}

uint64_t as::client::IOControllerPrefs::IOControllerPrefs(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE3DA8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  as::client::IOControllerPrefs::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3DA8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  as::client::IOControllerPrefs::move_from(a1, a2);
  return a1;
}

__n128 as::client::IOControllerPrefs::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 result;
  __int128 v11;
  _QWORD v12[2];

  v12[0] = 0;
  v12[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)v12);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  v7 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v7;
  v8 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v8;
  v9 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v9;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 80);
  v11 = *(_OWORD *)(a2 + 96);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + 96) = v11;
  return result;
}

uint64_t as::client::IOControllerPrefs::operator=(uint64_t a1, uint64_t a2)
{
  as::client::IOControllerPrefs::move_from(a1, a2);
  return a1;
}

double as::client::IOControllerPrefs::clear(as::client::IOControllerPrefs *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  double result;

  caulk::xstring::clear((as::client::IOControllerPrefs *)((char *)this + 64));
  v2 = (_QWORD *)*((_QWORD *)this + 2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  while (v3 != v2)
  {
    v5 = *--v3;
    v4 = v5;
    *v3 = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  *((_QWORD *)this + 3) = v2;
  v6 = (_QWORD *)*((_QWORD *)this + 5);
  v7 = (_QWORD *)*((_QWORD *)this + 6);
  while (v7 != v6)
  {
    v9 = *--v7;
    v8 = v9;
    *v7 = 0;
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  *((_QWORD *)this + 6) = v6;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  return result;
}

uint64_t as::client::StreamPrefs::isInitialized(as::client::StreamPrefs *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::client::IOControllerPrefs::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  int64x2_t *v9;
  uint64_t v10;
  void (**v11)(as::client::StreamPrefs *__hidden);
  uint64_t v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  BOOL v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  void (**v37)(as::client::StreamPrefs *__hidden);
  unint64_t v38;
  uint64_t *v39;
  _QWORD *v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t *v49;
  char v50;
  unsigned int v51;
  unint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  char v59;
  unsigned int v60;
  unint64_t v61;
  char v62;
  char v63;
  unsigned int v64;
  unint64_t v65;
  char v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  uint64_t *v73;
  char *v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  int64x2_t v78;
  uint64_t *v79;
  char *v80;
  _QWORD *v81;
  _QWORD *v82;
  uint64_t v83;
  int64x2_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  int64x2_t *v90;
  void *__p;
  int64x2_t v92;
  char *v93;
  uint64_t v94;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v90 = (int64x2_t *)(a1 + 40);
    v8 = a1 + 56;
    v9 = (int64x2_t *)(a1 + 16);
    v10 = a1 + 32;
    v11 = &off_24BFE3CC8;
    while (1)
    {
      v12 = *a2;
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v13 = 0;
        v14 = 0;
        v15 = 0;
        while (1)
        {
          v16 = v3 + 1;
          a2[1] = v3 + 1;
          v17 = *(_BYTE *)(v12 + v3);
          v15 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0)
            goto LABEL_23;
          v13 += 7;
          v3 = v16;
          v18 = v14++ > 8;
          if (v18)
          {
            v15 = 0;
            goto LABEL_23;
          }
        }
      }
      v19 = 0;
      v20 = 0;
      v15 = 0;
      v21 = v3 <= v2 ? v2 : v3;
      do
      {
        if (v21 == v3)
        {
          v4 = 1;
          *((_BYTE *)a2 + 24) = 1;
          return v4 == 0;
        }
        v22 = v3++;
        v23 = *(_BYTE *)(v12 + v22);
        a2[1] = v3;
        v15 |= (unint64_t)(v23 & 0x7F) << v19;
        if ((v23 & 0x80) == 0)
          goto LABEL_22;
        v19 += 7;
        v24 = v20++ >= 9;
      }
      while (!v24);
      v15 = 0;
LABEL_22:
      v16 = v22 + 1;
LABEL_23:
      if ((v15 & 7) == 4)
        break;
      switch((v15 >> 3))
      {
        case 1u:
          if (v16 > 0xFFFFFFFFFFFFFFF5 || v16 + 10 > v2)
          {
            v59 = 0;
            v60 = 0;
            v27 = 0;
            if (v2 <= v16)
              v2 = v16;
            do
            {
              if (v2 == v16)
              {
                LODWORD(v27) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_124;
              }
              v61 = v16 + 1;
              v62 = *(_BYTE *)(v12 + v16);
              a2[1] = v61;
              v27 |= (unint64_t)(v62 & 0x7F) << v59;
              if ((v62 & 0x80) == 0)
                goto LABEL_124;
              v59 += 7;
              v16 = v61;
              v24 = v60++ >= 9;
            }
            while (!v24);
LABEL_82:
            LODWORD(v27) = 0;
          }
          else
          {
            v25 = 0;
            v26 = 0;
            v27 = 0;
            while (1)
            {
              v28 = v16 + 1;
              a2[1] = v16 + 1;
              v29 = *(_BYTE *)(v12 + v16);
              v27 |= (unint64_t)(v29 & 0x7F) << v25;
              if ((v29 & 0x80) == 0)
                break;
              v25 += 7;
              v16 = v28;
              v18 = v26++ > 8;
              if (v18)
                goto LABEL_82;
            }
          }
LABEL_124:
          *(_DWORD *)(a1 + 100) = v27;
          v67 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_127;
        case 2u:
          if (v16 <= 0xFFFFFFFFFFFFFFF5 && v16 + 10 <= v2)
          {
            v41 = 0;
            v42 = 0;
            v43 = 0;
            do
            {
              v44 = v16 + 1;
              a2[1] = v16 + 1;
              v45 = *(_BYTE *)(v12 + v16);
              v43 |= (unint64_t)(v45 & 0x7F) << v41;
              if ((v45 & 0x80) == 0)
                goto LABEL_126;
              v41 += 7;
              v16 = v44;
              v18 = v42++ > 8;
            }
            while (!v18);
LABEL_89:
            LODWORD(v43) = 0;
            goto LABEL_126;
          }
          v63 = 0;
          v64 = 0;
          v43 = 0;
          if (v2 <= v16)
            v2 = v16;
          while (v2 != v16)
          {
            v65 = v16 + 1;
            v66 = *(_BYTE *)(v12 + v16);
            a2[1] = v65;
            v43 |= (unint64_t)(v66 & 0x7F) << v63;
            if ((v66 & 0x80) == 0)
              goto LABEL_126;
            v63 += 7;
            v16 = v65;
            v24 = v64++ >= 9;
            if (v24)
              goto LABEL_89;
          }
          LODWORD(v43) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_126:
          *(_DWORD *)(a1 + 108) = v43;
          v67 = *(_DWORD *)(a1 + 8) | 2;
          goto LABEL_127;
        case 4u:
          if (v16 <= 0xFFFFFFFFFFFFFFF5 && v16 + 10 <= v2)
          {
            v30 = 0;
            v31 = 0;
            v32 = 0;
            do
            {
              v33 = v16 + 1;
              a2[1] = v16 + 1;
              v34 = *(_BYTE *)(v12 + v16);
              v32 |= (unint64_t)(v34 & 0x7F) << v30;
              if ((v34 & 0x80) == 0)
                goto LABEL_122;
              v30 += 7;
              v16 = v33;
              v18 = v31++ > 8;
            }
            while (!v18);
LABEL_67:
            LODWORD(v32) = 0;
            goto LABEL_122;
          }
          v50 = 0;
          v51 = 0;
          v32 = 0;
          if (v2 <= v16)
            v2 = v16;
          while (v2 != v16)
          {
            v52 = v16 + 1;
            v53 = *(_BYTE *)(v12 + v16);
            a2[1] = v52;
            v32 |= (unint64_t)(v53 & 0x7F) << v50;
            if ((v53 & 0x80) == 0)
              goto LABEL_122;
            v50 += 7;
            v16 = v52;
            v24 = v51++ >= 9;
            if (v24)
              goto LABEL_67;
          }
          LODWORD(v32) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_122:
          *(_DWORD *)(a1 + 104) = v32;
          v67 = *(_DWORD *)(a1 + 8) | 4;
LABEL_127:
          *(_DWORD *)(a1 + 8) = v67;
          goto LABEL_128;
        case 5u:
          __p = 0;
          v92 = 0uLL;
          PB::Reader::read();
          caulk::xstring::assign();
          *(_DWORD *)(a1 + 8) |= 0x40u;
          if (v92.i8[15] < 0)
            operator delete(__p);
          goto LABEL_128;
        case 6u:
          v46 = operator new();
          v47 = v46;
          v37 = v11;
          *(_QWORD *)v46 = v11;
          *(_DWORD *)(v46 + 8) = 0;
          *(_OWORD *)(v46 + 16) = 0u;
          *(_OWORD *)(v46 + 32) = 0u;
          *(_OWORD *)(v46 + 48) = 0u;
          *(_DWORD *)(v46 + 64) = 0;
          v49 = *(uint64_t **)(a1 + 24);
          v48 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v49 >= v48)
          {
            v68 = ((uint64_t)v49 - v9->i64[0]) >> 3;
            if ((unint64_t)(v68 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v69 = v48 - v9->i64[0];
            v70 = v69 >> 2;
            if (v69 >> 2 <= (unint64_t)(v68 + 1))
              v70 = v68 + 1;
            if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
              v71 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v71 = v70;
            v94 = v10;
            if (v71)
              v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v10, v71);
            else
              v72 = 0;
            v79 = (uint64_t *)&v72[8 * v68];
            v80 = &v72[8 * v71];
            v93 = v80;
            *v79 = v47;
            v40 = v79 + 1;
            v92.i64[1] = (uint64_t)(v79 + 1);
            v82 = *(_QWORD **)(a1 + 16);
            v81 = *(_QWORD **)(a1 + 24);
            if (v81 == v82)
            {
              v84 = vdupq_n_s64((unint64_t)v81);
            }
            else
            {
              do
              {
                v83 = *--v81;
                *v81 = 0;
                *--v79 = v83;
              }
              while (v81 != v82);
              v84 = *v9;
              v40 = (_QWORD *)v92.i64[1];
              v80 = v93;
            }
            *(_QWORD *)(a1 + 16) = v79;
            *(_QWORD *)(a1 + 24) = v40;
            v92 = v84;
            v86 = *(char **)(a1 + 32);
            *(_QWORD *)(a1 + 32) = v80;
            v93 = v86;
            __p = (void *)v84.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v49 = v46;
            v40 = v49 + 1;
          }
          *(_QWORD *)(a1 + 24) = v40;
          goto LABEL_118;
        case 7u:
          v35 = operator new();
          v36 = v35;
          v37 = v11;
          *(_QWORD *)v35 = v11;
          *(_DWORD *)(v35 + 8) = 0;
          *(_OWORD *)(v35 + 16) = 0u;
          *(_OWORD *)(v35 + 32) = 0u;
          *(_OWORD *)(v35 + 48) = 0u;
          *(_DWORD *)(v35 + 64) = 0;
          v39 = *(uint64_t **)(a1 + 48);
          v38 = *(_QWORD *)(a1 + 56);
          if ((unint64_t)v39 >= v38)
          {
            v54 = ((uint64_t)v39 - v90->i64[0]) >> 3;
            if ((unint64_t)(v54 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v55 = v38 - v90->i64[0];
            v56 = v55 >> 2;
            if (v55 >> 2 <= (unint64_t)(v54 + 1))
              v56 = v54 + 1;
            if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
              v57 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v57 = v56;
            v94 = v8;
            if (v57)
              v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v8, v57);
            else
              v58 = 0;
            v73 = (uint64_t *)&v58[8 * v54];
            v74 = &v58[8 * v57];
            v93 = v74;
            *v73 = v36;
            v40 = v73 + 1;
            v92.i64[1] = (uint64_t)(v73 + 1);
            v76 = *(_QWORD **)(a1 + 40);
            v75 = *(_QWORD **)(a1 + 48);
            if (v75 == v76)
            {
              v78 = vdupq_n_s64((unint64_t)v75);
            }
            else
            {
              do
              {
                v77 = *--v75;
                *v75 = 0;
                *--v73 = v77;
              }
              while (v75 != v76);
              v78 = *v90;
              v40 = (_QWORD *)v92.i64[1];
              v74 = v93;
            }
            *(_QWORD *)(a1 + 40) = v73;
            *(_QWORD *)(a1 + 48) = v40;
            v92 = v78;
            v85 = *(char **)(a1 + 56);
            *(_QWORD *)(a1 + 56) = v74;
            v93 = v85;
            __p = (void *)v78.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v39 = v35;
            v40 = v39 + 1;
          }
          *(_QWORD *)(a1 + 48) = v40;
LABEL_118:
          v87 = *(v40 - 1);
          if ((PB::Reader::placeMark() & 1) == 0
            || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v87 + 16))(v87, a2) & 1) == 0)
          {
            return 0;
          }
          PB::Reader::recallMark();
          v11 = v37;
LABEL_128:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          break;
        case 8u:
          if (v16 > 0xFFFFFFFFFFFFFFF7 || v16 + 8 > v2)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_QWORD *)(a1 + 80) = *(_QWORD *)(v12 + v16);
            a2[1] += 8;
          }
          v67 = *(_DWORD *)(a1 + 8) | 8;
          goto LABEL_127;
        case 9u:
          if (v16 > 0xFFFFFFFFFFFFFFF7 || v16 + 8 > v2)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_QWORD *)(a1 + 88) = *(_QWORD *)(v12 + v16);
            a2[1] += 8;
          }
          v67 = *(_DWORD *)(a1 + 8) | 0x10;
          goto LABEL_127;
        case 0xAu:
          if (v16 > 0xFFFFFFFFFFFFFFFBLL || v16 + 4 > v2)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 96) = *(_DWORD *)(v12 + v16);
            a2[1] += 4;
          }
          v67 = *(_DWORD *)(a1 + 8) | 0x20;
          goto LABEL_127;
        default:
          goto LABEL_128;
      }
    }
    v4 = 0;
  }
  return v4 == 0;
}

void sub_2067F9ECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::client::IOControllerPrefs::writeTo(as::client::IOControllerPrefs *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  const PB::Base **v6;
  const PB::Base **v7;
  const PB::Base *v8;
  const PB::Base **v9;
  const PB::Base **v10;
  const PB::Base *v11;
  void *__p;
  char v13;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_11;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_12;
  }
LABEL_11:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_13;
  }
LABEL_12:
  PB::Writer::write(a2, *((double *)this + 10));
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0)
      goto LABEL_7;
LABEL_14:
    PB::Writer::write(a2, *((float *)this + 24));
    if ((*((_DWORD *)this + 2) & 0x40) == 0)
      goto LABEL_17;
    goto LABEL_15;
  }
LABEL_13:
  PB::Writer::write(a2, *((double *)this + 11));
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20) != 0)
    goto LABEL_14;
LABEL_7:
  if ((v4 & 0x40) == 0)
    goto LABEL_17;
LABEL_15:
  v5 = (char *)caulk::xstring::c_str((as::client::IOControllerPrefs *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(&__p, v5);
  PB::Writer::write();
  if (v13 < 0)
    operator delete(__p);
LABEL_17:
  v6 = (const PB::Base **)*((_QWORD *)this + 2);
  v7 = (const PB::Base **)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = *v6++;
    PB::Writer::writeSubmessage(a2, v8);
  }
  v10 = (const PB::Base **)*((_QWORD *)this + 5);
  v9 = (const PB::Base **)*((_QWORD *)this + 6);
  while (v10 != v9)
  {
    v11 = *v10++;
    PB::Writer::writeSubmessage(a2, v11);
  }
}

void sub_2067FA064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::client::IOControllerPrefs::formatText(as::client::IOControllerPrefs *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  void *__p;
  char v15;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "sessionToken");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_11;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "controllerType");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
    goto LABEL_12;
  }
LABEL_11:
  PB::TextFormatter::format(a2, "IOBufferFrameSize");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_13;
  }
LABEL_12:
  PB::TextFormatter::format(a2, "frameSizeSampleRate", *((double *)this + 10));
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_14;
  }
LABEL_13:
  PB::TextFormatter::format(a2, "IOBufferDuration", *((double *)this + 11));
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0)
      goto LABEL_17;
    goto LABEL_15;
  }
LABEL_14:
  PB::TextFormatter::format(a2, "IOUtilization", *((float *)this + 24));
  if ((*((_DWORD *)this + 2) & 0x40) == 0)
    goto LABEL_17;
LABEL_15:
  v6 = (char *)caulk::xstring::c_str((as::client::IOControllerPrefs *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(&__p, v6);
  PB::TextFormatter::format();
  if (v15 < 0)
    operator delete(__p);
LABEL_17:
  v7 = (uint64_t *)*((_QWORD *)this + 2);
  v8 = (uint64_t *)*((_QWORD *)this + 3);
  while (v7 != v8)
  {
    v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v9 + 32))(v9, a2, "inputStreamPrefs");
  }
  v10 = (uint64_t *)*((_QWORD *)this + 5);
  v11 = (uint64_t *)*((_QWORD *)this + 6);
  while (v10 != v11)
  {
    v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v12 + 32))(v12, a2, "outputStreamPrefs");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_2067FA238(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::client::IOControllerPrefs::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  BOOL v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  v4 = *(_QWORD *)(a1 + 80) == *(_QWORD *)(a2 + 80) && *(_QWORD *)(a1 + 88) == *(_QWORD *)(a2 + 88);
  v5 = v4 && *(_QWORD *)(a1 + 96) == *(_QWORD *)(a2 + 96);
  if (!v5 || *(_QWORD *)(a1 + 104) != *(_QWORD *)(a2 + 104))
    return 0;
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 64), (const caulk::xstring *)(a2 + 64)))
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v9 = (v7 - v8) >> 3;
  if (v9 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3)
    return 0;
  if (v7 != v8)
  {
    v10 = 0;
    if (v9 <= 1)
      v11 = 1;
    else
      v11 = (v7 - v8) >> 3;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v10);
      v13 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v10);
      if (v12)
        v14 = v13 == 0;
      else
        v14 = 1;
      if (v14)
      {
        if (v12 | v13)
          return 0;
      }
      else if (!as::client::StreamPrefs::operator==(v12, v13))
      {
        return 0;
      }
      ++v10;
    }
    while (v11 != v10);
  }
  v16 = *(_QWORD *)(a1 + 40);
  v15 = *(_QWORD *)(a1 + 48);
  v17 = (v15 - v16) >> 3;
  if (v17 == (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
  {
    if (v15 == v16)
    {
      return 1;
    }
    else
    {
      v18 = 0;
      v19 = 0;
      if (v17 <= 1)
        v20 = 1;
      else
        v20 = (v15 - v16) >> 3;
      do
      {
        v21 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v19);
        v22 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v19);
        if (v21)
          v23 = v22 == 0;
        else
          v23 = 1;
        if (v23)
        {
          if (v21 | v22)
            return v18;
        }
        else if (!as::client::StreamPrefs::operator==(v21, v22))
        {
          return v18;
        }
        v18 = ++v19 >= v17;
      }
      while (v20 != v19);
    }
  }
  else
  {
    return 0;
  }
  return v18;
}

uint64_t as::client::IOControllerPrefs::addInputStreamPrefs(as::client::IOControllerPrefs *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3CC8;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_DWORD *)(result + 64) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::client::IOControllerPrefs::addOutputStreamPrefs(as::client::IOControllerPrefs *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3CC8;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_DWORD *)(result + 64) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::client::StreamPrefs::default_instance(as::client::StreamPrefs *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3CC8;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_DWORD *)(v3 + 64) = 0;
    as::client::StreamPrefs::default_instance(void)::gInstance = v3;
  }
  return as::client::StreamPrefs::default_instance(void)::gInstance;
}

void sub_2067FA70C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::client::StreamPrefs::StreamPrefs(as::client::StreamPrefs *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3CC8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3CC8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  return result;
}

__n128 as::client::StreamPrefs::copy_from(as::client::StreamPrefs *this, const as::client::StreamPrefs *a2)
{
  const as::StreamFormat *v4;
  as::StreamFormat *v5;
  __n128 result;

  v4 = (const as::StreamFormat *)*((_QWORD *)a2 + 5);
  if (v4)
  {
    v5 = as::client::StreamPrefs::mutableStreamFormat(this);
    as::StreamFormat::operator=(v5, v4);
  }
  if (this != a2)
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 16, *((caulk::xstring **)a2 + 2), *((caulk::xstring **)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 4);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *((__n128 *)a2 + 3);
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((__n128 *)this + 3) = result;
  return result;
}

as::client::StreamPrefs *as::client::StreamPrefs::operator=(as::client::StreamPrefs *a1, const as::client::StreamPrefs *a2)
{
  as::client::StreamPrefs::copy_from(a1, a2);
  return a1;
}

uint64_t as::client::StreamPrefs::streamFormat(as::client::StreamPrefs *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 5);
  if (!result)
    return as::StreamFormat::default_instance(0);
  return result;
}

as::StreamFormat *as::client::StreamPrefs::mutableStreamFormat(as::client::StreamPrefs *this)
{
  as::StreamFormat *v1;
  double v3;
  uint64_t v4;

  v1 = (as::StreamFormat *)*((_QWORD *)this + 5);
  if (!v1)
  {
    v1 = (as::StreamFormat *)operator new();
    v3 = as::StreamFormat::StreamFormat(v1);
    v4 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = v1;
    if (v4)
      (*(void (**)(uint64_t, double))(*(_QWORD *)v4 + 8))(v4, v3);
  }
  return v1;
}

__n128 as::client::StreamPrefs::StreamPrefs(__n128 *a1, __n128 *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&off_24BFE3CC8;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = 0;
  v2 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v2;
  v3 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v3;
  v4 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v4;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&off_24BFE3CC8;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = 0;
  v2 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v2;
  v3 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v3;
  v4 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v4;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

__n128 as::client::StreamPrefs::move_from(__n128 *a1, __n128 *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  __n128 result;

  v2 = a1[2].n128_u64[1];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = v2;
  v3 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v3;
  v4 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v4;
  v5 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v5;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

__n128 as::client::StreamPrefs::operator=(__n128 *a1, __n128 *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  __n128 result;

  v2 = a1[2].n128_u64[1];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = v2;
  v3 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v3;
  v4 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v4;
  v5 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v5;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

uint64_t as::client::StreamPrefs::clear(as::client::StreamPrefs *this)
{
  uint64_t v2;
  char *v3;
  caulk::xstring *v4;
  uint64_t result;

  v2 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v4 = (caulk::xstring *)*((_QWORD *)this + 2);
  v3 = (char *)this + 16;
  result = std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v3, v4);
  *((_DWORD *)v3 - 2) = 0;
  *((_QWORD *)v3 + 4) = 0;
  *((_QWORD *)v3 + 5) = 0;
  *((_DWORD *)v3 + 12) = 0;
  return result;
}

BOOL as::client::StreamPrefs::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  BOOL v16;
  char v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  char v21;
  BOOL v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  unint64_t v26;
  char v27;
  char v28;
  unsigned int v29;
  uint64_t v30;
  unint64_t v31;
  char v32;
  as::StreamFormat *v33;
  double v34;
  uint64_t v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  char v44;
  unsigned int v45;
  unint64_t v46;
  char v47;
  char v48;
  unsigned int v49;
  unint64_t v50;
  char v51;
  int v52;
  char v53;
  unsigned int v54;
  unint64_t v55;
  char v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  char *v62;
  void *__p;
  char *v66;
  _QWORD *v67;
  char *v68;
  uint64_t v69;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v8 = (uint64_t *)(a1 + 16);
    v9 = a1 + 32;
    while (1)
    {
      v10 = *a2;
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        while (1)
        {
          v14 = v3 + 1;
          a2[1] = v3 + 1;
          v15 = *(_BYTE *)(v10 + v3);
          v13 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0)
            goto LABEL_23;
          v11 += 7;
          v3 = v14;
          v16 = v12++ > 8;
          if (v16)
          {
            v13 = 0;
            goto LABEL_23;
          }
        }
      }
      v17 = 0;
      v18 = 0;
      v13 = 0;
      v19 = v3 <= v2 ? v2 : v3;
      do
      {
        if (v19 == v3)
        {
          v4 = 1;
          *((_BYTE *)a2 + 24) = 1;
          return v4 == 0;
        }
        v20 = v3++;
        v21 = *(_BYTE *)(v10 + v20);
        a2[1] = v3;
        v13 |= (unint64_t)(v21 & 0x7F) << v17;
        if ((v21 & 0x80) == 0)
          goto LABEL_22;
        v17 += 7;
        v22 = v18++ >= 9;
      }
      while (!v22);
      v13 = 0;
LABEL_22:
      v14 = v20 + 1;
LABEL_23:
      if ((v13 & 7) == 4)
        break;
      switch((v13 >> 3))
      {
        case 1u:
          if (v14 > 0xFFFFFFFFFFFFFFF5 || v14 + 10 > v2)
          {
            v44 = 0;
            v45 = 0;
            v25 = 0;
            if (v2 <= v14)
              v2 = v14;
            do
            {
              if (v2 == v14)
              {
                LODWORD(v25) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_92;
              }
              v46 = v14 + 1;
              v47 = *(_BYTE *)(v10 + v14);
              a2[1] = v46;
              v25 |= (unint64_t)(v47 & 0x7F) << v44;
              if ((v47 & 0x80) == 0)
                goto LABEL_92;
              v44 += 7;
              v14 = v46;
              v22 = v45++ >= 9;
            }
            while (!v22);
LABEL_62:
            LODWORD(v25) = 0;
          }
          else
          {
            v23 = 0;
            v24 = 0;
            v25 = 0;
            while (1)
            {
              v26 = v14 + 1;
              a2[1] = v14 + 1;
              v27 = *(_BYTE *)(v10 + v14);
              v25 |= (unint64_t)(v27 & 0x7F) << v23;
              if ((v27 & 0x80) == 0)
                break;
              v23 += 7;
              v14 = v26;
              v16 = v24++ > 8;
              if (v16)
                goto LABEL_62;
            }
          }
LABEL_92:
          *(_DWORD *)(a1 + 56) = v25;
          v52 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_97;
        case 3u:
          if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
          {
            v28 = 0;
            v29 = 0;
            v30 = 0;
            do
            {
              v31 = v14 + 1;
              a2[1] = v14 + 1;
              v32 = *(_BYTE *)(v10 + v14);
              v30 |= (unint64_t)(v32 & 0x7F) << v28;
              if ((v32 & 0x80) == 0)
                goto LABEL_94;
              v28 += 7;
              v14 = v31;
              v16 = v29++ > 8;
            }
            while (!v16);
LABEL_69:
            LODWORD(v30) = 0;
            goto LABEL_94;
          }
          v48 = 0;
          v49 = 0;
          v30 = 0;
          if (v2 <= v14)
            v2 = v14;
          while (v2 != v14)
          {
            v50 = v14 + 1;
            v51 = *(_BYTE *)(v10 + v14);
            a2[1] = v50;
            v30 |= (unint64_t)(v51 & 0x7F) << v48;
            if ((v51 & 0x80) == 0)
              goto LABEL_94;
            v48 += 7;
            v14 = v50;
            v22 = v49++ >= 9;
            if (v22)
              goto LABEL_69;
          }
          LODWORD(v30) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_94:
          *(_DWORD *)(a1 + 60) = v30;
          v52 = *(_DWORD *)(a1 + 8) | 2;
          goto LABEL_97;
        case 5u:
          v33 = (as::StreamFormat *)operator new();
          v34 = as::StreamFormat::StreamFormat(v33);
          v35 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(a1 + 40) = v33;
          if (v35)
          {
            (*(void (**)(uint64_t, double))(*(_QWORD *)v35 + 8))(v35, v34);
            v33 = *(as::StreamFormat **)(a1 + 40);
          }
          if (!PB::Reader::placeMark()
            || ((*(uint64_t (**)(as::StreamFormat *, uint64_t *))(*(_QWORD *)v33 + 16))(v33, a2) & 1) == 0)
          {
            return 0;
          }
          PB::Reader::recallMark();
LABEL_98:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          break;
        case 6u:
          if (v14 > 0xFFFFFFFFFFFFFFF7 || v14 + 8 > v2)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_QWORD *)(a1 + 48) = *(_QWORD *)(v10 + v14);
            a2[1] += 8;
          }
          v52 = *(_DWORD *)(a1 + 8) | 4;
          goto LABEL_97;
        case 7u:
          if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
          {
            v36 = 0;
            v37 = 0;
            v38 = 0;
            do
            {
              v39 = v14 + 1;
              a2[1] = v14 + 1;
              v40 = *(_BYTE *)(v10 + v14);
              v38 |= (unint64_t)(v40 & 0x7F) << v36;
              if ((v40 & 0x80) == 0)
                goto LABEL_96;
              v36 += 7;
              v14 = v39;
              v16 = v37++ > 8;
            }
            while (!v16);
LABEL_78:
            LODWORD(v38) = 0;
            goto LABEL_96;
          }
          v53 = 0;
          v54 = 0;
          v38 = 0;
          if (v2 <= v14)
            v2 = v14;
          while (v2 != v14)
          {
            v55 = v14 + 1;
            v56 = *(_BYTE *)(v10 + v14);
            a2[1] = v55;
            v38 |= (unint64_t)(v56 & 0x7F) << v53;
            if ((v56 & 0x80) == 0)
              goto LABEL_96;
            v53 += 7;
            v14 = v55;
            v22 = v54++ >= 9;
            if (v22)
              goto LABEL_78;
          }
          LODWORD(v38) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_96:
          *(_DWORD *)(a1 + 64) = v38;
          v52 = *(_DWORD *)(a1 + 8) | 8;
LABEL_97:
          *(_DWORD *)(a1 + 8) = v52;
          goto LABEL_98;
        case 9u:
          v42 = *(_QWORD **)(a1 + 24);
          v41 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v42 >= v41)
          {
            v57 = ((uint64_t)v42 - *v8) >> 4;
            v58 = v57 + 1;
            if ((unint64_t)(v57 + 1) >> 60)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v59 = v41 - *v8;
            if (v59 >> 3 > v58)
              v58 = v59 >> 3;
            if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0)
              v60 = 0xFFFFFFFFFFFFFFFLL;
            else
              v60 = v58;
            v69 = v9;
            if (v60)
              v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v60);
            else
              v61 = 0;
            v62 = &v61[16 * v57];
            __p = v61;
            v66 = v62;
            v68 = &v61[16 * v60];
            *(_QWORD *)v62 = 0;
            *((_QWORD *)v62 + 1) = 0;
            v67 = v62 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
            v43 = *(_QWORD **)(a1 + 24);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v42 = 0;
            v42[1] = 0;
            v43 = v42 + 2;
            *(_QWORD *)(a1 + 24) = v42 + 2;
          }
          *(_QWORD *)(a1 + 24) = v43;
          __p = 0;
          v66 = 0;
          v67 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          if (SHIBYTE(v67) < 0)
            operator delete(__p);
          goto LABEL_98;
        default:
          goto LABEL_98;
      }
    }
    v4 = 0;
  }
  return v4 == 0;
}

void sub_2067FAFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void as::client::StreamPrefs::writeTo(as::client::StreamPrefs *this, PB::Writer *a2)
{
  int v4;
  const PB::Base *v5;
  int v6;
  caulk::xstring *v7;
  caulk::xstring *v8;
  char *v9;
  void *__p;
  char v11;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
    PB::Writer::writeVarInt(a2);
  v5 = (const PB::Base *)*((_QWORD *)this + 5);
  if (v5)
    PB::Writer::writeSubmessage(a2, v5);
  v6 = *((_DWORD *)this + 2);
  if ((v6 & 4) != 0)
  {
    PB::Writer::write(a2, *((double *)this + 6));
    v6 = *((_DWORD *)this + 2);
  }
  if ((v6 & 8) != 0)
    PB::Writer::writeVarInt(a2);
  v8 = (caulk::xstring *)*((_QWORD *)this + 2);
  v7 = (caulk::xstring *)*((_QWORD *)this + 3);
  while (v8 != v7)
  {
    v9 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(&__p, v9);
    PB::Writer::write();
    if (v11 < 0)
      operator delete(__p);
    v8 = (caulk::xstring *)((char *)v8 + 16);
  }
}

void sub_2067FB114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::client::StreamPrefs::formatText(as::client::StreamPrefs *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t v6;
  int v7;
  caulk::xstring *v8;
  caulk::xstring *i;
  char *v10;
  void *__p;
  char v13;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "streamToken");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "DSPFlavor");
  v6 = *((_QWORD *)this + 5);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "streamFormat");
  v7 = *((_DWORD *)this + 2);
  if ((v7 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "scalarVolume", *((double *)this + 6));
    v7 = *((_DWORD *)this + 2);
  }
  if ((v7 & 8) != 0)
    PB::TextFormatter::format(a2, "muteState");
  v8 = (caulk::xstring *)*((_QWORD *)this + 2);
  for (i = (caulk::xstring *)*((_QWORD *)this + 3); v8 != i; v8 = (caulk::xstring *)((char *)v8 + 16))
  {
    v10 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(&__p, v10);
    PB::TextFormatter::format();
    if (v13 < 0)
      operator delete(__p);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_2067FB258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::client::StreamPrefs::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  v4 = *(_QWORD *)(a1 + 48) == *(_QWORD *)(a2 + 48) && *(_QWORD *)(a1 + 56) == *(_QWORD *)(a2 + 56);
  if (!v4 || *(_DWORD *)(a1 + 64) != (unint64_t)*(unsigned int *)(a2 + 64))
    return 0;
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(_QWORD *)(a2 + 40);
  if (v7 && v8)
  {
    if (!as::StreamFormat::operator==(v7, v8))
      return 0;
  }
  else if (v7 | v8)
  {
    return 0;
  }
  v10 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a1 + 24);
  v11 = (v9 - v10) >> 4;
  if (v11 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 4)
    return 0;
  if (v9 == v10)
    return 1;
  v12 = v11 <= 1 ? 1 : (v9 - v10) >> 4;
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 16), *(const caulk::xstring **)(a2 + 16)))
    return 0;
  v13 = 1;
  v14 = 16;
  do
  {
    v15 = v13;
    if (v12 == v13)
      break;
    v16 = caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 16) + v14), (const caulk::xstring *)(*(_QWORD *)(a2 + 16) + v14));
    v13 = v15 + 1;
    v14 += 16;
  }
  while (!v16);
  return v15 >= v11;
}

uint64_t as::client::StreamPrefs::clearStreamFormat(as::client::StreamPrefs *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

as::client::TurnByTurnPref *as::client::TurnByTurnPref::TurnByTurnPref(as::client::TurnByTurnPref *this, const as::client::TurnByTurnPref *a2)
{
  *(_QWORD *)this = &off_24BFE3D38;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::client::TurnByTurnPref::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3D38;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::client::TurnByTurnPref::copy_from(this, a2);
  return this;
}

uint64_t as::client::TurnByTurnPref::copy_from(as::client::TurnByTurnPref *this, const as::client::TurnByTurnPref *a2)
{
  uint64_t result;

  result = caulk::xstring::assign((as::client::TurnByTurnPref *)((char *)this + 16), (const as::client::TurnByTurnPref *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_BYTE *)this + 32) = *((_BYTE *)a2 + 32);
  return result;
}

_QWORD *as::client::TurnByTurnPref::TurnByTurnPref(_QWORD *a1, uint64_t a2)
{
  *a1 = &off_24BFE3D38;
  a1[2] = 0;
  a1[3] = 0;
  as::client::TurnByTurnPref::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &off_24BFE3D38;
  a1[2] = 0;
  a1[3] = 0;
  as::client::TurnByTurnPref::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::client::TurnByTurnPref::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  return result;
}

uint64_t as::client::TurnByTurnPref::operator=(uint64_t a1, uint64_t a2)
{
  as::client::TurnByTurnPref::move_from(a1, a2);
  return a1;
}

uint64_t as::client::TurnByTurnPref::clear(as::client::TurnByTurnPref *this)
{
  uint64_t result;

  result = caulk::xstring::clear((as::client::TurnByTurnPref *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((_BYTE *)this + 32) = 0;
  return result;
}

BOOL as::client::TurnByTurnPref::isInitialized(as::client::TurnByTurnPref *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::client::TurnByTurnPref::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  unint64_t v21;
  int v22;
  BOOL v23;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        break;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v3 + 1;
        a2[1] = v3 + 1;
        v13 = *(_BYTE *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v3 = v12;
        if (v10++ > 8)
        {
          v11 = 0;
          break;
        }
      }
      v3 = v12;
LABEL_23:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v21 = v11 >> 3;
      if ((_DWORD)v21 == 2)
      {
        if (v3 >= v2)
        {
          v23 = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v22 = *(unsigned __int8 *)(v8 + v3++);
          a2[1] = v3;
          v23 = v22 != 0;
        }
        *(_BYTE *)(a1 + 32) = v23;
        *(_DWORD *)(a1 + 8) |= 2u;
      }
      else if ((_DWORD)v21 == 1)
      {
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 1u;
        v3 = a2[1];
        v2 = a2[2];
      }
      v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((_BYTE *)a2 + 24))
        return v4 == 0;
    }
    v15 = 0;
    v16 = 0;
    v11 = 0;
    if (v3 <= v2)
      v17 = v2;
    else
      v17 = v3;
    while (v17 != v3)
    {
      v18 = v3++;
      v19 = *(_BYTE *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0)
        goto LABEL_22;
      v15 += 7;
      if (v16++ >= 9)
      {
        v11 = 0;
LABEL_22:
        v3 = v18 + 1;
        goto LABEL_23;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_2067FB78C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::client::TurnByTurnPref::writeTo(as::client::TurnByTurnPref *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  void *__p;
  char v7;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::client::TurnByTurnPref *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v7 < 0)
      operator delete(__p);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
    PB::Writer::write(a2);
}

void sub_2067FB824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::client::TurnByTurnPref::formatText(as::client::TurnByTurnPref *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  void *__p;
  char v9;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::client::TurnByTurnPref *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v9 < 0)
      operator delete(__p);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "allowed");
  return PB::TextFormatter::endObject(a2);
}

void sub_2067FB8D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::client::TurnByTurnPref::operator==(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
      && caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
}

void as::client::SessionState::~SessionState(as::client::SessionState *this)
{
  as::client::SessionState::~SessionState(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)this = &off_24BFE3D00;
  v2 = *((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 26);
  *((_QWORD *)this + 26) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 192));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 176));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 160));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 144));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 128));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 112));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 96));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 80));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 64));
  v4 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v4 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v4);
  PB::Base::~Base(this);
}

void as::client::PortPrefs::~PortPrefs(as::client::PortPrefs *this)
{
  as::client::PortPrefs::~PortPrefs(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;

  *(_QWORD *)this = &off_24BFE3DE0;
  caulk::xstring::clear((as::client::PortPrefs *)((char *)this + 40));
  v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::client::PolarPatternPref::~PolarPatternPref(as::client::PolarPatternPref *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x20BCFDE58);
}

void as::client::IOControllerPrefs::~IOControllerPrefs(as::client::IOControllerPrefs *this)
{
  as::client::IOControllerPrefs::~IOControllerPrefs(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;

  *(_QWORD *)this = &off_24BFE3DA8;
  caulk::xstring::clear((as::client::IOControllerPrefs *)((char *)this + 64));
  v2 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::client::StreamPrefs::~StreamPrefs(as::client::StreamPrefs *this)
{
  as::client::StreamPrefs::~StreamPrefs(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE3CC8;
  v2 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::client::TurnByTurnPref::~TurnByTurnPref(as::client::TurnByTurnPref *this)
{
  as::client::TurnByTurnPref::~TurnByTurnPref(this);
  JUMPOUT(0x20BCFDE58);
}

{
  *(_QWORD *)this = &off_24BFE3D38;
  caulk::xstring::clear((as::client::TurnByTurnPref *)((char *)this + 16));
  PB::Base::~Base(this);
}

uint64_t std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

caulk::xstring *std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>(uint64_t a1, caulk::xstring *a2, caulk::xstring *a3, unint64_t a4)
{
  caulk::xstring *v6;
  uint64_t v8;
  caulk::xstring *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  caulk::xstring *result;
  caulk::xstring *v14;
  unint64_t v15;
  caulk::xstring *v16;
  uint64_t v17;
  caulk::xstring *v18;

  v6 = a2;
  v8 = a1 + 16;
  v9 = *(caulk::xstring **)a1;
  if (a4 > (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4)
  {
    std::vector<caulk::xstring>::__vdeallocate(a1);
    if (a4 >> 60)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v10 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
    v11 = v10 >> 3;
    if (v10 >> 3 <= a4)
      v11 = a4;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    std::vector<caulk::xstring>::__vallocate[abi:ne180100]((_QWORD *)a1, v12);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<caulk::xstring>,caulk::xstring*,caulk::xstring*,caulk::xstring*>(v8, v6, a3, *(caulk::xstring **)(a1 + 8));
LABEL_15:
    *(_QWORD *)(a1 + 8) = result;
    return result;
  }
  v14 = *(caulk::xstring **)(a1 + 8);
  v15 = (v14 - v9) >> 4;
  if (v15 < a4)
  {
    v16 = (caulk::xstring *)((char *)a2 + 16 * v15);
    if (v14 != v9)
    {
      v17 = 16 * v15;
      do
      {
        caulk::xstring::assign(v9, v6);
        v6 = (caulk::xstring *)((char *)v6 + 16);
        v9 = (caulk::xstring *)((char *)v9 + 16);
        v17 -= 16;
      }
      while (v17);
      v9 = *(caulk::xstring **)(a1 + 8);
    }
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<caulk::xstring>,caulk::xstring*,caulk::xstring*,caulk::xstring*>(v8, v16, a3, v9);
    goto LABEL_15;
  }
  if (a2 == a3)
  {
    v18 = *(caulk::xstring **)a1;
  }
  else
  {
    v18 = *(caulk::xstring **)a1;
    do
    {
      caulk::xstring::assign(v9, v6);
      v6 = (caulk::xstring *)((char *)v6 + 16);
      v9 = (caulk::xstring *)((char *)v9 + 16);
      v18 = (caulk::xstring *)((char *)v18 + 16);
    }
    while (v6 != a3);
  }
  return (caulk::xstring *)std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100](a1, v18);
}

void sub_2067FBCC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<caulk::xstring>::__vdeallocate(uint64_t a1)
{
  if (*(_QWORD *)a1)
  {
    std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100](a1, *(caulk::xstring **)a1);
    operator delete(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
}

char *std::vector<caulk::xstring>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

caulk::xstring *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<caulk::xstring>,caulk::xstring*,caulk::xstring*,caulk::xstring*>(uint64_t a1, caulk::xstring *a2, caulk::xstring *a3, caulk::xstring *this)
{
  caulk::xstring *v4;
  const caulk::xstring *v6;
  _QWORD v8[3];
  char v9;
  caulk::xstring *v10;
  caulk::xstring *v11;

  v4 = this;
  v10 = this;
  v11 = this;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *(_QWORD *)v4 = 0;
      *((_QWORD *)v4 + 1) = 0;
      caulk::xstring::assign(v4, v6);
      v6 = (const caulk::xstring *)((char *)v6 + 16);
      v4 = (caulk::xstring *)((char *)v11 + 16);
      v11 = (caulk::xstring *)((char *)v11 + 16);
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_2067FBDD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>::operator()[abi:ne180100](a1);
  return a1;
}

uint64_t std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>::operator()[abi:ne180100](uint64_t result)
{
  caulk::xstring *v1;
  caulk::xstring *v2;

  v1 = **(caulk::xstring ***)(result + 16);
  v2 = **(caulk::xstring ***)(result + 8);
  while (v1 != v2)
  {
    v1 = (caulk::xstring *)((char *)v1 - 16);
    result = caulk::xstring::clear(v1);
  }
  return result;
}

uint64_t std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100](uint64_t result, caulk::xstring *a2)
{
  uint64_t v3;
  caulk::xstring *i;

  v3 = result;
  for (i = *(caulk::xstring **)(result + 8); i != a2; result = caulk::xstring::clear(i))
    i = (caulk::xstring *)((char *)i - 16);
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

uint64_t std::vector<caulk::xstring>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 16;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      caulk::xstring::move();
      v7 = *((_QWORD *)&v15 + 1) - 16;
      *((_QWORD *)&v15 + 1) -= 16;
    }
    while (v9 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

caulk::xstring *std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[8];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[8];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v15 = v3;
  v16 = v2;
  v17 = v3;
  v18 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v10 = v7;
  v11 = v6;
  v12 = v7;
  v13 = v6;
  return std::__allocator_destroy[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>>(v4, (uint64_t)v14, (uint64_t)v9);
}

caulk::xstring *std::__allocator_destroy[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  caulk::xstring *result;

  for (result = *(caulk::xstring **)(a2 + 32); result != *(caulk::xstring **)(a3 + 32); *(_QWORD *)(a2 + 32) = result)
  {
    caulk::xstring::clear(result);
    result = (caulk::xstring *)(*(_QWORD *)(a2 + 32) + 16);
  }
  return result;
}

uint64_t std::__split_buffer<caulk::xstring>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<caulk::xstring>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__split_buffer<caulk::xstring>::__destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = result;
  while (1)
  {
    v4 = *(_QWORD *)(v3 + 16);
    if (v4 == a2)
      break;
    *(_QWORD *)(v3 + 16) = v4 - 16;
    result = caulk::xstring::clear((caulk::xstring *)(v4 - 16));
  }
  return result;
}

void std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (caulk::xstring *)*v2);
    operator delete(**a1);
  }
}

_UNKNOWN **as::mxsession_error_category::instance(as::mxsession_error_category *this)
{
  return &as::mxsession_error_category::instance(void)::gInstance;
}

_QWORD *as::mxsession_error_category::message@<X0>(int a1@<W1>, _QWORD *a2@<X8>)
{
  char *v3;

  if ((a1 + 15685) > 5)
    v3 = "unknown MXSessionError";
  else
    v3 = off_24BFE44B0[a1 + 15685];
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

void as::mxsession_error_category::~mxsession_error_category(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x20BCFDE58);
}

const char *as::mxsession_error_category::name(as::mxsession_error_category *this)
{
  return "MXSession Error";
}

uint64_t as::WorkloopPool::WorkloopPool(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char **v3;
  unint64_t i;
  void **v6;
  NSObject *inactive;
  _QWORD *v8;
  NSObject *v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v14;
  void *__p[2];
  uint64_t v17;
  uint64_t v18[3];
  __int128 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)(a1 + 24) = 0u;
  v3 = (char **)(a1 + 24);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  if (!a3)
  {
    v14 = _os_crash();
    as::WorkloopPool::WorkloopPool(v14);
  }
  for (i = 0; i != a3; ++i)
  {
    v20 = 7;
    v18[2] = 7;
    v19 = i;
    __p[1] = 0;
    v17 = 0;
    __p[0] = 0;
    v18[0] = 1;
    v18[1] = (uint64_t)&v19;
    std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)__p, "AudioSession (WL{})", 19, v18);
    if (v17 >= 0)
      v6 = __p;
    else
      v6 = (void **)__p[0];
    inactive = dispatch_workloop_create_inactive((const char *)v6);
    dispatch_workloop_set_scheduler_priority();
    dispatch_workloop_set_autorelease_frequency(inactive, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    dispatch_activate(inactive);
    v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    *v8 = &unk_24BFE4578;
    v9 = inactive;
    v8[3] = v9;
    *((_BYTE *)v8 + 32) = 0;
    *(_QWORD *)&v19 = v8 + 3;
    *((_QWORD *)&v19 + 1) = v8;
    std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::push_back[abi:ne180100](v3, &v19);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v19 + 1);
    if (*((_QWORD *)&v19 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    if (SHIBYTE(v17) < 0)
      operator delete(__p[0]);
  }
  return a1;
}

void sub_2067FC6A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  std::__shared_weak_count *v21;

  if (a16 < 0)
    operator delete(__p);
  std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::~deque[abi:ne180100]((_QWORD *)(a10 + 48));
  std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  v21 = *(std::__shared_weak_count **)(a10 + 8);
  if (v21)
    std::__shared_weak_count::__release_weak(v21);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = std::__split_buffer<std::shared_ptr<as::WorkloopPool::WorkloopState>>::~__split_buffer((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

void as::WorkloopPool::Create(as::WorkloopPool *this@<X0>, _QWORD *a2@<X8>)
{
  char v2;
  as::WorkloopPool *v3;

  v3 = this;
  std::allocate_shared[abi:ne180100]<as::WorkloopPool,std::allocator<as::WorkloopPool>,as::WorkloopPool::ConstructionTag,unsigned long &,void>((uint64_t)&v2, (uint64_t *)&v3, a2);
}

void as::WorkloopPool::dispatchAsync(os_unfair_lock_s *a1, void *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  NSObject **v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  NSObject *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD block[5];
  std::__shared_weak_count *v23;
  NSObject **v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  id v28;

  v27 = 0;
  v28 = a2;
  v26 = 0;
  os_unfair_lock_lock(a1 + 4);
  std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::push_back(&a1[12]._os_unfair_lock_opaque, &v28);
  v3 = *(uint64_t **)&a1[6]._os_unfair_lock_opaque;
  v4 = *(uint64_t **)&a1[8]._os_unfair_lock_opaque;
  if (v3 != v4)
  {
    while (*(_BYTE *)(*v3 + 8))
    {
      v3 += 2;
      if (v3 == v4)
        goto LABEL_8;
    }
  }
  if (v3 != v4)
  {
    std::shared_ptr<as::WorkloopPool::WorkloopState>::operator=[abi:ne180100](&v26, v3);
    if (*(_BYTE *)(v26 + 8))
    {
      v21 = _os_crash();
      as::WorkloopPool::WorkloopPool(v21);
    }
    *(_BYTE *)(v26 + 8) = 1;
  }
LABEL_8:
  os_unfair_lock_unlock(a1 + 4);
  v5 = (NSObject **)v26;
  if (v26)
  {
    v6 = *(_QWORD *)&a1->_os_unfair_lock_opaque;
    v7 = *(std::__shared_weak_count **)&a1[2]._os_unfair_lock_opaque;
    if (v7)
    {
      p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v9 = __ldxr(p_shared_weak_owners);
      while (__stxr(v9 + 1, p_shared_weak_owners));
    }
    v10 = *v5;
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3321888768;
    block[2] = ___ZN2as12WorkloopPool13dispatchAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &__block_descriptor_64_ea8_32c43_ZTSKNSt3__18weak_ptrIN2as12WorkloopPoolEEE48c60_ZTSNSt3__110shared_ptrIN2as12WorkloopPool13WorkloopStateEEE_e5_v8__0l;
    block[4] = v6;
    v23 = v7;
    if (v7)
    {
      v11 = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    v24 = v5;
    v25 = v27;
    if (v27)
    {
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    dispatch_async(v10, block);
    v15 = v25;
    if (v25)
    {
      v16 = (unint64_t *)&v25->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    if (v23)
      std::__shared_weak_count::__release_weak(v23);
    if (v7)
      std::__shared_weak_count::__release_weak(v7);
  }
  v18 = v27;
  if (v27)
  {
    v19 = (unint64_t *)&v27->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

}

void sub_2067FCA50(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;

  os_unfair_lock_unlock(v1);
  std::shared_ptr<as::WorkloopPool::WorkloopState>::~shared_ptr[abi:ne180100](v2 - 40);

  _Unwind_Resume(a1);
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t result;

  v4 = a1[1];
  v5 = a1[2];
  v6 = ((v5 - v4) << 6) - 1;
  if (v5 == v4)
    v6 = 0;
  if (v6 == a1[5] + a1[4])
  {
    std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__add_back_capacity(a1);
    v4 = a1[1];
    v5 = a1[2];
  }
  if (v5 == v4)
  {
    v8 = 0;
  }
  else
  {
    v7 = a1[5] + a1[4];
    v8 = (uint64_t *)(*(_QWORD *)(v4 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF));
  }
  result = MEMORY[0x20BCFE08C](*a2);
  *v8 = result;
  ++a1[5];
  return result;
}

_QWORD *std::shared_ptr<as::WorkloopPool::WorkloopState>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void ___ZN2as12WorkloopPool13dispatchAsyncEU13block_pointerFvvE_block_invoke(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  std::__shared_weak_count *v15;

  v14 = 0;
  v15 = 0;
  v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    v15 = std::__shared_weak_count::lock(v2);
    if (v15)
    {
      v3 = a1[4];
      v14 = v3;
      if (v3)
      {
        v4 = a1[6];
        v5 = (std::__shared_weak_count *)a1[7];
        v13[0] = v4;
        v13[1] = v5;
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldxr(p_shared_owners);
          while (__stxr(v7 + 1, p_shared_owners));
        }
        as::WorkloopPool::handleBlocks(v3, (uint64_t)v13);
        if (v5)
        {
          v8 = (unint64_t *)&v5->__shared_owners_;
          do
            v9 = __ldaxr(v8);
          while (__stlxr(v9 - 1, v8));
          if (!v9)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
      }
    }
  }
  v10 = v15;
  if (v15)
  {
    v11 = (unint64_t *)&v15->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_2067FCC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<as::WorkloopPool::WorkloopState>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<as::WorkloopPool::WorkloopState>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void as::WorkloopPool::handleBlocks(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void (**v5)(_QWORD);
  uint64_t v6;

  v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  while (*(_QWORD *)(a1 + 88))
  {
    v5 = (void (**)(_QWORD))MEMORY[0x20BCFE08C](*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56)
                                                                                 + ((*(_QWORD *)(a1 + 80) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                     + 8 * (*(_QWORD *)(a1 + 80) & 0x1FFLL)));
    std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::pop_front((int64x2_t *)(a1 + 48));
    os_unfair_lock_unlock(v4);
    if (v5)
      v5[2](v5);

    os_unfair_lock_lock(v4);
  }
  if (!*(_BYTE *)(*(_QWORD *)a2 + 8))
  {
    v6 = _os_crash();
    as::WorkloopPool::WorkloopPool(v6);
  }
  *(_BYTE *)(*(_QWORD *)a2 + 8) = 0;
  os_unfair_lock_unlock(v4);
}

void sub_2067FCD58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_32c43_ZTSKNSt3__18weak_ptrIN2as12WorkloopPoolEEE48c60_ZTSNSt3__110shared_ptrIN2as12WorkloopPool13WorkloopStateEEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_ea8_32c43_ZTSKNSt3__18weak_ptrIN2as12WorkloopPoolEEE48c60_ZTSNSt3__110shared_ptrIN2as12WorkloopPool13WorkloopStateEEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  std::shared_ptr<as::WorkloopPool::WorkloopState>::~shared_ptr[abi:ne180100](a1 + 48);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::pop_front(int64x2_t *a1)
{
  objc_release(*(id *)(*(_QWORD *)(a1->i64[1] + (((unint64_t)a1[2].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                     + 8 * (a1[2].i64[0] & 0x1FF)));
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_20682E240);
  return std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

uint64_t std::__split_buffer<std::shared_ptr<as::WorkloopPool::WorkloopState>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<as::WorkloopPool::WorkloopState>::~shared_ptr[abi:ne180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<as::WorkloopPool::WorkloopState>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::shared_ptr<as::WorkloopPool::WorkloopState>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  void **v7;
  uint64_t v8;
  void *v9;
  void **v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  if (v3 == v2)
  {
    v4 = a1 + 5;
    v3 = (void **)a1[1];
  }
  else
  {
    v4 = a1 + 5;
    v5 = a1[4];
    v6 = &v2[v5 >> 9];
    v7 = (void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (void **)v8)
    {
      do
      {
        v9 = *v7++;

        if ((char *)v7 - (_BYTE *)*v6 == 4096)
        {
          v10 = (void **)v6[1];
          ++v6;
          v7 = v10;
        }
      }
      while (v7 != (void **)v8);
      v2 = (void **)a1[1];
      v3 = (void **)a1[2];
    }
  }
  *v4 = 0;
  v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v12 = v11 >> 3;
  if (v12 == 1)
  {
    v13 = 256;
  }
  else
  {
    if (v12 != 2)
      goto LABEL_16;
    v13 = 512;
  }
  a1[4] = v13;
LABEL_16:
  while (v2 != v3)
  {
    v14 = *v2++;
    operator delete(v14);
  }
  return std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
    operator delete(v4);
  return a1;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, char *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  char v5;
  char v6;
  char **v7;
  __int128 v8;
  uint64_t v9;
  std::locale v10;
  char v11;
  char *v12[2];
  int v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[256];
  char *v17;
  __int128 v18;
  uint64_t (*v19)(char *, std::string::size_type, uint64_t);
  _BYTE *v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v18 = xmmword_20682E250;
  v17 = v16;
  v19 = std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke;
  v20 = v16;
  v4 = *a4;
  v12[0] = a2;
  v12[1] = &a2[a3];
  v13 = 0;
  v14 = 0;
  v15 = v4;
  v8 = *(_OWORD *)a4;
  v9 = a4[2];
  v5 = 0;
  v6 = 0;
  v7 = &v17;
  LOBYTE(v10.__locale_) = 0;
  v11 = 0;
  std::__format::__vformat_to[abi:ne180100]<std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v12, (uint64_t **)&v7);
  if (v11)
    std::locale::~locale(&v10);
  v19(v17, *((_QWORD *)&v18 + 1), (uint64_t)v20);
}

void sub_2067FD1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  _Unwind_Resume(exception_object);
}

uint64_t *std::__format::__vformat_to[abi:ne180100]<std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char **a1, uint64_t **a2)
{
  char *v3;
  char *v4;
  uint64_t *v5;
  int v7;
  char *v8;
  uint64_t *v10;

  v3 = *a1;
  v4 = a1[1];
  v5 = *a2;
  if (*a1 != v4)
  {
    while (1)
    {
      v7 = *v3;
      if (v7 == 125)
        break;
      if (v7 != 123)
        goto LABEL_10;
      if (++v3 == v4)
        std::__throw_format_error[abi:ne180100]("The format string terminates at a '{'");
      if (*v3 == 123)
      {
LABEL_10:
        v8 = v3 + 1;
        v10 = v5;
        std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v10, v3);
        v3 = v8;
        if (v8 == v4)
          return v5;
      }
      else
      {
        *a2 = v5;
        v3 = std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v3, v4, a1, a2);
        v5 = *a2;
        if (v3 == v4)
          return v5;
      }
    }
    if (++v3 == v4 || *v3 != 125)
      std::__throw_format_error[abi:ne180100]("The format string contains an invalid escape sequence");
    goto LABEL_10;
  }
  return v5;
}

uint64_t std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke(char *a1, std::string::size_type __n_add, uint64_t a3)
{
  std::string *v4;
  std::string::size_type size;
  std::string::size_type v6;

  v4 = *(std::string **)(a3 + 296);
  if (SHIBYTE(v4->__r_.__value_.__r.__words[2]) < 0)
  {
    v6 = v4->__r_.__value_.__r.__words[0];
    size = v4->__r_.__value_.__l.__size_;
  }
  else
  {
    size = HIBYTE(v4->__r_.__value_.__r.__words[2]);
    v6 = *(_QWORD *)(a3 + 296);
  }
  return std::string::__insert_with_size<char *,char *>(v4, v6 + size, a1, &a1[__n_add], __n_add);
}

uint64_t std::string::__insert_with_size<char *,char *>(std::string *this, uint64_t a2, char *a3, char *a4, std::string::size_type __n_add)
{
  std::string *v6;
  std::string::size_type v7;
  std::string::size_type size;
  std::string *v9;
  std::string::size_type v10;
  std::string *p_p;
  uint64_t v12;
  std::string __p;

  v6 = this;
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v7 = a2 - (_QWORD)this;
    if (__n_add)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = this;
      goto LABEL_6;
    }
    return (uint64_t)v6 + v7;
  }
  v9 = (std::string *)this->__r_.__value_.__r.__words[0];
  v7 = a2 - this->__r_.__value_.__r.__words[0];
  if (!__n_add)
  {
    v6 = (std::string *)this->__r_.__value_.__r.__words[0];
    return (uint64_t)v6 + v7;
  }
  size = this->__r_.__value_.__l.__size_;
LABEL_6:
  if (v9 > (std::string *)a3 || (char *)&v9->__r_.__value_.__l.__data_ + size + 1 <= a3)
    return std::string::__insert_from_safe_copy[abi:ne180100]<char *,char *>(this, __n_add, v7, a3, a4);
  std::string::__init_with_sentinel[abi:ne180100]<char *,char *>(&__p, a3, a4);
  v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v10 = __p.__r_.__value_.__l.__size_;
  v12 = std::string::__insert_from_safe_copy[abi:ne180100]<char *,char *>(v6, __n_add, v7, (char *)p_p, (char *)p_p + v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v12;
}

void sub_2067FD42C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::string::__insert_from_safe_copy[abi:ne180100]<char *,char *>(std::string *this, std::string::size_type __n_add, std::string::size_type __n_copy, char *a4, char *a5)
{
  std::string *v9;
  std::string::size_type size;
  std::string::size_type v11;
  std::string *v12;
  size_t v13;
  std::string::size_type v14;
  _BYTE *v15;
  char v16;

  v9 = this;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    size = this->__r_.__value_.__l.__size_;
    v11 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v11 - size >= __n_add)
    {
      v12 = (std::string *)this->__r_.__value_.__r.__words[0];
      goto LABEL_7;
    }
  }
  else
  {
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v11 = 22;
    v12 = this;
    if (22 - size >= __n_add)
    {
LABEL_7:
      v13 = size - __n_copy;
      if (size == __n_copy)
        size = __n_copy;
      else
        memmove((char *)v12 + __n_copy + __n_add, (char *)v12 + __n_copy, v13);
      goto LABEL_10;
    }
  }
  std::string::__grow_by(this, v11, size + __n_add - v11, size, __n_copy, 0, __n_add);
  v9->__r_.__value_.__l.__size_ = size + __n_add;
  v12 = (std::string *)v9->__r_.__value_.__r.__words[0];
LABEL_10:
  v14 = size + __n_add;
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0)
    v9->__r_.__value_.__l.__size_ = v14;
  else
    *((_BYTE *)&v9->__r_.__value_.__s + 23) = v14 & 0x7F;
  v12->__r_.__value_.__s.__data_[v14] = 0;
  if (a4 != a5)
  {
    v15 = (char *)v12 + __n_copy;
    do
    {
      v16 = *a4++;
      *v15++ = v16;
    }
    while (a4 != a5);
  }
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0)
    v9 = (std::string *)v9->__r_.__value_.__r.__words[0];
  return (uint64_t)v9 + __n_copy;
}

void std::string::__init_with_sentinel[abi:ne180100]<char *,char *>(std::string *this, std::string::value_type *a2, std::string::value_type *a3)
{
  std::string::value_type *v4;

  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    v4 = a2;
    do
      std::string::push_back(this, *v4++);
    while (v4 != a3);
  }
}

void sub_2067FD5B4(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  __cxa_rethrow();
}

void sub_2067FD5D0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__throw_format_error[abi:ne180100](const char *a1)
{
  std::runtime_error *exception;

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::format_error::format_error[abi:ne180100](exception, a1);
}

void sub_2067FD620(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, char *a2, char **a3, _QWORD *a4)
{
  char *v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 *v15;
  __int128 v16;
  char *v17;
  _QWORD v19[3];
  BOOL v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v7 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, (uint64_t)a3);
  if (v7 == a2)
    goto LABEL_14;
  v9 = *v7;
  v20 = v9 == 58;
  if (v9 == 125)
    goto LABEL_5;
  if (v9 != 58)
LABEL_14:
    std::__throw_format_error[abi:ne180100]("The argument index should end with a ':' or a '}'");
  ++v7;
LABEL_5:
  *a3 = v7;
  v19[0] = a3;
  v19[1] = a4;
  v19[2] = &v20;
  v10 = a4[1];
  if (v10 <= v8)
  {
    LOBYTE(v22) = 0;
  }
  else if (v10 > 0xC)
  {
    v15 = (__int128 *)(a4[2] + 32 * v8);
    v16 = v15[1];
    v21 = *v15;
    v22 = v16;
  }
  else
  {
    v11 = (uint64_t *)(a4[2] + 16 * v8);
    v13 = *v11;
    v12 = v11[1];
    v14 = (a4[3] >> (5 * v8)) & 0x1FLL;
    *(_QWORD *)&v21 = v13;
    *((_QWORD *)&v21 + 1) = v12;
    LOBYTE(v22) = v14;
  }
  std::__visit_format_arg[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)v19, (uint64_t)&v21);
  v17 = *a3;
  if (*a3 == a2 || *v17 != 125)
    std::__throw_format_error[abi:ne180100]("The replacement field misses a terminating '}'");
  return v17 + 1;
}

uint64_t **std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](uint64_t **a1, char *a2)
{
  uint64_t *v3;
  char v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *a1;
  v4 = *a2;
  v5 = **a1;
  v6 = (*a1)[2];
  v3[2] = v6 + 1;
  *(_BYTE *)(v5 + v6) = v4;
  if (v3[2] == v3[1])
  {
    ((void (*)(uint64_t))v3[3])(*v3);
    v3[2] = 0;
  }
  return a1;
}

std::runtime_error *std::format_error::format_error[abi:ne180100](std::runtime_error *a1, const char *a2)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_24BFE4550;
  return result;
}

void std::format_error::~format_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x20BCFDE58);
}

char *std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *a1, char *a2, uint64_t a3)
{
  char *v3;
  int v4;
  int v5;

  v3 = a1;
  v4 = *a1;
  if (v4 == 125 || v4 == 58)
  {
    std::basic_format_parse_context<char>::next_arg_id[abi:ne180100](a3);
    return v3;
  }
  if (v4 == 48)
  {
    v5 = *(_DWORD *)(a3 + 16);
    if (v5)
    {
      if (v5 == 2)
        std::__throw_format_error[abi:ne180100]("Using manual argument numbering in automatic argument numbering mode");
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 1;
    }
    return a1 + 1;
  }
  if ((v4 - 58) <= 0xF5u)
    std::__throw_format_error[abi:ne180100]("The argument index starts with an invalid character");
  return std::__format::__detail::__parse_manual[abi:ne180100]<char const*,std::basic_format_parse_context<char>>((unint64_t)a1, a2, a3);
}

void std::__visit_format_arg[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }
}

void sub_2067FD8E0(uint64_t a1, unsigned __int8 *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},BOOL &>(a1, a2);
}

void sub_2067FD8E8(uint64_t a1, unsigned __int8 *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char &>(a1, a2);
}

void sub_2067FD8F0(uint64_t a1, int *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},int &>(a1, a2);
}

void sub_2067FD8F8(uint64_t a1, uint64_t *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long long &>(a1, a2);
}

void sub_2067FD900(uint64_t a1, unint64_t *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},__int128 &>(a1, a2);
}

void sub_2067FD908(uint64_t a1, unsigned int *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned int &>(a1, a2);
}

void sub_2067FD910(uint64_t a1, unint64_t *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned long long &>(a1, a2);
}

void sub_2067FD918(uint64_t a1, unint64_t *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned __int128 &>(a1, a2);
}

uint64_t *sub_2067FD920(uint64_t a1, float *a2)
{
  return std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},float &>(a1, a2);
}

uint64_t *sub_2067FD928(uint64_t a1, double *a2)
{
  return std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},double &>(a1, a2);
}

uint64_t *sub_2067FD930(uint64_t a1, double *a2)
{
  return std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long double &>(a1, a2);
}

uint64_t *sub_2067FD938(uint64_t a1, char **a2)
{
  return std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char const*&>(a1, a2);
}

_QWORD *sub_2067FD940(uint64_t a1, uint64_t a2)
{
  return std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::string_view &>(a1, a2);
}

void sub_2067FD948(uint64_t a1, uint64_t *a2)
{
  std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},void const*&>(a1, a2);
}

uint64_t sub_2067FD950(_QWORD *a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a2 + 8))(*a1, a1[1], *(_QWORD *)a2);
}

void sub_2067FD968()
{
  std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
}

char *std::__format::__detail::__parse_manual[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(unint64_t a1, char *a2, uint64_t a3)
{
  char *result;
  int v5;

  result = std::__format::__parse_number[abi:ne180100]<char const*>(a1, a2);
  v5 = *(_DWORD *)(a3 + 16);
  if (v5)
  {
    if (v5 == 2)
      std::__throw_format_error[abi:ne180100]("Using manual argument numbering in automatic argument numbering mode");
  }
  else
  {
    *(_DWORD *)(a3 + 16) = 1;
  }
  return result;
}

uint64_t std::basic_format_parse_context<char>::next_arg_id[abi:ne180100](uint64_t a1)
{
  int v1;
  uint64_t v2;

  v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    if (v1 == 1)
      std::__throw_format_error[abi:ne180100]("Using automatic argument numbering in manual argument numbering mode");
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 2;
  }
  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v2 + 1;
  return v2;
}

char *std::__format::__parse_number[abi:ne180100]<char const*>(unint64_t a1, char *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned int v4;
  int v5;
  uint64_t v6;

  if ((uint64_t)&a2[-a1] <= 9)
    v2 = (unsigned __int8 *)a2;
  else
    v2 = (unsigned __int8 *)(a1 + 9);
  v3 = (unsigned __int8 *)(a1 + 1);
  v4 = *(char *)a1 - 48;
  if ((unsigned __int8 *)(a1 + 1) == v2)
  {
LABEL_8:
    if (v2 == (unsigned __int8 *)a2)
    {
      return a2;
    }
    else
    {
      v6 = *v2;
      if ((v6 - 48) > 9)
      {
        return (char *)v2;
      }
      else if ((v6 + 10 * (unint64_t)v4 - 48) >> 31
             || (v3 = (unsigned __int8 *)(a1 + 2), (char *)(a1 + 2) != a2) && *v3 - 48 <= 9)
      {
        std::__throw_format_error[abi:ne180100]("The numeric value of the format specifier is too large");
      }
    }
  }
  else
  {
    a1 += (unint64_t)&v2[~a1];
    while (1)
    {
      v5 = *v3;
      if ((v5 - 58) < 0xFFFFFFF6)
        break;
      v4 = v5 + 10 * v4 - 48;
      if (++v3 == v2)
        goto LABEL_8;
    }
  }
  return (char *)v3;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},BOOL &>(uint64_t a1, unsigned __int8 *a2)
{
  int v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  __int16 v11;
  char v12;

  v3 = *a2;
  v8 = 0;
  v9 = -1;
  v10 = 32;
  v11 = 0;
  v12 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_BOOL[abi:ne180100]<char>((uint64_t)&v8, "a BOOL");
    *v4 = v5;
  }
  v6 = *(_QWORD **)(a1 + 8);
  std::formatter<BOOL,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v8, v3 != 0, v6);
  *v6 = v7;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char &>(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  __int16 v11;
  char v12;

  v3 = *a2;
  v8 = 0;
  v9 = -1;
  v10 = 32;
  v11 = 0;
  v12 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_char[abi:ne180100]<char>((uint64_t)&v8, "a character");
    *v4 = v5;
  }
  v6 = *(_QWORD **)(a1 + 8);
  std::__formatter_char<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v8, v3, v6);
  *v6 = v7;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},int &>(uint64_t a1, int *a2)
{
  int v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  __int16 v11;
  char v12;

  v3 = *a2;
  v8 = 0;
  v9 = -1;
  v10 = 32;
  v11 = 0;
  v12 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    *v4 = v5;
  }
  v6 = *(_QWORD **)(a1 + 8);
  std::__formatter_integer<char>::format[abi:ne180100]<int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *v6 = v7;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long long &>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  __int16 v11;
  char v12;

  v3 = *a2;
  v8 = 0;
  v9 = -1;
  v10 = 32;
  v11 = 0;
  v12 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    *v4 = v5;
  }
  v6 = *(_QWORD **)(a1 + 8);
  std::__formatter_integer<char>::format[abi:ne180100]<long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *v6 = v7;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},__int128 &>(uint64_t a1, unint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  unsigned __int8 **v5;
  unsigned __int8 *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  char v11;
  __int16 v12;
  char v13;

  v4 = *a2;
  v3 = a2[1];
  v9 = 0;
  v10 = -1;
  v11 = 32;
  v12 = 0;
  v13 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v5 = *(unsigned __int8 ***)a1;
    v6 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v9, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v9, "an integer");
    *v5 = v6;
  }
  v7 = *(_QWORD **)(a1 + 8);
  std::__formatter_integer<char>::format[abi:ne180100]<__int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v9, v4, v3, v7);
  *v7 = v8;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned int &>(uint64_t a1, unsigned int *a2)
{
  uint64_t v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  __int16 v11;
  char v12;

  v3 = *a2;
  v8 = 0;
  v9 = -1;
  v10 = 32;
  v11 = 0;
  v12 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    *v4 = v5;
  }
  v6 = *(_QWORD **)(a1 + 8);
  std::__formatter_integer<char>::format[abi:ne180100]<unsigned int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *v6 = v7;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned long long &>(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char v10;
  __int16 v11;
  char v12;

  v3 = *a2;
  v8 = 0;
  v9 = -1;
  v10 = 32;
  v11 = 0;
  v12 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    *v4 = v5;
  }
  v6 = *(_QWORD **)(a1 + 8);
  std::__formatter_integer<char>::format[abi:ne180100]<unsigned long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *v6 = v7;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned __int128 &>(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  unint64_t v4;
  unsigned __int8 **v5;
  unsigned __int8 *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  char v11;
  __int16 v12;
  char v13;

  v4 = *a2;
  v3 = a2[1];
  v9 = 0;
  v10 = -1;
  v11 = 32;
  v12 = 0;
  v13 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v5 = *(unsigned __int8 ***)a1;
    v6 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v9, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v9, "an integer");
    *v5 = v6;
  }
  v7 = *(_QWORD **)(a1 + 8);
  std::__formatter_integer<char>::format[abi:ne180100]<unsigned __int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v9, v4, v3, v7);
  *v7 = v8;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},float &>(uint64_t a1, float *a2)
{
  float v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  uint64_t **v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *result;
  uint64_t v11;
  int v12;
  char v13;
  __int16 v14;
  char v15;

  v3 = *a2;
  v11 = 0;
  v12 = -1;
  v13 = 32;
  v14 = 0;
  v15 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1, 0x13Fu);
    if (BYTE1(v11) - 13 >= 6)
    {
      if (BYTE1(v11) > 0xCu || ((1 << SBYTE1(v11)) & 0x1801) == 0)
        std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a floating-point");
    }
    else if ((SWORD1(v11) & 0x80000000) == 0 && v12 == -1)
    {
      v12 = 6;
    }
    *v4 = v5;
  }
  v7 = *(uint64_t ***)(a1 + 8);
  v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v7);
  result = std::__formatter::__format_floating_point[abi:ne180100]<float,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, v8, v9, v3);
  *v7 = result;
  return result;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},double &>(uint64_t a1, double *a2)
{
  double v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  uint64_t **v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *result;
  uint64_t v11;
  int v12;
  char v13;
  __int16 v14;
  char v15;

  v3 = *a2;
  v11 = 0;
  v12 = -1;
  v13 = 32;
  v14 = 0;
  v15 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1, 0x13Fu);
    if (BYTE1(v11) - 13 >= 6)
    {
      if (BYTE1(v11) > 0xCu || ((1 << SBYTE1(v11)) & 0x1801) == 0)
        std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a floating-point");
    }
    else if ((SWORD1(v11) & 0x80000000) == 0 && v12 == -1)
    {
      v12 = 6;
    }
    *v4 = v5;
  }
  v7 = *(uint64_t ***)(a1 + 8);
  v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v7);
  result = std::__formatter::__format_floating_point[abi:ne180100]<double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, v8, v9, v3);
  *v7 = result;
  return result;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long double &>(uint64_t a1, double *a2)
{
  double v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  uint64_t **v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *result;
  uint64_t v11;
  int v12;
  char v13;
  __int16 v14;
  char v15;

  v3 = *a2;
  v11 = 0;
  v12 = -1;
  v13 = 32;
  v14 = 0;
  v15 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1, 0x13Fu);
    if (BYTE1(v11) - 13 >= 6)
    {
      if (BYTE1(v11) > 0xCu || ((1 << SBYTE1(v11)) & 0x1801) == 0)
        std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a floating-point");
    }
    else if ((SWORD1(v11) & 0x80000000) == 0 && v12 == -1)
    {
      v12 = 6;
    }
    *v4 = v5;
  }
  v7 = *(uint64_t ***)(a1 + 8);
  v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v7);
  result = std::__formatter::__format_floating_point[abi:ne180100]<long double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, v8, v9, v3);
  *v7 = result;
  return result;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char const*&>(uint64_t a1, char **a2)
{
  char *v3;
  unsigned __int8 **v4;
  uint64_t **v5;
  uint64_t *result;
  int v7;
  unint64_t v8;
  char v9;
  __int16 v10;
  char v11;

  v3 = *a2;
  v7 = 1;
  v8 = 0xFFFFFFFF00000000;
  v9 = 32;
  v10 = 0;
  v11 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    *v4 = std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v7, *(unsigned __int8 ***)a1);
  }
  v5 = *(uint64_t ***)(a1 + 8);
  result = std::formatter<char const*,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v7, v3, v5);
  *v5 = result;
  return result;
}

_QWORD *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::string_view &>(uint64_t a1, uint64_t a2)
{
  char *v3;
  size_t v4;
  unsigned __int8 **v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *result;
  int v11;
  unint64_t v12;
  char v13;
  __int16 v14;
  char v15;

  v3 = *(char **)a2;
  v4 = *(_QWORD *)(a2 + 8);
  v11 = 1;
  v12 = 0xFFFFFFFF00000000;
  v13 = 32;
  v14 = 0;
  v15 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v5 = *(unsigned __int8 ***)a1;
    *v5 = std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1);
  }
  v6 = *(_QWORD **)(a1 + 8);
  v7 = (_QWORD *)*v6;
  v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v6);
  result = std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v3, v4, v7, v8, v9);
  *v6 = result;
  return result;
}

void std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},void const*&>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unsigned __int8 **v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  char v9;
  __int16 v10;
  char v11;

  v3 = *a2;
  v7 = 0;
  v8 = -1;
  v9 = 32;
  v10 = 0;
  v11 = 0;
  if (**(_BYTE **)(a1 + 16))
  {
    v4 = *(unsigned __int8 ***)a1;
    *v4 = std::__formatter_pointer<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v7, *(unsigned __int8 ***)a1);
  }
  v5 = *(_QWORD **)(a1 + 8);
  std::__formatter_pointer<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v7, v3, v5);
  *v5 = v6;
}

void std::formatter<BOOL,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  __int16 v7;

  if (*(unsigned __int8 *)(a1 + 1) > 1u)
  {
    v7 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (uint64_t)a3, v7);
  }
  else
  {
    v5 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    std::__formatter::__format_BOOL[abi:ne180100]<char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (_QWORD **)a3, v5, v6);
  }
}

unsigned __int8 *std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(_BYTE *a1, unsigned __int8 **a2, unsigned __int16 a3)
{
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  int v8;
  unsigned __int8 *v9;
  BOOL v10;
  int v11;
  char v12;
  int v13;
  unsigned __int8 *v14;
  _BOOL4 v16;
  char *v17;

  v3 = *a2;
  v4 = a2[1];
  v17 = (char *)v3;
  if (v3 == v4)
    return v3;
  v8 = std::__format_spec::__parser<char>::__parse_fill_align[abi:ne180100]<char const*>(a1, (unsigned __int8 **)&v17, v4, (a3 >> 6) & 1);
  v9 = (unsigned __int8 *)v17;
  if (v8)
    v10 = v17 == (char *)v4;
  else
    v10 = 0;
  if (!v10)
  {
    if ((a3 & 1) == 0)
      goto LABEL_14;
    v11 = *v17;
    switch(v11)
    {
      case ' ':
        v12 = *a1 | 0x18;
        break;
      case '+':
        v12 = *a1 & 0xE7 | 0x10;
        break;
      case '-':
        v12 = *a1 & 0xE7 | 8;
        break;
      default:
LABEL_14:
        if ((a3 & 2) == 0 || *v9 != 35 || (*a1 |= 0x20u, ++v9, v17 = (char *)v9, v9 != v4))
        {
          if ((a3 & 4) == 0 || *v9 != 48)
            goto LABEL_22;
          if ((*a1 & 7) == 0)
            *a1 = *a1 & 0xF8 | 4;
          v17 = (char *)(v9 + 1);
          if (v9 + 1 != v4)
          {
LABEL_22:
            v13 = std::__format_spec::__parser<char>::__parse_width[abi:ne180100]<char const*,std::basic_format_parse_context<char>>((uint64_t)a1, (unint64_t *)&v17, (char *)v4, (uint64_t)a2);
            v14 = (unsigned __int8 *)v17;
            if (!v13 || v17 != (char *)v4)
            {
              if ((a3 & 8) == 0
                || (v16 = std::__format_spec::__parser<char>::__parse_precision[abi:ne180100]<char const*,std::basic_format_parse_context<char>>((uint64_t)a1, &v17, (char *)v4, (uint64_t)a2), v14 = (unsigned __int8 *)v17, !v16)|| v17 != (char *)v4)
              {
                if ((a3 & 0x10) == 0 || *v14 != 76 || (*a1 |= 0x40u, ++v14, v17 = (char *)v14, v14 != v4))
                {
                  if ((a3 & 0x80) == 0 || *v14 != 110 || (*a1 |= 0x80u, v17 = (char *)(v14 + 1), v14 + 1 != v4))
                  {
                    if ((a3 & 0x20) != 0)
                      std::__format_spec::__parser<char>::__parse_type[abi:ne180100]<char const*>((uint64_t)a1, &v17);
                    v3 = (unsigned __int8 *)v17;
                    if ((a3 & 0x100) == 0)
                      return v3;
                    if (v17 != (char *)v4)
                    {
                      v4 = (unsigned __int8 *)v17;
                      if (*v17 != 125)
                        std::__throw_format_error[abi:ne180100]("The format specifier should consume the input or end with a '}'");
                    }
                  }
                }
              }
            }
          }
        }
        return v4;
    }
    *a1 = v12;
    v17 = (char *)++v9;
    if (v9 == v4)
      return v4;
    goto LABEL_14;
  }
  return v4;
}

uint64_t std::__format_spec::__process_parsed_BOOL[abi:ne180100]<char>(uint64_t result, const char *a2)
{
  unsigned int v2;
  _BYTE *v3;

  v2 = *(unsigned __int8 *)(result + 1);
  if (v2 - 2 >= 6)
  {
    if (v2 > 1)
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a2);
    v3 = (_BYTE *)result;
    result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, 48, a2, -1);
    if ((*v3 & 7) == 0)
      *v3 = *v3 & 0xF8 | 1;
  }
  return result;
}

uint64_t std::__format_spec::__parser<char>::__parse_fill_align[abi:ne180100]<char const*>(_BYTE *a1, unsigned __int8 **a2, unsigned __int8 *a3, int a4)
{
  unsigned __int8 *v8;
  int v9;
  char v10;
  int v11;
  char v12;
  unsigned __int8 *v13;
  unsigned __int8 *v15;
  size_t v16;
  unsigned __int8 *v17[2];

  v17[0] = *a2;
  v17[1] = a3;
  if ((std::__unicode::__code_point_view<char>::__consume[abi:ne180100](v17) & 0x80000000) != 0)
    std::__throw_format_error[abi:ne180100]("The format specifier contains malformed Unicode characters");
  v8 = v17[0];
  if (v17[0] >= a3)
    goto LABEL_7;
  v9 = (char)*v17[0];
  switch(v9)
  {
    case '<':
      v10 = 1;
      goto LABEL_17;
    case '>':
      v10 = 3;
LABEL_17:
      *a1 = *a1 & 0xF8 | v10;
      v15 = *a2;
      v16 = v8 - *a2;
      if (v16 == 1)
      {
        std::__format_spec::__parser<char>::__validate_fill_character[abi:ne180100]((uint64_t)a1, (char)*v15, a4);
        v15 = *a2;
      }
      else if (v8 == v15)
      {
LABEL_21:
        v13 = &v8[v16];
        goto LABEL_22;
      }
      memmove(a1 + 12, v15, v16);
      v8 = *a2;
      goto LABEL_21;
    case '^':
      v10 = 2;
      goto LABEL_17;
  }
LABEL_7:
  v11 = (char)**a2;
  switch(v11)
  {
    case '<':
      v12 = 1;
      break;
    case '>':
      v12 = 3;
      break;
    case '^':
      v12 = 2;
      break;
    default:
      return 0;
  }
  *a1 = *a1 & 0xF8 | v12;
  v13 = *a2;
LABEL_22:
  *a2 = v13 + 1;
  return 1;
}

uint64_t std::__format_spec::__parser<char>::__parse_width[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(uint64_t a1, unint64_t *a2, char *a3, uint64_t a4)
{
  unint64_t v6;
  int v7;
  char *v9;
  char *v10;
  int v11;

  v6 = *a2;
  v7 = *(unsigned __int8 *)*a2;
  if (v7 == 123)
  {
    v9 = (char *)(v6 + 1);
    *a2 = (unint64_t)v9;
    v10 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v9, a3, a4);
    *(_WORD *)(a1 + 2) |= 0x4000u;
  }
  else
  {
    if (v7 == 48)
      std::__throw_format_error[abi:ne180100]("The width option should not have a leading zero");
    if ((v7 - 58) < 0xFFFFFFF6)
      return 0;
    v10 = std::__format::__parse_number[abi:ne180100]<char const*>(v6, a3);
  }
  *(_DWORD *)(a1 + 4) = v11;
  *a2 = (unint64_t)v10;
  return 1;
}

BOOL std::__format_spec::__parser<char>::__parse_precision[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(uint64_t a1, char **a2, char *a3, uint64_t a4)
{
  char *v4;
  int v5;
  unsigned __int8 *v8;
  int v9;
  char *v10;
  int v11;
  int v12;

  v4 = *a2;
  v5 = **a2;
  if (v5 == 46)
  {
    v8 = (unsigned __int8 *)(v4 + 1);
    *a2 = v4 + 1;
    if (v4 + 1 == a3)
      std::__throw_format_error[abi:ne180100]("End of input while parsing format specifier precision");
    v9 = *v8;
    if (v9 == 123)
    {
      *a2 = v4 + 2;
      v10 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v4 + 2, a3, a4);
      *(_WORD *)(a1 + 2) |= 0x8000u;
      *(_DWORD *)(a1 + 8) = v11;
    }
    else
    {
      if ((v9 - 58) <= 0xFFFFFFF5)
        std::__throw_format_error[abi:ne180100]("The precision option does not contain a value or an argument index");
      v10 = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)v8, a3);
      *(_DWORD *)(a1 + 8) = v12;
      *(_WORD *)(a1 + 2) &= ~0x8000u;
    }
    *a2 = v10;
  }
  return v5 == 46;
}

uint64_t std::__format_spec::__parser<char>::__parse_type[abi:ne180100]<char const*>(uint64_t result, char **a2)
{
  _BYTE *v2;
  int v3;
  char v4;
  int v5;

  v2 = *a2;
  v3 = **a2;
  if (v3 <= 96)
  {
    v5 = v3 - 65;
    v4 = 12;
    switch(v5)
    {
      case 0:
        goto LABEL_19;
      case 1:
        v4 = 3;
        goto LABEL_19;
      case 4:
        v4 = 14;
        goto LABEL_19;
      case 5:
        v4 = 16;
        goto LABEL_19;
      case 6:
        v4 = 18;
LABEL_19:
        *(_BYTE *)(result + 1) = v4;
        *a2 = v2 + 1;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(**a2)
    {
      case 'a':
        v4 = 11;
        goto LABEL_19;
      case 'b':
        v4 = 2;
        goto LABEL_19;
      case 'c':
        v4 = 10;
        goto LABEL_19;
      case 'd':
        v4 = 5;
        goto LABEL_19;
      case 'e':
        v4 = 13;
        goto LABEL_19;
      case 'f':
        v4 = 15;
        goto LABEL_19;
      case 'g':
        v4 = 17;
        goto LABEL_19;
      case 'o':
        v4 = 4;
        goto LABEL_19;
      case 'p':
        v4 = 8;
        goto LABEL_19;
      case 's':
        v4 = 1;
        goto LABEL_19;
      case 'x':
        v4 = 6;
        goto LABEL_19;
      default:
        return result;
    }
  }
  return result;
}

uint64_t std::__unicode::__code_point_view<char>::__consume[abi:ne180100](unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  int v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  char v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;

  v1 = *a1;
  v2 = **a1;
  v3 = __clz(v2 ^ 0xFF) - 24;
  if (v2 == 255)
    v4 = 8;
  else
    v4 = v3;
  switch(v4)
  {
    case 0:
      *a1 = v1 + 1;
      v5 = *v1;
      break;
    case 2:
      if (a1[1] - v1 < 2 || (v1[1] & 0xC0) != 0x80)
        goto LABEL_35;
      *a1 = v1 + 1;
      v6 = *v1;
      *a1 = v1 + 2;
      v7 = v1[1] & 0x3F | ((v6 & 0x1F) << 6);
      if (v7 >= 0x80)
        v5 = v7;
      else
        v5 = 2147549181;
      break;
    case 3:
      if (a1[1] - v1 < 3)
        goto LABEL_35;
      v8 = 1;
      do
        v9 = v1[v8] & 0xC0;
      while (v9 == 128 && (_DWORD)v8++ != 2);
      if (v9 != 128)
        goto LABEL_35;
      v5 = 2147549181;
      *a1 = v1 + 1;
      v11 = *v1 & 0xF;
      *a1 = v1 + 2;
      v12 = (v11 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      v13 = v12 & 0xFFFFFFC0 | v1[2] & 0x3F;
      if (v13 >= 0x800)
      {
        if ((v12 & 0xF800) == 0xD800)
          v5 = 2147549181;
        else
          v5 = v13;
      }
      break;
    case 4:
      if (a1[1] - v1 < 4)
        goto LABEL_35;
      v14 = 1;
      do
        v15 = v1[v14] & 0xC0;
      while (v15 == 128 && (_DWORD)v14++ != 3);
      if (v15 != 128)
        goto LABEL_35;
      v5 = 2147549181;
      *a1 = v1 + 1;
      v17 = *v1 & 7;
      *a1 = v1 + 2;
      v18 = (v17 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      v19 = v18 & 0xFFFFFFC0 | v1[2] & 0x3F;
      *a1 = v1 + 4;
      v20 = v1[3] & 0x3F | (v19 << 6);
      if (v20 >= 0x10000)
      {
        if (v20 >= 0x110000)
          v5 = 2147549181;
        else
          v5 = v20;
      }
      break;
    default:
LABEL_35:
      v5 = 2147549181;
      *a1 = v1 + 1;
      break;
  }
  return v5;
}

void std::__format_spec::__parser<char>::__validate_fill_character[abi:ne180100](uint64_t a1, int a2, int a3)
{
  if (a3 && a2 == 58 || a2 == 125 || a2 == 123)
    std::__throw_format_error[abi:ne180100]("The fill option contains an invalid value");
}

char *std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *a1, char *a2, uint64_t a3)
{
  char *v4;

  if (a1 == a2)
    std::__throw_format_error[abi:ne180100]("End of input while parsing an argument index");
  v4 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, a3);
  if (v4 == a2 || *v4 != 125)
    std::__throw_format_error[abi:ne180100]("The argument index is invalid");
  return v4 + 1;
}

void std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](const char *a1)
{
  size_t v2;
  std::string *v3;
  __int128 v4;
  std::string *v5;
  __int128 v6;
  const char *v7;
  std::string v8;
  std::string v9;
  __int128 v10;
  int64_t v11;

  std::string::basic_string[abi:ne180100]<0>(&v8, "The type option contains an invalid value for ");
  v2 = strlen(a1);
  v3 = std::string::append(&v8, a1, v2);
  v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  v5 = std::string::append(&v9, " formatting argument", 0x14uLL);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v11 = v5->__r_.__value_.__r.__words[2];
  v10 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (v11 >= 0)
    v7 = (const char *)&v10;
  else
    v7 = (const char *)v10;
  std::__throw_format_error[abi:ne180100](v7);
}

void sub_2067FEDE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (*(char *)(v21 - 25) < 0)
    operator delete(*(void **)(v21 - 48));
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t std::__format_spec::__parser<char>::__validate[abi:ne180100](uint64_t result, char a2, const char *a3, int a4)
{
  unsigned int v4;
  int v5;
  const char *v6;

  if ((a2 & 1) == 0 && (*(_BYTE *)result & 0x18) != 0)
  {
    v6 = "sign";
    goto LABEL_23;
  }
  if ((a2 & 2) == 0 && (*(_BYTE *)result & 0x20) != 0)
  {
    v6 = "alternate form";
    goto LABEL_23;
  }
  if ((a2 & 4) == 0 && (*(_BYTE *)result & 7) == 4)
  {
    v6 = "zero-padding";
    goto LABEL_23;
  }
  if ((a2 & 8) == 0 && *(_DWORD *)(result + 8) != -1)
  {
    v6 = "precision";
    goto LABEL_23;
  }
  if ((a2 & 0x10) == 0 && (*(_BYTE *)result & 0x40) != 0)
  {
    v6 = "locale-specific form";
LABEL_23:
    std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](a3, v6);
  }
  v4 = *(unsigned __int8 *)(result + 1);
  if (*(_BYTE *)(result + 1))
  {
    if (v4 >= 0x20)
      std::__throw_format_error[abi:ne180100]("The type does not fit in the mask");
    v5 = 1 << v4;
  }
  else
  {
    v5 = 1;
  }
  if ((v5 & a4) == 0)
    std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a3);
  return result;
}

void std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](const char *a1, const char *a2)
{
  size_t v4;
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  size_t v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  const char *v14;
  std::string v15;
  std::string v16;
  std::string v17;
  std::string v18;
  __int128 v19;
  int64_t v20;

  std::string::basic_string[abi:ne180100]<0>(&v15, "The format specifier for ");
  v4 = strlen(a1);
  v5 = std::string::append(&v15, a1, v4);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  v7 = std::string::append(&v16, " does not allow the ", 0x14uLL);
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  v9 = strlen(a2);
  v10 = std::string::append(&v17, a2, v9);
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  v12 = std::string::append(&v18, " option", 7uLL);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v20 = v12->__r_.__value_.__r.__words[2];
  v19 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (v20 >= 0)
    v14 = (const char *)&v19;
  else
    v14 = (const char *)v19;
  std::__throw_format_error[abi:ne180100](v14);
}

void sub_2067FF00C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;

  if (*(char *)(v28 - 25) < 0)
    operator delete(*(void **)(v28 - 48));
  if (*(char *)(v28 - 57) < 0)
    operator delete(*(void **)(v28 - 80));
  if (a28 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__formatter::__format_BOOL[abi:ne180100]<char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(int a1, _QWORD **a2, uint64_t a3, uint64_t a4)
{
  size_t v8;
  char *v9;
  const std::locale::facet *v11;
  uint64_t v12;
  char *locale;
  size_t v14;
  _QWORD *v15;
  std::locale v16;
  size_t v17;
  unsigned __int8 v18;

  if ((a3 & 0x40) != 0)
  {
    std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v16);
    v11 = std::locale::use_facet(&v16, MEMORY[0x24BEDB588]);
    std::locale::~locale(&v16);
    v12 = 56;
    if (a1)
      v12 = 48;
    (*(void (**)(std::locale *__return_ptr, const std::locale::facet *))((char *)&v11->~facet + v12))(&v16, v11);
    if ((v18 & 0x80u) == 0)
      locale = (char *)&v16;
    else
      locale = (char *)v16.__locale_;
    if ((v18 & 0x80u) == 0)
      v14 = v18;
    else
      v14 = v17;
    v15 = std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(locale, v14, *a2, a3, a4);
    if ((char)v18 < 0)
      operator delete(v16.__locale_);
    return v15;
  }
  else
  {
    if (a1)
      v8 = 4;
    else
      v8 = 5;
    if (a1)
      v9 = "true";
    else
      v9 = "false";
    return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v8, *a2, a3, a4, v8);
  }
}

void sub_2067FF1A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, _QWORD *a2)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *a1;
  v5 = a1[1];
  std::__format_spec::__parser<char>::__get_width[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)a1, a2);
  v7 = v6;
  std::__format_spec::__parser<char>::__get_precision[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)a1, a2);
  return (v5 << 8) | (v7 << 32) | v4 & 0x7F;
}

void std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, __int16 a3)
{
  __asm { BR              X10 }
}

_QWORD *sub_2067FF270(unsigned int a1, _QWORD **a2, unint64_t a3, unint64_t a4, char a5)
{
  char v6;
  uint64_t v7;

  return std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, &v6, (uint64_t)&v7, 0, 0xAu);
}

std::locale *std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]@<X0>(uint64_t a1@<X0>, std::locale *a2@<X8>)
{
  std::locale *v3;
  std::locale v5;

  v3 = (std::locale *)(a1 + 32);
  if (!*(_BYTE *)(a1 + 40))
  {
    MEMORY[0x20BCFDD98](&v5);
    std::optional<std::locale>::operator=[abi:ne180100]<std::locale,void>(v3, &v5);
    std::locale::~locale(&v5);
  }
  return std::locale::locale(a2, v3);
}

void sub_2067FF3D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;

  if (a4 <= 0)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
    return a3;
  }
  else
  {
    v10 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, __len, HIDWORD(a4), 1);
    return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, __len, a3, a4, a5, v10);
  }
}

std::locale *std::optional<std::locale>::operator=[abi:ne180100]<std::locale,void>(std::locale *this, const std::locale *a2)
{
  if (LOBYTE(this[1].__locale_))
  {
    std::locale::operator=(this, a2);
  }
  else
  {
    std::locale::locale(this, a2);
    LOBYTE(this[1].__locale_) = 1;
  }
  return this;
}

uint64_t std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>(unsigned __int8 *a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  unsigned __int8 *v8;
  int v9;

  result = 0;
  if (a2 && a3)
  {
    if ((char)*a1 < 0)
    {
      v8 = a1;
    }
    else
    {
      v7 = 0;
      v8 = &a1[a3 - 1];
      while (1)
      {
        if (a2 - 1 == v7)
          return a2;
        if (a3 - 1 == v7)
          break;
        v9 = (char)a1[++v7];
        if (v9 < 0)
        {
          a3 = a3 - v7 + 1;
          v8 = &a1[v7 - 1];
          return v8
               - a1
               + std::__format_spec::__detail::__estimate_column_width_grapheme_clustering[abi:ne180100]<char const*>(v8, &a1[a2], a3, a4);
        }
      }
      if (((char)a1[a3] & 0x80000000) == 0)
        return a3;
      a3 = 1;
    }
    return v8
         - a1
         + std::__format_spec::__detail::__estimate_column_width_grapheme_clustering[abi:ne180100]<char const*>(v8, &a1[a2], a3, a4);
  }
  return result;
}

_QWORD *std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4 >> 32 > a6)
    __asm { BR              X10 }
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
  return a3;
}

void sub_2067FF600()
{
  JUMPOUT(0x2067FF608);
}

_QWORD *std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(_QWORD *result, char *__src, size_t __len)
{
  size_t v3;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  size_t v8;

  v3 = __len;
  v5 = result;
  v7 = result[1];
  v6 = result[2];
  if (v6 + __len >= v7)
  {
    result = (_QWORD *)((uint64_t (*)(_QWORD))result[3])(*result);
    v6 = 0;
    v5[2] = 0;
    v7 = v5[1];
  }
  if (v3 >= v7)
  {
    do
    {
      if (v5[1] >= v3)
        v8 = v3;
      else
        v8 = v5[1];
      if (v8)
        memmove((void *)(*v5 + v6), __src, v8);
      v5[2] = v8;
      __src += v8;
      v3 -= v8;
      result = (_QWORD *)((uint64_t (*)(_QWORD, size_t, _QWORD))v5[3])(*v5, v8, v5[4]);
      v6 = 0;
      v5[2] = 0;
    }
    while (v3);
  }
  else
  {
    if (v3)
    {
      result = memmove((void *)(*v5 + v6), __src, v3);
      v6 = v5[2];
    }
    v5[2] = v6 + v3;
  }
  return result;
}

uint64_t std::__format_spec::__detail::__estimate_column_width_grapheme_clustering[abi:ne180100]<char const*>(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, int a4)
{
  uint64_t v8;
  unsigned int v9;
  unsigned __int8 *v10;
  int v11;
  unint64_t v12;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned int v16;
  char v17;

  v14 = a1;
  v15 = a2;
  v16 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100](&v14) & 0x7FFFFFFF;
  v17 = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v16);
  if (a1 == a2)
    return 0;
  v8 = 0;
  do
  {
    v9 = v16;
    v10 = v14;
    if (v14 == v15)
      v17 = 15;
    else
      v10 = std::__unicode::__extended_grapheme_cluster_view<char>::__get_break[abi:ne180100]((uint64_t)&v14);
    v11 = std::__width_estimation_table::__estimated_width[abi:ne180100](v9);
    v12 = v8 + v11;
    if (!a4 && v12 > a3)
      break;
    if (v10 == a2)
    {
      v8 += v11;
      return v8;
    }
    v8 += v11;
  }
  while (v12 <= a3);
  return v8;
}

uint64_t std::__width_estimation_table::__estimated_width[abi:ne180100](unsigned int a1)
{
  uint64_t v1;
  unint64_t v2;
  unsigned int *v3;
  unint64_t v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;

  if (a1 - 262142 < 0xFFFC1102)
    return 1;
  v2 = 108;
  v3 = (unsigned int *)&std::__width_estimation_table::__entries;
  do
  {
    v4 = v2 >> 1;
    v5 = &v3[v2 >> 1];
    v7 = *v5;
    v6 = v5 + 1;
    v2 += ~(v2 >> 1);
    if (((a1 << 14) | 0x3FFF) < v7)
      v2 = v4;
    else
      v3 = v6;
  }
  while (v2);
  v1 = 1;
  if (v3 != (unsigned int *)&std::__width_estimation_table::__entries)
  {
    if ((*(v3 - 1) & 0x3FFF) + (*(v3 - 1) >> 14) < a1)
      return 1;
    else
      return 2;
  }
  return v1;
}

uint64_t std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](unsigned int a1)
{
  unint64_t v1;
  unsigned int *v2;
  unint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v1 = 1496;
  v2 = (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries;
  do
  {
    v3 = v1 >> 1;
    v4 = &v2[v1 >> 1];
    v6 = *v4;
    v5 = v4 + 1;
    v1 += ~(v1 >> 1);
    if (((a1 << 11) | 0x7FF) < v6)
      v1 = v3;
    else
      v2 = v5;
  }
  while (v1);
  v7 = 16;
  if (v2 != (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries)
  {
    v8 = *(v2 - 1);
    v9 = ((v8 >> 4) & 0x7F) + (v8 >> 11);
    v10 = v8 & 0xF;
    if (v9 >= a1)
      return v10;
    else
      return 16;
  }
  return v7;
}

unsigned __int8 *std::__unicode::__extended_grapheme_cluster_view<char>::__get_break[abi:ne180100](uint64_t a1)
{
  int v2;
  unsigned __int8 *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  char v8;

  v2 = 0;
  v8 = 1;
  while (1)
  {
    v3 = *(unsigned __int8 **)a1;
    if (*(_QWORD *)a1 == *(_QWORD *)(a1 + 8))
      break;
    v4 = *(unsigned __int8 *)(a1 + 20);
    v5 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100]((unsigned __int8 **)a1) & 0x7FFFFFFF;
    *(_DWORD *)(a1 + 16) = v5;
    v6 = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v5);
    *(_BYTE *)(a1 + 20) = v6;
    v2 |= v4 == 3;
    if (std::__unicode::__at_extended_grapheme_cluster_break[abi:ne180100](&v8, v2 & 1, v4, v6))
      return v3;
  }
  *(_BYTE *)(a1 + 20) = 15;
  return v3;
}

BOOL std::__unicode::__at_extended_grapheme_cluster_break[abi:ne180100](_BYTE *a1, int a2, unsigned int a3, unsigned int a4)
{
  _BOOL8 v4;
  BOOL v6;

  if (!a3 && a4 == 5)
    return 0;
  if (a3 > 5 || (v4 = 1, ((1 << a3) & 0x23) == 0))
  {
    if (a4 > 5 || (v4 = 1, ((1 << a4) & 0x23) == 0))
    {
      if (a3 == 12 || a3 == 6)
      {
        if ((a4 - 11) >= 2u)
          goto LABEL_16;
      }
      else if (a3 != 4 || a4 - 4 >= 9 || ((0x10Du >> (a4 - 4)) & 1) == 0)
      {
LABEL_16:
        v6 = a3 == 11 || a3 == 7;
        if (v6 && a4 == 11 || a4 <= 0xD && ((1 << a4) & 0x2404) != 0 || a3 == 8 || a3 == 13 && a2 && a4 == 3)
          return 0;
        v4 = 1;
        if (a3 == 9 && a4 == 9)
        {
          v4 = *a1 == 0;
          *a1 ^= 1u;
        }
        return v4;
      }
      return 0;
    }
  }
  return v4;
}

_QWORD *std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(_QWORD *a1, size_t __len, int a3)
{
  size_t v3;
  unsigned int v5;
  size_t v6;
  int __src;

  v3 = __len;
  v5 = __clz(~(_BYTE)a3) - 24;
  __src = a3;
  if ((_BYTE)a3 == 0xFF)
    v6 = 8;
  else
    v6 = v5;
  if ((_DWORD)v6)
  {
    if (__len)
    {
      do
      {
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, (char *)&__src, v6);
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, __len, (char)a3);
  }
  return a1;
}

_QWORD *std::__format::__output_buffer<char>::__fill[abi:ne180100](_QWORD *result, size_t __len, int __c)
{
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  size_t v9;

  v5 = (uint64_t)result;
  v7 = result[1];
  v6 = result[2];
  if (v6 + __len >= v7)
  {
    result = (_QWORD *)((uint64_t (*)(_QWORD))result[3])(*result);
    v6 = 0;
    *(_QWORD *)(v5 + 16) = 0;
    v7 = *(_QWORD *)(v5 + 8);
  }
  if (v7 <= __len)
  {
    do
    {
      v8 = *(_QWORD *)v5;
      if (*(_QWORD *)(v5 + 8) >= __len)
        v9 = __len;
      else
        v9 = *(_QWORD *)(v5 + 8);
      if (v9)
      {
        memset((void *)(v8 + v6), __c, v9);
        v8 = *(_QWORD *)v5;
      }
      *(_QWORD *)(v5 + 16) = v9;
      __len -= v9;
      result = (_QWORD *)(*(uint64_t (**)(uint64_t, size_t, _QWORD))(v5 + 24))(v8, v9, *(_QWORD *)(v5 + 32));
      v6 = 0;
      *(_QWORD *)(v5 + 16) = 0;
    }
    while (__len);
  }
  else
  {
    if (__len)
    {
      result = memset((void *)(*(_QWORD *)v5 + v6), __c, __len);
      v6 = *(_QWORD *)(v5 + 16);
    }
    *(_QWORD *)(v5 + 16) = v6 + __len;
  }
  return result;
}

void std::__format_spec::__parser<char>::__get_width[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  __int16 v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  _QWORD v11[2];
  _QWORD v12[2];
  char v13;
  _BYTE v14[31];

  *(_QWORD *)&v14[23] = *MEMORY[0x24BDAC8D0];
  v3 = *(_WORD *)(a1 + 2);
  v4 = *(_DWORD *)(a1 + 4);
  if ((v3 & 0x4000) != 0)
  {
    v5 = v4;
    v6 = a2[1];
    if (v6 <= v4)
    {
      LOBYTE(v8) = 0;
    }
    else if (v6 > 0xC)
    {
      v9 = a2[2] + 32 * v4;
      v2 = *(_QWORD *)v9;
      v5 = *(_QWORD *)(v9 + 8);
      LOBYTE(v8) = *(_BYTE *)(v9 + 16);
      v11[0] = *(_QWORD *)(v9 + 17);
      *(_QWORD *)((char *)v11 + 7) = *(_QWORD *)(v9 + 24);
    }
    else
    {
      v7 = a2[2];
      v8 = (a2[3] >> (5 * v4)) & 0x1FLL;
      v2 = *(_QWORD *)(v7 + 16 * v4);
      v5 = *(_QWORD *)(v7 + 16 * v4 + 8);
    }
    v12[0] = v2;
    v12[1] = v5;
    v13 = v8;
    *(_QWORD *)v14 = v11[0];
    *(_QWORD *)&v14[7] = *(_QWORD *)((char *)v11 + 7);
    std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v10, (uint64_t)v12);
  }
}

void std::__format_spec::__parser<char>::__get_precision[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  _QWORD v11[2];
  _QWORD v12[2];
  char v13;
  _BYTE v14[31];

  *(_QWORD *)&v14[23] = *MEMORY[0x24BDAC8D0];
  v3 = *(__int16 *)(a1 + 2);
  v4 = *(_DWORD *)(a1 + 8);
  if (v3 < 0)
  {
    v5 = v4;
    v6 = a2[1];
    if (v6 <= v4)
    {
      LOBYTE(v8) = 0;
    }
    else if (v6 > 0xC)
    {
      v9 = a2[2] + 32 * v4;
      v2 = *(_QWORD *)v9;
      v5 = *(_QWORD *)(v9 + 8);
      LOBYTE(v8) = *(_BYTE *)(v9 + 16);
      v11[0] = *(_QWORD *)(v9 + 17);
      *(_QWORD *)((char *)v11 + 7) = *(_QWORD *)(v9 + 24);
    }
    else
    {
      v7 = a2[2];
      v8 = (a2[3] >> (5 * v4)) & 0x1FLL;
      v2 = *(_QWORD *)(v7 + 16 * v4);
      v5 = *(_QWORD *)(v7 + 16 * v4 + 8);
    }
    v12[0] = v2;
    v12[1] = v5;
    v13 = v8;
    *(_QWORD *)v14 = v11[0];
    *(_QWORD *)&v14[7] = *(_QWORD *)((char *)v11 + 7);
    std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v10, (uint64_t)v12);
  }
}

void std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }
}

uint64_t sub_2067FFDBC(uint64_t a1, unsigned int *a2)
{
  uint64_t result;

  result = *a2;
  if ((result & 0x80000000) != 0)
    std::__throw_format_error[abi:ne180100]("An argument index may not have a negative value");
  return result;
}

void sub_2067FFE00()
{
  std::__throw_format_error[abi:ne180100]("Replacement argument isn't a standard signed or unsigned integer type");
}

void sub_2067FFE0C()
{
  std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
}

unint64_t std::invoke[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},long long &>(uint64_t a1, unint64_t *a2)
{
  unint64_t result;

  result = *a2;
  if ((*a2 & 0x8000000000000000) != 0)
    std::__throw_format_error[abi:ne180100]("An argument index may not have a negative value");
  if (result >> 31)
    std::__throw_format_error[abi:ne180100]("The value of the argument index exceeds its maximum value");
  return result;
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unsigned int a1, _QWORD **a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, _BYTE *a8, unsigned int a9)
{
  char *v9;
  char v13;
  char v14;
  int v15;
  _WORD *v16;
  char v17;
  unsigned __int8 *v18;
  int v19;
  char *v20;
  const std::locale::facet *v21;
  char *locale;
  _QWORD *v23;
  std::string::value_type *v24;
  char *v25;
  std::string::value_type v26;
  uint64_t v27;
  std::string::value_type *v28;
  std::string::value_type *v29;
  std::string::value_type *v30;
  int v31;
  BOOL v32;
  char v33;
  _QWORD *v34;
  unint64_t v35;
  unsigned __int8 v36;
  int v37;
  unsigned __int8 v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  std::string __p;
  std::locale v45;
  uint64_t v46;
  unsigned __int8 v47;

  v9 = a6;
  v13 = a3;
  if ((a5 & 1) != 0)
  {
    v14 = 45;
LABEL_7:
    *a6 = v14;
    v16 = a6 + 1;
    goto LABEL_8;
  }
  v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    v14 = 43;
    goto LABEL_7;
  }
  v16 = a6;
  if (v15 == 3)
  {
    v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      v17 = *a8;
      if (*a8)
      {
        v18 = a8 + 1;
        do
        {
          *(_BYTE *)v16 = v17;
          v16 = (_WORD *)((char *)v16 + 1);
          v19 = *v18++;
          v17 = v19;
        }
        while (v19);
      }
    }
  }
  v20 = std::__to_chars_integral[abi:ne180100]<unsigned int>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0)
    goto LABEL_44;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v45);
  v21 = std::locale::use_facet(&v45, MEMORY[0x24BEDB588]);
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (char *)v45.__locale_;
    if (!v46)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v47)
      goto LABEL_44;
    locale = (char *)&v45;
  }
  if (v20 - (char *)v16 <= *locale)
  {
    if ((v47 & 0x80) != 0)
    {
      locale = (char *)v45.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    v35 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v9, (char *)v16 - v9);
      v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9)
        v37 = (_DWORD)v16 - (_DWORD)v9;
      else
        v37 = HIDWORD(a3);
      v35 = (HIDWORD(a3) - v37);
      v38 = 48;
      v9 = (char *)v16;
    }
    else
    {
      v38 = BYTE4(a4);
      v36 = a3;
    }
    v39 = *a2;
    v40 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    v41 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700)
      return (_QWORD *)std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, (uint64_t)v39, v40, v41, (uint64_t (*)(_QWORD))std::__formatter::__hex_to_upper[abi:ne180100]);
    else
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, v39, v40, v41, v20 - v9);
  }
  v23 = *a2;
  memset(&__p, 0, sizeof(__p));
  if ((v47 & 0x80u) == 0)
    v24 = (std::string::value_type *)&v45;
  else
    v24 = (std::string::value_type *)v45.__locale_;
  if ((v47 & 0x80u) == 0)
    v25 = (char *)&v45 + v47;
  else
    v25 = (char *)v45.__locale_ + v46;
  v26 = *v24;
  v27 = v20 - (char *)v16 - *v24;
  if (v27 >= 1)
  {
    v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (v24 == v28)
      {
        v26 = *v28;
        v24 = v28;
      }
      else
      {
        v29 = v24 + 1;
        v30 = v24 + 1;
        do
        {
          v31 = *v30++;
          v26 = v31;
          if (v31)
            v32 = 1;
          else
            v32 = v29 == v28;
          v29 = v30;
        }
        while (!v32);
        v24 = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  v33 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v23, v9, (char *)v16, (int)v20, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v47 < 0)
    operator delete(v45.__locale_);
  return v34;
}

void sub_206800134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(_QWORD *a1, char *__src, char *a3, int a4, uint64_t *a5, char a6, unint64_t a7, unint64_t a8)
{
  __int16 v8;
  char *v11;
  unint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char *v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  size_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v29;

  v8 = a7;
  v11 = a3;
  v13 = HIDWORD(a7);
  LODWORD(v14) = *((unsigned __int8 *)a5 + 23);
  if ((v14 & 0x80u) != 0)
    v14 = a5[1];
  v15 = a4 - (_DWORD)__src - 1 + v14;
  v16 = a7 & 7;
  v29 = HIDWORD(a8);
  if ((_DWORD)v16 == 4)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, __src, a3 - __src);
    if ((int)v13 > v15)
      std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, (int)v13 - v15, 48);
  }
  else
  {
    if (SHIDWORD(a7) > v15)
      __asm { BR              X10 }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, __src, a3 - __src);
  }
  v17 = *((unsigned __int8 *)a5 + 23);
  v18 = (char)v17;
  v19 = (char *)a5 + v17;
  if (v18 >= 0)
    v20 = v19;
  else
    v20 = (char *)(*a5 + a5[1]);
  if (v18 >= 0)
    v21 = a5;
  else
    v21 = (uint64_t *)*a5;
  v22 = (char *)v21 + 1;
  while (1)
  {
    v24 = v20 - 1;
    v23 = *(v20 - 1);
    if ((v8 & 0xFF00) == 0x700)
    {
      v25 = &v11[v23];
      std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)a1, v11, &v11[v23], (uint64_t (*)(_QWORD))std::__formatter::__hex_to_upper[abi:ne180100]);
      v11 = v25;
    }
    else
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, v11, v23);
      v11 += *v24;
    }
    if (v20 == v22)
      break;
    v26 = *a1;
    v27 = a1[2];
    a1[2] = v27 + 1;
    *(_BYTE *)(v26 + v27) = a6;
    --v20;
    if (a1[2] == a1[1])
    {
      ((void (*)(_QWORD))a1[3])(*a1);
      a1[2] = 0;
      v20 = v24;
    }
  }
  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, 0, v29);
}

uint64_t std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(_QWORD))
{
  if (a4 >> 32 > a2 - a1)
    __asm { BR              X10 }
  std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>(a3, a1, a2, a6);
  return a3;
}

void sub_206800400()
{
  JUMPOUT(0x206800408);
}

uint64_t std::__formatter::__hex_to_upper[abi:ne180100](int a1)
{
  if ((a1 - 97) >= 6)
    return (char)a1;
  else
    return (char)(a1 - 32);
}

char *std::__to_chars_integral[abi:ne180100]<unsigned int>(_WORD *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  char *v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v10;
  int v11;
  char *v12;
  unsigned int v13;
  BOOL v14;

  v4 = (char *)a2;
  HIDWORD(v6) = a4;
  LODWORD(v6) = a4 - 2;
  v5 = v6 >> 1;
  if (v5 != 4)
  {
    if (!v5)
      return (char *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)a1, a2, a3);
    if (v5 == 3)
      return (char *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)a1, a2, a3);
    if (v5 != 7)
    {
      v10 = a2 - (_QWORD)a1;
      v11 = std::__to_chars_integral_width[abi:ne180100]<unsigned int>(a3, a4);
      if (v10 < v11)
        return (char *)a2;
      v4 = (char *)a1 + v11;
      v12 = v4 - 1;
      v13 = a3;
      do
      {
        *v12-- = a0123456789abcd[v13 % a4];
        v14 = v13 >= a4;
        v13 /= a4;
      }
      while (v14);
      return v4;
    }
    return (char *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)a1, a2, a3);
  }
  if (a2 - (uint64_t)a1 > 9)
    return (char *)std::__itoa::__base_10_u32[abi:ne180100](a1, a3);
  v7 = (1233 * (32 - __clz(a3 | 1))) >> 12;
  if (a2 - (uint64_t)a1 >= (((__PAIR64__(v7, a3) - std::__itoa::__pow10_32[v7]) >> 32) + 1))
    return (char *)std::__itoa::__base_10_u32[abi:ne180100](a1, a3);
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned int>(unsigned int a1, unsigned int a2)
{
  uint64_t result;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  if (a1 < a2)
    return 1;
  v3 = a1;
  v4 = a2 * a2;
  v5 = v4 * v4;
  result = 4;
  while (1)
  {
    if (v3 < v4)
      return (result - 2);
    if (v3 < a2 * a2 * a2)
      break;
    if (v3 < v5)
      return result;
    v3 /= v5;
    result = (result + 4);
    if (v3 < a2)
      return (result - 3);
  }
  return (result - 1);
}

_WORD *std::__itoa::__base_10_u32[abi:ne180100](_WORD *a1, unsigned int a2)
{
  unsigned int v3;
  unint64_t v4;
  unsigned __int16 v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned __int16 v10;

  if (a2 >= 0xF4240)
  {
    if (a2 >= 0x5F5E100)
    {
      if (a2 > 0x3B9AC9FF)
      {
        return std::__itoa::__append10[abi:ne180100]<unsigned int>(a1, a2);
      }
      else
      {
        *(_BYTE *)a1 = a2 / 0x5F5E100 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        v7 = a2 % 0x5F5E100 % 0xF4240;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v7 / 0x2710uLL];
        v7 %= 0x2710u;
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v7 / 0x64u];
        *(_WORD *)((char *)a1 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v7 % 0x64u];
        return (_WORD *)((char *)a1 + 9);
      }
    }
    else
    {
      v3 = a2 / 0xF4240;
      if (a2 > 0x98967F)
      {
        *a1 = std::__itoa::__digits_base_10[v3];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        v9 = a2 % 0xF4240 % 0x2710;
        a1[2] = std::__itoa::__digits_base_10[(unsigned __int16)v9 / 0x64u];
        a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v9 % 0x64u];
        return a1 + 4;
      }
      else
      {
        *(_BYTE *)a1 = v3 + 48;
        v4 = (429497 * (unint64_t)(a2 % 0xF4240)) >> 32;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[v4];
        v5 = a2 % 0xF4240 - 10000 * v4;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v5 / 0x64u];
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v5 % 0x64u];
        return (_WORD *)((char *)a1 + 7);
      }
    }
  }
  else if (a2 >> 4 > 0x270)
  {
    v6 = a2 / 0x2710;
    if (a2 >> 5 > 0xC34)
    {
      *a1 = std::__itoa::__digits_base_10[v6];
      v10 = a2 % 0x2710;
      a1[1] = std::__itoa::__digits_base_10[v10 / 0x64u];
      a1[2] = std::__itoa::__digits_base_10[v10 % 0x64u];
      return a1 + 3;
    }
    else
    {
      *(_BYTE *)a1 = v6 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(5243 * (a2 % 0x2710)) >> 19];
      *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[(unsigned __int16)(a2 % 0x2710
                                                                                  - 100
                                                                                  * ((unsigned __int16)((5243 * (a2 % 0x2710)) >> 16) >> 3))];
      return (_WORD *)((char *)a1 + 5);
    }
  }
  else if (a2 > 0x63)
  {
    v8 = (unsigned __int16)a2 / 0x64u;
    if (a2 > 0x3E7)
    {
      *a1 = std::__itoa::__digits_base_10[v8];
      a1[1] = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return a1 + 2;
    }
    else
    {
      *(_BYTE *)a1 = v8 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return (_WORD *)((char *)a1 + 3);
    }
  }
  else if (a2 > 9)
  {
    *a1 = std::__itoa::__digits_base_10[a2];
    return a1 + 1;
  }
  else
  {
    *(_BYTE *)a1 = a2 + 48;
    return (_WORD *)((char *)a1 + 1);
  }
}

_WORD *std::__itoa::__append10[abi:ne180100]<unsigned int>(_WORD *a1, unsigned int a2)
{
  unsigned int v2;

  *a1 = std::__itoa::__digits_base_10[a2 / 0x5F5E100uLL];
  a1[1] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240uLL];
  v2 = a2 % 0x5F5E100 % 0xF4240;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  _BYTE *v8;

  v3 = 32 - __clz(a3 | 1);
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x11)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  v8 = (_BYTE *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  _BYTE *v7;
  BOOL v8;

  v3 = (86 * (34 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x41)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  _BYTE *v7;
  BOOL v8;

  v3 = (35 - __clz(a3 | 1)) >> 2;
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x101)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

uint64_t std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>(uint64_t result, char *a2, char *a3, uint64_t (*a4)(_QWORD))
{
  char *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  char *v17;
  unsigned int v18;

  v6 = a2;
  v7 = result;
  v8 = a3 - a2;
  v10 = *(_QWORD *)(result + 8);
  v9 = *(_QWORD *)(result + 16);
  if (v9 + v8 >= v10)
  {
    result = (*(uint64_t (**)(_QWORD))(result + 24))(*(_QWORD *)result);
    v9 = 0;
    *(_QWORD *)(v7 + 16) = 0;
    v10 = *(_QWORD *)(v7 + 8);
  }
  if (v8 >= v10)
  {
    do
    {
      v13 = *(_QWORD *)v7;
      if (*(_QWORD *)(v7 + 8) >= v8)
        v14 = v8;
      else
        v14 = *(_QWORD *)(v7 + 8);
      if (v14)
      {
        v15 = (_BYTE *)(v13 + v9);
        v16 = v14;
        v17 = v6;
        do
        {
          v18 = *v17++;
          *v15++ = a4(v18);
          --v16;
        }
        while (v16);
        v13 = *(_QWORD *)v7;
      }
      v6 += v14;
      *(_QWORD *)(v7 + 16) = v14;
      v8 -= v14;
      result = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(v7 + 24))(v13, v14, *(_QWORD *)(v7 + 32));
      v9 = 0;
      *(_QWORD *)(v7 + 16) = 0;
    }
    while (v8);
  }
  else
  {
    if (v6 != a3)
    {
      v11 = (_BYTE *)(*(_QWORD *)v7 + v9);
      do
      {
        v12 = *v6++;
        result = a4(v12);
        *v11++ = result;
      }
      while (v6 != a3);
      v9 = *(_QWORD *)(v7 + 16);
    }
    *(_QWORD *)(v7 + 16) = v9 + v8;
  }
  return result;
}

void std::__formatter_char<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, unsigned __int8 a2, _QWORD *a3)
{
  int v5;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  unsigned __int8 __src;

  v5 = *(unsigned __int8 *)(a1 + 1);
  if (v5 == 10 || v5 == 0)
  {
    v7 = (_QWORD *)*a3;
    v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    __src = a2;
    std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((char *)&__src, 1uLL, v7, v8, v9, 1);
  }
  else
  {
    v10 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (uint64_t)a3, v10);
  }
}

uint64_t std::__format_spec::__process_parsed_char[abi:ne180100]<char>(uint64_t result, const char *a2)
{
  unsigned int v2;
  BOOL v3;
  int v4;
  _BYTE *v6;

  v2 = *(unsigned __int8 *)(result + 1);
  if (v2 - 2 >= 6)
  {
    v3 = v2 > 0x13;
    v4 = (1 << v2) & 0x80401;
    if (v3 || v4 == 0)
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a2);
    v6 = (_BYTE *)result;
    result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, 48, a2, -1);
    if ((*v6 & 7) == 0)
      *v6 = *v6 & 0xF8 | 1;
  }
  return result;
}

void std::__formatter_integer<char>::format[abi:ne180100]<int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, int a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  if ((v6 & 0xFF00) == 0xA00)
  {
    std::__formatter::__format_char[abi:ne180100]<char,int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, (_QWORD *)*a3, v6, v5);
  }
  else
  {
    if (a2 >= 0)
      v7 = a2;
    else
      v7 = -a2;
    std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, (uint64_t)a3, v6);
  }
}

uint64_t std::__format_spec::__process_parsed_integer[abi:ne180100]<char>(uint64_t result, const char *a2)
{
  int v2;
  _BYTE *v4;

  v2 = *(unsigned __int8 *)(result + 1);
  if ((v2 - 2) >= 6 && v2 != 0)
  {
    if (v2 != 10)
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a2);
    v4 = (_BYTE *)result;
    result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, 48, a2, -1);
    if ((*v4 & 7) == 0)
      *v4 = *v4 & 0xF8 | 1;
  }
  return result;
}

_QWORD *std::__formatter::__format_char[abi:ne180100]<char,int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(int a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  char __src;

  if (a1 != (char)a1)
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void std::__formatter_integer<char>::format[abi:ne180100]<long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  if ((v6 & 0xFF00) == 0xA00)
  {
    std::__formatter::__format_char[abi:ne180100]<char,long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, (_QWORD *)*a3, v6, v5);
  }
  else
  {
    if (a2 >= 0)
      v7 = a2;
    else
      v7 = -a2;
    std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, (uint64_t)a3, v6);
  }
}

_QWORD *std::__formatter::__format_char[abi:ne180100]<char,long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  char __src;

  if (a1 != (char)a1)
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, __int16 a3)
{
  __asm { BR              X10 }
}

_QWORD *sub_206800FB0(unint64_t a1, _QWORD **a2, unint64_t a3, unint64_t a4, char a5)
{
  char v6;
  _BYTE v7[6];

  return std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, &v6, (uint64_t)v7, 0, 10);
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, _QWORD **a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, _BYTE *a8, signed int a9)
{
  char *v9;
  char v13;
  char v14;
  int v15;
  _WORD *v16;
  char v17;
  unsigned __int8 *v18;
  int v19;
  char *v20;
  const std::locale::facet *v21;
  char *locale;
  _QWORD *v23;
  std::string::value_type *v24;
  char *v25;
  std::string::value_type v26;
  uint64_t v27;
  std::string::value_type *v28;
  std::string::value_type *v29;
  std::string::value_type *v30;
  int v31;
  BOOL v32;
  char v33;
  _QWORD *v34;
  unint64_t v35;
  unsigned __int8 v36;
  int v37;
  unsigned __int8 v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  std::string __p;
  std::locale v45;
  uint64_t v46;
  unsigned __int8 v47;

  v9 = a6;
  v13 = a3;
  if ((a5 & 1) != 0)
  {
    v14 = 45;
LABEL_7:
    *a6 = v14;
    v16 = a6 + 1;
    goto LABEL_8;
  }
  v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    v14 = 43;
    goto LABEL_7;
  }
  v16 = a6;
  if (v15 == 3)
  {
    v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      v17 = *a8;
      if (*a8)
      {
        v18 = a8 + 1;
        do
        {
          *(_BYTE *)v16 = v17;
          v16 = (_WORD *)((char *)v16 + 1);
          v19 = *v18++;
          v17 = v19;
        }
        while (v19);
      }
    }
  }
  v20 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0)
    goto LABEL_44;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v45);
  v21 = std::locale::use_facet(&v45, MEMORY[0x24BEDB588]);
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (char *)v45.__locale_;
    if (!v46)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v47)
      goto LABEL_44;
    locale = (char *)&v45;
  }
  if (v20 - (char *)v16 <= *locale)
  {
    if ((v47 & 0x80) != 0)
    {
      locale = (char *)v45.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    v35 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v9, (char *)v16 - v9);
      v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9)
        v37 = (_DWORD)v16 - (_DWORD)v9;
      else
        v37 = HIDWORD(a3);
      v35 = (HIDWORD(a3) - v37);
      v38 = 48;
      v9 = (char *)v16;
    }
    else
    {
      v38 = BYTE4(a4);
      v36 = a3;
    }
    v39 = *a2;
    v40 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    v41 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700)
      return (_QWORD *)std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, (uint64_t)v39, v40, v41, (uint64_t (*)(_QWORD))std::__formatter::__hex_to_upper[abi:ne180100]);
    else
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, v39, v40, v41, v20 - v9);
  }
  v23 = *a2;
  memset(&__p, 0, sizeof(__p));
  if ((v47 & 0x80u) == 0)
    v24 = (std::string::value_type *)&v45;
  else
    v24 = (std::string::value_type *)v45.__locale_;
  if ((v47 & 0x80u) == 0)
    v25 = (char *)&v45 + v47;
  else
    v25 = (char *)v45.__locale_ + v46;
  v26 = *v24;
  v27 = v20 - (char *)v16 - *v24;
  if (v27 >= 1)
  {
    v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (v24 == v28)
      {
        v26 = *v28;
        v24 = v28;
      }
      else
      {
        v29 = v24 + 1;
        v30 = v24 + 1;
        do
        {
          v31 = *v30++;
          v26 = v31;
          if (v31)
            v32 = 1;
          else
            v32 = v29 == v28;
          v29 = v30;
        }
        while (!v32);
        v24 = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  v33 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v23, v9, (char *)v16, (int)v20, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v47 < 0)
    operator delete(v45.__locale_);
  return v34;
}

void sub_20680139C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  _Unwind_Resume(exception_object);
}

char *std::__to_chars_integral[abi:ne180100]<unsigned long long>(_WORD *a1, uint64_t a2, unint64_t a3, signed int a4)
{
  char *v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v10;
  int v11;
  char *v12;
  unint64_t v13;
  BOOL v14;

  v4 = (char *)a2;
  HIDWORD(v6) = a4;
  LODWORD(v6) = a4 - 2;
  v5 = v6 >> 1;
  if (v5 != 4)
  {
    if (!v5)
      return (char *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    if (v5 == 3)
      return (char *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    if (v5 != 7)
    {
      v10 = a2 - (_QWORD)a1;
      v11 = std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(a3, a4);
      if (v10 < v11)
        return (char *)a2;
      v4 = (char *)a1 + v11;
      v12 = v4 - 1;
      v13 = a3;
      do
      {
        *v12-- = a0123456789abcd[(v13 % a4)];
        v14 = v13 >= a4;
        v13 /= (unint64_t)a4;
      }
      while (v14);
      return v4;
    }
    return (char *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
  }
  if (a2 - (uint64_t)a1 > 19)
    return (char *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
  v7 = (1233 * (64 - __clz(a3 | 1))) >> 12;
  if (a2 - (uint64_t)a1 >= v7 - (std::__itoa::__pow10_64[v7] > a3) + 1)
    return (char *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(unint64_t a1, unsigned int a2)
{
  uint64_t result;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (a2 > a1)
    return 1;
  v3 = a1;
  v4 = a2 * a2;
  v5 = (v4 * v4);
  result = 4;
  while (1)
  {
    if (v3 < v4)
      return (result - 2);
    if (v3 < v4 * a2)
      break;
    if (v3 < v5)
      return result;
    v3 /= v5;
    result = (result + 4);
    if (v3 < a2)
      return (result - 3);
  }
  return (result - 1);
}

_WORD *std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](_WORD *a1, unint64_t a2)
{
  unint64_t v2;

  v2 = a2;
  if (!HIDWORD(a2))
    return std::__itoa::__base_10_u32[abi:ne180100](a1, a2);
  if (a2 > 0x2540BE3FFLL)
  {
    a1 = std::__itoa::__base_10_u32[abi:ne180100](a1, a2 / 0x2540BE400);
    v2 %= 0x2540BE400uLL;
  }
  return std::__itoa::__append10[abi:ne180100]<unsigned long long>(a1, v2);
}

_WORD *std::__itoa::__append10[abi:ne180100]<unsigned long long>(_WORD *a1, unint64_t a2)
{
  unsigned int v2;

  *a1 = std::__itoa::__digits_base_10[(a2 / 0x5F5E100)];
  v2 = a2 % 0x5F5E100;
  a1[1] = std::__itoa::__digits_base_10[v2 / 0xF4240uLL];
  v2 %= 0xF4240u;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  _BYTE *v8;

  v3 = 64 - __clz(a3 | 1);
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x11)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  v8 = (_BYTE *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  BOOL v8;

  v3 = (86 * (66 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3)
    return a2;
  v4 = a1 + v3;
  if (a3 < 0x41)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + v3;
    do
    {
      v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  BOOL v8;

  v3 = 67 - __clz(a3 | 1);
  if (a2 - a1 < (uint64_t)(v3 >> 2))
    return a2;
  v4 = a1 + (v3 >> 2);
  if (a3 < 0x101)
  {
    v6 = a3;
    v5 = v4;
  }
  else
  {
    v5 = a1 + (v3 >> 2);
    do
    {
      v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  v7 = (_BYTE *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

void std::__formatter_integer<char>::format[abi:ne180100]<__int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned __int128 v9;

  v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a4);
  if ((v8 & 0xFF00) == 0xA00)
  {
    std::__formatter::__format_char[abi:ne180100]<char,__int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, a3, (_QWORD *)*a4, v8, v7);
  }
  else
  {
    v9 = __PAIR128__(a3 ^ (unint64_t)(a3 >> 63), a2 ^ (a3 >> 63)) - __PAIR128__(a3 >> 63, a3 >> 63);
    std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v9, *((uint64_t *)&v9 + 1), (uint64_t)a4, v8);
  }
}

_QWORD *std::__formatter::__format_char[abi:ne180100]<char,__int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  char __src;

  if (__PAIR128__(-1, -257) >= __PAIR128__((unint64_t)(a1 >= 0x80) + a2 - 1, a1 - 128))
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a3, a4, a5, 1);
}

void std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  __asm { BR              X10 }
}

_QWORD *sub_2068019B8(unint64_t a1, unint64_t a2, _QWORD **a3, unint64_t a4, unint64_t a5, char a6)
{
  char v7;
  _BYTE v8[3];

  return std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, a6, &v7, (uint64_t)v8, 0, 10);
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, unint64_t a2, _QWORD **a3, unint64_t a4, unint64_t a5, char a6, char *a7, uint64_t a8, _BYTE *a9, signed int a10)
{
  char *v10;
  char v14;
  char v15;
  int v16;
  char *v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  char *v21;
  const std::locale::facet *v22;
  char *locale;
  _QWORD *v24;
  std::string::value_type *v25;
  char *v26;
  std::string::value_type v27;
  uint64_t v28;
  std::string::value_type *v29;
  std::string::value_type *v30;
  std::string::value_type *v31;
  int v32;
  BOOL v33;
  char v34;
  _QWORD *v35;
  unint64_t v36;
  unsigned __int8 v37;
  int v38;
  unsigned __int8 v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;
  std::string __p;
  std::locale v46;
  uint64_t v47;
  unsigned __int8 v48;

  v10 = a7;
  v14 = a4;
  if ((a6 & 1) != 0)
  {
    v15 = 45;
LABEL_7:
    *a7 = v15;
    v17 = a7 + 1;
    goto LABEL_8;
  }
  v16 = (a4 >> 3) & 3;
  if (v16 == 2)
  {
    v15 = 43;
    goto LABEL_7;
  }
  v17 = a7;
  if (v16 == 3)
  {
    v15 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a4 & 0x20) != 0)
  {
    if (a9)
    {
      v18 = *a9;
      if (*a9)
      {
        v19 = a9 + 1;
        do
        {
          *v17++ = v18;
          v20 = *v19++;
          v18 = v20;
        }
        while (v20);
      }
    }
  }
  v21 = (char *)std::__to_chars_integral[abi:ne180100]<unsigned __int128>(v17, a8, a1, a2, a10);
  if ((v14 & 0x40) == 0)
    goto LABEL_44;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a3, &v46);
  v22 = std::locale::use_facet(&v46, MEMORY[0x24BEDB588]);
  std::locale::~locale(&v46);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v22->__vftable[1].__on_zero_shared)(&v46, v22);
  if ((char)v48 < 0)
  {
    locale = (char *)v46.__locale_;
    if (!v47)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v48)
      goto LABEL_44;
    locale = (char *)&v46;
  }
  if (v21 - v17 <= *locale)
  {
    if ((v48 & 0x80) != 0)
    {
      locale = (char *)v46.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    v36 = HIDWORD(a4);
    if ((v14 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a3, v10, v17 - v10);
      v37 = a4 & 0xF8 | 3;
      if (SHIDWORD(a4) >= (int)v17 - (int)v10)
        v38 = (_DWORD)v17 - (_DWORD)v10;
      else
        v38 = HIDWORD(a4);
      v36 = (HIDWORD(a4) - v38);
      v39 = 48;
      v10 = v17;
    }
    else
    {
      v39 = BYTE4(a5);
      v37 = a4;
    }
    v40 = *a3;
    v41 = a4 & 0xFFFFFF00 | (v36 << 32) | v37;
    v42 = a5 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v39 << 32);
    if ((a4 & 0xFF00) == 0x700)
      return (_QWORD *)std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v21, (uint64_t)v40, v41, v42, (uint64_t (*)(_QWORD))std::__formatter::__hex_to_upper[abi:ne180100]);
    else
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v21 - v10, v40, v41, v42, v21 - v10);
  }
  v24 = *a3;
  memset(&__p, 0, sizeof(__p));
  if ((v48 & 0x80u) == 0)
    v25 = (std::string::value_type *)&v46;
  else
    v25 = (std::string::value_type *)v46.__locale_;
  if ((v48 & 0x80u) == 0)
    v26 = (char *)&v46 + v48;
  else
    v26 = (char *)v46.__locale_ + v47;
  v27 = *v25;
  v28 = v21 - v17 - *v25;
  if (v28 >= 1)
  {
    v29 = v26 - 1;
    do
    {
      std::string::push_back(&__p, v27);
      if (v25 == v29)
      {
        v27 = *v29;
        v25 = v29;
      }
      else
      {
        v30 = v25 + 1;
        v31 = v25 + 1;
        do
        {
          v32 = *v31++;
          v27 = v32;
          if (v32)
            v33 = 1;
          else
            v33 = v30 == v29;
          v30 = v31;
        }
        while (!v33);
        v25 = v31 - 1;
      }
      v28 -= v27;
    }
    while (v28 > 0);
  }
  std::string::push_back(&__p, v27 + v28);
  v34 = ((uint64_t (*)(const std::locale::facet *))v22->__vftable[1].~facet_0)(v22);
  v35 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v24, v10, v17, (int)v21, (uint64_t *)&__p, v34, a4, a5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v48 < 0)
    operator delete(v46.__locale_);
  return v35;
}

void sub_206801DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  _Unwind_Resume(exception_object);
}

_WORD *std::__to_chars_integral[abi:ne180100]<unsigned __int128>(_BYTE *a1, uint64_t a2, unint64_t a3, unint64_t a4, signed int a5)
{
  unint64_t v5;
  unint64_t v6;
  _BYTE *v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v13;
  uint64_t v18;
  int v19;
  _BYTE *v20;
  uint64_t v21;
  BOOL v22;
  unint64_t v23;

  v5 = a4;
  v6 = a3;
  v7 = (_BYTE *)a2;
  HIDWORD(v9) = a5;
  LODWORD(v9) = a5 - 2;
  v8 = v9 >> 1;
  if (v8 != 4)
  {
    if (!v8)
      return (_WORD *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)a1, a2, a3, a4);
    if (v8 == 3)
      return (_WORD *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)a1, a2, a3, a4);
    if (v8 != 7)
    {
      v18 = a2 - (_QWORD)a1;
      v19 = std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(a3, a4, a5);
      if (v18 >= v19)
      {
        v7 = &a1[v19];
        v20 = v7 - 1;
        do
        {
          v21 = __udivti3();
          v22 = __PAIR128__(v5, v6) >= a5;
          *v20-- = a0123456789abcd[(v6 - v21 * a5)];
          v6 = v21;
          v5 = v23;
        }
        while (v22);
      }
      return v7;
    }
    return (_WORD *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)a1, a2, a3, a4);
  }
  v10 = a2 - (_QWORD)a1;
  if (a4)
  {
    if (v10 > 38)
      return std::__itoa::__base_10_u128[abi:ne180100](a1, a3, a4);
    v11 = (1233 * (128 - __clz(a4))) >> 12;
    if (v10 >= v11 - (__PAIR128__(a4, a3) < std::__itoa::__pow10_128[v11]) + 1)
      return std::__itoa::__base_10_u128[abi:ne180100](a1, a3, a4);
  }
  else
  {
    if (v10 > 19)
      return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
    v13 = (1233 * (64 - __clz(a3 | 1))) >> 12;
    if (v10 >= v13 - (std::__itoa::__pow10_64[v13] > a3) + 1)
      return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
  }
  return v7;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  uint64_t v3;
  unsigned int v5;
  unsigned int v6;

  if (__PAIR128__(a2, a1) < a3)
    return 1;
  v5 = a3 * a3;
  v6 = a3 * a3 * a3;
  v3 = 4;
  while (1)
  {
    if (__PAIR128__(a2, a1) < v5)
      return (v3 - 2);
    if (__PAIR128__(a2, a1) < v6)
      break;
    if (__PAIR128__(a2, a1) < v5 * v5)
      return v3;
    a1 = __udivti3();
    v3 = (v3 + 4);
    if (__PAIR128__(a2, a1) < a3)
      return (v3 - 3);
  }
  return (v3 - 1);
}

_WORD *std::__itoa::__base_10_u128[abi:ne180100](_BYTE *a1, unint64_t a2, unint64_t a3)
{
  _WORD *v3;
  unint64_t v4;
  unint64_t v5;
  _WORD *v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t v9;
  _WORD *v10;
  _WORD *v11;
  unint64_t v12;
  unsigned int v13;

  v3 = a1;
  if (__PAIR128__(a3, a2) >= __PAIR128__(0x4B3B4CA85A86C47ALL, 0x98A224000000000))
  {
    *a1 = __udivti3() | 0x30;
    v7 = __udivti3();
    *((_BYTE *)v3 + 1) = v7 / 0x5F5E100 + 48;
    v3[1] = std::__itoa::__digits_base_10[v7 % 0x5F5E100 / 0xF4240];
    v8 = v7 % 0x5F5E100 % 0xF4240;
    v3[2] = std::__itoa::__digits_base_10[v8 / 0x2710uLL];
    v8 %= 0x2710u;
    v3[3] = std::__itoa::__digits_base_10[(unsigned __int16)v8 / 0x64u];
    v3[4] = std::__itoa::__digits_base_10[(unsigned __int16)v8 % 0x64u];
    v9 = __udivti3();
    v10 = v3 + 5;
LABEL_8:
    v6 = std::__itoa::__append10[abi:ne180100]<unsigned long long>(v10, v9);
    goto LABEL_9;
  }
  v4 = __udivti3();
  v5 = v4;
  if (HIDWORD(v4))
  {
    if (v4 > 0x2540BE3FFLL)
    {
      v3 = std::__itoa::__base_10_u32[abi:ne180100](v3, v4 / 0x2540BE400);
      v5 %= 0x2540BE400uLL;
    }
    v10 = v3;
    v9 = v5;
    goto LABEL_8;
  }
  v6 = std::__itoa::__base_10_u32[abi:ne180100](v3, v4);
LABEL_9:
  v11 = v6;
  v12 = __umodti3();
  *(_BYTE *)v11 = v12 / 0x2540BE400 / 0x5F5E100 + 48;
  v13 = v12 / 0x2540BE400 % 0x5F5E100;
  *(_WORD *)((char *)v11 + 1) = std::__itoa::__digits_base_10[v13 / 0xF4240];
  v13 %= 0xF4240u;
  *(_WORD *)((char *)v11 + 3) = std::__itoa::__digits_base_10[v13 / 0x2710uLL];
  v13 %= 0x2710u;
  *(_WORD *)((char *)v11 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v13 / 0x64u];
  *(_WORD *)((char *)v11 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v13 % 0x64u];
  return std::__itoa::__append10[abi:ne180100]<unsigned long long>((_WORD *)((char *)v11 + 9), v12 % 0x2540BE400);
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  BOOL v11;
  unint64_t v12;
  _BYTE *v13;
  unint64_t v14;
  __int128 v15;

  v4 = __clz(a3 | 1) | 0x40;
  v5 = __clz(a4);
  if (a4)
    v4 = v5;
  v6 = 128 - v4;
  if (a2 - a1 < v6)
    return a2;
  v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x11)
  {
    v9 = a3;
    v12 = a4;
    v8 = v7;
  }
  else
  {
    v8 = a1 + v6;
    do
    {
      *((_QWORD *)&v10 + 1) = a4;
      *(_QWORD *)&v10 = a3;
      v9 = v10 >> 4;
      v11 = a3 <= 0x10F;
      v12 = a4 >> 4;
      *(_DWORD *)(v8 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v8 -= 4;
      a3 = v9;
      a4 >>= 4;
    }
    while (!v11);
  }
  v13 = (_BYTE *)(v8 - 1);
  do
  {
    v14 = v9 & 1;
    v11 = v9 <= 1;
    *((_QWORD *)&v15 + 1) = v12;
    *(_QWORD *)&v15 = v9;
    v9 = v15 >> 1;
    v12 >>= 1;
    *v13-- = a01[v14];
  }
  while (!v11);
  return v7;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  _BYTE *v11;
  unint64_t v12;
  BOOL v13;
  __int128 v14;

  v4 = __clz(a3 | 1) | 0x40;
  v5 = __clz(a4);
  if (a4)
    v4 = v5;
  v6 = (-126 - v4) / 3u;
  if (a2 - a1 < v6)
    return a2;
  v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x41)
  {
    v9 = a3;
    v8 = v7;
  }
  else
  {
    v8 = a1 + v6;
    do
    {
      *((_QWORD *)&v10 + 1) = a4;
      *(_QWORD *)&v10 = a3;
      v9 = v10 >> 6;
      a4 >>= 6;
      *(_WORD *)(v8 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x40);
  }
  v11 = (_BYTE *)(v8 - 1);
  do
  {
    v12 = v9 & 7;
    v13 = v9 <= 7;
    *((_QWORD *)&v14 + 1) = a4;
    *(_QWORD *)&v14 = v9;
    v9 = v14 >> 3;
    a4 >>= 3;
    *v11-- = a01234567[v12];
  }
  while (!v13);
  return v7;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  _BYTE *v11;
  unint64_t v12;
  BOOL v13;
  __int128 v14;

  v4 = __clz(a3 | 1) | 0x40;
  v5 = __clz(a4);
  if (a4)
    v4 = v5;
  v6 = 131 - v4;
  if (a2 - a1 < (uint64_t)(v6 >> 2))
    return a2;
  v7 = a1 + (v6 >> 2);
  if (__PAIR128__(a4, a3) < 0x101)
  {
    v9 = a3;
    v8 = v7;
  }
  else
  {
    v8 = a1 + (v6 >> 2);
    do
    {
      *((_QWORD *)&v10 + 1) = a4;
      *(_QWORD *)&v10 = a3;
      v9 = v10 >> 8;
      a4 >>= 8;
      *(_WORD *)(v8 - 2) = *(_WORD *)&std::__itoa::__base_16_lut[2 * a3];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x100);
  }
  v11 = (_BYTE *)(v8 - 1);
  do
  {
    v12 = v9 & 0xF;
    v13 = v9 <= 0xF;
    *((_QWORD *)&v14 + 1) = a4;
    *(_QWORD *)&v14 = v9;
    v9 = v14 >> 4;
    a4 >>= 4;
    *v11-- = a0123456789abcd_0[v12];
  }
  while (!v13);
  return v7;
}

void std::__formatter_integer<char>::format[abi:ne180100]<unsigned int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;

  v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  if ((v6 & 0xFF00) == 0xA00)
    std::__formatter::__format_char[abi:ne180100]<char,unsigned int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, (_QWORD *)*a3, v6, v5);
  else
    std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (uint64_t)a3, v6);
}

_QWORD *std::__formatter::__format_char[abi:ne180100]<char,unsigned int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unsigned int a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  char __src;

  if (a1 >= 0x80)
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void std::__formatter_integer<char>::format[abi:ne180100]<unsigned long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;

  v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  if ((v6 & 0xFF00) == 0xA00)
    std::__formatter::__format_char[abi:ne180100]<char,unsigned long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, (_QWORD *)*a3, v6, v5);
  else
    std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (uint64_t)a3, v6);
}

_QWORD *std::__formatter::__format_char[abi:ne180100]<char,unsigned long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  char __src;

  if (a1 >= 0x80)
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void std::__formatter_integer<char>::format[abi:ne180100]<unsigned __int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unint64_t a2, unint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;

  v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a4);
  if ((v8 & 0xFF00) == 0xA00)
    std::__formatter::__format_char[abi:ne180100]<char,unsigned __int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, a3, (_QWORD *)*a4, v8, v7);
  else
    std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, a3, (uint64_t)a4, v8);
}

_QWORD *std::__formatter::__format_char[abi:ne180100]<char,unsigned __int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unint64_t a1, unint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  char __src;

  if (__PAIR128__(a2, a1) >= 0x80)
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a3, a4, a5, 1);
}

_QWORD *std::__formatter::__format_floating_point[abi:ne180100]<float,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t **a1, uint64_t a2, unint64_t a3, float a4)
{
  int v7;
  unint64_t v8;
  int v9;
  _QWORD *v10;
  char *v11;
  char *v12;
  char v13;
  char v14;
  int v15;
  int v16;
  int v17;
  char *v18;
  char *v19;
  uint64_t v20;
  size_t v21;
  uint64_t *v22;
  unsigned __int8 v23;
  unsigned __int8 v24;
  uint64_t *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  uint64_t *v31;
  std::locale v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  int v37;
  int v38;
  unint64_t v39;
  void *__p;
  _QWORD v41[33];

  v41[32] = *MEMORY[0x24BDAC8D0];
  v7 = LODWORD(a4) >> 31;
  if ((LODWORD(a4) & 0x7FFFFFFFu) >= 0x7F800000)
    return std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(*a1, a2, a3, a4 < 0.0, 0);
  v8 = (unint64_t)a2 >> 8;
  if ((_DWORD)a3 == -1)
    v9 = 149;
  else
    v9 = a3;
  v37 = v9;
  v38 = 0;
  if (v9 >= 150)
  {
    v37 = 149;
    v38 = v9 - 149;
    v39 = 194;
LABEL_9:
    v10 = v41;
    goto LABEL_10;
  }
  v39 = v9 + 45;
  if ((v9 + 45) < 0x101)
    goto LABEL_9;
  v10 = operator new(v9 + 45);
LABEL_10:
  __p = v10;
  std::__formatter::__format_buffer[abi:ne180100]<float,float>((uint64_t)&v37, v7, (a3 & 0x80000000) == 0, (a2 >> 3) & 3, v8);
  if ((a2 & 0x20) != 0)
  {
    v11 = v34;
    if (v34 == v36)
    {
      v36 = v34 + 1;
      *v34 = 46;
      v12 = v36 - 1;
      if (v35 != v36 - 1)
      {
        if (v35 + 1 == v12)
        {
          v14 = *v35;
          *v35 = *v12;
          *v12 = v14;
        }
        else
        {
          v13 = *(v36 - 1);
          memmove(v35 + 1, v35, v36 - 1 - v35);
          *v35 = v13;
        }
      }
      v11 = v35;
      v34 = v35++;
    }
    if ((BYTE1(a2) - 17) <= 1u)
    {
      if (a3 <= 1)
        v15 = 1;
      else
        v15 = a3;
      if ((a3 & 0x80000000) != 0)
        v15 = 6;
      if (v35 == v36)
        v16 = (_DWORD)v33 - (_DWORD)v11;
      else
        v16 = -1;
      v17 = v16 + v15;
      v18 = &v35[~(unint64_t)v11];
      if ((uint64_t)v18 < v17)
        v38 += v17 - (_DWORD)v18;
    }
  }
  if ((a2 & 0x40) != 0)
  {
    v25 = *a1;
    std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a1, &v32);
    v26 = std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,float,char>(v25, (uint64_t)&v37, &v33, &v32, a2, a3);
    std::locale::~locale(&v32);
  }
  else
  {
    v19 = (char *)__p;
    v20 = v36 - (_BYTE *)__p;
    v21 = v38;
    if (v36 - (_BYTE *)__p + v38 >= a2 >> 32)
    {
      if (!v38 || v35 == v36)
      {
        v26 = *a1;
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v36 - (_BYTE *)__p);
        std::__format::__output_buffer<char>::__fill[abi:ne180100](v26, v21, 48);
      }
      else
      {
        v26 = *a1;
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v35 - (_BYTE *)__p);
        std::__format::__output_buffer<char>::__fill[abi:ne180100](v26, v21, 48);
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v26, v35, v36 - v35);
      }
    }
    else
    {
      v22 = *a1;
      if ((a2 & 7) == 4)
      {
        if (__p != v33)
        {
          v31 = v22;
          std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v31, (char *)__p);
          ++v19;
        }
        v23 = a2 & 0xF8 | 3;
        v24 = 48;
      }
      else
      {
        v24 = BYTE4(a3);
        v23 = a2;
      }
      v27 = a2 & 0xFFFFFFFFFFFFFF00 | v23;
      v28 = a3 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v24 << 32);
      if ((_DWORD)v21)
        std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)v19, (uint64_t)v36, (uint64_t)v22, v27);
      else
        v29 = std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v19, v36 - v19, v22, v27, v28, v20);
      v26 = v29;
    }
  }
  if (v39 >= 0x101)
    operator delete(__p);
  return v26;
}

void sub_206802B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16, void *__p)
{
  if (a16 >= 0x101)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(_QWORD *a1, uint64_t a2, uint64_t a3, char a4, int a5)
{
  char v5;
  int v6;
  char *p_src;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unsigned __int8 v11;
  char __src;
  _BYTE v14[3];

  if ((a4 & 1) != 0)
  {
    v5 = 45;
  }
  else
  {
    v6 = (a2 >> 3) & 3;
    if (v6 == 2)
    {
      v5 = 43;
    }
    else
    {
      if (v6 != 3)
      {
        p_src = &__src;
        goto LABEL_8;
      }
      v5 = 32;
    }
  }
  p_src = v14;
  __src = v5;
LABEL_8:
  if (BYTE1(a2) <= 0x10u && ((1 << SBYTE1(a2)) & 0x15000) != 0)
  {
    v8 = 6;
  }
  else
  {
    v8 = 6;
    if (BYTE1(a2) != 18)
      v8 = 0;
  }
  v9 = 3;
  if (!a5)
    v9 = 0;
  v10 = &aInfnaninfnan[v8 + v9];
  *(_WORD *)p_src = *(_WORD *)v10;
  p_src[2] = v10[2];
  if ((a2 & 7) == 4)
    v11 = a2 & 0xF8 | 3;
  else
    v11 = a2;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, p_src - &__src + 3, a1, a2 & 0xFFFFFFFFFFFFFF00 | v11, a3, p_src - &__src + 3);
}

void std::__formatter::__format_buffer[abi:ne180100]<float,float>(uint64_t a1, char a2, uint64_t a3, int a4, int a5)
{
  char v5;

  if ((a2 & 1) != 0)
  {
    v5 = 45;
  }
  else if (a4 == 2)
  {
    v5 = 43;
  }
  else
  {
    if (a4 != 3)
      goto LABEL_8;
    v5 = 32;
  }
  **(_BYTE **)(a1 + 16) = v5;
LABEL_8:
  __asm { BR              X11 }
}

uint64_t sub_206802D1C(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;
  int v6;

  v4 = *a1;
  *v3 = a3;
  result = MEMORY[0x20BCFDE1C](a3, *((_QWORD *)a1 + 2) + *((_QWORD *)a1 + 1), 2, v4);
  v3[2] = result;
  v3[3] = result;
  if ((_DWORD)v4)
    v6 = v4 + 1;
  else
    v6 = 0;
  v3[1] = result - v6;
  return result;
}

uint64_t sub_206802DC8(int *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  _QWORD *v4;
  int v5;

  if (v3)
    v5 = *a1;
  else
    v5 = -1;
  return std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<float,float>((uint64_t)a1, v5, a3, v4);
}

uint64_t sub_206802DE4(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  return std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>((uint64_t)a1, *a1, a3, v3);
}

_QWORD *std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,float,char>(_QWORD *a1, uint64_t a2, char **a3, std::locale *this, uint64_t a5, unint64_t a6)
{
  const std::locale::facet *v11;
  char *v12;
  char *v13;
  std::string *p_p;
  std::string::size_type size;
  std::string::size_type v16;
  char *v17;
  std::string::value_type v18;
  uint64_t v19;
  std::string::value_type *v20;
  std::string::value_type *v21;
  std::string::value_type *v22;
  int v23;
  BOOL v24;
  unint64_t v25;
  char *v26;
  std::string::size_type v27;
  int v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  char *v32;
  std::string::size_type v33;
  char *v34;
  std::string *v35;
  char *v36;
  char v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  _QWORD *v46;
  int64_t __len;
  std::string v49;
  std::string __p;

  v11 = std::locale::use_facet(this, MEMORY[0x24BEDB588]);
  ((void (*)(std::string *__return_ptr))v11->__vftable[1].__on_zero_shared)(&__p);
  v12 = a3[2];
  v13 = *a3;
  if (v12 >= a3[1])
    v12 = a3[1];
  __len = v12 - v13;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if (!__p.__r_.__value_.__l.__size_)
      goto LABEL_29;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (__len <= *__p.__r_.__value_.__l.__data_)
    {
      *__p.__r_.__value_.__l.__data_ = 0;
      __p.__r_.__value_.__l.__size_ = 0;
      goto LABEL_29;
    }
    v16 = __p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((_BYTE *)&__p.__r_.__value_.__s + 23))
      goto LABEL_29;
    if (__len <= __p.__r_.__value_.__s.__data_[0])
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_29;
    }
    p_p = &__p;
    size = __p.__r_.__value_.__l.__size_;
    v16 = __p.__r_.__value_.__r.__words[0];
  }
  memset(&v49, 0, sizeof(v49));
  v17 = (char *)(v16 + size);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = (char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v18 = p_p->__r_.__value_.__s.__data_[0];
  v19 = __len - p_p->__r_.__value_.__s.__data_[0];
  if (v19 >= 1)
  {
    v20 = v17 - 1;
    do
    {
      std::string::push_back(&v49, v18);
      if (p_p == (std::string *)v20)
      {
        v18 = *v20;
        p_p = (std::string *)v20;
      }
      else
      {
        v21 = &p_p->__r_.__value_.__s.__data_[1];
        v22 = &p_p->__r_.__value_.__s.__data_[1];
        do
        {
          v23 = *v22++;
          v18 = v23;
          if (v23)
            v24 = 1;
          else
            v24 = v21 == v20;
          v21 = v22;
        }
        while (!v24);
        p_p = (std::string *)(v22 - 1);
      }
      v19 -= v18;
    }
    while (v19 > 0);
  }
  std::string::push_back(&v49, v18 + v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  __p = v49;
LABEL_29:
  v25 = HIDWORD(a6);
  v26 = *(char **)(a2 + 16);
  v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v27 = __p.__r_.__value_.__l.__size_;
  v28 = a5 & 7;
  if (a5 >> 32 > (uint64_t)(a3[3] - v26 + *(int *)(a2 + 4) + v27 - (v27 != 0)))
  {
    if (v28 == 4)
      v29 = 3;
    else
      v29 = a5 & 7;
    __asm { BR              X11 }
  }
  if (v28 == 4 && v13 != v26)
  {
    v49.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v49, v26);
  }
  v30 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, 0, v25);
  v31 = v30;
  if (v28 != 4)
  {
    v32 = *(char **)(a2 + 16);
    if (v13 != v32)
    {
      v49.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v49, v32);
    }
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (*((_BYTE *)&__p.__r_.__value_.__s + 23))
    {
      v34 = &__p.__r_.__value_.__s.__data_[1];
      v35 = &__p;
      goto LABEL_47;
    }
LABEL_51:
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, v13, __len);
    goto LABEL_52;
  }
  v33 = __p.__r_.__value_.__l.__size_;
  if (!__p.__r_.__value_.__l.__size_)
    goto LABEL_51;
  v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
  v34 = (char *)(__p.__r_.__value_.__r.__words[0] + 1);
LABEL_47:
  v36 = (char *)v35 + v33;
  v37 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet_0)(v11);
  while (1)
  {
    v38 = v36 - 1;
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, v13, *(v36 - 1));
    if (v36 == v34)
      break;
    v13 += *(v36 - 1);
    v39 = *v31;
    v40 = v31[2];
    v31[2] = v40 + 1;
    *(_BYTE *)(v39 + v40) = v37;
    --v36;
    if (v31[2] == v31[1])
    {
      ((void (*)(_QWORD))v31[3])(*v31);
      v31[2] = 0;
      v36 = v38;
    }
  }
LABEL_52:
  v41 = a3[1];
  if (v41 != a3[3])
  {
    v42 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet)(v11);
    v43 = *v31;
    v44 = v31[2];
    v31[2] = v44 + 1;
    *(_BYTE *)(v43 + v44) = v42;
    if (v31[2] == v31[1])
    {
      ((void (*)(_QWORD))v31[3])(*v31);
      v31[2] = 0;
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, a3[1] + 1, a3[2] - (a3[1] + 1));
    std::__format::__output_buffer<char>::__fill[abi:ne180100](v31, *(int *)(a2 + 4), 48);
    v41 = a3[3];
  }
  v45 = a3[2];
  if (v45 != v41)
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, v45, v41 - v45);
  v46 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v31, 0, v25);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v46;
}

void sub_206803224()
{
  JUMPOUT(0x206803038);
}

void sub_206803230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  __asm { BR              X10 }
}

_QWORD *sub_2068032EC(int a1, int a2, _QWORD *a3, int a4, unint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  char *v18;
  size_t v19;
  size_t v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  _QWORD *v24;

  v23 = HIDWORD(a5);
  v24 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v19, SHIDWORD(a5));
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v24, v22, v18 - v22);
  std::__format::__output_buffer<char>::__fill[abi:ne180100](v24, v20, 48);
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v24, v18, v21 - (_QWORD)v18);
  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v24, 0, v23);
}

_BYTE *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v6;
  _BYTE *result;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;

  *(_DWORD *)(a1 + 4) = 0;
  *a4 = a3;
  v6 = MEMORY[0x20BCFDE1C](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 3, a2);
  a4[3] = v6;
  result = (_BYTE *)(a3 + 1);
  if (a3 + 1 != v6)
  {
    v8 = v6 - (_QWORD)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a4[2] = v6;
    }
    else
    {
      v9 = 6;
      if (v8 < 6)
        v9 = v6 - (_QWORD)result;
      v10 = -v9;
      while (*(_BYTE *)(v6 + v10) != 101)
      {
        if (++v10 == -3)
          goto LABEL_8;
      }
      a4[2] = v6 + v10;
      if (v10)
      {
        if (*result == 46)
          v11 = (_BYTE *)(a3 + 1);
        else
          v11 = (_BYTE *)v6;
        goto LABEL_12;
      }
    }
    result = memchr(result, 46, v8);
    if (result)
      v11 = result;
    else
      v11 = (_BYTE *)v6;
LABEL_12:
    a4[1] = v11;
    return result;
  }
  a4[1] = v6;
  a4[2] = v6;
  return result;
}

_BYTE *std::__formatter::__format_buffer_default[abi:ne180100]<float,float>@<X0>(std::__1 *this@<X1>, uint64_t a2@<X0>, char *a3@<X2>, _QWORD *a4@<X8>, float a5@<S0>)
{
  uint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  _BYTE *result;
  _BYTE *v13;

  *a4 = this;
  v7 = std::to_chars(this, (char *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)), a3, a5);
  v8 = (_BYTE *)v7;
  a4[3] = v7;
  v9 = v7 - (_QWORD)this;
  v10 = (_BYTE *)v7;
  if (v7 - (uint64_t)this >= 4)
  {
    if (v9 >= 6)
      v9 = 6;
    v11 = -(uint64_t)v9;
    while (*(_BYTE *)(v7 + v11) != 101)
    {
      if (++v11 == -3)
      {
        v10 = (_BYTE *)v7;
        goto LABEL_9;
      }
    }
    v10 = (_BYTE *)(v7 + v11);
  }
LABEL_9:
  a4[2] = v10;
  result = memchr((char *)this + 1, 46, v10 - ((char *)this + 1));
  if (result)
    v13 = result;
  else
    v13 = v10;
  if (v13 == v10)
    v13 = v8;
  a4[1] = v13;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  void *v10;

  *a4 = a3;
  if (a2 == -1)
    result = std::to_chars();
  else
    result = MEMORY[0x20BCFDE1C](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 4);
  a4[3] = result;
  v8 = *(unsigned __int8 *)(a3 + 1);
  v7 = a3 + 1;
  if (v8 == 46)
  {
    v9 = result - 2;
    v10 = memchr((void *)(result - 5), 112, 3uLL);
    result = v7;
    if (v10)
      v7 = (uint64_t)v10;
    else
      v7 = v9;
  }
  a4[1] = result;
  a4[2] = v7;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  _BYTE *v6;
  _BYTE *v7;
  int v8;

  result = std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>(a1, a2, a3, a4);
  v6 = (_BYTE *)*a4;
  v7 = (_BYTE *)a4[2];
  if ((_BYTE *)*a4 != v7)
  {
    do
    {
      v8 = (char)*v6;
      if ((v8 - 97) < 6)
        LOBYTE(v8) = v8 - 32;
      *v6++ = v8;
    }
    while (v6 != v7);
    v6 = (_BYTE *)a4[2];
  }
  *v6 = 80;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *a4 = a3;
  result = MEMORY[0x20BCFDE1C](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 1, a2);
  a4[3] = result;
  v7 = a3 + 1;
  if (*(_BYTE *)(a3 + 1) == 46)
  {
    a4[1] = v7;
    v8 = result - a3 - 2;
    v7 = result;
    if (v8 >= 4)
    {
      v9 = 6;
      if ((unint64_t)v8 < 6)
        v9 = result - a3 - 2;
      v10 = -v9;
      while (*(_BYTE *)(result + v10) != 101)
      {
        if (++v10 == -3)
        {
          v7 = result;
          goto LABEL_11;
        }
      }
      v7 = result + v10;
    }
  }
  else
  {
    a4[1] = result;
  }
LABEL_11:
  a4[2] = v7;
  return result;
}

_QWORD *std::__formatter::__format_floating_point[abi:ne180100]<double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t **a1, uint64_t a2, unint64_t a3, double a4)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  size_t v10;
  _QWORD *v11;
  char *v12;
  char *v13;
  char v14;
  char v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  char *v20;
  uint64_t v21;
  size_t v22;
  uint64_t *v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  uint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  uint64_t *v32;
  std::locale v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  int v38;
  int v39;
  unint64_t v40;
  void *__p;
  _QWORD v42[129];

  v42[128] = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)&a4 >> 63;
  if ((*(_QWORD *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    return std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(*a1, a2, a3, a4 < 0.0, 0);
  v8 = (unint64_t)a2 >> 8;
  if ((_DWORD)a3 == -1)
    v9 = 1074;
  else
    v9 = a3;
  v38 = v9;
  v39 = 0;
  if (v9 < 1075)
  {
    v10 = v9 + 316;
    v40 = v10;
    if ((v9 + 316) < 0x401)
    {
      v11 = v42;
      goto LABEL_10;
    }
  }
  else
  {
    v38 = 1074;
    v39 = v9 - 1074;
    v10 = 1390;
    v40 = 1390;
  }
  v11 = operator new(v10);
LABEL_10:
  __p = v11;
  std::__formatter::__format_buffer[abi:ne180100]<double,double>((uint64_t)&v38, v7, (a3 & 0x80000000) == 0, (a2 >> 3) & 3, v8);
  if ((a2 & 0x20) != 0)
  {
    v12 = v35;
    if (v35 == v37)
    {
      v37 = v35 + 1;
      *v35 = 46;
      v13 = v37 - 1;
      if (v36 != v37 - 1)
      {
        if (v36 + 1 == v13)
        {
          v15 = *v36;
          *v36 = *v13;
          *v13 = v15;
        }
        else
        {
          v14 = *(v37 - 1);
          memmove(v36 + 1, v36, v37 - 1 - v36);
          *v36 = v14;
        }
      }
      v12 = v36;
      v35 = v36++;
    }
    if ((BYTE1(a2) - 17) <= 1u)
    {
      if (a3 <= 1)
        v16 = 1;
      else
        v16 = a3;
      if ((a3 & 0x80000000) != 0)
        v16 = 6;
      if (v36 == v37)
        v17 = (_DWORD)v34 - (_DWORD)v12;
      else
        v17 = -1;
      v18 = v17 + v16;
      v19 = &v36[~(unint64_t)v12];
      if ((uint64_t)v19 < v18)
        v39 += v18 - (_DWORD)v19;
    }
  }
  if ((a2 & 0x40) != 0)
  {
    v26 = *a1;
    std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a1, &v33);
    v27 = std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(v26, (uint64_t)&v38, &v34, &v33, a2, a3);
    std::locale::~locale(&v33);
  }
  else
  {
    v20 = (char *)__p;
    v21 = v37 - (_BYTE *)__p;
    v22 = v39;
    if (v37 - (_BYTE *)__p + v39 >= a2 >> 32)
    {
      if (!v39 || v36 == v37)
      {
        v27 = *a1;
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v37 - (_BYTE *)__p);
        std::__format::__output_buffer<char>::__fill[abi:ne180100](v27, v22, 48);
      }
      else
      {
        v27 = *a1;
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v36 - (_BYTE *)__p);
        std::__format::__output_buffer<char>::__fill[abi:ne180100](v27, v22, 48);
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v27, v36, v37 - v36);
      }
    }
    else
    {
      v23 = *a1;
      if ((a2 & 7) == 4)
      {
        if (__p != v34)
        {
          v32 = v23;
          std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v32, (char *)__p);
          ++v20;
        }
        v24 = a2 & 0xF8 | 3;
        v25 = 48;
      }
      else
      {
        v25 = BYTE4(a3);
        v24 = a2;
      }
      v28 = a2 & 0xFFFFFFFFFFFFFF00 | v24;
      v29 = a3 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v25 << 32);
      if ((_DWORD)v22)
        std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)v20, (uint64_t)v37, (uint64_t)v23, v28);
      else
        v30 = std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v20, v37 - v20, v23, v28, v29, v21);
      v27 = v30;
    }
  }
  if (v40 >= 0x401)
    operator delete(__p);
  return v27;
}

void sub_206803A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16, void *__p)
{
  if (a16 >= 0x401)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__formatter::__format_buffer[abi:ne180100]<double,double>(uint64_t a1, char a2, uint64_t a3, int a4, int a5)
{
  char v5;

  if ((a2 & 1) != 0)
  {
    v5 = 45;
  }
  else if (a4 == 2)
  {
    v5 = 43;
  }
  else
  {
    if (a4 != 3)
      goto LABEL_8;
    v5 = 32;
  }
  **(_BYTE **)(a1 + 16) = v5;
LABEL_8:
  __asm { BR              X11 }
}

uint64_t sub_206803AD0(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;
  int v6;

  v4 = *a1;
  *v3 = a3;
  result = MEMORY[0x20BCFDDD4](a3, *((_QWORD *)a1 + 2) + *((_QWORD *)a1 + 1), 2, v4);
  v3[2] = result;
  v3[3] = result;
  if ((_DWORD)v4)
    v6 = v4 + 1;
  else
    v6 = 0;
  v3[1] = result - v6;
  return result;
}

uint64_t sub_206803B7C(int *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  _QWORD *v4;
  int v5;

  if (v3)
    v5 = *a1;
  else
    v5 = -1;
  return std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,double>((uint64_t)a1, v5, a3, v4);
}

uint64_t sub_206803B98(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  return std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>((uint64_t)a1, *a1, a3, v3);
}

_QWORD *std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(_QWORD *a1, uint64_t a2, char **a3, std::locale *this, uint64_t a5, unint64_t a6)
{
  const std::locale::facet *v11;
  char *v12;
  char *v13;
  std::string *p_p;
  std::string::size_type size;
  std::string::size_type v16;
  char *v17;
  std::string::value_type v18;
  uint64_t v19;
  std::string::value_type *v20;
  std::string::value_type *v21;
  std::string::value_type *v22;
  int v23;
  BOOL v24;
  unint64_t v25;
  char *v26;
  std::string::size_type v27;
  int v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  char *v32;
  std::string::size_type v33;
  char *v34;
  std::string *v35;
  char *v36;
  char v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  _QWORD *v46;
  int64_t __len;
  std::string v49;
  std::string __p;

  v11 = std::locale::use_facet(this, MEMORY[0x24BEDB588]);
  ((void (*)(std::string *__return_ptr))v11->__vftable[1].__on_zero_shared)(&__p);
  v12 = a3[2];
  v13 = *a3;
  if (v12 >= a3[1])
    v12 = a3[1];
  __len = v12 - v13;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    size = __p.__r_.__value_.__l.__size_;
    if (!__p.__r_.__value_.__l.__size_)
      goto LABEL_29;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (__len <= *__p.__r_.__value_.__l.__data_)
    {
      *__p.__r_.__value_.__l.__data_ = 0;
      __p.__r_.__value_.__l.__size_ = 0;
      goto LABEL_29;
    }
    v16 = __p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((_BYTE *)&__p.__r_.__value_.__s + 23))
      goto LABEL_29;
    if (__len <= __p.__r_.__value_.__s.__data_[0])
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_29;
    }
    p_p = &__p;
    size = __p.__r_.__value_.__l.__size_;
    v16 = __p.__r_.__value_.__r.__words[0];
  }
  memset(&v49, 0, sizeof(v49));
  v17 = (char *)(v16 + size);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = (char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]);
  v18 = p_p->__r_.__value_.__s.__data_[0];
  v19 = __len - p_p->__r_.__value_.__s.__data_[0];
  if (v19 >= 1)
  {
    v20 = v17 - 1;
    do
    {
      std::string::push_back(&v49, v18);
      if (p_p == (std::string *)v20)
      {
        v18 = *v20;
        p_p = (std::string *)v20;
      }
      else
      {
        v21 = &p_p->__r_.__value_.__s.__data_[1];
        v22 = &p_p->__r_.__value_.__s.__data_[1];
        do
        {
          v23 = *v22++;
          v18 = v23;
          if (v23)
            v24 = 1;
          else
            v24 = v21 == v20;
          v21 = v22;
        }
        while (!v24);
        p_p = (std::string *)(v22 - 1);
      }
      v19 -= v18;
    }
    while (v19 > 0);
  }
  std::string::push_back(&v49, v18 + v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  __p = v49;
LABEL_29:
  v25 = HIDWORD(a6);
  v26 = *(char **)(a2 + 16);
  v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v27 = __p.__r_.__value_.__l.__size_;
  v28 = a5 & 7;
  if (a5 >> 32 > (uint64_t)(a3[3] - v26 + *(int *)(a2 + 4) + v27 - (v27 != 0)))
  {
    if (v28 == 4)
      v29 = 3;
    else
      v29 = a5 & 7;
    __asm { BR              X11 }
  }
  if (v28 == 4 && v13 != v26)
  {
    v49.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v49, v26);
  }
  v30 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, 0, v25);
  v31 = v30;
  if (v28 != 4)
  {
    v32 = *(char **)(a2 + 16);
    if (v13 != v32)
    {
      v49.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v49, v32);
    }
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (*((_BYTE *)&__p.__r_.__value_.__s + 23))
    {
      v34 = &__p.__r_.__value_.__s.__data_[1];
      v35 = &__p;
      goto LABEL_47;
    }
LABEL_51:
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, v13, __len);
    goto LABEL_52;
  }
  v33 = __p.__r_.__value_.__l.__size_;
  if (!__p.__r_.__value_.__l.__size_)
    goto LABEL_51;
  v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
  v34 = (char *)(__p.__r_.__value_.__r.__words[0] + 1);
LABEL_47:
  v36 = (char *)v35 + v33;
  v37 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet_0)(v11);
  while (1)
  {
    v38 = v36 - 1;
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, v13, *(v36 - 1));
    if (v36 == v34)
      break;
    v13 += *(v36 - 1);
    v39 = *v31;
    v40 = v31[2];
    v31[2] = v40 + 1;
    *(_BYTE *)(v39 + v40) = v37;
    --v36;
    if (v31[2] == v31[1])
    {
      ((void (*)(_QWORD))v31[3])(*v31);
      v31[2] = 0;
      v36 = v38;
    }
  }
LABEL_52:
  v41 = a3[1];
  if (v41 != a3[3])
  {
    v42 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet)(v11);
    v43 = *v31;
    v44 = v31[2];
    v31[2] = v44 + 1;
    *(_BYTE *)(v43 + v44) = v42;
    if (v31[2] == v31[1])
    {
      ((void (*)(_QWORD))v31[3])(*v31);
      v31[2] = 0;
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, a3[1] + 1, a3[2] - (a3[1] + 1));
    std::__format::__output_buffer<char>::__fill[abi:ne180100](v31, *(int *)(a2 + 4), 48);
    v41 = a3[3];
  }
  v45 = a3[2];
  if (v45 != v41)
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v31, v45, v41 - v45);
  v46 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v31, 0, v25);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v46;
}

void sub_206803FD8()
{
  JUMPOUT(0x206803DECLL);
}

void sub_206803FE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_BYTE *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v6;
  _BYTE *result;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;

  *(_DWORD *)(a1 + 4) = 0;
  *a4 = a3;
  v6 = MEMORY[0x20BCFDDD4](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 3, a2);
  a4[3] = v6;
  result = (_BYTE *)(a3 + 1);
  if (a3 + 1 != v6)
  {
    v8 = v6 - (_QWORD)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a4[2] = v6;
    }
    else
    {
      v9 = 6;
      if (v8 < 6)
        v9 = v6 - (_QWORD)result;
      v10 = -v9;
      while (*(_BYTE *)(v6 + v10) != 101)
      {
        if (++v10 == -3)
          goto LABEL_8;
      }
      a4[2] = v6 + v10;
      if (v10)
      {
        if (*result == 46)
          v11 = (_BYTE *)(a3 + 1);
        else
          v11 = (_BYTE *)v6;
        goto LABEL_12;
      }
    }
    result = memchr(result, 46, v8);
    if (result)
      v11 = result;
    else
      v11 = (_BYTE *)v6;
LABEL_12:
    a4[1] = v11;
    return result;
  }
  a4[1] = v6;
  a4[2] = v6;
  return result;
}

_BYTE *std::__formatter::__format_buffer_default[abi:ne180100]<double,double>@<X0>(std::__1 *this@<X1>, uint64_t a2@<X0>, char *a3@<X2>, _QWORD *a4@<X8>, double a5@<D0>)
{
  uint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  _BYTE *result;
  _BYTE *v13;

  *a4 = this;
  v7 = std::to_chars(this, (char *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)), a3, a5);
  v8 = (_BYTE *)v7;
  a4[3] = v7;
  v9 = v7 - (_QWORD)this;
  v10 = (_BYTE *)v7;
  if (v7 - (uint64_t)this >= 4)
  {
    if (v9 >= 6)
      v9 = 6;
    v11 = -(uint64_t)v9;
    while (*(_BYTE *)(v7 + v11) != 101)
    {
      if (++v11 == -3)
      {
        v10 = (_BYTE *)v7;
        goto LABEL_9;
      }
    }
    v10 = (_BYTE *)(v7 + v11);
  }
LABEL_9:
  a4[2] = v10;
  result = memchr((char *)this + 1, 46, v10 - ((char *)this + 1));
  if (result)
    v13 = result;
  else
    v13 = v10;
  if (v13 == v10)
    v13 = v8;
  a4[1] = v13;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  void *v10;

  *a4 = a3;
  if (a2 == -1)
    result = std::to_chars();
  else
    result = MEMORY[0x20BCFDDD4](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 4);
  a4[3] = result;
  v8 = *(unsigned __int8 *)(a3 + 1);
  v7 = a3 + 1;
  if (v8 == 46)
  {
    v9 = result - 2;
    v10 = memchr((void *)(result - 6), 112, 4uLL);
    result = v7;
    if (v10)
      v7 = (uint64_t)v10;
    else
      v7 = v9;
  }
  a4[1] = result;
  a4[2] = v7;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  _BYTE *v6;
  _BYTE *v7;
  int v8;

  result = std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>(a1, a2, a3, a4);
  v6 = (_BYTE *)*a4;
  v7 = (_BYTE *)a4[2];
  if ((_BYTE *)*a4 != v7)
  {
    do
    {
      v8 = (char)*v6;
      if ((v8 - 97) < 6)
        LOBYTE(v8) = v8 - 32;
      *v6++ = v8;
    }
    while (v6 != v7);
    v6 = (_BYTE *)a4[2];
  }
  *v6 = 80;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *a4 = a3;
  result = MEMORY[0x20BCFDDD4](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 1, a2);
  a4[3] = result;
  v7 = a3 + 1;
  if (*(_BYTE *)(a3 + 1) == 46)
  {
    a4[1] = v7;
    v8 = result - a3 - 2;
    v7 = result;
    if (v8 >= 4)
    {
      v9 = 6;
      if ((unint64_t)v8 < 6)
        v9 = result - a3 - 2;
      v10 = -v9;
      while (*(_BYTE *)(result + v10) != 101)
      {
        if (++v10 == -3)
        {
          v7 = result;
          goto LABEL_11;
        }
      }
      v7 = result + v10;
    }
  }
  else
  {
    a4[1] = result;
  }
LABEL_11:
  a4[2] = v7;
  return result;
}

_QWORD *std::__formatter::__format_floating_point[abi:ne180100]<long double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t **a1, uint64_t a2, unint64_t a3, double a4)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  size_t v10;
  _QWORD *v11;
  char *v12;
  char *v13;
  char v14;
  char v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  char *v20;
  uint64_t v21;
  size_t v22;
  uint64_t *v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  uint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  uint64_t *v32;
  std::locale v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  int v38;
  int v39;
  unint64_t v40;
  void *__p;
  _QWORD v42[129];

  v42[128] = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)&a4 >> 63;
  if ((*(_QWORD *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
    return std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(*a1, a2, a3, a4 < 0.0, 0);
  v8 = (unint64_t)a2 >> 8;
  if ((_DWORD)a3 == -1)
    v9 = 1074;
  else
    v9 = a3;
  v38 = v9;
  v39 = 0;
  if (v9 < 1075)
  {
    v10 = v9 + 316;
    v40 = v10;
    if ((v9 + 316) < 0x401)
    {
      v11 = v42;
      goto LABEL_10;
    }
  }
  else
  {
    v38 = 1074;
    v39 = v9 - 1074;
    v10 = 1390;
    v40 = 1390;
  }
  v11 = operator new(v10);
LABEL_10:
  __p = v11;
  std::__formatter::__format_buffer[abi:ne180100]<double,long double>((uint64_t)&v38, v7, (a3 & 0x80000000) == 0, (a2 >> 3) & 3, v8);
  if ((a2 & 0x20) != 0)
  {
    v12 = v35;
    if (v35 == v37)
    {
      v37 = v35 + 1;
      *v35 = 46;
      v13 = v37 - 1;
      if (v36 != v37 - 1)
      {
        if (v36 + 1 == v13)
        {
          v15 = *v36;
          *v36 = *v13;
          *v13 = v15;
        }
        else
        {
          v14 = *(v37 - 1);
          memmove(v36 + 1, v36, v37 - 1 - v36);
          *v36 = v14;
        }
      }
      v12 = v36;
      v35 = v36++;
    }
    if ((BYTE1(a2) - 17) <= 1u)
    {
      if (a3 <= 1)
        v16 = 1;
      else
        v16 = a3;
      if ((a3 & 0x80000000) != 0)
        v16 = 6;
      if (v36 == v37)
        v17 = (_DWORD)v34 - (_DWORD)v12;
      else
        v17 = -1;
      v18 = v17 + v16;
      v19 = &v36[~(unint64_t)v12];
      if ((uint64_t)v19 < v18)
        v39 += v18 - (_DWORD)v19;
    }
  }
  if ((a2 & 0x40) != 0)
  {
    v26 = *a1;
    std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a1, &v33);
    v27 = std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(v26, (uint64_t)&v38, &v34, &v33, a2, a3);
    std::locale::~locale(&v33);
  }
  else
  {
    v20 = (char *)__p;
    v21 = v37 - (_BYTE *)__p;
    v22 = v39;
    if (v37 - (_BYTE *)__p + v39 >= a2 >> 32)
    {
      if (!v39 || v36 == v37)
      {
        v27 = *a1;
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v37 - (_BYTE *)__p);
        std::__format::__output_buffer<char>::__fill[abi:ne180100](v27, v22, 48);
      }
      else
      {
        v27 = *a1;
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v36 - (_BYTE *)__p);
        std::__format::__output_buffer<char>::__fill[abi:ne180100](v27, v22, 48);
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v27, v36, v37 - v36);
      }
    }
    else
    {
      v23 = *a1;
      if ((a2 & 7) == 4)
      {
        if (__p != v34)
        {
          v32 = v23;
          std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v32, (char *)__p);
          ++v20;
        }
        v24 = a2 & 0xF8 | 3;
        v25 = 48;
      }
      else
      {
        v25 = BYTE4(a3);
        v24 = a2;
      }
      v28 = a2 & 0xFFFFFFFFFFFFFF00 | v24;
      v29 = a3 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v25 << 32);
      if ((_DWORD)v22)
        std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)v20, (uint64_t)v37, (uint64_t)v23, v28);
      else
        v30 = std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v20, v37 - v20, v23, v28, v29, v21);
      v27 = v30;
    }
  }
  if (v40 >= 0x401)
    operator delete(__p);
  return v27;
}

void sub_20680471C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16, void *__p)
{
  if (a16 >= 0x401)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::__formatter::__format_buffer[abi:ne180100]<double,long double>(uint64_t a1, char a2, uint64_t a3, int a4, int a5)
{
  char v5;

  if ((a2 & 1) != 0)
  {
    v5 = 45;
  }
  else if (a4 == 2)
  {
    v5 = 43;
  }
  else
  {
    if (a4 != 3)
      goto LABEL_8;
    v5 = 32;
  }
  **(_BYTE **)(a1 + 16) = v5;
LABEL_8:
  __asm { BR              X11 }
}

uint64_t sub_2068047B8(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;
  int v6;

  v4 = *a1;
  *v3 = a3;
  result = MEMORY[0x20BCFDDF8](a3, *((_QWORD *)a1 + 2) + *((_QWORD *)a1 + 1), 2, v4);
  v3[2] = result;
  v3[3] = result;
  if ((_DWORD)v4)
    v6 = v4 + 1;
  else
    v6 = 0;
  v3[1] = result - v6;
  return result;
}

uint64_t sub_206804864(int *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  _QWORD *v4;
  int v5;

  if (v3)
    v5 = *a1;
  else
    v5 = -1;
  return std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,long double>((uint64_t)a1, v5, a3, v4);
}

uint64_t sub_206804880(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  return std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>((uint64_t)a1, *a1, a3, v3);
}

_BYTE *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v6;
  _BYTE *result;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;

  *(_DWORD *)(a1 + 4) = 0;
  *a4 = a3;
  v6 = MEMORY[0x20BCFDDF8](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 3, a2);
  a4[3] = v6;
  result = (_BYTE *)(a3 + 1);
  if (a3 + 1 != v6)
  {
    v8 = v6 - (_QWORD)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a4[2] = v6;
    }
    else
    {
      v9 = 6;
      if (v8 < 6)
        v9 = v6 - (_QWORD)result;
      v10 = -v9;
      while (*(_BYTE *)(v6 + v10) != 101)
      {
        if (++v10 == -3)
          goto LABEL_8;
      }
      a4[2] = v6 + v10;
      if (v10)
      {
        if (*result == 46)
          v11 = (_BYTE *)(a3 + 1);
        else
          v11 = (_BYTE *)v6;
        goto LABEL_12;
      }
    }
    result = memchr(result, 46, v8);
    if (result)
      v11 = result;
    else
      v11 = (_BYTE *)v6;
LABEL_12:
    a4[1] = v11;
    return result;
  }
  a4[1] = v6;
  a4[2] = v6;
  return result;
}

_BYTE *std::__formatter::__format_buffer_default[abi:ne180100]<double,long double>@<X0>(std::__1 *this@<X1>, uint64_t a2@<X0>, char *a3@<X2>, _QWORD *a4@<X8>, double a5@<D0>)
{
  uint64_t v7;
  _BYTE *v8;
  unint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  _BYTE *result;
  _BYTE *v13;

  *a4 = this;
  v7 = std::to_chars(this, (char *)(*(_QWORD *)(a2 + 16) + *(_QWORD *)(a2 + 8)), a3, a5);
  v8 = (_BYTE *)v7;
  a4[3] = v7;
  v9 = v7 - (_QWORD)this;
  v10 = (_BYTE *)v7;
  if (v7 - (uint64_t)this >= 4)
  {
    if (v9 >= 6)
      v9 = 6;
    v11 = -(uint64_t)v9;
    while (*(_BYTE *)(v7 + v11) != 101)
    {
      if (++v11 == -3)
      {
        v10 = (_BYTE *)v7;
        goto LABEL_9;
      }
    }
    v10 = (_BYTE *)(v7 + v11);
  }
LABEL_9:
  a4[2] = v10;
  result = memchr((char *)this + 1, 46, v10 - ((char *)this + 1));
  if (result)
    v13 = result;
  else
    v13 = v10;
  if (v13 == v10)
    v13 = v8;
  a4[1] = v13;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  void *v10;

  *a4 = a3;
  if (a2 == -1)
    result = std::to_chars();
  else
    result = MEMORY[0x20BCFDDF8](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 4);
  a4[3] = result;
  v8 = *(unsigned __int8 *)(a3 + 1);
  v7 = a3 + 1;
  if (v8 == 46)
  {
    v9 = result - 2;
    v10 = memchr((void *)(result - 6), 112, 4uLL);
    result = v7;
    if (v10)
      v7 = (uint64_t)v10;
    else
      v7 = v9;
  }
  a4[1] = result;
  a4[2] = v7;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  _BYTE *v6;
  _BYTE *v7;
  int v8;

  result = std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>(a1, a2, a3, a4);
  v6 = (_BYTE *)*a4;
  v7 = (_BYTE *)a4[2];
  if ((_BYTE *)*a4 != v7)
  {
    do
    {
      v8 = (char)*v6;
      if ((v8 - 97) < 6)
        LOBYTE(v8) = v8 - 32;
      *v6++ = v8;
    }
    while (v6 != v7);
    v6 = (_BYTE *)a4[2];
  }
  *v6 = 80;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *a4 = a3;
  result = MEMORY[0x20BCFDDF8](a3, *(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8), 1, a2);
  a4[3] = result;
  v7 = a3 + 1;
  if (*(_BYTE *)(a3 + 1) == 46)
  {
    a4[1] = v7;
    v8 = result - a3 - 2;
    v7 = result;
    if (v8 >= 4)
    {
      v9 = 6;
      if ((unint64_t)v8 < 6)
        v9 = result - a3 - 2;
      v10 = -v9;
      while (*(_BYTE *)(result + v10) != 101)
      {
        if (++v10 == -3)
        {
          v7 = result;
          goto LABEL_11;
        }
      }
      v7 = result + v10;
    }
  }
  else
  {
    a4[1] = result;
  }
LABEL_11:
  a4[2] = v7;
  return result;
}

unsigned __int8 *std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(_BYTE *a1, unsigned __int8 **a2)
{
  unsigned __int8 *result;
  unsigned int v4;

  result = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(a1, a2, 0x128u);
  v4 = a1[1];
  if (v4 >= 2 && v4 != 19)
    std::__throw_format_error[abi:ne180100]("The type option contains an invalid value for a string formatting argument");
  return result;
}

uint64_t *std::formatter<char const*,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, char *a2, uint64_t **a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t *v11;
  uint64_t *v14;

  v5 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  if (SHIDWORD(v5) > 0 || (int)v6 >= 0)
  {
    v8 = v5;
    v9 = v6;
    v10 = strlen(a2);
    return std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, v10, *a3, v8, v9);
  }
  else
  {
    v11 = *a3;
    if (*a2)
    {
      do
      {
        v14 = v11;
        std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v14, a2);
      }
      while (*++a2);
    }
  }
  return v11;
}

_QWORD *std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  int v9;
  uint64_t v10;

  if ((a5 & 0x80000000) != 0)
    return std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, a2, a3, a4, a5);
  v9 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, a2, a5, 0);
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, v10 - (_QWORD)__src, a3, a4, a5, v9);
}

unsigned __int8 *std::__formatter_pointer<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(_BYTE *a1, unsigned __int8 **a2)
{
  unsigned __int8 *result;
  int v4;

  result = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(a1, a2, 0x124u);
  v4 = a1[1];
  if ((v4 - 8) >= 2 && v4 != 0)
    std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a pointer");
  return result;
}

void std::__formatter_pointer<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, uint64_t a2, _QWORD *a3)
{
  __int16 v5;
  __int16 v6;

  v5 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  v6 = 1536;
  if ((v5 & 0xFF00) == 0x900)
    v6 = 1792;
  std::__formatter::__format_integer[abi:ne180100]<unsigned long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (uint64_t)a3, v5 | v6 | 0x20);
}

void std::__formatter::__format_integer[abi:ne180100]<unsigned long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, uint64_t a2, __int16 a3)
{
  __asm { BR              X10 }
}

_QWORD *sub_206804DEC(unint64_t a1, _QWORD **a2, unint64_t a3, unint64_t a4, char a5)
{
  char v6;
  _BYTE v7[6];

  return std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, &v6, (uint64_t)v7, 0, 10);
}

_QWORD *std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, _QWORD **a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, _BYTE *a8, signed int a9)
{
  char *v9;
  char v13;
  char v14;
  int v15;
  _WORD *v16;
  char v17;
  unsigned __int8 *v18;
  int v19;
  char *v20;
  const std::locale::facet *v21;
  char *locale;
  _QWORD *v23;
  std::string::value_type *v24;
  char *v25;
  std::string::value_type v26;
  uint64_t v27;
  std::string::value_type *v28;
  std::string::value_type *v29;
  std::string::value_type *v30;
  int v31;
  BOOL v32;
  char v33;
  _QWORD *v34;
  unint64_t v35;
  unsigned __int8 v36;
  int v37;
  unsigned __int8 v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  std::string __p;
  std::locale v45;
  uint64_t v46;
  unsigned __int8 v47;

  v9 = a6;
  v13 = a3;
  if ((a5 & 1) != 0)
  {
    v14 = 45;
LABEL_7:
    *a6 = v14;
    v16 = a6 + 1;
    goto LABEL_8;
  }
  v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    v14 = 43;
    goto LABEL_7;
  }
  v16 = a6;
  if (v15 == 3)
  {
    v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      v17 = *a8;
      if (*a8)
      {
        v18 = a8 + 1;
        do
        {
          *(_BYTE *)v16 = v17;
          v16 = (_WORD *)((char *)v16 + 1);
          v19 = *v18++;
          v17 = v19;
        }
        while (v19);
      }
    }
  }
  v20 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0)
    goto LABEL_44;
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v45);
  v21 = std::locale::use_facet(&v45, MEMORY[0x24BEDB588]);
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (char *)v45.__locale_;
    if (!v46)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v47)
      goto LABEL_44;
    locale = (char *)&v45;
  }
  if (v20 - (char *)v16 <= *locale)
  {
    if ((v47 & 0x80) != 0)
    {
      locale = (char *)v45.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    v35 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v9, (char *)v16 - v9);
      v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9)
        v37 = (_DWORD)v16 - (_DWORD)v9;
      else
        v37 = HIDWORD(a3);
      v35 = (HIDWORD(a3) - v37);
      v38 = 48;
      v9 = (char *)v16;
    }
    else
    {
      v38 = BYTE4(a4);
      v36 = a3;
    }
    v39 = *a2;
    v40 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    v41 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700)
      return (_QWORD *)std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, (uint64_t)v39, v40, v41, (uint64_t (*)(_QWORD))std::__formatter::__hex_to_upper[abi:ne180100]);
    else
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, v39, v40, v41, v20 - v9);
  }
  v23 = *a2;
  memset(&__p, 0, sizeof(__p));
  if ((v47 & 0x80u) == 0)
    v24 = (std::string::value_type *)&v45;
  else
    v24 = (std::string::value_type *)v45.__locale_;
  if ((v47 & 0x80u) == 0)
    v25 = (char *)&v45 + v47;
  else
    v25 = (char *)v45.__locale_ + v46;
  v26 = *v24;
  v27 = v20 - (char *)v16 - *v24;
  if (v27 >= 1)
  {
    v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (v24 == v28)
      {
        v26 = *v28;
        v24 = v28;
      }
      else
      {
        v29 = v24 + 1;
        v30 = v24 + 1;
        do
        {
          v31 = *v30++;
          v26 = v31;
          if (v31)
            v32 = 1;
          else
            v32 = v29 == v28;
          v29 = v30;
        }
        while (!v32);
        v24 = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  v33 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v23, v9, (char *)v16, (int)v20, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if ((char)v47 < 0)
    operator delete(v45.__locale_);
  return v34;
}

void sub_2068051D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15.__locale_);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<as::WorkloopPool::WorkloopState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24BFE4578;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<as::WorkloopPool::WorkloopState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24BFE4578;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCFDE58);
}

void std::__shared_ptr_emplace<as::WorkloopPool::WorkloopState>::__on_zero_shared(uint64_t a1)
{

}

void std::allocate_shared[abi:ne180100]<as::WorkloopPool,std::allocator<as::WorkloopPool>,as::WorkloopPool::ConstructionTag,unsigned long &,void>(uint64_t a1@<X1>, uint64_t *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;

  v6 = operator new(0x78uLL);
  std::__shared_ptr_emplace<as::WorkloopPool>::__shared_ptr_emplace[abi:ne180100]<as::WorkloopPool::ConstructionTag,unsigned long &,std::allocator<as::WorkloopPool>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<as::WorkloopPool>::__enable_weak_this[abi:ne180100]<as::WorkloopPool,as::WorkloopPool,void>((uint64_t)a3, v6 + 3, (uint64_t)(v6 + 3));
}

void sub_2068052C4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<as::WorkloopPool>::__shared_ptr_emplace[abi:ne180100]<as::WorkloopPool::ConstructionTag,unsigned long &,std::allocator<as::WorkloopPool>,0>(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_24BFE45B0;
  as::WorkloopPool::WorkloopPool((uint64_t)(a1 + 3), a2, *a3);
  return a1;
}

void sub_206805314(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<as::WorkloopPool>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24BFE45B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<as::WorkloopPool>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24BFE45B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BCFDE58);
}

void std::__shared_ptr_emplace<as::WorkloopPool>::__on_zero_shared(uint64_t a1)
{
  std::__destroy_at[abi:ne180100]<as::WorkloopPool,0>(a1 + 24);
}

void std::__destroy_at[abi:ne180100]<as::WorkloopPool,0>(uint64_t a1)
{
  std::__shared_weak_count *v2;
  void **v3;

  std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::~deque[abi:ne180100]((_QWORD *)(a1 + 48));
  v3 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void std::shared_ptr<as::WorkloopPool>::__enable_weak_this[abi:ne180100]<as::WorkloopPool,as::WorkloopPool,void>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *p_shared_weak_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  if (a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      if (v5)
      {
        v10 = (unint64_t *)&v5->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }
}

void std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_20680573C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;

  v5 = (char *)a1[3];
  v4 = (uint64_t)(a1 + 3);
  v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    v7 = (char *)a1[1];
    v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v18 = 1;
      else
        v18 = (uint64_t)&v6[-*a1] >> 2;
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v4, v18);
      v21 = &v19[8 * (v18 >> 2)];
      v22 = (uint64_t *)a1[1];
      v6 = v21;
      v23 = a1[2] - (_QWORD)v22;
      if (v23)
      {
        v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        v24 = 8 * (v23 >> 3);
        v25 = &v19[8 * (v18 >> 2)];
        do
        {
          v26 = *v22++;
          *(_QWORD *)v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        v6 = (char *)a1[2];
      }
    }
    else
    {
      v9 = v8 >> 3;
      v10 = v8 >> 3 < -1;
      v11 = (v8 >> 3) + 2;
      if (v10)
        v12 = v11;
      else
        v12 = v9 + 1;
      v13 = -(v12 >> 1);
      v14 = v12 >> 1;
      v15 = &v7[-8 * v14];
      v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        v6 = (char *)a1[1];
      }
      v17 = &v6[8 * v13];
      v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(_QWORD *)v6 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = a1 + 24;
    v7 = *(_BYTE **)(a1 + 24);
    v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4)
        v12 = 1;
      else
        v12 = (v7 - v4) >> 2;
      v13 = 2 * v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v6, v12);
      v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      v16 = *(uint64_t **)(a1 + 8);
      v17 = v5;
      v18 = *(_QWORD *)(a1 + 16) - (_QWORD)v16;
      if (v18)
      {
        v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        v19 = 8 * (v18 >> 3);
        v20 = v5;
        do
        {
          v21 = *v16++;
          *(_QWORD *)v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      v22 = *(char **)a1;
      *(_QWORD *)a1 = v14;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v17;
      *(_QWORD *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v9 = (v7 - v8) >> 3;
      if (v9 >= -1)
        v10 = v9 + 1;
      else
        v10 = v9 + 2;
      v11 = v10 >> 1;
      v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_back(_QWORD *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 2;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(a1[4], v16);
      v19 = &v17[8 * (v16 >> 2)];
      v20 = (uint64_t *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        v22 = 8 * (v21 >> 3);
        v23 = &v17[8 * (v16 >> 2)];
        do
        {
          v24 = *v20++;
          *(_QWORD *)v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 3;
      v8 = v6 >> 3 < -1;
      v9 = (v6 >> 3) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-8 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[8 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(_QWORD *)v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(*(_QWORD *)(a1 + 32), v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 < 0x200)
    a2 = 1;
  if (v2 < 0x400)
    v4 = a2;
  else
    v4 = 0;
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

uint64_t as::server::HardwareInfo::default_instance(as::server::HardwareInfo *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3EC0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    as::server::HardwareInfo::default_instance(void)::gInstance = v3;
  }
  return as::server::HardwareInfo::default_instance(void)::gInstance;
}

void sub_206805CC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::HardwareInfo::HardwareInfo(as::server::HardwareInfo *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3EC0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3EC0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  return result;
}

as::server::HardwareInfo *as::server::HardwareInfo::HardwareInfo(as::server::HardwareInfo *this, const as::server::HardwareInfo *a2)
{
  *(_QWORD *)this = &off_24BFE3EC0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::HardwareInfo::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3EC0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::HardwareInfo::copy_from(this, a2);
  return this;
}

uint64_t as::server::HardwareInfo::copy_from(as::server::HardwareInfo *this, const as::server::HardwareInfo *a2)
{
  uint64_t result;

  caulk::xstring::assign((as::server::HardwareInfo *)((char *)this + 16), (const as::server::HardwareInfo *)((char *)a2 + 16));
  caulk::xstring::assign((as::server::HardwareInfo *)((char *)this + 32), (const as::server::HardwareInfo *)((char *)a2 + 32));
  result = caulk::xstring::assign((as::server::HardwareInfo *)((char *)this + 48), (const as::server::HardwareInfo *)((char *)a2 + 48));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  return result;
}

as::server::HardwareInfo *as::server::HardwareInfo::operator=(as::server::HardwareInfo *a1, const as::server::HardwareInfo *a2)
{
  as::server::HardwareInfo::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::HardwareInfo::HardwareInfo(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE3EC0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::HardwareInfo::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3EC0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::HardwareInfo::move_from(a1, a2);
  return a1;
}

uint64_t as::server::HardwareInfo::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  v5 = 0;
  v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  v5 = 0;
  v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)&v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t as::server::HardwareInfo::operator=(uint64_t a1, uint64_t a2)
{
  as::server::HardwareInfo::move_from(a1, a2);
  return a1;
}

uint64_t as::server::HardwareInfo::clear(as::server::HardwareInfo *this)
{
  uint64_t result;

  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 16));
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 32));
  result = caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 48));
  *((_DWORD *)this + 2) = 0;
  return result;
}

uint64_t as::server::HardwareInfo::isInitialized(as::server::HardwareInfo *this)
{
  return 1;
}

BOOL as::server::HardwareInfo::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v15;
  unsigned int v16;
  unint64_t v17;
  char v18;
  unint64_t v20;
  int v21;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0)
    return v4 == 0;
  while (1)
  {
    v8 = *a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      break;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = v2 + 1;
      a2[1] = v2 + 1;
      v13 = *(_BYTE *)(v8 + v2);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0)
        break;
      v9 += 7;
      v2 = v12;
      if (v10++ > 8)
        goto LABEL_19;
    }
LABEL_20:
    if ((v11 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    v20 = v11 >> 3;
    if ((v11 >> 3) == 5)
    {
      PB::Reader::read();
      caulk::xstring::assign();
      v21 = *(_DWORD *)(a1 + 8) | 4;
    }
    else if ((_DWORD)v20 == 4)
    {
      PB::Reader::read();
      caulk::xstring::assign();
      v21 = *(_DWORD *)(a1 + 8) | 2;
    }
    else
    {
      if ((_DWORD)v20 != 2)
        goto LABEL_28;
      PB::Reader::read();
      caulk::xstring::assign();
      v21 = *(_DWORD *)(a1 + 8) | 1;
    }
    *(_DWORD *)(a1 + 8) = v21;
LABEL_28:
    v2 = a2[1];
    v3 = a2[2];
    v4 = *((unsigned __int8 *)a2 + 24);
    if (v2 >= v3 || *((_BYTE *)a2 + 24))
      return v4 == 0;
  }
  v15 = 0;
  v16 = 0;
  v11 = 0;
  if (v2 > v3)
    v3 = v2;
  while (v3 != v2)
  {
    v17 = v2 + 1;
    v18 = *(_BYTE *)(v8 + v2);
    a2[1] = v17;
    v11 |= (unint64_t)(v18 & 0x7F) << v15;
    if ((v18 & 0x80) == 0)
      goto LABEL_20;
    v15 += 7;
    v2 = v17;
    if (v16++ >= 9)
    {
LABEL_19:
      v11 = 0;
      goto LABEL_20;
    }
  }
  v4 = 1;
  *((_BYTE *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_2068061F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::server::HardwareInfo::writeTo(as::server::HardwareInfo *this, PB::Writer *a2)
{
  int v3;
  char *v4;
  char *v5;
  char *v6;
  void *__p[2];
  char v8;

  v3 = *((_DWORD *)this + 2);
  if ((v3 & 1) != 0)
  {
    v4 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(__p, v4);
    PB::Writer::write();
    if (v8 < 0)
      operator delete(__p[0]);
    v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 2) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v8 < 0)
      operator delete(__p[0]);
    v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 4) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 48));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::Writer::write();
    if (v8 < 0)
      operator delete(__p[0]);
  }
}

void sub_2068062F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::HardwareInfo::formatText(as::server::HardwareInfo *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  char *v7;
  char *v8;
  void *__p[2];
  char v11;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v11 < 0)
      operator delete(__p[0]);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    v7 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v11 < 0)
      operator delete(__p[0]);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0)
  {
    v8 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 48));
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::TextFormatter::format();
    if (v11 < 0)
      operator delete(__p[0]);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_206806410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::HardwareInfo::operator==(_DWORD *a1, _DWORD *a2)
{
  return a1[2] == a2[2]
      && !caulk::xstring::compare((caulk::xstring *)(a1 + 4), (const caulk::xstring *)(a2 + 4))
      && !caulk::xstring::compare((caulk::xstring *)(a1 + 8), (const caulk::xstring *)(a2 + 8))
      && caulk::xstring::compare((caulk::xstring *)(a1 + 12), (const caulk::xstring *)(a2 + 12)) == 0;
}

uint64_t as::server::Clock::default_instance(as::server::Clock *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4358;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_QWORD *)(v3 + 128) = 0;
    as::server::Clock::default_instance(void)::gInstance = v3;
  }
  return as::server::Clock::default_instance(void)::gInstance;
}

void sub_206806534(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::Clock::Clock(as::server::Clock *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE4358;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE4358;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  return result;
}

as::server::Clock *as::server::Clock::Clock(as::server::Clock *this, const as::server::Clock *a2)
{
  *(_QWORD *)this = &off_24BFE4358;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  as::server::Clock::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4358;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  as::server::Clock::copy_from(this, a2);
  return this;
}

__n128 as::server::Clock::copy_from(as::server::Clock *this, const as::server::Clock *a2)
{
  _QWORD *v4;
  __n128 ***v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  __n128 **v9;
  __n128 **v10;
  __n128 *v11;
  unint64_t v12;
  __n128 **v13;
  _QWORD *v14;
  __n128 **v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  __n128 **v21;
  char *v22;
  __n128 *v23;
  __int128 v24;
  char *v25;
  const as::server::HardwareInfo *v26;
  as::server::HardwareInfo *v27;
  _QWORD *v28;
  as::server::ControlAndValue ***v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  const as::server::ControlAndValue **v33;
  const as::server::ControlAndValue **j;
  as::server::ControlAndValue *v35;
  const as::server::ControlAndValue *v36;
  unint64_t v37;
  as::server::ControlAndValue **v38;
  _QWORD *v39;
  as::server::ControlAndValue **v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  as::server::ControlAndValue **v46;
  char *v47;
  as::server::ControlAndValue *v48;
  __int128 v49;
  char *v50;
  __n128 result;
  const as::server::Clock *i;
  uint64_t v53;
  __int128 v54;
  char *v55;
  char *v56;

  v4 = (_QWORD *)*((_QWORD *)this + 2);
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = (__n128 ***)((char *)this + 16);
  while (v6 != v4)
  {
    v8 = *--v6;
    v7 = v8;
    *v6 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  *((_QWORD *)this + 3) = v4;
  v9 = (__n128 **)*((_QWORD *)a2 + 2);
  v10 = (__n128 **)*((_QWORD *)a2 + 3);
  for (i = a2; v9 != v10; ++v9)
  {
    v11 = (__n128 *)operator new();
    as::SampleRateRange::SampleRateRange(v11, *v9);
    v13 = (__n128 **)*((_QWORD *)this + 3);
    v12 = *((_QWORD *)this + 4);
    if ((unint64_t)v13 >= v12)
    {
      v15 = *v5;
      v16 = v13 - *v5;
      v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v18 = v12 - (_QWORD)v15;
      if (v18 >> 2 > v17)
        v17 = v18 >> 2;
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v17;
      v56 = (char *)this + 32;
      if (v19)
      {
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v19);
        v15 = (__n128 **)*((_QWORD *)this + 2);
        v13 = (__n128 **)*((_QWORD *)this + 3);
      }
      else
      {
        v20 = 0;
      }
      v21 = (__n128 **)&v20[8 * v16];
      v22 = &v20[8 * v19];
      v55 = v22;
      *v21 = v11;
      *((_QWORD *)&v54 + 1) = v21 + 1;
      if (v13 == v15)
      {
        v14 = v21 + 1;
      }
      else
      {
        do
        {
          v23 = *--v13;
          *v13 = 0;
          *--v21 = v23;
        }
        while (v13 != v15);
        v14 = (_QWORD *)*((_QWORD *)&v54 + 1);
        v22 = v55;
      }
      v24 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v21;
      *((_QWORD *)this + 3) = v14;
      v54 = v24;
      v25 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v22;
      v55 = v25;
      v53 = v24;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v53);
    }
    else
    {
      *v13 = v11;
      v14 = v13 + 1;
    }
    *((_QWORD *)this + 3) = v14;
  }
  v26 = (const as::server::HardwareInfo *)*((_QWORD *)i + 12);
  if (v26)
  {
    v27 = (as::server::HardwareInfo *)as::server::Clock::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v27, v26);
  }
  caulk::xstring::assign((as::server::Clock *)((char *)this + 64), (const as::server::Clock *)((char *)i + 64));
  caulk::xstring::assign((as::server::Clock *)((char *)this + 80), (const as::server::Clock *)((char *)i + 80));
  v28 = (_QWORD *)*((_QWORD *)this + 5);
  v30 = (_QWORD *)*((_QWORD *)this + 6);
  v29 = (as::server::ControlAndValue ***)((char *)this + 40);
  while (v30 != v28)
  {
    v32 = *--v30;
    v31 = v32;
    *v30 = 0;
    if (v32)
      (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  }
  *((_QWORD *)this + 6) = v28;
  v33 = (const as::server::ControlAndValue **)*((_QWORD *)i + 5);
  for (j = (const as::server::ControlAndValue **)*((_QWORD *)i + 6); v33 != j; ++v33)
  {
    v35 = (as::server::ControlAndValue *)operator new();
    v36 = *v33;
    *((_QWORD *)v35 + 1) = 0;
    *((_QWORD *)v35 + 2) = 0;
    *(_QWORD *)v35 = &off_24BFE3FA0;
    as::server::ControlAndValue::copy_from(v35, v36);
    v38 = (as::server::ControlAndValue **)*((_QWORD *)this + 6);
    v37 = *((_QWORD *)this + 7);
    if ((unint64_t)v38 >= v37)
    {
      v40 = *v29;
      v41 = v38 - *v29;
      v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v43 = v37 - (_QWORD)v40;
      if (v43 >> 2 > v42)
        v42 = v43 >> 2;
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
        v44 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v44 = v42;
      v56 = (char *)this + 56;
      if (v44)
      {
        v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 56, v44);
        v40 = (as::server::ControlAndValue **)*((_QWORD *)this + 5);
        v38 = (as::server::ControlAndValue **)*((_QWORD *)this + 6);
      }
      else
      {
        v45 = 0;
      }
      v46 = (as::server::ControlAndValue **)&v45[8 * v41];
      v47 = &v45[8 * v44];
      v55 = v47;
      *v46 = v35;
      *((_QWORD *)&v54 + 1) = v46 + 1;
      if (v38 == v40)
      {
        v39 = v46 + 1;
      }
      else
      {
        do
        {
          v48 = *--v38;
          *v38 = 0;
          *--v46 = v48;
        }
        while (v38 != v40);
        v39 = (_QWORD *)*((_QWORD *)&v54 + 1);
        v47 = v55;
      }
      v49 = *(_OWORD *)((char *)this + 40);
      *((_QWORD *)this + 5) = v46;
      *((_QWORD *)this + 6) = v39;
      v54 = v49;
      v50 = (char *)*((_QWORD *)this + 7);
      *((_QWORD *)this + 7) = v47;
      v55 = v50;
      v53 = v49;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v53);
    }
    else
    {
      *v38 = v35;
      v39 = v38 + 1;
    }
    *((_QWORD *)this + 6) = v39;
  }
  *((_DWORD *)this + 2) = *((_DWORD *)i + 2);
  result = *(__n128 *)((char *)i + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)i + 120);
  *(__n128 *)((char *)this + 104) = result;
  return result;
}

as::server::Clock *as::server::Clock::operator=(as::server::Clock *a1, const as::server::Clock *a2)
{
  as::server::Clock::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::Clock::hardwareInfo(as::server::Clock *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 12);
  if (!result)
    return as::server::HardwareInfo::default_instance(0);
  return result;
}

uint64_t as::server::Clock::mutableHardwareInfo(as::server::Clock *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 12);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3EC0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    v3 = *((_QWORD *)this + 12);
    *((_QWORD *)this + 12) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

as::server::ControlAndValue *as::server::ControlAndValue::ControlAndValue(as::server::ControlAndValue *this, const as::server::ControlAndValue *a2)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE3FA0;
  as::server::ControlAndValue::copy_from(this, a2);
  return this;
}

{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE3FA0;
  as::server::ControlAndValue::copy_from(this, a2);
  return this;
}

uint64_t as::server::Clock::Clock(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE4358;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  as::server::Clock::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE4358;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  as::server::Clock::move_from(a1, a2);
  return a1;
}

__n128 as::server::Clock::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __n128 result;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  v7 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 96) = v7;
  v12 = 0;
  v13 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v12);
  v12 = 0;
  v13 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v12);
  v8 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v8;
  v9 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v9;
  v10 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v10;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 104);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(__n128 *)(a1 + 104) = result;
  return result;
}

uint64_t as::server::Clock::operator=(uint64_t a1, uint64_t a2)
{
  as::server::Clock::move_from(a1, a2);
  return a1;
}

double as::server::Clock::clear(as::server::Clock *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  double result;

  v2 = (_QWORD *)*((_QWORD *)this + 2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  while (v3 != v2)
  {
    v5 = *--v3;
    v4 = v5;
    *v3 = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  *((_QWORD *)this + 3) = v2;
  v6 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  caulk::xstring::clear((as::server::Clock *)((char *)this + 64));
  caulk::xstring::clear((as::server::Clock *)((char *)this + 80));
  v7 = (_QWORD *)*((_QWORD *)this + 5);
  v8 = (_QWORD *)*((_QWORD *)this + 6);
  while (v8 != v7)
  {
    v10 = *--v8;
    v9 = v10;
    *v8 = 0;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  *((_QWORD *)this + 6) = v7;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

BOOL as::server::Clock::isInitialized(as::server::Clock *this)
{
  as::SampleRateRange **v2;
  as::SampleRateRange **v3;
  as::server::ControlAndValue **v4;
  as::server::ControlAndValue **v5;

  v2 = (as::SampleRateRange **)*((_QWORD *)this + 2);
  v3 = (as::SampleRateRange **)*((_QWORD *)this + 3);
  while (v2 != v3)
  {
    if (!as::SampleRateRange::isInitialized(*v2))
      return 0;
    ++v2;
  }
  if (!*((_QWORD *)this + 12))
    return 0;
  v4 = (as::server::ControlAndValue **)*((_QWORD *)this + 5);
  v5 = (as::server::ControlAndValue **)*((_QWORD *)this + 6);
  while (v4 != v5)
  {
    if (!as::server::ControlAndValue::isInitialized(*v4))
      return 0;
    ++v4;
  }
  return (~*((_DWORD *)this + 2) & 0xBF) == 0;
}

BOOL as::server::ControlAndValue::isInitialized(as::server::ControlAndValue *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 1);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 16);
    v3 = *(_QWORD *)(v1 + 24);
    if (v2 == v3)
    {
LABEL_5:
      if ((~*(_DWORD *)(v1 + 8) & 0x3F) == 0)
      {
        v4 = *((_QWORD *)this + 2);
        if (v4)
          return (~*(_DWORD *)(v4 + 8) & 3) == 0;
      }
    }
    else
    {
      while ((~*(_DWORD *)(*(_QWORD *)v2 + 8) & 3) == 0)
      {
        v2 += 8;
        if (v2 == v3)
          goto LABEL_5;
      }
    }
  }
  return 0;
}

BOOL as::server::Clock::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  int64x2_t *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  BOOL v17;
  char v18;
  unsigned int v19;
  unint64_t v20;
  unint64_t v21;
  char v22;
  BOOL v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  char v39;
  unsigned int v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t *v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  char v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  char v55;
  unsigned int v56;
  uint64_t v57;
  unint64_t v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  char v65;
  unsigned int v66;
  unint64_t v67;
  char v68;
  char v69;
  unsigned int v70;
  unint64_t v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  char *v77;
  char v78;
  unsigned int v79;
  unint64_t v80;
  char v81;
  int v82;
  char v83;
  unsigned int v84;
  unint64_t v85;
  char v86;
  char v87;
  unsigned int v88;
  unint64_t v89;
  char v90;
  char *v91;
  char *v92;
  _QWORD *v93;
  _QWORD *v94;
  uint64_t v95;
  int64x2_t v96;
  uint64_t *v97;
  char *v98;
  _QWORD *v99;
  _QWORD *v100;
  uint64_t v101;
  int64x2_t v102;
  char *v103;
  char *v104;
  uint64_t v105;
  int64x2_t *v108;
  void *__p;
  int64x2_t v110;
  char *v111;
  uint64_t v112;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v108 = (int64x2_t *)(a1 + 40);
  v8 = a1 + 56;
  v9 = (int64x2_t *)(a1 + 16);
  v10 = a1 + 32;
  while (2)
  {
    v11 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v12 = 0;
      v13 = 0;
      v14 = 0;
      while (1)
      {
        v15 = v3 + 1;
        a2[1] = v3 + 1;
        v16 = *(_BYTE *)(v11 + v3);
        v14 |= (unint64_t)(v16 & 0x7F) << v12;
        if ((v16 & 0x80) == 0)
          goto LABEL_23;
        v12 += 7;
        v3 = v15;
        v17 = v13++ > 8;
        if (v17)
        {
          v14 = 0;
          goto LABEL_23;
        }
      }
    }
    v18 = 0;
    v19 = 0;
    v14 = 0;
    if (v3 <= v2)
      v20 = v2;
    else
      v20 = v3;
    do
    {
      if (v20 == v3)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v21 = v3++;
      v22 = *(_BYTE *)(v11 + v21);
      a2[1] = v3;
      v14 |= (unint64_t)(v22 & 0x7F) << v18;
      if ((v22 & 0x80) == 0)
        goto LABEL_22;
      v18 += 7;
      v23 = v19++ >= 9;
    }
    while (!v23);
    v14 = 0;
LABEL_22:
    v15 = v21 + 1;
LABEL_23:
    if ((v14 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v14 >> 3))
    {
      case 1u:
        if (v15 > 0xFFFFFFFFFFFFFFF5 || v15 + 10 > v2)
        {
          v78 = 0;
          v79 = 0;
          v26 = 0;
          if (v2 <= v15)
            v2 = v15;
          do
          {
            if (v2 == v15)
            {
              v26 = 0;
              *((_BYTE *)a2 + 24) = 1;
              goto LABEL_151;
            }
            v80 = v15 + 1;
            v81 = *(_BYTE *)(v11 + v15);
            a2[1] = v80;
            v26 |= (unint64_t)(v81 & 0x7F) << v78;
            if ((v81 & 0x80) == 0)
              goto LABEL_151;
            v78 += 7;
            v15 = v80;
            v23 = v79++ >= 9;
          }
          while (!v23);
LABEL_112:
          v26 = 0;
        }
        else
        {
          v24 = 0;
          v25 = 0;
          v26 = 0;
          while (1)
          {
            v27 = v15 + 1;
            a2[1] = v15 + 1;
            v28 = *(_BYTE *)(v11 + v15);
            v26 |= (unint64_t)(v28 & 0x7F) << v24;
            if ((v28 & 0x80) == 0)
              break;
            v24 += 7;
            v15 = v27;
            v17 = v25++ > 8;
            if (v17)
              goto LABEL_112;
          }
        }
LABEL_151:
        *(_QWORD *)(a1 + 112) = v26;
        v82 = *(_DWORD *)(a1 + 8) | 1;
        goto LABEL_156;
      case 3u:
        if (v15 <= 0xFFFFFFFFFFFFFFF5 && v15 + 10 <= v2)
        {
          v47 = 0;
          v48 = 0;
          v49 = 0;
          do
          {
            v50 = v15 + 1;
            a2[1] = v15 + 1;
            v51 = *(_BYTE *)(v11 + v15);
            v49 |= (unint64_t)(v51 & 0x7F) << v47;
            if ((v51 & 0x80) == 0)
              goto LABEL_153;
            v47 += 7;
            v15 = v50;
            v17 = v48++ > 8;
          }
          while (!v17);
LABEL_121:
          LODWORD(v49) = 0;
          goto LABEL_153;
        }
        v83 = 0;
        v84 = 0;
        v49 = 0;
        if (v2 <= v15)
          v2 = v15;
        while (v2 != v15)
        {
          v85 = v15 + 1;
          v86 = *(_BYTE *)(v11 + v15);
          a2[1] = v85;
          v49 |= (unint64_t)(v86 & 0x7F) << v83;
          if ((v86 & 0x80) == 0)
            goto LABEL_153;
          v83 += 7;
          v15 = v85;
          v23 = v84++ >= 9;
          if (v23)
            goto LABEL_121;
        }
        LODWORD(v49) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_153:
        *(_DWORD *)(a1 + 120) = v49;
        v82 = *(_DWORD *)(a1 + 8) | 2;
        goto LABEL_156;
      case 4u:
        if (v15 > 0xFFFFFFFFFFFFFFF7 || v15 + 8 > v2)
        {
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          *(_QWORD *)(a1 + 104) = *(_QWORD *)(v11 + v15);
          a2[1] += 8;
        }
        v82 = *(_DWORD *)(a1 + 8) | 4;
        goto LABEL_156;
      case 5u:
        v44 = operator new();
        as::SampleRateRange::SampleRateRange(v44);
        v46 = *(uint64_t **)(a1 + 24);
        v45 = *(_QWORD *)(a1 + 32);
        if ((unint64_t)v46 >= v45)
        {
          v73 = ((uint64_t)v46 - v9->i64[0]) >> 3;
          if ((unint64_t)(v73 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v74 = v45 - v9->i64[0];
          v75 = v74 >> 2;
          if (v74 >> 2 <= (unint64_t)(v73 + 1))
            v75 = v73 + 1;
          if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFF8)
            v76 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v76 = v75;
          v112 = v10;
          if (v76)
            v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v10, v76);
          else
            v77 = 0;
          v97 = (uint64_t *)&v77[8 * v73];
          v98 = &v77[8 * v76];
          v111 = v98;
          *v97 = v44;
          v33 = v97 + 1;
          v110.i64[1] = (uint64_t)(v97 + 1);
          v100 = *(_QWORD **)(a1 + 16);
          v99 = *(_QWORD **)(a1 + 24);
          if (v99 == v100)
          {
            v102 = vdupq_n_s64((unint64_t)v99);
          }
          else
          {
            do
            {
              v101 = *--v99;
              *v99 = 0;
              *--v97 = v101;
            }
            while (v99 != v100);
            v102 = *v9;
            v33 = (_QWORD *)v110.i64[1];
            v98 = v111;
          }
          *(_QWORD *)(a1 + 16) = v97;
          *(_QWORD *)(a1 + 24) = v33;
          v110 = v102;
          v104 = *(char **)(a1 + 32);
          *(_QWORD *)(a1 + 32) = v98;
          v111 = v104;
          __p = (void *)v102.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v46 = v44;
          v33 = v46 + 1;
        }
        *(_QWORD *)(a1 + 24) = v33;
        goto LABEL_143;
      case 6u:
        if (v15 <= 0xFFFFFFFFFFFFFFF5 && v15 + 10 <= v2)
        {
          v34 = 0;
          v35 = 0;
          v36 = 0;
          do
          {
            v37 = v15 + 1;
            a2[1] = v15 + 1;
            v38 = *(_BYTE *)(v11 + v15);
            v36 |= (unint64_t)(v38 & 0x7F) << v34;
            if ((v38 & 0x80) == 0)
              goto LABEL_147;
            v34 += 7;
            v15 = v37;
            v17 = v35++ > 8;
          }
          while (!v17);
LABEL_90:
          LODWORD(v36) = 0;
          goto LABEL_147;
        }
        v65 = 0;
        v66 = 0;
        v36 = 0;
        if (v2 <= v15)
          v2 = v15;
        while (v2 != v15)
        {
          v67 = v15 + 1;
          v68 = *(_BYTE *)(v11 + v15);
          a2[1] = v67;
          v36 |= (unint64_t)(v68 & 0x7F) << v65;
          if ((v68 & 0x80) == 0)
            goto LABEL_147;
          v65 += 7;
          v15 = v67;
          v23 = v66++ >= 9;
          if (v23)
            goto LABEL_90;
        }
        LODWORD(v36) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_147:
        *(_DWORD *)(a1 + 124) = v36;
        v82 = *(_DWORD *)(a1 + 8) | 8;
        goto LABEL_156;
      case 7u:
        if (v15 <= 0xFFFFFFFFFFFFFFF5 && v15 + 10 <= v2)
        {
          v39 = 0;
          v40 = 0;
          v41 = 0;
          do
          {
            v42 = v15 + 1;
            a2[1] = v15 + 1;
            v43 = *(_BYTE *)(v11 + v15);
            v41 |= (unint64_t)(v43 & 0x7F) << v39;
            if ((v43 & 0x80) == 0)
              goto LABEL_149;
            v39 += 7;
            v15 = v42;
            v17 = v40++ > 8;
          }
          while (!v17);
LABEL_97:
          LODWORD(v41) = 0;
          goto LABEL_149;
        }
        v69 = 0;
        v70 = 0;
        v41 = 0;
        if (v2 <= v15)
          v2 = v15;
        while (v2 != v15)
        {
          v71 = v15 + 1;
          v72 = *(_BYTE *)(v11 + v15);
          a2[1] = v71;
          v41 |= (unint64_t)(v72 & 0x7F) << v69;
          if ((v72 & 0x80) == 0)
            goto LABEL_149;
          v69 += 7;
          v15 = v71;
          v23 = v70++ >= 9;
          if (v23)
            goto LABEL_97;
        }
        LODWORD(v41) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_149:
        *(_DWORD *)(a1 + 128) = v41;
        v82 = *(_DWORD *)(a1 + 8) | 0x10;
        goto LABEL_156;
      case 8u:
        v52 = operator new();
        *(_QWORD *)v52 = &off_24BFE3EC0;
        *(_DWORD *)(v52 + 8) = 0;
        *(_OWORD *)(v52 + 16) = 0u;
        *(_OWORD *)(v52 + 32) = 0u;
        *(_OWORD *)(v52 + 48) = 0u;
        v53 = *(_QWORD *)(a1 + 96);
        *(_QWORD *)(a1 + 96) = v52;
        if (v53)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v53 + 8))(v53);
          v52 = *(_QWORD *)(a1 + 96);
        }
        if (PB::Reader::placeMark()
          && ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v52 + 16))(v52, a2) & 1) != 0)
        {
          goto LABEL_64;
        }
        return 0;
      case 9u:
        __p = 0;
        v110 = 0uLL;
        PB::Reader::read();
        caulk::xstring::assign();
        v54 = *(_DWORD *)(a1 + 8) | 0x20;
        goto LABEL_74;
      case 0xAu:
        __p = 0;
        v110 = 0uLL;
        PB::Reader::read();
        caulk::xstring::assign();
        v54 = *(_DWORD *)(a1 + 8) | 0x40;
LABEL_74:
        *(_DWORD *)(a1 + 8) = v54;
        if (v110.i8[15] < 0)
          operator delete(__p);
        goto LABEL_157;
      case 0xBu:
        if (v15 <= 0xFFFFFFFFFFFFFFF5 && v15 + 10 <= v2)
        {
          v55 = 0;
          v56 = 0;
          v57 = 0;
          do
          {
            v58 = v15 + 1;
            a2[1] = v15 + 1;
            v59 = *(_BYTE *)(v11 + v15);
            v57 |= (unint64_t)(v59 & 0x7F) << v55;
            if ((v59 & 0x80) == 0)
              goto LABEL_155;
            v55 += 7;
            v15 = v58;
            v17 = v56++ > 8;
          }
          while (!v17);
LABEL_128:
          LODWORD(v57) = 0;
          goto LABEL_155;
        }
        v87 = 0;
        v88 = 0;
        v57 = 0;
        if (v2 <= v15)
          v2 = v15;
        while (v2 != v15)
        {
          v89 = v15 + 1;
          v90 = *(_BYTE *)(v11 + v15);
          a2[1] = v89;
          v57 |= (unint64_t)(v90 & 0x7F) << v87;
          if ((v90 & 0x80) == 0)
            goto LABEL_155;
          v87 += 7;
          v15 = v89;
          v23 = v88++ >= 9;
          if (v23)
            goto LABEL_128;
        }
        LODWORD(v57) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_155:
        *(_DWORD *)(a1 + 132) = v57;
        v82 = *(_DWORD *)(a1 + 8) | 0x80;
LABEL_156:
        *(_DWORD *)(a1 + 8) = v82;
        goto LABEL_157;
      case 0xCu:
        v29 = (_QWORD *)operator new();
        v30 = v29;
        v29[1] = 0;
        v29[2] = 0;
        *v29 = &off_24BFE3FA0;
        v32 = *(_QWORD **)(a1 + 48);
        v31 = *(_QWORD *)(a1 + 56);
        if ((unint64_t)v32 >= v31)
        {
          v60 = ((uint64_t)v32 - v108->i64[0]) >> 3;
          if ((unint64_t)(v60 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v61 = v31 - v108->i64[0];
          v62 = v61 >> 2;
          if (v61 >> 2 <= (unint64_t)(v60 + 1))
            v62 = v60 + 1;
          if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8)
            v63 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v63 = v62;
          v112 = v8;
          if (v63)
            v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v8, v63);
          else
            v64 = 0;
          v91 = &v64[8 * v60];
          v92 = &v64[8 * v63];
          v111 = v92;
          *(_QWORD *)v91 = v30;
          v33 = v91 + 8;
          v110.i64[1] = (uint64_t)(v91 + 8);
          v94 = *(_QWORD **)(a1 + 40);
          v93 = *(_QWORD **)(a1 + 48);
          if (v93 == v94)
          {
            v96 = vdupq_n_s64((unint64_t)v93);
          }
          else
          {
            do
            {
              v95 = *--v93;
              *v93 = 0;
              *((_QWORD *)v91 - 1) = v95;
              v91 -= 8;
            }
            while (v93 != v94);
            v96 = *v108;
            v33 = (_QWORD *)v110.i64[1];
            v92 = v111;
          }
          *(_QWORD *)(a1 + 40) = v91;
          *(_QWORD *)(a1 + 48) = v33;
          v110 = v96;
          v103 = *(char **)(a1 + 56);
          *(_QWORD *)(a1 + 56) = v92;
          v111 = v103;
          __p = (void *)v96.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v32 = v29;
          v33 = v32 + 1;
        }
        *(_QWORD *)(a1 + 48) = v33;
LABEL_143:
        v105 = *(v33 - 1);
        if ((PB::Reader::placeMark() & 1) != 0
          && ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v105 + 16))(v105, a2) & 1) != 0)
        {
LABEL_64:
          PB::Reader::recallMark();
LABEL_157:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          continue;
        }
        return 0;
      default:
        goto LABEL_157;
    }
  }
}

void sub_206807700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::Clock::writeTo(as::server::Clock *this, PB::Writer *a2)
{
  int v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;
  int v8;
  const PB::Base *v9;
  int v10;
  char *v11;
  char *v12;
  const PB::Base **v13;
  const PB::Base **v14;
  const PB::Base *v15;
  void *__p[2];
  char v17;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) == 0)
  {
    if ((v4 & 2) == 0)
      goto LABEL_3;
LABEL_29:
    PB::Writer::writeVarInt(a2);
    if ((*((_DWORD *)this + 2) & 4) == 0)
      goto LABEL_5;
    goto LABEL_4;
  }
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 2) != 0)
    goto LABEL_29;
LABEL_3:
  if ((v4 & 4) != 0)
LABEL_4:
    PB::Writer::write(a2, *((double *)this + 13));
LABEL_5:
  v5 = (const PB::Base **)*((_QWORD *)this + 2);
  v6 = (const PB::Base **)*((_QWORD *)this + 3);
  while (v5 != v6)
  {
    v7 = *v5++;
    PB::Writer::writeSubmessage(a2, v7);
  }
  v8 = *((_DWORD *)this + 2);
  if ((v8 & 8) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v8 = *((_DWORD *)this + 2);
  }
  if ((v8 & 0x10) != 0)
    PB::Writer::writeVarInt(a2);
  v9 = (const PB::Base *)*((_QWORD *)this + 12);
  if (v9)
    PB::Writer::writeSubmessage(a2, v9);
  v10 = *((_DWORD *)this + 2);
  if ((v10 & 0x20) != 0)
  {
    v11 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 64));
    std::string::basic_string[abi:ne180100]<0>(__p, v11);
    PB::Writer::write();
    if (v17 < 0)
      operator delete(__p[0]);
    v10 = *((_DWORD *)this + 2);
  }
  if ((v10 & 0x40) != 0)
  {
    v12 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 80));
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::Writer::write();
    if (v17 < 0)
      operator delete(__p[0]);
    v10 = *((_DWORD *)this + 2);
  }
  if ((v10 & 0x80) != 0)
    PB::Writer::writeVarInt(a2);
  v14 = (const PB::Base **)*((_QWORD *)this + 5);
  v13 = (const PB::Base **)*((_QWORD *)this + 6);
  while (v14 != v13)
  {
    v15 = *v14++;
    PB::Writer::writeSubmessage(a2, v15);
  }
}

void sub_2068078DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::Clock::formatText(as::server::Clock *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  char *v12;
  char *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  void *__p[2];
  char v19;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "objectToken");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "transportType");
  if ((*((_DWORD *)this + 2) & 4) != 0)
LABEL_4:
    PB::TextFormatter::format(a2, "sampleRate", *((double *)this + 13));
LABEL_5:
  v6 = (uint64_t *)*((_QWORD *)this + 2);
  v7 = (uint64_t *)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "availableSampleRates");
  }
  v9 = *((_DWORD *)this + 2);
  if ((v9 & 8) != 0)
  {
    PB::TextFormatter::format(a2, "outputLatency");
    v9 = *((_DWORD *)this + 2);
  }
  if ((v9 & 0x10) != 0)
    PB::TextFormatter::format(a2, "inputLatency");
  v10 = *((_QWORD *)this + 12);
  if (v10)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v10 + 32))(v10, a2, "hardwareInfo");
  v11 = *((_DWORD *)this + 2);
  if ((v11 & 0x20) != 0)
  {
    v12 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 64));
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::TextFormatter::format();
    if (v19 < 0)
      operator delete(__p[0]);
    v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 0x40) != 0)
  {
    v13 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 80));
    std::string::basic_string[abi:ne180100]<0>(__p, v13);
    PB::TextFormatter::format();
    if (v19 < 0)
      operator delete(__p[0]);
    v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 0x80) != 0)
    PB::TextFormatter::format(a2, "clockDomain");
  v14 = (uint64_t *)*((_QWORD *)this + 5);
  v15 = (uint64_t *)*((_QWORD *)this + 6);
  while (v14 != v15)
  {
    v16 = *v14++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v16 + 32))(v16, a2, "controls");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_206807B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::Clock::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  BOOL v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  v4 = *(_QWORD *)(a1 + 104) == *(_QWORD *)(a2 + 104) && *(_QWORD *)(a1 + 112) == *(_QWORD *)(a2 + 112);
  v5 = v4 && *(_QWORD *)(a1 + 120) == *(_QWORD *)(a2 + 120);
  if (!v5 || *(_QWORD *)(a1 + 128) != *(_QWORD *)(a2 + 128))
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v9 = (v7 - v8) >> 3;
  if (v9 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3)
    return 0;
  if (v7 != v8)
  {
    v10 = 0;
    if (v9 <= 1)
      v11 = 1;
    else
      v11 = (v7 - v8) >> 3;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v10);
      v13 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v10);
      if (v12)
        v14 = v13 == 0;
      else
        v14 = 1;
      if (v14)
      {
        if (v12 | v13)
          return 0;
      }
      else if (!as::SampleRateRange::operator==(v12, v13))
      {
        return 0;
      }
      ++v10;
    }
    while (v11 != v10);
  }
  v15 = *(_QWORD *)(a1 + 96);
  v16 = *(_QWORD *)(a2 + 96);
  if (v15 && v16)
  {
    if (!as::server::HardwareInfo::operator==((_DWORD *)v15, (_DWORD *)v16))
      return 0;
  }
  else if (v15 | v16)
  {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 64), (const caulk::xstring *)(a2 + 64)))
    return 0;
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 80), (const caulk::xstring *)(a2 + 80)))
    return 0;
  v18 = *(_QWORD *)(a1 + 40);
  v17 = *(_QWORD *)(a1 + 48);
  v19 = (v17 - v18) >> 3;
  if (v19 != (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
    return 0;
  if (v17 == v18)
  {
    return 1;
  }
  else
  {
    v20 = 0;
    v21 = 0;
    if (v19 <= 1)
      v22 = 1;
    else
      v22 = (v17 - v18) >> 3;
    do
    {
      v23 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v21);
      v24 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v21);
      if (v23)
        v25 = v24 == 0;
      else
        v25 = 1;
      if (v25)
      {
        if (v23 | v24)
          return v20;
      }
      else if (!as::server::ControlAndValue::operator==(v23, v24))
      {
        return v20;
      }
      v20 = ++v21 >= v19;
    }
    while (v22 != v21);
  }
  return v20;
}

uint64_t as::server::Clock::addAvailableSampleRates(as::server::Clock *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  char *v23;
  char *v24;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v24 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v23 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v22 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v22 + 1);
      v14 = v23;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v22 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v23 = v17;
    v21 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v21);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  v18 = operator new();
  result = as::SampleRateRange::SampleRateRange(v18);
  v20 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::Clock::clearHardwareInfo(as::server::Clock *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *as::server::Clock::addControls(as::server::Clock *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  _QWORD *result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  result = (_QWORD *)operator new();
  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE3FA0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return (_QWORD *)*(v6 - 1);
  }
  return result;
}

uint64_t as::server::HWStream::default_instance(as::server::HWStream *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4438;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_DWORD *)(v3 + 128) = 0;
    as::server::HWStream::default_instance(void)::gInstance = v3;
  }
  return as::server::HWStream::default_instance(void)::gInstance;
}

void sub_20680800C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::HWStream::HWStream(as::server::HWStream *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE4438;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE4438;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  return result;
}

as::server::HWStream *as::server::HWStream::HWStream(as::server::HWStream *this, const as::server::HWStream *a2)
{
  *(_QWORD *)this = &off_24BFE4438;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::HWStream::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4438;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::HWStream::copy_from(this, a2);
  return this;
}

__n128 as::server::HWStream::copy_from(as::server::HWStream *this, const as::server::HWStream *a2)
{
  const as::server::HardwareInfo *v4;
  as::server::HardwareInfo *v5;
  const as::StreamFormat *v6;
  as::StreamFormat *v7;
  const as::StreamFormat *v8;
  as::StreamFormat *v9;
  _QWORD *v10;
  as::AvailableStreamFormat ***v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  const as::AvailableStreamFormat **v15;
  const as::AvailableStreamFormat **v16;
  as::AvailableStreamFormat *v17;
  unint64_t v18;
  as::AvailableStreamFormat **v19;
  _QWORD *v20;
  as::AvailableStreamFormat **v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  as::AvailableStreamFormat **v27;
  char *v28;
  as::AvailableStreamFormat *v29;
  __int128 v30;
  char *v31;
  _QWORD *v32;
  as::AvailableStreamFormat ***v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  const as::AvailableStreamFormat **v37;
  const as::AvailableStreamFormat **j;
  as::AvailableStreamFormat *v39;
  unint64_t v40;
  as::AvailableStreamFormat **v41;
  _QWORD *v42;
  as::AvailableStreamFormat **v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  as::AvailableStreamFormat **v49;
  char *v50;
  as::AvailableStreamFormat *v51;
  __int128 v52;
  char *v53;
  __n128 result;
  const as::server::HWStream *i;
  uint64_t v56;
  __int128 v57;
  char *v58;
  char *v59;

  v4 = (const as::server::HardwareInfo *)*((_QWORD *)a2 + 11);
  if (v4)
  {
    v5 = (as::server::HardwareInfo *)as::server::HWStream::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v5, v4);
  }
  v6 = (const as::StreamFormat *)*((_QWORD *)a2 + 12);
  if (v6)
  {
    v7 = as::server::HWStream::mutablePrivateFormat(this);
    as::StreamFormat::operator=(v7, v6);
  }
  v8 = (const as::StreamFormat *)*((_QWORD *)a2 + 13);
  if (v8)
  {
    v9 = as::server::HWStream::mutablePublicFormat(this);
    as::StreamFormat::operator=(v9, v8);
  }
  v10 = (_QWORD *)*((_QWORD *)this + 5);
  v12 = (_QWORD *)*((_QWORD *)this + 6);
  v11 = (as::AvailableStreamFormat ***)((char *)this + 40);
  while (v12 != v10)
  {
    v14 = *--v12;
    v13 = v14;
    *v12 = 0;
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  }
  *((_QWORD *)this + 6) = v10;
  v15 = (const as::AvailableStreamFormat **)*((_QWORD *)a2 + 5);
  v16 = (const as::AvailableStreamFormat **)*((_QWORD *)a2 + 6);
  for (i = a2; v15 != v16; ++v15)
  {
    v17 = (as::AvailableStreamFormat *)operator new();
    as::AvailableStreamFormat::AvailableStreamFormat(v17, *v15);
    v19 = (as::AvailableStreamFormat **)*((_QWORD *)this + 6);
    v18 = *((_QWORD *)this + 7);
    if ((unint64_t)v19 >= v18)
    {
      v21 = *v11;
      v22 = v19 - *v11;
      v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 61)
LABEL_54:
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v24 = v18 - (_QWORD)v21;
      if (v24 >> 2 > v23)
        v23 = v24 >> 2;
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
        v25 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v25 = v23;
      v59 = (char *)this + 56;
      if (v25)
      {
        v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 56, v25);
        v21 = (as::AvailableStreamFormat **)*((_QWORD *)this + 5);
        v19 = (as::AvailableStreamFormat **)*((_QWORD *)this + 6);
      }
      else
      {
        v26 = 0;
      }
      v27 = (as::AvailableStreamFormat **)&v26[8 * v22];
      v28 = &v26[8 * v25];
      v58 = v28;
      *v27 = v17;
      *((_QWORD *)&v57 + 1) = v27 + 1;
      if (v19 == v21)
      {
        v20 = v27 + 1;
      }
      else
      {
        do
        {
          v29 = *--v19;
          *v19 = 0;
          *--v27 = v29;
        }
        while (v19 != v21);
        v20 = (_QWORD *)*((_QWORD *)&v57 + 1);
        v28 = v58;
      }
      v30 = *(_OWORD *)((char *)this + 40);
      *((_QWORD *)this + 5) = v27;
      *((_QWORD *)this + 6) = v20;
      v57 = v30;
      v31 = (char *)*((_QWORD *)this + 7);
      *((_QWORD *)this + 7) = v28;
      v58 = v31;
      v56 = v30;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v56);
    }
    else
    {
      *v19 = v17;
      v20 = v19 + 1;
    }
    *((_QWORD *)this + 6) = v20;
  }
  v32 = (_QWORD *)*((_QWORD *)this + 8);
  v34 = (_QWORD *)*((_QWORD *)this + 9);
  v33 = (as::AvailableStreamFormat ***)((char *)this + 64);
  while (v34 != v32)
  {
    v36 = *--v34;
    v35 = v36;
    *v34 = 0;
    if (v36)
      (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
  }
  *((_QWORD *)this + 9) = v32;
  v37 = (const as::AvailableStreamFormat **)*((_QWORD *)i + 8);
  for (j = (const as::AvailableStreamFormat **)*((_QWORD *)i + 9); v37 != j; ++v37)
  {
    v39 = (as::AvailableStreamFormat *)operator new();
    as::AvailableStreamFormat::AvailableStreamFormat(v39, *v37);
    v41 = (as::AvailableStreamFormat **)*((_QWORD *)this + 9);
    v40 = *((_QWORD *)this + 10);
    if ((unint64_t)v41 >= v40)
    {
      v43 = *v33;
      v44 = v41 - *v33;
      v45 = v44 + 1;
      if ((unint64_t)(v44 + 1) >> 61)
        goto LABEL_54;
      v46 = v40 - (_QWORD)v43;
      if (v46 >> 2 > v45)
        v45 = v46 >> 2;
      if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
        v47 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v47 = v45;
      v59 = (char *)this + 80;
      if (v47)
      {
        v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 80, v47);
        v43 = (as::AvailableStreamFormat **)*((_QWORD *)this + 8);
        v41 = (as::AvailableStreamFormat **)*((_QWORD *)this + 9);
      }
      else
      {
        v48 = 0;
      }
      v49 = (as::AvailableStreamFormat **)&v48[8 * v44];
      v50 = &v48[8 * v47];
      v58 = v50;
      *v49 = v39;
      *((_QWORD *)&v57 + 1) = v49 + 1;
      if (v41 == v43)
      {
        v42 = v49 + 1;
      }
      else
      {
        do
        {
          v51 = *--v41;
          *v41 = 0;
          *--v49 = v51;
        }
        while (v41 != v43);
        v42 = (_QWORD *)*((_QWORD *)&v57 + 1);
        v50 = v58;
      }
      v52 = *((_OWORD *)this + 4);
      *((_QWORD *)this + 8) = v49;
      *((_QWORD *)this + 9) = v42;
      v57 = v52;
      v53 = (char *)*((_QWORD *)this + 10);
      *((_QWORD *)this + 10) = v50;
      v58 = v53;
      v56 = v52;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v56);
    }
    else
    {
      *v41 = v39;
      v42 = v41 + 1;
    }
    *((_QWORD *)this + 9) = v42;
  }
  if (this != i)
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 16, *((caulk::xstring **)i + 2), *((caulk::xstring **)i + 3), (uint64_t)(*((_QWORD *)i + 3) - *((_QWORD *)i + 2)) >> 4);
  *((_DWORD *)this + 2) = *((_DWORD *)i + 2);
  result = *((__n128 *)i + 7);
  *((_DWORD *)this + 32) = *((_DWORD *)i + 32);
  *((__n128 *)this + 7) = result;
  return result;
}

as::server::HWStream *as::server::HWStream::operator=(as::server::HWStream *a1, const as::server::HWStream *a2)
{
  as::server::HWStream::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::HWStream::hardwareInfo(as::server::HWStream *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 11);
  if (!result)
    return as::server::HardwareInfo::default_instance(0);
  return result;
}

uint64_t as::server::HWStream::mutableHardwareInfo(as::server::HWStream *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 11);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3EC0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    v3 = *((_QWORD *)this + 11);
    *((_QWORD *)this + 11) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::HWStream::privateFormat(as::server::HWStream *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 12);
  if (!result)
    return as::StreamFormat::default_instance(0);
  return result;
}

as::StreamFormat *as::server::HWStream::mutablePrivateFormat(as::server::HWStream *this)
{
  as::StreamFormat *v1;
  double v3;
  uint64_t v4;

  v1 = (as::StreamFormat *)*((_QWORD *)this + 12);
  if (!v1)
  {
    v1 = (as::StreamFormat *)operator new();
    v3 = as::StreamFormat::StreamFormat(v1);
    v4 = *((_QWORD *)this + 12);
    *((_QWORD *)this + 12) = v1;
    if (v4)
      (*(void (**)(uint64_t, double))(*(_QWORD *)v4 + 8))(v4, v3);
  }
  return v1;
}

uint64_t as::server::HWStream::publicFormat(as::server::HWStream *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 13);
  if (!result)
    return as::StreamFormat::default_instance(0);
  return result;
}

as::StreamFormat *as::server::HWStream::mutablePublicFormat(as::server::HWStream *this)
{
  as::StreamFormat *v1;
  double v3;
  uint64_t v4;

  v1 = (as::StreamFormat *)*((_QWORD *)this + 13);
  if (!v1)
  {
    v1 = (as::StreamFormat *)operator new();
    v3 = as::StreamFormat::StreamFormat(v1);
    v4 = *((_QWORD *)this + 13);
    *((_QWORD *)this + 13) = v1;
    if (v4)
      (*(void (**)(uint64_t, double))(*(_QWORD *)v4 + 8))(v4, v3);
  }
  return v1;
}

uint64_t as::server::HWStream::HWStream(uint64_t a1, __n128 *a2)
{
  *(_QWORD *)a1 = &off_24BFE4438;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::HWStream::move_from((__n128 *)a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE4438;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::HWStream::move_from((__n128 *)a1, a2);
  return a1;
}

__n128 as::server::HWStream::move_from(__n128 *a1, __n128 *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  __n128 result;

  v2 = a1[5].n128_u64[1];
  a1[5].n128_u64[1] = a2[5].n128_u64[1];
  a2[5].n128_u64[1] = v2;
  v3 = a1[6].n128_u64[0];
  a1[6].n128_u64[0] = a2[6].n128_u64[0];
  a2[6].n128_u64[0] = v3;
  v4 = a1[6].n128_u64[1];
  a1[6].n128_u64[1] = a2[6].n128_u64[1];
  a2[6].n128_u64[1] = v4;
  v5 = a1[2].n128_u64[1];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = v5;
  v6 = a1[3].n128_u64[0];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a2[3].n128_u64[0] = v6;
  v7 = a1[3].n128_u64[1];
  a1[3].n128_u64[1] = a2[3].n128_u64[1];
  a2[3].n128_u64[1] = v7;
  v8 = a1[4].n128_u64[0];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[4].n128_u64[0] = v8;
  v9 = a1[4].n128_u64[1];
  a1[4].n128_u64[1] = a2[4].n128_u64[1];
  a2[4].n128_u64[1] = v9;
  v10 = a1[5].n128_u64[0];
  a1[5].n128_u64[0] = a2[5].n128_u64[0];
  a2[5].n128_u64[0] = v10;
  v11 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v11;
  v12 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v12;
  v13 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v13;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[7];
  a1[8].n128_u32[0] = a2[8].n128_u32[0];
  a1[7] = result;
  return result;
}

__n128 *as::server::HWStream::operator=(__n128 *a1, __n128 *a2)
{
  as::server::HWStream::move_from(a1, a2);
  return a1;
}

uint64_t as::server::HWStream::clear(as::server::HWStream *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  caulk::xstring *v14;
  uint64_t result;

  v2 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (_QWORD *)*((_QWORD *)this + 5);
  v6 = (_QWORD *)*((_QWORD *)this + 6);
  while (v6 != v5)
  {
    v8 = *--v6;
    v7 = v8;
    *v6 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  *((_QWORD *)this + 6) = v5;
  v9 = (_QWORD *)*((_QWORD *)this + 8);
  v10 = (_QWORD *)*((_QWORD *)this + 9);
  while (v10 != v9)
  {
    v12 = *--v10;
    v11 = v12;
    *v10 = 0;
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  }
  v14 = (caulk::xstring *)*((_QWORD *)this + 2);
  v13 = (char *)this + 16;
  *((_QWORD *)v13 + 7) = v9;
  result = std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v13, v14);
  *((_DWORD *)v13 - 2) = 0;
  *((_QWORD *)v13 + 12) = 0;
  *((_QWORD *)v13 + 13) = 0;
  *((_DWORD *)v13 + 28) = 0;
  return result;
}

uint64_t as::server::HWStream::isInitialized(as::server::HWStream *this)
{
  uint64_t result;
  as::AvailableStreamFormat **v3;
  as::AvailableStreamFormat **v4;
  as::AvailableStreamFormat **v5;
  as::AvailableStreamFormat **v6;

  if (!*((_QWORD *)this + 11))
    return 0;
  result = *((_QWORD *)this + 12);
  if (result)
  {
    result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
    if ((_DWORD)result)
    {
      result = *((_QWORD *)this + 13);
      if (result)
      {
        result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
        if ((_DWORD)result)
        {
          v3 = (as::AvailableStreamFormat **)*((_QWORD *)this + 5);
          v4 = (as::AvailableStreamFormat **)*((_QWORD *)this + 6);
          while (v3 != v4)
          {
            if ((as::AvailableStreamFormat::isInitialized(*v3) & 1) == 0)
              return 0;
            ++v3;
          }
          v5 = (as::AvailableStreamFormat **)*((_QWORD *)this + 8);
          v6 = (as::AvailableStreamFormat **)*((_QWORD *)this + 9);
          while (v5 != v6)
          {
            if ((as::AvailableStreamFormat::isInitialized(*v5) & 1) == 0)
              return 0;
            ++v5;
          }
          return (~*((_DWORD *)this + 2) & 0xF) == 0;
        }
      }
    }
  }
  return result;
}

BOOL as::server::HWStream::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  int64x2_t *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  BOOL v19;
  char v20;
  unsigned int v21;
  unint64_t v22;
  unint64_t v23;
  char v24;
  BOOL v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  as::AvailableStreamFormat *v40;
  unint64_t v41;
  as::AvailableStreamFormat **v42;
  _QWORD *v43;
  as::AvailableStreamFormat *v44;
  unint64_t v45;
  as::AvailableStreamFormat **v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  char v51;
  double v52;
  uint64_t v53;
  unint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  char v57;
  unsigned int v58;
  uint64_t v59;
  unint64_t v60;
  char v61;
  char v62;
  unsigned int v63;
  unint64_t v64;
  char v65;
  char v66;
  unsigned int v67;
  unint64_t v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  char v80;
  unsigned int v81;
  unint64_t v82;
  char v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  char v89;
  unsigned int v90;
  unint64_t v91;
  char v92;
  as::AvailableStreamFormat **v93;
  char *v94;
  _QWORD *v95;
  _QWORD *v96;
  as::AvailableStreamFormat *v97;
  int64x2_t v98;
  as::AvailableStreamFormat **v99;
  char *v100;
  _QWORD *v101;
  _QWORD *v102;
  as::AvailableStreamFormat *v103;
  int64x2_t v104;
  char *v105;
  char *v106;
  char *v107;
  int v108;
  int64x2_t *v111;
  void *__p;
  int64x2_t v113;
  char *v114;
  uint64_t v115;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v8 = (uint64_t *)(a1 + 16);
  v9 = a1 + 32;
  v111 = (int64x2_t *)(a1 + 64);
  v10 = a1 + 80;
  v11 = (int64x2_t *)(a1 + 40);
  v12 = a1 + 56;
  while (2)
  {
    v13 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      while (1)
      {
        v17 = v3 + 1;
        a2[1] = v3 + 1;
        v18 = *(_BYTE *)(v13 + v3);
        v16 |= (unint64_t)(v18 & 0x7F) << v14;
        if ((v18 & 0x80) == 0)
          goto LABEL_23;
        v14 += 7;
        v3 = v17;
        v19 = v15++ > 8;
        if (v19)
        {
          v16 = 0;
          goto LABEL_23;
        }
      }
    }
    v20 = 0;
    v21 = 0;
    v16 = 0;
    if (v3 <= v2)
      v22 = v2;
    else
      v22 = v3;
    do
    {
      if (v22 == v3)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v23 = v3++;
      v24 = *(_BYTE *)(v13 + v23);
      a2[1] = v3;
      v16 |= (unint64_t)(v24 & 0x7F) << v20;
      if ((v24 & 0x80) == 0)
        goto LABEL_22;
      v20 += 7;
      v25 = v21++ >= 9;
    }
    while (!v25);
    v16 = 0;
LABEL_22:
    v17 = v23 + 1;
LABEL_23:
    if ((v16 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v16 >> 3))
    {
      case 1u:
        if (v17 > 0xFFFFFFFFFFFFFFF5 || v17 + 10 > v2)
        {
          v66 = 0;
          v67 = 0;
          v28 = 0;
          if (v2 <= v17)
            v2 = v17;
          do
          {
            if (v2 == v17)
            {
              v28 = 0;
              *((_BYTE *)a2 + 24) = 1;
              goto LABEL_143;
            }
            v68 = v17 + 1;
            v69 = *(_BYTE *)(v13 + v17);
            a2[1] = v68;
            v28 |= (unint64_t)(v69 & 0x7F) << v66;
            if ((v69 & 0x80) == 0)
              goto LABEL_143;
            v66 += 7;
            v17 = v68;
            v25 = v67++ >= 9;
          }
          while (!v25);
LABEL_80:
          v28 = 0;
        }
        else
        {
          v26 = 0;
          v27 = 0;
          v28 = 0;
          while (1)
          {
            v29 = v17 + 1;
            a2[1] = v17 + 1;
            v30 = *(_BYTE *)(v13 + v17);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0)
              break;
            v26 += 7;
            v17 = v29;
            v19 = v27++ > 8;
            if (v19)
              goto LABEL_80;
          }
        }
LABEL_143:
        *(_QWORD *)(a1 + 112) = v28;
        v108 = *(_DWORD *)(a1 + 8) | 1;
        goto LABEL_148;
      case 2u:
        v36 = operator new();
        *(_QWORD *)v36 = &off_24BFE3EC0;
        *(_DWORD *)(v36 + 8) = 0;
        *(_OWORD *)(v36 + 16) = 0u;
        *(_OWORD *)(v36 + 32) = 0u;
        *(_OWORD *)(v36 + 48) = 0u;
        v39 = *(_QWORD *)(a1 + 88);
        *(_QWORD *)(a1 + 88) = v36;
        if (v39)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
          v36 = *(_QWORD *)(a1 + 88);
        }
        goto LABEL_56;
      case 5u:
        if (v17 <= 0xFFFFFFFFFFFFFFF5 && v17 + 10 <= v2)
        {
          v31 = 0;
          v32 = 0;
          v33 = 0;
          do
          {
            v34 = v17 + 1;
            a2[1] = v17 + 1;
            v35 = *(_BYTE *)(v13 + v17);
            v33 |= (unint64_t)(v35 & 0x7F) << v31;
            if ((v35 & 0x80) == 0)
              goto LABEL_141;
            v31 += 7;
            v17 = v34;
            v19 = v32++ > 8;
          }
          while (!v19);
LABEL_73:
          LODWORD(v33) = 0;
          goto LABEL_141;
        }
        v62 = 0;
        v63 = 0;
        v33 = 0;
        if (v2 <= v17)
          v2 = v17;
        while (v2 != v17)
        {
          v64 = v17 + 1;
          v65 = *(_BYTE *)(v13 + v17);
          a2[1] = v64;
          v33 |= (unint64_t)(v65 & 0x7F) << v62;
          if ((v65 & 0x80) == 0)
            goto LABEL_141;
          v62 += 7;
          v17 = v64;
          v25 = v63++ >= 9;
          if (v25)
            goto LABEL_73;
        }
        LODWORD(v33) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_141:
        *(_DWORD *)(a1 + 128) = v33;
        v108 = *(_DWORD *)(a1 + 8) | 2;
        goto LABEL_148;
      case 0xAu:
        if (v17 <= 0xFFFFFFFFFFFFFFF5 && v17 + 10 <= v2)
        {
          v47 = 0;
          v48 = 0;
          v49 = 0;
          do
          {
            v50 = v17 + 1;
            a2[1] = v17 + 1;
            v51 = *(_BYTE *)(v13 + v17);
            v49 |= (unint64_t)(v51 & 0x7F) << v47;
            if ((v51 & 0x80) == 0)
              goto LABEL_145;
            v47 += 7;
            v17 = v50;
            v19 = v48++ > 8;
          }
          while (!v19);
LABEL_103:
          LODWORD(v49) = 0;
          goto LABEL_145;
        }
        v80 = 0;
        v81 = 0;
        v49 = 0;
        if (v2 <= v17)
          v2 = v17;
        while (v2 != v17)
        {
          v82 = v17 + 1;
          v83 = *(_BYTE *)(v13 + v17);
          a2[1] = v82;
          v49 |= (unint64_t)(v83 & 0x7F) << v80;
          if ((v83 & 0x80) == 0)
            goto LABEL_145;
          v80 += 7;
          v17 = v82;
          v25 = v81++ >= 9;
          if (v25)
            goto LABEL_103;
        }
        LODWORD(v49) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_145:
        *(_DWORD *)(a1 + 120) = v49;
        v108 = *(_DWORD *)(a1 + 8) | 4;
        goto LABEL_148;
      case 0xBu:
        v36 = operator new();
        v52 = as::StreamFormat::StreamFormat((as::StreamFormat *)v36);
        v53 = *(_QWORD *)(a1 + 96);
        *(_QWORD *)(a1 + 96) = v36;
        if (v53)
        {
          (*(void (**)(uint64_t, double))(*(_QWORD *)v53 + 8))(v53, v52);
          v36 = *(_QWORD *)(a1 + 96);
        }
        goto LABEL_56;
      case 0xCu:
        v36 = operator new();
        v37 = as::StreamFormat::StreamFormat((as::StreamFormat *)v36);
        v38 = *(_QWORD *)(a1 + 104);
        *(_QWORD *)(a1 + 104) = v36;
        if (v38)
        {
          (*(void (**)(uint64_t, double))(*(_QWORD *)v38 + 8))(v38, v37);
          v36 = *(_QWORD *)(a1 + 104);
        }
LABEL_56:
        if (!PB::Reader::placeMark())
          return 0;
        goto LABEL_138;
      case 0xDu:
        v40 = (as::AvailableStreamFormat *)operator new();
        as::AvailableStreamFormat::AvailableStreamFormat(v40);
        v42 = *(as::AvailableStreamFormat ***)(a1 + 48);
        v41 = *(_QWORD *)(a1 + 56);
        if ((unint64_t)v42 >= v41)
        {
          v70 = ((uint64_t)v42 - v11->i64[0]) >> 3;
          if ((unint64_t)(v70 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v71 = v41 - v11->i64[0];
          v72 = v71 >> 2;
          if (v71 >> 2 <= (unint64_t)(v70 + 1))
            v72 = v70 + 1;
          if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8)
            v73 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v73 = v72;
          v115 = v12;
          if (v73)
            v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v12, v73);
          else
            v74 = 0;
          v93 = (as::AvailableStreamFormat **)&v74[8 * v70];
          v94 = &v74[8 * v73];
          v114 = v94;
          *v93 = v40;
          v43 = v93 + 1;
          v113.i64[1] = (uint64_t)(v93 + 1);
          v96 = *(_QWORD **)(a1 + 40);
          v95 = *(_QWORD **)(a1 + 48);
          if (v95 == v96)
          {
            v98 = vdupq_n_s64((unint64_t)v95);
          }
          else
          {
            do
            {
              v97 = (as::AvailableStreamFormat *)*--v95;
              *v95 = 0;
              *--v93 = v97;
            }
            while (v95 != v96);
            v98 = *v11;
            v43 = (_QWORD *)v113.i64[1];
            v94 = v114;
          }
          *(_QWORD *)(a1 + 40) = v93;
          *(_QWORD *)(a1 + 48) = v43;
          v113 = v98;
          v106 = *(char **)(a1 + 56);
          *(_QWORD *)(a1 + 56) = v94;
          v114 = v106;
          __p = (void *)v98.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v42 = v40;
          v43 = v42 + 1;
        }
        *(_QWORD *)(a1 + 48) = v43;
        goto LABEL_137;
      case 0xEu:
        v44 = (as::AvailableStreamFormat *)operator new();
        as::AvailableStreamFormat::AvailableStreamFormat(v44);
        v46 = *(as::AvailableStreamFormat ***)(a1 + 72);
        v45 = *(_QWORD *)(a1 + 80);
        if ((unint64_t)v46 >= v45)
        {
          v75 = ((uint64_t)v46 - v111->i64[0]) >> 3;
          if ((unint64_t)(v75 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v76 = v45 - v111->i64[0];
          v77 = v76 >> 2;
          if (v76 >> 2 <= (unint64_t)(v75 + 1))
            v77 = v75 + 1;
          if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8)
            v78 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v78 = v77;
          v115 = v10;
          if (v78)
            v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v10, v78);
          else
            v79 = 0;
          v99 = (as::AvailableStreamFormat **)&v79[8 * v75];
          v100 = &v79[8 * v78];
          v114 = v100;
          *v99 = v44;
          v43 = v99 + 1;
          v113.i64[1] = (uint64_t)(v99 + 1);
          v102 = *(_QWORD **)(a1 + 64);
          v101 = *(_QWORD **)(a1 + 72);
          if (v101 == v102)
          {
            v104 = vdupq_n_s64((unint64_t)v101);
          }
          else
          {
            do
            {
              v103 = (as::AvailableStreamFormat *)*--v101;
              *v101 = 0;
              *--v99 = v103;
            }
            while (v101 != v102);
            v104 = *v111;
            v43 = (_QWORD *)v113.i64[1];
            v100 = v114;
          }
          *(_QWORD *)(a1 + 64) = v99;
          *(_QWORD *)(a1 + 72) = v43;
          v113 = v104;
          v107 = *(char **)(a1 + 80);
          *(_QWORD *)(a1 + 80) = v100;
          v114 = v107;
          __p = (void *)v104.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v46 = v44;
          v43 = v46 + 1;
        }
        *(_QWORD *)(a1 + 72) = v43;
LABEL_137:
        v36 = *(v43 - 1);
        if ((PB::Reader::placeMark() & 1) == 0)
          return 0;
LABEL_138:
        if (((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v36 + 16))(v36, a2) & 1) != 0)
        {
          PB::Reader::recallMark();
LABEL_149:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          continue;
        }
        return 0;
      case 0xFu:
        if (v17 <= 0xFFFFFFFFFFFFFFF5 && v17 + 10 <= v2)
        {
          v57 = 0;
          v58 = 0;
          v59 = 0;
          do
          {
            v60 = v17 + 1;
            a2[1] = v17 + 1;
            v61 = *(_BYTE *)(v13 + v17);
            v59 |= (unint64_t)(v61 & 0x7F) << v57;
            if ((v61 & 0x80) == 0)
              goto LABEL_147;
            v57 += 7;
            v17 = v60;
            v19 = v58++ > 8;
          }
          while (!v19);
LABEL_118:
          LODWORD(v59) = 0;
          goto LABEL_147;
        }
        v89 = 0;
        v90 = 0;
        v59 = 0;
        if (v2 <= v17)
          v2 = v17;
        while (v2 != v17)
        {
          v91 = v17 + 1;
          v92 = *(_BYTE *)(v13 + v17);
          a2[1] = v91;
          v59 |= (unint64_t)(v92 & 0x7F) << v89;
          if ((v92 & 0x80) == 0)
            goto LABEL_147;
          v89 += 7;
          v17 = v91;
          v25 = v90++ >= 9;
          if (v25)
            goto LABEL_118;
        }
        LODWORD(v59) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_147:
        *(_DWORD *)(a1 + 124) = v59;
        v108 = *(_DWORD *)(a1 + 8) | 8;
LABEL_148:
        *(_DWORD *)(a1 + 8) = v108;
        goto LABEL_149;
      case 0x10u:
        v55 = *(_QWORD **)(a1 + 24);
        v54 = *(_QWORD *)(a1 + 32);
        if ((unint64_t)v55 >= v54)
        {
          v84 = ((uint64_t)v55 - *v8) >> 4;
          v85 = v84 + 1;
          if ((unint64_t)(v84 + 1) >> 60)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v86 = v54 - *v8;
          if (v86 >> 3 > v85)
            v85 = v86 >> 3;
          if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF0)
            v87 = 0xFFFFFFFFFFFFFFFLL;
          else
            v87 = v85;
          v115 = v9;
          if (v87)
            v88 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v87);
          else
            v88 = 0;
          v105 = &v88[16 * v84];
          __p = v88;
          v113.i64[0] = (uint64_t)v105;
          v114 = &v88[16 * v87];
          *(_QWORD *)v105 = 0;
          *((_QWORD *)v105 + 1) = 0;
          v113.i64[1] = (uint64_t)(v105 + 16);
          std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
          v56 = *(_QWORD **)(a1 + 24);
          std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v55 = 0;
          v55[1] = 0;
          v56 = v55 + 2;
          *(_QWORD *)(a1 + 24) = v55 + 2;
        }
        *(_QWORD *)(a1 + 24) = v56;
        __p = 0;
        v113 = 0uLL;
        PB::Reader::read();
        caulk::xstring::assign();
        if (v113.i8[15] < 0)
          operator delete(__p);
        goto LABEL_149;
      default:
        goto LABEL_149;
    }
  }
}

void sub_2068091C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::HWStream::writeTo(as::server::HWStream *this, PB::Writer *a2)
{
  const PB::Base *v4;
  int v5;
  const PB::Base *v6;
  const PB::Base *v7;
  const PB::Base **v8;
  const PB::Base **v9;
  const PB::Base *v10;
  const PB::Base **v11;
  const PB::Base **v12;
  const PB::Base *v13;
  caulk::xstring *v14;
  caulk::xstring *v15;
  char *v16;
  void *__p;
  char v18;

  if ((*((_BYTE *)this + 8) & 1) != 0)
    PB::Writer::writeVarInt(a2);
  v4 = (const PB::Base *)*((_QWORD *)this + 11);
  if (v4)
    PB::Writer::writeSubmessage(a2, v4);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 2) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0)
    PB::Writer::writeVarInt(a2);
  v6 = (const PB::Base *)*((_QWORD *)this + 12);
  if (v6)
    PB::Writer::writeSubmessage(a2, v6);
  v7 = (const PB::Base *)*((_QWORD *)this + 13);
  if (v7)
    PB::Writer::writeSubmessage(a2, v7);
  v8 = (const PB::Base **)*((_QWORD *)this + 5);
  v9 = (const PB::Base **)*((_QWORD *)this + 6);
  while (v8 != v9)
  {
    v10 = *v8++;
    PB::Writer::writeSubmessage(a2, v10);
  }
  v11 = (const PB::Base **)*((_QWORD *)this + 8);
  v12 = (const PB::Base **)*((_QWORD *)this + 9);
  while (v11 != v12)
  {
    v13 = *v11++;
    PB::Writer::writeSubmessage(a2, v13);
  }
  if ((*((_BYTE *)this + 8) & 8) != 0)
    PB::Writer::writeVarInt(a2);
  v15 = (caulk::xstring *)*((_QWORD *)this + 2);
  v14 = (caulk::xstring *)*((_QWORD *)this + 3);
  while (v15 != v14)
  {
    v16 = (char *)caulk::xstring::c_str(v15);
    std::string::basic_string[abi:ne180100]<0>(&__p, v16);
    PB::Writer::write();
    if (v18 < 0)
      operator delete(__p);
    v15 = (caulk::xstring *)((char *)v15 + 16);
  }
}

void sub_206809368(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::HWStream::formatText(as::server::HWStream *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  caulk::xstring *v15;
  caulk::xstring *i;
  char *v17;
  void *__p;
  char v20;

  PB::TextFormatter::beginObject(a2, a3);
  if ((*((_BYTE *)this + 8) & 1) != 0)
    PB::TextFormatter::format(a2, "objectToken");
  v5 = *((_QWORD *)this + 11);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "hardwareInfo");
  v6 = *((_DWORD *)this + 2);
  if ((v6 & 2) != 0)
  {
    PB::TextFormatter::format(a2, "direction");
    v6 = *((_DWORD *)this + 2);
  }
  if ((v6 & 4) != 0)
    PB::TextFormatter::format(a2, "startingChannel");
  v7 = *((_QWORD *)this + 12);
  if (v7)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v7 + 32))(v7, a2, "privateFormat");
  v8 = *((_QWORD *)this + 13);
  if (v8)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "publicFormat");
  v9 = (uint64_t *)*((_QWORD *)this + 5);
  v10 = (uint64_t *)*((_QWORD *)this + 6);
  while (v9 != v10)
  {
    v11 = *v9++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v11 + 32))(v11, a2, "availablePrivateFormats");
  }
  v12 = (uint64_t *)*((_QWORD *)this + 8);
  v13 = (uint64_t *)*((_QWORD *)this + 9);
  while (v12 != v13)
  {
    v14 = *v12++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v14 + 32))(v14, a2, "availablePublicFormats");
  }
  if ((*((_BYTE *)this + 8) & 8) != 0)
    PB::TextFormatter::format(a2, "latency");
  v15 = (caulk::xstring *)*((_QWORD *)this + 2);
  for (i = (caulk::xstring *)*((_QWORD *)this + 3); v15 != i; v15 = (caulk::xstring *)((char *)v15 + 16))
  {
    v17 = (char *)caulk::xstring::c_str(v15);
    std::string::basic_string[abi:ne180100]<0>(&__p, v17);
    PB::TextFormatter::format();
    if (v20 < 0)
      operator delete(__p);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_20680955C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::HWStream::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  int v36;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  v4 = *(_QWORD *)(a1 + 112) == *(_QWORD *)(a2 + 112) && *(_QWORD *)(a1 + 120) == *(_QWORD *)(a2 + 120);
  if (!v4 || *(_DWORD *)(a1 + 128) != (unint64_t)*(unsigned int *)(a2 + 128))
    return 0;
  v7 = *(_QWORD *)(a1 + 88);
  v8 = *(_QWORD *)(a2 + 88);
  if (v7 && v8)
  {
    if (!as::server::HardwareInfo::operator==((_DWORD *)v7, (_DWORD *)v8))
      return 0;
  }
  else if (v7 | v8)
  {
    return 0;
  }
  v9 = *(_QWORD *)(a1 + 96);
  v10 = *(_QWORD *)(a2 + 96);
  if (v9 && v10)
  {
    if (!as::StreamFormat::operator==(v9, v10))
      return 0;
  }
  else if (v9 | v10)
  {
    return 0;
  }
  v11 = *(_QWORD *)(a1 + 104);
  v12 = *(_QWORD *)(a2 + 104);
  if (v11 && v12)
  {
    if (!as::StreamFormat::operator==(v11, v12))
      return 0;
  }
  else if (v11 | v12)
  {
    return 0;
  }
  v14 = *(_QWORD *)(a1 + 40);
  v13 = *(_QWORD *)(a1 + 48);
  v15 = (v13 - v14) >> 3;
  if (v15 != (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
    return 0;
  if (v13 != v14)
  {
    v16 = 0;
    if (v15 <= 1)
      v17 = 1;
    else
      v17 = (v13 - v14) >> 3;
    do
    {
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v16);
      v19 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v16);
      if (v18)
        v20 = v19 == 0;
      else
        v20 = 1;
      if (v20)
      {
        if (v18 | v19)
          return 0;
      }
      else if (!as::AvailableStreamFormat::operator==(v18, v19))
      {
        return 0;
      }
      ++v16;
    }
    while (v17 != v16);
  }
  v22 = *(_QWORD *)(a1 + 64);
  v21 = *(_QWORD *)(a1 + 72);
  v23 = (v21 - v22) >> 3;
  if (v23 != (uint64_t)(*(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64)) >> 3)
    return 0;
  if (v21 != v22)
  {
    v24 = 0;
    if (v23 <= 1)
      v25 = 1;
    else
      v25 = (v21 - v22) >> 3;
    do
    {
      v26 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v24);
      v27 = *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v24);
      if (v26)
        v28 = v27 == 0;
      else
        v28 = 1;
      if (v28)
      {
        if (v26 | v27)
          return 0;
      }
      else if (!as::AvailableStreamFormat::operator==(v26, v27))
      {
        return 0;
      }
      ++v24;
    }
    while (v25 != v24);
  }
  v30 = *(_QWORD *)(a1 + 16);
  v29 = *(_QWORD *)(a1 + 24);
  v31 = (v29 - v30) >> 4;
  if (v31 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 4)
    return 0;
  if (v29 == v30)
    return 1;
  if (v31 <= 1)
    v32 = 1;
  else
    v32 = (v29 - v30) >> 4;
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 16), *(const caulk::xstring **)(a2 + 16)))
    return 0;
  v33 = 1;
  v34 = 16;
  do
  {
    v35 = v33;
    if (v32 == v33)
      break;
    v36 = caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 16) + v34), (const caulk::xstring *)(*(_QWORD *)(a2 + 16) + v34));
    v33 = v35 + 1;
    v34 += 16;
  }
  while (!v36);
  return v35 >= v31;
}

uint64_t as::server::HWStream::clearHardwareInfo(as::server::HWStream *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::HWStream::clearPrivateFormat(as::server::HWStream *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::HWStream::clearPublicFormat(as::server::HWStream *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void as::server::HWStream::addAvailablePrivateFormats(as::server::HWStream *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  as::AvailableStreamFormat *v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  char *v24;
  char *v25;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v25 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v24 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v23 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v23 + 1);
      v14 = v24;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v23 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v24 = v17;
    v22 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  v18 = (as::AvailableStreamFormat *)operator new();
  v19 = as::AvailableStreamFormat::AvailableStreamFormat(v18);
  v20 = *(v6 - 1);
  *(v6 - 1) = v21;
  if (v20)
    (*(void (**)(uint64_t, double))(*(_QWORD *)v20 + 8))(v20, v19);
}

void as::server::HWStream::addAvailablePublicFormats(as::server::HWStream *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  as::AvailableStreamFormat *v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  char *v24;
  char *v25;

  v4 = *((_QWORD *)this + 10);
  v2 = (char *)this + 80;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v25 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 8);
      v5 = (_QWORD *)*((_QWORD *)this + 9);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v24 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v23 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v23 + 1);
      v14 = v24;
    }
    v16 = *((_OWORD *)this + 4);
    *((_QWORD *)this + 8) = v13;
    *((_QWORD *)this + 9) = v6;
    v23 = v16;
    v17 = (char *)*((_QWORD *)this + 10);
    *((_QWORD *)this + 10) = v14;
    v24 = v17;
    v22 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 9) = v6;
  v18 = (as::AvailableStreamFormat *)operator new();
  v19 = as::AvailableStreamFormat::AvailableStreamFormat(v18);
  v20 = *(v6 - 1);
  *(v6 - 1) = v21;
  if (v20)
    (*(void (**)(uint64_t, double))(*(_QWORD *)v20 + 8))(v20, v19);
}

uint64_t as::server::Device::default_instance(as::server::Device *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4390;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_QWORD *)(v3 + 112) = 0;
    as::server::Device::default_instance(void)::gInstance = v3;
  }
  return as::server::Device::default_instance(void)::gInstance;
}

void sub_206809B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::Device::Device(as::server::Device *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE4390;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 14) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE4390;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 14) = 0;
  return result;
}

as::server::Device *as::server::Device::Device(as::server::Device *this, const as::server::Device *a2)
{
  *(_QWORD *)this = &off_24BFE4390;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Device::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4390;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Device::copy_from(this, a2);
  return this;
}

void as::server::Device::copy_from(as::server::Device *this, const as::server::Device *a2)
{
  _QWORD *v3;
  as::server::HWStream ***v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  const as::server::HWStream **v8;
  const as::server::HWStream **i;
  as::server::HWStream *v10;
  const as::server::HWStream *v11;
  unint64_t v12;
  as::server::HWStream **v13;
  _QWORD *v14;
  as::server::HWStream **v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  as::server::HWStream **v21;
  char *v22;
  as::server::HWStream *v23;
  __int128 v24;
  char *v25;
  _QWORD *v26;
  as::server::HWStream ***v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  const as::server::HWStream **v31;
  const as::server::HWStream **j;
  as::server::HWStream *v33;
  const as::server::HWStream *v34;
  unint64_t v35;
  as::server::HWStream **v36;
  _QWORD *v37;
  as::server::HWStream **v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  as::server::HWStream **v44;
  char *v45;
  as::server::HWStream *v46;
  __int128 v47;
  char *v48;
  _QWORD *v49;
  uint64_t **v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  const as::server::Port **v54;
  const as::server::Port **k;
  uint64_t v56;
  const as::server::Port *v57;
  unint64_t v58;
  uint64_t *v59;
  _QWORD *v60;
  uint64_t *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  uint64_t *v67;
  char *v68;
  uint64_t v69;
  __int128 v70;
  char *v71;
  _QWORD *v72;
  uint64_t **v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  const as::server::Port **v77;
  const as::server::Port **m;
  uint64_t v79;
  const as::server::Port *v80;
  unint64_t v81;
  uint64_t *v82;
  _QWORD *v83;
  uint64_t *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  uint64_t *v90;
  char *v91;
  uint64_t v92;
  __int128 v93;
  char *v94;
  uint64_t v96;
  __int128 v97;
  char *v98;
  char *v99;

  v3 = (_QWORD *)*((_QWORD *)this + 2);
  v5 = (_QWORD *)*((_QWORD *)this + 3);
  v4 = (as::server::HWStream ***)((char *)this + 16);
  while (v5 != v3)
  {
    v7 = *--v5;
    v6 = v7;
    *v5 = 0;
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  *((_QWORD *)this + 3) = v3;
  v8 = (const as::server::HWStream **)*((_QWORD *)a2 + 2);
  for (i = (const as::server::HWStream **)*((_QWORD *)a2 + 3); v8 != i; ++v8)
  {
    v10 = (as::server::HWStream *)operator new();
    v11 = *v8;
    *(_QWORD *)v10 = &off_24BFE4438;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 6) = 0u;
    as::server::HWStream::copy_from(v10, v11);
    v13 = (as::server::HWStream **)*((_QWORD *)this + 3);
    v12 = *((_QWORD *)this + 4);
    if ((unint64_t)v13 >= v12)
    {
      v15 = *v4;
      v16 = v13 - *v4;
      v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61)
LABEL_90:
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v18 = v12 - (_QWORD)v15;
      if (v18 >> 2 > v17)
        v17 = v18 >> 2;
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v17;
      v99 = (char *)this + 32;
      if (v19)
      {
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v19);
        v15 = (as::server::HWStream **)*((_QWORD *)this + 2);
        v13 = (as::server::HWStream **)*((_QWORD *)this + 3);
      }
      else
      {
        v20 = 0;
      }
      v21 = (as::server::HWStream **)&v20[8 * v16];
      v22 = &v20[8 * v19];
      v98 = v22;
      *v21 = v10;
      *((_QWORD *)&v97 + 1) = v21 + 1;
      if (v13 == v15)
      {
        v14 = v21 + 1;
      }
      else
      {
        do
        {
          v23 = *--v13;
          *v13 = 0;
          *--v21 = v23;
        }
        while (v13 != v15);
        v14 = (_QWORD *)*((_QWORD *)&v97 + 1);
        v22 = v98;
      }
      v24 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v21;
      *((_QWORD *)this + 3) = v14;
      v97 = v24;
      v25 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v22;
      v98 = v25;
      v96 = v24;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v96);
    }
    else
    {
      *v13 = v10;
      v14 = v13 + 1;
    }
    *((_QWORD *)this + 3) = v14;
  }
  v26 = (_QWORD *)*((_QWORD *)this + 5);
  v28 = (_QWORD *)*((_QWORD *)this + 6);
  v27 = (as::server::HWStream ***)((char *)this + 40);
  while (v28 != v26)
  {
    v30 = *--v28;
    v29 = v30;
    *v28 = 0;
    if (v30)
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  }
  *((_QWORD *)this + 6) = v26;
  v31 = (const as::server::HWStream **)*((_QWORD *)a2 + 5);
  for (j = (const as::server::HWStream **)*((_QWORD *)a2 + 6); v31 != j; ++v31)
  {
    v33 = (as::server::HWStream *)operator new();
    v34 = *v31;
    *(_QWORD *)v33 = &off_24BFE4438;
    *((_OWORD *)v33 + 1) = 0u;
    *((_OWORD *)v33 + 2) = 0u;
    *((_OWORD *)v33 + 3) = 0u;
    *((_OWORD *)v33 + 4) = 0u;
    *((_OWORD *)v33 + 5) = 0u;
    *((_OWORD *)v33 + 6) = 0u;
    as::server::HWStream::copy_from(v33, v34);
    v36 = (as::server::HWStream **)*((_QWORD *)this + 6);
    v35 = *((_QWORD *)this + 7);
    if ((unint64_t)v36 >= v35)
    {
      v38 = *v27;
      v39 = v36 - *v27;
      v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 61)
        goto LABEL_90;
      v41 = v35 - (_QWORD)v38;
      if (v41 >> 2 > v40)
        v40 = v41 >> 2;
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
        v42 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v42 = v40;
      v99 = (char *)this + 56;
      if (v42)
      {
        v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 56, v42);
        v38 = (as::server::HWStream **)*((_QWORD *)this + 5);
        v36 = (as::server::HWStream **)*((_QWORD *)this + 6);
      }
      else
      {
        v43 = 0;
      }
      v44 = (as::server::HWStream **)&v43[8 * v39];
      v45 = &v43[8 * v42];
      v98 = v45;
      *v44 = v33;
      *((_QWORD *)&v97 + 1) = v44 + 1;
      if (v36 == v38)
      {
        v37 = v44 + 1;
      }
      else
      {
        do
        {
          v46 = *--v36;
          *v36 = 0;
          *--v44 = v46;
        }
        while (v36 != v38);
        v37 = (_QWORD *)*((_QWORD *)&v97 + 1);
        v45 = v98;
      }
      v47 = *(_OWORD *)((char *)this + 40);
      *((_QWORD *)this + 5) = v44;
      *((_QWORD *)this + 6) = v37;
      v97 = v47;
      v48 = (char *)*((_QWORD *)this + 7);
      *((_QWORD *)this + 7) = v45;
      v98 = v48;
      v96 = v47;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v96);
    }
    else
    {
      *v36 = v33;
      v37 = v36 + 1;
    }
    *((_QWORD *)this + 6) = v37;
  }
  v49 = (_QWORD *)*((_QWORD *)this + 8);
  v51 = (_QWORD *)*((_QWORD *)this + 9);
  v50 = (uint64_t **)((char *)this + 64);
  while (v51 != v49)
  {
    v53 = *--v51;
    v52 = v53;
    *v51 = 0;
    if (v53)
      (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  }
  *((_QWORD *)this + 9) = v49;
  v54 = (const as::server::Port **)*((_QWORD *)a2 + 8);
  for (k = (const as::server::Port **)*((_QWORD *)a2 + 9); v54 != k; ++v54)
  {
    v56 = operator new();
    v57 = *v54;
    *(_QWORD *)v56 = &off_24BFE4320;
    *(_OWORD *)(v56 + 16) = 0u;
    *(_OWORD *)(v56 + 32) = 0u;
    *(_OWORD *)(v56 + 48) = 0u;
    *(_OWORD *)(v56 + 64) = 0u;
    *(_OWORD *)(v56 + 80) = 0u;
    *(_OWORD *)(v56 + 96) = 0u;
    *(_OWORD *)(v56 + 112) = 0u;
    *(_QWORD *)(v56 + 128) = 0;
    as::server::Port::copy_from((as::server::Port *)v56, v57);
    v59 = (uint64_t *)*((_QWORD *)this + 9);
    v58 = *((_QWORD *)this + 10);
    if ((unint64_t)v59 >= v58)
    {
      v61 = *v50;
      v62 = v59 - *v50;
      v63 = v62 + 1;
      if ((unint64_t)(v62 + 1) >> 61)
LABEL_91:
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v64 = v58 - (_QWORD)v61;
      if (v64 >> 2 > v63)
        v63 = v64 >> 2;
      if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
        v65 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v65 = v63;
      v99 = (char *)this + 80;
      if (v65)
      {
        v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 80, v65);
        v61 = (uint64_t *)*((_QWORD *)this + 8);
        v59 = (uint64_t *)*((_QWORD *)this + 9);
      }
      else
      {
        v66 = 0;
      }
      v67 = (uint64_t *)&v66[8 * v62];
      v68 = &v66[8 * v65];
      v98 = v68;
      *v67 = v56;
      *((_QWORD *)&v97 + 1) = v67 + 1;
      if (v59 == v61)
      {
        v60 = v67 + 1;
      }
      else
      {
        do
        {
          v69 = *--v59;
          *v59 = 0;
          *--v67 = v69;
        }
        while (v59 != v61);
        v60 = (_QWORD *)*((_QWORD *)&v97 + 1);
        v68 = v98;
      }
      v70 = *((_OWORD *)this + 4);
      *((_QWORD *)this + 8) = v67;
      *((_QWORD *)this + 9) = v60;
      v97 = v70;
      v71 = (char *)*((_QWORD *)this + 10);
      *((_QWORD *)this + 10) = v68;
      v98 = v71;
      v96 = v70;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v96);
    }
    else
    {
      *v59 = v56;
      v60 = v59 + 1;
    }
    *((_QWORD *)this + 9) = v60;
  }
  v72 = (_QWORD *)*((_QWORD *)this + 11);
  v74 = (_QWORD *)*((_QWORD *)this + 12);
  v73 = (uint64_t **)((char *)this + 88);
  while (v74 != v72)
  {
    v76 = *--v74;
    v75 = v76;
    *v74 = 0;
    if (v76)
      (*(void (**)(uint64_t))(*(_QWORD *)v75 + 8))(v75);
  }
  *((_QWORD *)this + 12) = v72;
  v77 = (const as::server::Port **)*((_QWORD *)a2 + 11);
  for (m = (const as::server::Port **)*((_QWORD *)a2 + 12); v77 != m; ++v77)
  {
    v79 = operator new();
    v80 = *v77;
    *(_QWORD *)v79 = &off_24BFE4320;
    *(_OWORD *)(v79 + 16) = 0u;
    *(_OWORD *)(v79 + 32) = 0u;
    *(_OWORD *)(v79 + 48) = 0u;
    *(_OWORD *)(v79 + 64) = 0u;
    *(_OWORD *)(v79 + 80) = 0u;
    *(_OWORD *)(v79 + 96) = 0u;
    *(_OWORD *)(v79 + 112) = 0u;
    *(_QWORD *)(v79 + 128) = 0;
    as::server::Port::copy_from((as::server::Port *)v79, v80);
    v82 = (uint64_t *)*((_QWORD *)this + 12);
    v81 = *((_QWORD *)this + 13);
    if ((unint64_t)v82 >= v81)
    {
      v84 = *v73;
      v85 = v82 - *v73;
      v86 = v85 + 1;
      if ((unint64_t)(v85 + 1) >> 61)
        goto LABEL_91;
      v87 = v81 - (_QWORD)v84;
      if (v87 >> 2 > v86)
        v86 = v87 >> 2;
      if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
        v88 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v88 = v86;
      v99 = (char *)this + 104;
      if (v88)
      {
        v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 104, v88);
        v84 = (uint64_t *)*((_QWORD *)this + 11);
        v82 = (uint64_t *)*((_QWORD *)this + 12);
      }
      else
      {
        v89 = 0;
      }
      v90 = (uint64_t *)&v89[8 * v85];
      v91 = &v89[8 * v88];
      v98 = v91;
      *v90 = v79;
      *((_QWORD *)&v97 + 1) = v90 + 1;
      if (v82 == v84)
      {
        v83 = v90 + 1;
      }
      else
      {
        do
        {
          v92 = *--v82;
          *v82 = 0;
          *--v90 = v92;
        }
        while (v82 != v84);
        v83 = (_QWORD *)*((_QWORD *)&v97 + 1);
        v91 = v98;
      }
      v93 = *(_OWORD *)((char *)this + 88);
      *((_QWORD *)this + 11) = v90;
      *((_QWORD *)this + 12) = v83;
      v97 = v93;
      v94 = (char *)*((_QWORD *)this + 13);
      *((_QWORD *)this + 13) = v91;
      v98 = v94;
      v96 = v93;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v96);
    }
    else
    {
      *v82 = v79;
      v83 = v82 + 1;
    }
    *((_QWORD *)this + 12) = v83;
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 14) = *((_QWORD *)a2 + 14);
}

as::server::Device *as::server::Device::operator=(as::server::Device *a1, const as::server::Device *a2)
{
  as::server::Device::copy_from(a1, a2);
  return a1;
}

as::server::Port *as::server::Port::Port(as::server::Port *this, const as::server::Port *a2)
{
  *(_QWORD *)this = &off_24BFE4320;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  as::server::Port::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4320;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  as::server::Port::copy_from(this, a2);
  return this;
}

uint64_t as::server::Device::Device(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE4390;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Device::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE4390;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Device::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Device::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  v5 = *(_QWORD *)(result + 40);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v5;
  v6 = *(_QWORD *)(result + 48);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v6;
  v7 = *(_QWORD *)(result + 56);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v7;
  v8 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v8;
  v9 = *(_QWORD *)(result + 72);
  *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v9;
  v10 = *(_QWORD *)(result + 80);
  *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v10;
  v11 = *(_QWORD *)(result + 88);
  *(_QWORD *)(result + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v11;
  v12 = *(_QWORD *)(result + 96);
  *(_QWORD *)(result + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 96) = v12;
  v13 = *(_QWORD *)(result + 104);
  *(_QWORD *)(result + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v13;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 112) = *(_QWORD *)(a2 + 112);
  return result;
}

uint64_t as::server::Device::operator=(uint64_t a1, uint64_t a2)
{
  as::server::Device::move_from(a1, a2);
  return a1;
}

_QWORD *as::server::Device::clear(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;

  v1 = this;
  v2 = (_QWORD *)this[2];
  v3 = (_QWORD *)this[3];
  while (v3 != v2)
  {
    v4 = (_QWORD *)*--v3;
    this = v4;
    *v3 = 0;
    if (v4)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[3] = v2;
  v5 = (_QWORD *)v1[5];
  v6 = (_QWORD *)v1[6];
  while (v6 != v5)
  {
    v7 = (_QWORD *)*--v6;
    this = v7;
    *v6 = 0;
    if (v7)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[6] = v5;
  v8 = (_QWORD *)v1[8];
  v9 = (_QWORD *)v1[9];
  while (v9 != v8)
  {
    v10 = (_QWORD *)*--v9;
    this = v10;
    *v9 = 0;
    if (v10)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[9] = v8;
  v11 = (_QWORD *)v1[11];
  v12 = (_QWORD *)v1[12];
  while (v12 != v11)
  {
    v13 = (_QWORD *)*--v12;
    this = v13;
    *v12 = 0;
    if (v13)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[12] = v11;
  *((_DWORD *)v1 + 2) = 0;
  v1[14] = 0;
  return this;
}

BOOL as::server::Device::isInitialized(as::server::Device *this)
{
  as::server::HWStream **v2;
  as::server::HWStream **v3;
  as::server::HWStream **v4;
  as::server::HWStream **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = (as::server::HWStream **)*((_QWORD *)this + 2);
  v3 = (as::server::HWStream **)*((_QWORD *)this + 3);
  while (v2 != v3)
  {
    if ((as::server::HWStream::isInitialized(*v2) & 1) == 0)
      return 0;
    ++v2;
  }
  v4 = (as::server::HWStream **)*((_QWORD *)this + 5);
  v5 = (as::server::HWStream **)*((_QWORD *)this + 6);
  while (v4 != v5)
  {
    if ((as::server::HWStream::isInitialized(*v4) & 1) == 0)
      return 0;
    ++v4;
  }
  v6 = *((_QWORD *)this + 8);
  v7 = *((_QWORD *)this + 9);
  if (v6 == v7)
  {
LABEL_14:
    v9 = *((_QWORD *)this + 11);
    v10 = *((_QWORD *)this + 12);
    if (v9 == v10)
      return (~*((_DWORD *)this + 2) & 3) == 0;
    while (1)
    {
      v11 = *(_QWORD *)(*(_QWORD *)v9 + 120);
      if (!v11 || (~*(_DWORD *)(v11 + 8) & 0x7F) != 0 || !*(_QWORD *)(*(_QWORD *)v9 + 128))
        break;
      v9 += 8;
      if (v9 == v10)
        return (~*((_DWORD *)this + 2) & 3) == 0;
    }
  }
  else
  {
    while (1)
    {
      v8 = *(_QWORD *)(*(_QWORD *)v6 + 120);
      if (!v8 || (~*(_DWORD *)(v8 + 8) & 0x7F) != 0 || !*(_QWORD *)(*(_QWORD *)v6 + 128))
        break;
      v6 += 8;
      if (v6 == v7)
        goto LABEL_14;
    }
  }
  return 0;
}

BOOL as::server::Port::isInitialized(as::server::Port *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 15);
  return v1 && (~*(_DWORD *)(v1 + 8) & 0x7F) == 0 && *((_QWORD *)this + 16) != 0;
}

BOOL as::server::Device::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  int64x2_t *v9;
  uint64_t v10;
  int64x2_t *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  BOOL v19;
  char v20;
  unsigned int v21;
  unint64_t v22;
  unint64_t v23;
  char v24;
  BOOL v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t *v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char v63;
  unsigned int v64;
  unint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  char v72;
  unsigned int v73;
  unint64_t v74;
  char v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  char *v80;
  uint64_t *v81;
  char *v82;
  _QWORD *v83;
  _QWORD *v84;
  uint64_t v85;
  int64x2_t v86;
  uint64_t *v87;
  char *v88;
  _QWORD *v89;
  _QWORD *v90;
  uint64_t v91;
  int64x2_t v92;
  uint64_t *v93;
  char *v94;
  _QWORD *v95;
  _QWORD *v96;
  uint64_t v97;
  int64x2_t v98;
  uint64_t *v99;
  char *v100;
  _QWORD *v101;
  _QWORD *v102;
  uint64_t v103;
  int64x2_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  uint64_t v109;
  int v110;
  uint64_t v113;
  int64x2_t *v114;
  int64x2_t *v115;
  uint64_t v116;
  int64x2_t v117;
  char *v118;
  uint64_t v119;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v113 = a1 + 104;
    v114 = (int64x2_t *)(a1 + 64);
    v115 = (int64x2_t *)(a1 + 88);
    v8 = a1 + 80;
    v9 = (int64x2_t *)(a1 + 40);
    v10 = a1 + 56;
    v11 = (int64x2_t *)(a1 + 16);
    v12 = a1 + 32;
    while (1)
    {
      v13 = *a2;
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v14 = 0;
        v15 = 0;
        v16 = 0;
        while (1)
        {
          v17 = v3 + 1;
          a2[1] = v3 + 1;
          v18 = *(_BYTE *)(v13 + v3);
          v16 |= (unint64_t)(v18 & 0x7F) << v14;
          if ((v18 & 0x80) == 0)
            goto LABEL_23;
          v14 += 7;
          v3 = v17;
          v19 = v15++ > 8;
          if (v19)
          {
            v16 = 0;
            goto LABEL_23;
          }
        }
      }
      v20 = 0;
      v21 = 0;
      v16 = 0;
      v22 = v3 <= v2 ? v2 : v3;
      do
      {
        if (v22 == v3)
        {
          v4 = 1;
          *((_BYTE *)a2 + 24) = 1;
          return v4 == 0;
        }
        v23 = v3++;
        v24 = *(_BYTE *)(v13 + v23);
        a2[1] = v3;
        v16 |= (unint64_t)(v24 & 0x7F) << v20;
        if ((v24 & 0x80) == 0)
          goto LABEL_22;
        v20 += 7;
        v25 = v21++ >= 9;
      }
      while (!v25);
      v16 = 0;
LABEL_22:
      v17 = v23 + 1;
LABEL_23:
      if ((v16 & 7) == 4)
        break;
      switch((v16 >> 3))
      {
        case 2u:
          if (v17 > 0xFFFFFFFFFFFFFFF5 || v17 + 10 > v2)
          {
            v63 = 0;
            v64 = 0;
            v28 = 0;
            if (v2 <= v17)
              v2 = v17;
            do
            {
              if (v2 == v17)
              {
                LODWORD(v28) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_125;
              }
              v65 = v17 + 1;
              v66 = *(_BYTE *)(v13 + v17);
              a2[1] = v65;
              v28 |= (unint64_t)(v66 & 0x7F) << v63;
              if ((v66 & 0x80) == 0)
                goto LABEL_125;
              v63 += 7;
              v17 = v65;
              v25 = v64++ >= 9;
            }
            while (!v25);
LABEL_69:
            LODWORD(v28) = 0;
          }
          else
          {
            v26 = 0;
            v27 = 0;
            v28 = 0;
            while (1)
            {
              v29 = v17 + 1;
              a2[1] = v17 + 1;
              v30 = *(_BYTE *)(v13 + v17);
              v28 |= (unint64_t)(v30 & 0x7F) << v26;
              if ((v30 & 0x80) == 0)
                break;
              v26 += 7;
              v17 = v29;
              v19 = v27++ > 8;
              if (v19)
                goto LABEL_69;
            }
          }
LABEL_125:
          *(_DWORD *)(a1 + 112) = v28;
          v110 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_128;
        case 3u:
          if (v17 <= 0xFFFFFFFFFFFFFFF5 && v17 + 10 <= v2)
          {
            v44 = 0;
            v45 = 0;
            v46 = 0;
            do
            {
              v47 = v17 + 1;
              a2[1] = v17 + 1;
              v48 = *(_BYTE *)(v13 + v17);
              v46 |= (unint64_t)(v48 & 0x7F) << v44;
              if ((v48 & 0x80) == 0)
                goto LABEL_127;
              v44 += 7;
              v17 = v47;
              v19 = v45++ > 8;
            }
            while (!v19);
LABEL_84:
            LODWORD(v46) = 0;
            goto LABEL_127;
          }
          v72 = 0;
          v73 = 0;
          v46 = 0;
          if (v2 <= v17)
            v2 = v17;
          while (v2 != v17)
          {
            v74 = v17 + 1;
            v75 = *(_BYTE *)(v13 + v17);
            a2[1] = v74;
            v46 |= (unint64_t)(v75 & 0x7F) << v72;
            if ((v75 & 0x80) == 0)
              goto LABEL_127;
            v72 += 7;
            v17 = v74;
            v25 = v73++ >= 9;
            if (v25)
              goto LABEL_84;
          }
          LODWORD(v46) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_127:
          *(_DWORD *)(a1 + 116) = v46;
          v110 = *(_DWORD *)(a1 + 8) | 2;
LABEL_128:
          *(_DWORD *)(a1 + 8) = v110;
          goto LABEL_129;
        case 4u:
          v36 = operator new();
          v37 = v36;
          *(_QWORD *)v36 = &off_24BFE4438;
          *(_DWORD *)(v36 + 8) = 0;
          *(_OWORD *)(v36 + 16) = 0u;
          *(_OWORD *)(v36 + 32) = 0u;
          *(_OWORD *)(v36 + 48) = 0u;
          *(_OWORD *)(v36 + 64) = 0u;
          *(_OWORD *)(v36 + 80) = 0u;
          *(_OWORD *)(v36 + 96) = 0u;
          *(_OWORD *)(v36 + 112) = 0u;
          *(_DWORD *)(v36 + 128) = 0;
          v39 = *(uint64_t **)(a1 + 24);
          v38 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v39 >= v38)
          {
            v58 = ((uint64_t)v39 - v11->i64[0]) >> 3;
            if ((unint64_t)(v58 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v59 = v38 - v11->i64[0];
            v60 = v59 >> 2;
            if (v59 >> 2 <= (unint64_t)(v58 + 1))
              v60 = v58 + 1;
            if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8)
              v61 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v61 = v60;
            v119 = v12;
            if (v61)
              v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v12, v61);
            else
              v62 = 0;
            v87 = (uint64_t *)&v62[8 * v58];
            v88 = &v62[8 * v61];
            v118 = v88;
            *v87 = v37;
            v35 = v87 + 1;
            v117.i64[1] = (uint64_t)(v87 + 1);
            v90 = *(_QWORD **)(a1 + 16);
            v89 = *(_QWORD **)(a1 + 24);
            if (v89 == v90)
            {
              v92 = vdupq_n_s64((unint64_t)v89);
            }
            else
            {
              do
              {
                v91 = *--v89;
                *v89 = 0;
                *--v87 = v91;
              }
              while (v89 != v90);
              v92 = *v11;
              v35 = (_QWORD *)v117.i64[1];
              v88 = v118;
            }
            *(_QWORD *)(a1 + 16) = v87;
            *(_QWORD *)(a1 + 24) = v35;
            v117 = v92;
            v106 = *(char **)(a1 + 32);
            *(_QWORD *)(a1 + 32) = v88;
            v118 = v106;
            v116 = v92.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v116);
          }
          else
          {
            *v39 = v36;
            v35 = v39 + 1;
          }
          *(_QWORD *)(a1 + 24) = v35;
          goto LABEL_121;
        case 5u:
          v40 = operator new();
          v41 = v40;
          *(_QWORD *)v40 = &off_24BFE4438;
          *(_DWORD *)(v40 + 8) = 0;
          *(_OWORD *)(v40 + 16) = 0u;
          *(_OWORD *)(v40 + 32) = 0u;
          *(_OWORD *)(v40 + 48) = 0u;
          *(_OWORD *)(v40 + 64) = 0u;
          *(_OWORD *)(v40 + 80) = 0u;
          *(_OWORD *)(v40 + 96) = 0u;
          *(_OWORD *)(v40 + 112) = 0u;
          *(_DWORD *)(v40 + 128) = 0;
          v43 = *(uint64_t **)(a1 + 48);
          v42 = *(_QWORD *)(a1 + 56);
          if ((unint64_t)v43 >= v42)
          {
            v67 = ((uint64_t)v43 - v9->i64[0]) >> 3;
            if ((unint64_t)(v67 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v68 = v42 - v9->i64[0];
            v69 = v68 >> 2;
            if (v68 >> 2 <= (unint64_t)(v67 + 1))
              v69 = v67 + 1;
            if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8)
              v70 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v70 = v69;
            v119 = v10;
            if (v70)
              v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v10, v70);
            else
              v71 = 0;
            v93 = (uint64_t *)&v71[8 * v67];
            v94 = &v71[8 * v70];
            v118 = v94;
            *v93 = v41;
            v35 = v93 + 1;
            v117.i64[1] = (uint64_t)(v93 + 1);
            v96 = *(_QWORD **)(a1 + 40);
            v95 = *(_QWORD **)(a1 + 48);
            if (v95 == v96)
            {
              v98 = vdupq_n_s64((unint64_t)v95);
            }
            else
            {
              do
              {
                v97 = *--v95;
                *v95 = 0;
                *--v93 = v97;
              }
              while (v95 != v96);
              v98 = *v9;
              v35 = (_QWORD *)v117.i64[1];
              v94 = v118;
            }
            *(_QWORD *)(a1 + 40) = v93;
            *(_QWORD *)(a1 + 48) = v35;
            v117 = v98;
            v107 = *(char **)(a1 + 56);
            *(_QWORD *)(a1 + 56) = v94;
            v118 = v107;
            v116 = v98.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v116);
          }
          else
          {
            *v43 = v40;
            v35 = v43 + 1;
          }
          *(_QWORD *)(a1 + 48) = v35;
          goto LABEL_121;
        case 6u:
          v31 = operator new();
          v32 = v31;
          *(_QWORD *)v31 = &off_24BFE4320;
          *(_DWORD *)(v31 + 8) = 0;
          *(_OWORD *)(v31 + 16) = 0u;
          *(_OWORD *)(v31 + 32) = 0u;
          *(_OWORD *)(v31 + 48) = 0u;
          *(_OWORD *)(v31 + 64) = 0u;
          *(_OWORD *)(v31 + 80) = 0u;
          *(_OWORD *)(v31 + 96) = 0u;
          *(_OWORD *)(v31 + 112) = 0u;
          *(_OWORD *)(v31 + 121) = 0u;
          v34 = *(uint64_t **)(a1 + 72);
          v33 = *(_QWORD *)(a1 + 80);
          if ((unint64_t)v34 >= v33)
          {
            v53 = ((uint64_t)v34 - v114->i64[0]) >> 3;
            if ((unint64_t)(v53 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v54 = v33 - v114->i64[0];
            v55 = v54 >> 2;
            if (v54 >> 2 <= (unint64_t)(v53 + 1))
              v55 = v53 + 1;
            if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
              v56 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v56 = v55;
            v119 = v8;
            if (v56)
              v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v8, v56);
            else
              v57 = 0;
            v81 = (uint64_t *)&v57[8 * v53];
            v82 = &v57[8 * v56];
            v118 = v82;
            *v81 = v32;
            v35 = v81 + 1;
            v117.i64[1] = (uint64_t)(v81 + 1);
            v84 = *(_QWORD **)(a1 + 64);
            v83 = *(_QWORD **)(a1 + 72);
            if (v83 == v84)
            {
              v86 = vdupq_n_s64((unint64_t)v83);
            }
            else
            {
              do
              {
                v85 = *--v83;
                *v83 = 0;
                *--v81 = v85;
              }
              while (v83 != v84);
              v86 = *v114;
              v35 = (_QWORD *)v117.i64[1];
              v82 = v118;
            }
            *(_QWORD *)(a1 + 64) = v81;
            *(_QWORD *)(a1 + 72) = v35;
            v117 = v86;
            v105 = *(char **)(a1 + 80);
            *(_QWORD *)(a1 + 80) = v82;
            v118 = v105;
            v116 = v86.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v116);
          }
          else
          {
            *v34 = v31;
            v35 = v34 + 1;
          }
          *(_QWORD *)(a1 + 72) = v35;
          goto LABEL_121;
        case 7u:
          v49 = operator new();
          v50 = v49;
          *(_QWORD *)v49 = &off_24BFE4320;
          *(_DWORD *)(v49 + 8) = 0;
          *(_OWORD *)(v49 + 16) = 0u;
          *(_OWORD *)(v49 + 32) = 0u;
          *(_OWORD *)(v49 + 48) = 0u;
          *(_OWORD *)(v49 + 64) = 0u;
          *(_OWORD *)(v49 + 80) = 0u;
          *(_OWORD *)(v49 + 96) = 0u;
          *(_OWORD *)(v49 + 112) = 0u;
          *(_OWORD *)(v49 + 121) = 0u;
          v52 = *(uint64_t **)(a1 + 96);
          v51 = *(_QWORD *)(a1 + 104);
          if ((unint64_t)v52 >= v51)
          {
            v76 = ((uint64_t)v52 - v115->i64[0]) >> 3;
            if ((unint64_t)(v76 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v77 = v51 - v115->i64[0];
            v78 = v77 >> 2;
            if (v77 >> 2 <= (unint64_t)(v76 + 1))
              v78 = v76 + 1;
            if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8)
              v79 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v79 = v78;
            v119 = v113;
            if (v79)
              v80 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v113, v79);
            else
              v80 = 0;
            v99 = (uint64_t *)&v80[8 * v76];
            v100 = &v80[8 * v79];
            v118 = v100;
            *v99 = v50;
            v35 = v99 + 1;
            v117.i64[1] = (uint64_t)(v99 + 1);
            v102 = *(_QWORD **)(a1 + 88);
            v101 = *(_QWORD **)(a1 + 96);
            if (v101 == v102)
            {
              v104 = vdupq_n_s64((unint64_t)v101);
            }
            else
            {
              do
              {
                v103 = *--v101;
                *v101 = 0;
                *--v99 = v103;
              }
              while (v101 != v102);
              v104 = *v115;
              v35 = (_QWORD *)v117.i64[1];
              v100 = v118;
            }
            *(_QWORD *)(a1 + 88) = v99;
            *(_QWORD *)(a1 + 96) = v35;
            v117 = v104;
            v108 = *(char **)(a1 + 104);
            *(_QWORD *)(a1 + 104) = v100;
            v118 = v108;
            v116 = v104.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v116);
          }
          else
          {
            *v52 = v49;
            v35 = v52 + 1;
          }
          *(_QWORD *)(a1 + 96) = v35;
LABEL_121:
          v109 = *(v35 - 1);
          if ((PB::Reader::placeMark() & 1) == 0
            || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v109 + 16))(v109, a2) & 1) == 0)
          {
            return 0;
          }
          PB::Reader::recallMark();
LABEL_129:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          break;
        default:
          goto LABEL_129;
      }
    }
    v4 = 0;
  }
  return v4 == 0;
}

void sub_20680AE08(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::Device::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;
  const PB::Base **v8;
  const PB::Base **v9;
  const PB::Base *v10;
  const PB::Base **v11;
  const PB::Base **v12;
  const PB::Base *v13;
  const PB::Base **v14;
  const PB::Base **v15;
  const PB::Base *v16;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0)
    this = PB::Writer::writeVarInt(a2);
  v5 = *(const PB::Base ***)(v3 + 16);
  v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    v7 = *v5++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  v8 = *(const PB::Base ***)(v3 + 40);
  v9 = *(const PB::Base ***)(v3 + 48);
  while (v8 != v9)
  {
    v10 = *v8++;
    this = PB::Writer::writeSubmessage(a2, v10);
  }
  v11 = *(const PB::Base ***)(v3 + 64);
  v12 = *(const PB::Base ***)(v3 + 72);
  while (v11 != v12)
  {
    v13 = *v11++;
    this = PB::Writer::writeSubmessage(a2, v13);
  }
  v15 = *(const PB::Base ***)(v3 + 88);
  v14 = *(const PB::Base ***)(v3 + 96);
  while (v15 != v14)
  {
    v16 = *v15++;
    this = PB::Writer::writeSubmessage(a2, v16);
  }
  return this;
}

uint64_t as::server::Device::formatText(as::server::Device *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "inputSafetyOffset");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "outputSafetyOffset");
  v6 = (uint64_t *)*((_QWORD *)this + 2);
  v7 = (uint64_t *)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "inputStreams");
  }
  v9 = (uint64_t *)*((_QWORD *)this + 5);
  v10 = (uint64_t *)*((_QWORD *)this + 6);
  while (v9 != v10)
  {
    v11 = *v9++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v11 + 32))(v11, a2, "outputStreams");
  }
  v12 = (uint64_t *)*((_QWORD *)this + 8);
  v13 = (uint64_t *)*((_QWORD *)this + 9);
  while (v12 != v13)
  {
    v14 = *v12++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v14 + 32))(v14, a2, "inputPorts");
  }
  v15 = (uint64_t *)*((_QWORD *)this + 11);
  v16 = (uint64_t *)*((_QWORD *)this + 12);
  while (v15 != v16)
  {
    v17 = *v15++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v17 + 32))(v17, a2, "outputPorts");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Device::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  BOOL v36;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a1 + 112) != *(_QWORD *)(a2 + 112))
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v6 = (v4 - v5) >> 3;
  if (v6 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3)
    return 0;
  if (v4 != v5)
  {
    v7 = 0;
    if (v6 <= 1)
      v8 = 1;
    else
      v8 = (v4 - v5) >> 3;
    do
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v7);
      v10 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v7);
      if (v9)
        v11 = v10 == 0;
      else
        v11 = 1;
      if (v11)
      {
        if (v9 | v10)
          return 0;
      }
      else if (!as::server::HWStream::operator==(v9, v10))
      {
        return 0;
      }
      ++v7;
    }
    while (v8 != v7);
  }
  v13 = *(_QWORD *)(a1 + 40);
  v12 = *(_QWORD *)(a1 + 48);
  v14 = (v12 - v13) >> 3;
  if (v14 != (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
    return 0;
  if (v12 != v13)
  {
    v15 = 0;
    if (v14 <= 1)
      v16 = 1;
    else
      v16 = (v12 - v13) >> 3;
    do
    {
      v17 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v15);
      v18 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v15);
      if (v17)
        v19 = v18 == 0;
      else
        v19 = 1;
      if (v19)
      {
        if (v17 | v18)
          return 0;
      }
      else if (!as::server::HWStream::operator==(v17, v18))
      {
        return 0;
      }
      ++v15;
    }
    while (v16 != v15);
  }
  v21 = *(_QWORD *)(a1 + 64);
  v20 = *(_QWORD *)(a1 + 72);
  v22 = (v20 - v21) >> 3;
  if (v22 != (uint64_t)(*(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64)) >> 3)
    return 0;
  if (v20 != v21)
  {
    v23 = 0;
    if (v22 <= 1)
      v24 = 1;
    else
      v24 = (v20 - v21) >> 3;
    do
    {
      v25 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v23);
      v26 = *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v23);
      if (v25)
        v27 = v26 == 0;
      else
        v27 = 1;
      if (v27)
      {
        if (v25 | v26)
          return 0;
      }
      else if (!as::server::Port::operator==(v25, v26))
      {
        return 0;
      }
      ++v23;
    }
    while (v24 != v23);
  }
  v29 = *(_QWORD *)(a1 + 88);
  v28 = *(_QWORD *)(a1 + 96);
  v30 = (v28 - v29) >> 3;
  if (v30 == (uint64_t)(*(_QWORD *)(a2 + 96) - *(_QWORD *)(a2 + 88)) >> 3)
  {
    if (v28 == v29)
    {
      return 1;
    }
    else
    {
      v31 = 0;
      v32 = 0;
      if (v30 <= 1)
        v33 = 1;
      else
        v33 = (v28 - v29) >> 3;
      do
      {
        v34 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8 * v32);
        v35 = *(_QWORD *)(*(_QWORD *)(a2 + 88) + 8 * v32);
        if (v34)
          v36 = v35 == 0;
        else
          v36 = 1;
        if (v36)
        {
          if (v34 | v35)
            return v31;
        }
        else if (!as::server::Port::operator==(v34, v35))
        {
          return v31;
        }
        v31 = ++v32 >= v30;
      }
      while (v33 != v32);
    }
  }
  else
  {
    return 0;
  }
  return v31;
}

uint64_t as::server::Device::addInputStreams(as::server::Device *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4438;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_DWORD *)(result + 128) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::Device::addOutputStreams(as::server::Device *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4438;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_DWORD *)(result + 128) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::Device::addInputPorts(as::server::Device *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 10);
  v2 = (char *)this + 80;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 8);
      v5 = (_QWORD *)*((_QWORD *)this + 9);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 4);
    *((_QWORD *)this + 8) = v13;
    *((_QWORD *)this + 9) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 10);
    *((_QWORD *)this + 10) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 9) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4320;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 121) = 0u;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::Device::addOutputPorts(as::server::Device *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 13);
  v2 = (char *)this + 104;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 11);
      v5 = (_QWORD *)*((_QWORD *)this + 12);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 88);
    *((_QWORD *)this + 11) = v13;
    *((_QWORD *)this + 12) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 13);
    *((_QWORD *)this + 13) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 12) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4320;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 121) = 0u;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::Device_Clock::default_instance(as::server::Device_Clock *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    v3[1] = 0;
    v3[2] = 0;
    *v3 = &off_24BFE3E88;
    as::server::Device_Clock::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::server::Device_Clock::default_instance(void)::gInstance;
}

void sub_20680B89C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::server::Device_Clock::Device_Clock(_QWORD *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE3E88;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE3E88;
  return this;
}

as::server::Device_Clock *as::server::Device_Clock::Device_Clock(as::server::Device_Clock *this, const as::server::Device_Clock *a2)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE3E88;
  as::server::Device_Clock::copy_from(this, a2);
  return this;
}

{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE3E88;
  as::server::Device_Clock::copy_from(this, a2);
  return this;
}

void as::server::Device_Clock::copy_from(as::server::Device_Clock *this, const as::server::Device_Clock *a2)
{
  const as::server::Clock *v4;
  as::server::Clock *v5;
  const as::server::Device *v6;
  as::server::Device *v7;

  v4 = (const as::server::Clock *)*((_QWORD *)a2 + 1);
  if (v4)
  {
    v5 = (as::server::Clock *)as::server::Device_Clock::mutableClock(this);
    as::server::Clock::copy_from(v5, v4);
  }
  v6 = (const as::server::Device *)*((_QWORD *)a2 + 2);
  if (v6)
  {
    v7 = (as::server::Device *)as::server::Device_Clock::mutableDevice(this);
    as::server::Device::copy_from(v7, v6);
  }
}

as::server::Device_Clock *as::server::Device_Clock::operator=(as::server::Device_Clock *a1, const as::server::Device_Clock *a2)
{
  as::server::Device_Clock::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::Device_Clock::clock(as::server::Device_Clock *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (!result)
    return as::server::Clock::default_instance(0);
  return result;
}

uint64_t as::server::Device_Clock::mutableClock(as::server::Device_Clock *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE4358;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_OWORD *)(v1 + 112) = 0u;
    *(_QWORD *)(v1 + 128) = 0;
    v3 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::Device_Clock::device(as::server::Device_Clock *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return as::server::Device::default_instance(0);
  return result;
}

uint64_t as::server::Device_Clock::mutableDevice(as::server::Device_Clock *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE4390;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_QWORD *)(v1 + 112) = 0;
    v3 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

_QWORD *as::server::Device_Clock::Device_Clock(_QWORD *result, uint64_t a2)
{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE3E88;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE3E88;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::Device_Clock::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::Device_Clock::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::Device_Clock::clear(as::server::Device_Clock *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

BOOL as::server::Device_Clock::isInitialized(as::server::Device_Clock *this)
{
  as::server::Clock *v2;
  as::server::Device *v3;

  v2 = (as::server::Clock *)*((_QWORD *)this + 1);
  return v2
      && as::server::Clock::isInitialized(v2)
      && (v3 = (as::server::Device *)*((_QWORD *)this + 2)) != 0
      && as::server::Device::isInitialized(v3);
}

BOOL as::server::Device_Clock::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v15;
  unsigned int v16;
  unint64_t v17;
  char v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    do
    {
      v8 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v15 = 0;
        v16 = 0;
        v11 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v17 = v2 + 1;
          v18 = *(_BYTE *)(v8 + v2);
          a2[1] = v17;
          v11 |= (unint64_t)(v18 & 0x7F) << v15;
          if ((v18 & 0x80) == 0)
            goto LABEL_20;
          v15 += 7;
          v2 = v17;
          if (v16++ >= 9)
          {
LABEL_19:
            v11 = 0;
            goto LABEL_20;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v2 + 1;
        a2[1] = v2 + 1;
        v13 = *(_BYTE *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v2 = v12;
        if (v10++ > 8)
          goto LABEL_19;
      }
LABEL_20:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v11 >> 3) == 2)
      {
        v20 = operator new();
        *(_QWORD *)v20 = &off_24BFE4390;
        *(_DWORD *)(v20 + 8) = 0;
        *(_OWORD *)(v20 + 16) = 0u;
        *(_OWORD *)(v20 + 32) = 0u;
        *(_OWORD *)(v20 + 48) = 0u;
        *(_OWORD *)(v20 + 64) = 0u;
        *(_OWORD *)(v20 + 80) = 0u;
        *(_OWORD *)(v20 + 96) = 0u;
        *(_QWORD *)(v20 + 112) = 0;
        v22 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v20;
        if (v22)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
          v20 = *(_QWORD *)(a1 + 16);
        }
      }
      else
      {
        if ((v11 >> 3) != 1)
          goto LABEL_30;
        v20 = operator new();
        *(_QWORD *)v20 = &off_24BFE4358;
        *(_DWORD *)(v20 + 8) = 0;
        *(_OWORD *)(v20 + 16) = 0u;
        *(_OWORD *)(v20 + 32) = 0u;
        *(_OWORD *)(v20 + 48) = 0u;
        *(_OWORD *)(v20 + 64) = 0u;
        *(_OWORD *)(v20 + 80) = 0u;
        *(_OWORD *)(v20 + 96) = 0u;
        *(_OWORD *)(v20 + 112) = 0u;
        *(_QWORD *)(v20 + 128) = 0;
        v21 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v20;
        if (v21)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
          v20 = *(_QWORD *)(a1 + 8);
        }
      }
      if (!PB::Reader::placeMark()
        || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v20 + 16))(v20, a2) & 1) == 0)
      {
        return 0;
      }
      PB::Reader::recallMark();
LABEL_30:
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

uint64_t as::server::Device_Clock::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  const PB::Base *v5;

  v3 = this;
  v4 = *(const PB::Base **)(this + 8);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
    return PB::Writer::writeSubmessage(a2, v5);
  return this;
}

uint64_t as::server::Device_Clock::formatText(as::server::Device_Clock *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 1);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "clock");
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "device");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Device_Clock::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a2 + 8);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (!(v4 | v5))
      goto LABEL_9;
    return 0;
  }
  if (!as::server::Clock::operator==(v4, v5))
    return 0;
LABEL_9:
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a2 + 16);
  result = (v8 | v9) == 0;
  if (v8)
  {
    if (v9)
      return as::server::Device::operator==(*(_QWORD *)(a1 + 16), v9);
  }
  return result;
}

uint64_t as::server::Device_Clock::clearClock(as::server::Device_Clock *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::Device_Clock::clearDevice(as::server::Device_Clock *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::Box::default_instance(as::server::Box *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE42E8;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_BYTE *)(v3 + 96) = 0;
    as::server::Box::default_instance(void)::gInstance = v3;
  }
  return as::server::Box::default_instance(void)::gInstance;
}

void sub_20680C084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::Box::Box(as::server::Box *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE42E8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_BYTE *)this + 96) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE42E8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_BYTE *)this + 96) = 0;
  return result;
}

as::server::Box *as::server::Box::Box(as::server::Box *this, const as::server::Box *a2)
{
  *(_QWORD *)this = &off_24BFE42E8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::Box::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE42E8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::Box::copy_from(this, a2);
  return this;
}

void as::server::Box::copy_from(as::server::Box *this, const as::server::Box *a2)
{
  const as::server::HardwareInfo *v4;
  as::server::HardwareInfo *v5;
  as::server::ControlAndValue ***v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  const as::server::ControlAndValue **v11;
  const as::server::ControlAndValue **i;
  as::server::ControlAndValue *v13;
  const as::server::ControlAndValue *v14;
  unint64_t v15;
  as::server::ControlAndValue **v16;
  _QWORD *v17;
  as::server::ControlAndValue **v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  as::server::ControlAndValue **v24;
  char *v25;
  as::server::ControlAndValue *v26;
  __int128 v27;
  char *v28;
  uint64_t v29;
  __int128 v30;
  char *v31;
  char *v32;

  v4 = (const as::server::HardwareInfo *)*((_QWORD *)a2 + 11);
  if (v4)
  {
    v5 = (as::server::HardwareInfo *)as::server::Box::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v5, v4);
  }
  if (this != a2)
  {
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((char *)this + 40, *((char **)a2 + 5), *((_QWORD *)a2 + 6), (uint64_t)(*((_QWORD *)a2 + 6) - *((_QWORD *)a2 + 5)) >> 3);
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((char *)this + 64, *((char **)a2 + 8), *((_QWORD *)a2 + 9), (uint64_t)(*((_QWORD *)a2 + 9) - *((_QWORD *)a2 + 8)) >> 3);
  }
  v7 = (_QWORD *)*((_QWORD *)this + 2);
  v8 = (_QWORD *)*((_QWORD *)this + 3);
  v6 = (as::server::ControlAndValue ***)((char *)this + 16);
  while (v8 != v7)
  {
    v10 = *--v8;
    v9 = v10;
    *v8 = 0;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  *((_QWORD *)this + 3) = v7;
  v11 = (const as::server::ControlAndValue **)*((_QWORD *)a2 + 2);
  for (i = (const as::server::ControlAndValue **)*((_QWORD *)a2 + 3); v11 != i; ++v11)
  {
    v13 = (as::server::ControlAndValue *)operator new();
    v14 = *v11;
    *((_QWORD *)v13 + 1) = 0;
    *((_QWORD *)v13 + 2) = 0;
    *(_QWORD *)v13 = &off_24BFE3FA0;
    as::server::ControlAndValue::copy_from(v13, v14);
    v16 = (as::server::ControlAndValue **)*((_QWORD *)this + 3);
    v15 = *((_QWORD *)this + 4);
    if ((unint64_t)v16 >= v15)
    {
      v18 = *v6;
      v19 = v16 - *v6;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v21 = v15 - (_QWORD)v18;
      if (v21 >> 2 > v20)
        v20 = v21 >> 2;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
        v22 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      v32 = (char *)this + 32;
      if (v22)
      {
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v22);
        v18 = (as::server::ControlAndValue **)*((_QWORD *)this + 2);
        v16 = (as::server::ControlAndValue **)*((_QWORD *)this + 3);
      }
      else
      {
        v23 = 0;
      }
      v24 = (as::server::ControlAndValue **)&v23[8 * v19];
      v25 = &v23[8 * v22];
      v31 = v25;
      *v24 = v13;
      *((_QWORD *)&v30 + 1) = v24 + 1;
      if (v16 == v18)
      {
        v17 = v24 + 1;
      }
      else
      {
        do
        {
          v26 = *--v16;
          *v16 = 0;
          *--v24 = v26;
        }
        while (v16 != v18);
        v17 = (_QWORD *)*((_QWORD *)&v30 + 1);
        v25 = v31;
      }
      v27 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v24;
      *((_QWORD *)this + 3) = v17;
      v30 = v27;
      v28 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v25;
      v31 = v28;
      v29 = v27;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v29);
    }
    else
    {
      *v16 = v13;
      v17 = v16 + 1;
    }
    *((_QWORD *)this + 3) = v17;
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_BYTE *)this + 96) = *((_BYTE *)a2 + 96);
}

as::server::Box *as::server::Box::operator=(as::server::Box *a1, const as::server::Box *a2)
{
  as::server::Box::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::Box::hardwareInfo(as::server::Box *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 11);
  if (!result)
    return as::server::HardwareInfo::default_instance(0);
  return result;
}

uint64_t as::server::Box::mutableHardwareInfo(as::server::Box *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 11);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3EC0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    v3 = *((_QWORD *)this + 11);
    *((_QWORD *)this + 11) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::Box::Box(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE42E8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::Box::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE42E8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::Box::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Box::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD *)(result + 88);
  *(_QWORD *)(result + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v2;
  v3 = *(_QWORD *)(result + 40);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v3;
  v4 = *(_QWORD *)(result + 48);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v4;
  v5 = *(_QWORD *)(result + 56);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v5;
  v6 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v6;
  v7 = *(_QWORD *)(result + 72);
  *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v7;
  v8 = *(_QWORD *)(result + 80);
  *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v8;
  v9 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v9;
  v10 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v10;
  v11 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v11;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(result + 96) = *(_BYTE *)(a2 + 96);
  return result;
}

uint64_t as::server::Box::operator=(uint64_t a1, uint64_t a2)
{
  as::server::Box::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Box::clear(as::server::Box *this)
{
  uint64_t result;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  result = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *((_QWORD *)this + 6) = *((_QWORD *)this + 5);
  *((_QWORD *)this + 9) = *((_QWORD *)this + 8);
  v3 = (_QWORD *)*((_QWORD *)this + 2);
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  while (v4 != v3)
  {
    v5 = *--v4;
    result = v5;
    *v4 = 0;
    if (v5)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 3) = v3;
  *((_DWORD *)this + 2) = 0;
  *((_BYTE *)this + 96) = 0;
  return result;
}

uint64_t as::server::Box::isInitialized(as::server::Box *this)
{
  as::server::ControlAndValue **v2;
  as::server::ControlAndValue **v3;

  if (!*((_QWORD *)this + 11))
    return 0;
  v2 = (as::server::ControlAndValue **)*((_QWORD *)this + 2);
  v3 = (as::server::ControlAndValue **)*((_QWORD *)this + 3);
  while (v2 != v3)
  {
    if (!as::server::ControlAndValue::isInitialized(*v2))
      return 0;
    ++v2;
  }
  return *((_BYTE *)this + 8) & 1;
}

BOOL as::server::Box::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  void **v9;
  _QWORD *v10;
  void **v11;
  _QWORD *v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  char v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  int v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  BOOL v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  char v51;
  char v52;
  unsigned int v53;
  uint64_t v54;
  unint64_t v55;
  char v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  char v70;
  unsigned int v71;
  uint64_t v72;
  unint64_t v73;
  char v74;
  char v75;
  unsigned int v76;
  uint64_t v77;
  unint64_t v78;
  char v79;
  int v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char *v86;
  unint64_t v87;
  char *v88;
  _QWORD *v89;
  unint64_t v90;
  char *v91;
  char *v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  char *v97;
  char *v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  char *v103;
  char *v104;
  char *v105;
  _QWORD *v106;
  _QWORD *v107;
  uint64_t v108;
  int64x2_t v109;
  char *v110;
  char *v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  char v116;
  unsigned int v117;
  unint64_t v119;
  char v120;
  uint64_t v121;
  unint64_t v122;
  char v123;
  char *v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  uint64_t v128;
  char v129;
  unsigned int v130;
  unint64_t v132;
  char v133;
  unint64_t v134;
  char v135;
  int64x2_t *v138;
  uint64_t v139;
  int64x2_t v140;
  char *v141;
  uint64_t v142;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v138 = (int64x2_t *)(a1 + 16);
  v8 = a1 + 32;
  v9 = (void **)(a1 + 64);
  v10 = (_QWORD *)(a1 + 80);
  v11 = (void **)(a1 + 40);
  v12 = (_QWORD *)(a1 + 56);
  while (2)
  {
    v13 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      while (1)
      {
        v17 = v3 + 1;
        a2[1] = v3 + 1;
        v18 = *(_BYTE *)(v13 + v3);
        v16 |= (unint64_t)(v18 & 0x7F) << v14;
        if ((v18 & 0x80) == 0)
          goto LABEL_23;
        v14 += 7;
        v3 = v17;
        v46 = v15++ > 8;
        if (v46)
        {
          v16 = 0;
          goto LABEL_23;
        }
      }
    }
    v19 = 0;
    v20 = 0;
    v16 = 0;
    if (v3 <= v2)
      v21 = v2;
    else
      v21 = v3;
    do
    {
      if (v21 == v3)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v22 = v3++;
      v23 = *(_BYTE *)(v13 + v22);
      a2[1] = v3;
      v16 |= (unint64_t)(v23 & 0x7F) << v19;
      if ((v23 & 0x80) == 0)
        goto LABEL_22;
      v19 += 7;
    }
    while (v20++ < 9);
    v16 = 0;
LABEL_22:
    v17 = v22 + 1;
LABEL_23:
    v25 = v16 & 7;
    if (v25 == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v16 >> 3))
    {
      case 2u:
        v26 = operator new();
        *(_QWORD *)v26 = &off_24BFE3EC0;
        *(_DWORD *)(v26 + 8) = 0;
        *(_OWORD *)(v26 + 16) = 0u;
        *(_OWORD *)(v26 + 32) = 0u;
        *(_OWORD *)(v26 + 48) = 0u;
        v27 = *(_QWORD *)(a1 + 88);
        *(_QWORD *)(a1 + 88) = v26;
        if (v27)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
          v26 = *(_QWORD *)(a1 + 88);
        }
        if (!PB::Reader::placeMark())
          return 0;
        goto LABEL_161;
      case 3u:
        if (v17 >= v2)
        {
          v81 = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v80 = *(unsigned __int8 *)(v13 + v17);
          a2[1] = v17 + 1;
          v81 = v80 != 0;
        }
        *(_BYTE *)(a1 + 96) = v81;
        *(_DWORD *)(a1 + 8) |= 1u;
        goto LABEL_211;
      case 4u:
        if (v25 == 2)
        {
          if ((PB::Reader::placeMark() & 1) != 0)
            return 0;
          if (a2[1] < (unint64_t)a2[2] && !*((_BYTE *)a2 + 24))
          {
            v33 = *(char **)(a1 + 48);
            do
            {
              if ((unint64_t)v33 >= *v12)
              {
                v34 = (char *)*v11;
                v35 = (v33 - (_BYTE *)*v11) >> 3;
                v36 = v35 + 1;
                if ((unint64_t)(v35 + 1) >> 61)
                  goto LABEL_221;
                v37 = *v12 - (_QWORD)v34;
                if (v37 >> 2 > v36)
                  v36 = v37 >> 2;
                if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
                  v38 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v38 = v36;
                if (v38)
                {
                  v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v12, v38);
                  v34 = *(char **)(a1 + 40);
                  v33 = *(char **)(a1 + 48);
                }
                else
                {
                  v39 = 0;
                }
                v40 = &v39[8 * v35];
                *(_QWORD *)v40 = 0;
                v41 = v40 + 8;
                while (v33 != v34)
                {
                  v42 = *((_QWORD *)v33 - 1);
                  v33 -= 8;
                  *((_QWORD *)v40 - 1) = v42;
                  v40 -= 8;
                }
                *(_QWORD *)(a1 + 40) = v40;
                *(_QWORD *)(a1 + 48) = v41;
                *(_QWORD *)(a1 + 56) = &v39[8 * v38];
                if (v34)
                  operator delete(v34);
                v33 = v41;
              }
              else
              {
                *(_QWORD *)v33 = 0;
                v33 += 8;
              }
              *(_QWORD *)(a1 + 48) = v33;
              v44 = a2[1];
              v43 = a2[2];
              v45 = *a2;
              v46 = v44 > 0xFFFFFFFFFFFFFFF5 || v44 + 10 > v43;
              if (v46)
              {
                v47 = 0;
                v48 = 0;
                v54 = 0;
                if (v43 <= v44)
                  v49 = a2[1];
                else
                  v49 = a2[2];
                while (1)
                {
                  if (v49 == v44)
                    goto LABEL_137;
                  v50 = v44++;
                  v51 = *(_BYTE *)(v45 + v50);
                  a2[1] = v44;
                  v54 |= (unint64_t)(v51 & 0x7F) << v47;
                  if ((v51 & 0x80) == 0)
                    break;
                  v47 += 7;
                  v46 = v48++ > 8;
                  if (v46)
                  {
                    v54 = 0;
                    goto LABEL_72;
                  }
                }
                if (*((_BYTE *)a2 + 24))
                  v54 = 0;
LABEL_72:
                v55 = v50 + 1;
              }
              else
              {
                v52 = 0;
                v53 = 0;
                v54 = 0;
                while (1)
                {
                  v55 = v44 + 1;
                  a2[1] = v44 + 1;
                  v56 = *(_BYTE *)(v45 + v44);
                  v54 |= (unint64_t)(v56 & 0x7F) << v52;
                  if ((v56 & 0x80) == 0)
                    break;
                  v52 += 7;
                  v44 = v55;
                  v46 = v53++ > 8;
                  if (v46)
                  {
                    v54 = 0;
                    break;
                  }
                }
              }
              *((_QWORD *)v33 - 1) = v54;
            }
            while (v55 < v43 && !*((_BYTE *)a2 + 24));
          }
          goto LABEL_211;
        }
        v88 = *(char **)(a1 + 48);
        v87 = *(_QWORD *)(a1 + 56);
        if ((unint64_t)v88 >= v87)
        {
          v92 = (char *)*v11;
          v93 = (v88 - (_BYTE *)*v11) >> 3;
          v94 = v93 + 1;
          if ((unint64_t)(v93 + 1) >> 61)
LABEL_221:
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v95 = v87 - (_QWORD)v92;
          if (v95 >> 2 > v94)
            v94 = v95 >> 2;
          if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8)
            v96 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v96 = v94;
          if (v96)
          {
            v97 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v12, v96);
            v92 = *(char **)(a1 + 40);
            v88 = *(char **)(a1 + 48);
          }
          else
          {
            v97 = 0;
          }
          v111 = &v97[8 * v93];
          *(_QWORD *)v111 = 0;
          v89 = v111 + 8;
          while (v88 != v92)
          {
            v112 = *((_QWORD *)v88 - 1);
            v88 -= 8;
            *((_QWORD *)v111 - 1) = v112;
            v111 -= 8;
          }
          *(_QWORD *)(a1 + 40) = v111;
          *(_QWORD *)(a1 + 48) = v89;
          *(_QWORD *)(a1 + 56) = &v97[8 * v96];
          if (v92)
            operator delete(v92);
        }
        else
        {
          *(_QWORD *)v88 = 0;
          v89 = v88 + 8;
        }
        *(_QWORD *)(a1 + 48) = v89;
        v113 = a2[1];
        v114 = a2[2];
        v115 = *a2;
        v116 = 0;
        v117 = 0;
        if (v113 <= 0xFFFFFFFFFFFFFFF5 && v113 + 10 <= v114)
        {
          v121 = 0;
          while (1)
          {
            v122 = v113 + 1;
            a2[1] = v113 + 1;
            v123 = *(_BYTE *)(v115 + v113);
            v121 |= (unint64_t)(v123 & 0x7F) << v116;
            if ((v123 & 0x80) == 0)
              goto LABEL_210;
            v116 += 7;
            v113 = v122;
            v46 = v117++ > 8;
            if (v46)
              goto LABEL_206;
          }
        }
        v121 = 0;
        if (v114 <= v113)
          v114 = a2[1];
        while (v114 != v113)
        {
          v119 = v113 + 1;
          v120 = *(_BYTE *)(v115 + v113);
          a2[1] = v119;
          v121 |= (unint64_t)(v120 & 0x7F) << v116;
          if ((v120 & 0x80) == 0)
            goto LABEL_208;
          v116 += 7;
          v113 = v119;
          v46 = v117++ > 8;
          if (v46)
            goto LABEL_206;
        }
        goto LABEL_207;
      case 5u:
        if (v25 != 2)
        {
          v91 = *(char **)(a1 + 72);
          v90 = *(_QWORD *)(a1 + 80);
          if ((unint64_t)v91 >= v90)
          {
            v98 = (char *)*v9;
            v99 = (v91 - (_BYTE *)*v9) >> 3;
            v100 = v99 + 1;
            if ((unint64_t)(v99 + 1) >> 61)
LABEL_220:
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v101 = v90 - (_QWORD)v98;
            if (v101 >> 2 > v100)
              v100 = v101 >> 2;
            if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFF8)
              v102 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v102 = v100;
            if (v102)
            {
              v103 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v10, v102);
              v98 = *(char **)(a1 + 64);
              v91 = *(char **)(a1 + 72);
            }
            else
            {
              v103 = 0;
            }
            v124 = &v103[8 * v99];
            *(_QWORD *)v124 = 0;
            v89 = v124 + 8;
            while (v91 != v98)
            {
              v125 = *((_QWORD *)v91 - 1);
              v91 -= 8;
              *((_QWORD *)v124 - 1) = v125;
              v124 -= 8;
            }
            *(_QWORD *)(a1 + 64) = v124;
            *(_QWORD *)(a1 + 72) = v89;
            *(_QWORD *)(a1 + 80) = &v103[8 * v102];
            if (v98)
              operator delete(v98);
          }
          else
          {
            *(_QWORD *)v91 = 0;
            v89 = v91 + 8;
          }
          *(_QWORD *)(a1 + 72) = v89;
          v126 = a2[1];
          v127 = a2[2];
          v128 = *a2;
          v129 = 0;
          v130 = 0;
          if (v126 > 0xFFFFFFFFFFFFFFF5 || v126 + 10 > v127)
          {
            v121 = 0;
            if (v127 <= v126)
              v127 = a2[1];
            while (v127 != v126)
            {
              v132 = v126 + 1;
              v133 = *(_BYTE *)(v128 + v126);
              a2[1] = v132;
              v121 |= (unint64_t)(v133 & 0x7F) << v129;
              if ((v133 & 0x80) == 0)
              {
LABEL_208:
                if (*((_BYTE *)a2 + 24))
                  v121 = 0;
                goto LABEL_210;
              }
              v129 += 7;
              v126 = v132;
              v46 = v130++ > 8;
              if (v46)
              {
LABEL_206:
                v121 = 0;
                goto LABEL_210;
              }
            }
LABEL_207:
            v121 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v121 = 0;
            while (1)
            {
              v134 = v126 + 1;
              a2[1] = v126 + 1;
              v135 = *(_BYTE *)(v128 + v126);
              v121 |= (unint64_t)(v135 & 0x7F) << v129;
              if ((v135 & 0x80) == 0)
                break;
              v129 += 7;
              v126 = v134;
              v46 = v130++ > 8;
              if (v46)
                goto LABEL_206;
            }
          }
LABEL_210:
          *(v89 - 1) = v121;
          goto LABEL_211;
        }
        if ((PB::Reader::placeMark() & 1) == 0)
        {
          if (a2[1] >= (unint64_t)a2[2] || *((_BYTE *)a2 + 24))
            goto LABEL_211;
          v33 = *(char **)(a1 + 72);
          do
          {
            if ((unint64_t)v33 >= *v10)
            {
              v57 = (char *)*v9;
              v58 = (v33 - (_BYTE *)*v9) >> 3;
              v59 = v58 + 1;
              if ((unint64_t)(v58 + 1) >> 61)
                goto LABEL_220;
              v60 = *v10 - (_QWORD)v57;
              if (v60 >> 2 > v59)
                v59 = v60 >> 2;
              if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
                v61 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v61 = v59;
              if (v61)
              {
                v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v10, v61);
                v57 = *(char **)(a1 + 64);
                v33 = *(char **)(a1 + 72);
              }
              else
              {
                v62 = 0;
              }
              v63 = &v62[8 * v58];
              *(_QWORD *)v63 = 0;
              v64 = v63 + 8;
              while (v33 != v57)
              {
                v65 = *((_QWORD *)v33 - 1);
                v33 -= 8;
                *((_QWORD *)v63 - 1) = v65;
                v63 -= 8;
              }
              *(_QWORD *)(a1 + 64) = v63;
              *(_QWORD *)(a1 + 72) = v64;
              *(_QWORD *)(a1 + 80) = &v62[8 * v61];
              if (v57)
                operator delete(v57);
              v33 = v64;
            }
            else
            {
              *(_QWORD *)v33 = 0;
              v33 += 8;
            }
            *(_QWORD *)(a1 + 72) = v33;
            v67 = a2[1];
            v66 = a2[2];
            v68 = *a2;
            if (v67 <= 0xFFFFFFFFFFFFFFF5 && v67 + 10 <= v66)
            {
              v75 = 0;
              v76 = 0;
              v77 = 0;
              while (1)
              {
                v78 = v67 + 1;
                a2[1] = v67 + 1;
                v79 = *(_BYTE *)(v68 + v67);
                v77 |= (unint64_t)(v79 & 0x7F) << v75;
                if ((v79 & 0x80) == 0)
                  goto LABEL_118;
                v75 += 7;
                v67 = v78;
                v46 = v76++ > 8;
                if (v46)
                {
                  v77 = 0;
                  goto LABEL_118;
                }
              }
            }
            v70 = 0;
            v71 = 0;
            v77 = 0;
            if (v66 <= v67)
              v72 = a2[1];
            else
              v72 = a2[2];
            while (1)
            {
              if (v72 == v67)
              {
LABEL_137:
                *((_BYTE *)a2 + 24) = 1;
                *((_QWORD *)v33 - 1) = 0;
                goto LABEL_211;
              }
              v73 = v67++;
              v74 = *(_BYTE *)(v68 + v73);
              a2[1] = v67;
              v77 |= (unint64_t)(v74 & 0x7F) << v70;
              if ((v74 & 0x80) == 0)
                break;
              v70 += 7;
              v46 = v71++ > 8;
              if (v46)
              {
                v77 = 0;
                goto LABEL_117;
              }
            }
            if (*((_BYTE *)a2 + 24))
              v77 = 0;
LABEL_117:
            v78 = v73 + 1;
LABEL_118:
            *((_QWORD *)v33 - 1) = v77;
          }
          while (v78 < v66 && !*((_BYTE *)a2 + 24));
LABEL_211:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          continue;
        }
        return 0;
      case 6u:
        v28 = (_QWORD *)operator new();
        v29 = v28;
        v28[1] = 0;
        v28[2] = 0;
        *v28 = &off_24BFE3FA0;
        v31 = *(_QWORD **)(a1 + 24);
        v30 = *(_QWORD *)(a1 + 32);
        if ((unint64_t)v31 >= v30)
        {
          v82 = ((uint64_t)v31 - v138->i64[0]) >> 3;
          if ((unint64_t)(v82 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v83 = v30 - v138->i64[0];
          v84 = v83 >> 2;
          if (v83 >> 2 <= (unint64_t)(v82 + 1))
            v84 = v82 + 1;
          if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8)
            v85 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v85 = v84;
          v142 = v8;
          if (v85)
            v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v8, v85);
          else
            v86 = 0;
          v104 = &v86[8 * v82];
          v105 = &v86[8 * v85];
          v141 = v105;
          *(_QWORD *)v104 = v29;
          v32 = v104 + 8;
          v140.i64[1] = (uint64_t)(v104 + 8);
          v107 = *(_QWORD **)(a1 + 16);
          v106 = *(_QWORD **)(a1 + 24);
          if (v106 == v107)
          {
            v109 = vdupq_n_s64((unint64_t)v106);
          }
          else
          {
            do
            {
              v108 = *--v106;
              *v106 = 0;
              *((_QWORD *)v104 - 1) = v108;
              v104 -= 8;
            }
            while (v106 != v107);
            v109 = *v138;
            v32 = (_QWORD *)v140.i64[1];
            v105 = v141;
          }
          *(_QWORD *)(a1 + 16) = v104;
          *(_QWORD *)(a1 + 24) = v32;
          v140 = v109;
          v110 = *(char **)(a1 + 32);
          *(_QWORD *)(a1 + 32) = v105;
          v141 = v110;
          v139 = v109.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v139);
        }
        else
        {
          *v31 = v28;
          v32 = v31 + 1;
        }
        *(_QWORD *)(a1 + 24) = v32;
        v26 = *(v32 - 1);
        if ((PB::Reader::placeMark() & 1) == 0)
          return 0;
LABEL_161:
        if (((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v26 + 16))(v26, a2) & 1) == 0)
          return 0;
        PB::Reader::recallMark();
        goto LABEL_211;
      default:
        goto LABEL_211;
    }
  }
}

void sub_20680D024(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::Box::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const PB::Base **v9;
  const PB::Base **v10;
  const PB::Base *v11;

  v3 = this;
  v4 = *(const PB::Base **)(this + 88);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  if ((*(_BYTE *)(v3 + 8) & 1) != 0)
    this = PB::Writer::write(a2);
  v5 = *(_QWORD *)(v3 + 40);
  v6 = *(_QWORD *)(v3 + 48);
  while (v5 != v6)
  {
    v5 += 8;
    this = PB::Writer::writeVarInt(a2);
  }
  v7 = *(_QWORD *)(v3 + 64);
  v8 = *(_QWORD *)(v3 + 72);
  while (v7 != v8)
  {
    v7 += 8;
    this = PB::Writer::writeVarInt(a2);
  }
  v10 = *(const PB::Base ***)(v3 + 16);
  v9 = *(const PB::Base ***)(v3 + 24);
  while (v10 != v9)
  {
    v11 = *v10++;
    this = PB::Writer::writeSubmessage(a2, v11);
  }
  return this;
}

uint64_t as::server::Box::formatText(as::server::Box *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 11);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "hardwareInfo");
  if ((*((_BYTE *)this + 8) & 1) != 0)
    PB::TextFormatter::format(a2, "activated");
  v6 = *((_QWORD *)this + 5);
  v7 = *((_QWORD *)this + 6);
  while (v6 != v7)
  {
    v6 += 8;
    PB::TextFormatter::format(a2, "clocksIDs");
  }
  v8 = *((_QWORD *)this + 8);
  v9 = *((_QWORD *)this + 9);
  while (v8 != v9)
  {
    v8 += 8;
    PB::TextFormatter::format(a2, "deviceIDs");
  }
  v10 = (uint64_t *)*((_QWORD *)this + 2);
  v11 = (uint64_t *)*((_QWORD *)this + 3);
  while (v10 != v11)
  {
    v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v12 + 32))(v12, a2, "controls");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Box::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t *v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(unsigned __int8 *)(a1 + 96) != *(unsigned __int8 *)(a2 + 96))
    return 0;
  v4 = *(_QWORD *)(a1 + 88);
  v5 = *(_QWORD *)(a2 + 88);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
  }
  else if (!as::server::HardwareInfo::operator==((_DWORD *)v4, (_DWORD *)v5))
  {
    return 0;
  }
  v7 = *(uint64_t **)(a1 + 40);
  v8 = *(_QWORD **)(a1 + 48);
  v9 = v8 - v7;
  v10 = *(uint64_t **)(a2 + 40);
  if (v9 != (uint64_t)(*(_QWORD *)(a2 + 48) - (_QWORD)v10) >> 3)
    return 0;
  if (v8 != v7)
  {
    if (v9 <= 1)
      v9 = 1;
    do
    {
      v12 = *v7++;
      v11 = v12;
      v13 = *v10++;
      if (v11 != v13)
        return 0;
    }
    while (--v9);
  }
  v14 = *(uint64_t **)(a1 + 64);
  v15 = *(_QWORD **)(a1 + 72);
  v16 = v15 - v14;
  v17 = *(uint64_t **)(a2 + 64);
  if (v16 != (uint64_t)(*(_QWORD *)(a2 + 72) - (_QWORD)v17) >> 3)
    return 0;
  if (v15 != v14)
  {
    if (v16 <= 1)
      v16 = 1;
    do
    {
      v19 = *v14++;
      v18 = v19;
      v20 = *v17++;
      if (v18 != v20)
        return 0;
    }
    while (--v16);
  }
  v22 = *(_QWORD *)(a1 + 16);
  v21 = *(_QWORD *)(a1 + 24);
  v23 = (v21 - v22) >> 3;
  if (v23 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3)
    return 0;
  if (v21 == v22)
  {
    return 1;
  }
  else
  {
    v24 = 0;
    v25 = 0;
    if (v23 <= 1)
      v26 = 1;
    else
      v26 = (v21 - v22) >> 3;
    do
    {
      v27 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v25);
      v28 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v25);
      if (v27)
        v29 = v28 == 0;
      else
        v29 = 1;
      if (v29)
      {
        if (v27 | v28)
          return v24;
      }
      else if (!as::server::ControlAndValue::operator==(v27, v28))
      {
        return v24;
      }
      v24 = ++v25 >= v23;
    }
    while (v26 != v25);
  }
  return v24;
}

uint64_t as::server::Box::clearHardwareInfo(as::server::Box *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *as::server::Box::addControls(as::server::Box *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  _QWORD *result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = (_QWORD *)operator new();
  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE3FA0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return (_QWORD *)*(v6 - 1);
  }
  return result;
}

uint64_t as::server::Driver::default_instance(as::server::Driver *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE43C8;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_QWORD *)(v3 + 112) = 0;
    as::server::Driver::default_instance(void)::gInstance = v3;
  }
  return as::server::Driver::default_instance(void)::gInstance;
}

void sub_20680D58C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::Driver::Driver(as::server::Driver *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE43C8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 14) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE43C8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 14) = 0;
  return result;
}

as::server::Driver *as::server::Driver::Driver(as::server::Driver *this, const as::server::Driver *a2)
{
  *(_QWORD *)this = &off_24BFE43C8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Driver::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE43C8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Driver::copy_from(this, a2);
  return this;
}

void as::server::Driver::copy_from(as::server::Driver *this, const as::server::Driver *a2)
{
  const as::server::HardwareInfo *v4;
  as::server::HardwareInfo *v5;
  _QWORD *v6;
  as::server::Device_Clock ***v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  const as::server::Device_Clock **v11;
  const as::server::Device_Clock **v12;
  as::server::Device_Clock *v13;
  const as::server::Device_Clock *v14;
  unint64_t v15;
  as::server::Device_Clock **v16;
  _QWORD *v17;
  as::server::Device_Clock **v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  as::server::Device_Clock **v24;
  char *v25;
  as::server::Device_Clock *v26;
  __int128 v27;
  char *v28;
  _QWORD *v29;
  uint64_t **v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  const as::server::Clock **v34;
  const as::server::Clock **j;
  uint64_t v36;
  const as::server::Clock *v37;
  unint64_t v38;
  uint64_t *v39;
  _QWORD *v40;
  uint64_t *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  uint64_t *v47;
  char *v48;
  uint64_t v49;
  __int128 v50;
  char *v51;
  _QWORD *v52;
  as::server::Box ***v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  const as::server::Box **v57;
  const as::server::Box **k;
  as::server::Box *v59;
  const as::server::Box *v60;
  unint64_t v61;
  as::server::Box **v62;
  _QWORD *v63;
  as::server::Box **v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  as::server::Box **v70;
  char *v71;
  as::server::Box *v72;
  __int128 v73;
  char *v74;
  const as::server::Driver *i;
  uint64_t v76;
  __int128 v77;
  char *v78;
  char *v79;

  caulk::xstring::assign((as::server::Driver *)((char *)this + 88), (const as::server::Driver *)((char *)a2 + 88));
  v4 = (const as::server::HardwareInfo *)*((_QWORD *)a2 + 13);
  if (v4)
  {
    v5 = (as::server::HardwareInfo *)as::server::Driver::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v5, v4);
  }
  v6 = (_QWORD *)*((_QWORD *)this + 2);
  v8 = (_QWORD *)*((_QWORD *)this + 3);
  v7 = (as::server::Device_Clock ***)((char *)this + 16);
  while (v8 != v6)
  {
    v10 = *--v8;
    v9 = v10;
    *v8 = 0;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  *((_QWORD *)this + 3) = v6;
  v11 = (const as::server::Device_Clock **)*((_QWORD *)a2 + 2);
  v12 = (const as::server::Device_Clock **)*((_QWORD *)a2 + 3);
  for (i = a2; v11 != v12; ++v11)
  {
    v13 = (as::server::Device_Clock *)operator new();
    v14 = *v11;
    *((_QWORD *)v13 + 1) = 0;
    *((_QWORD *)v13 + 2) = 0;
    *(_QWORD *)v13 = &off_24BFE3E88;
    as::server::Device_Clock::copy_from(v13, v14);
    v16 = (as::server::Device_Clock **)*((_QWORD *)this + 3);
    v15 = *((_QWORD *)this + 4);
    if ((unint64_t)v16 >= v15)
    {
      v18 = *v7;
      v19 = v16 - *v7;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v21 = v15 - (_QWORD)v18;
      if (v21 >> 2 > v20)
        v20 = v21 >> 2;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
        v22 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      v79 = (char *)this + 32;
      if (v22)
      {
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v22);
        v18 = (as::server::Device_Clock **)*((_QWORD *)this + 2);
        v16 = (as::server::Device_Clock **)*((_QWORD *)this + 3);
      }
      else
      {
        v23 = 0;
      }
      v24 = (as::server::Device_Clock **)&v23[8 * v19];
      v25 = &v23[8 * v22];
      v78 = v25;
      *v24 = v13;
      *((_QWORD *)&v77 + 1) = v24 + 1;
      if (v16 == v18)
      {
        v17 = v24 + 1;
      }
      else
      {
        do
        {
          v26 = *--v16;
          *v16 = 0;
          *--v24 = v26;
        }
        while (v16 != v18);
        v17 = (_QWORD *)*((_QWORD *)&v77 + 1);
        v25 = v78;
      }
      v27 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v24;
      *((_QWORD *)this + 3) = v17;
      v77 = v27;
      v28 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v25;
      v78 = v28;
      v76 = v27;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v76);
    }
    else
    {
      *v16 = v13;
      v17 = v16 + 1;
    }
    *((_QWORD *)this + 3) = v17;
  }
  v29 = (_QWORD *)*((_QWORD *)this + 5);
  v31 = (_QWORD *)*((_QWORD *)this + 6);
  v30 = (uint64_t **)((char *)this + 40);
  while (v31 != v29)
  {
    v33 = *--v31;
    v32 = v33;
    *v31 = 0;
    if (v33)
      (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
  }
  *((_QWORD *)this + 6) = v29;
  v34 = (const as::server::Clock **)*((_QWORD *)i + 5);
  for (j = (const as::server::Clock **)*((_QWORD *)i + 6); v34 != j; ++v34)
  {
    v36 = operator new();
    v37 = *v34;
    *(_QWORD *)v36 = &off_24BFE4358;
    *(_OWORD *)(v36 + 16) = 0u;
    *(_OWORD *)(v36 + 32) = 0u;
    *(_OWORD *)(v36 + 48) = 0u;
    *(_OWORD *)(v36 + 64) = 0u;
    *(_OWORD *)(v36 + 80) = 0u;
    *(_QWORD *)(v36 + 96) = 0;
    as::server::Clock::copy_from((as::server::Clock *)v36, v37);
    v39 = (uint64_t *)*((_QWORD *)this + 6);
    v38 = *((_QWORD *)this + 7);
    if ((unint64_t)v39 >= v38)
    {
      v41 = *v30;
      v42 = v39 - *v30;
      v43 = v42 + 1;
      if ((unint64_t)(v42 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v44 = v38 - (_QWORD)v41;
      if (v44 >> 2 > v43)
        v43 = v44 >> 2;
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8)
        v45 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v45 = v43;
      v79 = (char *)this + 56;
      if (v45)
      {
        v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 56, v45);
        v41 = (uint64_t *)*((_QWORD *)this + 5);
        v39 = (uint64_t *)*((_QWORD *)this + 6);
      }
      else
      {
        v46 = 0;
      }
      v47 = (uint64_t *)&v46[8 * v42];
      v48 = &v46[8 * v45];
      v78 = v48;
      *v47 = v36;
      *((_QWORD *)&v77 + 1) = v47 + 1;
      if (v39 == v41)
      {
        v40 = v47 + 1;
      }
      else
      {
        do
        {
          v49 = *--v39;
          *v39 = 0;
          *--v47 = v49;
        }
        while (v39 != v41);
        v40 = (_QWORD *)*((_QWORD *)&v77 + 1);
        v48 = v78;
      }
      v50 = *(_OWORD *)((char *)this + 40);
      *((_QWORD *)this + 5) = v47;
      *((_QWORD *)this + 6) = v40;
      v77 = v50;
      v51 = (char *)*((_QWORD *)this + 7);
      *((_QWORD *)this + 7) = v48;
      v78 = v51;
      v76 = v50;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v76);
    }
    else
    {
      *v39 = v36;
      v40 = v39 + 1;
    }
    *((_QWORD *)this + 6) = v40;
  }
  v52 = (_QWORD *)*((_QWORD *)this + 8);
  v54 = (_QWORD *)*((_QWORD *)this + 9);
  v53 = (as::server::Box ***)((char *)this + 64);
  while (v54 != v52)
  {
    v56 = *--v54;
    v55 = v56;
    *v54 = 0;
    if (v56)
      (*(void (**)(uint64_t))(*(_QWORD *)v55 + 8))(v55);
  }
  *((_QWORD *)this + 9) = v52;
  v57 = (const as::server::Box **)*((_QWORD *)i + 8);
  for (k = (const as::server::Box **)*((_QWORD *)i + 9); v57 != k; ++v57)
  {
    v59 = (as::server::Box *)operator new();
    v60 = *v57;
    *(_QWORD *)v59 = &off_24BFE42E8;
    *((_OWORD *)v59 + 1) = 0u;
    *((_OWORD *)v59 + 2) = 0u;
    *((_OWORD *)v59 + 3) = 0u;
    *((_OWORD *)v59 + 4) = 0u;
    *((_OWORD *)v59 + 5) = 0u;
    as::server::Box::copy_from(v59, v60);
    v62 = (as::server::Box **)*((_QWORD *)this + 9);
    v61 = *((_QWORD *)this + 10);
    if ((unint64_t)v62 >= v61)
    {
      v64 = *v53;
      v65 = v62 - *v53;
      v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v67 = v61 - (_QWORD)v64;
      if (v67 >> 2 > v66)
        v66 = v67 >> 2;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      v79 = (char *)this + 80;
      if (v68)
      {
        v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 80, v68);
        v64 = (as::server::Box **)*((_QWORD *)this + 8);
        v62 = (as::server::Box **)*((_QWORD *)this + 9);
      }
      else
      {
        v69 = 0;
      }
      v70 = (as::server::Box **)&v69[8 * v65];
      v71 = &v69[8 * v68];
      v78 = v71;
      *v70 = v59;
      *((_QWORD *)&v77 + 1) = v70 + 1;
      if (v62 == v64)
      {
        v63 = v70 + 1;
      }
      else
      {
        do
        {
          v72 = *--v62;
          *v62 = 0;
          *--v70 = v72;
        }
        while (v62 != v64);
        v63 = (_QWORD *)*((_QWORD *)&v77 + 1);
        v71 = v78;
      }
      v73 = *((_OWORD *)this + 4);
      *((_QWORD *)this + 8) = v70;
      *((_QWORD *)this + 9) = v63;
      v77 = v73;
      v74 = (char *)*((_QWORD *)this + 10);
      *((_QWORD *)this + 10) = v71;
      v78 = v74;
      v76 = v73;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v76);
    }
    else
    {
      *v62 = v59;
      v63 = v62 + 1;
    }
    *((_QWORD *)this + 9) = v63;
  }
  *((_DWORD *)this + 2) = *((_DWORD *)i + 2);
  *((_QWORD *)this + 14) = *((_QWORD *)i + 14);
}

as::server::Driver *as::server::Driver::operator=(as::server::Driver *a1, const as::server::Driver *a2)
{
  as::server::Driver::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::Driver::hardwareInfo(as::server::Driver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 13);
  if (!result)
    return as::server::HardwareInfo::default_instance(0);
  return result;
}

uint64_t as::server::Driver::mutableHardwareInfo(as::server::Driver *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 13);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3EC0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    v3 = *((_QWORD *)this + 13);
    *((_QWORD *)this + 13) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::Driver::Driver(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE43C8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Driver::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE43C8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Driver::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Driver::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[2];

  v15[0] = 0;
  v15[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)v15);
  v5 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v5;
  v6 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v6;
  v7 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v7;
  v8 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v8;
  v9 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v9;
  v10 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v10;
  v11 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v11;
  v12 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v12;
  v13 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v13;
  v14 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v14;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  return result;
}

uint64_t as::server::Driver::operator=(uint64_t a1, uint64_t a2)
{
  as::server::Driver::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Driver::clear(as::server::Driver *this)
{
  uint64_t result;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;

  caulk::xstring::clear((as::server::Driver *)((char *)this + 88));
  result = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  v3 = (_QWORD *)*((_QWORD *)this + 2);
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  while (v4 != v3)
  {
    v5 = *--v4;
    result = v5;
    *v4 = 0;
    if (v5)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 3) = v3;
  v6 = (_QWORD *)*((_QWORD *)this + 5);
  v7 = (_QWORD *)*((_QWORD *)this + 6);
  while (v7 != v6)
  {
    v8 = *--v7;
    result = v8;
    *v7 = 0;
    if (v8)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 6) = v6;
  v9 = (_QWORD *)*((_QWORD *)this + 8);
  v10 = (_QWORD *)*((_QWORD *)this + 9);
  while (v10 != v9)
  {
    v11 = *--v10;
    result = v11;
    *v10 = 0;
    if (v11)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 9) = v9;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 14) = 0;
  return result;
}

BOOL as::server::Driver::isInitialized(as::server::Driver *this)
{
  as::server::Device_Clock **v2;
  as::server::Device_Clock **v3;
  as::server::Clock **v4;
  as::server::Clock **v5;
  as::server::Box **v6;
  as::server::Box **v7;

  if (!*((_QWORD *)this + 13))
    return 0;
  v2 = (as::server::Device_Clock **)*((_QWORD *)this + 2);
  v3 = (as::server::Device_Clock **)*((_QWORD *)this + 3);
  while (v2 != v3)
  {
    if (!as::server::Device_Clock::isInitialized(*v2))
      return 0;
    ++v2;
  }
  v4 = (as::server::Clock **)*((_QWORD *)this + 5);
  v5 = (as::server::Clock **)*((_QWORD *)this + 6);
  while (v4 != v5)
  {
    if (!as::server::Clock::isInitialized(*v4))
      return 0;
    ++v4;
  }
  v6 = (as::server::Box **)*((_QWORD *)this + 8);
  v7 = (as::server::Box **)*((_QWORD *)this + 9);
  while (v6 != v7)
  {
    if ((as::server::Box::isInitialized(*v6) & 1) == 0)
      return 0;
    ++v6;
  }
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::Driver::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  BOOL v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  unint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char v50;
  unsigned int v51;
  unint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  uint64_t *v64;
  char *v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  int64x2_t v69;
  char *v70;
  char *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  int64x2_t v75;
  uint64_t *v76;
  char *v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  int64x2_t v81;
  char *v82;
  char *v83;
  char *v84;
  int64x2_t *v87;
  int64x2_t *v88;
  void *__p;
  int64x2_t v90;
  char *v91;
  uint64_t v92;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v8 = a1 + 80;
  v87 = (int64x2_t *)(a1 + 40);
  v88 = (int64x2_t *)(a1 + 64);
  v9 = a1 + 56;
  v10 = (int64x2_t *)(a1 + 16);
  v11 = a1 + 32;
  while (2)
  {
    v12 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      while (1)
      {
        v16 = v3 + 1;
        a2[1] = v3 + 1;
        v17 = *(_BYTE *)(v12 + v3);
        v15 |= (unint64_t)(v17 & 0x7F) << v13;
        if ((v17 & 0x80) == 0)
          goto LABEL_23;
        v13 += 7;
        v3 = v16;
        v18 = v14++ > 8;
        if (v18)
        {
          v15 = 0;
          goto LABEL_23;
        }
      }
    }
    v19 = 0;
    v20 = 0;
    v15 = 0;
    if (v3 <= v2)
      v21 = v2;
    else
      v21 = v3;
    do
    {
      if (v21 == v3)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v22 = v3++;
      v23 = *(_BYTE *)(v12 + v22);
      a2[1] = v3;
      v15 |= (unint64_t)(v23 & 0x7F) << v19;
      if ((v23 & 0x80) == 0)
        goto LABEL_22;
      v19 += 7;
      v24 = v20++ >= 9;
    }
    while (!v24);
    v15 = 0;
LABEL_22:
    v16 = v22 + 1;
LABEL_23:
    if ((v15 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v15 >> 3))
    {
      case 1u:
        if (v16 > 0xFFFFFFFFFFFFFFF5 || v16 + 10 > v2)
        {
          v50 = 0;
          v51 = 0;
          v27 = 0;
          if (v2 <= v16)
            v2 = v16;
          do
          {
            if (v2 == v16)
            {
              v27 = 0;
              *((_BYTE *)a2 + 24) = 1;
              goto LABEL_100;
            }
            v52 = v16 + 1;
            v53 = *(_BYTE *)(v12 + v16);
            a2[1] = v52;
            v27 |= (unint64_t)(v53 & 0x7F) << v50;
            if ((v53 & 0x80) == 0)
              goto LABEL_100;
            v50 += 7;
            v16 = v52;
            v24 = v51++ >= 9;
          }
          while (!v24);
LABEL_58:
          v27 = 0;
        }
        else
        {
          v25 = 0;
          v26 = 0;
          v27 = 0;
          while (1)
          {
            v28 = v16 + 1;
            a2[1] = v16 + 1;
            v29 = *(_BYTE *)(v12 + v16);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0)
              break;
            v25 += 7;
            v16 = v28;
            v18 = v26++ > 8;
            if (v18)
              goto LABEL_58;
          }
        }
LABEL_100:
        *(_QWORD *)(a1 + 112) = v27;
        *(_DWORD *)(a1 + 8) |= 1u;
        goto LABEL_101;
      case 2u:
        __p = 0;
        v90 = 0uLL;
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 2u;
        if (v90.i8[15] < 0)
          operator delete(__p);
        goto LABEL_101;
      case 3u:
        v35 = operator new();
        *(_QWORD *)v35 = &off_24BFE3EC0;
        *(_DWORD *)(v35 + 8) = 0;
        *(_OWORD *)(v35 + 16) = 0u;
        *(_OWORD *)(v35 + 32) = 0u;
        *(_OWORD *)(v35 + 48) = 0u;
        v36 = *(_QWORD *)(a1 + 104);
        *(_QWORD *)(a1 + 104) = v35;
        if (v36)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
          v35 = *(_QWORD *)(a1 + 104);
        }
        if (!PB::Reader::placeMark())
          return 0;
        goto LABEL_97;
      case 4u:
        v37 = (_QWORD *)operator new();
        v38 = v37;
        v37[1] = 0;
        v37[2] = 0;
        *v37 = &off_24BFE3E88;
        v40 = *(_QWORD **)(a1 + 24);
        v39 = *(_QWORD *)(a1 + 32);
        if ((unint64_t)v40 >= v39)
        {
          v54 = ((uint64_t)v40 - v10->i64[0]) >> 3;
          if ((unint64_t)(v54 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v55 = v39 - v10->i64[0];
          v56 = v55 >> 2;
          if (v55 >> 2 <= (unint64_t)(v54 + 1))
            v56 = v54 + 1;
          if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
            v57 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v57 = v56;
          v92 = v11;
          if (v57)
            v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v11, v57);
          else
            v58 = 0;
          v70 = &v58[8 * v54];
          v71 = &v58[8 * v57];
          v91 = v71;
          *(_QWORD *)v70 = v38;
          v34 = v70 + 8;
          v90.i64[1] = (uint64_t)(v70 + 8);
          v73 = *(_QWORD **)(a1 + 16);
          v72 = *(_QWORD **)(a1 + 24);
          if (v72 == v73)
          {
            v75 = vdupq_n_s64((unint64_t)v72);
          }
          else
          {
            do
            {
              v74 = *--v72;
              *v72 = 0;
              *((_QWORD *)v70 - 1) = v74;
              v70 -= 8;
            }
            while (v72 != v73);
            v75 = *v10;
            v34 = (_QWORD *)v90.i64[1];
            v71 = v91;
          }
          *(_QWORD *)(a1 + 16) = v70;
          *(_QWORD *)(a1 + 24) = v34;
          v90 = v75;
          v83 = *(char **)(a1 + 32);
          *(_QWORD *)(a1 + 32) = v71;
          v91 = v83;
          __p = (void *)v75.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v40 = v37;
          v34 = v40 + 1;
        }
        *(_QWORD *)(a1 + 24) = v34;
        goto LABEL_96;
      case 5u:
        v30 = operator new();
        v31 = v30;
        *(_QWORD *)v30 = &off_24BFE4358;
        *(_DWORD *)(v30 + 8) = 0;
        *(_OWORD *)(v30 + 16) = 0u;
        *(_OWORD *)(v30 + 32) = 0u;
        *(_OWORD *)(v30 + 48) = 0u;
        *(_OWORD *)(v30 + 64) = 0u;
        *(_OWORD *)(v30 + 80) = 0u;
        *(_OWORD *)(v30 + 96) = 0u;
        *(_OWORD *)(v30 + 112) = 0u;
        *(_QWORD *)(v30 + 128) = 0;
        v33 = *(uint64_t **)(a1 + 48);
        v32 = *(_QWORD *)(a1 + 56);
        if ((unint64_t)v33 >= v32)
        {
          v45 = ((uint64_t)v33 - v87->i64[0]) >> 3;
          if ((unint64_t)(v45 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v46 = v32 - v87->i64[0];
          v47 = v46 >> 2;
          if (v46 >> 2 <= (unint64_t)(v45 + 1))
            v47 = v45 + 1;
          if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8)
            v48 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v48 = v47;
          v92 = v9;
          if (v48)
            v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v48);
          else
            v49 = 0;
          v64 = (uint64_t *)&v49[8 * v45];
          v65 = &v49[8 * v48];
          v91 = v65;
          *v64 = v31;
          v34 = v64 + 1;
          v90.i64[1] = (uint64_t)(v64 + 1);
          v67 = *(_QWORD **)(a1 + 40);
          v66 = *(_QWORD **)(a1 + 48);
          if (v66 == v67)
          {
            v69 = vdupq_n_s64((unint64_t)v66);
          }
          else
          {
            do
            {
              v68 = *--v66;
              *v66 = 0;
              *--v64 = v68;
            }
            while (v66 != v67);
            v69 = *v87;
            v34 = (_QWORD *)v90.i64[1];
            v65 = v91;
          }
          *(_QWORD *)(a1 + 40) = v64;
          *(_QWORD *)(a1 + 48) = v34;
          v90 = v69;
          v82 = *(char **)(a1 + 56);
          *(_QWORD *)(a1 + 56) = v65;
          v91 = v82;
          __p = (void *)v69.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v33 = v30;
          v34 = v33 + 1;
        }
        *(_QWORD *)(a1 + 48) = v34;
        goto LABEL_96;
      case 6u:
        v41 = operator new();
        v42 = v41;
        *(_QWORD *)v41 = &off_24BFE42E8;
        *(_DWORD *)(v41 + 8) = 0;
        *(_OWORD *)(v41 + 16) = 0u;
        *(_OWORD *)(v41 + 32) = 0u;
        *(_OWORD *)(v41 + 48) = 0u;
        *(_OWORD *)(v41 + 64) = 0u;
        *(_OWORD *)(v41 + 80) = 0u;
        *(_BYTE *)(v41 + 96) = 0;
        v44 = *(uint64_t **)(a1 + 72);
        v43 = *(_QWORD *)(a1 + 80);
        if ((unint64_t)v44 >= v43)
        {
          v59 = ((uint64_t)v44 - v88->i64[0]) >> 3;
          if ((unint64_t)(v59 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v60 = v43 - v88->i64[0];
          v61 = v60 >> 2;
          if (v60 >> 2 <= (unint64_t)(v59 + 1))
            v61 = v59 + 1;
          if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
            v62 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v62 = v61;
          v92 = v8;
          if (v62)
            v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v8, v62);
          else
            v63 = 0;
          v76 = (uint64_t *)&v63[8 * v59];
          v77 = &v63[8 * v62];
          v91 = v77;
          *v76 = v42;
          v34 = v76 + 1;
          v90.i64[1] = (uint64_t)(v76 + 1);
          v79 = *(_QWORD **)(a1 + 64);
          v78 = *(_QWORD **)(a1 + 72);
          if (v78 == v79)
          {
            v81 = vdupq_n_s64((unint64_t)v78);
          }
          else
          {
            do
            {
              v80 = *--v78;
              *v78 = 0;
              *--v76 = v80;
            }
            while (v78 != v79);
            v81 = *v88;
            v34 = (_QWORD *)v90.i64[1];
            v77 = v91;
          }
          *(_QWORD *)(a1 + 64) = v76;
          *(_QWORD *)(a1 + 72) = v34;
          v90 = v81;
          v84 = *(char **)(a1 + 80);
          *(_QWORD *)(a1 + 80) = v77;
          v91 = v84;
          __p = (void *)v81.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v44 = v41;
          v34 = v44 + 1;
        }
        *(_QWORD *)(a1 + 72) = v34;
LABEL_96:
        v35 = *(v34 - 1);
        if ((PB::Reader::placeMark() & 1) == 0)
          return 0;
LABEL_97:
        if (((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v35 + 16))(v35, a2) & 1) != 0)
        {
          PB::Reader::recallMark();
LABEL_101:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          continue;
        }
        return 0;
      default:
        goto LABEL_101;
    }
  }
}

void sub_20680E5E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;

  (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  _Unwind_Resume(a1);
}

void as::server::Driver::writeTo(as::server::Driver *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  const PB::Base *v6;
  const PB::Base **v7;
  const PB::Base **v8;
  const PB::Base *v9;
  const PB::Base **v10;
  const PB::Base **v11;
  const PB::Base *v12;
  const PB::Base **v13;
  const PB::Base **v14;
  const PB::Base *v15;
  void *__p;
  char v17;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::server::Driver *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v17 < 0)
      operator delete(__p);
  }
  v6 = (const PB::Base *)*((_QWORD *)this + 13);
  if (v6)
    PB::Writer::writeSubmessage(a2, v6);
  v7 = (const PB::Base **)*((_QWORD *)this + 2);
  v8 = (const PB::Base **)*((_QWORD *)this + 3);
  while (v7 != v8)
  {
    v9 = *v7++;
    PB::Writer::writeSubmessage(a2, v9);
  }
  v10 = (const PB::Base **)*((_QWORD *)this + 5);
  v11 = (const PB::Base **)*((_QWORD *)this + 6);
  while (v10 != v11)
  {
    v12 = *v10++;
    PB::Writer::writeSubmessage(a2, v12);
  }
  v14 = (const PB::Base **)*((_QWORD *)this + 8);
  v13 = (const PB::Base **)*((_QWORD *)this + 9);
  while (v14 != v13)
  {
    v15 = *v14++;
    PB::Writer::writeSubmessage(a2, v15);
  }
}

void sub_20680E724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::Driver::formatText(as::server::Driver *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  void *__p;
  char v19;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "objectToken");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::server::Driver *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v19 < 0)
      operator delete(__p);
  }
  v7 = *((_QWORD *)this + 13);
  if (v7)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v7 + 32))(v7, a2, "hardwareInfo");
  v8 = (uint64_t *)*((_QWORD *)this + 2);
  v9 = (uint64_t *)*((_QWORD *)this + 3);
  while (v8 != v9)
  {
    v10 = *v8++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v10 + 32))(v10, a2, "devices");
  }
  v11 = (uint64_t *)*((_QWORD *)this + 5);
  v12 = (uint64_t *)*((_QWORD *)this + 6);
  while (v11 != v12)
  {
    v13 = *v11++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v13 + 32))(v13, a2, "clocks");
  }
  v14 = (uint64_t *)*((_QWORD *)this + 8);
  v15 = (uint64_t *)*((_QWORD *)this + 9);
  while (v14 != v15)
  {
    v16 = *v14++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v16 + 32))(v16, a2, "boxes");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_20680E8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::Driver::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(_QWORD *)(a1 + 112) != *(_QWORD *)(a2 + 112)
    || caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)))
  {
    return 0;
  }
  v6 = *(_QWORD *)(a1 + 104);
  v7 = *(_QWORD *)(a2 + 104);
  if (v6 && v7)
  {
    if (as::server::HardwareInfo::operator==((_DWORD *)v6, (_DWORD *)v7))
      goto LABEL_11;
    return 0;
  }
  if (v6 | v7)
    return 0;
LABEL_11:
  v9 = *(_QWORD *)(a1 + 16);
  v8 = *(_QWORD *)(a1 + 24);
  v10 = (v8 - v9) >> 3;
  if (v10 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3)
    return 0;
  if (v8 != v9)
  {
    v11 = 0;
    if (v10 <= 1)
      v12 = 1;
    else
      v12 = (v8 - v9) >> 3;
    do
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v11);
      v14 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v11);
      if (v13)
        v15 = v14 == 0;
      else
        v15 = 1;
      if (v15)
      {
        if (v13 | v14)
          return 0;
      }
      else if (!as::server::Device_Clock::operator==(v13, v14))
      {
        return 0;
      }
      ++v11;
    }
    while (v12 != v11);
  }
  v17 = *(_QWORD *)(a1 + 40);
  v16 = *(_QWORD *)(a1 + 48);
  v18 = (v16 - v17) >> 3;
  if (v18 != (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
    return 0;
  if (v16 != v17)
  {
    v19 = 0;
    if (v18 <= 1)
      v20 = 1;
    else
      v20 = (v16 - v17) >> 3;
    do
    {
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v19);
      v22 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v19);
      if (v21)
        v23 = v22 == 0;
      else
        v23 = 1;
      if (v23)
      {
        if (v21 | v22)
          return 0;
      }
      else if (!as::server::Clock::operator==(v21, v22))
      {
        return 0;
      }
      ++v19;
    }
    while (v20 != v19);
  }
  v25 = *(_QWORD *)(a1 + 64);
  v24 = *(_QWORD *)(a1 + 72);
  v26 = (v24 - v25) >> 3;
  if (v26 != (uint64_t)(*(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64)) >> 3)
    return 0;
  if (v24 == v25)
  {
    return 1;
  }
  else
  {
    v4 = 0;
    v27 = 0;
    if (v26 <= 1)
      v28 = 1;
    else
      v28 = (v24 - v25) >> 3;
    do
    {
      v29 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v27);
      v30 = *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v27);
      if (v29)
        v31 = v30 == 0;
      else
        v31 = 1;
      if (v31)
      {
        if (v29 | v30)
          return v4;
      }
      else if (!as::server::Box::operator==(v29, v30))
      {
        return v4;
      }
      v4 = ++v27 >= v26;
    }
    while (v28 != v27);
  }
  return v4;
}

uint64_t as::server::Driver::clearHardwareInfo(as::server::Driver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *as::server::Driver::addDevices(as::server::Driver *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  _QWORD *result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = (_QWORD *)operator new();
  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE3E88;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return (_QWORD *)*(v6 - 1);
  }
  return result;
}

uint64_t as::server::Driver::addClocks(as::server::Driver *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4358;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_QWORD *)(result + 128) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::Driver::addBoxes(as::server::Driver *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 10);
  v2 = (char *)this + 80;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 8);
      v5 = (_QWORD *)*((_QWORD *)this + 9);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 4);
    *((_QWORD *)this + 8) = v13;
    *((_QWORD *)this + 9) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 10);
    *((_QWORD *)this + 10) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 9) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE42E8;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_BYTE *)(result + 96) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::HardwareSystemState::default_instance(as::server::HardwareSystemState *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE41D0;
    *(_OWORD *)(v3 + 8) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    as::server::HardwareSystemState::default_instance(void)::gInstance = v3;
  }
  return as::server::HardwareSystemState::default_instance(void)::gInstance;
}

void sub_20680EF6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::HardwareSystemState::HardwareSystemState(as::server::HardwareSystemState *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE41D0;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE41D0;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

as::server::HardwareSystemState *as::server::HardwareSystemState::HardwareSystemState(as::server::HardwareSystemState *this, const as::server::HardwareSystemState *a2)
{
  *(_QWORD *)this = &off_24BFE41D0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::HardwareSystemState::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE41D0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::HardwareSystemState::copy_from(this, a2);
  return this;
}

void as::server::HardwareSystemState::copy_from(as::server::HardwareSystemState *this, const as::server::HardwareSystemState *a2)
{
  _QWORD *v4;
  as::server::Driver ***v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  const as::server::Driver **v9;
  const as::server::Driver **v10;
  as::server::Driver *v11;
  const as::server::Driver *v12;
  unint64_t v13;
  as::server::Driver **v14;
  _QWORD *v15;
  as::server::Driver **v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  as::server::Driver **v22;
  char *v23;
  as::server::Driver *v24;
  __int128 v25;
  char *v26;
  _QWORD *v27;
  as::RouteIdentifier ***v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  const as::RouteIdentifier **v32;
  const as::RouteIdentifier **j;
  as::RouteIdentifier *v34;
  unint64_t v35;
  as::RouteIdentifier **v36;
  _QWORD *v37;
  as::RouteIdentifier **v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  as::RouteIdentifier **v44;
  char *v45;
  as::RouteIdentifier *v46;
  __int128 v47;
  char *v48;
  const as::server::HardwareSystemState *i;
  uint64_t v50;
  __int128 v51;
  char *v52;
  char *v53;

  v4 = (_QWORD *)*((_QWORD *)this + 1);
  v6 = (_QWORD *)*((_QWORD *)this + 2);
  v5 = (as::server::Driver ***)((char *)this + 8);
  while (v6 != v4)
  {
    v8 = *--v6;
    v7 = v8;
    *v6 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  *((_QWORD *)this + 2) = v4;
  v9 = (const as::server::Driver **)*((_QWORD *)a2 + 1);
  v10 = (const as::server::Driver **)*((_QWORD *)a2 + 2);
  for (i = a2; v9 != v10; ++v9)
  {
    v11 = (as::server::Driver *)operator new();
    v12 = *v9;
    *(_QWORD *)v11 = &off_24BFE43C8;
    *((_OWORD *)v11 + 1) = 0u;
    *((_OWORD *)v11 + 2) = 0u;
    *((_OWORD *)v11 + 3) = 0u;
    *((_OWORD *)v11 + 4) = 0u;
    *((_OWORD *)v11 + 5) = 0u;
    *((_OWORD *)v11 + 6) = 0u;
    as::server::Driver::copy_from(v11, v12);
    v14 = (as::server::Driver **)*((_QWORD *)this + 2);
    v13 = *((_QWORD *)this + 3);
    if ((unint64_t)v14 >= v13)
    {
      v16 = *v5;
      v17 = v14 - *v5;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v53 = (char *)this + 24;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 24, v20);
        v16 = (as::server::Driver **)*((_QWORD *)this + 1);
        v14 = (as::server::Driver **)*((_QWORD *)this + 2);
      }
      else
      {
        v21 = 0;
      }
      v22 = (as::server::Driver **)&v21[8 * v17];
      v23 = &v21[8 * v20];
      v52 = v23;
      *v22 = v11;
      *((_QWORD *)&v51 + 1) = v22 + 1;
      if (v14 == v16)
      {
        v15 = v22 + 1;
      }
      else
      {
        do
        {
          v24 = *--v14;
          *v14 = 0;
          *--v22 = v24;
        }
        while (v14 != v16);
        v15 = (_QWORD *)*((_QWORD *)&v51 + 1);
        v23 = v52;
      }
      v25 = *(_OWORD *)((char *)this + 8);
      *((_QWORD *)this + 1) = v22;
      *((_QWORD *)this + 2) = v15;
      v51 = v25;
      v26 = (char *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = v23;
      v52 = v26;
      v50 = v25;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v50);
    }
    else
    {
      *v14 = v11;
      v15 = v14 + 1;
    }
    *((_QWORD *)this + 2) = v15;
  }
  v27 = (_QWORD *)*((_QWORD *)this + 4);
  v29 = (_QWORD *)*((_QWORD *)this + 5);
  v28 = (as::RouteIdentifier ***)((char *)this + 32);
  while (v29 != v27)
  {
    v31 = *--v29;
    v30 = v31;
    *v29 = 0;
    if (v31)
      (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  }
  *((_QWORD *)this + 5) = v27;
  v32 = (const as::RouteIdentifier **)*((_QWORD *)i + 4);
  for (j = (const as::RouteIdentifier **)*((_QWORD *)i + 5); v32 != j; ++v32)
  {
    v34 = (as::RouteIdentifier *)operator new();
    as::RouteIdentifier::RouteIdentifier(v34, *v32);
    v36 = (as::RouteIdentifier **)*((_QWORD *)this + 5);
    v35 = *((_QWORD *)this + 6);
    if ((unint64_t)v36 >= v35)
    {
      v38 = *v28;
      v39 = v36 - *v28;
      v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v41 = v35 - (_QWORD)v38;
      if (v41 >> 2 > v40)
        v40 = v41 >> 2;
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
        v42 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v42 = v40;
      v53 = (char *)this + 48;
      if (v42)
      {
        v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 48, v42);
        v38 = (as::RouteIdentifier **)*((_QWORD *)this + 4);
        v36 = (as::RouteIdentifier **)*((_QWORD *)this + 5);
      }
      else
      {
        v43 = 0;
      }
      v44 = (as::RouteIdentifier **)&v43[8 * v39];
      v45 = &v43[8 * v42];
      v52 = v45;
      *v44 = v34;
      *((_QWORD *)&v51 + 1) = v44 + 1;
      if (v36 == v38)
      {
        v37 = v44 + 1;
      }
      else
      {
        do
        {
          v46 = *--v36;
          *v36 = 0;
          *--v44 = v46;
        }
        while (v36 != v38);
        v37 = (_QWORD *)*((_QWORD *)&v51 + 1);
        v45 = v52;
      }
      v47 = *((_OWORD *)this + 2);
      *((_QWORD *)this + 4) = v44;
      *((_QWORD *)this + 5) = v37;
      v51 = v47;
      v48 = (char *)*((_QWORD *)this + 6);
      *((_QWORD *)this + 6) = v45;
      v52 = v48;
      v50 = v47;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v50);
    }
    else
    {
      *v36 = v34;
      v37 = v36 + 1;
    }
    *((_QWORD *)this + 5) = v37;
  }
}

as::server::HardwareSystemState *as::server::HardwareSystemState::operator=(as::server::HardwareSystemState *a1, const as::server::HardwareSystemState *a2)
{
  as::server::HardwareSystemState::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::HardwareSystemState::HardwareSystemState(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)a1 = &off_24BFE41D0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::HardwareSystemState::move_from((_QWORD *)a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE41D0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::HardwareSystemState::move_from((_QWORD *)a1, a2);
  return a1;
}

_QWORD *as::server::HardwareSystemState::move_from(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  v5 = result[4];
  result[4] = a2[4];
  a2[4] = v5;
  v6 = result[5];
  result[5] = a2[5];
  a2[5] = v6;
  v7 = result[6];
  result[6] = a2[6];
  a2[6] = v7;
  return result;
}

_QWORD *as::server::HardwareSystemState::operator=(_QWORD *a1, _QWORD *a2)
{
  as::server::HardwareSystemState::move_from(a1, a2);
  return a1;
}

_QWORD *as::server::HardwareSystemState::clear(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  v1 = this;
  v2 = (_QWORD *)this[1];
  v3 = (_QWORD *)this[2];
  while (v3 != v2)
  {
    v4 = (_QWORD *)*--v3;
    this = v4;
    *v3 = 0;
    if (v4)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[2] = v2;
  v5 = (_QWORD *)v1[4];
  v6 = (_QWORD *)v1[5];
  while (v6 != v5)
  {
    v7 = (_QWORD *)*--v6;
    this = v7;
    *v6 = 0;
    if (v7)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[5] = v5;
  return this;
}

uint64_t as::server::HardwareSystemState::isInitialized(as::server::HardwareSystemState *this)
{
  as::server::Driver **v2;
  as::server::Driver **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  BOOL v8;

  v2 = (as::server::Driver **)*((_QWORD *)this + 1);
  v3 = (as::server::Driver **)*((_QWORD *)this + 2);
  while (v2 != v3)
  {
    if (!as::server::Driver::isInitialized(*v2))
      return 0;
    ++v2;
  }
  v4 = *((_QWORD *)this + 4);
  v5 = *((_QWORD *)this + 5);
  if (v4 == v5)
    return 1;
  v6 = v4 + 8;
  do
  {
    result = as::RouteIdentifier::isInitialized(*(as::RouteIdentifier **)(v6 - 8));
    if ((_DWORD)result)
      v8 = v6 == v5;
    else
      v8 = 1;
    v6 += 8;
  }
  while (!v8);
  return result;
}

BOOL as::server::HardwareSystemState::readFrom(_QWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t v9;
  int64x2_t *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  char v19;
  unsigned int v20;
  unint64_t v21;
  char v22;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t *v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t *v42;
  char *v43;
  _QWORD *v44;
  _QWORD *v45;
  uint64_t v46;
  int64x2_t v47;
  uint64_t *v48;
  char *v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  int64x2_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v58;
  int64x2_t v59;
  char *v60;
  uint64_t v61;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v8 = (int64x2_t *)(a1 + 4);
    v9 = (uint64_t)(a1 + 6);
    v10 = (int64x2_t *)(a1 + 1);
    v11 = (uint64_t)(a1 + 3);
    do
    {
      v12 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v19 = 0;
        v20 = 0;
        v15 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v21 = v2 + 1;
          v22 = *(_BYTE *)(v12 + v2);
          a2[1] = v21;
          v15 |= (unint64_t)(v22 & 0x7F) << v19;
          if ((v22 & 0x80) == 0)
            goto LABEL_21;
          v19 += 7;
          v2 = v21;
          if (v20++ >= 9)
          {
LABEL_20:
            v15 = 0;
            goto LABEL_21;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v13 = 0;
      v14 = 0;
      v15 = 0;
      while (1)
      {
        v16 = v2 + 1;
        a2[1] = v2 + 1;
        v17 = *(_BYTE *)(v12 + v2);
        v15 |= (unint64_t)(v17 & 0x7F) << v13;
        if ((v17 & 0x80) == 0)
          break;
        v13 += 7;
        v2 = v16;
        if (v14++ > 8)
          goto LABEL_20;
      }
LABEL_21:
      if ((v15 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v15 >> 3) == 2)
      {
        v29 = operator new();
        as::RouteIdentifier::RouteIdentifier(v29);
        v31 = (uint64_t *)a1[5];
        v30 = a1[6];
        if ((unint64_t)v31 >= v30)
        {
          v37 = ((uint64_t)v31 - v8->i64[0]) >> 3;
          if ((unint64_t)(v37 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v38 = v30 - v8->i64[0];
          v39 = v38 >> 2;
          if (v38 >> 2 <= (unint64_t)(v37 + 1))
            v39 = v37 + 1;
          if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8)
            v40 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v40 = v39;
          v61 = v9;
          if (v40)
            v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v40);
          else
            v41 = 0;
          v48 = (uint64_t *)&v41[8 * v37];
          v49 = &v41[8 * v40];
          v60 = v49;
          *v48 = v29;
          v28 = v48 + 1;
          v59.i64[1] = (uint64_t)(v48 + 1);
          v51 = (_QWORD *)a1[4];
          v50 = (_QWORD *)a1[5];
          if (v50 == v51)
          {
            v53 = vdupq_n_s64((unint64_t)v50);
          }
          else
          {
            do
            {
              v52 = *--v50;
              *v50 = 0;
              *--v48 = v52;
            }
            while (v50 != v51);
            v53 = *v8;
            v28 = (_QWORD *)v59.i64[1];
            v49 = v60;
          }
          a1[4] = v48;
          a1[5] = v28;
          v59 = v53;
          v55 = (char *)a1[6];
          a1[6] = v49;
          v60 = v55;
          v58 = v53.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v58);
        }
        else
        {
          *v31 = v29;
          v28 = v31 + 1;
        }
        a1[5] = v28;
      }
      else
      {
        if ((v15 >> 3) != 1)
          goto LABEL_61;
        v24 = operator new();
        v25 = v24;
        *(_QWORD *)v24 = &off_24BFE43C8;
        *(_DWORD *)(v24 + 8) = 0;
        *(_OWORD *)(v24 + 16) = 0u;
        *(_OWORD *)(v24 + 32) = 0u;
        *(_OWORD *)(v24 + 48) = 0u;
        *(_OWORD *)(v24 + 64) = 0u;
        *(_OWORD *)(v24 + 80) = 0u;
        *(_OWORD *)(v24 + 96) = 0u;
        *(_QWORD *)(v24 + 112) = 0;
        v27 = (uint64_t *)a1[2];
        v26 = a1[3];
        if ((unint64_t)v27 >= v26)
        {
          v32 = ((uint64_t)v27 - v10->i64[0]) >> 3;
          if ((unint64_t)(v32 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v33 = v26 - v10->i64[0];
          v34 = v33 >> 2;
          if (v33 >> 2 <= (unint64_t)(v32 + 1))
            v34 = v32 + 1;
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
            v35 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v35 = v34;
          v61 = v11;
          if (v35)
            v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v11, v35);
          else
            v36 = 0;
          v42 = (uint64_t *)&v36[8 * v32];
          v43 = &v36[8 * v35];
          v60 = v43;
          *v42 = v25;
          v28 = v42 + 1;
          v59.i64[1] = (uint64_t)(v42 + 1);
          v45 = (_QWORD *)a1[1];
          v44 = (_QWORD *)a1[2];
          if (v44 == v45)
          {
            v47 = vdupq_n_s64((unint64_t)v44);
          }
          else
          {
            do
            {
              v46 = *--v44;
              *v44 = 0;
              *--v42 = v46;
            }
            while (v44 != v45);
            v47 = *v10;
            v28 = (_QWORD *)v59.i64[1];
            v43 = v60;
          }
          a1[1] = v42;
          a1[2] = v28;
          v59 = v47;
          v54 = (char *)a1[3];
          a1[3] = v43;
          v60 = v54;
          v58 = v47.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v58);
        }
        else
        {
          *v27 = v24;
          v28 = v27 + 1;
        }
        a1[2] = v28;
      }
      v56 = *(v28 - 1);
      if ((PB::Reader::placeMark() & 1) == 0
        || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v56 + 16))(v56, a2) & 1) == 0)
      {
        return 0;
      }
      PB::Reader::recallMark();
LABEL_61:
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

void sub_20680F940(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::HardwareSystemState::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base **v4;
  const PB::Base **v5;
  const PB::Base *v6;
  const PB::Base **v7;
  const PB::Base **v8;
  const PB::Base *v9;

  v3 = this;
  v4 = *(const PB::Base ***)(this + 8);
  v5 = *(const PB::Base ***)(this + 16);
  while (v4 != v5)
  {
    v6 = *v4++;
    this = PB::Writer::writeSubmessage(a2, v6);
  }
  v8 = *(const PB::Base ***)(v3 + 32);
  v7 = *(const PB::Base ***)(v3 + 40);
  while (v8 != v7)
  {
    v9 = *v8++;
    this = PB::Writer::writeSubmessage(a2, v9);
  }
  return this;
}

uint64_t as::server::HardwareSystemState::formatText(as::server::HardwareSystemState *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = (uint64_t *)*((_QWORD *)this + 1);
  v6 = (uint64_t *)*((_QWORD *)this + 2);
  while (v5 != v6)
  {
    v7 = *v5++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v7 + 32))(v7, a2, "drivers");
  }
  v8 = (uint64_t *)*((_QWORD *)this + 4);
  v9 = (uint64_t *)*((_QWORD *)this + 5);
  while (v8 != v9)
  {
    v10 = *v8++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v10 + 32))(v10, a2, "defaultRoutes");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::HardwareSystemState::operator==(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;

  v3 = a1[1];
  v2 = a1[2];
  v4 = (v2 - v3) >> 3;
  if (v4 != (uint64_t)(a2[2] - a2[1]) >> 3)
    return 0;
  if (v2 != v3)
  {
    v7 = 0;
    if (v4 <= 1)
      v8 = 1;
    else
      v8 = (v2 - v3) >> 3;
    do
    {
      v9 = *(_QWORD *)(a1[1] + 8 * v7);
      v10 = *(_QWORD *)(a2[1] + 8 * v7);
      if (v9)
        v11 = v10 == 0;
      else
        v11 = 1;
      if (v11)
      {
        if (v9 | v10)
          return 0;
      }
      else if (!as::server::Driver::operator==(v9, v10))
      {
        return 0;
      }
      ++v7;
    }
    while (v8 != v7);
  }
  v13 = a1[4];
  v12 = a1[5];
  v14 = (v12 - v13) >> 3;
  if (v14 == (uint64_t)(a2[5] - a2[4]) >> 3)
  {
    if (v12 == v13)
    {
      return 1;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      if (v14 <= 1)
        v17 = 1;
      else
        v17 = (v12 - v13) >> 3;
      do
      {
        v18 = *(_QWORD *)(a1[4] + 8 * v16);
        v19 = *(_QWORD *)(a2[4] + 8 * v16);
        if (v18)
          v20 = v19 == 0;
        else
          v20 = 1;
        if (v20)
        {
          if (v18 | v19)
            return v15;
        }
        else if (!as::RouteIdentifier::operator==(v18, v19))
        {
          return v15;
        }
        v15 = ++v16 >= v14;
      }
      while (v17 != v16);
    }
  }
  else
  {
    return 0;
  }
  return v15;
}

uint64_t as::server::HardwareSystemState::addDrivers(as::server::HardwareSystemState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 3);
  v2 = (char *)this + 24;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 1);
      v5 = (_QWORD *)*((_QWORD *)this + 2);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 8);
    *((_QWORD *)this + 1) = v13;
    *((_QWORD *)this + 2) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 2) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE43C8;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_QWORD *)(result + 112) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::HardwareSystemState::addDefaultRoutes(as::server::HardwareSystemState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  char *v23;
  char *v24;

  v4 = *((_QWORD *)this + 6);
  v2 = (char *)this + 48;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v24 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 4);
      v5 = (_QWORD *)*((_QWORD *)this + 5);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v23 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v22 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v22 + 1);
      v14 = v23;
    }
    v16 = *((_OWORD *)this + 2);
    *((_QWORD *)this + 4) = v13;
    *((_QWORD *)this + 5) = v6;
    v22 = v16;
    v17 = (char *)*((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v14;
    v23 = v17;
    v21 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v21);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 5) = v6;
  v18 = operator new();
  result = as::RouteIdentifier::RouteIdentifier(v18);
  v20 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::SelectorControlItem::default_instance(as::server::SelectorControlItem *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4208;
    *(_DWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 24) = 0;
    *(_QWORD *)(v3 + 32) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    as::server::SelectorControlItem::default_instance(void)::gInstance = v3;
  }
  return as::server::SelectorControlItem::default_instance(void)::gInstance;
}

void sub_20680FECC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::server::SelectorControlItem::SelectorControlItem(uint64_t this)
{
  *(_QWORD *)this = &off_24BFE4208;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 16) = 0;
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4208;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 16) = 0;
  return this;
}

as::server::SelectorControlItem *as::server::SelectorControlItem::SelectorControlItem(as::server::SelectorControlItem *this, const as::server::SelectorControlItem *a2)
{
  *(_QWORD *)this = &off_24BFE4208;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::server::SelectorControlItem::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4208;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::server::SelectorControlItem::copy_from(this, a2);
  return this;
}

uint64_t as::server::SelectorControlItem::copy_from(as::server::SelectorControlItem *this, const as::server::SelectorControlItem *a2)
{
  uint64_t result;

  result = caulk::xstring::assign((as::server::SelectorControlItem *)((char *)this + 16), (const as::server::SelectorControlItem *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  return result;
}

as::server::SelectorControlItem *as::server::SelectorControlItem::operator=(as::server::SelectorControlItem *a1, const as::server::SelectorControlItem *a2)
{
  as::server::SelectorControlItem::copy_from(a1, a2);
  return a1;
}

_QWORD *as::server::SelectorControlItem::SelectorControlItem(_QWORD *a1, uint64_t a2)
{
  *a1 = &off_24BFE4208;
  a1[2] = 0;
  a1[3] = 0;
  as::server::SelectorControlItem::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &off_24BFE4208;
  a1[2] = 0;
  a1[3] = 0;
  as::server::SelectorControlItem::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::server::SelectorControlItem::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

uint64_t as::server::SelectorControlItem::operator=(uint64_t a1, uint64_t a2)
{
  as::server::SelectorControlItem::move_from(a1, a2);
  return a1;
}

uint64_t as::server::SelectorControlItem::clear(as::server::SelectorControlItem *this)
{
  uint64_t result;

  result = caulk::xstring::clear((as::server::SelectorControlItem *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 4) = 0;
  return result;
}

BOOL as::server::SelectorControlItem::isInitialized(as::server::SelectorControlItem *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::SelectorControlItem::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  unint64_t v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  char v27;
  unsigned int v28;
  uint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  unint64_t v33;
  char v34;
  char v35;
  unsigned int v36;
  unint64_t v37;
  char v38;
  int v39;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  while (1)
  {
    v8 = *a2;
    if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      break;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = v3 + 1;
      a2[1] = v3 + 1;
      v13 = *(_BYTE *)(v8 + v3);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0)
        break;
      v9 += 7;
      v3 = v12;
      v14 = v10++ > 8;
      if (v14)
      {
        v11 = 0;
        break;
      }
    }
    v3 = v12;
LABEL_23:
    if ((v11 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    v21 = v11 >> 3;
    if ((_DWORD)v21 == 3)
    {
      PB::Reader::read();
      caulk::xstring::assign();
      a1[2] |= 4u;
      v3 = a2[1];
      v2 = a2[2];
    }
    else
    {
      if ((_DWORD)v21 == 2)
      {
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v35 = 0;
          v36 = 0;
          v29 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v37 = v3++;
            v38 = *(_BYTE *)(v8 + v37);
            a2[1] = v3;
            v29 |= (unint64_t)(v38 & 0x7F) << v35;
            if ((v38 & 0x80) == 0)
              goto LABEL_59;
            v35 += 7;
            v20 = v36++ >= 9;
            if (v20)
            {
              LODWORD(v29) = 0;
LABEL_59:
              v25 = v37 + 1;
              goto LABEL_63;
            }
          }
          LODWORD(v29) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v27 = 0;
          v28 = 0;
          v29 = 0;
          while (1)
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v30 = *(_BYTE *)(v8 + v3);
            v29 |= (unint64_t)(v30 & 0x7F) << v27;
            if ((v30 & 0x80) == 0)
              break;
            v27 += 7;
            v3 = v25;
            v14 = v28++ > 8;
            if (v14)
            {
              LODWORD(v29) = 0;
              break;
            }
          }
        }
LABEL_63:
        a1[9] = v29;
        v39 = a1[2] | 2;
      }
      else
      {
        if ((_DWORD)v21 != 1)
          goto LABEL_65;
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v31 = 0;
          v32 = 0;
          v24 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v33 = v3++;
            v34 = *(_BYTE *)(v8 + v33);
            a2[1] = v3;
            v24 |= (unint64_t)(v34 & 0x7F) << v31;
            if ((v34 & 0x80) == 0)
              goto LABEL_50;
            v31 += 7;
            v20 = v32++ >= 9;
            if (v20)
            {
              LODWORD(v24) = 0;
LABEL_50:
              v25 = v33 + 1;
              goto LABEL_61;
            }
          }
          LODWORD(v24) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = 0;
          while (1)
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v26 = *(_BYTE *)(v8 + v3);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0)
              break;
            v22 += 7;
            v3 = v25;
            v14 = v23++ > 8;
            if (v14)
            {
              LODWORD(v24) = 0;
              break;
            }
          }
        }
LABEL_61:
        a1[8] = v24;
        v39 = a1[2] | 1;
      }
      a1[2] = v39;
      v3 = v25;
    }
LABEL_65:
    v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((_BYTE *)a2 + 24))
      return v4 == 0;
  }
  v15 = 0;
  v16 = 0;
  v11 = 0;
  if (v3 <= v2)
    v17 = v2;
  else
    v17 = v3;
  while (v17 != v3)
  {
    v18 = v3++;
    v19 = *(_BYTE *)(v8 + v18);
    a2[1] = v3;
    v11 |= (unint64_t)(v19 & 0x7F) << v15;
    if ((v19 & 0x80) == 0)
      goto LABEL_22;
    v15 += 7;
    v20 = v16++ >= 9;
    if (v20)
    {
      v11 = 0;
LABEL_22:
      v3 = v18 + 1;
      goto LABEL_23;
    }
  }
  v4 = 1;
  *((_BYTE *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_206810484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::server::SelectorControlItem::writeTo(as::server::SelectorControlItem *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  void *__p;
  char v7;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        return;
      goto LABEL_7;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  if ((*((_DWORD *)this + 2) & 4) == 0)
    return;
LABEL_7:
  v5 = (char *)caulk::xstring::c_str((as::server::SelectorControlItem *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(&__p, v5);
  PB::Writer::write();
  if (v7 < 0)
    operator delete(__p);
}

void sub_206810540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::SelectorControlItem::formatText(as::server::SelectorControlItem *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  void *__p;
  char v9;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0)
      goto LABEL_3;
LABEL_6:
    PB::TextFormatter::format(a2, "kind");
    if ((*((_DWORD *)this + 2) & 4) == 0)
      return PB::TextFormatter::endObject(a2);
    goto LABEL_7;
  }
  PB::TextFormatter::format(a2, "ID");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 2) != 0)
    goto LABEL_6;
LABEL_3:
  if ((v5 & 4) == 0)
    return PB::TextFormatter::endObject(a2);
LABEL_7:
  v6 = (char *)caulk::xstring::c_str((as::server::SelectorControlItem *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(&__p, v6);
  PB::TextFormatter::format();
  if (v9 < 0)
    operator delete(__p);
  return PB::TextFormatter::endObject(a2);
}

void sub_20681061C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::SelectorControlItem::operator==(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)
      && caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
}

uint64_t as::server::ControlValue::default_instance(as::server::ControlValue *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3E50;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 57) = 0u;
    as::server::ControlValue::default_instance(void)::gInstance = v3;
  }
  return as::server::ControlValue::default_instance(void)::gInstance;
}

void sub_206810710(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::ControlValue::ControlValue(as::server::ControlValue *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3E50;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3E50;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

as::server::ControlValue *as::server::ControlValue::ControlValue(as::server::ControlValue *this, const as::server::ControlValue *a2)
{
  *(_QWORD *)this = &off_24BFE3E50;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  as::server::ControlValue::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3E50;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  as::server::ControlValue::copy_from(this, a2);
  return this;
}

__n128 as::server::ControlValue::copy_from(as::server::ControlValue *this, const as::server::ControlValue *a2)
{
  __n128 result;
  __int128 v5;

  if (this != a2)
    std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((char *)this + 16, *((char **)a2 + 2), *((_QWORD *)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 2);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 40);
  v5 = *(_OWORD *)((char *)a2 + 56);
  *((_BYTE *)this + 72) = *((_BYTE *)a2 + 72);
  *(_OWORD *)((char *)this + 56) = v5;
  *(__n128 *)((char *)this + 40) = result;
  return result;
}

as::server::ControlValue *as::server::ControlValue::operator=(as::server::ControlValue *a1, const as::server::ControlValue *a2)
{
  as::server::ControlValue::copy_from(a1, a2);
  return a1;
}

__n128 as::server::ControlValue::ControlValue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __n128 result;
  __int128 v5;

  *(_QWORD *)a1 = &off_24BFE3E50;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v2;
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v5 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  __n128 result;
  __int128 v5;

  *(_QWORD *)a1 = &off_24BFE3E50;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v2;
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v5 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::ControlValue::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 result;
  __int128 v6;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v6 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::ControlValue::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 result;
  __int128 v6;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v6 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double as::server::ControlValue::clear(as::server::ControlValue *this)
{
  double result;

  *((_QWORD *)this + 3) = *((_QWORD *)this + 2);
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_BYTE *)this + 72) = 0;
  return result;
}

BOOL as::server::ControlValue::isInitialized(as::server::ControlValue *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::ControlValue::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  void **v8;
  _QWORD *v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  char v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  BOOL v21;
  int v22;
  unint64_t v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  char v27;
  char *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  BOOL v44;
  unint64_t v45;
  char v46;
  char v47;
  char v48;
  unsigned int v49;
  uint64_t v50;
  char v51;
  int v52;
  BOOL v53;
  char v54;
  unsigned int v55;
  uint64_t v56;
  char v57;
  char v58;
  unsigned int v59;
  unint64_t v60;
  char v61;
  unint64_t v62;
  char *v63;
  _DWORD *v64;
  int v65;
  char v66;
  unsigned int v67;
  unint64_t v68;
  char v69;
  char v70;
  unsigned int v71;
  unint64_t v72;
  char v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  int v80;
  char *v82;
  int v83;
  unint64_t v84;
  uint64_t v85;
  char v86;
  unsigned int v87;
  unint64_t v89;
  char v90;
  uint64_t v91;
  char v92;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v8 = (void **)(a1 + 16);
    v9 = (_QWORD *)(a1 + 32);
    do
    {
      v10 = *a2;
      if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3)
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        while (1)
        {
          v14 = v2 + 1;
          a2[1] = v2 + 1;
          v15 = *(_BYTE *)(v10 + v2);
          v13 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0)
            break;
          v11 += 7;
          v2 = v14;
          v44 = v12++ > 8;
          if (v44)
          {
            v13 = 0;
            break;
          }
        }
        v2 = v14;
        goto LABEL_24;
      }
      v16 = 0;
      v17 = 0;
      v13 = 0;
      if (v2 <= v3)
        v18 = v3;
      else
        v18 = v2;
      do
      {
        if (v18 == v2)
        {
          v4 = 1;
          *((_BYTE *)a2 + 24) = 1;
          return v4 == 0;
        }
        v19 = v2++;
        v20 = *(_BYTE *)(v10 + v19);
        a2[1] = v2;
        v13 |= (unint64_t)(v20 & 0x7F) << v16;
        if ((v20 & 0x80) == 0)
          goto LABEL_23;
        v16 += 7;
        v21 = v17++ >= 9;
      }
      while (!v21);
      v13 = 0;
LABEL_23:
      v2 = v19 + 1;
LABEL_24:
      v22 = v13 & 7;
      if (v22 == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v23 = v13 >> 3;
      if ((int)v23 <= 20)
      {
        if ((int)v23 <= 9)
        {
          if ((_DWORD)v23 == 1)
          {
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              v66 = 0;
              v67 = 0;
              v50 = 0;
              if (v3 <= v2)
                v3 = v2;
              while (v3 != v2)
              {
                v68 = v2++;
                v69 = *(_BYTE *)(v10 + v68);
                a2[1] = v2;
                v50 |= (unint64_t)(v69 & 0x7F) << v66;
                if ((v69 & 0x80) == 0)
                  goto LABEL_134;
                v66 += 7;
                v21 = v67++ >= 9;
                if (v21)
                {
                  v50 = 0;
LABEL_134:
                  v3 = v68 + 1;
                  goto LABEL_160;
                }
              }
              v50 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v48 = 0;
              v49 = 0;
              v50 = 0;
              while (1)
              {
                v3 = v2 + 1;
                a2[1] = v2 + 1;
                v51 = *(_BYTE *)(v10 + v2);
                v50 |= (unint64_t)(v51 & 0x7F) << v48;
                if ((v51 & 0x80) == 0)
                  break;
                v48 += 7;
                v2 = v3;
                v44 = v49++ > 8;
                if (v44)
                {
                  v50 = 0;
                  break;
                }
              }
            }
LABEL_160:
            *(_QWORD *)(a1 + 56) = v50;
            v80 = *(_DWORD *)(a1 + 8) | 1;
          }
          else
          {
            if ((_DWORD)v23 != 6)
              goto LABEL_164;
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              v58 = 0;
              v59 = 0;
              v26 = 0;
              if (v3 <= v2)
                v3 = v2;
              while (v3 != v2)
              {
                v60 = v2++;
                v61 = *(_BYTE *)(v10 + v60);
                a2[1] = v2;
                v26 |= (unint64_t)(v61 & 0x7F) << v58;
                if ((v61 & 0x80) == 0)
                  goto LABEL_120;
                v58 += 7;
                v21 = v59++ >= 9;
                if (v21)
                {
                  LODWORD(v26) = 0;
LABEL_120:
                  v3 = v60 + 1;
                  goto LABEL_158;
                }
              }
              LODWORD(v26) = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v24 = 0;
              v25 = 0;
              v26 = 0;
              while (1)
              {
                v3 = v2 + 1;
                a2[1] = v2 + 1;
                v27 = *(_BYTE *)(v10 + v2);
                v26 |= (unint64_t)(v27 & 0x7F) << v24;
                if ((v27 & 0x80) == 0)
                  break;
                v24 += 7;
                v2 = v3;
                v44 = v25++ > 8;
                if (v44)
                {
                  LODWORD(v26) = 0;
                  break;
                }
              }
            }
LABEL_158:
            *(_DWORD *)(a1 + 68) = v26;
            v80 = *(_DWORD *)(a1 + 8) | 2;
          }
          goto LABEL_163;
        }
        if ((_DWORD)v23 == 10)
        {
          if (v2 >= v3)
          {
            v53 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v52 = *(unsigned __int8 *)(v10 + v2++);
            a2[1] = v2;
            v53 = v52 != 0;
          }
          *(_BYTE *)(a1 + 72) = v53;
          v65 = *(_DWORD *)(a1 + 8) | 4;
        }
        else
        {
          if ((_DWORD)v23 != 20)
            goto LABEL_164;
          if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 40) = *(_DWORD *)(v10 + v2);
            v2 = a2[1] + 4;
            a2[1] = v2;
          }
          v65 = *(_DWORD *)(a1 + 8) | 8;
        }
LABEL_139:
        *(_DWORD *)(a1 + 8) = v65;
        goto LABEL_164;
      }
      if ((int)v23 > 39)
      {
        if ((_DWORD)v23 != 40)
        {
          if ((_DWORD)v23 != 50)
            goto LABEL_164;
          if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(v10 + v2);
            v2 = a2[1] + 4;
            a2[1] = v2;
          }
          v65 = *(_DWORD *)(a1 + 8) | 0x40;
          goto LABEL_139;
        }
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v70 = 0;
          v71 = 0;
          v56 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v72 = v2++;
            v73 = *(_BYTE *)(v10 + v72);
            a2[1] = v2;
            v56 |= (unint64_t)(v73 & 0x7F) << v70;
            if ((v73 & 0x80) == 0)
              goto LABEL_147;
            v70 += 7;
            v21 = v71++ >= 9;
            if (v21)
            {
              LODWORD(v56) = 0;
LABEL_147:
              v3 = v72 + 1;
              goto LABEL_162;
            }
          }
          LODWORD(v56) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v54 = 0;
          v55 = 0;
          v56 = 0;
          while (1)
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v57 = *(_BYTE *)(v10 + v2);
            v56 |= (unint64_t)(v57 & 0x7F) << v54;
            if ((v57 & 0x80) == 0)
              break;
            v54 += 7;
            v2 = v3;
            v44 = v55++ > 8;
            if (v44)
            {
              LODWORD(v56) = 0;
              break;
            }
          }
        }
LABEL_162:
        *(_DWORD *)(a1 + 64) = v56;
        v80 = *(_DWORD *)(a1 + 8) | 0x20;
LABEL_163:
        *(_DWORD *)(a1 + 8) = v80;
        v2 = v3;
      }
      else
      {
        if ((_DWORD)v23 == 21)
        {
          if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 44) = *(_DWORD *)(v10 + v2);
            v2 = a2[1] + 4;
            a2[1] = v2;
          }
          v65 = *(_DWORD *)(a1 + 8) | 0x10;
          goto LABEL_139;
        }
        if ((_DWORD)v23 != 31)
          goto LABEL_164;
        if (v22 == 2)
        {
          if ((PB::Reader::placeMark() & 1) != 0)
            return 0;
          v2 = a2[1];
          if (v2 >= a2[2] || *((_BYTE *)a2 + 24))
            goto LABEL_164;
          v28 = *(char **)(a1 + 24);
          do
          {
            if ((unint64_t)v28 >= *v9)
            {
              v29 = (char *)*v8;
              v30 = (v28 - (_BYTE *)*v8) >> 2;
              v31 = v30 + 1;
              if ((unint64_t)(v30 + 1) >> 62)
                goto LABEL_201;
              v32 = *v9 - (_QWORD)v29;
              if (v32 >> 1 > v31)
                v31 = v32 >> 1;
              if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL)
                v33 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v33 = v31;
              if (v33)
              {
                v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v33);
                v29 = *(char **)(a1 + 16);
                v28 = *(char **)(a1 + 24);
              }
              else
              {
                v34 = 0;
              }
              v35 = &v34[4 * v30];
              *(_DWORD *)v35 = 0;
              v36 = v35 + 4;
              while (v28 != v29)
              {
                v37 = *((_DWORD *)v28 - 1);
                v28 -= 4;
                *((_DWORD *)v35 - 1) = v37;
                v35 -= 4;
              }
              *(_QWORD *)(a1 + 16) = v35;
              *(_QWORD *)(a1 + 24) = v36;
              *(_QWORD *)(a1 + 32) = &v34[4 * v33];
              if (v29)
                operator delete(v29);
              v28 = v36;
            }
            else
            {
              *(_DWORD *)v28 = 0;
              v28 += 4;
            }
            *(_QWORD *)(a1 + 24) = v28;
            v39 = a2[1];
            v38 = a2[2];
            v40 = *a2;
            v41 = 0;
            v42 = 0;
            v43 = 0;
            v44 = v39 > 0xFFFFFFFFFFFFFFF5 || v39 + 10 > v38;
            if (!v44)
            {
              while (1)
              {
                v2 = v39 + 1;
                a2[1] = v39 + 1;
                v47 = *(_BYTE *)(v40 + v39);
                v43 |= (unint64_t)(v47 & 0x7F) << v41;
                if ((v47 & 0x80) == 0)
                  goto LABEL_81;
                v41 += 7;
                v39 = v2;
                v44 = v42++ > 8;
                if (v44)
                {
                  LODWORD(v43) = 0;
                  goto LABEL_81;
                }
              }
            }
            if (v38 <= v39)
              v2 = a2[1];
            else
              v2 = a2[2];
            while (1)
            {
              if (v2 == v39)
              {
                *((_BYTE *)a2 + 24) = 1;
                *((_DWORD *)v28 - 1) = 0;
                goto LABEL_164;
              }
              v45 = v39++;
              v46 = *(_BYTE *)(v40 + v45);
              a2[1] = v39;
              v43 |= (unint64_t)(v46 & 0x7F) << v41;
              if ((v46 & 0x80) == 0)
                break;
              v41 += 7;
              v44 = v42++ > 8;
              if (v44)
              {
                LODWORD(v43) = 0;
                goto LABEL_80;
              }
            }
            if (*((_BYTE *)a2 + 24))
              LODWORD(v43) = 0;
LABEL_80:
            v2 = v45 + 1;
LABEL_81:
            *((_DWORD *)v28 - 1) = v43;
          }
          while (v2 < v38 && !*((_BYTE *)a2 + 24));
        }
        else
        {
          v63 = *(char **)(a1 + 24);
          v62 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v63 >= v62)
          {
            v74 = (char *)*v8;
            v75 = (v63 - (_BYTE *)*v8) >> 2;
            v76 = v75 + 1;
            if ((unint64_t)(v75 + 1) >> 62)
LABEL_201:
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v77 = v62 - (_QWORD)v74;
            if (v77 >> 1 > v76)
              v76 = v77 >> 1;
            if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFFCLL)
              v78 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v78 = v76;
            if (v78)
            {
              v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v78);
              v74 = *(char **)(a1 + 16);
              v63 = *(char **)(a1 + 24);
            }
            else
            {
              v79 = 0;
            }
            v82 = &v79[4 * v75];
            *(_DWORD *)v82 = 0;
            v64 = v82 + 4;
            while (v63 != v74)
            {
              v83 = *((_DWORD *)v63 - 1);
              v63 -= 4;
              *((_DWORD *)v82 - 1) = v83;
              v82 -= 4;
            }
            *(_QWORD *)(a1 + 16) = v82;
            *(_QWORD *)(a1 + 24) = v64;
            *(_QWORD *)(a1 + 32) = &v79[4 * v78];
            if (v74)
              operator delete(v74);
          }
          else
          {
            *(_DWORD *)v63 = 0;
            v64 = v63 + 4;
          }
          *(_QWORD *)(a1 + 24) = v64;
          v84 = a2[1];
          v2 = a2[2];
          v85 = *a2;
          v86 = 0;
          v87 = 0;
          if (v84 > 0xFFFFFFFFFFFFFFF5 || v84 + 10 > v2)
          {
            v91 = 0;
            if (v2 <= v84)
              v2 = a2[1];
            while (1)
            {
              if (v2 == v84)
              {
                LODWORD(v91) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_195;
              }
              v89 = v84++;
              v90 = *(_BYTE *)(v85 + v89);
              a2[1] = v84;
              v91 |= (unint64_t)(v90 & 0x7F) << v86;
              if ((v90 & 0x80) == 0)
                break;
              v86 += 7;
              v44 = v87++ > 8;
              if (v44)
              {
                LODWORD(v91) = 0;
                goto LABEL_194;
              }
            }
            if (*((_BYTE *)a2 + 24))
              LODWORD(v91) = 0;
LABEL_194:
            v2 = v89 + 1;
          }
          else
          {
            v91 = 0;
            while (1)
            {
              v2 = v84 + 1;
              a2[1] = v84 + 1;
              v92 = *(_BYTE *)(v85 + v84);
              v91 |= (unint64_t)(v92 & 0x7F) << v86;
              if ((v92 & 0x80) == 0)
                break;
              v86 += 7;
              v84 = v2;
              v44 = v87++ > 8;
              if (v44)
              {
                LODWORD(v91) = 0;
                break;
              }
            }
          }
LABEL_195:
          *(v64 - 1) = v91;
        }
      }
LABEL_164:
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && v4 == 0);
  }
  return v4 == 0;
}

uint64_t as::server::ControlValue::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_16;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
LABEL_17:
    this = PB::Writer::write(a2, *(float *)(v3 + 40));
    if ((*(_DWORD *)(v3 + 8) & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_16:
  this = PB::Writer::write(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) != 0)
    goto LABEL_17;
LABEL_5:
  if ((v4 & 0x10) != 0)
LABEL_6:
    this = PB::Writer::write(a2, *(float *)(v3 + 44));
LABEL_7:
  v5 = *(_QWORD *)(v3 + 16);
  v6 = *(_QWORD *)(v3 + 24);
  while (v5 != v6)
  {
    v5 += 4;
    this = PB::Writer::writeVarInt(a2);
  }
  v7 = *(_DWORD *)(v3 + 8);
  if ((v7 & 0x20) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v7 = *(_DWORD *)(v3 + 8);
  }
  if ((v7 & 0x40) != 0)
    return PB::Writer::write(a2, *(float *)(v3 + 48));
  return this;
}

uint64_t as::server::ControlValue::formatText(as::server::ControlValue *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "objectToken");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_16;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "type");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
    goto LABEL_17;
  }
LABEL_16:
  PB::TextFormatter::format(a2, "BOOLValue");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_17:
  PB::TextFormatter::format(a2, "scalarValue", *((float *)this + 10));
  if ((*((_DWORD *)this + 2) & 0x10) != 0)
LABEL_6:
    PB::TextFormatter::format(a2, "decibelValue", *((float *)this + 11));
LABEL_7:
  v6 = *((_QWORD *)this + 2);
  v7 = *((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v6 += 4;
    PB::TextFormatter::format(a2, "activeSelectorValues");
  }
  v8 = *((_DWORD *)this + 2);
  if ((v8 & 0x20) != 0)
  {
    PB::TextFormatter::format(a2, "sliderValue");
    v8 = *((_DWORD *)this + 2);
  }
  if ((v8 & 0x40) != 0)
    PB::TextFormatter::format(a2, "panValue", *((float *)this + 12));
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ControlValue::operator==(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  _DWORD *v5;
  unint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  if (memcmp((const void *)(a1 + 40), (const void *)(a2 + 40), 0x21uLL))
    return 0;
  v4 = *(_DWORD **)(a1 + 16);
  v5 = *(_DWORD **)(a1 + 24);
  v6 = v5 - v4;
  v7 = *(_DWORD **)(a2 + 16);
  if (v6 != (uint64_t)(*(_QWORD *)(a2 + 24) - (_QWORD)v7) >> 2)
    return 0;
  if (v5 == v4)
    return 1;
  v8 = v6 <= 1 ? 1 : v5 - v4;
  if (*v4 != *v7)
    return 0;
  v9 = 1;
  do
  {
    v10 = v9;
    if (v8 == v9)
      break;
    v11 = v4[v9];
    v12 = v7[v9++];
  }
  while (v11 == v12);
  return v10 >= v6;
}

uint64_t as::server::Control::default_instance(as::server::Control *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = off_24BFE4400;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_WORD *)(v3 + 96) = 0;
    as::server::Control::default_instance(void)::gInstance = v3;
  }
  return as::server::Control::default_instance(void)::gInstance;
}

void sub_2068115F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::Control::Control(as::server::Control *this)
{
  double result;

  *(_QWORD *)this = off_24BFE4400;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_WORD *)this + 48) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = off_24BFE4400;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_WORD *)this + 48) = 0;
  return result;
}

as::server::Control *as::server::Control::Control(as::server::Control *this, const as::server::Control *a2)
{
  *(_QWORD *)this = off_24BFE4400;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  as::server::Control::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = off_24BFE4400;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  as::server::Control::copy_from(this, a2);
  return this;
}

__n128 as::server::Control::copy_from(as::server::Control *this, const as::server::Control *a2)
{
  as::server::SelectorControlItem ***v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  const as::server::SelectorControlItem **v9;
  const as::server::SelectorControlItem **i;
  as::server::SelectorControlItem *v11;
  const as::server::SelectorControlItem *v12;
  unint64_t v13;
  as::server::SelectorControlItem **v14;
  _QWORD *v15;
  as::server::SelectorControlItem **v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  as::server::SelectorControlItem **v22;
  char *v23;
  as::server::SelectorControlItem *v24;
  __int128 v25;
  char *v26;
  __n128 result;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  char *v32;
  char *v33;

  v5 = (_QWORD *)*((_QWORD *)this + 2);
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v4 = (as::server::SelectorControlItem ***)((char *)this + 16);
  while (v6 != v5)
  {
    v8 = *--v6;
    v7 = v8;
    *v6 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  *((_QWORD *)this + 3) = v5;
  v9 = (const as::server::SelectorControlItem **)*((_QWORD *)a2 + 2);
  for (i = (const as::server::SelectorControlItem **)*((_QWORD *)a2 + 3); v9 != i; ++v9)
  {
    v11 = (as::server::SelectorControlItem *)operator new();
    v12 = *v9;
    *(_QWORD *)v11 = &off_24BFE4208;
    *((_QWORD *)v11 + 2) = 0;
    *((_QWORD *)v11 + 3) = 0;
    as::server::SelectorControlItem::copy_from(v11, v12);
    v14 = (as::server::SelectorControlItem **)*((_QWORD *)this + 3);
    v13 = *((_QWORD *)this + 4);
    if ((unint64_t)v14 >= v13)
    {
      v16 = *v4;
      v17 = v14 - *v4;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v33 = (char *)this + 32;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v20);
        v16 = (as::server::SelectorControlItem **)*((_QWORD *)this + 2);
        v14 = (as::server::SelectorControlItem **)*((_QWORD *)this + 3);
      }
      else
      {
        v21 = 0;
      }
      v22 = (as::server::SelectorControlItem **)&v21[8 * v17];
      v23 = &v21[8 * v20];
      v32 = v23;
      *v22 = v11;
      *((_QWORD *)&v31 + 1) = v22 + 1;
      if (v14 == v16)
      {
        v15 = v22 + 1;
      }
      else
      {
        do
        {
          v24 = *--v14;
          *v14 = 0;
          *--v22 = v24;
        }
        while (v14 != v16);
        v15 = (_QWORD *)*((_QWORD *)&v31 + 1);
        v23 = v32;
      }
      v25 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v22;
      *((_QWORD *)this + 3) = v15;
      v31 = v25;
      v26 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v23;
      v32 = v26;
      v30 = v25;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v30);
    }
    else
    {
      *v14 = v11;
      v15 = v14 + 1;
    }
    *((_QWORD *)this + 3) = v15;
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 40);
  v28 = *(_OWORD *)((char *)a2 + 56);
  v29 = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)this + 82) = *(_OWORD *)((char *)a2 + 82);
  *(_OWORD *)((char *)this + 72) = v29;
  *(_OWORD *)((char *)this + 56) = v28;
  *(__n128 *)((char *)this + 40) = result;
  return result;
}

as::server::Control *as::server::Control::operator=(as::server::Control *a1, const as::server::Control *a2)
{
  as::server::Control::copy_from(a1, a2);
  return a1;
}

__n128 as::server::Control::Control(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __n128 result;
  __int128 v5;
  __int128 v6;

  *(_QWORD *)a1 = off_24BFE4400;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v2;
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v5 = *(_OWORD *)(a2 + 56);
  v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v6;
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  __n128 result;
  __int128 v5;
  __int128 v6;

  *(_QWORD *)a1 = off_24BFE4400;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v2 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v2;
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v5 = *(_OWORD *)(a2 + 56);
  v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v6;
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::Control::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v6 = *(_OWORD *)(a2 + 56);
  v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::Control::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 40);
  v6 = *(_OWORD *)(a2 + 56);
  v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double as::server::Control::clear(as::server::Control *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  double result;

  v2 = (_QWORD *)*((_QWORD *)this + 2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  while (v3 != v2)
  {
    v5 = *--v3;
    v4 = v5;
    *v3 = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  *((_QWORD *)this + 3) = v2;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 82) = 0u;
  return result;
}

BOOL as::server::Control::isInitialized(as::server::Control *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 3);
  if (v1 == v2)
    return (~*((_DWORD *)this + 2) & 0x3F) == 0;
  while ((~*(_DWORD *)(*(_QWORD *)v1 + 8) & 3) == 0)
  {
    v1 += 8;
    if (v1 == v2)
      return (~*((_DWORD *)this + 2) & 0x3F) == 0;
  }
  return 0;
}

BOOL as::server::Control::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  BOOL v16;
  char v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  char v21;
  BOOL v22;
  unint64_t v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  char v27;
  char v28;
  unsigned int v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t *v35;
  _QWORD *v36;
  char v37;
  unsigned int v38;
  uint64_t v39;
  char v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  char v44;
  char v45;
  unsigned int v46;
  uint64_t v47;
  char v48;
  char v49;
  unsigned int v50;
  uint64_t v51;
  char v52;
  int v53;
  BOOL v54;
  char v55;
  unsigned int v56;
  uint64_t v57;
  char v58;
  int v59;
  BOOL v60;
  char v61;
  unsigned int v62;
  uint64_t v63;
  char v64;
  char v65;
  unsigned int v66;
  uint64_t v67;
  char v68;
  char v69;
  unsigned int v70;
  unint64_t v71;
  char v72;
  int v73;
  char v74;
  unsigned int v75;
  unint64_t v76;
  char v77;
  char v78;
  unsigned int v79;
  unint64_t v80;
  char v81;
  char v82;
  unsigned int v83;
  unint64_t v84;
  char v85;
  char v86;
  unsigned int v87;
  unint64_t v88;
  char v89;
  char v90;
  unsigned int v91;
  unint64_t v92;
  char v93;
  char v94;
  unsigned int v95;
  unint64_t v96;
  char v97;
  char v98;
  unsigned int v99;
  unint64_t v100;
  char v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  char *v106;
  char v107;
  unsigned int v108;
  unint64_t v109;
  char v110;
  uint64_t *v111;
  char *v112;
  _QWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  int64x2_t v116;
  char *v117;
  uint64_t v118;
  int v119;
  uint64_t v122;
  int64x2_t v123;
  char *v124;
  uint64_t v125;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v8 = (int64x2_t *)(a1 + 16);
    v9 = a1 + 32;
    do
    {
      v10 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v17 = 0;
        v18 = 0;
        v13 = 0;
        if (v2 <= v3)
          v19 = v3;
        else
          v19 = v2;
        while (v19 != v2)
        {
          v20 = v2++;
          v21 = *(_BYTE *)(v10 + v20);
          a2[1] = v2;
          v13 |= (unint64_t)(v21 & 0x7F) << v17;
          if ((v21 & 0x80) == 0)
            goto LABEL_23;
          v17 += 7;
          v22 = v18++ >= 9;
          if (v22)
          {
            v13 = 0;
LABEL_23:
            v2 = v20 + 1;
            goto LABEL_24;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v2 + 1;
        a2[1] = v2 + 1;
        v15 = *(_BYTE *)(v10 + v2);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v2 = v14;
        v16 = v12++ > 8;
        if (v16)
        {
          v13 = 0;
          break;
        }
      }
      v2 = v14;
LABEL_24:
      if ((v13 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v23 = v13 >> 3;
      if ((int)v23 <= 22)
      {
        switch((int)v23)
        {
          case 1:
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              v94 = 0;
              v95 = 0;
              v26 = 0;
              if (v3 <= v2)
                v3 = v2;
              while (v3 != v2)
              {
                v96 = v2++;
                v97 = *(_BYTE *)(v10 + v96);
                a2[1] = v2;
                v26 |= (unint64_t)(v97 & 0x7F) << v94;
                if ((v97 & 0x80) == 0)
                  goto LABEL_173;
                v94 += 7;
                v22 = v95++ >= 9;
                if (v22)
                {
                  v26 = 0;
LABEL_173:
                  v3 = v96 + 1;
                  goto LABEL_223;
                }
              }
              v26 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v24 = 0;
              v25 = 0;
              v26 = 0;
              do
              {
                v3 = v2 + 1;
                a2[1] = v2 + 1;
                v27 = *(_BYTE *)(v10 + v2);
                v26 |= (unint64_t)(v27 & 0x7F) << v24;
                if ((v27 & 0x80) == 0)
                  goto LABEL_223;
                v24 += 7;
                v2 = v3;
                v16 = v25++ > 8;
              }
              while (!v16);
              v26 = 0;
            }
LABEL_223:
            *(_QWORD *)(a1 + 56) = v26;
            v119 = *(_DWORD *)(a1 + 8) | 1;
            break;
          case 2:
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              v98 = 0;
              v99 = 0;
              v63 = 0;
              if (v3 <= v2)
                v3 = v2;
              while (v3 != v2)
              {
                v100 = v2++;
                v101 = *(_BYTE *)(v10 + v100);
                a2[1] = v2;
                v63 |= (unint64_t)(v101 & 0x7F) << v98;
                if ((v101 & 0x80) == 0)
                  goto LABEL_181;
                v98 += 7;
                v22 = v99++ >= 9;
                if (v22)
                {
                  LODWORD(v63) = 0;
LABEL_181:
                  v3 = v100 + 1;
                  goto LABEL_225;
                }
              }
              LODWORD(v63) = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v61 = 0;
              v62 = 0;
              v63 = 0;
              do
              {
                v3 = v2 + 1;
                a2[1] = v2 + 1;
                v64 = *(_BYTE *)(v10 + v2);
                v63 |= (unint64_t)(v64 & 0x7F) << v61;
                if ((v64 & 0x80) == 0)
                  goto LABEL_225;
                v61 += 7;
                v2 = v3;
                v16 = v62++ > 8;
              }
              while (!v16);
              LODWORD(v63) = 0;
            }
LABEL_225:
            *(_DWORD *)(a1 + 64) = v63;
            v119 = *(_DWORD *)(a1 + 8) | 2;
            break;
          case 3:
            if (v2 >= v3)
            {
              v54 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v53 = *(unsigned __int8 *)(v10 + v2++);
              a2[1] = v2;
              v54 = v53 != 0;
            }
            *(_BYTE *)(a1 + 96) = v54;
            v73 = *(_DWORD *)(a1 + 8) | 4;
            goto LABEL_184;
          case 4:
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              v90 = 0;
              v91 = 0;
              v57 = 0;
              if (v3 <= v2)
                v3 = v2;
              while (v3 != v2)
              {
                v92 = v2++;
                v93 = *(_BYTE *)(v10 + v92);
                a2[1] = v2;
                v57 |= (unint64_t)(v93 & 0x7F) << v90;
                if ((v93 & 0x80) == 0)
                  goto LABEL_165;
                v90 += 7;
                v22 = v91++ >= 9;
                if (v22)
                {
                  LODWORD(v57) = 0;
LABEL_165:
                  v3 = v92 + 1;
                  goto LABEL_221;
                }
              }
              LODWORD(v57) = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v55 = 0;
              v56 = 0;
              v57 = 0;
              do
              {
                v3 = v2 + 1;
                a2[1] = v2 + 1;
                v58 = *(_BYTE *)(v10 + v2);
                v57 |= (unint64_t)(v58 & 0x7F) << v55;
                if ((v58 & 0x80) == 0)
                  goto LABEL_221;
                v55 += 7;
                v2 = v3;
                v16 = v56++ > 8;
              }
              while (!v16);
              LODWORD(v57) = 0;
            }
LABEL_221:
            *(_DWORD *)(a1 + 68) = v57;
            v119 = *(_DWORD *)(a1 + 8) | 8;
            break;
          case 5:
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              v69 = 0;
              v70 = 0;
              v43 = 0;
              if (v3 <= v2)
                v3 = v2;
              while (v3 != v2)
              {
                v71 = v2++;
                v72 = *(_BYTE *)(v10 + v71);
                a2[1] = v2;
                v43 |= (unint64_t)(v72 & 0x7F) << v69;
                if ((v72 & 0x80) == 0)
                  goto LABEL_119;
                v69 += 7;
                v22 = v70++ >= 9;
                if (v22)
                {
                  LODWORD(v43) = 0;
LABEL_119:
                  v3 = v71 + 1;
                  goto LABEL_211;
                }
              }
              LODWORD(v43) = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v41 = 0;
              v42 = 0;
              v43 = 0;
              do
              {
                v3 = v2 + 1;
                a2[1] = v2 + 1;
                v44 = *(_BYTE *)(v10 + v2);
                v43 |= (unint64_t)(v44 & 0x7F) << v41;
                if ((v44 & 0x80) == 0)
                  goto LABEL_211;
                v41 += 7;
                v2 = v3;
                v16 = v42++ > 8;
              }
              while (!v16);
              LODWORD(v43) = 0;
            }
LABEL_211:
            *(_DWORD *)(a1 + 72) = v43;
            v119 = *(_DWORD *)(a1 + 8) | 0x10;
            break;
          case 6:
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              v107 = 0;
              v108 = 0;
              v67 = 0;
              if (v3 <= v2)
                v3 = v2;
              while (v3 != v2)
              {
                v109 = v2++;
                v110 = *(_BYTE *)(v10 + v109);
                a2[1] = v2;
                v67 |= (unint64_t)(v110 & 0x7F) << v107;
                if ((v110 & 0x80) == 0)
                  goto LABEL_200;
                v107 += 7;
                v22 = v108++ >= 9;
                if (v22)
                {
                  LODWORD(v67) = 0;
LABEL_200:
                  v3 = v109 + 1;
                  goto LABEL_227;
                }
              }
              LODWORD(v67) = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v65 = 0;
              v66 = 0;
              v67 = 0;
              do
              {
                v3 = v2 + 1;
                a2[1] = v2 + 1;
                v68 = *(_BYTE *)(v10 + v2);
                v67 |= (unint64_t)(v68 & 0x7F) << v65;
                if ((v68 & 0x80) == 0)
                  goto LABEL_227;
                v65 += 7;
                v2 = v3;
                v16 = v66++ > 8;
              }
              while (!v16);
              LODWORD(v67) = 0;
            }
LABEL_227:
            *(_DWORD *)(a1 + 92) = v67;
            v119 = *(_DWORD *)(a1 + 8) | 0x20;
            break;
          default:
            if ((_DWORD)v23 != 22)
              goto LABEL_229;
            if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > v3)
            {
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              *(_QWORD *)(a1 + 40) = *(_QWORD *)(v10 + v2);
              v2 = a2[1] + 8;
              a2[1] = v2;
            }
            v73 = *(_DWORD *)(a1 + 8) | 0x40;
            goto LABEL_184;
        }
LABEL_228:
        *(_DWORD *)(a1 + 8) = v119;
        v2 = v3;
        goto LABEL_229;
      }
      if ((int)v23 <= 40)
      {
        switch((_DWORD)v23)
        {
          case 0x17:
            if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > v3)
            {
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              *(_QWORD *)(a1 + 48) = *(_QWORD *)(v10 + v2);
              v2 = a2[1] + 8;
              a2[1] = v2;
            }
            v73 = *(_DWORD *)(a1 + 8) | 0x80;
            goto LABEL_184;
          case 0x1E:
            if (v2 >= v3)
            {
              v60 = 0;
              *((_BYTE *)a2 + 24) = 1;
            }
            else
            {
              v59 = *(unsigned __int8 *)(v10 + v2++);
              a2[1] = v2;
              v60 = v59 != 0;
            }
            *(_BYTE *)(a1 + 97) = v60;
            v73 = *(_DWORD *)(a1 + 8) | 0x100;
LABEL_184:
            *(_DWORD *)(a1 + 8) = v73;
            break;
          case 0x20:
            v32 = operator new();
            v33 = v32;
            *(_QWORD *)v32 = &off_24BFE4208;
            *(_DWORD *)(v32 + 8) = 0;
            *(_QWORD *)(v32 + 24) = 0;
            *(_QWORD *)(v32 + 32) = 0;
            *(_QWORD *)(v32 + 16) = 0;
            v35 = *(uint64_t **)(a1 + 24);
            v34 = *(_QWORD *)(a1 + 32);
            if ((unint64_t)v35 >= v34)
            {
              v102 = ((uint64_t)v35 - v8->i64[0]) >> 3;
              if ((unint64_t)(v102 + 1) >> 61)
                std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
              v103 = v34 - v8->i64[0];
              v104 = v103 >> 2;
              if (v103 >> 2 <= (unint64_t)(v102 + 1))
                v104 = v102 + 1;
              if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8)
                v105 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v105 = v104;
              v125 = v9;
              if (v105)
                v106 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v105);
              else
                v106 = 0;
              v111 = (uint64_t *)&v106[8 * v102];
              v112 = &v106[8 * v105];
              v124 = v112;
              *v111 = v33;
              v36 = v111 + 1;
              v123.i64[1] = (uint64_t)(v111 + 1);
              v114 = *(_QWORD **)(a1 + 16);
              v113 = *(_QWORD **)(a1 + 24);
              if (v113 == v114)
              {
                v116 = vdupq_n_s64((unint64_t)v113);
              }
              else
              {
                do
                {
                  v115 = *--v113;
                  *v113 = 0;
                  *--v111 = v115;
                }
                while (v113 != v114);
                v116 = *v8;
                v36 = (_QWORD *)v123.i64[1];
                v112 = v124;
              }
              *(_QWORD *)(a1 + 16) = v111;
              *(_QWORD *)(a1 + 24) = v36;
              v123 = v116;
              v117 = *(char **)(a1 + 32);
              *(_QWORD *)(a1 + 32) = v112;
              v124 = v117;
              v122 = v116.i64[0];
              std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v122);
            }
            else
            {
              *v35 = v32;
              v36 = v35 + 1;
            }
            *(_QWORD *)(a1 + 24) = v36;
            v118 = *(v36 - 1);
            if ((PB::Reader::placeMark() & 1) == 0
              || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v118 + 16))(v118, a2) & 1) == 0)
            {
              return 0;
            }
            PB::Reader::recallMark();
            v2 = a2[1];
            break;
        }
      }
      else if ((int)v23 > 50)
      {
        if ((_DWORD)v23 == 51)
        {
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            v78 = 0;
            v79 = 0;
            v51 = 0;
            if (v3 <= v2)
              v3 = v2;
            while (v3 != v2)
            {
              v80 = v2++;
              v81 = *(_BYTE *)(v10 + v80);
              a2[1] = v2;
              v51 |= (unint64_t)(v81 & 0x7F) << v78;
              if ((v81 & 0x80) == 0)
                goto LABEL_137;
              v78 += 7;
              v22 = v79++ >= 9;
              if (v22)
              {
                LODWORD(v51) = 0;
LABEL_137:
                v3 = v80 + 1;
                goto LABEL_215;
              }
            }
            LODWORD(v51) = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v49 = 0;
            v50 = 0;
            v51 = 0;
            while (1)
            {
              v3 = v2 + 1;
              a2[1] = v2 + 1;
              v52 = *(_BYTE *)(v10 + v2);
              v51 |= (unint64_t)(v52 & 0x7F) << v49;
              if ((v52 & 0x80) == 0)
                break;
              v49 += 7;
              v2 = v3;
              v16 = v50++ > 8;
              if (v16)
              {
                LODWORD(v51) = 0;
                break;
              }
            }
          }
LABEL_215:
          *(_DWORD *)(a1 + 84) = v51;
          v119 = *(_DWORD *)(a1 + 8) | 0x800;
          goto LABEL_228;
        }
        if ((_DWORD)v23 == 52)
        {
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            v86 = 0;
            v87 = 0;
            v39 = 0;
            if (v3 <= v2)
              v3 = v2;
            while (v3 != v2)
            {
              v88 = v2++;
              v89 = *(_BYTE *)(v10 + v88);
              a2[1] = v2;
              v39 |= (unint64_t)(v89 & 0x7F) << v86;
              if ((v89 & 0x80) == 0)
                goto LABEL_157;
              v86 += 7;
              v22 = v87++ >= 9;
              if (v22)
              {
                LODWORD(v39) = 0;
LABEL_157:
                v3 = v88 + 1;
                goto LABEL_219;
              }
            }
            LODWORD(v39) = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v37 = 0;
            v38 = 0;
            v39 = 0;
            while (1)
            {
              v3 = v2 + 1;
              a2[1] = v2 + 1;
              v40 = *(_BYTE *)(v10 + v2);
              v39 |= (unint64_t)(v40 & 0x7F) << v37;
              if ((v40 & 0x80) == 0)
                break;
              v37 += 7;
              v2 = v3;
              v16 = v38++ > 8;
              if (v16)
              {
                LODWORD(v39) = 0;
                break;
              }
            }
          }
LABEL_219:
          *(_DWORD *)(a1 + 88) = v39;
          v119 = *(_DWORD *)(a1 + 8) | 0x1000;
          goto LABEL_228;
        }
      }
      else
      {
        if ((_DWORD)v23 == 41)
        {
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            v74 = 0;
            v75 = 0;
            v47 = 0;
            if (v3 <= v2)
              v3 = v2;
            while (v3 != v2)
            {
              v76 = v2++;
              v77 = *(_BYTE *)(v10 + v76);
              a2[1] = v2;
              v47 |= (unint64_t)(v77 & 0x7F) << v74;
              if ((v77 & 0x80) == 0)
                goto LABEL_129;
              v74 += 7;
              v22 = v75++ >= 9;
              if (v22)
              {
                LODWORD(v47) = 0;
LABEL_129:
                v3 = v76 + 1;
                goto LABEL_213;
              }
            }
            LODWORD(v47) = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v45 = 0;
            v46 = 0;
            v47 = 0;
            while (1)
            {
              v3 = v2 + 1;
              a2[1] = v2 + 1;
              v48 = *(_BYTE *)(v10 + v2);
              v47 |= (unint64_t)(v48 & 0x7F) << v45;
              if ((v48 & 0x80) == 0)
                break;
              v45 += 7;
              v2 = v3;
              v16 = v46++ > 8;
              if (v16)
              {
                LODWORD(v47) = 0;
                break;
              }
            }
          }
LABEL_213:
          *(_DWORD *)(a1 + 76) = v47;
          v119 = *(_DWORD *)(a1 + 8) | 0x200;
          goto LABEL_228;
        }
        if ((_DWORD)v23 == 42)
        {
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            v82 = 0;
            v83 = 0;
            v30 = 0;
            if (v3 <= v2)
              v3 = v2;
            while (v3 != v2)
            {
              v84 = v2++;
              v85 = *(_BYTE *)(v10 + v84);
              a2[1] = v2;
              v30 |= (unint64_t)(v85 & 0x7F) << v82;
              if ((v85 & 0x80) == 0)
                goto LABEL_149;
              v82 += 7;
              v22 = v83++ >= 9;
              if (v22)
              {
                LODWORD(v30) = 0;
LABEL_149:
                v3 = v84 + 1;
                goto LABEL_217;
              }
            }
            LODWORD(v30) = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v28 = 0;
            v29 = 0;
            v30 = 0;
            while (1)
            {
              v3 = v2 + 1;
              a2[1] = v2 + 1;
              v31 = *(_BYTE *)(v10 + v2);
              v30 |= (unint64_t)(v31 & 0x7F) << v28;
              if ((v31 & 0x80) == 0)
                break;
              v28 += 7;
              v2 = v3;
              v16 = v29++ > 8;
              if (v16)
              {
                LODWORD(v30) = 0;
                break;
              }
            }
          }
LABEL_217:
          *(_DWORD *)(a1 + 80) = v30;
          v119 = *(_DWORD *)(a1 + 8) | 0x400;
          goto LABEL_228;
        }
      }
LABEL_229:
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && v4 == 0);
  }
  return v4 == 0;
}

void sub_20681267C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::Control::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;
  int v8;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_21;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_22;
  }
LABEL_21:
  this = PB::Writer::write(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_23;
  }
LABEL_22:
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_24;
  }
LABEL_23:
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_25;
  }
LABEL_24:
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 0x80) == 0)
      goto LABEL_9;
LABEL_26:
    this = PB::Writer::write(a2, *(double *)(v3 + 48));
    if ((*(_DWORD *)(v3 + 8) & 0x100) == 0)
      goto LABEL_11;
    goto LABEL_10;
  }
LABEL_25:
  this = PB::Writer::write(a2, *(double *)(v3 + 40));
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x80) != 0)
    goto LABEL_26;
LABEL_9:
  if ((v4 & 0x100) != 0)
LABEL_10:
    this = PB::Writer::write(a2);
LABEL_11:
  v5 = *(const PB::Base ***)(v3 + 16);
  v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    v7 = *v5++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  v8 = *(_DWORD *)(v3 + 8);
  if ((v8 & 0x200) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v8 = *(_DWORD *)(v3 + 8);
    if ((v8 & 0x400) == 0)
    {
LABEL_16:
      if ((v8 & 0x800) == 0)
        goto LABEL_17;
      goto LABEL_30;
    }
  }
  else if ((v8 & 0x400) == 0)
  {
    goto LABEL_16;
  }
  this = PB::Writer::writeVarInt(a2);
  v8 = *(_DWORD *)(v3 + 8);
  if ((v8 & 0x800) == 0)
  {
LABEL_17:
    if ((v8 & 0x1000) == 0)
      return this;
    return PB::Writer::writeVarInt(a2);
  }
LABEL_30:
  this = PB::Writer::writeVarInt(a2);
  if ((*(_DWORD *)(v3 + 8) & 0x1000) != 0)
    return PB::Writer::writeVarInt(a2);
  return this;
}

uint64_t as::server::Control::formatText(as::server::Control *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "objectToken");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_21;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "classID");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
    goto LABEL_22;
  }
LABEL_21:
  PB::TextFormatter::format(a2, "settable");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_23;
  }
LABEL_22:
  PB::TextFormatter::format(a2, "scope");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_24;
  }
LABEL_23:
  PB::TextFormatter::format(a2, "element");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_25;
  }
LABEL_24:
  PB::TextFormatter::format(a2, "type");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40) == 0)
  {
LABEL_8:
    if ((v5 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_26;
  }
LABEL_25:
  PB::TextFormatter::format(a2, "decibelMinimum", *((double *)this + 5));
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x80) == 0)
  {
LABEL_9:
    if ((v5 & 0x100) == 0)
      goto LABEL_11;
    goto LABEL_10;
  }
LABEL_26:
  PB::TextFormatter::format(a2, "decibelMaximum", *((double *)this + 6));
  if ((*((_DWORD *)this + 2) & 0x100) != 0)
LABEL_10:
    PB::TextFormatter::format(a2, "isMultiValue");
LABEL_11:
  v6 = (uint64_t *)*((_QWORD *)this + 2);
  v7 = (uint64_t *)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "supportedSelectorValues");
  }
  v9 = *((_DWORD *)this + 2);
  if ((v9 & 0x200) != 0)
  {
    PB::TextFormatter::format(a2, "sliderMinimum");
    v9 = *((_DWORD *)this + 2);
    if ((v9 & 0x400) == 0)
    {
LABEL_15:
      if ((v9 & 0x800) == 0)
        goto LABEL_16;
LABEL_30:
      PB::TextFormatter::format(a2, "panLeftChannel");
      if ((*((_DWORD *)this + 2) & 0x1000) == 0)
        return PB::TextFormatter::endObject(a2);
      goto LABEL_17;
    }
  }
  else if ((v9 & 0x400) == 0)
  {
    goto LABEL_15;
  }
  PB::TextFormatter::format(a2, "sliderMaximum");
  v9 = *((_DWORD *)this + 2);
  if ((v9 & 0x800) != 0)
    goto LABEL_30;
LABEL_16:
  if ((v9 & 0x1000) != 0)
LABEL_17:
    PB::TextFormatter::format(a2, "panRightChannel");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Control::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && !memcmp((const void *)(a1 + 40), (const void *)(a2 + 40), 0x3AuLL)
    && (v5 = *(_QWORD *)(a1 + 16),
        v4 = *(_QWORD *)(a1 + 24),
        v6 = (v4 - v5) >> 3,
        v6 == (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3))
  {
    if (v4 == v5)
    {
      return 1;
    }
    else
    {
      v7 = 0;
      v8 = 0;
      if (v6 <= 1)
        v9 = 1;
      else
        v9 = (v4 - v5) >> 3;
      do
      {
        v10 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v8);
        v11 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v8);
        if (v10)
          v12 = v11 == 0;
        else
          v12 = 1;
        if (v12)
        {
          if (v10 | v11)
            return v7;
        }
        else if (!as::server::SelectorControlItem::operator==(v10, v11))
        {
          return v7;
        }
        v7 = ++v8 >= v6;
      }
      while (v9 != v8);
    }
  }
  else
  {
    return 0;
  }
  return v7;
}

uint64_t as::server::Control::addSupportedSelectorValues(as::server::Control *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4208;
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 16) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::ControlAndValue::default_instance(as::server::ControlAndValue *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    v3[1] = 0;
    v3[2] = 0;
    *v3 = &off_24BFE3FA0;
    as::server::ControlAndValue::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::server::ControlAndValue::default_instance(void)::gInstance;
}

void sub_206812D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::server::ControlAndValue::ControlAndValue(_QWORD *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE3FA0;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE3FA0;
  return this;
}

double as::server::ControlAndValue::copy_from(as::server::ControlAndValue *this, const as::server::ControlAndValue *a2)
{
  const as::server::Control *v4;
  as::server::Control *v5;
  double result;
  const as::server::ControlValue *v7;
  as::server::ControlValue *v8;

  v4 = (const as::server::Control *)*((_QWORD *)a2 + 1);
  if (v4)
  {
    v5 = (as::server::Control *)as::server::ControlAndValue::mutableControl(this);
    *(_QWORD *)&result = as::server::Control::copy_from(v5, v4).n128_u64[0];
  }
  v7 = (const as::server::ControlValue *)*((_QWORD *)a2 + 2);
  if (v7)
  {
    v8 = (as::server::ControlValue *)as::server::ControlAndValue::mutableValue(this);
    *(_QWORD *)&result = as::server::ControlValue::copy_from(v8, v7).n128_u64[0];
  }
  return result;
}

as::server::ControlAndValue *as::server::ControlAndValue::operator=(as::server::ControlAndValue *a1, const as::server::ControlAndValue *a2)
{
  as::server::ControlAndValue::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::ControlAndValue::control(as::server::ControlAndValue *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (!result)
    return as::server::Control::default_instance(0);
  return result;
}

uint64_t as::server::ControlAndValue::mutableControl(as::server::ControlAndValue *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = off_24BFE4400;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_WORD *)(v1 + 96) = 0;
    v3 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ControlAndValue::value(as::server::ControlAndValue *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return as::server::ControlValue::default_instance(0);
  return result;
}

uint64_t as::server::ControlAndValue::mutableValue(as::server::ControlAndValue *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3E50;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 57) = 0u;
    v3 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

_QWORD *as::server::ControlAndValue::ControlAndValue(_QWORD *result, uint64_t a2)
{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE3FA0;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE3FA0;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::ControlAndValue::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::ControlAndValue::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::ControlAndValue::clear(as::server::ControlAndValue *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

BOOL as::server::ControlAndValue::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v15;
  unsigned int v16;
  unint64_t v17;
  char v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    do
    {
      v8 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v15 = 0;
        v16 = 0;
        v11 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v17 = v2 + 1;
          v18 = *(_BYTE *)(v8 + v2);
          a2[1] = v17;
          v11 |= (unint64_t)(v18 & 0x7F) << v15;
          if ((v18 & 0x80) == 0)
            goto LABEL_20;
          v15 += 7;
          v2 = v17;
          if (v16++ >= 9)
          {
LABEL_19:
            v11 = 0;
            goto LABEL_20;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v2 + 1;
        a2[1] = v2 + 1;
        v13 = *(_BYTE *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v2 = v12;
        if (v10++ > 8)
          goto LABEL_19;
      }
LABEL_20:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v11 >> 3) == 2)
      {
        v20 = operator new();
        *(_QWORD *)v20 = &off_24BFE3E50;
        *(_DWORD *)(v20 + 8) = 0;
        *(_OWORD *)(v20 + 16) = 0u;
        *(_OWORD *)(v20 + 32) = 0u;
        *(_OWORD *)(v20 + 48) = 0u;
        *(_OWORD *)(v20 + 57) = 0u;
        v22 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v20;
        if (v22)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
          v20 = *(_QWORD *)(a1 + 16);
        }
      }
      else
      {
        if ((v11 >> 3) != 1)
          goto LABEL_30;
        v20 = operator new();
        *(_QWORD *)v20 = off_24BFE4400;
        *(_DWORD *)(v20 + 8) = 0;
        *(_OWORD *)(v20 + 16) = 0u;
        *(_OWORD *)(v20 + 32) = 0u;
        *(_OWORD *)(v20 + 48) = 0u;
        *(_OWORD *)(v20 + 64) = 0u;
        *(_OWORD *)(v20 + 80) = 0u;
        *(_WORD *)(v20 + 96) = 0;
        v21 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v20;
        if (v21)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
          v20 = *(_QWORD *)(a1 + 8);
        }
      }
      if (!PB::Reader::placeMark()
        || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v20 + 16))(v20, a2) & 1) == 0)
      {
        return 0;
      }
      PB::Reader::recallMark();
LABEL_30:
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

uint64_t as::server::ControlAndValue::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  const PB::Base *v5;

  v3 = this;
  v4 = *(const PB::Base **)(this + 8);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
    return PB::Writer::writeSubmessage(a2, v5);
  return this;
}

uint64_t as::server::ControlAndValue::formatText(as::server::ControlAndValue *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 1);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "control");
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "value");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ControlAndValue::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a2 + 8);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (!(v4 | v5))
      goto LABEL_9;
    return 0;
  }
  if (!as::server::Control::operator==(v4, v5))
    return 0;
LABEL_9:
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a2 + 16);
  result = (v8 | v9) == 0;
  if (v8)
  {
    if (v9)
      return as::server::ControlValue::operator==(*(_QWORD *)(a1 + 16), v9);
  }
  return result;
}

uint64_t as::server::ControlAndValue::clearControl(as::server::ControlAndValue *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ControlAndValue::clearValue(as::server::ControlAndValue *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::IOStreamState::default_instance(as::server::IOStreamState *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3F30;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_DWORD *)(v3 + 80) = 0;
    as::server::IOStreamState::default_instance(void)::gInstance = v3;
  }
  return as::server::IOStreamState::default_instance(void)::gInstance;
}

void sub_20681347C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::IOStreamState::IOStreamState(as::server::IOStreamState *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3F30;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3F30;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 0;
  return result;
}

as::server::IOStreamState *as::server::IOStreamState::IOStreamState(as::server::IOStreamState *this, const as::server::IOStreamState *a2)
{
  *(_QWORD *)this = &off_24BFE3F30;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  as::server::IOStreamState::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3F30;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  as::server::IOStreamState::copy_from(this, a2);
  return this;
}

as::server::IOStreamState *as::server::IOStreamState::copy_from(as::server::IOStreamState *this, const as::server::IOStreamState *a2)
{
  as::server::IOStreamState *v3;
  const as::StreamFormat *v4;
  as::StreamFormat *v5;
  as::AvailableStreamFormat ***v6;
  _QWORD *v7;
  _QWORD *v8;
  as::server::IOStreamState *v9;
  const as::AvailableStreamFormat **v10;
  const as::AvailableStreamFormat **i;
  as::AvailableStreamFormat *v12;
  unint64_t v13;
  as::AvailableStreamFormat **v14;
  _QWORD *v15;
  as::AvailableStreamFormat **v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  as::AvailableStreamFormat **v22;
  char *v23;
  as::AvailableStreamFormat *v24;
  __int128 v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  char *v30;
  char *v31;

  v3 = this;
  v4 = (const as::StreamFormat *)*((_QWORD *)a2 + 8);
  if (v4)
  {
    v5 = as::server::IOStreamState::mutableStreamFormat(this);
    this = as::StreamFormat::operator=(v5, v4);
  }
  v7 = (_QWORD *)*((_QWORD *)v3 + 5);
  v8 = (_QWORD *)*((_QWORD *)v3 + 6);
  v6 = (as::AvailableStreamFormat ***)((char *)v3 + 40);
  while (v8 != v7)
  {
    v9 = (as::server::IOStreamState *)*--v8;
    this = v9;
    *v8 = 0;
    if (v9)
      this = (as::server::IOStreamState *)(*(uint64_t (**)(as::server::IOStreamState *))(*(_QWORD *)this + 8))(this);
  }
  *((_QWORD *)v3 + 6) = v7;
  v10 = (const as::AvailableStreamFormat **)*((_QWORD *)a2 + 5);
  for (i = (const as::AvailableStreamFormat **)*((_QWORD *)a2 + 6); v10 != i; ++v10)
  {
    v12 = (as::AvailableStreamFormat *)operator new();
    this = as::AvailableStreamFormat::AvailableStreamFormat(v12, *v10);
    v14 = (as::AvailableStreamFormat **)*((_QWORD *)v3 + 6);
    v13 = *((_QWORD *)v3 + 7);
    if ((unint64_t)v14 >= v13)
    {
      v16 = *v6;
      v17 = v14 - *v6;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v31 = (char *)v3 + 56;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v3 + 56, v20);
        v16 = (as::AvailableStreamFormat **)*((_QWORD *)v3 + 5);
        v14 = (as::AvailableStreamFormat **)*((_QWORD *)v3 + 6);
      }
      else
      {
        v21 = 0;
      }
      v22 = (as::AvailableStreamFormat **)&v21[8 * v17];
      v23 = &v21[8 * v20];
      v30 = v23;
      *v22 = v12;
      *((_QWORD *)&v29 + 1) = v22 + 1;
      if (v14 == v16)
      {
        v15 = v22 + 1;
      }
      else
      {
        do
        {
          v24 = *--v14;
          *v14 = 0;
          *--v22 = v24;
        }
        while (v14 != v16);
        v15 = (_QWORD *)*((_QWORD *)&v29 + 1);
        v23 = v30;
      }
      v25 = *(_OWORD *)((char *)v3 + 40);
      *((_QWORD *)v3 + 5) = v22;
      *((_QWORD *)v3 + 6) = v15;
      v29 = v25;
      v26 = (char *)*((_QWORD *)v3 + 7);
      *((_QWORD *)v3 + 7) = v23;
      v30 = v26;
      v28 = v25;
      this = (as::server::IOStreamState *)std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v28);
    }
    else
    {
      *v14 = v12;
      v15 = v14 + 1;
    }
    *((_QWORD *)v3 + 6) = v15;
  }
  if (v3 != a2)
    this = std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)v3 + 16, *((caulk::xstring **)a2 + 2), *((caulk::xstring **)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 4);
  *((_DWORD *)v3 + 2) = *((_DWORD *)a2 + 2);
  v27 = *((_QWORD *)a2 + 9);
  *((_DWORD *)v3 + 20) = *((_DWORD *)a2 + 20);
  *((_QWORD *)v3 + 9) = v27;
  return this;
}

as::server::IOStreamState *as::server::IOStreamState::operator=(as::server::IOStreamState *a1, const as::server::IOStreamState *a2)
{
  as::server::IOStreamState::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::IOStreamState::streamFormat(as::server::IOStreamState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 8);
  if (!result)
    return as::StreamFormat::default_instance(0);
  return result;
}

as::StreamFormat *as::server::IOStreamState::mutableStreamFormat(as::server::IOStreamState *this)
{
  as::StreamFormat *v1;
  double v3;
  uint64_t v4;

  v1 = (as::StreamFormat *)*((_QWORD *)this + 8);
  if (!v1)
  {
    v1 = (as::StreamFormat *)operator new();
    v3 = as::StreamFormat::StreamFormat(v1);
    v4 = *((_QWORD *)this + 8);
    *((_QWORD *)this + 8) = v1;
    if (v4)
      (*(void (**)(uint64_t, double))(*(_QWORD *)v4 + 8))(v4, v3);
  }
  return v1;
}

uint64_t as::server::IOStreamState::IOStreamState(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE3F30;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = 0;
  as::server::IOStreamState::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3F30;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = 0;
  as::server::IOStreamState::move_from(a1, a2);
  return a1;
}

uint64_t as::server::IOStreamState::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v2;
  v3 = *(_QWORD *)(result + 40);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v3;
  v4 = *(_QWORD *)(result + 48);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v4;
  v5 = *(_QWORD *)(result + 56);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v5;
  v6 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v6;
  v7 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v7;
  v8 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v8;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a2 + 72);
  *(_DWORD *)(result + 80) = *(_DWORD *)(a2 + 80);
  *(_QWORD *)(result + 72) = v9;
  return result;
}

uint64_t as::server::IOStreamState::operator=(uint64_t a1, uint64_t a2)
{
  as::server::IOStreamState::move_from(a1, a2);
  return a1;
}

uint64_t as::server::IOStreamState::clear(as::server::IOStreamState *this)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  caulk::xstring *v8;
  uint64_t result;

  v2 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (_QWORD *)*((_QWORD *)this + 5);
  v4 = (_QWORD *)*((_QWORD *)this + 6);
  while (v4 != v3)
  {
    v6 = *--v4;
    v5 = v6;
    *v4 = 0;
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  }
  v8 = (caulk::xstring *)*((_QWORD *)this + 2);
  v7 = (char *)this + 16;
  *((_QWORD *)v7 + 4) = v3;
  result = std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v7, v8);
  *((_DWORD *)v7 - 2) = 0;
  *((_QWORD *)v7 + 7) = 0;
  *((_DWORD *)v7 + 16) = 0;
  return result;
}

uint64_t as::server::IOStreamState::isInitialized(as::server::IOStreamState *this)
{
  uint64_t result;
  as::AvailableStreamFormat **v3;
  as::AvailableStreamFormat **v4;

  result = *((_QWORD *)this + 8);
  if (result)
  {
    result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
    if ((_DWORD)result)
    {
      v3 = (as::AvailableStreamFormat **)*((_QWORD *)this + 5);
      v4 = (as::AvailableStreamFormat **)*((_QWORD *)this + 6);
      while (1)
      {
        if (v3 == v4)
          return (~*((_DWORD *)this + 2) & 5) == 0;
        if ((as::AvailableStreamFormat::isInitialized(*v3) & 1) == 0)
          break;
        ++v3;
      }
      return 0;
    }
  }
  return result;
}

BOOL as::server::IOStreamState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t *v8;
  uint64_t v9;
  int64x2_t *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  BOOL v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  as::StreamFormat *v33;
  double v34;
  uint64_t v35;
  as::AvailableStreamFormat *v36;
  unint64_t v37;
  as::AvailableStreamFormat **v38;
  _QWORD *v39;
  char v40;
  unsigned int v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  char v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t v48;
  char v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  char v55;
  unsigned int v56;
  unint64_t v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  char v64;
  unsigned int v65;
  unint64_t v66;
  char v67;
  char v68;
  unsigned int v69;
  unint64_t v70;
  char v71;
  char *v72;
  as::AvailableStreamFormat **v73;
  char *v74;
  _QWORD *v75;
  _QWORD *v76;
  as::AvailableStreamFormat *v77;
  int64x2_t v78;
  char *v79;
  uint64_t v80;
  int v81;
  void *__p;
  int64x2_t v85;
  char *v86;
  uint64_t v87;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v8 = (uint64_t *)(a1 + 16);
  v9 = a1 + 32;
  v10 = (int64x2_t *)(a1 + 40);
  v11 = a1 + 56;
  while (2)
  {
    v12 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      while (1)
      {
        v16 = v3 + 1;
        a2[1] = v3 + 1;
        v17 = *(_BYTE *)(v12 + v3);
        v15 |= (unint64_t)(v17 & 0x7F) << v13;
        if ((v17 & 0x80) == 0)
          goto LABEL_23;
        v13 += 7;
        v3 = v16;
        v18 = v14++ > 8;
        if (v18)
        {
          v15 = 0;
          goto LABEL_23;
        }
      }
    }
    v19 = 0;
    v20 = 0;
    v15 = 0;
    if (v3 <= v2)
      v21 = v2;
    else
      v21 = v3;
    do
    {
      if (v21 == v3)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v22 = v3++;
      v23 = *(_BYTE *)(v12 + v22);
      a2[1] = v3;
      v15 |= (unint64_t)(v23 & 0x7F) << v19;
      if ((v23 & 0x80) == 0)
        goto LABEL_22;
      v19 += 7;
      v24 = v20++ >= 9;
    }
    while (!v24);
    v15 = 0;
LABEL_22:
    v16 = v22 + 1;
LABEL_23:
    if ((v15 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v15 >> 3))
    {
      case 1u:
        if (v16 > 0xFFFFFFFFFFFFFFF5 || v16 + 10 > v2)
        {
          v55 = 0;
          v56 = 0;
          v27 = 0;
          if (v2 <= v16)
            v2 = v16;
          do
          {
            if (v2 == v16)
            {
              LODWORD(v27) = 0;
              *((_BYTE *)a2 + 24) = 1;
              goto LABEL_106;
            }
            v57 = v16 + 1;
            v58 = *(_BYTE *)(v12 + v16);
            a2[1] = v57;
            v27 |= (unint64_t)(v58 & 0x7F) << v55;
            if ((v58 & 0x80) == 0)
              goto LABEL_106;
            v55 += 7;
            v16 = v57;
            v24 = v56++ >= 9;
          }
          while (!v24);
LABEL_69:
          LODWORD(v27) = 0;
        }
        else
        {
          v25 = 0;
          v26 = 0;
          v27 = 0;
          while (1)
          {
            v28 = v16 + 1;
            a2[1] = v16 + 1;
            v29 = *(_BYTE *)(v12 + v16);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0)
              break;
            v25 += 7;
            v16 = v28;
            v18 = v26++ > 8;
            if (v18)
              goto LABEL_69;
          }
        }
LABEL_106:
        *(_DWORD *)(a1 + 72) = v27;
        v81 = *(_DWORD *)(a1 + 8) | 1;
        goto LABEL_111;
      case 2u:
        if (v16 <= 0xFFFFFFFFFFFFFFF5 && v16 + 10 <= v2)
        {
          v40 = 0;
          v41 = 0;
          v42 = 0;
          do
          {
            v43 = v16 + 1;
            a2[1] = v16 + 1;
            v44 = *(_BYTE *)(v12 + v16);
            v42 |= (unint64_t)(v44 & 0x7F) << v40;
            if ((v44 & 0x80) == 0)
              goto LABEL_108;
            v40 += 7;
            v16 = v43;
            v18 = v41++ > 8;
          }
          while (!v18);
LABEL_84:
          LODWORD(v42) = 0;
          goto LABEL_108;
        }
        v64 = 0;
        v65 = 0;
        v42 = 0;
        if (v2 <= v16)
          v2 = v16;
        while (v2 != v16)
        {
          v66 = v16 + 1;
          v67 = *(_BYTE *)(v12 + v16);
          a2[1] = v66;
          v42 |= (unint64_t)(v67 & 0x7F) << v64;
          if ((v67 & 0x80) == 0)
            goto LABEL_108;
          v64 += 7;
          v16 = v66;
          v24 = v65++ >= 9;
          if (v24)
            goto LABEL_84;
        }
        LODWORD(v42) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_108:
        *(_DWORD *)(a1 + 76) = v42;
        v81 = *(_DWORD *)(a1 + 8) | 2;
        goto LABEL_111;
      case 3u:
        v33 = (as::StreamFormat *)operator new();
        v34 = as::StreamFormat::StreamFormat(v33);
        v35 = *(_QWORD *)(a1 + 64);
        *(_QWORD *)(a1 + 64) = v33;
        if (v35)
        {
          (*(void (**)(uint64_t, double))(*(_QWORD *)v35 + 8))(v35, v34);
          v33 = *(as::StreamFormat **)(a1 + 64);
        }
        if (PB::Reader::placeMark()
          && ((*(uint64_t (**)(as::StreamFormat *, uint64_t *))(*(_QWORD *)v33 + 16))(v33, a2) & 1) != 0)
        {
          goto LABEL_38;
        }
        return 0;
      case 4u:
        v36 = (as::AvailableStreamFormat *)operator new();
        as::AvailableStreamFormat::AvailableStreamFormat(v36);
        v38 = *(as::AvailableStreamFormat ***)(a1 + 48);
        v37 = *(_QWORD *)(a1 + 56);
        if ((unint64_t)v38 >= v37)
        {
          v59 = ((uint64_t)v38 - v10->i64[0]) >> 3;
          if ((unint64_t)(v59 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v60 = v37 - v10->i64[0];
          v61 = v60 >> 2;
          if (v60 >> 2 <= (unint64_t)(v59 + 1))
            v61 = v59 + 1;
          if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
            v62 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v62 = v61;
          v87 = v11;
          if (v62)
            v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v11, v62);
          else
            v63 = 0;
          v73 = (as::AvailableStreamFormat **)&v63[8 * v59];
          v74 = &v63[8 * v62];
          v86 = v74;
          *v73 = v36;
          v39 = v73 + 1;
          v85.i64[1] = (uint64_t)(v73 + 1);
          v76 = *(_QWORD **)(a1 + 40);
          v75 = *(_QWORD **)(a1 + 48);
          if (v75 == v76)
          {
            v78 = vdupq_n_s64((unint64_t)v75);
          }
          else
          {
            do
            {
              v77 = (as::AvailableStreamFormat *)*--v75;
              *v75 = 0;
              *--v73 = v77;
            }
            while (v75 != v76);
            v78 = *v10;
            v39 = (_QWORD *)v85.i64[1];
            v74 = v86;
          }
          *(_QWORD *)(a1 + 40) = v73;
          *(_QWORD *)(a1 + 48) = v39;
          v85 = v78;
          v79 = *(char **)(a1 + 56);
          *(_QWORD *)(a1 + 56) = v74;
          v86 = v79;
          __p = (void *)v78.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v38 = v36;
          v39 = v38 + 1;
        }
        *(_QWORD *)(a1 + 48) = v39;
        v80 = *(v39 - 1);
        if ((PB::Reader::placeMark() & 1) != 0
          && ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v80 + 16))(v80, a2) & 1) != 0)
        {
LABEL_38:
          PB::Reader::recallMark();
LABEL_112:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          continue;
        }
        return 0;
      case 5u:
        v31 = *(_QWORD **)(a1 + 24);
        v30 = *(_QWORD *)(a1 + 32);
        if ((unint64_t)v31 >= v30)
        {
          v50 = ((uint64_t)v31 - *v8) >> 4;
          v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 60)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v52 = v30 - *v8;
          if (v52 >> 3 > v51)
            v51 = v52 >> 3;
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF0)
            v53 = 0xFFFFFFFFFFFFFFFLL;
          else
            v53 = v51;
          v87 = v9;
          if (v53)
            v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v53);
          else
            v54 = 0;
          v72 = &v54[16 * v50];
          __p = v54;
          v85.i64[0] = (uint64_t)v72;
          v86 = &v54[16 * v53];
          *(_QWORD *)v72 = 0;
          *((_QWORD *)v72 + 1) = 0;
          v85.i64[1] = (uint64_t)(v72 + 16);
          std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
          v32 = *(_QWORD **)(a1 + 24);
          std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v31 = 0;
          v31[1] = 0;
          v32 = v31 + 2;
          *(_QWORD *)(a1 + 24) = v31 + 2;
        }
        *(_QWORD *)(a1 + 24) = v32;
        __p = 0;
        v85 = 0uLL;
        PB::Reader::read();
        caulk::xstring::assign();
        if (v85.i8[15] < 0)
          operator delete(__p);
        goto LABEL_112;
      case 6u:
        if (v16 <= 0xFFFFFFFFFFFFFFF5 && v16 + 10 <= v2)
        {
          v45 = 0;
          v46 = 0;
          v47 = 0;
          do
          {
            v48 = v16 + 1;
            a2[1] = v16 + 1;
            v49 = *(_BYTE *)(v12 + v16);
            v47 |= (unint64_t)(v49 & 0x7F) << v45;
            if ((v49 & 0x80) == 0)
              goto LABEL_110;
            v45 += 7;
            v16 = v48;
            v18 = v46++ > 8;
          }
          while (!v18);
LABEL_91:
          LODWORD(v47) = 0;
          goto LABEL_110;
        }
        v68 = 0;
        v69 = 0;
        v47 = 0;
        if (v2 <= v16)
          v2 = v16;
        while (v2 != v16)
        {
          v70 = v16 + 1;
          v71 = *(_BYTE *)(v12 + v16);
          a2[1] = v70;
          v47 |= (unint64_t)(v71 & 0x7F) << v68;
          if ((v71 & 0x80) == 0)
            goto LABEL_110;
          v68 += 7;
          v16 = v70;
          v24 = v69++ >= 9;
          if (v24)
            goto LABEL_91;
        }
        LODWORD(v47) = 0;
        *((_BYTE *)a2 + 24) = 1;
LABEL_110:
        *(_DWORD *)(a1 + 80) = v47;
        v81 = *(_DWORD *)(a1 + 8) | 4;
LABEL_111:
        *(_DWORD *)(a1 + 8) = v81;
        goto LABEL_112;
      default:
        goto LABEL_112;
    }
  }
}

void sub_20681406C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::IOStreamState::writeTo(as::server::IOStreamState *this, PB::Writer *a2)
{
  int v4;
  const PB::Base *v5;
  const PB::Base **v6;
  const PB::Base **v7;
  const PB::Base *v8;
  caulk::xstring *v9;
  caulk::xstring *v10;
  char *v11;
  void *__p;
  char v13;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
    PB::Writer::writeVarInt(a2);
  v5 = (const PB::Base *)*((_QWORD *)this + 8);
  if (v5)
    PB::Writer::writeSubmessage(a2, v5);
  v6 = (const PB::Base **)*((_QWORD *)this + 5);
  v7 = (const PB::Base **)*((_QWORD *)this + 6);
  while (v6 != v7)
  {
    v8 = *v6++;
    PB::Writer::writeSubmessage(a2, v8);
  }
  v9 = (caulk::xstring *)*((_QWORD *)this + 2);
  v10 = (caulk::xstring *)*((_QWORD *)this + 3);
  while (v9 != v10)
  {
    v11 = (char *)caulk::xstring::c_str(v9);
    std::string::basic_string[abi:ne180100]<0>(&__p, v11);
    PB::Writer::write();
    if (v13 < 0)
      operator delete(__p);
    v9 = (caulk::xstring *)((char *)v9 + 16);
  }
  if ((*((_BYTE *)this + 8) & 4) != 0)
    PB::Writer::writeVarInt(a2);
}

void sub_2068141A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::IOStreamState::formatText(as::server::IOStreamState *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  caulk::xstring *v10;
  caulk::xstring *i;
  char *v12;
  void *__p;
  char v15;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "streamToken");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "DSPFlavor");
  v6 = *((_QWORD *)this + 8);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "streamFormat");
  v7 = (uint64_t *)*((_QWORD *)this + 5);
  v8 = (uint64_t *)*((_QWORD *)this + 6);
  while (v7 != v8)
  {
    v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v9 + 32))(v9, a2, "availableFormats");
  }
  v10 = (caulk::xstring *)*((_QWORD *)this + 2);
  for (i = (caulk::xstring *)*((_QWORD *)this + 3); v10 != i; v10 = (caulk::xstring *)((char *)v10 + 16))
  {
    v12 = (char *)caulk::xstring::c_str(v10);
    std::string::basic_string[abi:ne180100]<0>(&__p, v12);
    PB::TextFormatter::format();
    if (v15 < 0)
      operator delete(__p);
  }
  if ((*((_BYTE *)this + 8) & 4) != 0)
    PB::TextFormatter::format(a2, "latency");
  return PB::TextFormatter::endObject(a2);
}

void sub_20681430C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::IOStreamState::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a1 + 72) != *(_QWORD *)(a2 + 72)
    || *(_DWORD *)(a1 + 80) != (unint64_t)*(unsigned int *)(a2 + 80))
  {
    return 0;
  }
  v6 = *(_QWORD *)(a1 + 64);
  v7 = *(_QWORD *)(a2 + 64);
  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8)
  {
    if (v6 | v7)
      return 0;
  }
  else if (!as::StreamFormat::operator==(v6, v7))
  {
    return 0;
  }
  v10 = *(_QWORD *)(a1 + 40);
  v9 = *(_QWORD *)(a1 + 48);
  v11 = (v9 - v10) >> 3;
  if (v11 != (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
    return 0;
  if (v9 != v10)
  {
    v12 = 0;
    if (v11 <= 1)
      v13 = 1;
    else
      v13 = (v9 - v10) >> 3;
    do
    {
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v12);
      v15 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v12);
      if (v14)
        v16 = v15 == 0;
      else
        v16 = 1;
      if (v16)
      {
        if (v14 | v15)
          return 0;
      }
      else if (!as::AvailableStreamFormat::operator==(v14, v15))
      {
        return 0;
      }
      ++v12;
    }
    while (v13 != v12);
  }
  v18 = *(_QWORD *)(a1 + 16);
  v17 = *(_QWORD *)(a1 + 24);
  v19 = (v17 - v18) >> 4;
  if (v19 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 4)
    return 0;
  if (v17 == v18)
    return 1;
  if (v19 <= 1)
    v20 = 1;
  else
    v20 = (v17 - v18) >> 4;
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 16), *(const caulk::xstring **)(a2 + 16)))
    return 0;
  v21 = 1;
  v22 = 16;
  do
  {
    v23 = v21;
    if (v20 == v21)
      break;
    v24 = caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 16) + v22), (const caulk::xstring *)(*(_QWORD *)(a2 + 16) + v22));
    v21 = v23 + 1;
    v22 += 16;
  }
  while (!v24);
  return v23 >= v19;
}

uint64_t as::server::IOStreamState::clearStreamFormat(as::server::IOStreamState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void as::server::IOStreamState::addAvailableFormats(as::server::IOStreamState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  as::AvailableStreamFormat *v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  char *v24;
  char *v25;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v25 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v24 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v23 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v23 + 1);
      v14 = v24;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v23 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v24 = v17;
    v22 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  v18 = (as::AvailableStreamFormat *)operator new();
  v19 = as::AvailableStreamFormat::AvailableStreamFormat(v18);
  v20 = *(v6 - 1);
  *(v6 - 1) = v21;
  if (v20)
    (*(void (**)(uint64_t, double))(*(_QWORD *)v20 + 8))(v20, v19);
}

uint64_t as::server::PortInvariants::default_instance(as::server::PortInvariants *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3F68;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_QWORD *)(v3 + 64) = 0;
    as::server::PortInvariants::default_instance(void)::gInstance = v3;
  }
  return as::server::PortInvariants::default_instance(void)::gInstance;
}

void sub_206814690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::PortInvariants::PortInvariants(as::server::PortInvariants *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3F68;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3F68;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  return result;
}

as::server::PortInvariants *as::server::PortInvariants::PortInvariants(as::server::PortInvariants *this, __n128 *a2)
{
  *(_QWORD *)this = &off_24BFE3F68;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::PortInvariants::copy_from((__n128 *)this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3F68;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::PortInvariants::copy_from((__n128 *)this, a2);
  return this;
}

__n128 as::server::PortInvariants::copy_from(__n128 *this, __n128 *a2)
{
  __n128 result;

  caulk::xstring::assign((caulk::xstring *)&this[1], (const caulk::xstring *)&a2[1]);
  caulk::xstring::assign((caulk::xstring *)&this[2], (const caulk::xstring *)&a2[2]);
  this->n128_u32[2] = a2->n128_u32[2];
  result = a2[3];
  this[4].n128_u64[0] = a2[4].n128_u64[0];
  this[3] = result;
  return result;
}

__n128 *as::server::PortInvariants::operator=(__n128 *a1, __n128 *a2)
{
  as::server::PortInvariants::copy_from(a1, a2);
  return a1;
}

{
  as::server::PortInvariants::move_from(a1, a2);
  return a1;
}

uint64_t as::server::PortInvariants::PortInvariants(uint64_t a1, __n128 *a2)
{
  *(_QWORD *)a1 = &off_24BFE3F68;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::PortInvariants::move_from((__n128 *)a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3F68;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::PortInvariants::move_from((__n128 *)a1, a2);
  return a1;
}

__n128 as::server::PortInvariants::move_from(__n128 *a1, __n128 *a2)
{
  __n128 result;
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  v5 = 0;
  v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  return result;
}

uint64_t as::server::PortInvariants::clear(as::server::PortInvariants *this)
{
  uint64_t result;

  caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 16));
  result = caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 32));
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  return result;
}

BOOL as::server::PortInvariants::isInitialized(as::server::PortInvariants *this)
{
  return (~*((_DWORD *)this + 2) & 0x7F) == 0;
}

BOOL as::server::PortInvariants::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  int v46;
  char v47;
  unsigned int v48;
  unint64_t v49;
  char v50;
  char v51;
  unsigned int v52;
  unint64_t v53;
  char v54;
  char v55;
  unsigned int v56;
  unint64_t v57;
  char v58;
  char v59;
  unsigned int v60;
  unint64_t v61;
  char v62;
  char v63;
  unsigned int v64;
  unint64_t v65;
  char v66;
  int v67;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        v15 = 0;
        v16 = 0;
        v11 = 0;
        if (v3 <= v2)
          v17 = v2;
        else
          v17 = v3;
        while (v17 != v3)
        {
          v18 = v3++;
          v19 = *(_BYTE *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0)
            goto LABEL_21;
          v15 += 7;
          v20 = v16++ >= 9;
          if (v20)
          {
            v11 = 0;
LABEL_21:
            v12 = v18 + 1;
            goto LABEL_22;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
      }
      else
      {
        v9 = 0;
        v10 = 0;
        v11 = 0;
        while (1)
        {
          v12 = v3 + 1;
          a2[1] = v3 + 1;
          v13 = *(_BYTE *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0)
            break;
          v9 += 7;
          v3 = v12;
          v14 = v10++ > 8;
          if (v14)
          {
            v11 = 0;
            break;
          }
        }
LABEL_22:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 1u:
              if (v12 > 0xFFFFFFFFFFFFFFF5 || v12 + 10 > v2)
              {
                v47 = 0;
                v48 = 0;
                v23 = 0;
                if (v2 <= v12)
                  v2 = v12;
                do
                {
                  if (v2 == v12)
                  {
                    v23 = 0;
                    *((_BYTE *)a2 + 24) = 1;
                    goto LABEL_98;
                  }
                  v49 = v12 + 1;
                  v50 = *(_BYTE *)(v8 + v12);
                  a2[1] = v49;
                  v23 |= (unint64_t)(v50 & 0x7F) << v47;
                  if ((v50 & 0x80) == 0)
                    goto LABEL_98;
                  v47 += 7;
                  v12 = v49;
                  v20 = v48++ >= 9;
                }
                while (!v20);
LABEL_68:
                v23 = 0;
              }
              else
              {
                v21 = 0;
                v22 = 0;
                v23 = 0;
                while (1)
                {
                  v24 = v12 + 1;
                  a2[1] = v12 + 1;
                  v25 = *(_BYTE *)(v8 + v12);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0)
                    break;
                  v21 += 7;
                  v12 = v24;
                  v14 = v22++ > 8;
                  if (v14)
                    goto LABEL_68;
                }
              }
LABEL_98:
              *(_QWORD *)(a1 + 48) = v23;
              v67 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_107;
            case 2u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                v26 = 0;
                v27 = 0;
                v28 = 0;
                do
                {
                  v29 = v12 + 1;
                  a2[1] = v12 + 1;
                  v30 = *(_BYTE *)(v8 + v12);
                  v28 |= (unint64_t)(v30 & 0x7F) << v26;
                  if ((v30 & 0x80) == 0)
                    goto LABEL_100;
                  v26 += 7;
                  v12 = v29;
                  v14 = v27++ > 8;
                }
                while (!v14);
LABEL_75:
                LODWORD(v28) = 0;
                goto LABEL_100;
              }
              v51 = 0;
              v52 = 0;
              v28 = 0;
              if (v2 <= v12)
                v2 = v12;
              while (v2 != v12)
              {
                v53 = v12 + 1;
                v54 = *(_BYTE *)(v8 + v12);
                a2[1] = v53;
                v28 |= (unint64_t)(v54 & 0x7F) << v51;
                if ((v54 & 0x80) == 0)
                  goto LABEL_100;
                v51 += 7;
                v12 = v53;
                v20 = v52++ >= 9;
                if (v20)
                  goto LABEL_75;
              }
              LODWORD(v28) = 0;
              *((_BYTE *)a2 + 24) = 1;
LABEL_100:
              *(_DWORD *)(a1 + 56) = v28;
              v67 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_107;
            case 3u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                v31 = 0;
                v32 = 0;
                v33 = 0;
                do
                {
                  v34 = v12 + 1;
                  a2[1] = v12 + 1;
                  v35 = *(_BYTE *)(v8 + v12);
                  v33 |= (unint64_t)(v35 & 0x7F) << v31;
                  if ((v35 & 0x80) == 0)
                    goto LABEL_102;
                  v31 += 7;
                  v12 = v34;
                  v14 = v32++ > 8;
                }
                while (!v14);
LABEL_82:
                LODWORD(v33) = 0;
                goto LABEL_102;
              }
              v55 = 0;
              v56 = 0;
              v33 = 0;
              if (v2 <= v12)
                v2 = v12;
              while (v2 != v12)
              {
                v57 = v12 + 1;
                v58 = *(_BYTE *)(v8 + v12);
                a2[1] = v57;
                v33 |= (unint64_t)(v58 & 0x7F) << v55;
                if ((v58 & 0x80) == 0)
                  goto LABEL_102;
                v55 += 7;
                v12 = v57;
                v20 = v56++ >= 9;
                if (v20)
                  goto LABEL_82;
              }
              LODWORD(v33) = 0;
              *((_BYTE *)a2 + 24) = 1;
LABEL_102:
              *(_DWORD *)(a1 + 60) = v33;
              v67 = *(_DWORD *)(a1 + 8) | 4;
              goto LABEL_107;
            case 4u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                v36 = 0;
                v37 = 0;
                v38 = 0;
                do
                {
                  v39 = v12 + 1;
                  a2[1] = v12 + 1;
                  v40 = *(_BYTE *)(v8 + v12);
                  v38 |= (unint64_t)(v40 & 0x7F) << v36;
                  if ((v40 & 0x80) == 0)
                    goto LABEL_104;
                  v36 += 7;
                  v12 = v39;
                  v14 = v37++ > 8;
                }
                while (!v14);
LABEL_89:
                LODWORD(v38) = 0;
                goto LABEL_104;
              }
              v59 = 0;
              v60 = 0;
              v38 = 0;
              if (v2 <= v12)
                v2 = v12;
              while (v2 != v12)
              {
                v61 = v12 + 1;
                v62 = *(_BYTE *)(v8 + v12);
                a2[1] = v61;
                v38 |= (unint64_t)(v62 & 0x7F) << v59;
                if ((v62 & 0x80) == 0)
                  goto LABEL_104;
                v59 += 7;
                v12 = v61;
                v20 = v60++ >= 9;
                if (v20)
                  goto LABEL_89;
              }
              LODWORD(v38) = 0;
              *((_BYTE *)a2 + 24) = 1;
LABEL_104:
              *(_DWORD *)(a1 + 64) = v38;
              v67 = *(_DWORD *)(a1 + 8) | 8;
              goto LABEL_107;
            case 5u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                v41 = 0;
                v42 = 0;
                v43 = 0;
                do
                {
                  v44 = v12 + 1;
                  a2[1] = v12 + 1;
                  v45 = *(_BYTE *)(v8 + v12);
                  v43 |= (unint64_t)(v45 & 0x7F) << v41;
                  if ((v45 & 0x80) == 0)
                    goto LABEL_106;
                  v41 += 7;
                  v12 = v44;
                  v14 = v42++ > 8;
                }
                while (!v14);
LABEL_96:
                LODWORD(v43) = 0;
                goto LABEL_106;
              }
              v63 = 0;
              v64 = 0;
              v43 = 0;
              if (v2 <= v12)
                v2 = v12;
              while (v2 != v12)
              {
                v65 = v12 + 1;
                v66 = *(_BYTE *)(v8 + v12);
                a2[1] = v65;
                v43 |= (unint64_t)(v66 & 0x7F) << v63;
                if ((v66 & 0x80) == 0)
                  goto LABEL_106;
                v63 += 7;
                v12 = v65;
                v20 = v64++ >= 9;
                if (v20)
                  goto LABEL_96;
              }
              LODWORD(v43) = 0;
              *((_BYTE *)a2 + 24) = 1;
LABEL_106:
              *(_DWORD *)(a1 + 68) = v43;
              v67 = *(_DWORD *)(a1 + 8) | 0x10;
LABEL_107:
              *(_DWORD *)(a1 + 8) = v67;
LABEL_108:
              v3 = a2[1];
              v2 = a2[2];
              v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0)
                return v4 == 0;
              continue;
            case 6u:
              PB::Reader::read();
              caulk::xstring::assign();
              v46 = *(_DWORD *)(a1 + 8) | 0x20;
              goto LABEL_61;
            case 7u:
              PB::Reader::read();
              caulk::xstring::assign();
              v46 = *(_DWORD *)(a1 + 8) | 0x40;
LABEL_61:
              *(_DWORD *)(a1 + 8) = v46;
              goto LABEL_108;
            default:
              goto LABEL_108;
          }
        }
        v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_206814F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::server::PortInvariants::writeTo(as::server::PortInvariants *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  char *v6;
  void *__p[2];
  char v8;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_11;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_12;
  }
LABEL_11:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_13;
  }
LABEL_12:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_14;
  }
LABEL_13:
  PB::Writer::writeVarInt(a2);
  v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0)
      return;
    goto LABEL_17;
  }
LABEL_14:
  v5 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(__p, v5);
  PB::Writer::write();
  if (v8 < 0)
    operator delete(__p[0]);
  if ((*((_DWORD *)this + 2) & 0x40) != 0)
  {
LABEL_17:
    v6 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::Writer::write();
    if (v8 < 0)
      operator delete(__p[0]);
  }
}

void sub_2068150B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::PortInvariants::formatText(as::server::PortInvariants *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  char *v7;
  void *__p[2];
  char v10;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "objectToken");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_11;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "portType");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
    goto LABEL_12;
  }
LABEL_11:
  PB::TextFormatter::format(a2, "endpointType");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_13;
  }
LABEL_12:
  PB::TextFormatter::format(a2, "connectionType");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_14;
  }
LABEL_13:
  PB::TextFormatter::format(a2, "direction");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0)
      return PB::TextFormatter::endObject(a2);
    goto LABEL_17;
  }
LABEL_14:
  v6 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(__p, v6);
  PB::TextFormatter::format();
  if (v10 < 0)
    operator delete(__p[0]);
  if ((*((_DWORD *)this + 2) & 0x40) != 0)
  {
LABEL_17:
    v7 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v10 < 0)
      operator delete(__p[0]);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_206815234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::PortInvariants::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  BOOL v5;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && (*(_QWORD *)(a1 + 48) == *(_QWORD *)(a2 + 48) ? (v4 = *(_QWORD *)(a1 + 56) == *(_QWORD *)(a2 + 56)) : (v4 = 0),
        v4 ? (v5 = *(_QWORD *)(a1 + 64) == *(_QWORD *)(a2 + 64)) : (v5 = 0),
        v5 && !caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16))))
  {
    return caulk::xstring::compare((caulk::xstring *)(a1 + 32), (const caulk::xstring *)(a2 + 32)) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t as::server::Port::default_instance(as::server::Port *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4320;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_OWORD *)(v3 + 121) = 0u;
    as::server::Port::default_instance(void)::gInstance = v3;
  }
  return as::server::Port::default_instance(void)::gInstance;
}

void sub_206815364(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::Port::Port(as::server::Port *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE4320;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 121) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE4320;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 121) = 0u;
  return result;
}

uint64_t as::server::Port::copy_from(as::server::Port *this, const as::server::Port *a2)
{
  __n128 *v4;
  __n128 *v5;
  const as::server::HardwareInfo *v6;
  as::server::HardwareInfo *v7;
  uint64_t result;

  v4 = (__n128 *)*((_QWORD *)a2 + 15);
  if (v4)
  {
    v5 = (__n128 *)as::server::Port::mutableInvariants(this);
    as::server::PortInvariants::copy_from(v5, v4);
  }
  caulk::xstring::assign((as::server::Port *)((char *)this + 88), (const as::server::Port *)((char *)a2 + 88));
  if (this != a2)
  {
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 16, *((caulk::xstring **)a2 + 2), *((caulk::xstring **)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 4);
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 40, *((caulk::xstring **)a2 + 5), *((caulk::xstring **)a2 + 6), (uint64_t)(*((_QWORD *)a2 + 6) - *((_QWORD *)a2 + 5)) >> 4);
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 64, *((caulk::xstring **)a2 + 8), *((caulk::xstring **)a2 + 9), (uint64_t)(*((_QWORD *)a2 + 9) - *((_QWORD *)a2 + 8)) >> 4);
  }
  v6 = (const as::server::HardwareInfo *)*((_QWORD *)a2 + 16);
  if (v6)
  {
    v7 = (as::server::HardwareInfo *)as::server::Port::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v7, v6);
  }
  result = caulk::xstring::assign((as::server::Port *)((char *)this + 104), (const as::server::Port *)((char *)a2 + 104));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_BYTE *)this + 136) = *((_BYTE *)a2 + 136);
  return result;
}

as::server::Port *as::server::Port::operator=(as::server::Port *a1, const as::server::Port *a2)
{
  as::server::Port::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::Port::invariants(as::server::Port *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 15);
  if (!result)
    return as::server::PortInvariants::default_instance(0);
  return result;
}

uint64_t as::server::Port::mutableInvariants(as::server::Port *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 15);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3F68;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_QWORD *)(v1 + 64) = 0;
    v3 = *((_QWORD *)this + 15);
    *((_QWORD *)this + 15) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::Port::hardwareInfo(as::server::Port *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (!result)
    return as::server::HardwareInfo::default_instance(0);
  return result;
}

uint64_t as::server::Port::mutableHardwareInfo(as::server::Port *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 16);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3EC0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    v3 = *((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::Port::Port(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE4320;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  as::server::Port::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE4320;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  as::server::Port::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Port::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = v4;
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v5;
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v6;
  v7 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v7;
  v8 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v8;
  v9 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v9;
  v10 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v10;
  v11 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v11;
  v12 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v12;
  v13 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v13;
  v14 = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v14;
  v16 = 0;
  v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)&v16);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 136) = *(_BYTE *)(a2 + 136);
  return result;
}

uint64_t as::server::Port::operator=(uint64_t a1, uint64_t a2)
{
  as::server::Port::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Port::clear(as::server::Port *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  caulk::xstring::clear((as::server::Port *)((char *)this + 88));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 16, *((caulk::xstring **)this + 2));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 40, *((caulk::xstring **)this + 5));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 64, *((caulk::xstring **)this + 8));
  v3 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  result = caulk::xstring::clear((as::server::Port *)((char *)this + 104));
  *((_DWORD *)this + 2) = 0;
  *((_BYTE *)this + 136) = 0;
  return result;
}

BOOL as::server::Port::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  char v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  int v38;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  uint64_t v59;
  uint64_t v60;
  void *__p;
  char *v62;
  _QWORD *v63;
  char *v64;
  uint64_t v65;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v8 = (uint64_t *)(a1 + 64);
    v9 = (uint64_t *)(a1 + 40);
    v59 = a1 + 56;
    v60 = a1 + 80;
    v10 = (uint64_t *)(a1 + 16);
    v11 = a1 + 32;
    while (1)
    {
      v12 = *a2;
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v13 = 0;
        v14 = 0;
        v15 = 0;
        while (1)
        {
          v16 = v3 + 1;
          a2[1] = v3 + 1;
          v17 = *(_BYTE *)(v12 + v3);
          v15 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0)
            goto LABEL_23;
          v13 += 7;
          v3 = v16;
          if (v14++ > 8)
          {
            v15 = 0;
            goto LABEL_23;
          }
        }
      }
      v19 = 0;
      v20 = 0;
      v15 = 0;
      v21 = v3 <= v2 ? v2 : v3;
      do
      {
        if (v21 == v3)
        {
          v4 = 1;
          *((_BYTE *)a2 + 24) = 1;
          return v4 == 0;
        }
        v22 = v3++;
        v23 = *(_BYTE *)(v12 + v22);
        a2[1] = v3;
        v15 |= (unint64_t)(v23 & 0x7F) << v19;
        if ((v23 & 0x80) == 0)
          goto LABEL_22;
        v19 += 7;
      }
      while (v20++ < 9);
      v15 = 0;
LABEL_22:
      v16 = v22 + 1;
LABEL_23:
      if ((v15 & 7) == 4)
        break;
      switch((v15 >> 3))
      {
        case 1u:
          v25 = operator new();
          *(_QWORD *)v25 = &off_24BFE3F68;
          *(_DWORD *)(v25 + 8) = 0;
          *(_OWORD *)(v25 + 16) = 0u;
          *(_OWORD *)(v25 + 32) = 0u;
          *(_OWORD *)(v25 + 48) = 0u;
          *(_QWORD *)(v25 + 64) = 0;
          v26 = *(_QWORD *)(a1 + 120);
          *(_QWORD *)(a1 + 120) = v25;
          if (v26)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
            v25 = *(_QWORD *)(a1 + 120);
          }
          goto LABEL_36;
        case 2u:
          __p = 0;
          v62 = 0;
          v63 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          v27 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_42;
        case 4u:
          v29 = *(_QWORD **)(a1 + 24);
          v28 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v29 >= v28)
          {
            v40 = ((uint64_t)v29 - *v10) >> 4;
            v41 = v40 + 1;
            if ((unint64_t)(v40 + 1) >> 60)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v42 = v28 - *v10;
            if (v42 >> 3 > v41)
              v41 = v42 >> 3;
            if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF0)
              v43 = 0xFFFFFFFFFFFFFFFLL;
            else
              v43 = v41;
            v65 = v11;
            if (v43)
              v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v11, v43);
            else
              v44 = 0;
            v55 = &v44[16 * v40];
            __p = v44;
            v62 = v55;
            v64 = &v44[16 * v43];
            *(_QWORD *)v55 = 0;
            *((_QWORD *)v55 + 1) = 0;
            v63 = v55 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v10, &__p);
            v30 = *(_QWORD **)(a1 + 24);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v29 = 0;
            v29[1] = 0;
            v30 = v29 + 2;
            *(_QWORD *)(a1 + 24) = v29 + 2;
          }
          *(_QWORD *)(a1 + 24) = v30;
          __p = 0;
          v62 = 0;
          v63 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_78;
        case 5u:
          v32 = *(_QWORD **)(a1 + 48);
          v31 = *(_QWORD *)(a1 + 56);
          if ((unint64_t)v32 >= v31)
          {
            v45 = ((uint64_t)v32 - *v9) >> 4;
            v46 = v45 + 1;
            if ((unint64_t)(v45 + 1) >> 60)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v47 = v31 - *v9;
            if (v47 >> 3 > v46)
              v46 = v47 >> 3;
            if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0)
              v48 = 0xFFFFFFFFFFFFFFFLL;
            else
              v48 = v46;
            v65 = v59;
            if (v48)
              v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v59, v48);
            else
              v49 = 0;
            v56 = &v49[16 * v45];
            __p = v49;
            v62 = v56;
            v64 = &v49[16 * v48];
            *(_QWORD *)v56 = 0;
            *((_QWORD *)v56 + 1) = 0;
            v63 = v56 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v9, &__p);
            v33 = *(_QWORD **)(a1 + 48);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v32 = 0;
            v32[1] = 0;
            v33 = v32 + 2;
            *(_QWORD *)(a1 + 48) = v32 + 2;
          }
          *(_QWORD *)(a1 + 48) = v33;
          __p = 0;
          v62 = 0;
          v63 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_78;
        case 6u:
          v35 = *(_QWORD **)(a1 + 72);
          v34 = *(_QWORD *)(a1 + 80);
          if ((unint64_t)v35 >= v34)
          {
            v50 = ((uint64_t)v35 - *v8) >> 4;
            v51 = v50 + 1;
            if ((unint64_t)(v50 + 1) >> 60)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v52 = v34 - *v8;
            if (v52 >> 3 > v51)
              v51 = v52 >> 3;
            if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF0)
              v53 = 0xFFFFFFFFFFFFFFFLL;
            else
              v53 = v51;
            v65 = v60;
            if (v53)
              v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v60, v53);
            else
              v54 = 0;
            v57 = &v54[16 * v50];
            __p = v54;
            v62 = v57;
            v64 = &v54[16 * v53];
            *(_QWORD *)v57 = 0;
            *((_QWORD *)v57 + 1) = 0;
            v63 = v57 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
            v36 = *(_QWORD **)(a1 + 72);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v35 = 0;
            v35[1] = 0;
            v36 = v35 + 2;
            *(_QWORD *)(a1 + 72) = v35 + 2;
          }
          *(_QWORD *)(a1 + 72) = v36;
          __p = 0;
          v62 = 0;
          v63 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_78;
        case 7u:
          v25 = operator new();
          *(_QWORD *)v25 = &off_24BFE3EC0;
          *(_DWORD *)(v25 + 8) = 0;
          *(_OWORD *)(v25 + 16) = 0u;
          *(_OWORD *)(v25 + 32) = 0u;
          *(_OWORD *)(v25 + 48) = 0u;
          v37 = *(_QWORD *)(a1 + 128);
          *(_QWORD *)(a1 + 128) = v25;
          if (v37)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
            v25 = *(_QWORD *)(a1 + 128);
          }
LABEL_36:
          if (!PB::Reader::placeMark()
            || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v25 + 16))(v25, a2) & 1) == 0)
          {
            return 0;
          }
          PB::Reader::recallMark();
LABEL_80:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || *((_BYTE *)a2 + 24))
            return v4 == 0;
          break;
        case 8u:
          if (v16 >= v2)
          {
            v39 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v38 = *(unsigned __int8 *)(v12 + v16);
            a2[1] = v16 + 1;
            v39 = v38 != 0;
          }
          *(_BYTE *)(a1 + 136) = v39;
          *(_DWORD *)(a1 + 8) |= 2u;
          goto LABEL_80;
        case 9u:
          __p = 0;
          v62 = 0;
          v63 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          v27 = *(_DWORD *)(a1 + 8) | 4;
LABEL_42:
          *(_DWORD *)(a1 + 8) = v27;
LABEL_78:
          if (SHIBYTE(v63) < 0)
            operator delete(__p);
          goto LABEL_80;
        default:
          goto LABEL_80;
      }
    }
    v4 = 0;
  }
  return v4 == 0;
}

void sub_206815E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void as::server::Port::writeTo(as::server::Port *this, PB::Writer *a2)
{
  const PB::Base *v4;
  char *v5;
  caulk::xstring *v6;
  caulk::xstring *v7;
  char *v8;
  caulk::xstring *v9;
  caulk::xstring *v10;
  char *v11;
  caulk::xstring *v12;
  caulk::xstring *v13;
  char *v14;
  const PB::Base *v15;
  int v16;
  char *v17;
  void *__p[2];
  char v19;

  v4 = (const PB::Base *)*((_QWORD *)this + 15);
  if (v4)
    PB::Writer::writeSubmessage(a2, v4);
  if ((*((_BYTE *)this + 8) & 1) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v19 < 0)
      operator delete(__p[0]);
  }
  v6 = (caulk::xstring *)*((_QWORD *)this + 2);
  v7 = (caulk::xstring *)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = (char *)caulk::xstring::c_str(v6);
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::Writer::write();
    if (v19 < 0)
      operator delete(__p[0]);
    v6 = (caulk::xstring *)((char *)v6 + 16);
  }
  v9 = (caulk::xstring *)*((_QWORD *)this + 5);
  v10 = (caulk::xstring *)*((_QWORD *)this + 6);
  while (v9 != v10)
  {
    v11 = (char *)caulk::xstring::c_str(v9);
    std::string::basic_string[abi:ne180100]<0>(__p, v11);
    PB::Writer::write();
    if (v19 < 0)
      operator delete(__p[0]);
    v9 = (caulk::xstring *)((char *)v9 + 16);
  }
  v12 = (caulk::xstring *)*((_QWORD *)this + 8);
  v13 = (caulk::xstring *)*((_QWORD *)this + 9);
  while (v12 != v13)
  {
    v14 = (char *)caulk::xstring::c_str(v12);
    std::string::basic_string[abi:ne180100]<0>(__p, v14);
    PB::Writer::write();
    if (v19 < 0)
      operator delete(__p[0]);
    v12 = (caulk::xstring *)((char *)v12 + 16);
  }
  v15 = (const PB::Base *)*((_QWORD *)this + 16);
  if (v15)
    PB::Writer::writeSubmessage(a2, v15);
  v16 = *((_DWORD *)this + 2);
  if ((v16 & 2) != 0)
  {
    PB::Writer::write(a2);
    v16 = *((_DWORD *)this + 2);
  }
  if ((v16 & 4) != 0)
  {
    v17 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 104));
    std::string::basic_string[abi:ne180100]<0>(__p, v17);
    PB::Writer::write();
    if (v19 < 0)
      operator delete(__p[0]);
  }
}

void sub_20681607C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::Port::formatText(as::server::Port *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  char *v6;
  caulk::xstring *v7;
  caulk::xstring *i;
  char *v9;
  caulk::xstring *v10;
  caulk::xstring *j;
  char *v12;
  caulk::xstring *v13;
  caulk::xstring *k;
  char *v15;
  uint64_t v16;
  int v17;
  char *v18;
  void *__p[2];
  char v21;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 15);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "invariants");
  if ((*((_BYTE *)this + 8) & 1) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v21 < 0)
      operator delete(__p[0]);
  }
  v7 = (caulk::xstring *)*((_QWORD *)this + 2);
  for (i = (caulk::xstring *)*((_QWORD *)this + 3); v7 != i; v7 = (caulk::xstring *)((char *)v7 + 16))
  {
    v9 = (char *)caulk::xstring::c_str(v7);
    std::string::basic_string[abi:ne180100]<0>(__p, v9);
    PB::TextFormatter::format();
    if (v21 < 0)
      operator delete(__p[0]);
  }
  v10 = (caulk::xstring *)*((_QWORD *)this + 5);
  for (j = (caulk::xstring *)*((_QWORD *)this + 6); v10 != j; v10 = (caulk::xstring *)((char *)v10 + 16))
  {
    v12 = (char *)caulk::xstring::c_str(v10);
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::TextFormatter::format();
    if (v21 < 0)
      operator delete(__p[0]);
  }
  v13 = (caulk::xstring *)*((_QWORD *)this + 8);
  for (k = (caulk::xstring *)*((_QWORD *)this + 9); v13 != k; v13 = (caulk::xstring *)((char *)v13 + 16))
  {
    v15 = (char *)caulk::xstring::c_str(v13);
    std::string::basic_string[abi:ne180100]<0>(__p, v15);
    PB::TextFormatter::format();
    if (v21 < 0)
      operator delete(__p[0]);
  }
  v16 = *((_QWORD *)this + 16);
  if (v16)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v16 + 32))(v16, a2, "hardwareInfo");
  v17 = *((_DWORD *)this + 2);
  if ((v17 & 2) != 0)
  {
    PB::TextFormatter::format(a2, "turnByTurnUseAllowed");
    v17 = *((_DWORD *)this + 2);
  }
  if ((v17 & 4) != 0)
  {
    v18 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 104));
    std::string::basic_string[abi:ne180100]<0>(__p, v18);
    PB::TextFormatter::format();
    if (v21 < 0)
      operator delete(__p[0]);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_2068162CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::Port::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(unsigned __int8 *)(a1 + 136) != *(unsigned __int8 *)(a2 + 136))
    return 0;
  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(_QWORD *)(a2 + 120);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
  }
  else if (!as::server::PortInvariants::operator==(v4, v5))
  {
    return 0;
  }
  if (!caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)))
  {
    v8 = *(_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 24);
    v9 = (v7 - v8) >> 4;
    if (v9 == (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 4)
    {
      if (v7 != v8)
      {
        v10 = 0;
        if (v9 <= 1)
          v11 = 1;
        else
          v11 = (v7 - v8) >> 4;
        while (!caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 16) + v10), (const caulk::xstring *)(*(_QWORD *)(a2 + 16) + v10)))
        {
          v10 += 16;
          if (!--v11)
            goto LABEL_19;
        }
        return 0;
      }
LABEL_19:
      v13 = *(_QWORD *)(a1 + 40);
      v12 = *(_QWORD *)(a1 + 48);
      v14 = (v12 - v13) >> 4;
      if (v14 == (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 4)
      {
        if (v12 != v13)
        {
          v15 = 0;
          if (v14 <= 1)
            v16 = 1;
          else
            v16 = (v12 - v13) >> 4;
          while (!caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 40) + v15), (const caulk::xstring *)(*(_QWORD *)(a2 + 40) + v15)))
          {
            v15 += 16;
            if (!--v16)
              goto LABEL_26;
          }
          return 0;
        }
LABEL_26:
        v18 = *(_QWORD *)(a1 + 64);
        v17 = *(_QWORD *)(a1 + 72);
        v19 = (v17 - v18) >> 4;
        if (v19 == (uint64_t)(*(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64)) >> 4)
        {
          if (v17 != v18)
          {
            v20 = 0;
            if (v19 <= 1)
              v21 = 1;
            else
              v21 = (v17 - v18) >> 4;
            while (!caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 64) + v20), (const caulk::xstring *)(*(_QWORD *)(a2 + 64) + v20)))
            {
              v20 += 16;
              if (!--v21)
                goto LABEL_33;
            }
            return 0;
          }
LABEL_33:
          v22 = *(_QWORD *)(a1 + 128);
          v23 = *(_QWORD *)(a2 + 128);
          if (v22 && v23)
          {
            if (as::server::HardwareInfo::operator==((_DWORD *)v22, (_DWORD *)v23))
              return caulk::xstring::compare((caulk::xstring *)(a1 + 104), (const caulk::xstring *)(a2 + 104)) == 0;
          }
          else if (!(v22 | v23))
          {
            return caulk::xstring::compare((caulk::xstring *)(a1 + 104), (const caulk::xstring *)(a2 + 104)) == 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t as::server::Port::clearInvariants(as::server::Port *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::Port::clearHardwareInfo(as::server::Port *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::SessionUpdateSummary::default_instance(as::server::SessionUpdateSummary *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)v3 = &off_24BFE4240;
    *(_DWORD *)(v3 + 24) = 0;
    as::server::SessionUpdateSummary::default_instance(void)::gInstance = v3;
  }
  return as::server::SessionUpdateSummary::default_instance(void)::gInstance;
}

void sub_206816570(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::server::SessionUpdateSummary::SessionUpdateSummary(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)this = &off_24BFE4240;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

{
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)this = &off_24BFE4240;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

__n128 as::server::SessionUpdateSummary::SessionUpdateSummary(as::server::SessionUpdateSummary *this, const as::server::SessionUpdateSummary *a2)
{
  __n128 result;

  *(_QWORD *)this = &off_24BFE4240;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 12);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

{
  __n128 result;

  *(_QWORD *)this = &off_24BFE4240;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 12);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::copy_from(as::server::SessionUpdateSummary *this, const as::server::SessionUpdateSummary *a2)
{
  __n128 result;

  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 12);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::operator=(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::SessionUpdateSummary(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a1 = &off_24BFE4240;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(_QWORD *)a1 = &off_24BFE4240;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::move_from(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

uint64_t as::server::SessionUpdateSummary::clear(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

BOOL as::server::SessionUpdateSummary::isInitialized(as::server::SessionUpdateSummary *this)
{
  return (~*((_DWORD *)this + 2) & 0xF) == 0;
}

BOOL as::server::SessionUpdateSummary::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v6;
  char v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  BOOL v12;
  char v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  char v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t v23;
  char v24;
  int v25;
  _DWORD *v26;
  char v27;
  unsigned int v28;
  char v29;
  char v30;
  unsigned int v31;
  char v32;
  char v33;
  unsigned int v34;
  char v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  char v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  char v45;
  char v46;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  char v50;
  char v51;
  unsigned int v52;
  uint64_t v53;
  unint64_t v54;
  char v55;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v6 = *a2;
    while (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      while (1)
      {
        v10 = v3 + 1;
        a2[1] = v3 + 1;
        v11 = *(_BYTE *)(v6 + v3);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0)
          break;
        v7 += 7;
        v3 = v10;
        v12 = v8++ > 8;
        if (v12)
        {
          v9 = 0;
          break;
        }
      }
      v3 = v10;
LABEL_24:
      if ((v9 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      switch((v9 >> 3))
      {
        case 1u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            v20 = 0;
            v21 = 0;
            v22 = 0;
            do
            {
              v23 = v3 + 1;
              a2[1] = v3 + 1;
              v24 = *(_BYTE *)(v6 + v3);
              v22 |= (unint64_t)(v24 & 0x7F) << v20;
              if ((v24 & 0x80) == 0)
                goto LABEL_33;
              v20 += 7;
              v3 = v23;
              v12 = v21++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_33:
            v25 = 1;
            v26 = a1 + 3;
            goto LABEL_99;
          }
          v36 = 0;
          v37 = 0;
          v22 = 0;
          v38 = *a2;
          if (v3 <= v2)
            v23 = v2;
          else
            v23 = v3;
          while (v23 != v3)
          {
            v39 = v3++;
            v40 = *(_BYTE *)(v38 + v39);
            a2[1] = v3;
            v22 |= (unint64_t)(v40 & 0x7F) << v36;
            if ((v40 & 0x80) == 0)
              goto LABEL_66;
            v36 += 7;
            v12 = v37++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
LABEL_66:
              v3 = v39 + 1;
              v25 = 1;
              v26 = a1 + 3;
              goto LABEL_100;
            }
          }
          v25 = 1;
          v26 = a1 + 3;
          goto LABEL_98;
        case 2u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            v27 = 0;
            v28 = 0;
            v22 = 0;
            do
            {
              v23 = v3 + 1;
              a2[1] = v3 + 1;
              v29 = *(_BYTE *)(v6 + v3);
              v22 |= (unint64_t)(v29 & 0x7F) << v27;
              if ((v29 & 0x80) == 0)
                goto LABEL_41;
              v27 += 7;
              v3 = v23;
              v12 = v28++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_41:
            v25 = 2;
            v26 = a1 + 4;
            goto LABEL_99;
          }
          v41 = 0;
          v42 = 0;
          v22 = 0;
          v43 = *a2;
          if (v3 <= v2)
            v23 = v2;
          else
            v23 = v3;
          while (v23 != v3)
          {
            v44 = v3++;
            v45 = *(_BYTE *)(v43 + v44);
            a2[1] = v3;
            v22 |= (unint64_t)(v45 & 0x7F) << v41;
            if ((v45 & 0x80) == 0)
              goto LABEL_75;
            v41 += 7;
            v12 = v42++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
LABEL_75:
              v3 = v44 + 1;
              v25 = 2;
              v26 = a1 + 4;
              goto LABEL_100;
            }
          }
          v25 = 2;
          v26 = a1 + 4;
          goto LABEL_98;
        case 3u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            v30 = 0;
            v31 = 0;
            v22 = 0;
            do
            {
              v23 = v3 + 1;
              a2[1] = v3 + 1;
              v32 = *(_BYTE *)(v6 + v3);
              v22 |= (unint64_t)(v32 & 0x7F) << v30;
              if ((v32 & 0x80) == 0)
                goto LABEL_49;
              v30 += 7;
              v3 = v23;
              v12 = v31++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_49:
            v25 = 4;
            v26 = a1 + 5;
            goto LABEL_99;
          }
          v46 = 0;
          v47 = 0;
          v22 = 0;
          v48 = *a2;
          if (v3 <= v2)
            v23 = v2;
          else
            v23 = v3;
          while (v23 != v3)
          {
            v49 = v3++;
            v50 = *(_BYTE *)(v48 + v49);
            a2[1] = v3;
            v22 |= (unint64_t)(v50 & 0x7F) << v46;
            if ((v50 & 0x80) == 0)
              goto LABEL_84;
            v46 += 7;
            v12 = v47++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
LABEL_84:
              v3 = v49 + 1;
              v25 = 4;
              v26 = a1 + 5;
              goto LABEL_100;
            }
          }
          v25 = 4;
          v26 = a1 + 5;
          goto LABEL_98;
        case 4u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            v33 = 0;
            v34 = 0;
            v22 = 0;
            do
            {
              v23 = v3 + 1;
              a2[1] = v3 + 1;
              v35 = *(_BYTE *)(v6 + v3);
              v22 |= (unint64_t)(v35 & 0x7F) << v33;
              if ((v35 & 0x80) == 0)
                goto LABEL_57;
              v33 += 7;
              v3 = v23;
              v12 = v34++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_57:
            v25 = 8;
            v26 = a1 + 6;
            goto LABEL_99;
          }
          v51 = 0;
          v52 = 0;
          v22 = 0;
          v53 = *a2;
          if (v3 <= v2)
            v23 = v2;
          else
            v23 = v3;
          break;
        default:
          goto LABEL_101;
      }
      while (v23 != v3)
      {
        v54 = v3++;
        v55 = *(_BYTE *)(v53 + v54);
        a2[1] = v3;
        v22 |= (unint64_t)(v55 & 0x7F) << v51;
        if ((v55 & 0x80) == 0)
          goto LABEL_93;
        v51 += 7;
        v12 = v52++ > 8;
        if (v12)
        {
          LODWORD(v22) = 0;
LABEL_93:
          v3 = v54 + 1;
          v25 = 8;
          v26 = a1 + 6;
          goto LABEL_100;
        }
      }
      v25 = 8;
      v26 = a1 + 6;
LABEL_98:
      LODWORD(v22) = 0;
      *((_BYTE *)a2 + 24) = 1;
LABEL_99:
      v3 = v23;
LABEL_100:
      *v26 = v22;
      a1[2] |= v25;
LABEL_101:
      v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((_BYTE *)a2 + 24))
        return v4 == 0;
    }
    v13 = 0;
    v14 = 0;
    v9 = 0;
    v15 = *a2;
    if (v3 <= v2)
      v16 = v2;
    else
      v16 = v3;
    while (v16 != v3)
    {
      v17 = v3++;
      v18 = *(_BYTE *)(v15 + v17);
      a2[1] = v3;
      v9 |= (unint64_t)(v18 & 0x7F) << v13;
      if ((v18 & 0x80) == 0)
        goto LABEL_23;
      v13 += 7;
      if (v14++ >= 9)
      {
        v9 = 0;
LABEL_23:
        v3 = v17 + 1;
        goto LABEL_24;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::SessionUpdateSummary::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      return this;
    return PB::Writer::writeVarInt(a2);
  }
LABEL_8:
  this = PB::Writer::writeVarInt(a2);
  if ((*(_DWORD *)(v3 + 8) & 8) != 0)
    return PB::Writer::writeVarInt(a2);
  return this;
}

uint64_t as::server::SessionUpdateSummary::formatText(as::server::SessionUpdateSummary *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "sessionToken");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
LABEL_9:
      PB::TextFormatter::format(a2, "generationCount");
      if ((*((_DWORD *)this + 2) & 8) == 0)
        return PB::TextFormatter::endObject(a2);
      goto LABEL_5;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "changeFlags");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) != 0)
    goto LABEL_9;
LABEL_4:
  if ((v5 & 8) != 0)
LABEL_5:
    PB::TextFormatter::format(a2, "changeReason");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionUpdateSummary::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  return *(_QWORD *)(a1 + 12) == *(_QWORD *)(a2 + 12) && *(_QWORD *)(a1 + 20) == *(_QWORD *)(a2 + 20);
}

uint64_t as::server::ConfigChangeSummary::default_instance(as::server::ConfigChangeSummary *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4198;
    *(_OWORD *)(v3 + 8) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    as::server::ConfigChangeSummary::default_instance(void)::gInstance = v3;
  }
  return as::server::ConfigChangeSummary::default_instance(void)::gInstance;
}

void sub_206816D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::ConfigChangeSummary::ConfigChangeSummary(as::server::ConfigChangeSummary *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE4198;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE4198;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

as::server::ConfigChangeSummary *as::server::ConfigChangeSummary::ConfigChangeSummary(as::server::ConfigChangeSummary *this, const as::server::ConfigChangeSummary *a2)
{
  *(_QWORD *)this = &off_24BFE4198;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::server::ConfigChangeSummary::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4198;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::server::ConfigChangeSummary::copy_from(this, a2);
  return this;
}

void as::server::ConfigChangeSummary::copy_from(as::server::ConfigChangeSummary *this, const as::server::ConfigChangeSummary *a2)
{
  const as::server::ChangedObject *v4;
  as::server::ChangedObject *v5;
  uint64_t **v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t *v25;
  char *v26;
  uint64_t v27;
  __int128 v28;
  char *v29;
  uint64_t v30;
  __int128 v31;
  char *v32;
  char *v33;

  v4 = (const as::server::ChangedObject *)*((_QWORD *)a2 + 4);
  if (v4)
  {
    v5 = (as::server::ChangedObject *)as::server::ConfigChangeSummary::mutableHardwareSystemChange(this);
    as::server::ChangedObject::copy_from(v5, v4);
  }
  v7 = (_QWORD *)*((_QWORD *)this + 1);
  v8 = (_QWORD *)*((_QWORD *)this + 2);
  v6 = (uint64_t **)((char *)this + 8);
  while (v8 != v7)
  {
    v10 = *--v8;
    v9 = v10;
    *v8 = 0;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  *((_QWORD *)this + 2) = v7;
  v11 = (uint64_t *)*((_QWORD *)a2 + 1);
  for (i = (uint64_t *)*((_QWORD *)a2 + 2); v11 != i; ++v11)
  {
    v13 = operator new();
    v14 = v13;
    v15 = *v11;
    *(_QWORD *)v13 = &off_24BFE4240;
    *(_DWORD *)(v13 + 8) = *(_DWORD *)(v15 + 8);
    *(_OWORD *)(v13 + 12) = *(_OWORD *)(v15 + 12);
    v17 = (uint64_t *)*((_QWORD *)this + 2);
    v16 = *((_QWORD *)this + 3);
    if ((unint64_t)v17 >= v16)
    {
      v19 = *v6;
      v20 = v17 - *v6;
      v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v22 = v16 - (_QWORD)v19;
      if (v22 >> 2 > v21)
        v21 = v22 >> 2;
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
        v23 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v23 = v21;
      v33 = (char *)this + 24;
      if (v23)
      {
        v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 24, v23);
        v19 = (uint64_t *)*((_QWORD *)this + 1);
        v17 = (uint64_t *)*((_QWORD *)this + 2);
      }
      else
      {
        v24 = 0;
      }
      v25 = (uint64_t *)&v24[8 * v20];
      v26 = &v24[8 * v23];
      v32 = v26;
      *v25 = v14;
      *((_QWORD *)&v31 + 1) = v25 + 1;
      if (v17 == v19)
      {
        v18 = v25 + 1;
      }
      else
      {
        do
        {
          v27 = *--v17;
          *v17 = 0;
          *--v25 = v27;
        }
        while (v17 != v19);
        v18 = (_QWORD *)*((_QWORD *)&v31 + 1);
        v26 = v32;
      }
      v28 = *(_OWORD *)((char *)this + 8);
      *((_QWORD *)this + 1) = v25;
      *((_QWORD *)this + 2) = v18;
      v31 = v28;
      v29 = (char *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = v26;
      v32 = v29;
      v30 = v28;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v30);
    }
    else
    {
      *v17 = v13;
      v18 = v17 + 1;
    }
    *((_QWORD *)this + 2) = v18;
  }
}

as::server::ConfigChangeSummary *as::server::ConfigChangeSummary::operator=(as::server::ConfigChangeSummary *a1, const as::server::ConfigChangeSummary *a2)
{
  as::server::ConfigChangeSummary::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::ConfigChangeSummary::hardwareSystemChange(as::server::ConfigChangeSummary *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (!result)
    return as::server::ChangedObject::default_instance(0);
  return result;
}

uint64_t as::server::ConfigChangeSummary::mutableHardwareSystemChange(as::server::ConfigChangeSummary *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 4);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3EF8;
    *(_OWORD *)(v1 + 8) = 0u;
    *(_OWORD *)(v1 + 24) = 0u;
    *(_OWORD *)(v1 + 40) = 0u;
    *(_OWORD *)(v1 + 56) = 0u;
    *(_OWORD *)(v1 + 72) = 0u;
    *(_OWORD *)(v1 + 88) = 0u;
    *(_OWORD *)(v1 + 104) = 0u;
    *(_OWORD *)(v1 + 120) = 0u;
    v3 = *((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

as::server::ChangedObject *as::server::ChangedObject::operator=(as::server::ChangedObject *a1, const as::server::ChangedObject *a2)
{
  as::server::ChangedObject::copy_from(a1, a2);
  return a1;
}

double as::server::ConfigChangeSummary::ConfigChangeSummary(uint64_t a1, _QWORD *a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24BFE4198;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 32) = a2[4];
  a2[4] = 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2[1];
  a2[1] = v3;
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2[2];
  a2[2] = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24BFE4198;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 32) = a2[4];
  a2[4] = 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2[1];
  a2[1] = v3;
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2[2];
  a2[2] = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

_QWORD *as::server::ConfigChangeSummary::move_from(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

_QWORD *as::server::ConfigChangeSummary::operator=(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

uint64_t as::server::ConfigChangeSummary::clear(as::server::ConfigChangeSummary *this)
{
  uint64_t result;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  result = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  v3 = (_QWORD *)*((_QWORD *)this + 1);
  v4 = (_QWORD *)*((_QWORD *)this + 2);
  while (v4 != v3)
  {
    v5 = *--v4;
    result = v5;
    *v4 = 0;
    if (v5)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 2) = v3;
  return result;
}

BOOL as::server::ConfigChangeSummary::isInitialized(as::server::ConfigChangeSummary *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _BOOL8 result;
  BOOL v5;

  v2 = *((_QWORD *)this + 1);
  v1 = *((_QWORD *)this + 2);
  if (v2 == v1)
    return 1;
  v3 = v2 + 8;
  do
  {
    result = (*(_DWORD *)(*(_QWORD *)(v3 - 8) + 8) & 0xF) == 15;
    v5 = (*(_DWORD *)(*(_QWORD *)(v3 - 8) + 8) & 0xF) != 0xF || v3 == v1;
    v3 += 8;
  }
  while (!v5);
  return result;
}

BOOL as::server::ConfigChangeSummary::readFrom(_QWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  char v17;
  unsigned int v18;
  unint64_t v19;
  char v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  char *v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  int64x2_t v39;
  char *v40;
  uint64_t v42;
  int64x2_t v43;
  char *v44;
  uint64_t v45;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v8 = (int64x2_t *)(a1 + 1);
    v9 = (uint64_t)(a1 + 3);
    do
    {
      v10 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v17 = 0;
        v18 = 0;
        v13 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v19 = v2 + 1;
          v20 = *(_BYTE *)(v10 + v2);
          a2[1] = v19;
          v13 |= (unint64_t)(v20 & 0x7F) << v17;
          if ((v20 & 0x80) == 0)
            goto LABEL_21;
          v17 += 7;
          v2 = v19;
          if (v18++ >= 9)
          {
LABEL_20:
            v13 = 0;
            goto LABEL_21;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v2 + 1;
        a2[1] = v2 + 1;
        v15 = *(_BYTE *)(v10 + v2);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v2 = v14;
        if (v12++ > 8)
          goto LABEL_20;
      }
LABEL_21:
      if ((v13 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v13 >> 3) == 3)
      {
        v24 = operator new();
        v25 = v24;
        *(_QWORD *)(v24 + 8) = 0;
        *(_QWORD *)(v24 + 16) = 0;
        *(_QWORD *)v24 = &off_24BFE4240;
        *(_DWORD *)(v24 + 24) = 0;
        v27 = (uint64_t *)a1[2];
        v26 = a1[3];
        if ((unint64_t)v27 >= v26)
        {
          v29 = ((uint64_t)v27 - v8->i64[0]) >> 3;
          if ((unint64_t)(v29 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v30 = v26 - v8->i64[0];
          v31 = v30 >> 2;
          if (v30 >> 2 <= (unint64_t)(v29 + 1))
            v31 = v29 + 1;
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
            v32 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          v45 = v9;
          if (v32)
            v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v32);
          else
            v33 = 0;
          v34 = (uint64_t *)&v33[8 * v29];
          v35 = &v33[8 * v32];
          v44 = v35;
          *v34 = v25;
          v28 = v34 + 1;
          v43.i64[1] = (uint64_t)(v34 + 1);
          v37 = (_QWORD *)a1[1];
          v36 = (_QWORD *)a1[2];
          if (v36 == v37)
          {
            v39 = vdupq_n_s64((unint64_t)v36);
          }
          else
          {
            do
            {
              v38 = *--v36;
              *v36 = 0;
              *--v34 = v38;
            }
            while (v36 != v37);
            v39 = *v8;
            v28 = (_QWORD *)v43.i64[1];
            v35 = v44;
          }
          a1[1] = v34;
          a1[2] = v28;
          v43 = v39;
          v40 = (char *)a1[3];
          a1[3] = v35;
          v44 = v40;
          v42 = v39.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v42);
        }
        else
        {
          *v27 = v24;
          v28 = v27 + 1;
        }
        a1[2] = v28;
        v22 = *(v28 - 1);
        if ((PB::Reader::placeMark() & 1) == 0)
          return 0;
      }
      else
      {
        if ((v13 >> 3) != 2)
          goto LABEL_47;
        v22 = operator new();
        *(_QWORD *)v22 = &off_24BFE3EF8;
        *(_OWORD *)(v22 + 8) = 0u;
        *(_OWORD *)(v22 + 24) = 0u;
        *(_OWORD *)(v22 + 40) = 0u;
        *(_OWORD *)(v22 + 56) = 0u;
        *(_OWORD *)(v22 + 72) = 0u;
        *(_OWORD *)(v22 + 88) = 0u;
        *(_OWORD *)(v22 + 104) = 0u;
        *(_OWORD *)(v22 + 120) = 0u;
        v23 = a1[4];
        a1[4] = v22;
        if (v23)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
          v22 = a1[4];
        }
        if (!PB::Reader::placeMark())
          return 0;
      }
      if (((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v22 + 16))(v22, a2) & 1) == 0)
        return 0;
      PB::Reader::recallMark();
LABEL_47:
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

void sub_2068175F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::ConfigChangeSummary::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;

  v3 = this;
  v4 = *(const PB::Base **)(this + 32);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  v6 = *(const PB::Base ***)(v3 + 8);
  v5 = *(const PB::Base ***)(v3 + 16);
  while (v6 != v5)
  {
    v7 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  return this;
}

uint64_t as::server::ConfigChangeSummary::formatText(as::server::ConfigChangeSummary *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 4);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "hardwareSystemChange");
  v6 = (uint64_t *)*((_QWORD *)this + 1);
  v7 = (uint64_t *)*((_QWORD *)this + 2);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "sessionChanges");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ConfigChangeSummary::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(a2 + 32);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
  }
  else if (!as::server::ChangedObject::operator==((_QWORD *)v4, (_QWORD *)v5))
  {
    return 0;
  }
  v9 = a1 + 8;
  v8 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)(v9 + 8);
  v10 = (v7 - v8) >> 3;
  v12 = a2 + 8;
  v11 = *(_QWORD *)(a2 + 8);
  if (v10 != (*(_QWORD *)(v12 + 8) - v11) >> 3)
    return 0;
  if (v7 == v8)
  {
    return 1;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    if (v10 <= 1)
      v15 = 1;
    else
      v15 = (v7 - v8) >> 3;
    do
    {
      v16 = *(_QWORD *)(v8 + 8 * v14);
      v17 = *(_QWORD *)(v11 + 8 * v14);
      if (v16)
        v18 = v17 == 0;
      else
        v18 = 1;
      if (v18)
      {
        if (v16 | v17)
          return v13;
      }
      else if (!as::server::SessionUpdateSummary::operator==(v16, v17))
      {
        return v13;
      }
      v13 = ++v14 >= v10;
    }
    while (v15 != v14);
  }
  return v13;
}

uint64_t as::server::ChangedObject::default_instance(as::server::ChangedObject *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3EF8;
    *(_OWORD *)(v3 + 8) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    as::server::ChangedObject::default_instance(void)::gInstance = v3;
  }
  return as::server::ChangedObject::default_instance(void)::gInstance;
}

void sub_206817874(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::ChangedObject::ChangedObject(as::server::ChangedObject *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3EF8;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3EF8;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

uint64_t as::server::ConfigChangeSummary::clearHardwareSystemChange(as::server::ConfigChangeSummary *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ConfigChangeSummary::addSessionChanges(as::server::ConfigChangeSummary *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 3);
  v2 = (char *)this + 24;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 1);
      v5 = (_QWORD *)*((_QWORD *)this + 2);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 8);
    *((_QWORD *)this + 1) = v13;
    *((_QWORD *)this + 2) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 2) = v6;
  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)result = &off_24BFE4240;
  *(_DWORD *)(result + 24) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::CustomPropertyAddress::default_instance(as::server::CustomPropertyAddress *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    v3[1] = 0;
    v3[2] = 0;
    *v3 = &off_24BFE4278;
    as::server::CustomPropertyAddress::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::server::CustomPropertyAddress::default_instance(void)::gInstance;
}

void sub_206817AB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::server::CustomPropertyAddress::CustomPropertyAddress(_QWORD *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE4278;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE4278;
  return this;
}

uint64_t as::server::CustomPropertyAddress::CustomPropertyAddress(uint64_t this, const as::server::CustomPropertyAddress *a2)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24BFE4278;
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  v2 = *(_QWORD *)((char *)a2 + 12);
  *(_DWORD *)(this + 20) = *((_DWORD *)a2 + 5);
  *(_QWORD *)(this + 12) = v2;
  return this;
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24BFE4278;
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  v2 = *(_QWORD *)((char *)a2 + 12);
  *(_DWORD *)(this + 20) = *((_DWORD *)a2 + 5);
  *(_QWORD *)(this + 12) = v2;
  return this;
}

uint64_t as::server::CustomPropertyAddress::copy_from(uint64_t this, const as::server::CustomPropertyAddress *a2)
{
  uint64_t v2;

  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  v2 = *(_QWORD *)((char *)a2 + 12);
  *(_DWORD *)(this + 20) = *((_DWORD *)a2 + 5);
  *(_QWORD *)(this + 12) = v2;
  return this;
}

uint64_t as::server::CustomPropertyAddress::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v2 = *(_QWORD *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(result + 12) = v2;
  return result;
}

{
  uint64_t v2;

  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v2 = *(_QWORD *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(result + 12) = v2;
  return result;
}

uint64_t as::server::CustomPropertyAddress::CustomPropertyAddress(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)result = &off_24BFE4278;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v2 = *(_QWORD *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(result + 12) = v2;
  return result;
}

{
  uint64_t v2;

  *(_QWORD *)result = &off_24BFE4278;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v2 = *(_QWORD *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(result + 12) = v2;
  return result;
}

uint64_t as::server::CustomPropertyAddress::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v2 = *(_QWORD *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(result + 12) = v2;
  return result;
}

uint64_t as::server::CustomPropertyAddress::clear(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  return this;
}

BOOL as::server::CustomPropertyAddress::isInitialized(as::server::CustomPropertyAddress *this)
{
  return (~*((_DWORD *)this + 2) & 7) == 0;
}

BOOL as::server::CustomPropertyAddress::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v6;
  char v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  BOOL v12;
  char v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  unint64_t v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  int v26;
  _DWORD *v27;
  char v28;
  unsigned int v29;
  char v30;
  char v31;
  unsigned int v32;
  char v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  char v39;
  unsigned int v40;
  uint64_t v41;
  unint64_t v42;
  char v43;
  char v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  char v48;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v6 = *a2;
  while (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    while (1)
    {
      v10 = v3 + 1;
      a2[1] = v3 + 1;
      v11 = *(_BYTE *)(v6 + v3);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0)
        break;
      v7 += 7;
      v3 = v10;
      v12 = v8++ > 8;
      if (v12)
      {
        v9 = 0;
        break;
      }
    }
    v3 = v10;
LABEL_24:
    if ((v9 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    v20 = v9 >> 3;
    switch((_DWORD)v20)
    {
      case 3:
        if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
        {
          v28 = 0;
          v29 = 0;
          v23 = 0;
          while (1)
          {
            v24 = v3 + 1;
            a2[1] = v3 + 1;
            v30 = *(_BYTE *)(v6 + v3);
            v23 |= (unint64_t)(v30 & 0x7F) << v28;
            if ((v30 & 0x80) == 0)
              break;
            v28 += 7;
            v3 = v24;
            v12 = v29++ > 8;
            if (v12)
            {
              LODWORD(v23) = 0;
              break;
            }
          }
          v26 = 4;
          v27 = a1 + 5;
LABEL_83:
          v3 = v24;
LABEL_84:
          *v27 = v23;
          a1[2] |= v26;
          break;
        }
        v39 = 0;
        v40 = 0;
        v23 = 0;
        v41 = *a2;
        if (v3 <= v2)
          v24 = v2;
        else
          v24 = v3;
        while (v24 != v3)
        {
          v42 = v3++;
          v43 = *(_BYTE *)(v41 + v42);
          a2[1] = v3;
          v23 |= (unint64_t)(v43 & 0x7F) << v39;
          if ((v43 & 0x80) == 0)
            goto LABEL_69;
          v39 += 7;
          v12 = v40++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
LABEL_69:
            v3 = v42 + 1;
            v26 = 4;
            v27 = a1 + 5;
            goto LABEL_84;
          }
        }
        v26 = 4;
        v27 = a1 + 5;
LABEL_82:
        LODWORD(v23) = 0;
        *((_BYTE *)a2 + 24) = 1;
        goto LABEL_83;
      case 2:
        if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
        {
          v31 = 0;
          v32 = 0;
          v23 = 0;
          while (1)
          {
            v24 = v3 + 1;
            a2[1] = v3 + 1;
            v33 = *(_BYTE *)(v6 + v3);
            v23 |= (unint64_t)(v33 & 0x7F) << v31;
            if ((v33 & 0x80) == 0)
              break;
            v31 += 7;
            v3 = v24;
            v12 = v32++ > 8;
            if (v12)
            {
              LODWORD(v23) = 0;
              break;
            }
          }
          v26 = 2;
          v27 = a1 + 4;
          goto LABEL_83;
        }
        v44 = 0;
        v45 = 0;
        v23 = 0;
        v46 = *a2;
        if (v3 <= v2)
          v24 = v2;
        else
          v24 = v3;
        while (v24 != v3)
        {
          v47 = v3++;
          v48 = *(_BYTE *)(v46 + v47);
          a2[1] = v3;
          v23 |= (unint64_t)(v48 & 0x7F) << v44;
          if ((v48 & 0x80) == 0)
            goto LABEL_78;
          v44 += 7;
          v12 = v45++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
LABEL_78:
            v3 = v47 + 1;
            v26 = 2;
            v27 = a1 + 4;
            goto LABEL_84;
          }
        }
        v26 = 2;
        v27 = a1 + 4;
        goto LABEL_82;
      case 1:
        if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
        {
          v21 = 0;
          v22 = 0;
          v23 = 0;
          while (1)
          {
            v24 = v3 + 1;
            a2[1] = v3 + 1;
            v25 = *(_BYTE *)(v6 + v3);
            v23 |= (unint64_t)(v25 & 0x7F) << v21;
            if ((v25 & 0x80) == 0)
              break;
            v21 += 7;
            v3 = v24;
            v12 = v22++ > 8;
            if (v12)
            {
              LODWORD(v23) = 0;
              break;
            }
          }
          v26 = 1;
          v27 = a1 + 3;
          goto LABEL_83;
        }
        v34 = 0;
        v35 = 0;
        v23 = 0;
        v36 = *a2;
        if (v3 <= v2)
          v24 = v2;
        else
          v24 = v3;
        while (v24 != v3)
        {
          v37 = v3++;
          v38 = *(_BYTE *)(v36 + v37);
          a2[1] = v3;
          v23 |= (unint64_t)(v38 & 0x7F) << v34;
          if ((v38 & 0x80) == 0)
            goto LABEL_60;
          v34 += 7;
          v12 = v35++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
LABEL_60:
            v3 = v37 + 1;
            v26 = 1;
            v27 = a1 + 3;
            goto LABEL_84;
          }
        }
        v26 = 1;
        v27 = a1 + 3;
        goto LABEL_82;
    }
    v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((_BYTE *)a2 + 24))
      return v4 == 0;
  }
  v13 = 0;
  v14 = 0;
  v9 = 0;
  v15 = *a2;
  if (v3 <= v2)
    v16 = v2;
  else
    v16 = v3;
  while (v16 != v3)
  {
    v17 = v3++;
    v18 = *(_BYTE *)(v15 + v17);
    a2[1] = v3;
    v9 |= (unint64_t)(v18 & 0x7F) << v13;
    if ((v18 & 0x80) == 0)
      goto LABEL_23;
    v13 += 7;
    if (v14++ >= 9)
    {
      v9 = 0;
LABEL_23:
      v3 = v17 + 1;
      goto LABEL_24;
    }
  }
  v4 = 1;
  *((_BYTE *)a2 + 24) = 1;
  return v4 == 0;
}

uint64_t as::server::CustomPropertyAddress::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        return this;
      return PB::Writer::writeVarInt(a2);
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  if ((*(_DWORD *)(v3 + 8) & 4) != 0)
    return PB::Writer::writeVarInt(a2);
  return this;
}

uint64_t as::server::CustomPropertyAddress::formatText(as::server::CustomPropertyAddress *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0)
      goto LABEL_3;
LABEL_7:
    PB::TextFormatter::format(a2, "scope");
    if ((*((_DWORD *)this + 2) & 4) == 0)
      return PB::TextFormatter::endObject(a2);
    goto LABEL_4;
  }
  PB::TextFormatter::format(a2, "selector");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 2) != 0)
    goto LABEL_7;
LABEL_3:
  if ((v5 & 4) != 0)
LABEL_4:
    PB::TextFormatter::format(a2, "element");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::CustomPropertyAddress::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  return *(_QWORD *)(a1 + 12) == *(_QWORD *)(a2 + 12)
      && *(_DWORD *)(a1 + 20) == (unint64_t)*(unsigned int *)(a2 + 20);
}

uint64_t as::server::ObjectDescription::default_instance(as::server::ObjectDescription *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4128;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 92) = 0u;
    as::server::ObjectDescription::default_instance(void)::gInstance = v3;
  }
  return as::server::ObjectDescription::default_instance(void)::gInstance;
}

void sub_2068181C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::ObjectDescription::ObjectDescription(as::server::ObjectDescription *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE4128;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE4128;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  return result;
}

as::server::ObjectDescription *as::server::ObjectDescription::ObjectDescription(as::server::ObjectDescription *this, const as::server::ObjectDescription *a2)
{
  *(_QWORD *)this = &off_24BFE4128;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::ObjectDescription::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4128;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::ObjectDescription::copy_from(this, a2);
  return this;
}

void as::server::ObjectDescription::copy_from(as::server::ObjectDescription *this, const as::server::ObjectDescription *a2)
{
  const as::server::Driver *v4;
  as::server::Driver *v5;
  const as::server::Box *v6;
  as::server::Box *v7;
  const as::server::Clock *v8;
  as::server::Clock *v9;
  const as::server::Device_Clock *v10;
  as::server::Device_Clock *v11;
  const as::server::Port *v12;
  as::server::Port *v13;
  const as::server::HWStream *v14;
  as::server::HWStream *v15;
  const as::server::ControlAndValue *v16;
  as::server::ControlAndValue *v17;
  const as::server::IOControllerState *v18;
  as::server::IOControllerState *v19;
  const as::server::IOStreamState *v20;
  as::server::IOStreamState *v21;
  const as::server::VirtualPort *v22;
  as::server::VirtualPort *v23;
  uint64_t v24;

  v4 = (const as::server::Driver *)*((_QWORD *)a2 + 2);
  if (v4)
  {
    v5 = (as::server::Driver *)as::server::ObjectDescription::mutableDriver(this);
    as::server::Driver::copy_from(v5, v4);
  }
  v6 = (const as::server::Box *)*((_QWORD *)a2 + 3);
  if (v6)
  {
    v7 = (as::server::Box *)as::server::ObjectDescription::mutableBox(this);
    as::server::Box::copy_from(v7, v6);
  }
  v8 = (const as::server::Clock *)*((_QWORD *)a2 + 4);
  if (v8)
  {
    v9 = (as::server::Clock *)as::server::ObjectDescription::mutableClock(this);
    as::server::Clock::copy_from(v9, v8);
  }
  v10 = (const as::server::Device_Clock *)*((_QWORD *)a2 + 5);
  if (v10)
  {
    v11 = (as::server::Device_Clock *)as::server::ObjectDescription::mutableDevice(this);
    as::server::Device_Clock::copy_from(v11, v10);
  }
  v12 = (const as::server::Port *)*((_QWORD *)a2 + 6);
  if (v12)
  {
    v13 = (as::server::Port *)as::server::ObjectDescription::mutableHwPort(this);
    as::server::Port::copy_from(v13, v12);
  }
  v14 = (const as::server::HWStream *)*((_QWORD *)a2 + 7);
  if (v14)
  {
    v15 = (as::server::HWStream *)as::server::ObjectDescription::mutableHwStream(this);
    as::server::HWStream::copy_from(v15, v14);
  }
  v16 = (const as::server::ControlAndValue *)*((_QWORD *)a2 + 8);
  if (v16)
  {
    v17 = (as::server::ControlAndValue *)as::server::ObjectDescription::mutableControlAndValue(this);
    as::server::ControlAndValue::copy_from(v17, v16);
  }
  v18 = (const as::server::IOControllerState *)*((_QWORD *)a2 + 9);
  if (v18)
  {
    v19 = (as::server::IOControllerState *)as::server::ObjectDescription::mutableController(this);
    as::server::IOControllerState::copy_from(v19, v18);
  }
  v20 = (const as::server::IOStreamState *)*((_QWORD *)a2 + 10);
  if (v20)
  {
    v21 = (as::server::IOStreamState *)as::server::ObjectDescription::mutableIoStream(this);
    as::server::IOStreamState::copy_from(v21, v20);
  }
  v22 = (const as::server::VirtualPort *)*((_QWORD *)a2 + 11);
  if (v22)
  {
    v23 = (as::server::VirtualPort *)as::server::ObjectDescription::mutableVirtualPort(this);
    as::server::VirtualPort::copy_from(v23, v22);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v24 = *((_QWORD *)a2 + 12);
  *((_DWORD *)this + 26) = *((_DWORD *)a2 + 26);
  *((_QWORD *)this + 12) = v24;
}

as::server::ObjectDescription *as::server::ObjectDescription::operator=(as::server::ObjectDescription *a1, const as::server::ObjectDescription *a2)
{
  as::server::ObjectDescription::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::ObjectDescription::driver(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return as::server::Driver::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableDriver(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE43C8;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_QWORD *)(v1 + 112) = 0;
    v3 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::box(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (!result)
    return as::server::Box::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableBox(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 3);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE42E8;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_BYTE *)(v1 + 96) = 0;
    v3 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::clock(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (!result)
    return as::server::Clock::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableClock(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 4);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE4358;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_OWORD *)(v1 + 112) = 0u;
    *(_QWORD *)(v1 + 128) = 0;
    v3 = *((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::device(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 5);
  if (!result)
    return as::server::Device_Clock::default_instance(0);
  return result;
}

_QWORD *as::server::ObjectDescription::mutableDevice(as::server::ObjectDescription *this)
{
  _QWORD *v1;
  uint64_t v3;

  v1 = (_QWORD *)*((_QWORD *)this + 5);
  if (!v1)
  {
    v1 = (_QWORD *)operator new();
    v1[1] = 0;
    v1[2] = 0;
    *v1 = &off_24BFE3E88;
    v3 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::hwPort(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 6);
  if (!result)
    return as::server::Port::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableHwPort(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 6);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE4320;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_OWORD *)(v1 + 112) = 0u;
    *(_OWORD *)(v1 + 121) = 0u;
    v3 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::hwStream(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 7);
  if (!result)
    return as::server::HWStream::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableHwStream(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 7);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE4438;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_OWORD *)(v1 + 112) = 0u;
    *(_DWORD *)(v1 + 128) = 0;
    v3 = *((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::controlAndValue(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 8);
  if (!result)
    return as::server::ControlAndValue::default_instance(0);
  return result;
}

_QWORD *as::server::ObjectDescription::mutableControlAndValue(as::server::ObjectDescription *this)
{
  _QWORD *v1;
  uint64_t v3;

  v1 = (_QWORD *)*((_QWORD *)this + 8);
  if (!v1)
  {
    v1 = (_QWORD *)operator new();
    v1[1] = 0;
    v1[2] = 0;
    *v1 = &off_24BFE3FA0;
    v3 = *((_QWORD *)this + 8);
    *((_QWORD *)this + 8) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::controller(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 9);
  if (!result)
    return as::server::IOControllerState::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableController(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 9);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE40F0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_OWORD *)(v1 + 112) = 0u;
    *(_QWORD *)(v1 + 128) = 0;
    v3 = *((_QWORD *)this + 9);
    *((_QWORD *)this + 9) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

as::server::IOControllerState *as::server::IOControllerState::operator=(as::server::IOControllerState *a1, const as::server::IOControllerState *a2)
{
  as::server::IOControllerState::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::ObjectDescription::ioStream(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 10);
  if (!result)
    return as::server::IOStreamState::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableIoStream(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 10);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3F30;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_DWORD *)(v1 + 80) = 0;
    v3 = *((_QWORD *)this + 10);
    *((_QWORD *)this + 10) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ObjectDescription::virtualPort(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 11);
  if (!result)
    return as::server::VirtualPort::default_instance(0);
  return result;
}

uint64_t as::server::ObjectDescription::mutableVirtualPort(as::server::ObjectDescription *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 11);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3E18;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_WORD *)(v1 + 48) = 0;
    v3 = *((_QWORD *)this + 11);
    *((_QWORD *)this + 11) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

as::server::VirtualPort *as::server::VirtualPort::operator=(as::server::VirtualPort *a1, const as::server::VirtualPort *a2)
{
  as::server::VirtualPort::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::ObjectDescription::ObjectDescription(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE4128;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::ObjectDescription::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE4128;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::ObjectDescription::move_from(a1, a2);
  return a1;
}

uint64_t as::server::ObjectDescription::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  v5 = *(_QWORD *)(result + 40);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v5;
  v6 = *(_QWORD *)(result + 48);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v6;
  v7 = *(_QWORD *)(result + 56);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v7;
  v8 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v8;
  v9 = *(_QWORD *)(result + 72);
  *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v9;
  v10 = *(_QWORD *)(result + 80);
  *(_QWORD *)(result + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v10;
  v11 = *(_QWORD *)(result + 88);
  *(_QWORD *)(result + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v11;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v12 = *(_QWORD *)(a2 + 96);
  *(_DWORD *)(result + 104) = *(_DWORD *)(a2 + 104);
  *(_QWORD *)(result + 96) = v12;
  return result;
}

uint64_t as::server::ObjectDescription::operator=(uint64_t a1, uint64_t a2)
{
  as::server::ObjectDescription::move_from(a1, a2);
  return a1;
}

uint64_t as::server::ObjectDescription::clear(as::server::ObjectDescription *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  v9 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v10 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  result = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  return result;
}

BOOL as::server::ObjectDescription::isInitialized(as::server::ObjectDescription *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::ObjectDescription::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int i;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  unint64_t v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v44;
  unsigned int v45;
  unint64_t v46;
  char v47;
  char v48;
  unsigned int v49;
  unint64_t v50;
  char v51;
  int v52;

  v3 = a2[1];
  v2 = a2[2];
  for (i = *((unsigned __int8 *)a2 + 24); v3 < v2 && i == 0; i = *((unsigned __int8 *)a2 + 24))
  {
    v8 = *a2;
    if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
    {
      v15 = 0;
      v16 = 0;
      v11 = 0;
      if (v3 <= v2)
        v17 = v2;
      else
        v17 = v3;
      while (v17 != v3)
      {
        v18 = v3++;
        v19 = *(_BYTE *)(v8 + v18);
        a2[1] = v3;
        v11 |= (unint64_t)(v19 & 0x7F) << v15;
        if ((v19 & 0x80) == 0)
          goto LABEL_21;
        v15 += 7;
        v20 = v16++ >= 9;
        if (v20)
        {
          v11 = 0;
LABEL_21:
          v12 = v18 + 1;
          goto LABEL_22;
        }
      }
      i = 1;
      *((_BYTE *)a2 + 24) = 1;
      return i == 0;
    }
    v9 = 0;
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = v3 + 1;
      a2[1] = v3 + 1;
      v13 = *(_BYTE *)(v8 + v3);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0)
        break;
      v9 += 7;
      v3 = v12;
      v14 = v10++ > 8;
      if (v14)
      {
        v11 = 0;
        break;
      }
    }
LABEL_22:
    if ((v11 & 7) == 4)
    {
      i = 0;
      return i == 0;
    }
    v21 = v11 >> 3;
    if ((int)(v11 >> 3) <= 39)
    {
      switch((int)v21)
      {
        case 1:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            v22 = 0;
            v23 = 0;
            v24 = 0;
            do
            {
              v25 = v12 + 1;
              a2[1] = v12 + 1;
              v26 = *(_BYTE *)(v8 + v12);
              v24 |= (unint64_t)(v26 & 0x7F) << v22;
              if ((v26 & 0x80) == 0)
                goto LABEL_85;
              v22 += 7;
              v12 = v25;
              v14 = v23++ > 8;
            }
            while (!v14);
LABEL_76:
            v24 = 0;
            goto LABEL_85;
          }
          v44 = 0;
          v45 = 0;
          v24 = 0;
          if (v2 <= v12)
            v2 = v12;
          while (v2 != v12)
          {
            v46 = v12 + 1;
            v47 = *(_BYTE *)(v8 + v12);
            a2[1] = v46;
            v24 |= (unint64_t)(v47 & 0x7F) << v44;
            if ((v47 & 0x80) == 0)
              goto LABEL_85;
            v44 += 7;
            v12 = v46;
            v20 = v45++ >= 9;
            if (v20)
              goto LABEL_76;
          }
          v24 = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_85:
          *(_QWORD *)(a1 + 96) = v24;
          v52 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_88;
        case 2:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            v29 = 0;
            v30 = 0;
            v31 = 0;
            do
            {
              v32 = v12 + 1;
              a2[1] = v12 + 1;
              v33 = *(_BYTE *)(v8 + v12);
              v31 |= (unint64_t)(v33 & 0x7F) << v29;
              if ((v33 & 0x80) == 0)
                goto LABEL_87;
              v29 += 7;
              v12 = v32;
              v14 = v30++ > 8;
            }
            while (!v14);
LABEL_83:
            LODWORD(v31) = 0;
            goto LABEL_87;
          }
          v48 = 0;
          v49 = 0;
          v31 = 0;
          if (v2 <= v12)
            v2 = v12;
          while (v2 != v12)
          {
            v50 = v12 + 1;
            v51 = *(_BYTE *)(v8 + v12);
            a2[1] = v50;
            v31 |= (unint64_t)(v51 & 0x7F) << v48;
            if ((v51 & 0x80) == 0)
              goto LABEL_87;
            v48 += 7;
            v12 = v50;
            v20 = v49++ >= 9;
            if (v20)
              goto LABEL_83;
          }
          LODWORD(v31) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_87:
          *(_DWORD *)(a1 + 104) = v31;
          v52 = *(_DWORD *)(a1 + 8) | 2;
LABEL_88:
          *(_DWORD *)(a1 + 8) = v52;
          break;
        case 3:
          v27 = operator new();
          *(_QWORD *)v27 = &off_24BFE43C8;
          *(_DWORD *)(v27 + 8) = 0;
          *(_OWORD *)(v27 + 16) = 0u;
          *(_OWORD *)(v27 + 32) = 0u;
          *(_OWORD *)(v27 + 48) = 0u;
          *(_OWORD *)(v27 + 64) = 0u;
          *(_OWORD *)(v27 + 80) = 0u;
          *(_OWORD *)(v27 + 96) = 0u;
          *(_QWORD *)(v27 + 112) = 0;
          v34 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(a1 + 16) = v27;
          if (v34)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
            v27 = *(_QWORD *)(a1 + 16);
          }
          goto LABEL_62;
        case 4:
          v27 = operator new();
          *(_QWORD *)v27 = &off_24BFE42E8;
          *(_DWORD *)(v27 + 8) = 0;
          *(_OWORD *)(v27 + 16) = 0u;
          *(_OWORD *)(v27 + 32) = 0u;
          *(_OWORD *)(v27 + 48) = 0u;
          *(_OWORD *)(v27 + 64) = 0u;
          *(_OWORD *)(v27 + 80) = 0u;
          *(_BYTE *)(v27 + 96) = 0;
          v35 = *(_QWORD *)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v27;
          if (v35)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
            v27 = *(_QWORD *)(a1 + 24);
          }
          goto LABEL_62;
        case 5:
          v27 = operator new();
          *(_QWORD *)v27 = &off_24BFE4358;
          *(_DWORD *)(v27 + 8) = 0;
          *(_OWORD *)(v27 + 16) = 0u;
          *(_OWORD *)(v27 + 32) = 0u;
          *(_OWORD *)(v27 + 48) = 0u;
          *(_OWORD *)(v27 + 64) = 0u;
          *(_OWORD *)(v27 + 80) = 0u;
          *(_OWORD *)(v27 + 96) = 0u;
          *(_OWORD *)(v27 + 112) = 0u;
          *(_QWORD *)(v27 + 128) = 0;
          v36 = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) = v27;
          if (v36)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
            v27 = *(_QWORD *)(a1 + 32);
          }
          goto LABEL_62;
        case 6:
          v27 = operator new();
          *(_QWORD *)(v27 + 8) = 0;
          *(_QWORD *)(v27 + 16) = 0;
          *(_QWORD *)v27 = &off_24BFE3E88;
          v37 = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(a1 + 40) = v27;
          if (v37)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
            v27 = *(_QWORD *)(a1 + 40);
          }
          goto LABEL_62;
        case 7:
          v27 = operator new();
          *(_QWORD *)v27 = &off_24BFE4320;
          *(_DWORD *)(v27 + 8) = 0;
          *(_OWORD *)(v27 + 16) = 0u;
          *(_OWORD *)(v27 + 32) = 0u;
          *(_OWORD *)(v27 + 48) = 0u;
          *(_OWORD *)(v27 + 64) = 0u;
          *(_OWORD *)(v27 + 80) = 0u;
          *(_OWORD *)(v27 + 96) = 0u;
          *(_OWORD *)(v27 + 112) = 0u;
          *(_OWORD *)(v27 + 121) = 0u;
          v38 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)(a1 + 48) = v27;
          if (v38)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
            v27 = *(_QWORD *)(a1 + 48);
          }
          goto LABEL_62;
        case 8:
          v27 = operator new();
          *(_QWORD *)v27 = &off_24BFE4438;
          *(_DWORD *)(v27 + 8) = 0;
          *(_OWORD *)(v27 + 16) = 0u;
          *(_OWORD *)(v27 + 32) = 0u;
          *(_OWORD *)(v27 + 48) = 0u;
          *(_OWORD *)(v27 + 64) = 0u;
          *(_OWORD *)(v27 + 80) = 0u;
          *(_OWORD *)(v27 + 96) = 0u;
          *(_OWORD *)(v27 + 112) = 0u;
          *(_DWORD *)(v27 + 128) = 0;
          v39 = *(_QWORD *)(a1 + 56);
          *(_QWORD *)(a1 + 56) = v27;
          if (v39)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
            v27 = *(_QWORD *)(a1 + 56);
          }
          goto LABEL_62;
        case 9:
          v27 = operator new();
          *(_QWORD *)(v27 + 8) = 0;
          *(_QWORD *)(v27 + 16) = 0;
          *(_QWORD *)v27 = &off_24BFE3FA0;
          v40 = *(_QWORD *)(a1 + 64);
          *(_QWORD *)(a1 + 64) = v27;
          if (v40)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v40 + 8))(v40);
            v27 = *(_QWORD *)(a1 + 64);
          }
          goto LABEL_62;
        default:
          goto LABEL_65;
      }
      goto LABEL_65;
    }
    switch((_DWORD)v21)
    {
      case '(':
        v27 = operator new();
        *(_QWORD *)v27 = &off_24BFE40F0;
        *(_DWORD *)(v27 + 8) = 0;
        *(_OWORD *)(v27 + 16) = 0u;
        *(_OWORD *)(v27 + 32) = 0u;
        *(_OWORD *)(v27 + 48) = 0u;
        *(_OWORD *)(v27 + 64) = 0u;
        *(_OWORD *)(v27 + 80) = 0u;
        *(_OWORD *)(v27 + 96) = 0u;
        *(_OWORD *)(v27 + 112) = 0u;
        *(_QWORD *)(v27 + 128) = 0;
        v41 = *(_QWORD *)(a1 + 72);
        *(_QWORD *)(a1 + 72) = v27;
        if (v41)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v41 + 8))(v41);
          v27 = *(_QWORD *)(a1 + 72);
        }
        break;
      case ')':
        v27 = operator new();
        *(_QWORD *)v27 = &off_24BFE3F30;
        *(_DWORD *)(v27 + 8) = 0;
        *(_OWORD *)(v27 + 16) = 0u;
        *(_OWORD *)(v27 + 32) = 0u;
        *(_OWORD *)(v27 + 48) = 0u;
        *(_OWORD *)(v27 + 64) = 0u;
        *(_DWORD *)(v27 + 80) = 0;
        v42 = *(_QWORD *)(a1 + 80);
        *(_QWORD *)(a1 + 80) = v27;
        if (v42)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v42 + 8))(v42);
          v27 = *(_QWORD *)(a1 + 80);
        }
        break;
      case '*':
        v27 = operator new();
        *(_QWORD *)v27 = &off_24BFE3E18;
        *(_DWORD *)(v27 + 8) = 0;
        *(_OWORD *)(v27 + 16) = 0u;
        *(_OWORD *)(v27 + 32) = 0u;
        *(_WORD *)(v27 + 48) = 0;
        v28 = *(_QWORD *)(a1 + 88);
        *(_QWORD *)(a1 + 88) = v27;
        if (v28)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
          v27 = *(_QWORD *)(a1 + 88);
        }
        break;
      default:
        goto LABEL_65;
    }
LABEL_62:
    if (!PB::Reader::placeMark()
      || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v27 + 16))(v27, a2) & 1) == 0)
    {
      return 0;
    }
    PB::Reader::recallMark();
LABEL_65:
    v3 = a2[1];
    v2 = a2[2];
  }
  return i == 0;
}

uint64_t as::server::ObjectDescription::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;
  const PB::Base *v5;
  const PB::Base *v6;
  const PB::Base *v7;
  const PB::Base *v8;
  const PB::Base *v9;
  const PB::Base *v10;
  const PB::Base *v11;
  const PB::Base *v12;
  const PB::Base *v13;
  const PB::Base *v14;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0)
    this = PB::Writer::writeVarInt(a2);
  v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
    this = PB::Writer::writeSubmessage(a2, v5);
  v6 = *(const PB::Base **)(v3 + 24);
  if (v6)
    this = PB::Writer::writeSubmessage(a2, v6);
  v7 = *(const PB::Base **)(v3 + 32);
  if (v7)
    this = PB::Writer::writeSubmessage(a2, v7);
  v8 = *(const PB::Base **)(v3 + 40);
  if (v8)
    this = PB::Writer::writeSubmessage(a2, v8);
  v9 = *(const PB::Base **)(v3 + 48);
  if (v9)
    this = PB::Writer::writeSubmessage(a2, v9);
  v10 = *(const PB::Base **)(v3 + 56);
  if (v10)
    this = PB::Writer::writeSubmessage(a2, v10);
  v11 = *(const PB::Base **)(v3 + 64);
  if (v11)
    this = PB::Writer::writeSubmessage(a2, v11);
  v12 = *(const PB::Base **)(v3 + 72);
  if (v12)
    this = PB::Writer::writeSubmessage(a2, v12);
  v13 = *(const PB::Base **)(v3 + 80);
  if (v13)
    this = PB::Writer::writeSubmessage(a2, v13);
  v14 = *(const PB::Base **)(v3 + 88);
  if (v14)
    return PB::Writer::writeSubmessage(a2, v14);
  return this;
}

uint64_t as::server::ObjectDescription::formatText(as::server::ObjectDescription *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "objectToken");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "classTypeID");
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "driver");
  v7 = *((_QWORD *)this + 3);
  if (v7)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v7 + 32))(v7, a2, "box");
  v8 = *((_QWORD *)this + 4);
  if (v8)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "clock");
  v9 = *((_QWORD *)this + 5);
  if (v9)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v9 + 32))(v9, a2, "device");
  v10 = *((_QWORD *)this + 6);
  if (v10)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v10 + 32))(v10, a2, "hwPort");
  v11 = *((_QWORD *)this + 7);
  if (v11)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v11 + 32))(v11, a2, "hwStream");
  v12 = *((_QWORD *)this + 8);
  if (v12)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v12 + 32))(v12, a2, "controlAndValue");
  v13 = *((_QWORD *)this + 9);
  if (v13)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v13 + 32))(v13, a2, "controller");
  v14 = *((_QWORD *)this + 10);
  if (v14)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v14 + 32))(v14, a2, "ioStream");
  v15 = *((_QWORD *)this + 11);
  if (v15)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v15 + 32))(v15, a2, "virtualPort");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ObjectDescription::operator==(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a1 + 96) != *(_QWORD *)(a2 + 96)
    || *(_DWORD *)(a1 + 104) != (unint64_t)*(unsigned int *)(a2 + 104))
  {
    return 0;
  }
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a2 + 16);
  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8)
  {
    if (v6 | v7)
      return 0;
  }
  else if (!as::server::Driver::operator==(v6, v7))
  {
    return 0;
  }
  v9 = *(_QWORD *)(a1 + 24);
  v10 = *(_QWORD *)(a2 + 24);
  if (v9 && v10)
  {
    if (!as::server::Box::operator==(v9, v10))
      return 0;
  }
  else if (v9 | v10)
  {
    return 0;
  }
  v11 = *(_QWORD *)(a1 + 32);
  v12 = *(_QWORD *)(a2 + 32);
  if (v11 && v12)
  {
    if (!as::server::Clock::operator==(v11, v12))
      return 0;
  }
  else if (v11 | v12)
  {
    return 0;
  }
  v13 = *(_QWORD *)(a1 + 40);
  v14 = *(_QWORD *)(a2 + 40);
  if (v13 && v14)
  {
    if (!as::server::Device_Clock::operator==(v13, v14))
      return 0;
  }
  else if (v13 | v14)
  {
    return 0;
  }
  v15 = *(_QWORD *)(a1 + 48);
  v16 = *(_QWORD *)(a2 + 48);
  if (v15 && v16)
  {
    if (!as::server::Port::operator==(v15, v16))
      return 0;
  }
  else if (v15 | v16)
  {
    return 0;
  }
  v17 = *(_QWORD *)(a1 + 56);
  v18 = *(_QWORD *)(a2 + 56);
  if (v17 && v18)
  {
    if (!as::server::HWStream::operator==(v17, v18))
      return 0;
  }
  else if (v17 | v18)
  {
    return 0;
  }
  v19 = *(_QWORD *)(a1 + 64);
  v20 = *(_QWORD *)(a2 + 64);
  if (v19 && v20)
  {
    if (!as::server::ControlAndValue::operator==(v19, v20))
      return 0;
  }
  else if (v19 | v20)
  {
    return 0;
  }
  v21 = *(_QWORD *)(a1 + 72);
  v22 = *(_QWORD *)(a2 + 72);
  if (v21 && v22)
  {
    if (!as::server::IOControllerState::operator==(v21, v22))
      return 0;
  }
  else if (v21 | v22)
  {
    return 0;
  }
  v23 = *(_QWORD *)(a1 + 80);
  v24 = *(_QWORD *)(a2 + 80);
  if (!v23 || !v24)
  {
    if (!(v23 | v24))
      goto LABEL_56;
    return 0;
  }
  if (!as::server::IOStreamState::operator==(v23, v24))
    return 0;
LABEL_56:
  v25 = *(_QWORD *)(a1 + 88);
  v26 = *(_QWORD *)(a2 + 88);
  result = (v25 | v26) == 0;
  if (v25)
  {
    if (v26)
      return as::server::VirtualPort::operator==(*(_QWORD *)(a1 + 88), v26);
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearDriver(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ObjectDescription::clearBox(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ObjectDescription::clearClock(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ObjectDescription::clearDevice(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ObjectDescription::clearHwPort(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ObjectDescription::clearHwStream(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ObjectDescription::clearControlAndValue(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::IOControllerState::default_instance(as::server::IOControllerState *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE40F0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_QWORD *)(v3 + 128) = 0;
    as::server::IOControllerState::default_instance(void)::gInstance = v3;
  }
  return as::server::IOControllerState::default_instance(void)::gInstance;
}

void sub_206819960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::IOControllerState::IOControllerState(as::server::IOControllerState *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE40F0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE40F0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_QWORD *)this + 16) = 0;
  return result;
}

uint64_t as::server::ObjectDescription::clearController(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::ObjectDescription::clearIoStream(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::VirtualPort::default_instance(as::server::VirtualPort *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3E18;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_WORD *)(v3 + 48) = 0;
    as::server::VirtualPort::default_instance(void)::gInstance = v3;
  }
  return as::server::VirtualPort::default_instance(void)::gInstance;
}

void sub_206819A6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::VirtualPort::VirtualPort(as::server::VirtualPort *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3E18;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_WORD *)this + 24) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3E18;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_WORD *)this + 24) = 0;
  return result;
}

uint64_t as::server::ObjectDescription::clearVirtualPort(as::server::ObjectDescription *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

as::server::ChangedObject *as::server::ChangedObject::ChangedObject(as::server::ChangedObject *this, const as::server::ChangedObject *a2)
{
  *(_QWORD *)this = &off_24BFE3EF8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  as::server::ChangedObject::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3EF8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  as::server::ChangedObject::copy_from(this, a2);
  return this;
}

void as::server::ChangedObject::copy_from(as::server::ChangedObject *this, const as::server::ChangedObject *a2)
{
  const as::server::ObjectDescription *v3;
  as::server::ObjectDescription *v4;
  _QWORD *v5;
  uint64_t **v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t *v25;
  char *v26;
  uint64_t v27;
  __int128 v28;
  char *v29;
  _QWORD *v30;
  as::server::ObjectDescription ***v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  const as::server::ObjectDescription **v35;
  const as::server::ObjectDescription **j;
  as::server::ObjectDescription *v37;
  const as::server::ObjectDescription *v38;
  unint64_t v39;
  as::server::ObjectDescription **v40;
  _QWORD *v41;
  as::server::ObjectDescription **v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  as::server::ObjectDescription **v48;
  char *v49;
  as::server::ObjectDescription *v50;
  __int128 v51;
  char *v52;
  _QWORD *v53;
  as::server::ObjectDescription ***v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  const as::server::ObjectDescription **v58;
  const as::server::ObjectDescription **k;
  as::server::ObjectDescription *v60;
  const as::server::ObjectDescription *v61;
  unint64_t v62;
  as::server::ObjectDescription **v63;
  _QWORD *v64;
  as::server::ObjectDescription **v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char *v70;
  as::server::ObjectDescription **v71;
  char *v72;
  as::server::ObjectDescription *v73;
  __int128 v74;
  char *v75;
  _QWORD *v76;
  uint64_t **v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  const as::server::ChangedObject **v81;
  const as::server::ChangedObject **m;
  uint64_t v83;
  const as::server::ChangedObject *v84;
  unint64_t v85;
  uint64_t *v86;
  _QWORD *v87;
  uint64_t *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  char *v93;
  uint64_t *v94;
  char *v95;
  uint64_t v96;
  __int128 v97;
  char *v98;
  uint64_t v100;
  __int128 v101;
  char *v102;
  char *v103;

  v3 = (const as::server::ObjectDescription *)*((_QWORD *)a2 + 16);
  if (v3)
  {
    v4 = (as::server::ObjectDescription *)as::server::ChangedObject::mutableObjectDescription(this);
    as::server::ObjectDescription::copy_from(v4, v3);
  }
  if (this != a2)
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 8, *((caulk::xstring **)a2 + 1), *((caulk::xstring **)a2 + 2), (uint64_t)(*((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1)) >> 4);
  v5 = (_QWORD *)*((_QWORD *)this + 4);
  v7 = (_QWORD *)*((_QWORD *)this + 5);
  v6 = (uint64_t **)((char *)this + 32);
  while (v7 != v5)
  {
    v9 = *--v7;
    v8 = v9;
    *v7 = 0;
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  *((_QWORD *)this + 5) = v5;
  v10 = (uint64_t *)*((_QWORD *)a2 + 4);
  for (i = (uint64_t *)*((_QWORD *)a2 + 5); v10 != i; ++v10)
  {
    v12 = operator new();
    v13 = v12;
    v14 = *v10;
    *(_QWORD *)v12 = &off_24BFE4278;
    *(_DWORD *)(v12 + 8) = *(_DWORD *)(v14 + 8);
    v15 = *(_QWORD *)(v14 + 12);
    *(_DWORD *)(v12 + 20) = *(_DWORD *)(v14 + 20);
    *(_QWORD *)(v12 + 12) = v15;
    v17 = (uint64_t *)*((_QWORD *)this + 5);
    v16 = *((_QWORD *)this + 6);
    if ((unint64_t)v17 >= v16)
    {
      v19 = *v6;
      v20 = v17 - *v6;
      v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v22 = v16 - (_QWORD)v19;
      if (v22 >> 2 > v21)
        v21 = v22 >> 2;
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
        v23 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v23 = v21;
      v103 = (char *)this + 48;
      if (v23)
      {
        v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 48, v23);
        v19 = (uint64_t *)*((_QWORD *)this + 4);
        v17 = (uint64_t *)*((_QWORD *)this + 5);
      }
      else
      {
        v24 = 0;
      }
      v25 = (uint64_t *)&v24[8 * v20];
      v26 = &v24[8 * v23];
      v102 = v26;
      *v25 = v13;
      *((_QWORD *)&v101 + 1) = v25 + 1;
      if (v17 == v19)
      {
        v18 = v25 + 1;
      }
      else
      {
        do
        {
          v27 = *--v17;
          *v17 = 0;
          *--v25 = v27;
        }
        while (v17 != v19);
        v18 = (_QWORD *)*((_QWORD *)&v101 + 1);
        v26 = v102;
      }
      v28 = *((_OWORD *)this + 2);
      *((_QWORD *)this + 4) = v25;
      *((_QWORD *)this + 5) = v18;
      v101 = v28;
      v29 = (char *)*((_QWORD *)this + 6);
      *((_QWORD *)this + 6) = v26;
      v102 = v29;
      v100 = v28;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v100);
    }
    else
    {
      *v17 = v12;
      v18 = v17 + 1;
    }
    *((_QWORD *)this + 5) = v18;
  }
  v30 = (_QWORD *)*((_QWORD *)this + 7);
  v32 = (_QWORD *)*((_QWORD *)this + 8);
  v31 = (as::server::ObjectDescription ***)((char *)this + 56);
  while (v32 != v30)
  {
    v34 = *--v32;
    v33 = v34;
    *v32 = 0;
    if (v34)
      (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
  }
  *((_QWORD *)this + 8) = v30;
  v35 = (const as::server::ObjectDescription **)*((_QWORD *)a2 + 7);
  for (j = (const as::server::ObjectDescription **)*((_QWORD *)a2 + 8); v35 != j; ++v35)
  {
    v37 = (as::server::ObjectDescription *)operator new();
    v38 = *v35;
    *(_QWORD *)v37 = &off_24BFE4128;
    *((_OWORD *)v37 + 1) = 0u;
    *((_OWORD *)v37 + 2) = 0u;
    *((_OWORD *)v37 + 3) = 0u;
    *((_OWORD *)v37 + 4) = 0u;
    *((_OWORD *)v37 + 5) = 0u;
    as::server::ObjectDescription::copy_from(v37, v38);
    v40 = (as::server::ObjectDescription **)*((_QWORD *)this + 8);
    v39 = *((_QWORD *)this + 9);
    if ((unint64_t)v40 >= v39)
    {
      v42 = *v31;
      v43 = v40 - *v31;
      v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61)
LABEL_94:
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v45 = v39 - (_QWORD)v42;
      if (v45 >> 2 > v44)
        v44 = v45 >> 2;
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
        v46 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v46 = v44;
      v103 = (char *)this + 72;
      if (v46)
      {
        v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 72, v46);
        v42 = (as::server::ObjectDescription **)*((_QWORD *)this + 7);
        v40 = (as::server::ObjectDescription **)*((_QWORD *)this + 8);
      }
      else
      {
        v47 = 0;
      }
      v48 = (as::server::ObjectDescription **)&v47[8 * v43];
      v49 = &v47[8 * v46];
      v102 = v49;
      *v48 = v37;
      *((_QWORD *)&v101 + 1) = v48 + 1;
      if (v40 == v42)
      {
        v41 = v48 + 1;
      }
      else
      {
        do
        {
          v50 = *--v40;
          *v40 = 0;
          *--v48 = v50;
        }
        while (v40 != v42);
        v41 = (_QWORD *)*((_QWORD *)&v101 + 1);
        v49 = v102;
      }
      v51 = *(_OWORD *)((char *)this + 56);
      *((_QWORD *)this + 7) = v48;
      *((_QWORD *)this + 8) = v41;
      v101 = v51;
      v52 = (char *)*((_QWORD *)this + 9);
      *((_QWORD *)this + 9) = v49;
      v102 = v52;
      v100 = v51;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v100);
    }
    else
    {
      *v40 = v37;
      v41 = v40 + 1;
    }
    *((_QWORD *)this + 8) = v41;
  }
  v53 = (_QWORD *)*((_QWORD *)this + 10);
  v55 = (_QWORD *)*((_QWORD *)this + 11);
  v54 = (as::server::ObjectDescription ***)((char *)this + 80);
  while (v55 != v53)
  {
    v57 = *--v55;
    v56 = v57;
    *v55 = 0;
    if (v57)
      (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
  }
  *((_QWORD *)this + 11) = v53;
  v58 = (const as::server::ObjectDescription **)*((_QWORD *)a2 + 10);
  for (k = (const as::server::ObjectDescription **)*((_QWORD *)a2 + 11); v58 != k; ++v58)
  {
    v60 = (as::server::ObjectDescription *)operator new();
    v61 = *v58;
    *(_QWORD *)v60 = &off_24BFE4128;
    *((_OWORD *)v60 + 1) = 0u;
    *((_OWORD *)v60 + 2) = 0u;
    *((_OWORD *)v60 + 3) = 0u;
    *((_OWORD *)v60 + 4) = 0u;
    *((_OWORD *)v60 + 5) = 0u;
    as::server::ObjectDescription::copy_from(v60, v61);
    v63 = (as::server::ObjectDescription **)*((_QWORD *)this + 11);
    v62 = *((_QWORD *)this + 12);
    if ((unint64_t)v63 >= v62)
    {
      v65 = *v54;
      v66 = v63 - *v54;
      v67 = v66 + 1;
      if ((unint64_t)(v66 + 1) >> 61)
        goto LABEL_94;
      v68 = v62 - (_QWORD)v65;
      if (v68 >> 2 > v67)
        v67 = v68 >> 2;
      if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8)
        v69 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v69 = v67;
      v103 = (char *)this + 96;
      if (v69)
      {
        v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 96, v69);
        v65 = (as::server::ObjectDescription **)*((_QWORD *)this + 10);
        v63 = (as::server::ObjectDescription **)*((_QWORD *)this + 11);
      }
      else
      {
        v70 = 0;
      }
      v71 = (as::server::ObjectDescription **)&v70[8 * v66];
      v72 = &v70[8 * v69];
      v102 = v72;
      *v71 = v60;
      *((_QWORD *)&v101 + 1) = v71 + 1;
      if (v63 == v65)
      {
        v64 = v71 + 1;
      }
      else
      {
        do
        {
          v73 = *--v63;
          *v63 = 0;
          *--v71 = v73;
        }
        while (v63 != v65);
        v64 = (_QWORD *)*((_QWORD *)&v101 + 1);
        v72 = v102;
      }
      v74 = *((_OWORD *)this + 5);
      *((_QWORD *)this + 10) = v71;
      *((_QWORD *)this + 11) = v64;
      v101 = v74;
      v75 = (char *)*((_QWORD *)this + 12);
      *((_QWORD *)this + 12) = v72;
      v102 = v75;
      v100 = v74;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v100);
    }
    else
    {
      *v63 = v60;
      v64 = v63 + 1;
    }
    *((_QWORD *)this + 11) = v64;
  }
  v76 = (_QWORD *)*((_QWORD *)this + 13);
  v78 = (_QWORD *)*((_QWORD *)this + 14);
  v77 = (uint64_t **)((char *)this + 104);
  while (v78 != v76)
  {
    v80 = *--v78;
    v79 = v80;
    *v78 = 0;
    if (v80)
      (*(void (**)(uint64_t))(*(_QWORD *)v79 + 8))(v79);
  }
  *((_QWORD *)this + 14) = v76;
  v81 = (const as::server::ChangedObject **)*((_QWORD *)a2 + 13);
  for (m = (const as::server::ChangedObject **)*((_QWORD *)a2 + 14); v81 != m; ++v81)
  {
    v83 = operator new();
    v84 = *v81;
    *(_QWORD *)v83 = &off_24BFE3EF8;
    *(_OWORD *)(v83 + 8) = 0u;
    *(_OWORD *)(v83 + 24) = 0u;
    *(_OWORD *)(v83 + 40) = 0u;
    *(_OWORD *)(v83 + 56) = 0u;
    *(_OWORD *)(v83 + 72) = 0u;
    *(_OWORD *)(v83 + 88) = 0u;
    *(_OWORD *)(v83 + 104) = 0u;
    *(_OWORD *)(v83 + 120) = 0u;
    as::server::ChangedObject::copy_from((as::server::ChangedObject *)v83, v84);
    v86 = (uint64_t *)*((_QWORD *)this + 14);
    v85 = *((_QWORD *)this + 15);
    if ((unint64_t)v86 >= v85)
    {
      v88 = *v77;
      v89 = v86 - *v77;
      v90 = v89 + 1;
      if ((unint64_t)(v89 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v91 = v85 - (_QWORD)v88;
      if (v91 >> 2 > v90)
        v90 = v91 >> 2;
      if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFF8)
        v92 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v92 = v90;
      v103 = (char *)this + 120;
      if (v92)
      {
        v93 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 120, v92);
        v88 = (uint64_t *)*((_QWORD *)this + 13);
        v86 = (uint64_t *)*((_QWORD *)this + 14);
      }
      else
      {
        v93 = 0;
      }
      v94 = (uint64_t *)&v93[8 * v89];
      v95 = &v93[8 * v92];
      v102 = v95;
      *v94 = v83;
      *((_QWORD *)&v101 + 1) = v94 + 1;
      if (v86 == v88)
      {
        v87 = v94 + 1;
      }
      else
      {
        do
        {
          v96 = *--v86;
          *v86 = 0;
          *--v94 = v96;
        }
        while (v86 != v88);
        v87 = (_QWORD *)*((_QWORD *)&v101 + 1);
        v95 = v102;
      }
      v97 = *(_OWORD *)((char *)this + 104);
      *((_QWORD *)this + 13) = v94;
      *((_QWORD *)this + 14) = v87;
      v101 = v97;
      v98 = (char *)*((_QWORD *)this + 15);
      *((_QWORD *)this + 15) = v95;
      v102 = v98;
      v100 = v97;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v100);
    }
    else
    {
      *v86 = v83;
      v87 = v86 + 1;
    }
    *((_QWORD *)this + 14) = v87;
  }
}

uint64_t as::server::ChangedObject::objectDescription(as::server::ChangedObject *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  if (!result)
    return as::server::ObjectDescription::default_instance(0);
  return result;
}

uint64_t as::server::ChangedObject::mutableObjectDescription(as::server::ChangedObject *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 16);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE4128;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 92) = 0u;
    v3 = *((_QWORD *)this + 16);
    *((_QWORD *)this + 16) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::ChangedObject::ChangedObject(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)a1 = &off_24BFE3EF8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  as::server::ChangedObject::move_from((_QWORD *)a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3EF8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  as::server::ChangedObject::move_from((_QWORD *)a1, a2);
  return a1;
}

_QWORD *as::server::ChangedObject::move_from(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v2 = result[16];
  result[16] = a2[16];
  a2[16] = v2;
  v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  v6 = result[4];
  result[4] = a2[4];
  a2[4] = v6;
  v7 = result[5];
  result[5] = a2[5];
  a2[5] = v7;
  v8 = result[6];
  result[6] = a2[6];
  a2[6] = v8;
  v9 = result[7];
  result[7] = a2[7];
  a2[7] = v9;
  v10 = result[8];
  result[8] = a2[8];
  a2[8] = v10;
  v11 = result[9];
  result[9] = a2[9];
  a2[9] = v11;
  v12 = result[10];
  result[10] = a2[10];
  a2[10] = v12;
  v13 = result[11];
  result[11] = a2[11];
  a2[11] = v13;
  v14 = result[12];
  result[12] = a2[12];
  a2[12] = v14;
  v15 = result[13];
  result[13] = a2[13];
  a2[13] = v15;
  v16 = result[14];
  result[14] = a2[14];
  a2[14] = v16;
  v17 = result[15];
  result[15] = a2[15];
  a2[15] = v17;
  return result;
}

_QWORD *as::server::ChangedObject::operator=(_QWORD *a1, _QWORD *a2)
{
  as::server::ChangedObject::move_from(a1, a2);
  return a1;
}

uint64_t as::server::ChangedObject::clear(as::server::ChangedObject *this)
{
  uint64_t v2;
  uint64_t result;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;

  v2 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  result = std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 8, *((caulk::xstring **)this + 1));
  v4 = (_QWORD *)*((_QWORD *)this + 4);
  v5 = (_QWORD *)*((_QWORD *)this + 5);
  while (v5 != v4)
  {
    v6 = *--v5;
    result = v6;
    *v5 = 0;
    if (v6)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 5) = v4;
  v7 = (_QWORD *)*((_QWORD *)this + 7);
  v8 = (_QWORD *)*((_QWORD *)this + 8);
  while (v8 != v7)
  {
    v9 = *--v8;
    result = v9;
    *v8 = 0;
    if (v9)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 8) = v7;
  v10 = (_QWORD *)*((_QWORD *)this + 10);
  v11 = (_QWORD *)*((_QWORD *)this + 11);
  while (v11 != v10)
  {
    v12 = *--v11;
    result = v12;
    *v11 = 0;
    if (v12)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 11) = v10;
  v13 = (_QWORD *)*((_QWORD *)this + 13);
  v14 = (_QWORD *)*((_QWORD *)this + 14);
  while (v14 != v13)
  {
    v15 = *--v14;
    result = v15;
    *v14 = 0;
    if (v15)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 14) = v13;
  return result;
}

uint64_t as::server::ChangedObject::isInitialized(as::server::ChangedObject *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  BOOL v12;

  v1 = *((_QWORD *)this + 16);
  if (!v1 || (~*(_DWORD *)(v1 + 8) & 3) != 0)
    return 0;
  v2 = *((_QWORD *)this + 4);
  v3 = *((_QWORD *)this + 5);
  if (v2 != v3)
  {
    while ((~*(_DWORD *)(*(_QWORD *)v2 + 8) & 7) == 0)
    {
      v2 += 8;
      if (v2 == v3)
        goto LABEL_6;
    }
    return 0;
  }
LABEL_6:
  v4 = *((_QWORD *)this + 7);
  v5 = *((_QWORD *)this + 8);
  if (v4 != v5)
  {
    while ((~*(_DWORD *)(*(_QWORD *)v4 + 8) & 3) == 0)
    {
      v4 += 8;
      if (v4 == v5)
        goto LABEL_9;
    }
    return 0;
  }
LABEL_9:
  v6 = *((_QWORD *)this + 10);
  v7 = *((_QWORD *)this + 11);
  if (v6 != v7)
  {
    while ((~*(_DWORD *)(*(_QWORD *)v6 + 8) & 3) == 0)
    {
      v6 += 8;
      if (v6 == v7)
        goto LABEL_12;
    }
    return 0;
  }
LABEL_12:
  v8 = *((_QWORD *)this + 13);
  v9 = *((_QWORD *)this + 14);
  if (v8 == v9)
    return 1;
  v10 = v8 + 8;
  do
  {
    result = as::server::ChangedObject::isInitialized(*(as::server::ChangedObject **)(v10 - 8));
    if ((_DWORD)result)
      v12 = v10 == v9;
    else
      v12 = 1;
    v10 += 8;
  }
  while (!v12);
  return result;
}

BOOL as::server::ChangedObject::readFrom(uint64_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  int64x2_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  char v20;
  unsigned int v21;
  unint64_t v22;
  char v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t *v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  uint64_t *v72;
  char *v73;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  int64x2_t v77;
  char *v78;
  char *v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  int64x2_t v83;
  uint64_t *v84;
  char *v85;
  _QWORD *v86;
  _QWORD *v87;
  uint64_t v88;
  int64x2_t v89;
  char *v90;
  uint64_t *v91;
  char *v92;
  _QWORD *v93;
  _QWORD *v94;
  uint64_t v95;
  int64x2_t v96;
  char *v97;
  char *v98;
  char *v99;
  char *v100;
  uint64_t v102;
  uint64_t v103;
  int64x2_t *v104;
  int64x2_t *v105;
  int64x2_t *v106;
  void *__p;
  int64x2_t v108;
  char *v109;
  uint64_t v110;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0)
    return v4 == 0;
  v103 = (uint64_t)(a1 + 15);
  v105 = (int64x2_t *)(a1 + 10);
  v106 = (int64x2_t *)(a1 + 13);
  v102 = (uint64_t)(a1 + 12);
  v104 = (int64x2_t *)(a1 + 7);
  v8 = (uint64_t)(a1 + 9);
  v9 = (int64x2_t *)(a1 + 4);
  v10 = (uint64_t)(a1 + 6);
  v11 = a1 + 1;
  v12 = (uint64_t)(a1 + 3);
  while (2)
  {
    v13 = *a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
    {
      v20 = 0;
      v21 = 0;
      v16 = 0;
      if (v2 > v3)
        v3 = v2;
      while (v3 != v2)
      {
        v22 = v2 + 1;
        v23 = *(_BYTE *)(v13 + v2);
        a2[1] = v22;
        v16 |= (unint64_t)(v23 & 0x7F) << v20;
        if ((v23 & 0x80) == 0)
          goto LABEL_21;
        v20 += 7;
        v2 = v22;
        if (v21++ >= 9)
        {
LABEL_20:
          v16 = 0;
          goto LABEL_21;
        }
      }
      v4 = 1;
      *((_BYTE *)a2 + 24) = 1;
      return v4 == 0;
    }
    v14 = 0;
    v15 = 0;
    v16 = 0;
    while (1)
    {
      v17 = v2 + 1;
      a2[1] = v2 + 1;
      v18 = *(_BYTE *)(v13 + v2);
      v16 |= (unint64_t)(v18 & 0x7F) << v14;
      if ((v18 & 0x80) == 0)
        break;
      v14 += 7;
      v2 = v17;
      if (v15++ > 8)
        goto LABEL_20;
    }
LABEL_21:
    if ((v16 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v16 >> 3))
    {
      case 1u:
        v25 = operator new();
        *(_QWORD *)v25 = &off_24BFE4128;
        *(_DWORD *)(v25 + 8) = 0;
        *(_OWORD *)(v25 + 16) = 0u;
        *(_OWORD *)(v25 + 32) = 0u;
        *(_OWORD *)(v25 + 48) = 0u;
        *(_OWORD *)(v25 + 64) = 0u;
        *(_OWORD *)(v25 + 80) = 0u;
        *(_OWORD *)(v25 + 92) = 0u;
        v26 = a1[16];
        a1[16] = v25;
        if (v26)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
          v25 = a1[16];
        }
        if (PB::Reader::placeMark())
          goto LABEL_110;
        return 0;
      case 2u:
        v41 = (_QWORD *)a1[2];
        v40 = a1[3];
        if ((unint64_t)v41 >= v40)
        {
          v62 = ((uint64_t)v41 - *v11) >> 4;
          v63 = v62 + 1;
          if ((unint64_t)(v62 + 1) >> 60)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v64 = v40 - *v11;
          if (v64 >> 3 > v63)
            v63 = v64 >> 3;
          if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF0)
            v65 = 0xFFFFFFFFFFFFFFFLL;
          else
            v65 = v63;
          v110 = v12;
          if (v65)
            v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v12, v65);
          else
            v66 = 0;
          v90 = &v66[16 * v62];
          __p = v66;
          v108.i64[0] = (uint64_t)v90;
          v109 = &v66[16 * v65];
          *(_QWORD *)v90 = 0;
          *((_QWORD *)v90 + 1) = 0;
          v108.i64[1] = (uint64_t)(v90 + 16);
          std::vector<caulk::xstring>::__swap_out_circular_buffer(v11, &__p);
          v42 = (_QWORD *)a1[2];
          std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v41 = 0;
          v41[1] = 0;
          v42 = v41 + 2;
          a1[2] = (uint64_t)(v41 + 2);
        }
        a1[2] = (uint64_t)v42;
        __p = 0;
        v108 = 0uLL;
        PB::Reader::read();
        caulk::xstring::assign();
        if (v108.i8[15] < 0)
          operator delete(__p);
        goto LABEL_112;
      case 3u:
        v32 = (_QWORD *)operator new();
        v33 = v32;
        v32[1] = 0;
        v32[2] = 0;
        *v32 = &off_24BFE4278;
        v35 = (_QWORD *)a1[5];
        v34 = a1[6];
        if ((unint64_t)v35 >= v34)
        {
          v52 = ((uint64_t)v35 - v9->i64[0]) >> 3;
          if ((unint64_t)(v52 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v53 = v34 - v9->i64[0];
          v54 = v53 >> 2;
          if (v53 >> 2 <= (unint64_t)(v52 + 1))
            v54 = v52 + 1;
          if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
            v55 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v55 = v54;
          v110 = v10;
          if (v55)
            v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v10, v55);
          else
            v56 = 0;
          v78 = &v56[8 * v52];
          v79 = &v56[8 * v55];
          v109 = v79;
          *(_QWORD *)v78 = v33;
          v31 = v78 + 8;
          v108.i64[1] = (uint64_t)(v78 + 8);
          v81 = (_QWORD *)a1[4];
          v80 = (_QWORD *)a1[5];
          if (v80 == v81)
          {
            v83 = vdupq_n_s64((unint64_t)v80);
          }
          else
          {
            do
            {
              v82 = *--v80;
              *v80 = 0;
              *((_QWORD *)v78 - 1) = v82;
              v78 -= 8;
            }
            while (v80 != v81);
            v83 = *v9;
            v31 = (_QWORD *)v108.i64[1];
            v79 = v109;
          }
          a1[4] = (uint64_t)v78;
          a1[5] = (uint64_t)v31;
          v108 = v83;
          v98 = (char *)a1[6];
          a1[6] = (uint64_t)v79;
          v109 = v98;
          __p = (void *)v83.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v35 = v32;
          v31 = v35 + 1;
        }
        a1[5] = (uint64_t)v31;
        goto LABEL_109;
      case 4u:
        v36 = operator new();
        v37 = v36;
        *(_QWORD *)v36 = &off_24BFE4128;
        *(_DWORD *)(v36 + 8) = 0;
        *(_OWORD *)(v36 + 16) = 0u;
        *(_OWORD *)(v36 + 32) = 0u;
        *(_OWORD *)(v36 + 48) = 0u;
        *(_OWORD *)(v36 + 64) = 0u;
        *(_OWORD *)(v36 + 80) = 0u;
        *(_OWORD *)(v36 + 92) = 0u;
        v39 = (uint64_t *)a1[8];
        v38 = a1[9];
        if ((unint64_t)v39 >= v38)
        {
          v57 = ((uint64_t)v39 - v104->i64[0]) >> 3;
          if ((unint64_t)(v57 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v58 = v38 - v104->i64[0];
          v59 = v58 >> 2;
          if (v58 >> 2 <= (unint64_t)(v57 + 1))
            v59 = v57 + 1;
          if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8)
            v60 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v60 = v59;
          v110 = v8;
          if (v60)
            v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v8, v60);
          else
            v61 = 0;
          v84 = (uint64_t *)&v61[8 * v57];
          v85 = &v61[8 * v60];
          v109 = v85;
          *v84 = v37;
          v31 = v84 + 1;
          v108.i64[1] = (uint64_t)(v84 + 1);
          v87 = (_QWORD *)a1[7];
          v86 = (_QWORD *)a1[8];
          if (v86 == v87)
          {
            v89 = vdupq_n_s64((unint64_t)v86);
          }
          else
          {
            do
            {
              v88 = *--v86;
              *v86 = 0;
              *--v84 = v88;
            }
            while (v86 != v87);
            v89 = *v104;
            v31 = (_QWORD *)v108.i64[1];
            v85 = v109;
          }
          a1[7] = (uint64_t)v84;
          a1[8] = (uint64_t)v31;
          v108 = v89;
          v99 = (char *)a1[9];
          a1[9] = (uint64_t)v85;
          v109 = v99;
          __p = (void *)v89.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v39 = v36;
          v31 = v39 + 1;
        }
        a1[8] = (uint64_t)v31;
        goto LABEL_109;
      case 5u:
        v27 = operator new();
        v28 = v27;
        *(_QWORD *)v27 = &off_24BFE4128;
        *(_DWORD *)(v27 + 8) = 0;
        *(_OWORD *)(v27 + 16) = 0u;
        *(_OWORD *)(v27 + 32) = 0u;
        *(_OWORD *)(v27 + 48) = 0u;
        *(_OWORD *)(v27 + 64) = 0u;
        *(_OWORD *)(v27 + 80) = 0u;
        *(_OWORD *)(v27 + 92) = 0u;
        v30 = (uint64_t *)a1[11];
        v29 = a1[12];
        if ((unint64_t)v30 >= v29)
        {
          v47 = ((uint64_t)v30 - v105->i64[0]) >> 3;
          if ((unint64_t)(v47 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v48 = v29 - v105->i64[0];
          v49 = v48 >> 2;
          if (v48 >> 2 <= (unint64_t)(v47 + 1))
            v49 = v47 + 1;
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
            v50 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v50 = v49;
          v110 = v102;
          if (v50)
            v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v102, v50);
          else
            v51 = 0;
          v72 = (uint64_t *)&v51[8 * v47];
          v73 = &v51[8 * v50];
          v109 = v73;
          *v72 = v28;
          v31 = v72 + 1;
          v108.i64[1] = (uint64_t)(v72 + 1);
          v75 = (_QWORD *)a1[10];
          v74 = (_QWORD *)a1[11];
          if (v74 == v75)
          {
            v77 = vdupq_n_s64((unint64_t)v74);
          }
          else
          {
            do
            {
              v76 = *--v74;
              *v74 = 0;
              *--v72 = v76;
            }
            while (v74 != v75);
            v77 = *v105;
            v31 = (_QWORD *)v108.i64[1];
            v73 = v109;
          }
          a1[10] = (uint64_t)v72;
          a1[11] = (uint64_t)v31;
          v108 = v77;
          v97 = (char *)a1[12];
          a1[12] = (uint64_t)v73;
          v109 = v97;
          __p = (void *)v77.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v30 = v27;
          v31 = v30 + 1;
        }
        a1[11] = (uint64_t)v31;
        goto LABEL_109;
      case 6u:
        v43 = operator new();
        v44 = v43;
        *(_QWORD *)v43 = &off_24BFE3EF8;
        *(_OWORD *)(v43 + 8) = 0u;
        *(_OWORD *)(v43 + 24) = 0u;
        *(_OWORD *)(v43 + 40) = 0u;
        *(_OWORD *)(v43 + 56) = 0u;
        *(_OWORD *)(v43 + 72) = 0u;
        *(_OWORD *)(v43 + 88) = 0u;
        *(_OWORD *)(v43 + 104) = 0u;
        *(_OWORD *)(v43 + 120) = 0u;
        v46 = (uint64_t *)a1[14];
        v45 = a1[15];
        if ((unint64_t)v46 >= v45)
        {
          v67 = ((uint64_t)v46 - v106->i64[0]) >> 3;
          if ((unint64_t)(v67 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v68 = v45 - v106->i64[0];
          v69 = v68 >> 2;
          if (v68 >> 2 <= (unint64_t)(v67 + 1))
            v69 = v67 + 1;
          if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8)
            v70 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v70 = v69;
          v110 = v103;
          if (v70)
            v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v103, v70);
          else
            v71 = 0;
          v91 = (uint64_t *)&v71[8 * v67];
          v92 = &v71[8 * v70];
          v109 = v92;
          *v91 = v44;
          v31 = v91 + 1;
          v108.i64[1] = (uint64_t)(v91 + 1);
          v94 = (_QWORD *)a1[13];
          v93 = (_QWORD *)a1[14];
          if (v93 == v94)
          {
            v96 = vdupq_n_s64((unint64_t)v93);
          }
          else
          {
            do
            {
              v95 = *--v93;
              *v93 = 0;
              *--v91 = v95;
            }
            while (v93 != v94);
            v96 = *v106;
            v31 = (_QWORD *)v108.i64[1];
            v92 = v109;
          }
          a1[13] = (uint64_t)v91;
          a1[14] = (uint64_t)v31;
          v108 = v96;
          v100 = (char *)a1[15];
          a1[15] = (uint64_t)v92;
          v109 = v100;
          __p = (void *)v96.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
        }
        else
        {
          *v46 = v43;
          v31 = v46 + 1;
        }
        a1[14] = (uint64_t)v31;
LABEL_109:
        v25 = *(v31 - 1);
        if ((PB::Reader::placeMark() & 1) == 0)
          return 0;
LABEL_110:
        if (((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v25 + 16))(v25, a2) & 1) != 0)
        {
          PB::Reader::recallMark();
LABEL_112:
          v2 = a2[1];
          v3 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v2 >= v3 || *((_BYTE *)a2 + 24))
            return v4 == 0;
          continue;
        }
        return 0;
      default:
        goto LABEL_112;
    }
  }
}

void sub_20681ADF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  _Unwind_Resume(a1);
}

void as::server::ChangedObject::writeTo(as::server::ChangedObject *this, PB::Writer *a2)
{
  const PB::Base *v4;
  caulk::xstring *v5;
  caulk::xstring *v6;
  char *v7;
  const PB::Base **v8;
  const PB::Base **v9;
  const PB::Base *v10;
  const PB::Base **v11;
  const PB::Base **v12;
  const PB::Base *v13;
  const PB::Base **v14;
  const PB::Base **v15;
  const PB::Base *v16;
  const PB::Base **v17;
  const PB::Base **v18;
  const PB::Base *v19;
  void *__p;
  char v21;

  v4 = (const PB::Base *)*((_QWORD *)this + 16);
  if (v4)
    PB::Writer::writeSubmessage(a2, v4);
  v5 = (caulk::xstring *)*((_QWORD *)this + 1);
  v6 = (caulk::xstring *)*((_QWORD *)this + 2);
  while (v5 != v6)
  {
    v7 = (char *)caulk::xstring::c_str(v5);
    std::string::basic_string[abi:ne180100]<0>(&__p, v7);
    PB::Writer::write();
    if (v21 < 0)
      operator delete(__p);
    v5 = (caulk::xstring *)((char *)v5 + 16);
  }
  v8 = (const PB::Base **)*((_QWORD *)this + 4);
  v9 = (const PB::Base **)*((_QWORD *)this + 5);
  while (v8 != v9)
  {
    v10 = *v8++;
    PB::Writer::writeSubmessage(a2, v10);
  }
  v11 = (const PB::Base **)*((_QWORD *)this + 7);
  v12 = (const PB::Base **)*((_QWORD *)this + 8);
  while (v11 != v12)
  {
    v13 = *v11++;
    PB::Writer::writeSubmessage(a2, v13);
  }
  v14 = (const PB::Base **)*((_QWORD *)this + 10);
  v15 = (const PB::Base **)*((_QWORD *)this + 11);
  while (v14 != v15)
  {
    v16 = *v14++;
    PB::Writer::writeSubmessage(a2, v16);
  }
  v18 = (const PB::Base **)*((_QWORD *)this + 13);
  v17 = (const PB::Base **)*((_QWORD *)this + 14);
  while (v18 != v17)
  {
    v19 = *v18++;
    PB::Writer::writeSubmessage(a2, v19);
  }
}

void sub_20681AF60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::ChangedObject::formatText(as::server::ChangedObject *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  caulk::xstring *v6;
  caulk::xstring *i;
  char *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  void *__p;
  char v23;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 16);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "objectDescription");
  v6 = (caulk::xstring *)*((_QWORD *)this + 1);
  for (i = (caulk::xstring *)*((_QWORD *)this + 2); v6 != i; v6 = (caulk::xstring *)((char *)v6 + 16))
  {
    v8 = (char *)caulk::xstring::c_str(v6);
    std::string::basic_string[abi:ne180100]<0>(&__p, v8);
    PB::TextFormatter::format();
    if (v23 < 0)
      operator delete(__p);
  }
  v9 = (uint64_t *)*((_QWORD *)this + 4);
  v10 = (uint64_t *)*((_QWORD *)this + 5);
  while (v9 != v10)
  {
    v11 = *v9++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v11 + 32))(v11, a2, "changedCustomProperties");
  }
  v12 = (uint64_t *)*((_QWORD *)this + 7);
  v13 = (uint64_t *)*((_QWORD *)this + 8);
  while (v12 != v13)
  {
    v14 = *v12++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v14 + 32))(v14, a2, "createdChildren");
  }
  v15 = (uint64_t *)*((_QWORD *)this + 10);
  v16 = (uint64_t *)*((_QWORD *)this + 11);
  while (v15 != v16)
  {
    v17 = *v15++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v17 + 32))(v17, a2, "destroyedChildren");
  }
  v18 = (uint64_t *)*((_QWORD *)this + 13);
  v19 = (uint64_t *)*((_QWORD *)this + 14);
  while (v18 != v19)
  {
    v20 = *v18++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v20 + 32))(v20, a2, "changedChildren");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_20681B10C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::ChangedObject::operator==(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v4 = a1[16];
  v5 = a2[16];
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
  }
  else if (!as::server::ObjectDescription::operator==(v4, v5))
  {
    return 0;
  }
  v8 = a1[1];
  v7 = a1[2];
  v9 = (v7 - v8) >> 4;
  if (v9 != (uint64_t)(a2[2] - a2[1]) >> 4)
    return 0;
  if (v7 != v8)
  {
    v10 = 0;
    if (v9 <= 1)
      v11 = 1;
    else
      v11 = (v7 - v8) >> 4;
    while (!caulk::xstring::compare((caulk::xstring *)(a1[1] + v10), (const caulk::xstring *)(a2[1] + v10)))
    {
      v10 += 16;
      if (!--v11)
        goto LABEL_16;
    }
    return 0;
  }
LABEL_16:
  v13 = (uint64_t *)a1[4];
  v12 = (uint64_t *)a1[5];
  v14 = v12 - v13;
  v15 = (uint64_t *)a2[4];
  if (v14 != (uint64_t)(a2[5] - (_QWORD)v15) >> 3)
    return 0;
  if (v12 != v13)
  {
    if (v14 <= 1)
      v16 = 1;
    else
      v16 = v12 - v13;
    do
    {
      v17 = *v13;
      v18 = *v15;
      if (*v13)
        v19 = v18 == 0;
      else
        v19 = 1;
      if (v19)
      {
        if (v17 | v18)
          return 0;
      }
      else if (!as::server::CustomPropertyAddress::operator==(v17, v18))
      {
        return 0;
      }
      ++v13;
      ++v15;
      --v16;
    }
    while (v16);
  }
  v21 = a1[7];
  v20 = a1[8];
  v22 = (v20 - v21) >> 3;
  if (v22 != (uint64_t)(a2[8] - a2[7]) >> 3)
    return 0;
  if (v20 != v21)
  {
    v23 = 0;
    if (v22 <= 1)
      v24 = 1;
    else
      v24 = (v20 - v21) >> 3;
    do
    {
      v25 = *(_QWORD *)(a1[7] + 8 * v23);
      v26 = *(_QWORD *)(a2[7] + 8 * v23);
      if (v25)
        v27 = v26 == 0;
      else
        v27 = 1;
      if (v27)
      {
        if (v25 | v26)
          return 0;
      }
      else if (!as::server::ObjectDescription::operator==(v25, v26))
      {
        return 0;
      }
      ++v23;
    }
    while (v24 != v23);
  }
  v29 = a1[10];
  v28 = a1[11];
  v30 = (v28 - v29) >> 3;
  if (v30 != (uint64_t)(a2[11] - a2[10]) >> 3)
    return 0;
  if (v28 != v29)
  {
    v31 = 0;
    if (v30 <= 1)
      v32 = 1;
    else
      v32 = (v28 - v29) >> 3;
    do
    {
      v33 = *(_QWORD *)(a1[10] + 8 * v31);
      v34 = *(_QWORD *)(a2[10] + 8 * v31);
      if (v33)
        v35 = v34 == 0;
      else
        v35 = 1;
      if (v35)
      {
        if (v33 | v34)
          return 0;
      }
      else if (!as::server::ObjectDescription::operator==(v33, v34))
      {
        return 0;
      }
      ++v31;
    }
    while (v32 != v31);
  }
  v37 = a1[13];
  v36 = a1[14];
  v38 = (v36 - v37) >> 3;
  if (v38 != (uint64_t)(a2[14] - a2[13]) >> 3)
    return 0;
  if (v36 != v37)
  {
    v39 = 0;
    v40 = 0;
    if (v38 <= 1)
      v41 = 1;
    else
      v41 = (v36 - v37) >> 3;
    while (1)
    {
      v42 = *(_QWORD *)(a2[13] + 8 * v40);
      if (*(_QWORD *)(a1[13] + 8 * v40))
      {
        if (!v42 || !as::server::ChangedObject::operator==())
          return v39;
      }
      else if (v42)
      {
        return v39;
      }
      v39 = ++v40 >= v38;
      if (v41 == v40)
        return v39;
    }
  }
  return 1;
}

uint64_t as::server::ChangedObject::clearObjectDescription(as::server::ChangedObject *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *as::server::ChangedObject::addChangedCustomProperties(as::server::ChangedObject *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  _QWORD *result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 6);
  v2 = (char *)this + 48;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 4);
      v5 = (_QWORD *)*((_QWORD *)this + 5);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 2);
    *((_QWORD *)this + 4) = v13;
    *((_QWORD *)this + 5) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 5) = v6;
  result = (_QWORD *)operator new();
  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE4278;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return (_QWORD *)*(v6 - 1);
  }
  return result;
}

uint64_t as::server::ChangedObject::addCreatedChildren(as::server::ChangedObject *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 9);
  v2 = (char *)this + 72;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 7);
      v5 = (_QWORD *)*((_QWORD *)this + 8);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 56);
    *((_QWORD *)this + 7) = v13;
    *((_QWORD *)this + 8) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 9);
    *((_QWORD *)this + 9) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 8) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4128;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 92) = 0u;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::ChangedObject::addDestroyedChildren(as::server::ChangedObject *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 12);
  v2 = (char *)this + 96;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 10);
      v5 = (_QWORD *)*((_QWORD *)this + 11);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 5);
    *((_QWORD *)this + 10) = v13;
    *((_QWORD *)this + 11) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 12);
    *((_QWORD *)this + 12) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 11) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE4128;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 92) = 0u;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::ChangedObject::addChangedChildren(as::server::ChangedObject *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 15);
  v2 = (char *)this + 120;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 13);
      v5 = (_QWORD *)*((_QWORD *)this + 14);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 104);
    *((_QWORD *)this + 13) = v13;
    *((_QWORD *)this + 14) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 15);
    *((_QWORD *)this + 15) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 14) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3EF8;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_OWORD *)(result + 104) = 0u;
  *(_OWORD *)(result + 120) = 0u;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

as::server::VirtualPort *as::server::VirtualPort::VirtualPort(as::server::VirtualPort *this, const as::server::VirtualPort *a2)
{
  *(_QWORD *)this = &off_24BFE3E18;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::VirtualPort::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3E18;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::VirtualPort::copy_from(this, a2);
  return this;
}

uint64_t as::server::VirtualPort::copy_from(as::server::VirtualPort *this, const as::server::VirtualPort *a2)
{
  __n128 *v4;
  __n128 *v5;
  const as::server::MicrophoneConfiguration *v6;
  as::server::MicrophoneConfiguration *active;
  uint64_t result;

  v4 = (__n128 *)*((_QWORD *)a2 + 4);
  if (v4)
  {
    v5 = (__n128 *)as::server::VirtualPort::mutableHwPortInvariants(this);
    as::server::PortInvariants::copy_from(v5, v4);
  }
  v6 = (const as::server::MicrophoneConfiguration *)*((_QWORD *)a2 + 5);
  if (v6)
  {
    active = (as::server::MicrophoneConfiguration *)as::server::VirtualPort::mutableActiveMicrophoneConfiguration(this);
    as::server::MicrophoneConfiguration::copy_from(active, v6);
  }
  result = caulk::xstring::assign((as::server::VirtualPort *)((char *)this + 16), (const as::server::VirtualPort *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_WORD *)this + 24) = *((_WORD *)a2 + 24);
  return result;
}

uint64_t as::server::VirtualPort::hwPortInvariants(as::server::VirtualPort *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (!result)
    return as::server::PortInvariants::default_instance(0);
  return result;
}

uint64_t as::server::VirtualPort::mutableHwPortInvariants(as::server::VirtualPort *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 4);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3F68;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_QWORD *)(v1 + 64) = 0;
    v3 = *((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::VirtualPort::activeMicrophoneConfiguration(as::server::VirtualPort *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 5);
  if (!result)
    return as::server::MicrophoneConfiguration::default_instance(0);
  return result;
}

uint64_t as::server::VirtualPort::mutableActiveMicrophoneConfiguration(as::server::VirtualPort *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 5);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE42B0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 57) = 0u;
    v3 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

as::server::MicrophoneConfiguration *as::server::MicrophoneConfiguration::operator=(as::server::MicrophoneConfiguration *a1, const as::server::MicrophoneConfiguration *a2)
{
  as::server::MicrophoneConfiguration::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::VirtualPort::VirtualPort(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE3E18;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::VirtualPort::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3E18;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::VirtualPort::move_from(a1, a2);
  return a1;
}

uint64_t as::server::VirtualPort::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _QWORD v7[2];

  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v5;
  v7[0] = 0;
  v7[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)v7);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  return result;
}

uint64_t as::server::VirtualPort::operator=(uint64_t a1, uint64_t a2)
{
  as::server::VirtualPort::move_from(a1, a2);
  return a1;
}

uint64_t as::server::VirtualPort::clear(as::server::VirtualPort *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  result = caulk::xstring::clear((as::server::VirtualPort *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((_WORD *)this + 24) = 0;
  return result;
}

BOOL as::server::VirtualPort::isInitialized(as::server::VirtualPort *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 4);
  return v1 && (~*(_DWORD *)(v1 + 8) & 0x7F) == 0 && (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::VirtualPort::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  int v28;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  while (2)
  {
    v8 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v3 + 1;
        a2[1] = v3 + 1;
        v13 = *(_BYTE *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          goto LABEL_22;
        v9 += 7;
        v3 = v12;
        if (v10++ > 8)
        {
          v11 = 0;
          goto LABEL_22;
        }
      }
    }
    v15 = 0;
    v16 = 0;
    v11 = 0;
    if (v3 <= v2)
      v17 = v2;
    else
      v17 = v3;
    do
    {
      if (v17 == v3)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v18 = v3++;
      v19 = *(_BYTE *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0)
        goto LABEL_21;
      v15 += 7;
    }
    while (v16++ < 9);
    v11 = 0;
LABEL_21:
    v12 = v18 + 1;
LABEL_22:
    if ((v11 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v11 >> 3))
    {
      case 1u:
        v21 = operator new();
        *(_QWORD *)v21 = &off_24BFE3F68;
        *(_DWORD *)(v21 + 8) = 0;
        *(_OWORD *)(v21 + 16) = 0u;
        *(_OWORD *)(v21 + 32) = 0u;
        *(_OWORD *)(v21 + 48) = 0u;
        *(_QWORD *)(v21 + 64) = 0;
        v22 = *(_QWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 32) = v21;
        if (v22)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
          v21 = *(_QWORD *)(a1 + 32);
        }
        goto LABEL_32;
      case 2u:
        if (v12 >= v2)
        {
          v24 = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v23 = *(unsigned __int8 *)(v8 + v12);
          a2[1] = v12 + 1;
          v24 = v23 != 0;
        }
        *(_BYTE *)(a1 + 48) = v24;
        v28 = *(_DWORD *)(a1 + 8) | 1;
        goto LABEL_40;
      case 3u:
        if (v12 >= v2)
        {
          v26 = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v25 = *(unsigned __int8 *)(v8 + v12);
          a2[1] = v12 + 1;
          v26 = v25 != 0;
        }
        *(_BYTE *)(a1 + 49) = v26;
        v28 = *(_DWORD *)(a1 + 8) | 2;
LABEL_40:
        *(_DWORD *)(a1 + 8) = v28;
        goto LABEL_41;
      case 4u:
        v21 = operator new();
        *(_QWORD *)v21 = &off_24BFE42B0;
        *(_DWORD *)(v21 + 8) = 0;
        *(_OWORD *)(v21 + 16) = 0u;
        *(_OWORD *)(v21 + 32) = 0u;
        *(_OWORD *)(v21 + 48) = 0u;
        *(_OWORD *)(v21 + 57) = 0u;
        v27 = *(_QWORD *)(a1 + 40);
        *(_QWORD *)(a1 + 40) = v21;
        if (v27)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
          v21 = *(_QWORD *)(a1 + 40);
        }
LABEL_32:
        if (PB::Reader::placeMark()
          && ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v21 + 16))(v21, a2) & 1) != 0)
        {
          PB::Reader::recallMark();
LABEL_41:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || *((_BYTE *)a2 + 24))
            return v4 == 0;
          continue;
        }
        return 0;
      case 5u:
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 4u;
        goto LABEL_41;
      default:
        goto LABEL_41;
    }
  }
}

void sub_20681C06C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::server::VirtualPort::writeTo(as::server::VirtualPort *this, PB::Writer *a2)
{
  const PB::Base *v4;
  int v5;
  const PB::Base *v6;
  char *v7;
  void *__p;
  char v9;

  v4 = (const PB::Base *)*((_QWORD *)this + 4);
  if (v4)
    PB::Writer::writeSubmessage(a2, v4);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::Writer::write(a2);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::Writer::write(a2);
  v6 = (const PB::Base *)*((_QWORD *)this + 5);
  if (v6)
    PB::Writer::writeSubmessage(a2, v6);
  if ((*((_BYTE *)this + 8) & 4) != 0)
  {
    v7 = (char *)caulk::xstring::c_str((as::server::VirtualPort *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v7);
    PB::Writer::write();
    if (v9 < 0)
      operator delete(__p);
  }
}

void sub_20681C144(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::VirtualPort::formatText(as::server::VirtualPort *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  char *v8;
  void *__p;
  char v11;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 4);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "hwPortInvariants");
  v6 = *((_DWORD *)this + 2);
  if ((v6 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "routable");
    v6 = *((_DWORD *)this + 2);
  }
  if ((v6 & 2) != 0)
    PB::TextFormatter::format(a2, "canSetRoutable");
  v7 = *((_QWORD *)this + 5);
  if (v7)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v7 + 32))(v7, a2, "activeMicrophoneConfiguration");
  if ((*((_BYTE *)this + 8) & 4) != 0)
  {
    v8 = (char *)caulk::xstring::c_str((as::server::VirtualPort *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v8);
    PB::TextFormatter::format();
    if (v11 < 0)
      operator delete(__p);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_20681C254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::VirtualPort::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(unsigned __int16 *)(a1 + 48) != *(unsigned __int16 *)(a2 + 48))
    return 0;
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a2 + 32);
  if (v5)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
  {
    if (v5 | v6)
      return 0;
  }
  else if (!as::server::PortInvariants::operator==(v5, v6))
  {
    return 0;
  }
  v8 = *(_QWORD *)(a1 + 40);
  v9 = *(_QWORD *)(a2 + 40);
  if (v8 && v9)
  {
    if (as::server::MicrophoneConfiguration::operator==(v8, v9))
      return caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
    return 0;
  }
  if (v8 | v9)
    return 0;
  return caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
}

uint64_t as::server::VirtualPort::clearHwPortInvariants(as::server::VirtualPort *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::MicrophoneConfiguration::default_instance(as::server::MicrophoneConfiguration *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE42B0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 57) = 0u;
    as::server::MicrophoneConfiguration::default_instance(void)::gInstance = v3;
  }
  return as::server::MicrophoneConfiguration::default_instance(void)::gInstance;
}

void sub_20681C3C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::MicrophoneConfiguration::MicrophoneConfiguration(as::server::MicrophoneConfiguration *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE42B0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE42B0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

uint64_t as::server::VirtualPort::clearActiveMicrophoneConfiguration(as::server::VirtualPort *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

as::server::MicrophoneConfiguration *as::server::MicrophoneConfiguration::MicrophoneConfiguration(as::server::MicrophoneConfiguration *this, const as::server::MicrophoneConfiguration *a2)
{
  *(_QWORD *)this = &off_24BFE42B0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  as::server::MicrophoneConfiguration::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE42B0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  as::server::MicrophoneConfiguration::copy_from(this, a2);
  return this;
}

__n128 as::server::MicrophoneConfiguration::copy_from(as::server::MicrophoneConfiguration *this, const as::server::MicrophoneConfiguration *a2)
{
  __n128 result;

  caulk::xstring::assign((as::server::MicrophoneConfiguration *)((char *)this + 40), (const as::server::MicrophoneConfiguration *)((char *)a2 + 40));
  if (this != a2)
    std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((char *)this + 16, *((char **)a2 + 2), *((_QWORD *)a2 + 3), (uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 2);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 56);
  *((_BYTE *)this + 72) = *((_BYTE *)a2 + 72);
  *(__n128 *)((char *)this + 56) = result;
  return result;
}

uint64_t as::server::MicrophoneConfiguration::MicrophoneConfiguration(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE42B0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0;
  as::server::MicrophoneConfiguration::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE42B0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0;
  as::server::MicrophoneConfiguration::move_from(a1, a2);
  return a1;
}

__n128 as::server::MicrophoneConfiguration::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 result;
  _QWORD v8[2];

  v8[0] = 0;
  v8[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)v8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 56);
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(__n128 *)(a1 + 56) = result;
  return result;
}

uint64_t as::server::MicrophoneConfiguration::operator=(uint64_t a1, uint64_t a2)
{
  as::server::MicrophoneConfiguration::move_from(a1, a2);
  return a1;
}

uint64_t as::server::MicrophoneConfiguration::clear(as::server::MicrophoneConfiguration *this)
{
  uint64_t result;

  result = caulk::xstring::clear((as::server::MicrophoneConfiguration *)((char *)this + 40));
  *((_QWORD *)this + 3) = *((_QWORD *)this + 2);
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_BYTE *)this + 72) = 0;
  return result;
}

BOOL as::server::MicrophoneConfiguration::isInitialized(as::server::MicrophoneConfiguration *this)
{
  return (~*((_DWORD *)this + 2) & 0x3F) == 0;
}

BOOL as::server::MicrophoneConfiguration::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  void **v8;
  _QWORD *v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  char v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  BOOL v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  char v27;
  unsigned int v28;
  uint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  char v34;
  char *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  int v44;
  unint64_t v45;
  uint64_t v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  BOOL v50;
  unint64_t v51;
  char v52;
  char v53;
  char v54;
  unsigned int v55;
  uint64_t v56;
  char v57;
  int v58;
  BOOL v59;
  char v60;
  unsigned int v61;
  unint64_t v62;
  char v63;
  char v64;
  unsigned int v65;
  unint64_t v66;
  char v67;
  char v68;
  unsigned int v69;
  unint64_t v70;
  char v71;
  unint64_t v72;
  char *v73;
  _DWORD *v74;
  char v75;
  unsigned int v76;
  unint64_t v77;
  char v78;
  char *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  int v85;
  char *v86;
  int v87;
  unint64_t v88;
  uint64_t v89;
  char v90;
  unsigned int v91;
  uint64_t v92;
  unint64_t v94;
  char v95;
  char v96;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  v8 = (void **)(a1 + 16);
  v9 = (_QWORD *)(a1 + 32);
  while (2)
  {
    v10 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v3 + 1;
        a2[1] = v3 + 1;
        v15 = *(_BYTE *)(v10 + v3);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v3 = v14;
        v50 = v12++ > 8;
        if (v50)
        {
          v13 = 0;
          break;
        }
      }
      v3 = v14;
      goto LABEL_24;
    }
    v16 = 0;
    v17 = 0;
    v13 = 0;
    if (v3 <= v2)
      v18 = v2;
    else
      v18 = v3;
    do
    {
      if (v18 == v3)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v19 = v3++;
      v20 = *(_BYTE *)(v10 + v19);
      a2[1] = v3;
      v13 |= (unint64_t)(v20 & 0x7F) << v16;
      if ((v20 & 0x80) == 0)
        goto LABEL_23;
      v16 += 7;
      v21 = v17++ >= 9;
    }
    while (!v21);
    v13 = 0;
LABEL_23:
    v3 = v19 + 1;
LABEL_24:
    if ((v13 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v13 >> 3))
    {
      case 1u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v60 = 0;
          v61 = 0;
          v24 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v62 = v3++;
            v63 = *(_BYTE *)(v10 + v62);
            a2[1] = v3;
            v24 |= (unint64_t)(v63 & 0x7F) << v60;
            if ((v63 & 0x80) == 0)
              goto LABEL_110;
            v60 += 7;
            v21 = v61++ >= 9;
            if (v21)
            {
              LODWORD(v24) = 0;
LABEL_110:
              v25 = v62 + 1;
              goto LABEL_152;
            }
          }
          LODWORD(v24) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = 0;
          do
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v26 = *(_BYTE *)(v10 + v3);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0)
              goto LABEL_152;
            v22 += 7;
            v3 = v25;
            v50 = v23++ > 8;
          }
          while (!v50);
          LODWORD(v24) = 0;
        }
LABEL_152:
        *(_DWORD *)(a1 + 56) = v24;
        v85 = *(_DWORD *)(a1 + 8) | 1;
        goto LABEL_159;
      case 2u:
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 2u;
        v3 = a2[1];
        v2 = a2[2];
        goto LABEL_160;
      case 3u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v64 = 0;
          v65 = 0;
          v29 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v66 = v3++;
            v67 = *(_BYTE *)(v10 + v66);
            a2[1] = v3;
            v29 |= (unint64_t)(v67 & 0x7F) << v64;
            if ((v67 & 0x80) == 0)
              goto LABEL_119;
            v64 += 7;
            v21 = v65++ >= 9;
            if (v21)
            {
              LODWORD(v29) = 0;
LABEL_119:
              v25 = v66 + 1;
              goto LABEL_154;
            }
          }
          LODWORD(v29) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v27 = 0;
          v28 = 0;
          v29 = 0;
          do
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v30 = *(_BYTE *)(v10 + v3);
            v29 |= (unint64_t)(v30 & 0x7F) << v27;
            if ((v30 & 0x80) == 0)
              goto LABEL_154;
            v27 += 7;
            v3 = v25;
            v50 = v28++ > 8;
          }
          while (!v50);
          LODWORD(v29) = 0;
        }
LABEL_154:
        *(_DWORD *)(a1 + 60) = v29;
        v85 = *(_DWORD *)(a1 + 8) | 4;
        goto LABEL_159;
      case 4u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v68 = 0;
          v69 = 0;
          v33 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v70 = v3++;
            v71 = *(_BYTE *)(v10 + v70);
            a2[1] = v3;
            v33 |= (unint64_t)(v71 & 0x7F) << v68;
            if ((v71 & 0x80) == 0)
              goto LABEL_128;
            v68 += 7;
            v21 = v69++ >= 9;
            if (v21)
            {
              LODWORD(v33) = 0;
LABEL_128:
              v25 = v70 + 1;
              goto LABEL_156;
            }
          }
          LODWORD(v33) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v31 = 0;
          v32 = 0;
          v33 = 0;
          do
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v34 = *(_BYTE *)(v10 + v3);
            v33 |= (unint64_t)(v34 & 0x7F) << v31;
            if ((v34 & 0x80) == 0)
              goto LABEL_156;
            v31 += 7;
            v3 = v25;
            v50 = v32++ > 8;
          }
          while (!v50);
          LODWORD(v33) = 0;
        }
LABEL_156:
        *(_DWORD *)(a1 + 64) = v33;
        v85 = *(_DWORD *)(a1 + 8) | 8;
        goto LABEL_159;
      case 5u:
        if ((v13 & 7) != 2)
        {
          v73 = *(char **)(a1 + 24);
          v72 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v73 >= v72)
          {
            v79 = (char *)*v8;
            v80 = (v73 - (_BYTE *)*v8) >> 2;
            v81 = v80 + 1;
            if ((unint64_t)(v80 + 1) >> 62)
LABEL_195:
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v82 = v72 - (_QWORD)v79;
            if (v82 >> 1 > v81)
              v81 = v82 >> 1;
            if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFFCLL)
              v83 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v83 = v81;
            if (v83)
            {
              v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v83);
              v79 = *(char **)(a1 + 16);
              v73 = *(char **)(a1 + 24);
            }
            else
            {
              v84 = 0;
            }
            v86 = &v84[4 * v80];
            *(_DWORD *)v86 = 0;
            v74 = v86 + 4;
            while (v73 != v79)
            {
              v87 = *((_DWORD *)v73 - 1);
              v73 -= 4;
              *((_DWORD *)v86 - 1) = v87;
              v86 -= 4;
            }
            *(_QWORD *)(a1 + 16) = v86;
            *(_QWORD *)(a1 + 24) = v74;
            *(_QWORD *)(a1 + 32) = &v84[4 * v83];
            if (v79)
              operator delete(v79);
          }
          else
          {
            *(_DWORD *)v73 = 0;
            v74 = v73 + 4;
          }
          *(_QWORD *)(a1 + 24) = v74;
          v88 = a2[1];
          v2 = a2[2];
          v89 = *a2;
          v90 = 0;
          v91 = 0;
          v92 = 0;
          if (v88 > 0xFFFFFFFFFFFFFFF5 || v88 + 10 > v2)
          {
            if (v2 <= v88)
              v3 = a2[1];
            else
              v3 = a2[2];
            while (1)
            {
              if (v3 == v88)
              {
                LODWORD(v92) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_190;
              }
              v94 = v88++;
              v95 = *(_BYTE *)(v89 + v94);
              a2[1] = v88;
              v92 |= (unint64_t)(v95 & 0x7F) << v90;
              if ((v95 & 0x80) == 0)
                break;
              v90 += 7;
              v50 = v91++ > 8;
              if (v50)
              {
                LODWORD(v92) = 0;
                goto LABEL_189;
              }
            }
            if (*((_BYTE *)a2 + 24))
              LODWORD(v92) = 0;
LABEL_189:
            v3 = v94 + 1;
          }
          else
          {
            do
            {
              v3 = v88 + 1;
              a2[1] = v88 + 1;
              v96 = *(_BYTE *)(v89 + v88);
              v92 |= (unint64_t)(v96 & 0x7F) << v90;
              if ((v96 & 0x80) == 0)
                goto LABEL_190;
              v90 += 7;
              v88 = v3;
              v50 = v91++ > 8;
            }
            while (!v50);
            LODWORD(v92) = 0;
          }
LABEL_190:
          *(v74 - 1) = v92;
          goto LABEL_160;
        }
        if ((PB::Reader::placeMark() & 1) == 0)
        {
          v3 = a2[1];
          v2 = a2[2];
          if (v3 < v2 && !*((_BYTE *)a2 + 24))
          {
            v35 = *(char **)(a1 + 24);
            do
            {
              if ((unint64_t)v35 >= *v9)
              {
                v36 = (char *)*v8;
                v37 = (v35 - (_BYTE *)*v8) >> 2;
                v38 = v37 + 1;
                if ((unint64_t)(v37 + 1) >> 62)
                  goto LABEL_195;
                v39 = *v9 - (_QWORD)v36;
                if (v39 >> 1 > v38)
                  v38 = v39 >> 1;
                if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL)
                  v40 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v40 = v38;
                if (v40)
                {
                  v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v40);
                  v36 = *(char **)(a1 + 16);
                  v35 = *(char **)(a1 + 24);
                }
                else
                {
                  v41 = 0;
                }
                v42 = &v41[4 * v37];
                *(_DWORD *)v42 = 0;
                v43 = v42 + 4;
                while (v35 != v36)
                {
                  v44 = *((_DWORD *)v35 - 1);
                  v35 -= 4;
                  *((_DWORD *)v42 - 1) = v44;
                  v42 -= 4;
                }
                *(_QWORD *)(a1 + 16) = v42;
                *(_QWORD *)(a1 + 24) = v43;
                *(_QWORD *)(a1 + 32) = &v41[4 * v40];
                if (v36)
                  operator delete(v36);
                v35 = v43;
              }
              else
              {
                *(_DWORD *)v35 = 0;
                v35 += 4;
              }
              *(_QWORD *)(a1 + 24) = v35;
              v45 = a2[1];
              v2 = a2[2];
              v46 = *a2;
              v47 = 0;
              v48 = 0;
              v49 = 0;
              v50 = v45 > 0xFFFFFFFFFFFFFFF5 || v45 + 10 > v2;
              if (!v50)
              {
                while (1)
                {
                  v3 = v45 + 1;
                  a2[1] = v45 + 1;
                  v53 = *(_BYTE *)(v46 + v45);
                  v49 |= (unint64_t)(v53 & 0x7F) << v47;
                  if ((v53 & 0x80) == 0)
                    goto LABEL_90;
                  v47 += 7;
                  v45 = v3;
                  v50 = v48++ > 8;
                  if (v50)
                  {
                    LODWORD(v49) = 0;
                    goto LABEL_90;
                  }
                }
              }
              if (v2 <= v45)
                v3 = a2[1];
              else
                v3 = a2[2];
              while (1)
              {
                if (v3 == v45)
                {
                  *((_BYTE *)a2 + 24) = 1;
                  *((_DWORD *)v35 - 1) = 0;
                  goto LABEL_160;
                }
                v51 = v45++;
                v52 = *(_BYTE *)(v46 + v51);
                a2[1] = v45;
                v49 |= (unint64_t)(v52 & 0x7F) << v47;
                if ((v52 & 0x80) == 0)
                  break;
                v47 += 7;
                v50 = v48++ > 8;
                if (v50)
                {
                  LODWORD(v49) = 0;
                  goto LABEL_89;
                }
              }
              if (*((_BYTE *)a2 + 24))
                LODWORD(v49) = 0;
LABEL_89:
              v3 = v51 + 1;
LABEL_90:
              *((_DWORD *)v35 - 1) = v49;
            }
            while (v3 < v2 && !*((_BYTE *)a2 + 24));
          }
LABEL_160:
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || *((_BYTE *)a2 + 24))
            return v4 == 0;
          continue;
        }
        return 0;
      case 6u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v75 = 0;
          v76 = 0;
          v56 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v77 = v3++;
            v78 = *(_BYTE *)(v10 + v77);
            a2[1] = v3;
            v56 |= (unint64_t)(v78 & 0x7F) << v75;
            if ((v78 & 0x80) == 0)
              goto LABEL_139;
            v75 += 7;
            v21 = v76++ >= 9;
            if (v21)
            {
              LODWORD(v56) = 0;
LABEL_139:
              v25 = v77 + 1;
              goto LABEL_158;
            }
          }
          LODWORD(v56) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v54 = 0;
          v55 = 0;
          v56 = 0;
          do
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v57 = *(_BYTE *)(v10 + v3);
            v56 |= (unint64_t)(v57 & 0x7F) << v54;
            if ((v57 & 0x80) == 0)
              goto LABEL_158;
            v54 += 7;
            v3 = v25;
            v50 = v55++ > 8;
          }
          while (!v50);
          LODWORD(v56) = 0;
        }
LABEL_158:
        *(_DWORD *)(a1 + 68) = v56;
        v85 = *(_DWORD *)(a1 + 8) | 0x10;
LABEL_159:
        *(_DWORD *)(a1 + 8) = v85;
        v3 = v25;
        goto LABEL_160;
      case 7u:
        if (v3 >= v2)
        {
          v59 = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v58 = *(unsigned __int8 *)(v10 + v3++);
          a2[1] = v3;
          v59 = v58 != 0;
        }
        *(_BYTE *)(a1 + 72) = v59;
        *(_DWORD *)(a1 + 8) |= 0x20u;
        goto LABEL_160;
      default:
        goto LABEL_160;
    }
  }
}

void sub_20681CF48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::server::MicrophoneConfiguration::writeTo(as::server::MicrophoneConfiguration *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  void *__p;
  char v10;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::server::MicrophoneConfiguration *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v10 < 0)
      operator delete(__p);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 4) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 8) != 0)
    PB::Writer::writeVarInt(a2);
  v6 = *((_QWORD *)this + 2);
  v7 = *((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v6 += 4;
    PB::Writer::writeVarInt(a2);
  }
  v8 = *((_DWORD *)this + 2);
  if ((v8 & 0x10) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v8 = *((_DWORD *)this + 2);
  }
  if ((v8 & 0x20) != 0)
    PB::Writer::write(a2);
}

void sub_20681D068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::MicrophoneConfiguration::formatText(as::server::MicrophoneConfiguration *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void *__p;
  char v12;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "configurationID");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::server::MicrophoneConfiguration *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v12 < 0)
      operator delete(__p);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "location");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 8) != 0)
    PB::TextFormatter::format(a2, "orientation");
  v7 = *((_QWORD *)this + 2);
  v8 = *((_QWORD *)this + 3);
  while (v7 != v8)
  {
    v7 += 4;
    PB::TextFormatter::format(a2, "availablePolarPatterns");
  }
  v9 = *((_DWORD *)this + 2);
  if ((v9 & 0x10) != 0)
  {
    PB::TextFormatter::format(a2, "activePolarPattern");
    v9 = *((_DWORD *)this + 2);
  }
  if ((v9 & 0x20) != 0)
    PB::TextFormatter::format(a2, "SDKClientVisible");
  return PB::TextFormatter::endObject(a2);
}

void sub_20681D1C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::MicrophoneConfiguration::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  _DWORD *v6;
  _DWORD *v7;
  unint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  int v14;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  v4 = *(_QWORD *)(a1 + 56) == *(_QWORD *)(a2 + 56) && *(_QWORD *)(a1 + 64) == *(_QWORD *)(a2 + 64);
  if (!v4 || *(unsigned __int8 *)(a1 + 72) != (unint64_t)*(unsigned __int8 *)(a2 + 72))
    return 0;
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 40), (const caulk::xstring *)(a2 + 40)))
    return 0;
  v6 = *(_DWORD **)(a1 + 16);
  v7 = *(_DWORD **)(a1 + 24);
  v8 = v7 - v6;
  v9 = *(_DWORD **)(a2 + 16);
  if (v8 != (uint64_t)(*(_QWORD *)(a2 + 24) - (_QWORD)v9) >> 2)
    return 0;
  if (v7 == v6)
    return 1;
  v10 = v8 <= 1 ? 1 : v7 - v6;
  if (*v6 != *v9)
    return 0;
  v11 = 1;
  do
  {
    v12 = v11;
    if (v10 == v11)
      break;
    v13 = v6[v11];
    v14 = v9[v11++];
  }
  while (v13 == v14);
  return v12 >= v8;
}

as::server::IOControllerState *as::server::IOControllerState::IOControllerState(as::server::IOControllerState *this, const as::server::IOControllerState *a2)
{
  *(_QWORD *)this = &off_24BFE40F0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  as::server::IOControllerState::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE40F0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  as::server::IOControllerState::copy_from(this, a2);
  return this;
}

__n128 as::server::IOControllerState::copy_from(as::server::IOControllerState *this, const as::server::IOControllerState *a2)
{
  _QWORD *v4;
  __n128 ***v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  __n128 **v9;
  __n128 **v10;
  __n128 *v11;
  unint64_t v12;
  __n128 **v13;
  _QWORD *v14;
  __n128 **v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  __n128 **v21;
  char *v22;
  __n128 *v23;
  __int128 v24;
  char *v25;
  _QWORD *v26;
  uint64_t **v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  const as::server::IOStreamState **v31;
  const as::server::IOStreamState **j;
  uint64_t v33;
  const as::server::IOStreamState *v34;
  unint64_t v35;
  uint64_t *v36;
  _QWORD *v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  uint64_t *v44;
  char *v45;
  uint64_t v46;
  __int128 v47;
  char *v48;
  _QWORD *v49;
  uint64_t **v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  const as::server::IOStreamState **v54;
  const as::server::IOStreamState **k;
  uint64_t v56;
  const as::server::IOStreamState *v57;
  unint64_t v58;
  uint64_t *v59;
  _QWORD *v60;
  uint64_t *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  uint64_t *v67;
  char *v68;
  uint64_t v69;
  __int128 v70;
  char *v71;
  __n128 result;
  const as::server::IOControllerState *i;
  uint64_t v74;
  __int128 v75;
  char *v76;
  char *v77;

  v4 = (_QWORD *)*((_QWORD *)this + 2);
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = (__n128 ***)((char *)this + 16);
  while (v6 != v4)
  {
    v8 = *--v6;
    v7 = v8;
    *v6 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  *((_QWORD *)this + 3) = v4;
  v9 = (__n128 **)*((_QWORD *)a2 + 2);
  v10 = (__n128 **)*((_QWORD *)a2 + 3);
  for (i = a2; v9 != v10; ++v9)
  {
    v11 = (__n128 *)operator new();
    as::SampleRateRange::SampleRateRange(v11, *v9);
    v13 = (__n128 **)*((_QWORD *)this + 3);
    v12 = *((_QWORD *)this + 4);
    if ((unint64_t)v13 >= v12)
    {
      v15 = *v5;
      v16 = v13 - *v5;
      v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v18 = v12 - (_QWORD)v15;
      if (v18 >> 2 > v17)
        v17 = v18 >> 2;
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v17;
      v77 = (char *)this + 32;
      if (v19)
      {
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v19);
        v15 = (__n128 **)*((_QWORD *)this + 2);
        v13 = (__n128 **)*((_QWORD *)this + 3);
      }
      else
      {
        v20 = 0;
      }
      v21 = (__n128 **)&v20[8 * v16];
      v22 = &v20[8 * v19];
      v76 = v22;
      *v21 = v11;
      *((_QWORD *)&v75 + 1) = v21 + 1;
      if (v13 == v15)
      {
        v14 = v21 + 1;
      }
      else
      {
        do
        {
          v23 = *--v13;
          *v13 = 0;
          *--v21 = v23;
        }
        while (v13 != v15);
        v14 = (_QWORD *)*((_QWORD *)&v75 + 1);
        v22 = v76;
      }
      v24 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v21;
      *((_QWORD *)this + 3) = v14;
      v75 = v24;
      v25 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v22;
      v76 = v25;
      v74 = v24;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v74);
    }
    else
    {
      *v13 = v11;
      v14 = v13 + 1;
    }
    *((_QWORD *)this + 3) = v14;
  }
  v26 = (_QWORD *)*((_QWORD *)this + 5);
  v28 = (_QWORD *)*((_QWORD *)this + 6);
  v27 = (uint64_t **)((char *)this + 40);
  while (v28 != v26)
  {
    v30 = *--v28;
    v29 = v30;
    *v28 = 0;
    if (v30)
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  }
  *((_QWORD *)this + 6) = v26;
  v31 = (const as::server::IOStreamState **)*((_QWORD *)i + 5);
  for (j = (const as::server::IOStreamState **)*((_QWORD *)i + 6); v31 != j; ++v31)
  {
    v33 = operator new();
    v34 = *v31;
    *(_QWORD *)v33 = &off_24BFE3F30;
    *(_OWORD *)(v33 + 16) = 0u;
    *(_OWORD *)(v33 + 32) = 0u;
    *(_OWORD *)(v33 + 48) = 0u;
    *(_QWORD *)(v33 + 64) = 0;
    as::server::IOStreamState::copy_from((as::server::IOStreamState *)v33, v34);
    v36 = (uint64_t *)*((_QWORD *)this + 6);
    v35 = *((_QWORD *)this + 7);
    if ((unint64_t)v36 >= v35)
    {
      v38 = *v27;
      v39 = v36 - *v27;
      v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 61)
LABEL_68:
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v41 = v35 - (_QWORD)v38;
      if (v41 >> 2 > v40)
        v40 = v41 >> 2;
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
        v42 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v42 = v40;
      v77 = (char *)this + 56;
      if (v42)
      {
        v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 56, v42);
        v38 = (uint64_t *)*((_QWORD *)this + 5);
        v36 = (uint64_t *)*((_QWORD *)this + 6);
      }
      else
      {
        v43 = 0;
      }
      v44 = (uint64_t *)&v43[8 * v39];
      v45 = &v43[8 * v42];
      v76 = v45;
      *v44 = v33;
      *((_QWORD *)&v75 + 1) = v44 + 1;
      if (v36 == v38)
      {
        v37 = v44 + 1;
      }
      else
      {
        do
        {
          v46 = *--v36;
          *v36 = 0;
          *--v44 = v46;
        }
        while (v36 != v38);
        v37 = (_QWORD *)*((_QWORD *)&v75 + 1);
        v45 = v76;
      }
      v47 = *(_OWORD *)((char *)this + 40);
      *((_QWORD *)this + 5) = v44;
      *((_QWORD *)this + 6) = v37;
      v75 = v47;
      v48 = (char *)*((_QWORD *)this + 7);
      *((_QWORD *)this + 7) = v45;
      v76 = v48;
      v74 = v47;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v74);
    }
    else
    {
      *v36 = v33;
      v37 = v36 + 1;
    }
    *((_QWORD *)this + 6) = v37;
  }
  v49 = (_QWORD *)*((_QWORD *)this + 8);
  v51 = (_QWORD *)*((_QWORD *)this + 9);
  v50 = (uint64_t **)((char *)this + 64);
  while (v51 != v49)
  {
    v53 = *--v51;
    v52 = v53;
    *v51 = 0;
    if (v53)
      (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  }
  *((_QWORD *)this + 9) = v49;
  v54 = (const as::server::IOStreamState **)*((_QWORD *)i + 8);
  for (k = (const as::server::IOStreamState **)*((_QWORD *)i + 9); v54 != k; ++v54)
  {
    v56 = operator new();
    v57 = *v54;
    *(_QWORD *)v56 = &off_24BFE3F30;
    *(_OWORD *)(v56 + 16) = 0u;
    *(_OWORD *)(v56 + 32) = 0u;
    *(_OWORD *)(v56 + 48) = 0u;
    *(_QWORD *)(v56 + 64) = 0;
    as::server::IOStreamState::copy_from((as::server::IOStreamState *)v56, v57);
    v59 = (uint64_t *)*((_QWORD *)this + 9);
    v58 = *((_QWORD *)this + 10);
    if ((unint64_t)v59 >= v58)
    {
      v61 = *v50;
      v62 = v59 - *v50;
      v63 = v62 + 1;
      if ((unint64_t)(v62 + 1) >> 61)
        goto LABEL_68;
      v64 = v58 - (_QWORD)v61;
      if (v64 >> 2 > v63)
        v63 = v64 >> 2;
      if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
        v65 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v65 = v63;
      v77 = (char *)this + 80;
      if (v65)
      {
        v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 80, v65);
        v61 = (uint64_t *)*((_QWORD *)this + 8);
        v59 = (uint64_t *)*((_QWORD *)this + 9);
      }
      else
      {
        v66 = 0;
      }
      v67 = (uint64_t *)&v66[8 * v62];
      v68 = &v66[8 * v65];
      v76 = v68;
      *v67 = v56;
      *((_QWORD *)&v75 + 1) = v67 + 1;
      if (v59 == v61)
      {
        v60 = v67 + 1;
      }
      else
      {
        do
        {
          v69 = *--v59;
          *v59 = 0;
          *--v67 = v69;
        }
        while (v59 != v61);
        v60 = (_QWORD *)*((_QWORD *)&v75 + 1);
        v68 = v76;
      }
      v70 = *((_OWORD *)this + 4);
      *((_QWORD *)this + 8) = v67;
      *((_QWORD *)this + 9) = v60;
      v75 = v70;
      v71 = (char *)*((_QWORD *)this + 10);
      *((_QWORD *)this + 10) = v68;
      v76 = v71;
      v74 = v70;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v74);
    }
    else
    {
      *v59 = v56;
      v60 = v59 + 1;
    }
    *((_QWORD *)this + 9) = v60;
  }
  caulk::xstring::assign((as::server::IOControllerState *)((char *)this + 88), (const as::server::IOControllerState *)((char *)i + 88));
  *((_DWORD *)this + 2) = *((_DWORD *)i + 2);
  result = *(__n128 *)((char *)i + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)i + 120);
  *(__n128 *)((char *)this + 104) = result;
  return result;
}

uint64_t as::server::IOControllerState::IOControllerState(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE40F0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  as::server::IOControllerState::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE40F0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  as::server::IOControllerState::move_from(a1, a2);
  return a1;
}

__n128 as::server::IOControllerState::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __n128 result;
  _QWORD v14[2];

  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  v7 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v7;
  v8 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v8;
  v9 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v9;
  v10 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v10;
  v11 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v11;
  v12 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v12;
  v14[0] = 0;
  v14[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)v14);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 104);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(__n128 *)(a1 + 104) = result;
  return result;
}

uint64_t as::server::IOControllerState::operator=(uint64_t a1, uint64_t a2)
{
  as::server::IOControllerState::move_from(a1, a2);
  return a1;
}

double as::server::IOControllerState::clear(as::server::IOControllerState *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  double result;

  v2 = (_QWORD *)*((_QWORD *)this + 2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  while (v3 != v2)
  {
    v5 = *--v3;
    v4 = v5;
    *v3 = 0;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  *((_QWORD *)this + 3) = v2;
  v6 = (_QWORD *)*((_QWORD *)this + 5);
  v7 = (_QWORD *)*((_QWORD *)this + 6);
  while (v7 != v6)
  {
    v9 = *--v7;
    v8 = v9;
    *v7 = 0;
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  *((_QWORD *)this + 6) = v6;
  v10 = (_QWORD *)*((_QWORD *)this + 8);
  v11 = (_QWORD *)*((_QWORD *)this + 9);
  while (v11 != v10)
  {
    v13 = *--v11;
    v12 = v13;
    *v11 = 0;
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  }
  *((_QWORD *)this + 9) = v10;
  caulk::xstring::clear((as::server::IOControllerState *)((char *)this + 88));
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

BOOL as::server::IOControllerState::isInitialized(as::server::IOControllerState *this)
{
  as::SampleRateRange **v2;
  as::SampleRateRange **v3;
  as::server::IOStreamState **v4;
  as::server::IOStreamState **v5;
  as::server::IOStreamState **v6;
  as::server::IOStreamState **v7;

  v2 = (as::SampleRateRange **)*((_QWORD *)this + 2);
  v3 = (as::SampleRateRange **)*((_QWORD *)this + 3);
  while (v2 != v3)
  {
    if (!as::SampleRateRange::isInitialized(*v2))
      return 0;
    ++v2;
  }
  v4 = (as::server::IOStreamState **)*((_QWORD *)this + 5);
  v5 = (as::server::IOStreamState **)*((_QWORD *)this + 6);
  while (v4 != v5)
  {
    if ((as::server::IOStreamState::isInitialized(*v4) & 1) == 0)
      return 0;
    ++v4;
  }
  v6 = (as::server::IOStreamState **)*((_QWORD *)this + 8);
  v7 = (as::server::IOStreamState **)*((_QWORD *)this + 9);
  while (v6 != v7)
  {
    if ((as::server::IOStreamState::isInitialized(*v6) & 1) == 0)
      return 0;
    ++v6;
  }
  return (~*((_DWORD *)this + 2) & 0xF) == 0;
}

BOOL as::server::IOControllerState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  int64x2_t *v9;
  uint64_t v10;
  int64x2_t *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  BOOL v19;
  char v20;
  unsigned int v21;
  unint64_t v22;
  unint64_t v23;
  char v24;
  BOOL v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t *v42;
  char v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  char v64;
  unsigned int v65;
  unint64_t v66;
  char v67;
  char v68;
  unsigned int v69;
  unint64_t v70;
  char v71;
  uint64_t *v72;
  char *v73;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  int64x2_t v77;
  uint64_t *v78;
  char *v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  int64x2_t v83;
  uint64_t *v84;
  char *v85;
  _QWORD *v86;
  _QWORD *v87;
  uint64_t v88;
  int64x2_t v89;
  char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  int64x2_t *v96;
  void *__p;
  int64x2_t v98;
  char *v99;
  uint64_t v100;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v96 = (int64x2_t *)(a1 + 64);
    v8 = a1 + 80;
    v9 = (int64x2_t *)(a1 + 40);
    v10 = a1 + 56;
    v11 = (int64x2_t *)(a1 + 16);
    v12 = a1 + 32;
    while (1)
    {
      v13 = *a2;
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v14 = 0;
        v15 = 0;
        v16 = 0;
        while (1)
        {
          v17 = v3 + 1;
          a2[1] = v3 + 1;
          v18 = *(_BYTE *)(v13 + v3);
          v16 |= (unint64_t)(v18 & 0x7F) << v14;
          if ((v18 & 0x80) == 0)
            goto LABEL_23;
          v14 += 7;
          v3 = v17;
          v19 = v15++ > 8;
          if (v19)
          {
            v16 = 0;
            goto LABEL_23;
          }
        }
      }
      v20 = 0;
      v21 = 0;
      v16 = 0;
      v22 = v3 <= v2 ? v2 : v3;
      do
      {
        if (v22 == v3)
        {
          v4 = 1;
          *((_BYTE *)a2 + 24) = 1;
          return v4 == 0;
        }
        v23 = v3++;
        v24 = *(_BYTE *)(v13 + v23);
        a2[1] = v3;
        v16 |= (unint64_t)(v24 & 0x7F) << v20;
        if ((v24 & 0x80) == 0)
          goto LABEL_22;
        v20 += 7;
        v25 = v21++ >= 9;
      }
      while (!v25);
      v16 = 0;
LABEL_22:
      v17 = v23 + 1;
LABEL_23:
      if ((v16 & 7) == 4)
        break;
      switch((v16 >> 3))
      {
        case 2u:
          if (v17 > 0xFFFFFFFFFFFFFFF5 || v17 + 10 > v2)
          {
            v64 = 0;
            v65 = 0;
            v28 = 0;
            if (v2 <= v17)
              v2 = v17;
            do
            {
              if (v2 == v17)
              {
                LODWORD(v28) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_126;
              }
              v66 = v17 + 1;
              v67 = *(_BYTE *)(v13 + v17);
              a2[1] = v66;
              v28 |= (unint64_t)(v67 & 0x7F) << v64;
              if ((v67 & 0x80) == 0)
                goto LABEL_126;
              v64 += 7;
              v17 = v66;
              v25 = v65++ >= 9;
            }
            while (!v25);
LABEL_89:
            LODWORD(v28) = 0;
          }
          else
          {
            v26 = 0;
            v27 = 0;
            v28 = 0;
            while (1)
            {
              v29 = v17 + 1;
              a2[1] = v17 + 1;
              v30 = *(_BYTE *)(v13 + v17);
              v28 |= (unint64_t)(v30 & 0x7F) << v26;
              if ((v30 & 0x80) == 0)
                break;
              v26 += 7;
              v17 = v29;
              v19 = v27++ > 8;
              if (v19)
                goto LABEL_89;
            }
          }
LABEL_126:
          *(_DWORD *)(a1 + 132) = v28;
          v58 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_129;
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
          goto LABEL_130;
        case 0xAu:
          if (v17 > 0xFFFFFFFFFFFFFFF7 || v17 + 8 > v2)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_QWORD *)(a1 + 104) = *(_QWORD *)(v13 + v17);
            a2[1] += 8;
          }
          v58 = *(_DWORD *)(a1 + 8) | 2;
          goto LABEL_129;
        case 0xBu:
          v40 = operator new();
          as::SampleRateRange::SampleRateRange(v40);
          v42 = *(uint64_t **)(a1 + 24);
          v41 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v42 >= v41)
          {
            v59 = ((uint64_t)v42 - v11->i64[0]) >> 3;
            if ((unint64_t)(v59 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v60 = v41 - v11->i64[0];
            v61 = v60 >> 2;
            if (v60 >> 2 <= (unint64_t)(v59 + 1))
              v61 = v59 + 1;
            if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
              v62 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v62 = v61;
            v100 = v12;
            if (v62)
              v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v12, v62);
            else
              v63 = 0;
            v84 = (uint64_t *)&v63[8 * v59];
            v85 = &v63[8 * v62];
            v99 = v85;
            *v84 = v40;
            v35 = v84 + 1;
            v98.i64[1] = (uint64_t)(v84 + 1);
            v87 = *(_QWORD **)(a1 + 16);
            v86 = *(_QWORD **)(a1 + 24);
            if (v86 == v87)
            {
              v89 = vdupq_n_s64((unint64_t)v86);
            }
            else
            {
              do
              {
                v88 = *--v86;
                *v86 = 0;
                *--v84 = v88;
              }
              while (v86 != v87);
              v89 = *v11;
              v35 = (_QWORD *)v98.i64[1];
              v85 = v99;
            }
            *(_QWORD *)(a1 + 16) = v84;
            *(_QWORD *)(a1 + 24) = v35;
            v98 = v89;
            v92 = *(char **)(a1 + 32);
            *(_QWORD *)(a1 + 32) = v85;
            v99 = v92;
            __p = (void *)v89.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v42 = v40;
            v35 = v42 + 1;
          }
          *(_QWORD *)(a1 + 24) = v35;
          goto LABEL_122;
        case 0xCu:
          if (v17 > 0xFFFFFFFFFFFFFFF7 || v17 + 8 > v2)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_QWORD *)(a1 + 112) = *(_QWORD *)(v13 + v17);
            a2[1] += 8;
          }
          v58 = *(_DWORD *)(a1 + 8) | 4;
          goto LABEL_129;
        case 0xDu:
          if (v17 > 0xFFFFFFFFFFFFFFF7 || v17 + 8 > v2)
          {
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            *(_QWORD *)(a1 + 120) = *(_QWORD *)(v13 + v17);
            a2[1] += 8;
          }
          v58 = *(_DWORD *)(a1 + 8) | 8;
          goto LABEL_129;
        case 0xEu:
          if (v17 <= 0xFFFFFFFFFFFFFFF5 && v17 + 10 <= v2)
          {
            v43 = 0;
            v44 = 0;
            v45 = 0;
            do
            {
              v46 = v17 + 1;
              a2[1] = v17 + 1;
              v47 = *(_BYTE *)(v13 + v17);
              v45 |= (unint64_t)(v47 & 0x7F) << v43;
              if ((v47 & 0x80) == 0)
                goto LABEL_128;
              v43 += 7;
              v17 = v46;
              v19 = v44++ > 8;
            }
            while (!v19);
LABEL_100:
            LODWORD(v45) = 0;
            goto LABEL_128;
          }
          v68 = 0;
          v69 = 0;
          v45 = 0;
          if (v2 <= v17)
            v2 = v17;
          while (v2 != v17)
          {
            v70 = v17 + 1;
            v71 = *(_BYTE *)(v13 + v17);
            a2[1] = v70;
            v45 |= (unint64_t)(v71 & 0x7F) << v68;
            if ((v71 & 0x80) == 0)
              goto LABEL_128;
            v68 += 7;
            v17 = v70;
            v25 = v69++ >= 9;
            if (v25)
              goto LABEL_100;
          }
          LODWORD(v45) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_128:
          *(_DWORD *)(a1 + 128) = v45;
          v58 = *(_DWORD *)(a1 + 8) | 0x10;
LABEL_129:
          *(_DWORD *)(a1 + 8) = v58;
          goto LABEL_130;
        case 0x14u:
          v36 = operator new();
          v37 = v36;
          *(_QWORD *)v36 = &off_24BFE3F30;
          *(_DWORD *)(v36 + 8) = 0;
          *(_OWORD *)(v36 + 16) = 0u;
          *(_OWORD *)(v36 + 32) = 0u;
          *(_OWORD *)(v36 + 48) = 0u;
          *(_OWORD *)(v36 + 64) = 0u;
          *(_DWORD *)(v36 + 80) = 0;
          v39 = *(uint64_t **)(a1 + 48);
          v38 = *(_QWORD *)(a1 + 56);
          if ((unint64_t)v39 >= v38)
          {
            v53 = ((uint64_t)v39 - v9->i64[0]) >> 3;
            if ((unint64_t)(v53 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v54 = v38 - v9->i64[0];
            v55 = v54 >> 2;
            if (v54 >> 2 <= (unint64_t)(v53 + 1))
              v55 = v53 + 1;
            if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
              v56 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v56 = v55;
            v100 = v10;
            if (v56)
              v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v10, v56);
            else
              v57 = 0;
            v78 = (uint64_t *)&v57[8 * v53];
            v79 = &v57[8 * v56];
            v99 = v79;
            *v78 = v37;
            v35 = v78 + 1;
            v98.i64[1] = (uint64_t)(v78 + 1);
            v81 = *(_QWORD **)(a1 + 40);
            v80 = *(_QWORD **)(a1 + 48);
            if (v80 == v81)
            {
              v83 = vdupq_n_s64((unint64_t)v80);
            }
            else
            {
              do
              {
                v82 = *--v80;
                *v80 = 0;
                *--v78 = v82;
              }
              while (v80 != v81);
              v83 = *v9;
              v35 = (_QWORD *)v98.i64[1];
              v79 = v99;
            }
            *(_QWORD *)(a1 + 40) = v78;
            *(_QWORD *)(a1 + 48) = v35;
            v98 = v83;
            v91 = *(char **)(a1 + 56);
            *(_QWORD *)(a1 + 56) = v79;
            v99 = v91;
            __p = (void *)v83.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v39 = v36;
            v35 = v39 + 1;
          }
          *(_QWORD *)(a1 + 48) = v35;
          goto LABEL_122;
        case 0x15u:
          v31 = operator new();
          v32 = v31;
          *(_QWORD *)v31 = &off_24BFE3F30;
          *(_DWORD *)(v31 + 8) = 0;
          *(_OWORD *)(v31 + 16) = 0u;
          *(_OWORD *)(v31 + 32) = 0u;
          *(_OWORD *)(v31 + 48) = 0u;
          *(_OWORD *)(v31 + 64) = 0u;
          *(_DWORD *)(v31 + 80) = 0;
          v34 = *(uint64_t **)(a1 + 72);
          v33 = *(_QWORD *)(a1 + 80);
          if ((unint64_t)v34 >= v33)
          {
            v48 = ((uint64_t)v34 - v96->i64[0]) >> 3;
            if ((unint64_t)(v48 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v49 = v33 - v96->i64[0];
            v50 = v49 >> 2;
            if (v49 >> 2 <= (unint64_t)(v48 + 1))
              v50 = v48 + 1;
            if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8)
              v51 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v51 = v50;
            v100 = v8;
            if (v51)
              v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v8, v51);
            else
              v52 = 0;
            v72 = (uint64_t *)&v52[8 * v48];
            v73 = &v52[8 * v51];
            v99 = v73;
            *v72 = v32;
            v35 = v72 + 1;
            v98.i64[1] = (uint64_t)(v72 + 1);
            v75 = *(_QWORD **)(a1 + 64);
            v74 = *(_QWORD **)(a1 + 72);
            if (v74 == v75)
            {
              v77 = vdupq_n_s64((unint64_t)v74);
            }
            else
            {
              do
              {
                v76 = *--v74;
                *v74 = 0;
                *--v72 = v76;
              }
              while (v74 != v75);
              v77 = *v96;
              v35 = (_QWORD *)v98.i64[1];
              v73 = v99;
            }
            *(_QWORD *)(a1 + 64) = v72;
            *(_QWORD *)(a1 + 72) = v35;
            v98 = v77;
            v90 = *(char **)(a1 + 80);
            *(_QWORD *)(a1 + 80) = v73;
            v99 = v90;
            __p = (void *)v77.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v34 = v31;
            v35 = v34 + 1;
          }
          *(_QWORD *)(a1 + 72) = v35;
LABEL_122:
          v93 = *(v35 - 1);
          if ((PB::Reader::placeMark() & 1) == 0
            || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v93 + 16))(v93, a2) & 1) == 0)
          {
            return 0;
          }
          PB::Reader::recallMark();
LABEL_130:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          break;
        default:
          if ((v16 >> 3) == 30)
          {
            __p = 0;
            v98 = 0uLL;
            PB::Reader::read();
            caulk::xstring::assign();
            *(_DWORD *)(a1 + 8) |= 0x20u;
            if (v98.i8[15] < 0)
              operator delete(__p);
          }
          goto LABEL_130;
      }
    }
    v4 = 0;
  }
  return v4 == 0;
}

void sub_20681E2EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;

  (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  _Unwind_Resume(a1);
}

void as::server::IOControllerState::writeTo(as::server::IOControllerState *this, PB::Writer *a2)
{
  int v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;
  int v8;
  const PB::Base **v9;
  const PB::Base **v10;
  const PB::Base *v11;
  const PB::Base **v12;
  const PB::Base **v13;
  const PB::Base *v14;
  char *v15;
  void *__p;
  char v17;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
    PB::Writer::write(a2, *((double *)this + 13));
  v5 = (const PB::Base **)*((_QWORD *)this + 2);
  v6 = (const PB::Base **)*((_QWORD *)this + 3);
  while (v5 != v6)
  {
    v7 = *v5++;
    PB::Writer::writeSubmessage(a2, v7);
  }
  v8 = *((_DWORD *)this + 2);
  if ((v8 & 4) == 0)
  {
    if ((v8 & 8) == 0)
      goto LABEL_10;
LABEL_23:
    PB::Writer::write(a2, *((double *)this + 15));
    if ((*((_DWORD *)this + 2) & 0x10) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
  PB::Writer::write(a2, *((double *)this + 14));
  v8 = *((_DWORD *)this + 2);
  if ((v8 & 8) != 0)
    goto LABEL_23;
LABEL_10:
  if ((v8 & 0x10) != 0)
LABEL_11:
    PB::Writer::writeVarInt(a2);
LABEL_12:
  v9 = (const PB::Base **)*((_QWORD *)this + 5);
  v10 = (const PB::Base **)*((_QWORD *)this + 6);
  while (v9 != v10)
  {
    v11 = *v9++;
    PB::Writer::writeSubmessage(a2, v11);
  }
  v12 = (const PB::Base **)*((_QWORD *)this + 8);
  v13 = (const PB::Base **)*((_QWORD *)this + 9);
  while (v12 != v13)
  {
    v14 = *v12++;
    PB::Writer::writeSubmessage(a2, v14);
  }
  if ((*((_BYTE *)this + 8) & 0x20) != 0)
  {
    v15 = (char *)caulk::xstring::c_str((as::server::IOControllerState *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v15);
    PB::Writer::write();
    if (v17 < 0)
      operator delete(__p);
  }
}

void sub_20681E484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::IOControllerState::formatText(as::server::IOControllerState *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  char *v16;
  void *__p;
  char v19;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "type");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "sampleRate", *((double *)this + 13));
  v6 = (uint64_t *)*((_QWORD *)this + 2);
  v7 = (uint64_t *)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "availableSampleRates");
  }
  v9 = *((_DWORD *)this + 2);
  if ((v9 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "minimumSampleRate", *((double *)this + 14));
    v9 = *((_DWORD *)this + 2);
    if ((v9 & 8) == 0)
    {
LABEL_9:
      if ((v9 & 0x10) == 0)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  else if ((v9 & 8) == 0)
  {
    goto LABEL_9;
  }
  PB::TextFormatter::format(a2, "maximumSampleRate", *((double *)this + 15));
  if ((*((_DWORD *)this + 2) & 0x10) != 0)
LABEL_10:
    PB::TextFormatter::format(a2, "bufferFrameSize");
LABEL_11:
  v10 = (uint64_t *)*((_QWORD *)this + 5);
  v11 = (uint64_t *)*((_QWORD *)this + 6);
  while (v10 != v11)
  {
    v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v12 + 32))(v12, a2, "inputIOStreams");
  }
  v13 = (uint64_t *)*((_QWORD *)this + 8);
  v14 = (uint64_t *)*((_QWORD *)this + 9);
  while (v13 != v14)
  {
    v15 = *v13++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v15 + 32))(v15, a2, "outputIOStreams");
  }
  if ((*((_BYTE *)this + 8) & 0x20) != 0)
  {
    v16 = (char *)caulk::xstring::c_str((as::server::IOControllerState *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v16);
    PB::TextFormatter::format();
    if (v19 < 0)
      operator delete(__p);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_20681E660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::IOControllerState::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  BOOL v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  v4 = *(_QWORD *)(a1 + 104) == *(_QWORD *)(a2 + 104) && *(_QWORD *)(a1 + 112) == *(_QWORD *)(a2 + 112);
  v5 = v4 && *(_QWORD *)(a1 + 120) == *(_QWORD *)(a2 + 120);
  if (!v5 || *(_QWORD *)(a1 + 128) != *(_QWORD *)(a2 + 128))
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v9 = (v7 - v8) >> 3;
  if (v9 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3)
    return 0;
  if (v7 != v8)
  {
    v10 = 0;
    if (v9 <= 1)
      v11 = 1;
    else
      v11 = (v7 - v8) >> 3;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v10);
      v13 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v10);
      if (v12)
        v14 = v13 == 0;
      else
        v14 = 1;
      if (v14)
      {
        if (v12 | v13)
          return 0;
      }
      else if (!as::SampleRateRange::operator==(v12, v13))
      {
        return 0;
      }
      ++v10;
    }
    while (v11 != v10);
  }
  v16 = *(_QWORD *)(a1 + 40);
  v15 = *(_QWORD *)(a1 + 48);
  v17 = (v15 - v16) >> 3;
  if (v17 != (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
    return 0;
  if (v15 != v16)
  {
    v18 = 0;
    if (v17 <= 1)
      v19 = 1;
    else
      v19 = (v15 - v16) >> 3;
    do
    {
      v20 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v18);
      v21 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v18);
      if (v20)
        v22 = v21 == 0;
      else
        v22 = 1;
      if (v22)
      {
        if (v20 | v21)
          return 0;
      }
      else if (!as::server::IOStreamState::operator==(v20, v21))
      {
        return 0;
      }
      ++v18;
    }
    while (v19 != v18);
  }
  v24 = *(_QWORD *)(a1 + 64);
  v23 = *(_QWORD *)(a1 + 72);
  v25 = (v23 - v24) >> 3;
  if (v25 != (uint64_t)(*(_QWORD *)(a2 + 72) - *(_QWORD *)(a2 + 64)) >> 3)
    return 0;
  if (v23 != v24)
  {
    v26 = 0;
    if (v25 <= 1)
      v27 = 1;
    else
      v27 = (v23 - v24) >> 3;
    do
    {
      v28 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v26);
      v29 = *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v26);
      if (v28)
        v30 = v29 == 0;
      else
        v30 = 1;
      if (v30)
      {
        if (v28 | v29)
          return 0;
      }
      else if (!as::server::IOStreamState::operator==(v28, v29))
      {
        return 0;
      }
      ++v26;
    }
    while (v27 != v26);
  }
  return caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)) == 0;
}

uint64_t as::server::IOControllerState::addAvailableSampleRates(as::server::IOControllerState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  char *v23;
  char *v24;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v24 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v23 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v22 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v22 + 1);
      v14 = v23;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v22 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v23 = v17;
    v21 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v21);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  v18 = operator new();
  result = as::SampleRateRange::SampleRateRange(v18);
  v20 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::IOControllerState::addInputIOStreams(as::server::IOControllerState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3F30;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_DWORD *)(result + 80) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::IOControllerState::addOutputIOStreams(as::server::IOControllerState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 10);
  v2 = (char *)this + 80;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 8);
      v5 = (_QWORD *)*((_QWORD *)this + 9);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 4);
    *((_QWORD *)this + 8) = v13;
    *((_QWORD *)this + 9) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 10);
    *((_QWORD *)this + 10) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 9) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3F30;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_DWORD *)(result + 80) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::PlatformSupport::default_instance(as::server::PlatformSupport *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3FD8;
    *(_OWORD *)(v3 + 8) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    as::server::PlatformSupport::default_instance(void)::gInstance = v3;
  }
  return as::server::PlatformSupport::default_instance(void)::gInstance;
}

void sub_20681ECC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::PlatformSupport::PlatformSupport(as::server::PlatformSupport *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3FD8;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3FD8;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

as::server::PlatformSupport *as::server::PlatformSupport::PlatformSupport(as::server::PlatformSupport *this, caulk::xstring **a2)
{
  *(_QWORD *)this = &off_24BFE3FD8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::PlatformSupport::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3FD8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::PlatformSupport::copy_from(this, a2);
  return this;
}

caulk::xstring *as::server::PlatformSupport::copy_from(caulk::xstring *this, caulk::xstring **a2)
{
  caulk::xstring *v3;

  if (this != (caulk::xstring *)a2)
  {
    v3 = this;
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 8, a2[1], a2[2], (a2[2] - a2[1]) >> 4);
    return std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)v3 + 32, a2[4], a2[5], (a2[5] - a2[4]) >> 4);
  }
  return this;
}

caulk::xstring *as::server::PlatformSupport::operator=(caulk::xstring *a1, caulk::xstring **a2)
{
  as::server::PlatformSupport::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::PlatformSupport::PlatformSupport(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)a1 = &off_24BFE3FD8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::PlatformSupport::move_from((_QWORD *)a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3FD8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::PlatformSupport::move_from((_QWORD *)a1, a2);
  return a1;
}

_QWORD *as::server::PlatformSupport::move_from(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  v5 = result[4];
  result[4] = a2[4];
  a2[4] = v5;
  v6 = result[5];
  result[5] = a2[5];
  a2[5] = v6;
  v7 = result[6];
  result[6] = a2[6];
  a2[6] = v7;
  return result;
}

_QWORD *as::server::PlatformSupport::operator=(_QWORD *a1, _QWORD *a2)
{
  as::server::PlatformSupport::move_from(a1, a2);
  return a1;
}

uint64_t as::server::PlatformSupport::clear(caulk::xstring **this)
{
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)(this + 1), this[1]);
  return std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)(this + 4), this[4]);
}

uint64_t as::server::PlatformSupport::isInitialized(as::server::PlatformSupport *this)
{
  return 1;
}

BOOL as::server::PlatformSupport::readFrom(_QWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  char v19;
  unsigned int v20;
  unint64_t v21;
  char v22;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void *__p;
  char *v44;
  _QWORD *v45;
  char *v46;
  uint64_t v47;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0)
    return v4 == 0;
  v8 = a1 + 4;
  v9 = (uint64_t)(a1 + 6);
  v10 = a1 + 1;
  v11 = (uint64_t)(a1 + 3);
  while (1)
  {
    v12 = *a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      break;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    while (1)
    {
      v16 = v2 + 1;
      a2[1] = v2 + 1;
      v17 = *(_BYTE *)(v12 + v2);
      v15 |= (unint64_t)(v17 & 0x7F) << v13;
      if ((v17 & 0x80) == 0)
        break;
      v13 += 7;
      v2 = v16;
      if (v14++ > 8)
        goto LABEL_20;
    }
LABEL_21:
    if ((v15 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    if ((v15 >> 3) == 2)
    {
      v28 = (_QWORD *)a1[5];
      v27 = a1[6];
      if ((unint64_t)v28 >= v27)
      {
        v35 = ((uint64_t)v28 - *v8) >> 4;
        v36 = v35 + 1;
        if ((unint64_t)(v35 + 1) >> 60)
          std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
        v37 = v27 - *v8;
        if (v37 >> 3 > v36)
          v36 = v37 >> 3;
        if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF0)
          v38 = 0xFFFFFFFFFFFFFFFLL;
        else
          v38 = v36;
        v47 = v9;
        if (v38)
          v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v38);
        else
          v39 = 0;
        v41 = &v39[16 * v35];
        __p = v39;
        v44 = v41;
        v46 = &v39[16 * v38];
        *(_QWORD *)v41 = 0;
        *((_QWORD *)v41 + 1) = 0;
        v45 = v41 + 16;
        std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
        v29 = (_QWORD *)a1[5];
        std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
      }
      else
      {
        *v28 = 0;
        v28[1] = 0;
        v29 = v28 + 2;
        a1[5] = v28 + 2;
      }
      a1[5] = v29;
      __p = 0;
      v44 = 0;
      v45 = 0;
      PB::Reader::read();
      caulk::xstring::assign();
      goto LABEL_50;
    }
    if ((v15 >> 3) == 1)
    {
      v25 = (_QWORD *)a1[2];
      v24 = a1[3];
      if ((unint64_t)v25 >= v24)
      {
        v30 = ((uint64_t)v25 - *v10) >> 4;
        v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 60)
          std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
        v32 = v24 - *v10;
        if (v32 >> 3 > v31)
          v31 = v32 >> 3;
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0)
          v33 = 0xFFFFFFFFFFFFFFFLL;
        else
          v33 = v31;
        v47 = v11;
        if (v33)
          v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v11, v33);
        else
          v34 = 0;
        v40 = &v34[16 * v30];
        __p = v34;
        v44 = v40;
        v46 = &v34[16 * v33];
        *(_QWORD *)v40 = 0;
        *((_QWORD *)v40 + 1) = 0;
        v45 = v40 + 16;
        std::vector<caulk::xstring>::__swap_out_circular_buffer(v10, &__p);
        v26 = (_QWORD *)a1[2];
        std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
      }
      else
      {
        *v25 = 0;
        v25[1] = 0;
        v26 = v25 + 2;
        a1[2] = v25 + 2;
      }
      a1[2] = v26;
      __p = 0;
      v44 = 0;
      v45 = 0;
      PB::Reader::read();
      caulk::xstring::assign();
LABEL_50:
      if (SHIBYTE(v45) < 0)
        operator delete(__p);
    }
    v2 = a2[1];
    v3 = a2[2];
    v4 = *((unsigned __int8 *)a2 + 24);
    if (v2 >= v3 || *((_BYTE *)a2 + 24))
      return v4 == 0;
  }
  v19 = 0;
  v20 = 0;
  v15 = 0;
  if (v2 > v3)
    v3 = v2;
  while (v3 != v2)
  {
    v21 = v2 + 1;
    v22 = *(_BYTE *)(v12 + v2);
    a2[1] = v21;
    v15 |= (unint64_t)(v22 & 0x7F) << v19;
    if ((v22 & 0x80) == 0)
      goto LABEL_21;
    v19 += 7;
    v2 = v21;
    if (v20++ >= 9)
    {
LABEL_20:
      v15 = 0;
      goto LABEL_21;
    }
  }
  v4 = 1;
  *((_BYTE *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_20681F25C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void as::server::PlatformSupport::writeTo(as::server::PlatformSupport *this, PB::Writer *a2)
{
  caulk::xstring *v3;
  caulk::xstring *v4;
  char *v5;
  caulk::xstring *v6;
  caulk::xstring *v7;
  char *v8;
  void *__p[2];
  char v10;

  v3 = (caulk::xstring *)*((_QWORD *)this + 1);
  v4 = (caulk::xstring *)*((_QWORD *)this + 2);
  while (v3 != v4)
  {
    v5 = (char *)caulk::xstring::c_str(v3);
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v10 < 0)
      operator delete(__p[0]);
    v3 = (caulk::xstring *)((char *)v3 + 16);
  }
  v7 = (caulk::xstring *)*((_QWORD *)this + 4);
  v6 = (caulk::xstring *)*((_QWORD *)this + 5);
  while (v7 != v6)
  {
    v8 = (char *)caulk::xstring::c_str(v7);
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::Writer::write();
    if (v10 < 0)
      operator delete(__p[0]);
    v7 = (caulk::xstring *)((char *)v7 + 16);
  }
}

void sub_20681F350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::server::PlatformSupport::formatText(as::server::PlatformSupport *this, PB::TextFormatter *a2, const char *a3)
{
  caulk::xstring *v5;
  caulk::xstring *i;
  char *v7;
  caulk::xstring *v8;
  caulk::xstring *j;
  char *v10;
  void *__p[2];
  char v13;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = (caulk::xstring *)*((_QWORD *)this + 1);
  for (i = (caulk::xstring *)*((_QWORD *)this + 2); v5 != i; v5 = (caulk::xstring *)((char *)v5 + 16))
  {
    v7 = (char *)caulk::xstring::c_str(v5);
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v13 < 0)
      operator delete(__p[0]);
  }
  v8 = (caulk::xstring *)*((_QWORD *)this + 4);
  for (j = (caulk::xstring *)*((_QWORD *)this + 5); v8 != j; v8 = (caulk::xstring *)((char *)v8 + 16))
  {
    v10 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(__p, v10);
    PB::TextFormatter::format();
    if (v13 < 0)
      operator delete(__p[0]);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_20681F464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::server::PlatformSupport::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v4 = (v2 - v3) >> 4;
  if (v4 != (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 4)
    return 0;
  if (v2 != v3)
  {
    v7 = 0;
    if (v4 <= 1)
      v8 = 1;
    else
      v8 = (v2 - v3) >> 4;
    while (!caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 8) + v7), (const caulk::xstring *)(*(_QWORD *)(a2 + 8) + v7)))
    {
      v7 += 16;
      if (!--v8)
        goto LABEL_8;
    }
    return 0;
  }
LABEL_8:
  v10 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(a1 + 40);
  v11 = (v9 - v10) >> 4;
  if (v11 != (uint64_t)(*(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 32)) >> 4)
    return 0;
  if (v9 == v10)
    return 1;
  if (v11 <= 1)
    v12 = 1;
  else
    v12 = (v9 - v10) >> 4;
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 32), *(const caulk::xstring **)(a2 + 32)))
    return 0;
  v14 = 1;
  v15 = 16;
  do
  {
    v16 = v14;
    if (v12 == v14)
      break;
    v17 = caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 32) + v15), (const caulk::xstring *)(*(_QWORD *)(a2 + 32) + v15));
    v14 = v16 + 1;
    v15 += 16;
  }
  while (!v17);
  return v16 >= v11;
}

uint64_t as::server::SessionServerState::default_instance(as::server::SessionServerState *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE4160;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 57) = 0u;
    as::server::SessionServerState::default_instance(void)::gInstance = v3;
  }
  return as::server::SessionServerState::default_instance(void)::gInstance;
}

void sub_20681F61C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::server::SessionServerState::SessionServerState(as::server::SessionServerState *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE4160;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE4160;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

as::server::SessionServerState *as::server::SessionServerState::SessionServerState(as::server::SessionServerState *this, const as::server::SessionServerState *a2)
{
  *(_QWORD *)this = &off_24BFE4160;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::SessionServerState::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE4160;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::SessionServerState::copy_from(this, a2);
  return this;
}

void as::server::SessionServerState::copy_from(as::server::SessionServerState *this, const as::server::SessionServerState *a2)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  const as::server::IOControllerState **v9;
  const as::server::IOControllerState **v10;
  uint64_t v11;
  const as::server::IOControllerState *v12;
  unint64_t v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  uint64_t v24;
  __int128 v25;
  char *v26;
  _QWORD *v27;
  as::server::VirtualPort ***v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  const as::server::VirtualPort **v32;
  const as::server::VirtualPort **j;
  as::server::VirtualPort *v34;
  const as::server::VirtualPort *v35;
  unint64_t v36;
  as::server::VirtualPort **v37;
  _QWORD *v38;
  as::server::VirtualPort **v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  as::server::VirtualPort **v45;
  char *v46;
  as::server::VirtualPort *v47;
  __int128 v48;
  char *v49;
  uint64_t v50;
  const as::server::SessionServerState *i;
  uint64_t v52;
  __int128 v53;
  char *v54;
  char *v55;

  v4 = (_QWORD *)*((_QWORD *)this + 2);
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = (uint64_t **)((char *)this + 16);
  while (v6 != v4)
  {
    v8 = *--v6;
    v7 = v8;
    *v6 = 0;
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  *((_QWORD *)this + 3) = v4;
  v9 = (const as::server::IOControllerState **)*((_QWORD *)a2 + 2);
  v10 = (const as::server::IOControllerState **)*((_QWORD *)a2 + 3);
  for (i = a2; v9 != v10; ++v9)
  {
    v11 = operator new();
    v12 = *v9;
    *(_QWORD *)v11 = &off_24BFE40F0;
    *(_OWORD *)(v11 + 16) = 0u;
    *(_OWORD *)(v11 + 32) = 0u;
    *(_OWORD *)(v11 + 48) = 0u;
    *(_OWORD *)(v11 + 64) = 0u;
    *(_OWORD *)(v11 + 80) = 0u;
    *(_QWORD *)(v11 + 96) = 0;
    as::server::IOControllerState::copy_from((as::server::IOControllerState *)v11, v12);
    v14 = (uint64_t *)*((_QWORD *)this + 3);
    v13 = *((_QWORD *)this + 4);
    if ((unint64_t)v14 >= v13)
    {
      v16 = *v5;
      v17 = v14 - *v5;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v55 = (char *)this + 32;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 32, v20);
        v16 = (uint64_t *)*((_QWORD *)this + 2);
        v14 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v21 = 0;
      }
      v22 = (uint64_t *)&v21[8 * v17];
      v23 = &v21[8 * v20];
      v54 = v23;
      *v22 = v11;
      *((_QWORD *)&v53 + 1) = v22 + 1;
      if (v14 == v16)
      {
        v15 = v22 + 1;
      }
      else
      {
        do
        {
          v24 = *--v14;
          *v14 = 0;
          *--v22 = v24;
        }
        while (v14 != v16);
        v15 = (_QWORD *)*((_QWORD *)&v53 + 1);
        v23 = v54;
      }
      v25 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v22;
      *((_QWORD *)this + 3) = v15;
      v53 = v25;
      v26 = (char *)*((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v23;
      v54 = v26;
      v52 = v25;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v52);
    }
    else
    {
      *v14 = v11;
      v15 = v14 + 1;
    }
    *((_QWORD *)this + 3) = v15;
  }
  v27 = (_QWORD *)*((_QWORD *)this + 5);
  v29 = (_QWORD *)*((_QWORD *)this + 6);
  v28 = (as::server::VirtualPort ***)((char *)this + 40);
  while (v29 != v27)
  {
    v31 = *--v29;
    v30 = v31;
    *v29 = 0;
    if (v31)
      (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
  }
  *((_QWORD *)this + 6) = v27;
  v32 = (const as::server::VirtualPort **)*((_QWORD *)i + 5);
  for (j = (const as::server::VirtualPort **)*((_QWORD *)i + 6); v32 != j; ++v32)
  {
    v34 = (as::server::VirtualPort *)operator new();
    v35 = *v32;
    *(_QWORD *)v34 = &off_24BFE3E18;
    *((_OWORD *)v34 + 1) = 0u;
    *((_OWORD *)v34 + 2) = 0u;
    as::server::VirtualPort::copy_from(v34, v35);
    v37 = (as::server::VirtualPort **)*((_QWORD *)this + 6);
    v36 = *((_QWORD *)this + 7);
    if ((unint64_t)v37 >= v36)
    {
      v39 = *v28;
      v40 = v37 - *v28;
      v41 = v40 + 1;
      if ((unint64_t)(v40 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v42 = v36 - (_QWORD)v39;
      if (v42 >> 2 > v41)
        v41 = v42 >> 2;
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
        v43 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v43 = v41;
      v55 = (char *)this + 56;
      if (v43)
      {
        v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 56, v43);
        v39 = (as::server::VirtualPort **)*((_QWORD *)this + 5);
        v37 = (as::server::VirtualPort **)*((_QWORD *)this + 6);
      }
      else
      {
        v44 = 0;
      }
      v45 = (as::server::VirtualPort **)&v44[8 * v40];
      v46 = &v44[8 * v43];
      v54 = v46;
      *v45 = v34;
      *((_QWORD *)&v53 + 1) = v45 + 1;
      if (v37 == v39)
      {
        v38 = v45 + 1;
      }
      else
      {
        do
        {
          v47 = *--v37;
          *v37 = 0;
          *--v45 = v47;
        }
        while (v37 != v39);
        v38 = (_QWORD *)*((_QWORD *)&v53 + 1);
        v46 = v54;
      }
      v48 = *(_OWORD *)((char *)this + 40);
      *((_QWORD *)this + 5) = v45;
      *((_QWORD *)this + 6) = v38;
      v53 = v48;
      v49 = (char *)*((_QWORD *)this + 7);
      *((_QWORD *)this + 7) = v46;
      v54 = v49;
      v52 = v48;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v52);
    }
    else
    {
      *v37 = v34;
      v38 = v37 + 1;
    }
    *((_QWORD *)this + 6) = v38;
  }
  *((_DWORD *)this + 2) = *((_DWORD *)i + 2);
  v50 = *((_QWORD *)i + 8);
  *((_BYTE *)this + 72) = *((_BYTE *)i + 72);
  *((_QWORD *)this + 8) = v50;
}

as::server::SessionServerState *as::server::SessionServerState::operator=(as::server::SessionServerState *a1, const as::server::SessionServerState *a2)
{
  as::server::SessionServerState::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::SessionServerState::SessionServerState(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE4160;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::SessionServerState::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE4160;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::SessionServerState::move_from(a1, a2);
  return a1;
}

uint64_t as::server::SessionServerState::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  v5 = *(_QWORD *)(result + 40);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v5;
  v6 = *(_QWORD *)(result + 48);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v6;
  v7 = *(_QWORD *)(result + 56);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v7;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v8 = *(_QWORD *)(a2 + 64);
  *(_BYTE *)(result + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)(result + 64) = v8;
  return result;
}

uint64_t as::server::SessionServerState::operator=(uint64_t a1, uint64_t a2)
{
  as::server::SessionServerState::move_from(a1, a2);
  return a1;
}

_QWORD *as::server::SessionServerState::clear(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;

  v1 = this;
  v2 = (_QWORD *)this[2];
  v3 = (_QWORD *)this[3];
  while (v3 != v2)
  {
    v4 = (_QWORD *)*--v3;
    this = v4;
    *v3 = 0;
    if (v4)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[3] = v2;
  v5 = (_QWORD *)v1[5];
  v6 = (_QWORD *)v1[6];
  while (v6 != v5)
  {
    v7 = (_QWORD *)*--v6;
    this = v7;
    *v6 = 0;
    if (v7)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[6] = v5;
  *((_DWORD *)v1 + 2) = 0;
  v1[8] = 0;
  *((_BYTE *)v1 + 72) = 0;
  return this;
}

BOOL as::server::SessionServerState::isInitialized(as::server::SessionServerState *this)
{
  as::server::IOControllerState **v2;
  as::server::IOControllerState **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (as::server::IOControllerState **)*((_QWORD *)this + 2);
  v3 = (as::server::IOControllerState **)*((_QWORD *)this + 3);
  while (v2 != v3)
  {
    if (!as::server::IOControllerState::isInitialized(*v2))
      return 0;
    ++v2;
  }
  v4 = *((_QWORD *)this + 5);
  v5 = *((_QWORD *)this + 6);
  if (v4 == v5)
    return (~*((_DWORD *)this + 2) & 7) == 0;
  while (1)
  {
    v6 = *(_QWORD *)(*(_QWORD *)v4 + 32);
    if (!v6 || (~*(_DWORD *)(v6 + 8) & 0x7F) != 0 || (~*(_DWORD *)(*(_QWORD *)v4 + 8) & 3) != 0)
      break;
    v4 += 8;
    if (v4 == v5)
      return (~*((_DWORD *)this + 2) & 7) == 0;
  }
  return 0;
}

BOOL as::server::SessionServerState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t v9;
  int64x2_t *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  BOOL v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t *v38;
  _QWORD *v39;
  int v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t *v45;
  char v46;
  unsigned int v47;
  unint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  char v55;
  unsigned int v56;
  unint64_t v57;
  char v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  uint64_t *v65;
  char *v66;
  _QWORD *v67;
  _QWORD *v68;
  uint64_t v69;
  int64x2_t v70;
  uint64_t *v71;
  char *v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  int64x2_t v76;
  char *v77;
  char *v78;
  uint64_t v79;
  uint64_t v82;
  int64x2_t v83;
  char *v84;
  uint64_t v85;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v8 = (int64x2_t *)(a1 + 40);
    v9 = a1 + 56;
    v10 = (int64x2_t *)(a1 + 16);
    v11 = a1 + 32;
    while (1)
    {
      v12 = *a2;
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        v13 = 0;
        v14 = 0;
        v15 = 0;
        while (1)
        {
          v16 = v3 + 1;
          a2[1] = v3 + 1;
          v17 = *(_BYTE *)(v12 + v3);
          v15 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0)
            goto LABEL_23;
          v13 += 7;
          v3 = v16;
          v18 = v14++ > 8;
          if (v18)
          {
            v15 = 0;
            goto LABEL_23;
          }
        }
      }
      v19 = 0;
      v20 = 0;
      v15 = 0;
      v21 = v3 <= v2 ? v2 : v3;
      do
      {
        if (v21 == v3)
        {
          v4 = 1;
          *((_BYTE *)a2 + 24) = 1;
          return v4 == 0;
        }
        v22 = v3++;
        v23 = *(_BYTE *)(v12 + v22);
        a2[1] = v3;
        v15 |= (unint64_t)(v23 & 0x7F) << v19;
        if ((v23 & 0x80) == 0)
          goto LABEL_22;
        v19 += 7;
        v24 = v20++ >= 9;
      }
      while (!v24);
      v15 = 0;
LABEL_22:
      v16 = v22 + 1;
LABEL_23:
      if ((v15 & 7) == 4)
        break;
      switch((v15 >> 3))
      {
        case 1u:
          if (v16 > 0xFFFFFFFFFFFFFFF5 || v16 + 10 > v2)
          {
            v55 = 0;
            v56 = 0;
            v27 = 0;
            if (v2 <= v16)
              v2 = v16;
            do
            {
              if (v2 == v16)
              {
                LODWORD(v27) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_97;
              }
              v57 = v16 + 1;
              v58 = *(_BYTE *)(v12 + v16);
              a2[1] = v57;
              v27 |= (unint64_t)(v58 & 0x7F) << v55;
              if ((v58 & 0x80) == 0)
                goto LABEL_97;
              v55 += 7;
              v16 = v57;
              v24 = v56++ >= 9;
            }
            while (!v24);
LABEL_66:
            LODWORD(v27) = 0;
          }
          else
          {
            v25 = 0;
            v26 = 0;
            v27 = 0;
            while (1)
            {
              v28 = v16 + 1;
              a2[1] = v16 + 1;
              v29 = *(_BYTE *)(v12 + v16);
              v27 |= (unint64_t)(v29 & 0x7F) << v25;
              if ((v29 & 0x80) == 0)
                break;
              v25 += 7;
              v16 = v28;
              v18 = v26++ > 8;
              if (v18)
                goto LABEL_66;
            }
          }
LABEL_97:
          *(_DWORD *)(a1 + 64) = v27;
          v59 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_98;
        case 2u:
          v42 = operator new();
          v43 = v42;
          *(_QWORD *)v42 = &off_24BFE40F0;
          *(_DWORD *)(v42 + 8) = 0;
          *(_OWORD *)(v42 + 16) = 0u;
          *(_OWORD *)(v42 + 32) = 0u;
          *(_OWORD *)(v42 + 48) = 0u;
          *(_OWORD *)(v42 + 64) = 0u;
          *(_OWORD *)(v42 + 80) = 0u;
          *(_OWORD *)(v42 + 96) = 0u;
          *(_OWORD *)(v42 + 112) = 0u;
          *(_QWORD *)(v42 + 128) = 0;
          v45 = *(uint64_t **)(a1 + 24);
          v44 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v45 >= v44)
          {
            v60 = ((uint64_t)v45 - v10->i64[0]) >> 3;
            if ((unint64_t)(v60 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v61 = v44 - v10->i64[0];
            v62 = v61 >> 2;
            if (v61 >> 2 <= (unint64_t)(v60 + 1))
              v62 = v60 + 1;
            if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8)
              v63 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v63 = v62;
            v85 = v11;
            if (v63)
              v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v11, v63);
            else
              v64 = 0;
            v71 = (uint64_t *)&v64[8 * v60];
            v72 = &v64[8 * v63];
            v84 = v72;
            *v71 = v43;
            v39 = v71 + 1;
            v83.i64[1] = (uint64_t)(v71 + 1);
            v74 = *(_QWORD **)(a1 + 16);
            v73 = *(_QWORD **)(a1 + 24);
            if (v73 == v74)
            {
              v76 = vdupq_n_s64((unint64_t)v73);
            }
            else
            {
              do
              {
                v75 = *--v73;
                *v73 = 0;
                *--v71 = v75;
              }
              while (v73 != v74);
              v76 = *v10;
              v39 = (_QWORD *)v83.i64[1];
              v72 = v84;
            }
            *(_QWORD *)(a1 + 16) = v71;
            *(_QWORD *)(a1 + 24) = v39;
            v83 = v76;
            v78 = *(char **)(a1 + 32);
            *(_QWORD *)(a1 + 32) = v72;
            v84 = v78;
            v82 = v76.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v82);
          }
          else
          {
            *v45 = v42;
            v39 = v45 + 1;
          }
          *(_QWORD *)(a1 + 24) = v39;
          goto LABEL_91;
        case 3u:
          v35 = operator new();
          v36 = v35;
          *(_QWORD *)v35 = &off_24BFE3E18;
          *(_DWORD *)(v35 + 8) = 0;
          *(_OWORD *)(v35 + 16) = 0u;
          *(_OWORD *)(v35 + 32) = 0u;
          *(_WORD *)(v35 + 48) = 0;
          v38 = *(uint64_t **)(a1 + 48);
          v37 = *(_QWORD *)(a1 + 56);
          if ((unint64_t)v38 >= v37)
          {
            v50 = ((uint64_t)v38 - v8->i64[0]) >> 3;
            if ((unint64_t)(v50 + 1) >> 61)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v51 = v37 - v8->i64[0];
            v52 = v51 >> 2;
            if (v51 >> 2 <= (unint64_t)(v50 + 1))
              v52 = v50 + 1;
            if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
              v53 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v53 = v52;
            v85 = v9;
            if (v53)
              v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v53);
            else
              v54 = 0;
            v65 = (uint64_t *)&v54[8 * v50];
            v66 = &v54[8 * v53];
            v84 = v66;
            *v65 = v36;
            v39 = v65 + 1;
            v83.i64[1] = (uint64_t)(v65 + 1);
            v68 = *(_QWORD **)(a1 + 40);
            v67 = *(_QWORD **)(a1 + 48);
            if (v67 == v68)
            {
              v70 = vdupq_n_s64((unint64_t)v67);
            }
            else
            {
              do
              {
                v69 = *--v67;
                *v67 = 0;
                *--v65 = v69;
              }
              while (v67 != v68);
              v70 = *v8;
              v39 = (_QWORD *)v83.i64[1];
              v66 = v84;
            }
            *(_QWORD *)(a1 + 40) = v65;
            *(_QWORD *)(a1 + 48) = v39;
            v83 = v70;
            v77 = *(char **)(a1 + 56);
            *(_QWORD *)(a1 + 56) = v66;
            v84 = v77;
            v82 = v70.i64[0];
            std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v82);
          }
          else
          {
            *v38 = v35;
            v39 = v38 + 1;
          }
          *(_QWORD *)(a1 + 48) = v39;
LABEL_91:
          v79 = *(v39 - 1);
          if ((PB::Reader::placeMark() & 1) == 0
            || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v79 + 16))(v79, a2) & 1) == 0)
          {
            return 0;
          }
          PB::Reader::recallMark();
LABEL_99:
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0)
            return v4 == 0;
          break;
        case 4u:
          if (v16 >= v2)
          {
            v41 = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v40 = *(unsigned __int8 *)(v12 + v16);
            a2[1] = v16 + 1;
            v41 = v40 != 0;
          }
          *(_BYTE *)(a1 + 72) = v41;
          v59 = *(_DWORD *)(a1 + 8) | 2;
          goto LABEL_98;
        case 5u:
          if (v16 <= 0xFFFFFFFFFFFFFFF5 && v16 + 10 <= v2)
          {
            v30 = 0;
            v31 = 0;
            v32 = 0;
            do
            {
              v33 = v16 + 1;
              a2[1] = v16 + 1;
              v34 = *(_BYTE *)(v12 + v16);
              v32 |= (unint64_t)(v34 & 0x7F) << v30;
              if ((v34 & 0x80) == 0)
                goto LABEL_95;
              v30 += 7;
              v16 = v33;
              v18 = v31++ > 8;
            }
            while (!v18);
LABEL_51:
            LODWORD(v32) = 0;
            goto LABEL_95;
          }
          v46 = 0;
          v47 = 0;
          v32 = 0;
          if (v2 <= v16)
            v2 = v16;
          while (v2 != v16)
          {
            v48 = v16 + 1;
            v49 = *(_BYTE *)(v12 + v16);
            a2[1] = v48;
            v32 |= (unint64_t)(v49 & 0x7F) << v46;
            if ((v49 & 0x80) == 0)
              goto LABEL_95;
            v46 += 7;
            v16 = v48;
            v24 = v47++ >= 9;
            if (v24)
              goto LABEL_51;
          }
          LODWORD(v32) = 0;
          *((_BYTE *)a2 + 24) = 1;
LABEL_95:
          *(_DWORD *)(a1 + 68) = v32;
          v59 = *(_DWORD *)(a1 + 8) | 4;
LABEL_98:
          *(_DWORD *)(a1 + 8) = v59;
          goto LABEL_99;
        default:
          goto LABEL_99;
      }
    }
    v4 = 0;
  }
  return v4 == 0;
}

void sub_206820278(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::SessionServerState::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base **v4;
  const PB::Base **v5;
  const PB::Base *v6;
  const PB::Base **v7;
  const PB::Base **v8;
  const PB::Base *v9;
  int v10;

  v3 = this;
  if ((*(_BYTE *)(this + 8) & 1) != 0)
    this = PB::Writer::writeVarInt(a2);
  v4 = *(const PB::Base ***)(v3 + 16);
  v5 = *(const PB::Base ***)(v3 + 24);
  while (v4 != v5)
  {
    v6 = *v4++;
    this = PB::Writer::writeSubmessage(a2, v6);
  }
  v7 = *(const PB::Base ***)(v3 + 40);
  v8 = *(const PB::Base ***)(v3 + 48);
  while (v7 != v8)
  {
    v9 = *v7++;
    this = PB::Writer::writeSubmessage(a2, v9);
  }
  v10 = *(_DWORD *)(v3 + 8);
  if ((v10 & 2) != 0)
  {
    this = PB::Writer::write(a2);
    v10 = *(_DWORD *)(v3 + 8);
  }
  if ((v10 & 4) != 0)
    return PB::Writer::writeVarInt(a2);
  return this;
}

uint64_t as::server::SessionServerState::formatText(as::server::SessionServerState *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  PB::TextFormatter::beginObject(a2, a3);
  if ((*((_BYTE *)this + 8) & 1) != 0)
    PB::TextFormatter::format(a2, "generationCount");
  v5 = (uint64_t *)*((_QWORD *)this + 2);
  v6 = (uint64_t *)*((_QWORD *)this + 3);
  while (v5 != v6)
  {
    v7 = *v5++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v7 + 32))(v7, a2, "controllers");
  }
  v8 = (uint64_t *)*((_QWORD *)this + 5);
  v9 = (uint64_t *)*((_QWORD *)this + 6);
  while (v8 != v9)
  {
    v10 = *v8++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v10 + 32))(v10, a2, "ports");
  }
  v11 = *((_DWORD *)this + 2);
  if ((v11 & 2) != 0)
  {
    PB::TextFormatter::format(a2, "simulated");
    v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 4) != 0)
    PB::TextFormatter::format(a2, "sessionToken");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionServerState::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a1 + 64) != *(_QWORD *)(a2 + 64)
    || *(unsigned __int8 *)(a1 + 72) != (unint64_t)*(unsigned __int8 *)(a2 + 72))
  {
    return 0;
  }
  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  v7 = (v5 - v6) >> 3;
  if (v7 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 3)
    return 0;
  if (v5 != v6)
  {
    v8 = 0;
    if (v7 <= 1)
      v9 = 1;
    else
      v9 = (v5 - v6) >> 3;
    do
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v8);
      v11 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v8);
      if (v10)
        v12 = v11 == 0;
      else
        v12 = 1;
      if (v12)
      {
        if (v10 | v11)
          return 0;
      }
      else if (!as::server::IOControllerState::operator==(v10, v11))
      {
        return 0;
      }
      ++v8;
    }
    while (v9 != v8);
  }
  v14 = *(_QWORD *)(a1 + 40);
  v13 = *(_QWORD *)(a1 + 48);
  v15 = (v13 - v14) >> 3;
  if (v15 == (uint64_t)(*(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40)) >> 3)
  {
    if (v13 == v14)
    {
      return 1;
    }
    else
    {
      v16 = 0;
      v17 = 0;
      if (v15 <= 1)
        v18 = 1;
      else
        v18 = (v13 - v14) >> 3;
      do
      {
        v19 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v17);
        v20 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v17);
        if (v19)
          v21 = v20 == 0;
        else
          v21 = 1;
        if (v21)
        {
          if (v19 | v20)
            return v16;
        }
        else if (!as::server::VirtualPort::operator==(v19, v20))
        {
          return v16;
        }
        v16 = ++v17 >= v15;
      }
      while (v18 != v17);
    }
  }
  else
  {
    return 0;
  }
  return v16;
}

uint64_t as::server::SessionServerState::addControllers(as::server::SessionServerState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE40F0;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_QWORD *)(result + 128) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::SessionServerState::addPorts(as::server::SessionServerState *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 7);
  v2 = (char *)this + 56;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 5);
      v5 = (_QWORD *)*((_QWORD *)this + 6);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 40);
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3E18;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_WORD *)(result + 48) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::SessionFullState::default_instance(as::server::SessionFullState *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    v3[1] = 0;
    v3[2] = 0;
    *v3 = &off_24BFE4080;
    as::server::SessionFullState::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::server::SessionFullState::default_instance(void)::gInstance;
}

void sub_2068208EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::server::SessionFullState::SessionFullState(_QWORD *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE4080;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE4080;
  return this;
}

as::server::SessionFullState *as::server::SessionFullState::SessionFullState(as::server::SessionFullState *this, const as::server::SessionFullState *a2)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE4080;
  as::server::SessionFullState::copy_from(this, a2);
  return this;
}

{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE4080;
  as::server::SessionFullState::copy_from(this, a2);
  return this;
}

void as::server::SessionFullState::copy_from(as::server::SessionFullState *this, const as::server::SessionFullState *a2)
{
  const as::server::SessionServerState *v4;
  as::server::SessionServerState *v5;
  const as::client::SessionState *v6;
  as::client::SessionState *v7;

  v4 = (const as::server::SessionServerState *)*((_QWORD *)a2 + 1);
  if (v4)
  {
    v5 = (as::server::SessionServerState *)as::server::SessionFullState::mutableServerState(this);
    as::server::SessionServerState::copy_from(v5, v4);
  }
  v6 = (const as::client::SessionState *)*((_QWORD *)a2 + 2);
  if (v6)
  {
    v7 = as::server::SessionFullState::mutableClientState(this);
    as::client::SessionState::operator=(v7, v6);
  }
}

as::server::SessionFullState *as::server::SessionFullState::operator=(as::server::SessionFullState *a1, const as::server::SessionFullState *a2)
{
  as::server::SessionFullState::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::SessionFullState::serverState(as::server::SessionFullState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (!result)
    return as::server::SessionServerState::default_instance(0);
  return result;
}

uint64_t as::server::SessionFullState::mutableServerState(as::server::SessionFullState *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE4160;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 57) = 0u;
    v3 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::SessionFullState::clientState(as::server::SessionFullState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return as::client::SessionState::default_instance(0);
  return result;
}

as::client::SessionState *as::server::SessionFullState::mutableClientState(as::server::SessionFullState *this)
{
  as::client::SessionState *v1;
  double v3;
  uint64_t v4;

  v1 = (as::client::SessionState *)*((_QWORD *)this + 2);
  if (!v1)
  {
    v1 = (as::client::SessionState *)operator new();
    v3 = as::client::SessionState::SessionState(v1);
    v4 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v1;
    if (v4)
      (*(void (**)(uint64_t, double))(*(_QWORD *)v4 + 8))(v4, v3);
  }
  return v1;
}

_QWORD *as::server::SessionFullState::SessionFullState(_QWORD *result, uint64_t a2)
{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE4080;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE4080;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::SessionFullState::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::SessionFullState::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::SessionFullState::clear(as::server::SessionFullState *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

as::client::SessionState *as::server::SessionFullState::isInitialized(as::server::SessionFullState *this)
{
  as::client::SessionState *result;

  result = (as::client::SessionState *)*((_QWORD *)this + 2);
  if (result)
    return (as::client::SessionState *)as::client::SessionState::isInitialized(result);
  return result;
}

BOOL as::server::SessionFullState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v15;
  unsigned int v16;
  unint64_t v17;
  char v18;
  uint64_t v20;
  uint64_t v21;
  double v22;
  uint64_t v23;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    do
    {
      v8 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v15 = 0;
        v16 = 0;
        v11 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v17 = v2 + 1;
          v18 = *(_BYTE *)(v8 + v2);
          a2[1] = v17;
          v11 |= (unint64_t)(v18 & 0x7F) << v15;
          if ((v18 & 0x80) == 0)
            goto LABEL_20;
          v15 += 7;
          v2 = v17;
          if (v16++ >= 9)
          {
LABEL_19:
            v11 = 0;
            goto LABEL_20;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v2 + 1;
        a2[1] = v2 + 1;
        v13 = *(_BYTE *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v2 = v12;
        if (v10++ > 8)
          goto LABEL_19;
      }
LABEL_20:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v11 >> 3) == 2)
      {
        v20 = operator new();
        v22 = as::client::SessionState::SessionState((as::client::SessionState *)v20);
        v23 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v20;
        if (v23)
        {
          (*(void (**)(uint64_t, double))(*(_QWORD *)v23 + 8))(v23, v22);
          v20 = *(_QWORD *)(a1 + 16);
        }
      }
      else
      {
        if ((v11 >> 3) != 1)
          goto LABEL_30;
        v20 = operator new();
        *(_QWORD *)v20 = &off_24BFE4160;
        *(_DWORD *)(v20 + 8) = 0;
        *(_OWORD *)(v20 + 16) = 0u;
        *(_OWORD *)(v20 + 32) = 0u;
        *(_OWORD *)(v20 + 48) = 0u;
        *(_OWORD *)(v20 + 57) = 0u;
        v21 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v20;
        if (v21)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
          v20 = *(_QWORD *)(a1 + 8);
        }
      }
      if (!PB::Reader::placeMark()
        || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v20 + 16))(v20, a2) & 1) == 0)
      {
        return 0;
      }
      PB::Reader::recallMark();
LABEL_30:
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

uint64_t as::server::SessionFullState::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  const PB::Base *v5;

  v3 = this;
  v4 = *(const PB::Base **)(this + 8);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
    return PB::Writer::writeSubmessage(a2, v5);
  return this;
}

uint64_t as::server::SessionFullState::formatText(as::server::SessionFullState *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 1);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "serverState");
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "clientState");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionFullState::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  unint64_t v9;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a2 + 8);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (!(v4 | v5))
      goto LABEL_9;
    return 0;
  }
  if (!as::server::SessionServerState::operator==(v4, v5))
    return 0;
LABEL_9:
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a2 + 16);
  result = (v8 | v9) == 0;
  if (v8)
  {
    if (v9)
      return as::client::SessionState::operator==(*(_QWORD **)(a1 + 16), (_QWORD *)v9);
  }
  return result;
}

uint64_t as::server::SessionFullState::clearServerState(as::server::SessionFullState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::SessionFullState::clearClientState(as::server::SessionFullState *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::VirtualPortList::default_instance(as::server::VirtualPortList *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    *v3 = off_24BFE4010;
    v3[1] = 0;
    v3[2] = 0;
    v3[3] = 0;
    as::server::VirtualPortList::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::server::VirtualPortList::default_instance(void)::gInstance;
}

void sub_206821034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::server::VirtualPortList::VirtualPortList(_QWORD *this)
{
  *this = off_24BFE4010;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = off_24BFE4010;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

as::server::VirtualPortList *as::server::VirtualPortList::VirtualPortList(as::server::VirtualPortList *this, const as::server::VirtualPortList *a2)
{
  *(_QWORD *)this = off_24BFE4010;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::server::VirtualPortList::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = off_24BFE4010;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::server::VirtualPortList::copy_from(this, a2);
  return this;
}

_QWORD *as::server::VirtualPortList::copy_from(_QWORD *this, const as::server::VirtualPortList *a2)
{
  _QWORD *v3;
  as::server::VirtualPort ***v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  const as::server::VirtualPort **v8;
  const as::server::VirtualPort **i;
  as::server::VirtualPort *v10;
  const as::server::VirtualPort *v11;
  unint64_t v12;
  as::server::VirtualPort **v13;
  _QWORD *v14;
  as::server::VirtualPort **v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  as::server::VirtualPort **v21;
  char *v22;
  as::server::VirtualPort *v23;
  __int128 v24;
  char *v25;
  uint64_t v26;
  __int128 v27;
  char *v28;
  _QWORD *v29;

  v3 = this;
  v5 = (_QWORD *)this[1];
  v6 = (_QWORD *)this[2];
  v4 = (as::server::VirtualPort ***)(this + 1);
  while (v6 != v5)
  {
    v7 = (_QWORD *)*--v6;
    this = v7;
    *v6 = 0;
    if (v7)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v3[2] = v5;
  v8 = (const as::server::VirtualPort **)*((_QWORD *)a2 + 1);
  for (i = (const as::server::VirtualPort **)*((_QWORD *)a2 + 2); v8 != i; ++v8)
  {
    v10 = (as::server::VirtualPort *)operator new();
    v11 = *v8;
    *(_QWORD *)v10 = &off_24BFE3E18;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    this = (_QWORD *)as::server::VirtualPort::copy_from(v10, v11);
    v13 = (as::server::VirtualPort **)v3[2];
    v12 = v3[3];
    if ((unint64_t)v13 >= v12)
    {
      v15 = *v4;
      v16 = v13 - *v4;
      v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v18 = v12 - (_QWORD)v15;
      if (v18 >> 2 > v17)
        v17 = v18 >> 2;
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
        v19 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v19 = v17;
      v29 = v3 + 3;
      if (v19)
      {
        v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(v3 + 3), v19);
        v15 = (as::server::VirtualPort **)v3[1];
        v13 = (as::server::VirtualPort **)v3[2];
      }
      else
      {
        v20 = 0;
      }
      v21 = (as::server::VirtualPort **)&v20[8 * v16];
      v22 = &v20[8 * v19];
      v28 = v22;
      *v21 = v10;
      *((_QWORD *)&v27 + 1) = v21 + 1;
      if (v13 == v15)
      {
        v14 = v21 + 1;
      }
      else
      {
        do
        {
          v23 = *--v13;
          *v13 = 0;
          *--v21 = v23;
        }
        while (v13 != v15);
        v14 = (_QWORD *)*((_QWORD *)&v27 + 1);
        v22 = v28;
      }
      v24 = *(_OWORD *)(v3 + 1);
      v3[1] = v21;
      v3[2] = v14;
      v27 = v24;
      v25 = (char *)v3[3];
      v3[3] = v22;
      v28 = v25;
      v26 = v24;
      this = (_QWORD *)std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v26);
    }
    else
    {
      *v13 = v10;
      v14 = v13 + 1;
    }
    v3[2] = v14;
  }
  return this;
}

_QWORD *as::server::VirtualPortList::operator=(_QWORD *a1, const as::server::VirtualPortList *a2)
{
  as::server::VirtualPortList::copy_from(a1, a2);
  return a1;
}

_QWORD *as::server::VirtualPortList::VirtualPortList(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  *result = off_24BFE4010;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  *result = off_24BFE4010;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

_QWORD *as::server::VirtualPortList::move_from(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

_QWORD *as::server::VirtualPortList::operator=(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

_QWORD *as::server::VirtualPortList::clear(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;

  v1 = this;
  v2 = (_QWORD *)this[1];
  v3 = (_QWORD *)this[2];
  while (v3 != v2)
  {
    v4 = (_QWORD *)*--v3;
    this = v4;
    *v3 = 0;
    if (v4)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[2] = v2;
  return this;
}

uint64_t as::server::VirtualPortList::isInitialized(as::server::VirtualPortList *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *((_QWORD *)this + 1);
  v2 = *((_QWORD *)this + 2);
  if (v1 == v2)
    return 1;
  while (1)
  {
    v3 = *(_QWORD *)(*(_QWORD *)v1 + 32);
    if (!v3 || (~*(_DWORD *)(v3 + 8) & 0x7F) != 0 || (~*(_DWORD *)(*(_QWORD *)v1 + 8) & 3) != 0)
      break;
    v1 += 8;
    if (v1 == v2)
      return 1;
  }
  return 0;
}

BOOL as::server::VirtualPortList::readFrom(_QWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  char v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  char v21;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  char *v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  int64x2_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v43;
  int64x2_t v44;
  char *v45;
  uint64_t v46;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v4 = 0;
    v8 = (int64x2_t *)(a1 + 1);
    v9 = (uint64_t)(a1 + 3);
    while (1)
    {
      v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        break;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v3 + 1;
        a2[1] = v3 + 1;
        v15 = *(_BYTE *)(v10 + v3);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v3 = v14;
        if (v12++ > 8)
        {
          v13 = 0;
          break;
        }
      }
      v3 = v14;
LABEL_24:
      if ((v13 & 7) == 4)
        return v4 == 0;
      if ((v13 & 0x7FFFFFFF8) == 8)
      {
        v23 = operator new();
        v24 = v23;
        *(_QWORD *)v23 = &off_24BFE3E18;
        *(_DWORD *)(v23 + 8) = 0;
        *(_OWORD *)(v23 + 16) = 0u;
        *(_OWORD *)(v23 + 32) = 0u;
        *(_WORD *)(v23 + 48) = 0;
        v26 = (uint64_t *)a1[2];
        v25 = a1[3];
        if ((unint64_t)v26 >= v25)
        {
          v29 = ((uint64_t)v26 - v8->i64[0]) >> 3;
          if ((unint64_t)(v29 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v30 = v25 - v8->i64[0];
          v31 = v30 >> 2;
          if (v30 >> 2 <= (unint64_t)(v29 + 1))
            v31 = v29 + 1;
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
            v32 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          v46 = v9;
          if (v32)
            v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v32);
          else
            v33 = 0;
          v34 = (uint64_t *)&v33[8 * v29];
          v35 = &v33[8 * v32];
          v45 = v35;
          *v34 = v24;
          v27 = v34 + 1;
          v44.i64[1] = (uint64_t)(v34 + 1);
          v37 = (_QWORD *)a1[1];
          v36 = (_QWORD *)a1[2];
          if (v36 == v37)
          {
            v39 = vdupq_n_s64((unint64_t)v36);
          }
          else
          {
            do
            {
              v38 = *--v36;
              *v36 = 0;
              *--v34 = v38;
            }
            while (v36 != v37);
            v39 = *v8;
            v27 = (_QWORD *)v44.i64[1];
            v35 = v45;
          }
          a1[1] = v34;
          a1[2] = v27;
          v44 = v39;
          v40 = (char *)a1[3];
          a1[3] = v35;
          v45 = v40;
          v43 = v39.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v43);
        }
        else
        {
          *v26 = v23;
          v27 = v26 + 1;
        }
        a1[2] = v27;
        v41 = *(v27 - 1);
        if ((PB::Reader::placeMark() & 1) == 0
          || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v41 + 16))(v41, a2) & 1) == 0)
        {
          return 0;
        }
        PB::Reader::recallMark();
        v3 = a2[1];
        v2 = a2[2];
        v4 = *((unsigned __int8 *)a2 + 24);
        v28 = v4;
      }
      else
      {
        v28 = 0;
      }
      if (v3 >= v2 || v28)
        return v4 == 0;
    }
    v17 = 0;
    v18 = 0;
    v13 = 0;
    if (v3 <= v2)
      v19 = v2;
    else
      v19 = v3;
    while (v19 != v3)
    {
      v20 = v3++;
      v21 = *(_BYTE *)(v10 + v20);
      a2[1] = v3;
      v13 |= (unint64_t)(v21 & 0x7F) << v17;
      if ((v21 & 0x80) == 0)
        goto LABEL_23;
      v17 += 7;
      if (v18++ >= 9)
      {
        v13 = 0;
LABEL_23:
        v3 = v20 + 1;
        goto LABEL_24;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_206821700(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::VirtualPortList::writeTo(uint64_t this, PB::Writer *a2)
{
  const PB::Base **v2;
  const PB::Base **i;
  const PB::Base *v5;

  v2 = *(const PB::Base ***)(this + 8);
  for (i = *(const PB::Base ***)(this + 16); v2 != i; this = PB::Writer::writeSubmessage(a2, v5))
    v5 = *v2++;
  return this;
}

uint64_t as::server::VirtualPortList::formatText(as::server::VirtualPortList *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = (uint64_t *)*((_QWORD *)this + 1);
  v6 = (uint64_t *)*((_QWORD *)this + 2);
  while (v5 != v6)
  {
    v7 = *v5++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v7 + 32))(v7, a2, "ports");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::VirtualPortList::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v4 = (v2 - v3) >> 3;
  if (v4 == (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3)
  {
    if (v2 == v3)
    {
      return 1;
    }
    else
    {
      v7 = 0;
      v8 = 0;
      if (v4 <= 1)
        v9 = 1;
      else
        v9 = (v2 - v3) >> 3;
      do
      {
        v10 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v8);
        v11 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v8);
        if (v10)
          v12 = v11 == 0;
        else
          v12 = 1;
        if (v12)
        {
          if (v10 | v11)
            return v7;
        }
        else if (!as::server::VirtualPort::operator==(v10, v11))
        {
          return v7;
        }
        v7 = ++v8 >= v4;
      }
      while (v9 != v8);
    }
  }
  else
  {
    return 0;
  }
  return v7;
}

uint64_t as::server::VirtualPortList::addPorts(as::server::VirtualPortList *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 3);
  v2 = (char *)this + 24;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 1);
      v5 = (_QWORD *)*((_QWORD *)this + 2);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 8);
    *((_QWORD *)this + 1) = v13;
    *((_QWORD *)this + 2) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 2) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3E18;
  *(_DWORD *)(result + 8) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_WORD *)(result + 48) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::server::EligiblePortList::default_instance(as::server::EligiblePortList *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    v3[1] = 0;
    v3[2] = 0;
    *v3 = &off_24BFE4048;
    as::server::EligiblePortList::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::server::EligiblePortList::default_instance(void)::gInstance;
}

void sub_206821A68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::server::EligiblePortList::EligiblePortList(_QWORD *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE4048;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &off_24BFE4048;
  return this;
}

as::server::EligiblePortList *as::server::EligiblePortList::EligiblePortList(as::server::EligiblePortList *this, const as::server::EligiblePortList *a2)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE4048;
  as::server::EligiblePortList::copy_from(this, a2);
  return this;
}

{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24BFE4048;
  as::server::EligiblePortList::copy_from(this, a2);
  return this;
}

as::server::EligiblePortList *as::server::EligiblePortList::copy_from(as::server::EligiblePortList *this, const as::server::EligiblePortList *a2)
{
  as::server::EligiblePortList *v3;
  const as::server::VirtualPortList *v4;
  _QWORD *v5;
  const as::server::VirtualPortList *v6;
  _QWORD *v7;

  v3 = this;
  v4 = (const as::server::VirtualPortList *)*((_QWORD *)a2 + 1);
  if (v4)
  {
    v5 = as::server::EligiblePortList::mutableStandardPorts(this);
    this = (as::server::EligiblePortList *)as::server::VirtualPortList::copy_from(v5, v4);
  }
  v6 = (const as::server::VirtualPortList *)*((_QWORD *)a2 + 2);
  if (v6)
  {
    v7 = as::server::EligiblePortList::mutableDecoupledPorts(v3);
    return (as::server::EligiblePortList *)as::server::VirtualPortList::copy_from(v7, v6);
  }
  return this;
}

as::server::EligiblePortList *as::server::EligiblePortList::operator=(as::server::EligiblePortList *a1, const as::server::EligiblePortList *a2)
{
  as::server::EligiblePortList::copy_from(a1, a2);
  return a1;
}

uint64_t as::server::EligiblePortList::standardPorts(as::server::EligiblePortList *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (!result)
    return as::server::VirtualPortList::default_instance(0);
  return result;
}

_QWORD *as::server::EligiblePortList::mutableStandardPorts(as::server::EligiblePortList *this)
{
  _QWORD *v1;
  uint64_t v3;

  v1 = (_QWORD *)*((_QWORD *)this + 1);
  if (!v1)
  {
    v1 = (_QWORD *)operator new();
    *v1 = off_24BFE4010;
    v1[1] = 0;
    v1[2] = 0;
    v1[3] = 0;
    v3 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::server::EligiblePortList::decoupledPorts(as::server::EligiblePortList *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return as::server::VirtualPortList::default_instance(0);
  return result;
}

_QWORD *as::server::EligiblePortList::mutableDecoupledPorts(as::server::EligiblePortList *this)
{
  _QWORD *v1;
  uint64_t v3;

  v1 = (_QWORD *)*((_QWORD *)this + 2);
  if (!v1)
  {
    v1 = (_QWORD *)operator new();
    *v1 = off_24BFE4010;
    v1[1] = 0;
    v1[2] = 0;
    v1[3] = 0;
    v3 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

_QWORD *as::server::EligiblePortList::EligiblePortList(_QWORD *result, uint64_t a2)
{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE4048;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *result = &off_24BFE4048;
  result[1] = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v2 = result[2];
  result[2] = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::EligiblePortList::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::EligiblePortList::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::EligiblePortList::clear(as::server::EligiblePortList *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::EligiblePortList::isInitialized(as::server::EligiblePortList *this)
{
  return 1;
}

BOOL as::server::EligiblePortList::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  char v15;
  unsigned int v16;
  unint64_t v17;
  char v18;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    do
    {
      v8 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v15 = 0;
        v16 = 0;
        v11 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v17 = v2 + 1;
          v18 = *(_BYTE *)(v8 + v2);
          a2[1] = v17;
          v11 |= (unint64_t)(v18 & 0x7F) << v15;
          if ((v18 & 0x80) == 0)
            goto LABEL_20;
          v15 += 7;
          v2 = v17;
          if (v16++ >= 9)
          {
LABEL_19:
            v11 = 0;
            goto LABEL_20;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v2 + 1;
        a2[1] = v2 + 1;
        v13 = *(_BYTE *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v2 = v12;
        if (v10++ > 8)
          goto LABEL_19;
      }
LABEL_20:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v11 >> 3) == 2)
      {
        v20 = (_QWORD *)operator new();
        *v20 = off_24BFE4010;
        v20[1] = 0;
        v20[2] = 0;
        v20[3] = 0;
        v22 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v20;
        if (v22)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
          v20 = *(_QWORD **)(a1 + 16);
        }
      }
      else
      {
        if ((v11 >> 3) != 1)
          goto LABEL_30;
        v20 = (_QWORD *)operator new();
        *v20 = off_24BFE4010;
        v20[1] = 0;
        v20[2] = 0;
        v20[3] = 0;
        v21 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = v20;
        if (v21)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
          v20 = *(_QWORD **)(a1 + 8);
        }
      }
      if (!PB::Reader::placeMark()
        || ((*(uint64_t (**)(_QWORD *, uint64_t *))(*v20 + 16))(v20, a2) & 1) == 0)
      {
        return 0;
      }
      PB::Reader::recallMark();
LABEL_30:
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

uint64_t as::server::EligiblePortList::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  const PB::Base *v5;

  v3 = this;
  v4 = *(const PB::Base **)(this + 8);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
    return PB::Writer::writeSubmessage(a2, v5);
  return this;
}

uint64_t as::server::EligiblePortList::formatText(as::server::EligiblePortList *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 1);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "standardPorts");
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "decoupledPorts");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::EligiblePortList::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a2 + 8);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (!(v4 | v5))
      goto LABEL_9;
    return 0;
  }
  if (!as::server::VirtualPortList::operator==(v4, v5))
    return 0;
LABEL_9:
  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a2 + 16);
  result = (v8 | v9) == 0;
  if (v8)
  {
    if (v9)
      return as::server::VirtualPortList::operator==(*(_QWORD *)(a1 + 16), v9);
  }
  return result;
}

uint64_t as::server::EligiblePortList::clearStandardPorts(as::server::EligiblePortList *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::EligiblePortList::clearDecoupledPorts(as::server::EligiblePortList *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::server::SessionTokenList::default_instance(as::server::SessionTokenList *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    *v3 = &off_24BFE40B8;
    v3[1] = 0;
    v3[2] = 0;
    v3[3] = 0;
    as::server::SessionTokenList::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::server::SessionTokenList::default_instance(void)::gInstance;
}

void sub_206822198(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::server::SessionTokenList::SessionTokenList(_QWORD *this)
{
  *this = &off_24BFE40B8;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = &off_24BFE40B8;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

as::server::SessionTokenList *as::server::SessionTokenList::SessionTokenList(as::server::SessionTokenList *this, const as::server::SessionTokenList *a2)
{
  *(_QWORD *)this = &off_24BFE40B8;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::server::SessionTokenList::copy_from((char *)this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE40B8;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::server::SessionTokenList::copy_from((char *)this, a2);
  return this;
}

char *as::server::SessionTokenList::copy_from(char *this, const as::server::SessionTokenList *a2)
{
  if (this != (char *)a2)
    return std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(this + 8, *((char **)a2 + 1), *((_QWORD *)a2 + 2), (uint64_t)(*((_QWORD *)a2 + 2) - *((_QWORD *)a2 + 1)) >> 2);
  return this;
}

char *as::server::SessionTokenList::operator=(char *a1, const as::server::SessionTokenList *a2)
{
  as::server::SessionTokenList::copy_from(a1, a2);
  return a1;
}

_QWORD *as::server::SessionTokenList::SessionTokenList(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  *result = &off_24BFE40B8;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  *result = &off_24BFE40B8;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

_QWORD *as::server::SessionTokenList::move_from(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

_QWORD *as::server::SessionTokenList::operator=(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

uint64_t as::server::SessionTokenList::clear(uint64_t this)
{
  *(_QWORD *)(this + 16) = *(_QWORD *)(this + 8);
  return this;
}

uint64_t as::server::SessionTokenList::isInitialized(as::server::SessionTokenList *this)
{
  return 1;
}

BOOL as::server::SessionTokenList::readFrom(_QWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  void **v8;
  _QWORD *v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  char v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  int v31;
  unint64_t v32;
  uint64_t v33;
  char v34;
  unsigned int v35;
  uint64_t v36;
  BOOL v37;
  unint64_t v38;
  char v39;
  char v40;
  int v41;
  unint64_t v42;
  char *v43;
  _DWORD *v44;
  char *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  int v52;
  unint64_t v53;
  uint64_t v54;
  char v55;
  unsigned int v56;
  uint64_t v57;
  unint64_t v59;
  char v60;
  char v61;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v4 = 0;
    v8 = (void **)(a1 + 1);
    v9 = a1 + 3;
    while (1)
    {
      v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        break;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v3 + 1;
        a2[1] = v3 + 1;
        v15 = *(_BYTE *)(v10 + v3);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v3 = v14;
        v37 = v12++ > 8;
        if (v37)
        {
          v13 = 0;
          break;
        }
      }
      v3 = v14;
LABEL_24:
      if ((v13 & 7) == 4)
        return v4 == 0;
      if ((v13 & 0x7FFFFFFF8) == 8)
      {
        if ((v13 & 7) == 2)
        {
          if ((PB::Reader::placeMark() & 1) != 0)
            return 0;
          v3 = a2[1];
          v2 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 < v2 && !*((_BYTE *)a2 + 24))
          {
            v22 = (char *)a1[2];
            do
            {
              if ((unint64_t)v22 >= *v9)
              {
                v23 = (char *)*v8;
                v24 = (v22 - (_BYTE *)*v8) >> 2;
                v25 = v24 + 1;
                if ((unint64_t)(v24 + 1) >> 62)
                  goto LABEL_119;
                v26 = *v9 - (_QWORD)v23;
                if (v26 >> 1 > v25)
                  v25 = v26 >> 1;
                if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
                  v27 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v27 = v25;
                if (v27)
                {
                  v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v27);
                  v23 = (char *)a1[1];
                  v22 = (char *)a1[2];
                }
                else
                {
                  v28 = 0;
                }
                v29 = &v28[4 * v24];
                *(_DWORD *)v29 = 0;
                v30 = v29 + 4;
                while (v22 != v23)
                {
                  v31 = *((_DWORD *)v22 - 1);
                  v22 -= 4;
                  *((_DWORD *)v29 - 1) = v31;
                  v29 -= 4;
                }
                a1[1] = v29;
                a1[2] = v30;
                a1[3] = &v28[4 * v27];
                if (v23)
                  operator delete(v23);
                v22 = v30;
              }
              else
              {
                *(_DWORD *)v22 = 0;
                v22 += 4;
              }
              a1[2] = v22;
              v32 = a2[1];
              v2 = a2[2];
              v33 = *a2;
              v34 = 0;
              v35 = 0;
              v36 = 0;
              v37 = v32 > 0xFFFFFFFFFFFFFFF5 || v32 + 10 > v2;
              if (!v37)
              {
                while (1)
                {
                  v3 = v32 + 1;
                  a2[1] = v32 + 1;
                  v40 = *(_BYTE *)(v33 + v32);
                  v36 |= (unint64_t)(v40 & 0x7F) << v34;
                  if ((v40 & 0x80) == 0)
                    goto LABEL_68;
                  v34 += 7;
                  v32 = v3;
                  v37 = v35++ > 8;
                  if (v37)
                  {
                    LODWORD(v36) = 0;
                    goto LABEL_68;
                  }
                }
              }
              if (v2 <= v32)
                v3 = a2[1];
              else
                v3 = a2[2];
              while (1)
              {
                if (v3 == v32)
                {
                  v4 = 1;
                  *((_BYTE *)a2 + 24) = 1;
                  *((_DWORD *)v22 - 1) = 0;
                  goto LABEL_111;
                }
                v38 = v32++;
                v39 = *(_BYTE *)(v33 + v38);
                a2[1] = v32;
                v36 |= (unint64_t)(v39 & 0x7F) << v34;
                if ((v39 & 0x80) == 0)
                  break;
                v34 += 7;
                v37 = v35++ > 8;
                if (v37)
                {
                  LODWORD(v36) = 0;
                  goto LABEL_67;
                }
              }
              if (*((_BYTE *)a2 + 24))
                LODWORD(v36) = 0;
LABEL_67:
              v3 = v38 + 1;
LABEL_68:
              *((_DWORD *)v22 - 1) = v36;
              v4 = *((unsigned __int8 *)a2 + 24);
            }
            while (v3 < v2 && !*((_BYTE *)a2 + 24));
          }
        }
        else
        {
          v43 = (char *)a1[2];
          v42 = a1[3];
          if ((unint64_t)v43 >= v42)
          {
            v45 = (char *)*v8;
            v46 = (v43 - (_BYTE *)*v8) >> 2;
            v47 = v46 + 1;
            if ((unint64_t)(v46 + 1) >> 62)
LABEL_119:
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v48 = v42 - (_QWORD)v45;
            if (v48 >> 1 > v47)
              v47 = v48 >> 1;
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL)
              v49 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v49 = v47;
            if (v49)
            {
              v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v49);
              v45 = (char *)a1[1];
              v43 = (char *)a1[2];
            }
            else
            {
              v50 = 0;
            }
            v51 = &v50[4 * v46];
            *(_DWORD *)v51 = 0;
            v44 = v51 + 4;
            while (v43 != v45)
            {
              v52 = *((_DWORD *)v43 - 1);
              v43 -= 4;
              *((_DWORD *)v51 - 1) = v52;
              v51 -= 4;
            }
            a1[1] = v51;
            a1[2] = v44;
            a1[3] = &v50[4 * v49];
            if (v45)
              operator delete(v45);
          }
          else
          {
            *(_DWORD *)v43 = 0;
            v44 = v43 + 4;
          }
          a1[2] = v44;
          v53 = a2[1];
          v2 = a2[2];
          v54 = *a2;
          v55 = 0;
          v56 = 0;
          v57 = 0;
          if (v53 > 0xFFFFFFFFFFFFFFF5 || v53 + 10 > v2)
          {
            if (v2 <= v53)
              v3 = a2[1];
            else
              v3 = a2[2];
            while (1)
            {
              if (v3 == v53)
              {
                LODWORD(v57) = 0;
                *((_BYTE *)a2 + 24) = 1;
                goto LABEL_110;
              }
              v59 = v53++;
              v60 = *(_BYTE *)(v54 + v59);
              a2[1] = v53;
              v57 |= (unint64_t)(v60 & 0x7F) << v55;
              if ((v60 & 0x80) == 0)
                break;
              v55 += 7;
              v37 = v56++ > 8;
              if (v37)
              {
                LODWORD(v57) = 0;
                goto LABEL_109;
              }
            }
            if (*((_BYTE *)a2 + 24))
              LODWORD(v57) = 0;
LABEL_109:
            v3 = v59 + 1;
          }
          else
          {
            while (1)
            {
              v3 = v53 + 1;
              a2[1] = v53 + 1;
              v61 = *(_BYTE *)(v54 + v53);
              v57 |= (unint64_t)(v61 & 0x7F) << v55;
              if ((v61 & 0x80) == 0)
                break;
              v55 += 7;
              v53 = v3;
              v37 = v56++ > 8;
              if (v37)
              {
                LODWORD(v57) = 0;
                break;
              }
            }
          }
LABEL_110:
          *(v44 - 1) = v57;
          v4 = *((unsigned __int8 *)a2 + 24);
        }
LABEL_111:
        v41 = v4;
      }
      else
      {
        v41 = 0;
      }
      if (v3 >= v2 || v41)
        return v4 == 0;
    }
    v16 = 0;
    v17 = 0;
    v13 = 0;
    if (v3 <= v2)
      v18 = v2;
    else
      v18 = v3;
    while (v18 != v3)
    {
      v19 = v3++;
      v20 = *(_BYTE *)(v10 + v19);
      a2[1] = v3;
      v13 |= (unint64_t)(v20 & 0x7F) << v16;
      if ((v20 & 0x80) == 0)
        goto LABEL_23;
      v16 += 7;
      if (v17++ >= 9)
      {
        v13 = 0;
LABEL_23:
        v3 = v19 + 1;
        goto LABEL_24;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::SessionTokenList::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v2;
  uint64_t i;

  v2 = *(_QWORD *)(this + 8);
  for (i = *(_QWORD *)(this + 16); v2 != i; this = PB::Writer::writeVarInt(a2))
    v2 += 4;
  return this;
}

uint64_t as::server::SessionTokenList::formatText(as::server::SessionTokenList *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t v6;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 1);
  v6 = *((_QWORD *)this + 2);
  while (v5 != v6)
  {
    v5 += 4;
    PB::TextFormatter::format(a2, "tokens");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionTokenList::operator==(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  _DWORD *v3;
  unint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = *(_DWORD **)(a1 + 16);
  v4 = v3 - v2;
  v5 = *(_DWORD **)(a2 + 8);
  if (v4 != (uint64_t)(*(_QWORD *)(a2 + 16) - (_QWORD)v5) >> 2)
    return 0;
  if (v3 == v2)
    return 1;
  v6 = v4 <= 1 ? 1 : v3 - v2;
  if (*v2 != *v5)
    return 0;
  v7 = 1;
  do
  {
    v8 = v7;
    if (v6 == v7)
      break;
    v9 = v2[v7];
    v10 = v5[v7++];
  }
  while (v9 == v10);
  return v8 >= v4;
}

void as::server::HardwareInfo::~HardwareInfo(as::server::HardwareInfo *this)
{
  as::server::HardwareInfo::~HardwareInfo(this);
  JUMPOUT(0x20BCFDE58);
}

{
  *(_QWORD *)this = &off_24BFE3EC0;
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 48));
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 32));
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::Clock::~Clock(as::server::Clock *this)
{
  as::server::Clock::~Clock(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE4358;
  v2 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  caulk::xstring::clear((as::server::Clock *)((char *)this + 80));
  caulk::xstring::clear((as::server::Clock *)((char *)this + 64));
  v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::HWStream::~HWStream(as::server::HWStream *this)
{
  as::server::HWStream::~HWStream(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;

  *(_QWORD *)this = &off_24BFE4438;
  v2 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v5);
  PB::Base::~Base(this);
}

void as::server::Device::~Device(as::server::Device *this)
{
  as::server::Device::~Device(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE4390;
  v2 = (void **)((char *)this + 16);
  v3 = (void **)((char *)this + 88);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = v2;
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::Device_Clock::~Device_Clock(as::server::Device_Clock *this)
{
  as::server::Device_Clock::~Device_Clock(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24BFE3E88;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  PB::Base::~Base(this);
}

void as::server::Box::~Box(as::server::Box *this)
{
  as::server::Box::~Box(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void *v3;
  void *v4;
  void **v5;

  *(_QWORD *)this = &off_24BFE42E8;
  v2 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
  {
    *((_QWORD *)this + 6) = v4;
    operator delete(v4);
  }
  v5 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v5);
  PB::Base::~Base(this);
}

void as::server::Driver::~Driver(as::server::Driver *this)
{
  as::server::Driver::~Driver(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE43C8;
  v2 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  caulk::xstring::clear((as::server::Driver *)((char *)this + 88));
  v3 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::HardwareSystemState::~HardwareSystemState(as::server::HardwareSystemState *this)
{
  as::server::HardwareSystemState::~HardwareSystemState(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE41D0;
  v2 = (void **)((char *)this + 8);
  v3 = (void **)((char *)this + 32);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = v2;
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::SelectorControlItem::~SelectorControlItem(as::server::SelectorControlItem *this)
{
  as::server::SelectorControlItem::~SelectorControlItem(this);
  JUMPOUT(0x20BCFDE58);
}

{
  *(_QWORD *)this = &off_24BFE4208;
  caulk::xstring::clear((as::server::SelectorControlItem *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::ControlValue::~ControlValue(as::server::ControlValue *this)
{
  as::server::ControlValue::~ControlValue(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void *v2;

  *(_QWORD *)this = &off_24BFE3E50;
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  PB::Base::~Base(this);
}

void as::server::Control::~Control(as::server::Control *this)
{
  void **v2;

  *(_QWORD *)this = off_24BFE4400;
  v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

{
  void **v2;

  *(_QWORD *)this = off_24BFE4400;
  v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
  MEMORY[0x20BCFDE58]();
}

void as::server::ControlAndValue::~ControlAndValue(as::server::ControlAndValue *this)
{
  as::server::ControlAndValue::~ControlAndValue(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24BFE3FA0;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  PB::Base::~Base(this);
}

void as::server::IOStreamState::~IOStreamState(as::server::IOStreamState *this)
{
  as::server::IOStreamState::~IOStreamState(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE3F30;
  v2 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::PortInvariants::~PortInvariants(as::server::PortInvariants *this)
{
  as::server::PortInvariants::~PortInvariants(this);
  JUMPOUT(0x20BCFDE58);
}

{
  *(_QWORD *)this = &off_24BFE3F68;
  caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 32));
  caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::Port::~Port(as::server::Port *this)
{
  as::server::Port::~Port(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)this = &off_24BFE4320;
  v2 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  caulk::xstring::clear((as::server::Port *)((char *)this + 104));
  caulk::xstring::clear((as::server::Port *)((char *)this + 88));
  v4 = (void **)((char *)this + 64);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v4);
  v4 = (void **)((char *)this + 40);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v4);
  v4 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v4);
  PB::Base::~Base(this);
}

void as::server::SessionUpdateSummary::~SessionUpdateSummary(as::server::SessionUpdateSummary *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x20BCFDE58);
}

void as::server::ConfigChangeSummary::~ConfigChangeSummary(as::server::ConfigChangeSummary *this)
{
  as::server::ConfigChangeSummary::~ConfigChangeSummary(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE4198;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::CustomPropertyAddress::~CustomPropertyAddress(as::server::CustomPropertyAddress *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x20BCFDE58);
}

void as::server::ObjectDescription::~ObjectDescription(as::server::ObjectDescription *this)
{
  as::server::ObjectDescription::~ObjectDescription(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)this = &off_24BFE4128;
  v2 = *((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v8)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  v9 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v10 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v11 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  PB::Base::~Base(this);
}

void as::server::ChangedObject::~ChangedObject(as::server::ChangedObject *this)
{
  as::server::ChangedObject::~ChangedObject(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE3EF8;
  v2 = *((_QWORD *)this + 16);
  *((_QWORD *)this + 16) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)((char *)this + 104);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 80);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 56);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 32);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 8);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::VirtualPort::~VirtualPort(as::server::VirtualPort *this)
{
  as::server::VirtualPort::~VirtualPort(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24BFE3E18;
  v2 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  caulk::xstring::clear((as::server::VirtualPort *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::MicrophoneConfiguration::~MicrophoneConfiguration(as::server::MicrophoneConfiguration *this)
{
  as::server::MicrophoneConfiguration::~MicrophoneConfiguration(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void *v2;

  *(_QWORD *)this = &off_24BFE42B0;
  caulk::xstring::clear((as::server::MicrophoneConfiguration *)((char *)this + 40));
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  PB::Base::~Base(this);
}

void as::server::IOControllerState::~IOControllerState(as::server::IOControllerState *this)
{
  as::server::IOControllerState::~IOControllerState(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;

  *(_QWORD *)this = &off_24BFE40F0;
  caulk::xstring::clear((as::server::IOControllerState *)((char *)this + 88));
  v2 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::server::PlatformSupport::~PlatformSupport(as::server::PlatformSupport *this)
{
  as::server::PlatformSupport::~PlatformSupport(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE3FD8;
  v2 = (void **)((char *)this + 8);
  v3 = (void **)((char *)this + 32);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = v2;
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::SessionServerState::~SessionServerState(as::server::SessionServerState *this)
{
  as::server::SessionServerState::~SessionServerState(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE4160;
  v2 = (void **)((char *)this + 16);
  v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = v2;
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::SessionFullState::~SessionFullState(as::server::SessionFullState *this)
{
  as::server::SessionFullState::~SessionFullState(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24BFE4080;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  PB::Base::~Base(this);
}

void as::server::VirtualPortList::~VirtualPortList(as::server::VirtualPortList *this)
{
  void **v2;

  *(_QWORD *)this = off_24BFE4010;
  v2 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

{
  void **v2;

  *(_QWORD *)this = off_24BFE4010;
  v2 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
  MEMORY[0x20BCFDE58]();
}

void as::server::EligiblePortList::~EligiblePortList(as::server::EligiblePortList *this)
{
  as::server::EligiblePortList::~EligiblePortList(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24BFE4048;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  PB::Base::~Base(this);
}

void as::server::SessionTokenList::~SessionTokenList(as::server::SessionTokenList *this)
{
  as::server::SessionTokenList::~SessionTokenList(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void *v2;

  *(_QWORD *)this = &off_24BFE40B8;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  PB::Base::~Base(this);
}

char *std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned long long>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned long long>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

char *std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned int>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned int>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

uint64_t as::smipc_Server_types_utility::updateDefaultRoute(as::smipc_Server_types_utility *this, const as::RouteIdentifier *a2, as::server::HardwareSystemState *a3)
{
  uint64_t result;
  uint64_t *v6;
  uint64_t *v7;
  as::RouteIdentifier *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;

  result = as::RouteIdentifier::isInitialized(this);
  if ((result & 1) == 0)
    as::smipc_Server_types_utility::updateDefaultRoute();
  v7 = (uint64_t *)*((_QWORD *)a2 + 4);
  v6 = (uint64_t *)*((_QWORD *)a2 + 5);
  if (v7 != v6)
  {
    while (*(_DWORD *)(*v7 + 24) != *((_DWORD *)this + 6))
    {
      if (++v7 == v6)
        goto LABEL_9;
    }
  }
  if (v7 == v6)
  {
LABEL_9:
    if (*((_QWORD *)this + 2))
    {
      v8 = (as::RouteIdentifier *)as::server::HardwareSystemState::addDefaultRoutes(a2);
      return (uint64_t)as::RouteIdentifier::operator=(v8, this);
    }
  }
  else
  {
    if (*((_QWORD *)this + 2))
    {
      v8 = (as::RouteIdentifier *)*v7;
      return (uint64_t)as::RouteIdentifier::operator=(v8, this);
    }
    result = (uint64_t)std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,0>(v7 + 1, v6, v7);
    v10 = v9;
    v11 = (_QWORD *)*((_QWORD *)a2 + 5);
    if (v11 != v9)
    {
      do
      {
        v12 = *--v11;
        result = v12;
        *v11 = 0;
        if (v12)
          result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
      }
      while (v11 != v10);
    }
    *((_QWORD *)a2 + 5) = v10;
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      v6 = *v4;
      *v4 = 0;
      v7 = *a3;
      *a3 = v6;
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      ++v4;
      ++a3;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

void as::SetServerXPCListenerEndpoint(id obj, NSXPCListenerEndpoint *a2)
{
}

uint64_t as::ChannelDescription::default_instance(as::ChannelDescription *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    *v3 = &off_24BFE3B90;
    v3[1] = 0;
    v3[2] = 0;
    v3[3] = 0;
    as::ChannelDescription::default_instance(void)::gInstance = (uint64_t)v3;
  }
  return as::ChannelDescription::default_instance(void)::gInstance;
}

void sub_206823E34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *as::ChannelDescription::ChannelDescription(_QWORD *this)
{
  *this = &off_24BFE3B90;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = &off_24BFE3B90;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

__n128 as::ChannelDescription::ChannelDescription(as::ChannelDescription *this, const as::ChannelDescription *a2)
{
  __n128 result;

  *(_QWORD *)this = &off_24BFE3B90;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 12);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

{
  __n128 result;

  *(_QWORD *)this = &off_24BFE3B90;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 12);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::ChannelDescription::copy_from(as::ChannelDescription *this, const as::ChannelDescription *a2)
{
  __n128 result;

  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 12);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::ChannelDescription::operator=(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::ChannelDescription::ChannelDescription(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a1 = &off_24BFE3B90;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(_QWORD *)a1 = &off_24BFE3B90;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::ChannelDescription::move_from(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

_QWORD *as::ChannelDescription::clear(_QWORD *this)
{
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

uint64_t as::ChannelDescription::isInitialized(as::ChannelDescription *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::ChannelDescription::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v6;
  char v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  BOOL v12;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  BOOL v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  char v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  char v26;
  char v27;
  unsigned int v28;
  unint64_t v29;
  char v30;
  char v31;
  unsigned int v32;
  unint64_t v33;
  char v34;
  int v35;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (2)
    {
      v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v13 = 0;
        v14 = 0;
        v9 = 0;
        if (v2 <= v3)
          v15 = v3;
        else
          v15 = v2;
        while (v15 != v2)
        {
          v16 = v2++;
          v17 = *(_BYTE *)(v6 + v16);
          a2[1] = v2;
          v9 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0)
            goto LABEL_22;
          v13 += 7;
          v18 = v14++ >= 9;
          if (v18)
          {
            v9 = 0;
LABEL_22:
            v2 = v16 + 1;
            goto LABEL_23;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
      }
      else
      {
        v7 = 0;
        v8 = 0;
        v9 = 0;
        while (1)
        {
          v10 = v2 + 1;
          a2[1] = v2 + 1;
          v11 = *(_BYTE *)(v6 + v2);
          v9 |= (unint64_t)(v11 & 0x7F) << v7;
          if ((v11 & 0x80) == 0)
            break;
          v7 += 7;
          v2 = v10;
          v12 = v8++ > 8;
          if (v12)
          {
            v9 = 0;
            break;
          }
        }
        v2 = v10;
LABEL_23:
        if ((v9 & 7) != 4)
        {
          switch((v9 >> 3))
          {
            case 1u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                v27 = 0;
                v28 = 0;
                v21 = 0;
                if (v3 <= v2)
                  v3 = v2;
                do
                {
                  if (v3 == v2)
                  {
                    LODWORD(v21) = 0;
                    *((_BYTE *)a2 + 24) = 1;
                    goto LABEL_71;
                  }
                  v29 = v2++;
                  v30 = *(_BYTE *)(v6 + v29);
                  a2[1] = v2;
                  v21 |= (unint64_t)(v30 & 0x7F) << v27;
                  if ((v30 & 0x80) == 0)
                    goto LABEL_55;
                  v27 += 7;
                  v18 = v28++ >= 9;
                }
                while (!v18);
                LODWORD(v21) = 0;
LABEL_55:
                v3 = v29 + 1;
              }
              else
              {
                v19 = 0;
                v20 = 0;
                v21 = 0;
                do
                {
                  v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  v22 = *(_BYTE *)(v6 + v2);
                  v21 |= (unint64_t)(v22 & 0x7F) << v19;
                  if ((v22 & 0x80) == 0)
                    goto LABEL_71;
                  v19 += 7;
                  v2 = v3;
                  v12 = v20++ > 8;
                }
                while (!v12);
                LODWORD(v21) = 0;
              }
LABEL_71:
              a1[6] = v21;
              v35 = 1;
              goto LABEL_74;
            case 2u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                v31 = 0;
                v32 = 0;
                v25 = 0;
                if (v3 <= v2)
                  v3 = v2;
                while (v3 != v2)
                {
                  v33 = v2++;
                  v34 = *(_BYTE *)(v6 + v33);
                  a2[1] = v2;
                  v25 |= (unint64_t)(v34 & 0x7F) << v31;
                  if ((v34 & 0x80) == 0)
                    goto LABEL_63;
                  v31 += 7;
                  v18 = v32++ >= 9;
                  if (v18)
                  {
                    LODWORD(v25) = 0;
LABEL_63:
                    v3 = v33 + 1;
                    goto LABEL_73;
                  }
                }
                LODWORD(v25) = 0;
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                v23 = 0;
                v24 = 0;
                v25 = 0;
                do
                {
                  v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  v26 = *(_BYTE *)(v6 + v2);
                  v25 |= (unint64_t)(v26 & 0x7F) << v23;
                  if ((v26 & 0x80) == 0)
                    goto LABEL_73;
                  v23 += 7;
                  v2 = v3;
                  v12 = v24++ > 8;
                }
                while (!v12);
                LODWORD(v25) = 0;
              }
LABEL_73:
              a1[7] = v25;
              v35 = 2;
LABEL_74:
              v2 = v3;
LABEL_75:
              a1[2] |= v35;
LABEL_76:
              v3 = a2[2];
              v4 = *((unsigned __int8 *)a2 + 24);
              if (v2 >= v3 || v4 != 0)
                return v4 == 0;
              continue;
            case 3u:
              if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
              {
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                a1[3] = *(_DWORD *)(v6 + v2);
                v2 = a2[1] + 4;
                a2[1] = v2;
              }
              v35 = 4;
              goto LABEL_75;
            case 4u:
              if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
              {
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                a1[4] = *(_DWORD *)(v6 + v2);
                v2 = a2[1] + 4;
                a2[1] = v2;
              }
              v35 = 8;
              goto LABEL_75;
            case 5u:
              if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
              {
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                a1[5] = *(_DWORD *)(v6 + v2);
                v2 = a2[1] + 4;
                a2[1] = v2;
              }
              v35 = 16;
              goto LABEL_75;
            default:
              goto LABEL_76;
          }
        }
        v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

uint64_t as::ChannelDescription::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_9;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_10;
  }
LABEL_9:
  this = PB::Writer::write(a2, *(float *)(v3 + 12));
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0)
      return this;
    return PB::Writer::write(a2, *(float *)(v3 + 20));
  }
LABEL_10:
  this = PB::Writer::write(a2, *(float *)(v3 + 16));
  if ((*(_DWORD *)(v3 + 8) & 0x10) != 0)
    return PB::Writer::write(a2, *(float *)(v3 + 20));
  return this;
}

uint64_t as::ChannelDescription::formatText(as::ChannelDescription *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "flags");
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "label");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
LABEL_11:
    PB::TextFormatter::format(a2, "coord1", *((float *)this + 4));
    if ((*((_DWORD *)this + 2) & 0x10) == 0)
      return PB::TextFormatter::endObject(a2);
    goto LABEL_6;
  }
LABEL_10:
  PB::TextFormatter::format(a2, "coord0", *((float *)this + 3));
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) != 0)
    goto LABEL_11;
LABEL_5:
  if ((v5 & 0x10) != 0)
LABEL_6:
    PB::TextFormatter::format(a2, "coord2", *((float *)this + 5));
  return PB::TextFormatter::endObject(a2);
}

BOOL as::ChannelDescription::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  return *(_QWORD *)(a1 + 12) == *(_QWORD *)(a2 + 12)
      && *(_QWORD *)(a1 + 20) == *(_QWORD *)(a2 + 20)
      && *(_DWORD *)(a1 + 28) == (unint64_t)*(unsigned int *)(a2 + 28);
}

uint64_t as::ChannelLayout::default_instance(as::ChannelLayout *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = off_24BFE3A30;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    as::ChannelLayout::default_instance(void)::gInstance = v3;
  }
  return as::ChannelLayout::default_instance(void)::gInstance;
}

void sub_20682456C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::ChannelLayout::ChannelLayout(as::ChannelLayout *this)
{
  double result;

  *(_QWORD *)this = off_24BFE3A30;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = off_24BFE3A30;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  return result;
}

as::ChannelLayout *as::ChannelLayout::ChannelLayout(as::ChannelLayout *this, const as::ChannelLayout *a2)
{
  *(_QWORD *)this = off_24BFE3A30;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  as::ChannelLayout::copy_from((uint64_t)this, a2);
  return this;
}

{
  *(_QWORD *)this = off_24BFE3A30;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  as::ChannelLayout::copy_from((uint64_t)this, a2);
  return this;
}

uint64_t as::ChannelLayout::copy_from(uint64_t this, const as::ChannelLayout *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  uint64_t v24;
  __int128 v25;
  char *v26;
  const as::ChannelLayout *i;
  uint64_t v28;
  __int128 v29;
  char *v30;
  uint64_t v31;

  v3 = this;
  v4 = *(_QWORD **)(this + 16);
  v6 = *(_QWORD **)(this + 24);
  v5 = (_QWORD *)(this + 16);
  while (v6 != v4)
  {
    v7 = *--v6;
    this = v7;
    *v6 = 0;
    if (v7)
      this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 8))(this);
  }
  *(_QWORD *)(v3 + 24) = v4;
  v8 = (uint64_t *)*((_QWORD *)a2 + 2);
  v9 = (uint64_t *)*((_QWORD *)a2 + 3);
  for (i = a2; v8 != v9; ++v8)
  {
    this = operator new();
    v10 = this;
    v11 = *v8;
    *(_QWORD *)this = &off_24BFE3B90;
    *(_DWORD *)(this + 8) = *(_DWORD *)(v11 + 8);
    v12 = *(_OWORD *)(v11 + 12);
    *(_DWORD *)(this + 28) = *(_DWORD *)(v11 + 28);
    *(_OWORD *)(this + 12) = v12;
    v14 = *(_QWORD **)(v3 + 24);
    v13 = *(_QWORD *)(v3 + 32);
    if ((unint64_t)v14 >= v13)
    {
      v16 = (_QWORD *)*v5;
      v17 = ((uint64_t)v14 - *v5) >> 3;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v31 = v3 + 32;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v3 + 32, v20);
        v16 = *(_QWORD **)(v3 + 16);
        v14 = *(_QWORD **)(v3 + 24);
      }
      else
      {
        v21 = 0;
      }
      v22 = (uint64_t *)&v21[8 * v17];
      v23 = &v21[8 * v20];
      v30 = v23;
      *v22 = v10;
      *((_QWORD *)&v29 + 1) = v22 + 1;
      if (v14 == v16)
      {
        v15 = v22 + 1;
      }
      else
      {
        do
        {
          v24 = *--v14;
          *v14 = 0;
          *--v22 = v24;
        }
        while (v14 != v16);
        v15 = (_QWORD *)*((_QWORD *)&v29 + 1);
        v23 = v30;
      }
      v25 = *(_OWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 16) = v22;
      *(_QWORD *)(v3 + 24) = v15;
      v29 = v25;
      v26 = *(char **)(v3 + 32);
      *(_QWORD *)(v3 + 32) = v23;
      v30 = v26;
      v28 = v25;
      this = std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v28);
    }
    else
    {
      *v14 = this;
      v15 = v14 + 1;
    }
    *(_QWORD *)(v3 + 24) = v15;
  }
  *(_DWORD *)(v3 + 8) = *((_DWORD *)i + 2);
  *(_QWORD *)(v3 + 40) = *((_QWORD *)i + 5);
  return this;
}

uint64_t as::ChannelLayout::operator=(uint64_t a1, const as::ChannelLayout *a2)
{
  as::ChannelLayout::copy_from(a1, a2);
  return a1;
}

uint64_t as::ChannelLayout::ChannelLayout(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)result = off_24BFE3A30;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v2 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v2;
  v3 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)result = off_24BFE3A30;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v2 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v2;
  v3 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

uint64_t as::ChannelLayout::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

uint64_t as::ChannelLayout::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v3 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  v4 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

_QWORD *as::ChannelLayout::clear(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;

  v1 = this;
  v2 = (_QWORD *)this[2];
  v3 = (_QWORD *)this[3];
  while (v3 != v2)
  {
    v4 = (_QWORD *)*--v3;
    this = v4;
    *v3 = 0;
    if (v4)
      this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
  }
  v1[3] = v2;
  *((_DWORD *)v1 + 2) = 0;
  v1[5] = 0;
  return this;
}

uint64_t as::ChannelLayout::isInitialized(as::ChannelLayout *this)
{
  uint64_t i;

  for (i = *((_QWORD *)this + 2); ; i += 8)
  {
    if (i == *((_QWORD *)this + 3))
      return *((_BYTE *)this + 8) & 1;
    if ((*(_BYTE *)(*(_QWORD *)i + 8) & 1) == 0)
      break;
  }
  return 0;
}

BOOL as::ChannelLayout::readFrom(int64x2_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t i64;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  BOOL v16;
  char v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  char v21;
  BOOL v22;
  unint64_t v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  char v32;
  _QWORD *v33;
  _QWORD *v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  char v38;
  unsigned int v39;
  unint64_t v40;
  char v41;
  char v42;
  unsigned int v43;
  unint64_t v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  int64x2_t v56;
  char *v57;
  uint64_t v58;
  int v59;
  uint64_t v61;
  int64x2_t v62;
  char *v63;
  uint64_t v64;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    v8 = a1 + 1;
    i64 = (uint64_t)a1[2].i64;
    do
    {
      v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        v17 = 0;
        v18 = 0;
        v13 = 0;
        if (v3 <= v2)
          v19 = v2;
        else
          v19 = v3;
        while (v19 != v3)
        {
          v20 = v3++;
          v21 = *(_BYTE *)(v10 + v20);
          a2[1] = v3;
          v13 |= (unint64_t)(v21 & 0x7F) << v17;
          if ((v21 & 0x80) == 0)
            goto LABEL_23;
          v17 += 7;
          v22 = v18++ >= 9;
          if (v22)
          {
            v13 = 0;
LABEL_23:
            v3 = v20 + 1;
            goto LABEL_24;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v3 + 1;
        a2[1] = v3 + 1;
        v15 = *(_BYTE *)(v10 + v3);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v3 = v14;
        v16 = v12++ > 8;
        if (v16)
        {
          v13 = 0;
          break;
        }
      }
      v3 = v14;
LABEL_24:
      if ((v13 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v23 = v13 >> 3;
      if ((_DWORD)v23 == 3)
      {
        v33 = (_QWORD *)operator new();
        v34 = v33;
        *v33 = &off_24BFE3B90;
        v33[1] = 0;
        v33[2] = 0;
        v33[3] = 0;
        v36 = (_QWORD *)a1[1].i64[1];
        v35 = a1[2].u64[0];
        if ((unint64_t)v36 >= v35)
        {
          v46 = ((uint64_t)v36 - v8->i64[0]) >> 3;
          if ((unint64_t)(v46 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v47 = v35 - v8->i64[0];
          v48 = v47 >> 2;
          if (v47 >> 2 <= (unint64_t)(v46 + 1))
            v48 = v46 + 1;
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8)
            v49 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v49 = v48;
          v64 = i64;
          if (v49)
            v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(i64, v49);
          else
            v50 = 0;
          v51 = &v50[8 * v46];
          v52 = &v50[8 * v49];
          v63 = v52;
          *(_QWORD *)v51 = v34;
          v37 = v51 + 8;
          v62.i64[1] = (uint64_t)(v51 + 8);
          v54 = (_QWORD *)a1[1].i64[0];
          v53 = (_QWORD *)a1[1].i64[1];
          if (v53 == v54)
          {
            v56 = vdupq_n_s64((unint64_t)v53);
          }
          else
          {
            do
            {
              v55 = *--v53;
              *v53 = 0;
              *((_QWORD *)v51 - 1) = v55;
              v51 -= 8;
            }
            while (v53 != v54);
            v56 = *v8;
            v37 = (_QWORD *)v62.i64[1];
            v52 = v63;
          }
          a1[1].i64[0] = (uint64_t)v51;
          a1[1].i64[1] = (uint64_t)v37;
          v62 = v56;
          v57 = (char *)a1[2].i64[0];
          a1[2].i64[0] = (uint64_t)v52;
          v63 = v57;
          v61 = v56.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v61);
        }
        else
        {
          *v36 = v33;
          v37 = v36 + 1;
        }
        a1[1].i64[1] = (uint64_t)v37;
        v58 = *(v37 - 1);
        if ((PB::Reader::placeMark() & 1) == 0
          || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v58 + 16))(v58, a2) & 1) == 0)
        {
          return 0;
        }
        PB::Reader::recallMark();
        v3 = a2[1];
        v2 = a2[2];
      }
      else
      {
        if ((_DWORD)v23 == 2)
        {
          if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
          {
            v38 = 0;
            v39 = 0;
            v31 = 0;
            if (v2 <= v3)
              v27 = v3;
            else
              v27 = v2;
            while (v27 != v3)
            {
              v40 = v3++;
              v41 = *(_BYTE *)(v10 + v40);
              a2[1] = v3;
              v31 |= (unint64_t)(v41 & 0x7F) << v38;
              if ((v41 & 0x80) == 0)
                goto LABEL_52;
              v38 += 7;
              v22 = v39++ >= 9;
              if (v22)
              {
                LODWORD(v31) = 0;
LABEL_52:
                v27 = v40 + 1;
                goto LABEL_80;
              }
            }
            LODWORD(v31) = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v29 = 0;
            v30 = 0;
            v31 = 0;
            while (1)
            {
              v27 = v3 + 1;
              a2[1] = v3 + 1;
              v32 = *(_BYTE *)(v10 + v3);
              v31 |= (unint64_t)(v32 & 0x7F) << v29;
              if ((v32 & 0x80) == 0)
                break;
              v29 += 7;
              v3 = v27;
              v16 = v30++ > 8;
              if (v16)
              {
                LODWORD(v31) = 0;
                break;
              }
            }
          }
LABEL_80:
          a1[2].i32[3] = v31;
          v59 = a1->i32[2] | 2;
        }
        else
        {
          if ((_DWORD)v23 != 1)
            goto LABEL_84;
          if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
          {
            v42 = 0;
            v43 = 0;
            v26 = 0;
            if (v2 <= v3)
              v27 = v3;
            else
              v27 = v2;
            while (v27 != v3)
            {
              v44 = v3++;
              v45 = *(_BYTE *)(v10 + v44);
              a2[1] = v3;
              v26 |= (unint64_t)(v45 & 0x7F) << v42;
              if ((v45 & 0x80) == 0)
                goto LABEL_61;
              v42 += 7;
              v22 = v43++ >= 9;
              if (v22)
              {
                LODWORD(v26) = 0;
LABEL_61:
                v27 = v44 + 1;
                goto LABEL_82;
              }
            }
            LODWORD(v26) = 0;
            *((_BYTE *)a2 + 24) = 1;
          }
          else
          {
            v24 = 0;
            v25 = 0;
            v26 = 0;
            while (1)
            {
              v27 = v3 + 1;
              a2[1] = v3 + 1;
              v28 = *(_BYTE *)(v10 + v3);
              v26 |= (unint64_t)(v28 & 0x7F) << v24;
              if ((v28 & 0x80) == 0)
                break;
              v24 += 7;
              v3 = v27;
              v16 = v25++ > 8;
              if (v16)
              {
                LODWORD(v26) = 0;
                break;
              }
            }
          }
LABEL_82:
          a1[2].i32[2] = v26;
          v59 = a1->i32[2] | 1;
        }
        a1->i32[2] = v59;
        v3 = v27;
      }
LABEL_84:
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v3 < v2 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

void sub_206824E4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::ChannelLayout::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0)
    this = PB::Writer::writeVarInt(a2);
  v6 = *(const PB::Base ***)(v3 + 16);
  v5 = *(const PB::Base ***)(v3 + 24);
  while (v6 != v5)
  {
    v7 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  return this;
}

uint64_t as::ChannelLayout::formatText(as::ChannelLayout *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "tag");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "bitmap");
  v6 = (uint64_t *)*((_QWORD *)this + 2);
  v7 = (uint64_t *)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "descriptions");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::ChannelLayout::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 40)
    && (v3 = *(_QWORD *)(a1 + 16),
        v2 = *(_QWORD *)(a1 + 24),
        v4 = (v2 - v3) >> 3,
        v5 = *(_QWORD *)(a2 + 16),
        v4 == (*(_QWORD *)(a2 + 24) - v5) >> 3))
  {
    if (v2 == v3)
    {
      return 1;
    }
    else
    {
      v6 = 0;
      v7 = 0;
      if (v4 <= 1)
        v8 = 1;
      else
        v8 = (v2 - v3) >> 3;
      do
      {
        v9 = *(_QWORD *)(v3 + 8 * v7);
        v10 = *(_QWORD *)(v5 + 8 * v7);
        if (v9)
          v11 = v10 == 0;
        else
          v11 = 1;
        if (v11)
        {
          if (v9 | v10)
            return v6;
        }
        else if (!as::ChannelDescription::operator==(v9, v10))
        {
          return v6;
        }
        v6 = ++v7 >= v4;
      }
      while (v8 != v7);
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

_QWORD *as::ChannelLayout::addDescriptions(as::ChannelLayout *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  _QWORD *result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 2);
      v5 = (_QWORD *)*((_QWORD *)this + 3);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *((_OWORD *)this + 1);
    *((_QWORD *)this + 2) = v13;
    *((_QWORD *)this + 3) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 3) = v6;
  result = (_QWORD *)operator new();
  *result = &off_24BFE3B90;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return (_QWORD *)*(v6 - 1);
  }
  return result;
}

uint64_t as::StreamFormat::default_instance(as::StreamFormat *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE39F8;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 44) = 0u;
    as::StreamFormat::default_instance(void)::gInstance = v3;
  }
  return as::StreamFormat::default_instance(void)::gInstance;
}

void sub_20682522C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::StreamFormat::StreamFormat(as::StreamFormat *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE39F8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE39F8;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

as::StreamFormat *as::StreamFormat::StreamFormat(as::StreamFormat *this, const as::StreamFormat *a2)
{
  *(_QWORD *)this = &off_24BFE39F8;
  *((_QWORD *)this + 2) = 0;
  as::StreamFormat::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE39F8;
  *((_QWORD *)this + 2) = 0;
  as::StreamFormat::copy_from(this, a2);
  return this;
}

__n128 as::StreamFormat::copy_from(as::StreamFormat *this, const as::StreamFormat *a2)
{
  const as::ChannelLayout *v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = (const as::ChannelLayout *)*((_QWORD *)a2 + 2);
  if (v4)
  {
    v5 = as::StreamFormat::mutableLayout(this);
    as::ChannelLayout::copy_from(v5, v4);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  result = *(__n128 *)((char *)a2 + 24);
  v7 = *(_OWORD *)((char *)a2 + 40);
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  *(_OWORD *)((char *)this + 40) = v7;
  *(__n128 *)((char *)this + 24) = result;
  return result;
}

as::StreamFormat *as::StreamFormat::operator=(as::StreamFormat *a1, const as::StreamFormat *a2)
{
  as::StreamFormat::copy_from(a1, a2);
  return a1;
}

uint64_t as::StreamFormat::layout(as::StreamFormat *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return as::ChannelLayout::default_instance(0);
  return result;
}

uint64_t as::StreamFormat::mutableLayout(as::StreamFormat *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = off_24BFE3A30;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    v3 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

__n128 as::StreamFormat::StreamFormat(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a1 = &off_24BFE39F8;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 24);
  v3 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v3;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a1 = &off_24BFE39F8;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 24);
  v3 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v3;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

__n128 as::StreamFormat::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 24);
  v4 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v4;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

__n128 as::StreamFormat::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 24);
  v4 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v4;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

double as::StreamFormat::clear(as::StreamFormat *this)
{
  uint64_t v2;
  double result;

  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  return result;
}

BOOL as::StreamFormat::isInitialized(as::StreamFormat *this)
{
  uint64_t v1;
  uint64_t i;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
    return 0;
  for (i = *(_QWORD *)(v1 + 16); i != *(_QWORD *)(v1 + 24); i += 8)
  {
    if ((*(_BYTE *)(*(_QWORD *)i + 8) & 1) == 0)
      return 0;
  }
  return (*(_BYTE *)(v1 + 8) & 1) != 0 && *((unsigned __int8 *)this + 8) == 0xFF;
}

BOOL as::StreamFormat::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  char v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  char v28;
  char v29;
  unsigned int v30;
  uint64_t v31;
  char v32;
  char v33;
  unsigned int v34;
  uint64_t v35;
  char v36;
  char v37;
  unsigned int v38;
  uint64_t v39;
  char v40;
  char v41;
  unsigned int v42;
  uint64_t v43;
  char v44;
  char v45;
  unsigned int v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  unsigned int v52;
  unint64_t v53;
  char v54;
  char v55;
  unsigned int v56;
  unint64_t v57;
  char v58;
  char v59;
  unsigned int v60;
  unint64_t v61;
  char v62;
  char v63;
  unsigned int v64;
  unint64_t v65;
  char v66;
  char v67;
  unsigned int v68;
  unint64_t v69;
  char v70;
  char v71;
  unsigned int v72;
  unint64_t v73;
  char v74;
  char v75;
  unsigned int v76;
  unint64_t v77;
  char v78;
  int v79;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0)
    return v4 == 0;
  while (2)
  {
    v8 = *a2;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3)
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v2 + 1;
        a2[1] = v2 + 1;
        v13 = *(_BYTE *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v2 = v12;
        v14 = v10++ > 8;
        if (v14)
        {
          v11 = 0;
          break;
        }
      }
      v2 = v12;
      goto LABEL_23;
    }
    v15 = 0;
    v16 = 0;
    v11 = 0;
    if (v2 <= v3)
      v17 = v3;
    else
      v17 = v2;
    do
    {
      if (v17 == v2)
      {
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v18 = v2++;
      v19 = *(_BYTE *)(v8 + v18);
      a2[1] = v2;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0)
        goto LABEL_22;
      v15 += 7;
      v20 = v16++ >= 9;
    }
    while (!v20);
    v11 = 0;
LABEL_22:
    v2 = v18 + 1;
LABEL_23:
    if ((v11 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    switch((v11 >> 3))
    {
      case 1u:
        if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > v3)
        {
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + v2);
          v2 = a2[1] + 8;
          a2[1] = v2;
        }
        *(_DWORD *)(a1 + 8) |= 1u;
        goto LABEL_155;
      case 2u:
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v51 = 0;
          v52 = 0;
          v23 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v53 = v2++;
            v54 = *(_BYTE *)(v8 + v53);
            a2[1] = v2;
            v23 |= (unint64_t)(v54 & 0x7F) << v51;
            if ((v54 & 0x80) == 0)
              goto LABEL_91;
            v51 += 7;
            v20 = v52++ >= 9;
            if (v20)
            {
              LODWORD(v23) = 0;
LABEL_91:
              v3 = v53 + 1;
              goto LABEL_141;
            }
          }
          LODWORD(v23) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v21 = 0;
          v22 = 0;
          v23 = 0;
          do
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v24 = *(_BYTE *)(v8 + v2);
            v23 |= (unint64_t)(v24 & 0x7F) << v21;
            if ((v24 & 0x80) == 0)
              goto LABEL_141;
            v21 += 7;
            v2 = v3;
            v14 = v22++ > 8;
          }
          while (!v14);
          LODWORD(v23) = 0;
        }
LABEL_141:
        *(_DWORD *)(a1 + 32) = v23;
        v79 = *(_DWORD *)(a1 + 8) | 2;
        goto LABEL_154;
      case 3u:
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v55 = 0;
          v56 = 0;
          v27 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v57 = v2++;
            v58 = *(_BYTE *)(v8 + v57);
            a2[1] = v2;
            v27 |= (unint64_t)(v58 & 0x7F) << v55;
            if ((v58 & 0x80) == 0)
              goto LABEL_99;
            v55 += 7;
            v20 = v56++ >= 9;
            if (v20)
            {
              LODWORD(v27) = 0;
LABEL_99:
              v3 = v57 + 1;
              goto LABEL_143;
            }
          }
          LODWORD(v27) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v25 = 0;
          v26 = 0;
          v27 = 0;
          do
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v28 = *(_BYTE *)(v8 + v2);
            v27 |= (unint64_t)(v28 & 0x7F) << v25;
            if ((v28 & 0x80) == 0)
              goto LABEL_143;
            v25 += 7;
            v2 = v3;
            v14 = v26++ > 8;
          }
          while (!v14);
          LODWORD(v27) = 0;
        }
LABEL_143:
        *(_DWORD *)(a1 + 36) = v27;
        v79 = *(_DWORD *)(a1 + 8) | 4;
        goto LABEL_154;
      case 4u:
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v59 = 0;
          v60 = 0;
          v31 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v61 = v2++;
            v62 = *(_BYTE *)(v8 + v61);
            a2[1] = v2;
            v31 |= (unint64_t)(v62 & 0x7F) << v59;
            if ((v62 & 0x80) == 0)
              goto LABEL_107;
            v59 += 7;
            v20 = v60++ >= 9;
            if (v20)
            {
              LODWORD(v31) = 0;
LABEL_107:
              v3 = v61 + 1;
              goto LABEL_145;
            }
          }
          LODWORD(v31) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v29 = 0;
          v30 = 0;
          v31 = 0;
          do
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v32 = *(_BYTE *)(v8 + v2);
            v31 |= (unint64_t)(v32 & 0x7F) << v29;
            if ((v32 & 0x80) == 0)
              goto LABEL_145;
            v29 += 7;
            v2 = v3;
            v14 = v30++ > 8;
          }
          while (!v14);
          LODWORD(v31) = 0;
        }
LABEL_145:
        *(_DWORD *)(a1 + 40) = v31;
        v79 = *(_DWORD *)(a1 + 8) | 8;
        goto LABEL_154;
      case 5u:
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v63 = 0;
          v64 = 0;
          v35 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v65 = v2++;
            v66 = *(_BYTE *)(v8 + v65);
            a2[1] = v2;
            v35 |= (unint64_t)(v66 & 0x7F) << v63;
            if ((v66 & 0x80) == 0)
              goto LABEL_115;
            v63 += 7;
            v20 = v64++ >= 9;
            if (v20)
            {
              LODWORD(v35) = 0;
LABEL_115:
              v3 = v65 + 1;
              goto LABEL_147;
            }
          }
          LODWORD(v35) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v33 = 0;
          v34 = 0;
          v35 = 0;
          do
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v36 = *(_BYTE *)(v8 + v2);
            v35 |= (unint64_t)(v36 & 0x7F) << v33;
            if ((v36 & 0x80) == 0)
              goto LABEL_147;
            v33 += 7;
            v2 = v3;
            v14 = v34++ > 8;
          }
          while (!v14);
          LODWORD(v35) = 0;
        }
LABEL_147:
        *(_DWORD *)(a1 + 44) = v35;
        v79 = *(_DWORD *)(a1 + 8) | 0x10;
        goto LABEL_154;
      case 6u:
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v67 = 0;
          v68 = 0;
          v39 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v69 = v2++;
            v70 = *(_BYTE *)(v8 + v69);
            a2[1] = v2;
            v39 |= (unint64_t)(v70 & 0x7F) << v67;
            if ((v70 & 0x80) == 0)
              goto LABEL_123;
            v67 += 7;
            v20 = v68++ >= 9;
            if (v20)
            {
              LODWORD(v39) = 0;
LABEL_123:
              v3 = v69 + 1;
              goto LABEL_149;
            }
          }
          LODWORD(v39) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v37 = 0;
          v38 = 0;
          v39 = 0;
          do
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v40 = *(_BYTE *)(v8 + v2);
            v39 |= (unint64_t)(v40 & 0x7F) << v37;
            if ((v40 & 0x80) == 0)
              goto LABEL_149;
            v37 += 7;
            v2 = v3;
            v14 = v38++ > 8;
          }
          while (!v14);
          LODWORD(v39) = 0;
        }
LABEL_149:
        *(_DWORD *)(a1 + 48) = v39;
        v79 = *(_DWORD *)(a1 + 8) | 0x20;
        goto LABEL_154;
      case 7u:
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v71 = 0;
          v72 = 0;
          v43 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v73 = v2++;
            v74 = *(_BYTE *)(v8 + v73);
            a2[1] = v2;
            v43 |= (unint64_t)(v74 & 0x7F) << v71;
            if ((v74 & 0x80) == 0)
              goto LABEL_131;
            v71 += 7;
            v20 = v72++ >= 9;
            if (v20)
            {
              LODWORD(v43) = 0;
LABEL_131:
              v3 = v73 + 1;
              goto LABEL_151;
            }
          }
          LODWORD(v43) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v41 = 0;
          v42 = 0;
          v43 = 0;
          do
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v44 = *(_BYTE *)(v8 + v2);
            v43 |= (unint64_t)(v44 & 0x7F) << v41;
            if ((v44 & 0x80) == 0)
              goto LABEL_151;
            v41 += 7;
            v2 = v3;
            v14 = v42++ > 8;
          }
          while (!v14);
          LODWORD(v43) = 0;
        }
LABEL_151:
        *(_DWORD *)(a1 + 52) = v43;
        v79 = *(_DWORD *)(a1 + 8) | 0x40;
        goto LABEL_154;
      case 8u:
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          v75 = 0;
          v76 = 0;
          v47 = 0;
          if (v3 <= v2)
            v3 = v2;
          while (v3 != v2)
          {
            v77 = v2++;
            v78 = *(_BYTE *)(v8 + v77);
            a2[1] = v2;
            v47 |= (unint64_t)(v78 & 0x7F) << v75;
            if ((v78 & 0x80) == 0)
              goto LABEL_139;
            v75 += 7;
            v20 = v76++ >= 9;
            if (v20)
            {
              LODWORD(v47) = 0;
LABEL_139:
              v3 = v77 + 1;
              goto LABEL_153;
            }
          }
          LODWORD(v47) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v45 = 0;
          v46 = 0;
          v47 = 0;
          do
          {
            v3 = v2 + 1;
            a2[1] = v2 + 1;
            v48 = *(_BYTE *)(v8 + v2);
            v47 |= (unint64_t)(v48 & 0x7F) << v45;
            if ((v48 & 0x80) == 0)
              goto LABEL_153;
            v45 += 7;
            v2 = v3;
            v14 = v46++ > 8;
          }
          while (!v14);
          LODWORD(v47) = 0;
        }
LABEL_153:
        *(_DWORD *)(a1 + 56) = v47;
        v79 = *(_DWORD *)(a1 + 8) | 0x80;
LABEL_154:
        *(_DWORD *)(a1 + 8) = v79;
        v2 = v3;
        goto LABEL_155;
      case 9u:
        v49 = operator new();
        *(_QWORD *)v49 = off_24BFE3A30;
        *(_DWORD *)(v49 + 8) = 0;
        *(_OWORD *)(v49 + 16) = 0u;
        *(_OWORD *)(v49 + 32) = 0u;
        v50 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v49;
        if (v50)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v50 + 8))(v50);
          v49 = *(_QWORD *)(a1 + 16);
        }
        if (PB::Reader::placeMark()
          && ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v49 + 16))(v49, a2) & 1) != 0)
        {
          PB::Reader::recallMark();
          v2 = a2[1];
LABEL_155:
          v3 = a2[2];
          v4 = *((unsigned __int8 *)a2 + 24);
          if (v2 >= v3 || v4 != 0)
            return v4 == 0;
          continue;
        }
        return 0;
      default:
        goto LABEL_155;
    }
  }
}

uint64_t as::StreamFormat::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;
  const PB::Base *v5;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::write(a2, *(double *)(this + 24));
    v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_14;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_15;
  }
LABEL_14:
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_16;
  }
LABEL_15:
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_17;
  }
LABEL_16:
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_18;
  }
LABEL_17:
  this = PB::Writer::writeVarInt(a2);
  v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 0x80) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_18:
  this = PB::Writer::writeVarInt(a2);
  if ((*(_DWORD *)(v3 + 8) & 0x80) != 0)
LABEL_9:
    this = PB::Writer::writeVarInt(a2);
LABEL_10:
  v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
    return PB::Writer::writeSubmessage(a2, v5);
  return this;
}

uint64_t as::StreamFormat::formatText(as::StreamFormat *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  uint64_t v6;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "sampleRate", *((double *)this + 3));
    v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_15;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "formatID");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
    goto LABEL_16;
  }
LABEL_15:
  PB::TextFormatter::format(a2, "formatFlags");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_17;
  }
LABEL_16:
  PB::TextFormatter::format(a2, "bytesPerPacket");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0)
      goto LABEL_7;
    goto LABEL_18;
  }
LABEL_17:
  PB::TextFormatter::format(a2, "framesPerPacket");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0)
      goto LABEL_8;
    goto LABEL_19;
  }
LABEL_18:
  PB::TextFormatter::format(a2, "bytesPerFrame");
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40) == 0)
  {
LABEL_8:
    if ((v5 & 0x80) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_19:
  PB::TextFormatter::format(a2, "channelsPerFrame");
  if ((*((_DWORD *)this + 2) & 0x80) != 0)
LABEL_9:
    PB::TextFormatter::format(a2, "bitsPerChannel");
LABEL_10:
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v6 + 32))(v6, a2, "layout");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::StreamFormat::operator==(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || memcmp((const void *)(a1 + 24), (const void *)(a2 + 24), 0x24uLL))
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a2 + 16);
  result = (v5 | v6) == 0;
  if (v5)
  {
    if (v6)
      return as::ChannelLayout::operator==(*(_QWORD *)(a1 + 16), v6);
  }
  return result;
}

uint64_t as::StreamFormat::clearLayout(as::StreamFormat *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::AvailableStreamFormat::default_instance(as::AvailableStreamFormat *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3C00;
    *(_OWORD *)(v3 + 8) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    as::AvailableStreamFormat::default_instance(void)::gInstance = v3;
  }
  return as::AvailableStreamFormat::default_instance(void)::gInstance;
}

void sub_2068260F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::AvailableStreamFormat::AvailableStreamFormat(as::AvailableStreamFormat *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3C00;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3C00;
  result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

as::AvailableStreamFormat *as::AvailableStreamFormat::AvailableStreamFormat(as::AvailableStreamFormat *this, const as::AvailableStreamFormat *a2)
{
  *(_QWORD *)this = &off_24BFE3C00;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::AvailableStreamFormat::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3C00;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::AvailableStreamFormat::copy_from(this, a2);
  return this;
}

void as::AvailableStreamFormat::copy_from(as::AvailableStreamFormat *this, const as::AvailableStreamFormat *a2)
{
  const as::StreamFormat *v4;
  as::StreamFormat *v5;
  uint64_t **v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t *v25;
  char *v26;
  uint64_t v27;
  __int128 v28;
  char *v29;
  uint64_t v30;
  __int128 v31;
  char *v32;
  char *v33;

  v4 = (const as::StreamFormat *)*((_QWORD *)a2 + 4);
  if (v4)
  {
    v5 = (as::StreamFormat *)as::AvailableStreamFormat::mutableFormat(this);
    as::StreamFormat::copy_from(v5, v4);
  }
  v7 = (_QWORD *)*((_QWORD *)this + 1);
  v8 = (_QWORD *)*((_QWORD *)this + 2);
  v6 = (uint64_t **)((char *)this + 8);
  while (v8 != v7)
  {
    v10 = *--v8;
    v9 = v10;
    *v8 = 0;
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  *((_QWORD *)this + 2) = v7;
  v11 = (uint64_t *)*((_QWORD *)a2 + 1);
  for (i = (uint64_t *)*((_QWORD *)a2 + 2); v11 != i; ++v11)
  {
    v13 = operator new();
    v14 = v13;
    v15 = *v11;
    *(_QWORD *)v13 = &off_24BFE3B20;
    *(_DWORD *)(v13 + 8) = *(_DWORD *)(v15 + 8);
    *(_OWORD *)(v13 + 16) = *(_OWORD *)(v15 + 16);
    v17 = (uint64_t *)*((_QWORD *)this + 2);
    v16 = *((_QWORD *)this + 3);
    if ((unint64_t)v17 >= v16)
    {
      v19 = *v6;
      v20 = v17 - *v6;
      v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 61)
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      v22 = v16 - (_QWORD)v19;
      if (v22 >> 2 > v21)
        v21 = v22 >> 2;
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
        v23 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v23 = v21;
      v33 = (char *)this + 24;
      if (v23)
      {
        v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)this + 24, v23);
        v19 = (uint64_t *)*((_QWORD *)this + 1);
        v17 = (uint64_t *)*((_QWORD *)this + 2);
      }
      else
      {
        v24 = 0;
      }
      v25 = (uint64_t *)&v24[8 * v20];
      v26 = &v24[8 * v23];
      v32 = v26;
      *v25 = v14;
      *((_QWORD *)&v31 + 1) = v25 + 1;
      if (v17 == v19)
      {
        v18 = v25 + 1;
      }
      else
      {
        do
        {
          v27 = *--v17;
          *v17 = 0;
          *--v25 = v27;
        }
        while (v17 != v19);
        v18 = (_QWORD *)*((_QWORD *)&v31 + 1);
        v26 = v32;
      }
      v28 = *(_OWORD *)((char *)this + 8);
      *((_QWORD *)this + 1) = v25;
      *((_QWORD *)this + 2) = v18;
      v31 = v28;
      v29 = (char *)*((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = v26;
      v32 = v29;
      v30 = v28;
      std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v30);
    }
    else
    {
      *v17 = v13;
      v18 = v17 + 1;
    }
    *((_QWORD *)this + 2) = v18;
  }
}

as::AvailableStreamFormat *as::AvailableStreamFormat::operator=(as::AvailableStreamFormat *a1, const as::AvailableStreamFormat *a2)
{
  as::AvailableStreamFormat::copy_from(a1, a2);
  return a1;
}

uint64_t as::AvailableStreamFormat::format(as::AvailableStreamFormat *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  if (!result)
    return as::StreamFormat::default_instance(0);
  return result;
}

uint64_t as::AvailableStreamFormat::mutableFormat(as::AvailableStreamFormat *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 4);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE39F8;
    *(_DWORD *)(v1 + 8) = 0;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_OWORD *)(v1 + 44) = 0u;
    v3 = *((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

__n128 as::SampleRateRange::SampleRateRange(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&off_24BFE3B20;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  a1[1] = result;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&off_24BFE3B20;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  a1[1] = result;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&off_24BFE3B20;
  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  a1[1] = result;
  return result;
}

double as::AvailableStreamFormat::AvailableStreamFormat(uint64_t a1, _QWORD *a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24BFE3C00;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 32) = a2[4];
  a2[4] = 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2[1];
  a2[1] = v3;
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2[2];
  a2[2] = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24BFE3C00;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 32) = a2[4];
  a2[4] = 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2[1];
  a2[1] = v3;
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = a2[2];
  a2[2] = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

_QWORD *as::AvailableStreamFormat::move_from(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

_QWORD *as::AvailableStreamFormat::operator=(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

uint64_t as::AvailableStreamFormat::clear(as::AvailableStreamFormat *this)
{
  uint64_t result;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  result = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  v3 = (_QWORD *)*((_QWORD *)this + 1);
  v4 = (_QWORD *)*((_QWORD *)this + 2);
  while (v4 != v3)
  {
    v5 = *--v4;
    result = v5;
    *v4 = 0;
    if (v5)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)this + 2) = v3;
  return result;
}

uint64_t as::AvailableStreamFormat::isInitialized(as::AvailableStreamFormat *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;

  result = *((_QWORD *)this + 4);
  if (result)
  {
    result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
    if ((_DWORD)result)
    {
      v4 = *((_QWORD *)this + 1);
      v3 = *((_QWORD *)this + 2);
      if (v4 == v3)
      {
        return 1;
      }
      else
      {
        v5 = v4 + 8;
        do
        {
          result = (*(_DWORD *)(*(_QWORD *)(v5 - 8) + 8) & 3) == 3;
          v6 = (*(_DWORD *)(*(_QWORD *)(v5 - 8) + 8) & 3) != 3 || v5 == v3;
          v5 += 8;
        }
        while (!v6);
      }
    }
  }
  return result;
}

BOOL as::SampleRateRange::isInitialized(as::SampleRateRange *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::AvailableStreamFormat::readFrom(_QWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int64x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  char v17;
  unsigned int v18;
  unint64_t v19;
  char v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  char *v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  int64x2_t v39;
  char *v40;
  uint64_t v42;
  int64x2_t v43;
  char *v44;
  uint64_t v45;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v8 = (int64x2_t *)(a1 + 1);
    v9 = (uint64_t)(a1 + 3);
    do
    {
      v10 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        v17 = 0;
        v18 = 0;
        v13 = 0;
        if (v2 > v3)
          v3 = v2;
        while (v3 != v2)
        {
          v19 = v2 + 1;
          v20 = *(_BYTE *)(v10 + v2);
          a2[1] = v19;
          v13 |= (unint64_t)(v20 & 0x7F) << v17;
          if ((v20 & 0x80) == 0)
            goto LABEL_21;
          v17 += 7;
          v2 = v19;
          if (v18++ >= 9)
          {
LABEL_20:
            v13 = 0;
            goto LABEL_21;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
        return v4 == 0;
      }
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v2 + 1;
        a2[1] = v2 + 1;
        v15 = *(_BYTE *)(v10 + v2);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v2 = v14;
        if (v12++ > 8)
          goto LABEL_20;
      }
LABEL_21:
      if ((v13 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v13 >> 3) == 2)
      {
        v24 = operator new();
        v25 = v24;
        *(_QWORD *)v24 = &off_24BFE3B20;
        *(_DWORD *)(v24 + 8) = 0;
        *(_QWORD *)(v24 + 16) = 0;
        *(_QWORD *)(v24 + 24) = 0;
        v27 = (uint64_t *)a1[2];
        v26 = a1[3];
        if ((unint64_t)v27 >= v26)
        {
          v29 = ((uint64_t)v27 - v8->i64[0]) >> 3;
          if ((unint64_t)(v29 + 1) >> 61)
            std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
          v30 = v26 - v8->i64[0];
          v31 = v30 >> 2;
          if (v30 >> 2 <= (unint64_t)(v29 + 1))
            v31 = v29 + 1;
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
            v32 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          v45 = v9;
          if (v32)
            v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v9, v32);
          else
            v33 = 0;
          v34 = (uint64_t *)&v33[8 * v29];
          v35 = &v33[8 * v32];
          v44 = v35;
          *v34 = v25;
          v28 = v34 + 1;
          v43.i64[1] = (uint64_t)(v34 + 1);
          v37 = (_QWORD *)a1[1];
          v36 = (_QWORD *)a1[2];
          if (v36 == v37)
          {
            v39 = vdupq_n_s64((unint64_t)v36);
          }
          else
          {
            do
            {
              v38 = *--v36;
              *v36 = 0;
              *--v34 = v38;
            }
            while (v36 != v37);
            v39 = *v8;
            v28 = (_QWORD *)v43.i64[1];
            v35 = v44;
          }
          a1[1] = v34;
          a1[2] = v28;
          v43 = v39;
          v40 = (char *)a1[3];
          a1[3] = v35;
          v44 = v40;
          v42 = v39.i64[0];
          std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v42);
        }
        else
        {
          *v27 = v24;
          v28 = v27 + 1;
        }
        a1[2] = v28;
        v22 = *(v28 - 1);
        if ((PB::Reader::placeMark() & 1) == 0)
          return 0;
      }
      else
      {
        if ((v13 >> 3) != 1)
          goto LABEL_47;
        v22 = operator new();
        *(_QWORD *)v22 = &off_24BFE39F8;
        *(_DWORD *)(v22 + 8) = 0;
        *(_OWORD *)(v22 + 16) = 0u;
        *(_OWORD *)(v22 + 32) = 0u;
        *(_OWORD *)(v22 + 44) = 0u;
        v23 = a1[4];
        a1[4] = v22;
        if (v23)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
          v22 = a1[4];
        }
        if (!PB::Reader::placeMark())
          return 0;
      }
      if (((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v22 + 16))(v22, a2) & 1) == 0)
        return 0;
      PB::Reader::recallMark();
LABEL_47:
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((_BYTE *)a2 + 24));
  }
  return v4 == 0;
}

void sub_206826980(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::AvailableStreamFormat::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;
  const PB::Base **v5;
  const PB::Base **v6;
  const PB::Base *v7;

  v3 = this;
  v4 = *(const PB::Base **)(this + 32);
  if (v4)
    this = PB::Writer::writeSubmessage(a2, v4);
  v6 = *(const PB::Base ***)(v3 + 8);
  v5 = *(const PB::Base ***)(v3 + 16);
  while (v6 != v5)
  {
    v7 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  return this;
}

uint64_t as::AvailableStreamFormat::formatText(as::AvailableStreamFormat *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_QWORD *)this + 4);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "format");
  v6 = (uint64_t *)*((_QWORD *)this + 1);
  v7 = (uint64_t *)*((_QWORD *)this + 2);
  while (v6 != v7)
  {
    v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v8 + 32))(v8, a2, "sampleRateRange");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::AvailableStreamFormat::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(a2 + 32);
  if (v4)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (v4 | v5)
      return 0;
  }
  else if (!as::StreamFormat::operator==(v4, v5))
  {
    return 0;
  }
  v9 = a1 + 8;
  v8 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)(v9 + 8);
  v10 = (v7 - v8) >> 3;
  v12 = a2 + 8;
  v11 = *(_QWORD *)(a2 + 8);
  if (v10 != (*(_QWORD *)(v12 + 8) - v11) >> 3)
    return 0;
  if (v7 == v8)
  {
    return 1;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    if (v10 <= 1)
      v15 = 1;
    else
      v15 = (v7 - v8) >> 3;
    do
    {
      v16 = *(_QWORD *)(v8 + 8 * v14);
      v17 = *(_QWORD *)(v11 + 8 * v14);
      if (v16)
        v18 = v17 == 0;
      else
        v18 = 1;
      if (v18)
      {
        if (v16 | v17)
          return v13;
      }
      else if (!as::SampleRateRange::operator==(v16, v17))
      {
        return v13;
      }
      v13 = ++v14 >= v10;
    }
    while (v15 != v14);
  }
  return v13;
}

uint64_t as::AvailableStreamFormat::clearFormat(as::AvailableStreamFormat *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t as::AvailableStreamFormat::addSampleRateRange(as::AvailableStreamFormat *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  char *v22;
  char *v23;

  v4 = *((_QWORD *)this + 3);
  v2 = (char *)this + 24;
  v3 = v4;
  v5 = (_QWORD *)*((_QWORD *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)v2 - 2);
    v8 = v5 - v7;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    v9 = v3 - (_QWORD)v7;
    v10 = (uint64_t)(v3 - (_QWORD)v7) >> 2;
    if (v10 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    v23 = v2;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v11);
      v7 = (_QWORD *)*((_QWORD *)this + 1);
      v5 = (_QWORD *)*((_QWORD *)this + 2);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    v14 = &v12[8 * v11];
    v22 = v14;
    *(_QWORD *)v13 = 0;
    *((_QWORD *)&v21 + 1) = v13 + 8;
    if (v5 == v7)
    {
      v6 = v13 + 8;
    }
    else
    {
      do
      {
        v15 = *--v5;
        *v5 = 0;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v5 != v7);
      v6 = (_QWORD *)*((_QWORD *)&v21 + 1);
      v14 = v22;
    }
    v16 = *(_OWORD *)((char *)this + 8);
    *((_QWORD *)this + 1) = v13;
    *((_QWORD *)this + 2) = v6;
    v21 = v16;
    v17 = (char *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v14;
    v22 = v17;
    v20 = v16;
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *v5 = 0;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 2) = v6;
  result = operator new();
  *(_QWORD *)result = &off_24BFE3B20;
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  v19 = *(v6 - 1);
  *(v6 - 1) = result;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    return *(v6 - 1);
  }
  return result;
}

uint64_t as::SampleRateRange::default_instance(as::SampleRateRange *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3B20;
    *(_DWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 24) = 0;
    as::SampleRateRange::default_instance(void)::gInstance = v3;
  }
  return as::SampleRateRange::default_instance(void)::gInstance;
}

void sub_206826D58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::SampleRateRange::SampleRateRange(uint64_t this)
{
  *(_QWORD *)this = &off_24BFE3B20;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3B20;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  return this;
}

__n128 as::SampleRateRange::SampleRateRange(__n128 *this, __n128 *a2)
{
  __n128 result;

  this->n128_u64[0] = (unint64_t)&off_24BFE3B20;
  this->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  this[1] = result;
  return result;
}

__n128 as::SampleRateRange::copy_from(__n128 *this, __n128 *a2)
{
  __n128 result;

  this->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  this[1] = result;
  return result;
}

__n128 as::SampleRateRange::operator=(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  a1[1] = result;
  return result;
}

{
  __n128 result;

  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  a1[1] = result;
  return result;
}

__n128 as::SampleRateRange::move_from(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1->n128_u32[2] = a2->n128_u32[2];
  result = a2[1];
  a1[1] = result;
  return result;
}

uint64_t as::SampleRateRange::clear(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  return this;
}

BOOL as::SampleRateRange::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v6;
  char v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  char v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  unint64_t v19;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0)
    return v4 == 0;
  while (1)
  {
    v6 = *a2;
    if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      break;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    while (1)
    {
      v10 = v3 + 1;
      a2[1] = v3 + 1;
      v11 = *(_BYTE *)(v6 + v3);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0)
        break;
      v7 += 7;
      v3 = v10;
      if (v8++ > 8)
      {
        v9 = 0;
        break;
      }
    }
    v3 = v10;
LABEL_23:
    if ((v9 & 7) == 4)
    {
      v4 = 0;
      return v4 == 0;
    }
    v19 = v9 >> 3;
    if ((_DWORD)v19 == 2)
    {
      if (v3 > 0xFFFFFFFFFFFFFFF7 || v3 + 8 > v2)
        goto LABEL_33;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(v6 + v3);
    }
    else
    {
      if ((_DWORD)v19 != 1)
        goto LABEL_35;
      if (v3 > 0xFFFFFFFFFFFFFFF7 || v3 + 8 > v2)
      {
LABEL_33:
        *((_BYTE *)a2 + 24) = 1;
        goto LABEL_34;
      }
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(v6 + v3);
    }
    v3 = a2[1] + 8;
    a2[1] = v3;
LABEL_34:
    *(_DWORD *)(a1 + 8) |= v19;
LABEL_35:
    v2 = a2[2];
    v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((_BYTE *)a2 + 24))
      return v4 == 0;
  }
  v13 = 0;
  v14 = 0;
  v9 = 0;
  if (v3 <= v2)
    v15 = v2;
  else
    v15 = v3;
  while (v15 != v3)
  {
    v16 = v3++;
    v17 = *(_BYTE *)(v6 + v16);
    a2[1] = v3;
    v9 |= (unint64_t)(v17 & 0x7F) << v13;
    if ((v17 & 0x80) == 0)
      goto LABEL_22;
    v13 += 7;
    if (v14++ >= 9)
    {
      v9 = 0;
LABEL_22:
      v3 = v16 + 1;
      goto LABEL_23;
    }
  }
  v4 = 1;
  *((_BYTE *)a2 + 24) = 1;
  return v4 == 0;
}

uint64_t as::SampleRateRange::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  int v4;

  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) != 0)
  {
    this = PB::Writer::write(a2, *(double *)(this + 16));
    v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0)
    return PB::Writer::write(a2, *(double *)(v3 + 24));
  return this;
}

uint64_t as::SampleRateRange::formatText(as::SampleRateRange *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "minimum", *((double *)this + 2));
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
    PB::TextFormatter::format(a2, "maximum", *((double *)this + 3));
  return PB::TextFormatter::endObject(a2);
}

BOOL as::SampleRateRange::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  return *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16) && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24);
}

uint64_t as::ActivationContext::default_instance(as::ActivationContext *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3B58;
    *(_DWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 24) = 0;
    *(_QWORD *)(v3 + 32) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 40) = 0;
    as::ActivationContext::default_instance(void)::gInstance = v3;
  }
  return as::ActivationContext::default_instance(void)::gInstance;
}

void sub_206827158(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::ActivationContext::ActivationContext(uint64_t this)
{
  *(_QWORD *)this = &off_24BFE3B58;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3B58;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

as::ActivationContext *as::ActivationContext::ActivationContext(as::ActivationContext *this, const as::ActivationContext *a2)
{
  *(_QWORD *)this = &off_24BFE3B58;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::ActivationContext::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3B58;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::ActivationContext::copy_from(this, a2);
  return this;
}

uint64_t as::ActivationContext::copy_from(as::ActivationContext *this, const as::ActivationContext *a2)
{
  uint64_t result;
  uint64_t v5;

  result = caulk::xstring::assign((as::ActivationContext *)((char *)this + 16), (const as::ActivationContext *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v5 = *((_QWORD *)a2 + 4);
  *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
  *((_QWORD *)this + 4) = v5;
  return result;
}

as::ActivationContext *as::ActivationContext::operator=(as::ActivationContext *a1, const as::ActivationContext *a2)
{
  as::ActivationContext::copy_from(a1, a2);
  return a1;
}

_QWORD *as::ActivationContext::ActivationContext(_QWORD *a1, uint64_t a2)
{
  *a1 = &off_24BFE3B58;
  a1[2] = 0;
  a1[3] = 0;
  as::ActivationContext::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &off_24BFE3B58;
  a1[2] = 0;
  a1[3] = 0;
  as::ActivationContext::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::ActivationContext::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  _QWORD v6[2];

  v6[0] = 0;
  v6[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)v6);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = v5;
  return result;
}

uint64_t as::ActivationContext::operator=(uint64_t a1, uint64_t a2)
{
  as::ActivationContext::move_from(a1, a2);
  return a1;
}

uint64_t as::ActivationContext::clear(as::ActivationContext *this)
{
  uint64_t result;

  result = caulk::xstring::clear((as::ActivationContext *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  return result;
}

uint64_t as::ActivationContext::isInitialized(as::ActivationContext *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::ActivationContext::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  char v29;
  char v30;
  unsigned int v31;
  uint64_t v32;
  char v33;
  char v34;
  unsigned int v35;
  unint64_t v36;
  char v37;
  char v38;
  unsigned int v39;
  unint64_t v40;
  char v41;
  char v42;
  unsigned int v43;
  unint64_t v44;
  char v45;
  int v46;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        v15 = 0;
        v16 = 0;
        v11 = 0;
        if (v3 <= v2)
          v17 = v2;
        else
          v17 = v3;
        while (v17 != v3)
        {
          v18 = v3++;
          v19 = *(_BYTE *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0)
            goto LABEL_22;
          v15 += 7;
          v20 = v16++ >= 9;
          if (v20)
          {
            v11 = 0;
LABEL_22:
            v3 = v18 + 1;
            goto LABEL_23;
          }
        }
        v4 = 1;
        *((_BYTE *)a2 + 24) = 1;
      }
      else
      {
        v9 = 0;
        v10 = 0;
        v11 = 0;
        while (1)
        {
          v12 = v3 + 1;
          a2[1] = v3 + 1;
          v13 = *(_BYTE *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0)
            break;
          v9 += 7;
          v3 = v12;
          v14 = v10++ > 8;
          if (v14)
          {
            v11 = 0;
            break;
          }
        }
        v3 = v12;
LABEL_23:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 1u:
              if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
              {
                v34 = 0;
                v35 = 0;
                v23 = 0;
                if (v2 <= v3)
                  v24 = v3;
                else
                  v24 = v2;
                do
                {
                  if (v24 == v3)
                  {
                    LODWORD(v23) = 0;
                    *((_BYTE *)a2 + 24) = 1;
                    goto LABEL_75;
                  }
                  v36 = v3++;
                  v37 = *(_BYTE *)(v8 + v36);
                  a2[1] = v3;
                  v23 |= (unint64_t)(v37 & 0x7F) << v34;
                  if ((v37 & 0x80) == 0)
                    goto LABEL_55;
                  v34 += 7;
                  v20 = v35++ >= 9;
                }
                while (!v20);
                LODWORD(v23) = 0;
LABEL_55:
                v24 = v36 + 1;
              }
              else
              {
                v21 = 0;
                v22 = 0;
                v23 = 0;
                do
                {
                  v24 = v3 + 1;
                  a2[1] = v3 + 1;
                  v25 = *(_BYTE *)(v8 + v3);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0)
                    goto LABEL_75;
                  v21 += 7;
                  v3 = v24;
                  v14 = v22++ > 8;
                }
                while (!v14);
                LODWORD(v23) = 0;
              }
LABEL_75:
              a1[8] = v23;
              v46 = a1[2] | 1;
              goto LABEL_80;
            case 2u:
              PB::Reader::read();
              caulk::xstring::assign();
              a1[2] |= 2u;
              v3 = a2[1];
              v2 = a2[2];
              goto LABEL_81;
            case 3u:
              if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
              {
                v38 = 0;
                v39 = 0;
                v28 = 0;
                if (v2 <= v3)
                  v24 = v3;
                else
                  v24 = v2;
                while (v24 != v3)
                {
                  v40 = v3++;
                  v41 = *(_BYTE *)(v8 + v40);
                  a2[1] = v3;
                  v28 |= (unint64_t)(v41 & 0x7F) << v38;
                  if ((v41 & 0x80) == 0)
                    goto LABEL_64;
                  v38 += 7;
                  v20 = v39++ >= 9;
                  if (v20)
                  {
                    LODWORD(v28) = 0;
LABEL_64:
                    v24 = v40 + 1;
                    goto LABEL_77;
                  }
                }
                LODWORD(v28) = 0;
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                v26 = 0;
                v27 = 0;
                v28 = 0;
                do
                {
                  v24 = v3 + 1;
                  a2[1] = v3 + 1;
                  v29 = *(_BYTE *)(v8 + v3);
                  v28 |= (unint64_t)(v29 & 0x7F) << v26;
                  if ((v29 & 0x80) == 0)
                    goto LABEL_77;
                  v26 += 7;
                  v3 = v24;
                  v14 = v27++ > 8;
                }
                while (!v14);
                LODWORD(v28) = 0;
              }
LABEL_77:
              a1[9] = v28;
              v46 = a1[2] | 8;
              goto LABEL_80;
            case 4u:
              if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
              {
                v42 = 0;
                v43 = 0;
                v32 = 0;
                if (v2 <= v3)
                  v24 = v3;
                else
                  v24 = v2;
                while (v24 != v3)
                {
                  v44 = v3++;
                  v45 = *(_BYTE *)(v8 + v44);
                  a2[1] = v3;
                  v32 |= (unint64_t)(v45 & 0x7F) << v42;
                  if ((v45 & 0x80) == 0)
                    goto LABEL_73;
                  v42 += 7;
                  v20 = v43++ >= 9;
                  if (v20)
                  {
                    LODWORD(v32) = 0;
LABEL_73:
                    v24 = v44 + 1;
                    goto LABEL_79;
                  }
                }
                LODWORD(v32) = 0;
                *((_BYTE *)a2 + 24) = 1;
              }
              else
              {
                v30 = 0;
                v31 = 0;
                v32 = 0;
                do
                {
                  v24 = v3 + 1;
                  a2[1] = v3 + 1;
                  v33 = *(_BYTE *)(v8 + v3);
                  v32 |= (unint64_t)(v33 & 0x7F) << v30;
                  if ((v33 & 0x80) == 0)
                    goto LABEL_79;
                  v30 += 7;
                  v3 = v24;
                  v14 = v31++ > 8;
                }
                while (!v14);
                LODWORD(v32) = 0;
              }
LABEL_79:
              a1[10] = v32;
              v46 = a1[2] | 4;
LABEL_80:
              a1[2] = v46;
              v3 = v24;
LABEL_81:
              v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || *((_BYTE *)a2 + 24))
                return v4 == 0;
              continue;
            default:
              goto LABEL_81;
          }
        }
        v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_206827808(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::ActivationContext::writeTo(as::ActivationContext *this, PB::Writer *a2)
{
  int v4;
  char *v5;
  void *__p;
  char v7;

  v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::ActivationContext *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v7 < 0)
      operator delete(__p);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 4) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 8) != 0)
    PB::Writer::writeVarInt(a2);
}

void sub_2068278D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::ActivationContext::formatText(as::ActivationContext *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  void *__p;
  char v9;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "trigger");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::ActivationContext *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v9 < 0)
      operator delete(__p);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "accessibilityPreference");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 8) != 0)
    PB::TextFormatter::format(a2, "callDirection");
  return PB::TextFormatter::endObject(a2);
}

void sub_2068279BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::ActivationContext::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v2;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && (*(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)
      ? (v2 = *(unsigned int *)(a1 + 40) == (unint64_t)*(unsigned int *)(a2 + 40))
      : (v2 = 0),
        v2))
  {
    return caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t as::AggregateDevice::default_instance(as::AggregateDevice *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3AB0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_QWORD *)(v3 + 96) = 0;
    as::AggregateDevice::default_instance(void)::gInstance = v3;
  }
  return as::AggregateDevice::default_instance(void)::gInstance;
}

void sub_206827AC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double as::AggregateDevice::AggregateDevice(as::AggregateDevice *this)
{
  double result;

  *(_QWORD *)this = &off_24BFE3AB0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  return result;
}

{
  double result;

  *(_QWORD *)this = &off_24BFE3AB0;
  *((_DWORD *)this + 2) = 0;
  result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  return result;
}

as::AggregateDevice *as::AggregateDevice::AggregateDevice(as::AggregateDevice *this, caulk::xstring **a2)
{
  *(_QWORD *)this = &off_24BFE3AB0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  as::AggregateDevice::copy_from((caulk::xstring **)this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3AB0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  as::AggregateDevice::copy_from((caulk::xstring **)this, a2);
  return this;
}

uint64_t as::AggregateDevice::copy_from(caulk::xstring **this, caulk::xstring **a2)
{
  uint64_t result;

  caulk::xstring::assign((caulk::xstring *)(this + 5), (const caulk::xstring *)(a2 + 5));
  caulk::xstring::assign((caulk::xstring *)(this + 7), (const caulk::xstring *)(a2 + 7));
  if (this != a2)
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)(this + 2), a2[2], a2[3], (a2[3] - a2[2]) >> 4);
  caulk::xstring::assign((caulk::xstring *)(this + 9), (const caulk::xstring *)(a2 + 9));
  result = caulk::xstring::assign((caulk::xstring *)(this + 11), (const caulk::xstring *)(a2 + 11));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  return result;
}

caulk::xstring **as::AggregateDevice::operator=(caulk::xstring **a1, caulk::xstring **a2)
{
  as::AggregateDevice::copy_from(a1, a2);
  return a1;
}

uint64_t as::AggregateDevice::AggregateDevice(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_24BFE3AB0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  as::AggregateDevice::move_from(a1, a2);
  return a1;
}

{
  *(_QWORD *)a1 = &off_24BFE3AB0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_QWORD *)(a1 + 96) = 0;
  as::AggregateDevice::move_from(a1, a2);
  return a1;
}

uint64_t as::AggregateDevice::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v8);
  v8 = 0;
  v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  v8 = 0;
  v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v8);
  v8 = 0;
  v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)&v8);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t as::AggregateDevice::operator=(uint64_t a1, uint64_t a2)
{
  as::AggregateDevice::move_from(a1, a2);
  return a1;
}

uint64_t as::AggregateDevice::clear(caulk::xstring **this)
{
  uint64_t result;

  caulk::xstring::clear((caulk::xstring *)(this + 5));
  caulk::xstring::clear((caulk::xstring *)(this + 7));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)(this + 2), this[2]);
  caulk::xstring::clear((caulk::xstring *)(this + 9));
  result = caulk::xstring::clear((caulk::xstring *)(this + 11));
  *((_DWORD *)this + 2) = 0;
  return result;
}

BOOL as::AggregateDevice::isInitialized(as::AggregateDevice *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::AggregateDevice::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  char v17;
  unsigned int v18;
  unint64_t v19;
  char v20;
  int v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  void *__p;
  char *v34;
  _QWORD *v35;
  char *v36;
  uint64_t v37;

  v2 = a2[1];
  v3 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v8 = (uint64_t *)(a1 + 16);
    v9 = a1 + 32;
    while (1)
    {
      v10 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        break;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        v14 = v2 + 1;
        a2[1] = v2 + 1;
        v15 = *(_BYTE *)(v10 + v2);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0)
          break;
        v11 += 7;
        v2 = v14;
        if (v12++ > 8)
          goto LABEL_20;
      }
LABEL_21:
      if ((v13 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      switch((v13 >> 3))
      {
        case 1u:
          __p = 0;
          v34 = 0;
          v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          v22 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_29;
        case 2u:
          __p = 0;
          v34 = 0;
          v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          v22 = *(_DWORD *)(a1 + 8) | 2;
          goto LABEL_29;
        case 3u:
          v24 = *(_QWORD **)(a1 + 24);
          v23 = *(_QWORD *)(a1 + 32);
          if ((unint64_t)v24 >= v23)
          {
            v26 = ((uint64_t)v24 - *v8) >> 4;
            v27 = v26 + 1;
            if ((unint64_t)(v26 + 1) >> 60)
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            v28 = v23 - *v8;
            if (v28 >> 3 > v27)
              v27 = v28 >> 3;
            if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0)
              v29 = 0xFFFFFFFFFFFFFFFLL;
            else
              v29 = v27;
            v37 = v9;
            if (v29)
              v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v29);
            else
              v30 = 0;
            v31 = &v30[16 * v26];
            __p = v30;
            v34 = v31;
            v36 = &v30[16 * v29];
            *(_QWORD *)v31 = 0;
            *((_QWORD *)v31 + 1) = 0;
            v35 = v31 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
            v25 = *(_QWORD **)(a1 + 24);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *v24 = 0;
            v24[1] = 0;
            v25 = v24 + 2;
            *(_QWORD *)(a1 + 24) = v24 + 2;
          }
          *(_QWORD *)(a1 + 24) = v25;
          __p = 0;
          v34 = 0;
          v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_30;
        case 4u:
          __p = 0;
          v34 = 0;
          v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          v22 = *(_DWORD *)(a1 + 8) | 4;
          goto LABEL_29;
        case 5u:
          __p = 0;
          v34 = 0;
          v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          v22 = *(_DWORD *)(a1 + 8) | 8;
LABEL_29:
          *(_DWORD *)(a1 + 8) = v22;
LABEL_30:
          if (SHIBYTE(v35) < 0)
            operator delete(__p);
          break;
        default:
          break;
      }
      v2 = a2[1];
      v3 = a2[2];
      v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((_BYTE *)a2 + 24))
        return v4 == 0;
    }
    v17 = 0;
    v18 = 0;
    v13 = 0;
    if (v2 > v3)
      v3 = v2;
    while (v3 != v2)
    {
      v19 = v2 + 1;
      v20 = *(_BYTE *)(v10 + v2);
      a2[1] = v19;
      v13 |= (unint64_t)(v20 & 0x7F) << v17;
      if ((v20 & 0x80) == 0)
        goto LABEL_21;
      v17 += 7;
      v2 = v19;
      if (v18++ >= 9)
      {
LABEL_20:
        v13 = 0;
        goto LABEL_21;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_2068281FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void as::AggregateDevice::writeTo(as::AggregateDevice *this, PB::Writer *a2)
{
  int v3;
  char *v4;
  char *v5;
  caulk::xstring *v6;
  caulk::xstring *v7;
  char *v8;
  int v9;
  char *v10;
  char *v11;
  void *__p[2];
  char v13;

  v3 = *((_DWORD *)this + 2);
  if ((v3 & 1) != 0)
  {
    v4 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(__p, v4);
    PB::Writer::write();
    if (v13 < 0)
      operator delete(__p[0]);
    v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 2) != 0)
  {
    v5 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 56));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v13 < 0)
      operator delete(__p[0]);
  }
  v6 = (caulk::xstring *)*((_QWORD *)this + 2);
  v7 = (caulk::xstring *)*((_QWORD *)this + 3);
  while (v6 != v7)
  {
    v8 = (char *)caulk::xstring::c_str(v6);
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::Writer::write();
    if (v13 < 0)
      operator delete(__p[0]);
    v6 = (caulk::xstring *)((char *)v6 + 16);
  }
  v9 = *((_DWORD *)this + 2);
  if ((v9 & 4) != 0)
  {
    v10 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 72));
    std::string::basic_string[abi:ne180100]<0>(__p, v10);
    PB::Writer::write();
    if (v13 < 0)
      operator delete(__p[0]);
    v9 = *((_DWORD *)this + 2);
  }
  if ((v9 & 8) != 0)
  {
    v11 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v11);
    PB::Writer::write();
    if (v13 < 0)
      operator delete(__p[0]);
  }
}

void sub_2068283A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::AggregateDevice::formatText(as::AggregateDevice *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  char *v7;
  caulk::xstring *v8;
  caulk::xstring *i;
  char *v10;
  int v11;
  char *v12;
  char *v13;
  void *__p[2];
  char v16;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v16 < 0)
      operator delete(__p[0]);
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    v7 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 56));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v16 < 0)
      operator delete(__p[0]);
  }
  v8 = (caulk::xstring *)*((_QWORD *)this + 2);
  for (i = (caulk::xstring *)*((_QWORD *)this + 3); v8 != i; v8 = (caulk::xstring *)((char *)v8 + 16))
  {
    v10 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(__p, v10);
    PB::TextFormatter::format();
    if (v16 < 0)
      operator delete(__p[0]);
  }
  v11 = *((_DWORD *)this + 2);
  if ((v11 & 4) != 0)
  {
    v12 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 72));
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::TextFormatter::format();
    if (v16 < 0)
      operator delete(__p[0]);
    v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 8) != 0)
  {
    v13 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v13);
    PB::TextFormatter::format();
    if (v16 < 0)
      operator delete(__p[0]);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_20682856C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::AggregateDevice::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
    return 0;
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 40), (const caulk::xstring *)(a2 + 40)))
    return 0;
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 56), (const caulk::xstring *)(a2 + 56)))
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v6 = (v4 - v5) >> 4;
  if (v6 != (uint64_t)(*(_QWORD *)(a2 + 24) - *(_QWORD *)(a2 + 16)) >> 4)
    return 0;
  if (v4 != v5)
  {
    v7 = 0;
    if (v6 <= 1)
      v8 = 1;
    else
      v8 = (v4 - v5) >> 4;
    while (!caulk::xstring::compare((caulk::xstring *)(*(_QWORD *)(a1 + 16) + v7), (const caulk::xstring *)(*(_QWORD *)(a2 + 16) + v7)))
    {
      v7 += 16;
      if (!--v8)
        goto LABEL_11;
    }
    return 0;
  }
LABEL_11:
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 72), (const caulk::xstring *)(a2 + 72)))
    return 0;
  return caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)) == 0;
}

uint64_t as::RouteIdentifierCore::default_instance(as::RouteIdentifierCore *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3BC8;
    *(_DWORD *)(v3 + 8) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 24) = 0;
    *(_DWORD *)(v3 + 32) = 0;
    as::RouteIdentifierCore::default_instance(void)::gInstance = v3;
  }
  return as::RouteIdentifierCore::default_instance(void)::gInstance;
}

void sub_2068286F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::RouteIdentifierCore::RouteIdentifierCore(uint64_t this)
{
  *(_QWORD *)this = &off_24BFE3BC8;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3BC8;
  *(_DWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

as::RouteIdentifierCore *as::RouteIdentifierCore::RouteIdentifierCore(as::RouteIdentifierCore *this, const as::RouteIdentifierCore *a2)
{
  *(_QWORD *)this = &off_24BFE3BC8;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::RouteIdentifierCore::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3BC8;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  as::RouteIdentifierCore::copy_from(this, a2);
  return this;
}

uint64_t as::RouteIdentifierCore::copy_from(as::RouteIdentifierCore *this, const as::RouteIdentifierCore *a2)
{
  uint64_t result;

  result = caulk::xstring::assign((as::RouteIdentifierCore *)((char *)this + 16), (const as::RouteIdentifierCore *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  return result;
}

as::RouteIdentifierCore *as::RouteIdentifierCore::operator=(as::RouteIdentifierCore *a1, const as::RouteIdentifierCore *a2)
{
  as::RouteIdentifierCore::copy_from(a1, a2);
  return a1;
}

_QWORD *as::RouteIdentifierCore::RouteIdentifierCore(_QWORD *a1, uint64_t a2)
{
  *a1 = &off_24BFE3BC8;
  a1[2] = 0;
  a1[3] = 0;
  as::RouteIdentifierCore::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &off_24BFE3BC8;
  a1[2] = 0;
  a1[3] = 0;
  as::RouteIdentifierCore::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::RouteIdentifierCore::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  result = caulk::xstring::clear((caulk::xstring *)v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t as::RouteIdentifierCore::operator=(uint64_t a1, uint64_t a2)
{
  as::RouteIdentifierCore::move_from(a1, a2);
  return a1;
}

uint64_t as::RouteIdentifierCore::clear(as::RouteIdentifierCore *this)
{
  uint64_t result;

  result = caulk::xstring::clear((as::RouteIdentifierCore *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 8) = 0;
  return result;
}

BOOL as::RouteIdentifierCore::isInitialized(as::RouteIdentifierCore *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::RouteIdentifierCore::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  unint64_t v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  char v27;
  unsigned int v28;
  unint64_t v29;
  char v30;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        break;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v3 + 1;
        a2[1] = v3 + 1;
        v13 = *(_BYTE *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v3 = v12;
        v14 = v10++ > 8;
        if (v14)
        {
          v11 = 0;
          break;
        }
      }
      v3 = v12;
LABEL_23:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v21 = v11 >> 3;
      if ((_DWORD)v21 == 2)
      {
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 2u;
        v3 = a2[1];
        v2 = a2[2];
      }
      else if ((_DWORD)v21 == 1)
      {
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v27 = 0;
          v28 = 0;
          v24 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v29 = v3++;
            v30 = *(_BYTE *)(v8 + v29);
            a2[1] = v3;
            v24 |= (unint64_t)(v30 & 0x7F) << v27;
            if ((v30 & 0x80) == 0)
              goto LABEL_42;
            v27 += 7;
            v20 = v28++ >= 9;
            if (v20)
            {
              LODWORD(v24) = 0;
LABEL_42:
              v25 = v29 + 1;
              goto LABEL_44;
            }
          }
          LODWORD(v24) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = 0;
          while (1)
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v26 = *(_BYTE *)(v8 + v3);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0)
              break;
            v22 += 7;
            v3 = v25;
            v14 = v23++ > 8;
            if (v14)
            {
              LODWORD(v24) = 0;
              break;
            }
          }
        }
LABEL_44:
        *(_DWORD *)(a1 + 32) = v24;
        *(_DWORD *)(a1 + 8) |= 1u;
        v3 = v25;
      }
      v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((_BYTE *)a2 + 24))
        return v4 == 0;
    }
    v15 = 0;
    v16 = 0;
    v11 = 0;
    if (v3 <= v2)
      v17 = v2;
    else
      v17 = v3;
    while (v17 != v3)
    {
      v18 = v3++;
      v19 = *(_BYTE *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0)
        goto LABEL_22;
      v15 += 7;
      v20 = v16++ >= 9;
      if (v20)
      {
        v11 = 0;
LABEL_22:
        v3 = v18 + 1;
        goto LABEL_23;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_206828BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::RouteIdentifierCore::writeTo(as::RouteIdentifierCore *this, PB::Writer *a2)
{
  int v3;
  char *v4;
  void *__p;
  char v6;

  v3 = *((_DWORD *)this + 2);
  if ((v3 & 1) != 0)
  {
    PB::Writer::writeVarInt(a2);
    v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 2) != 0)
  {
    v4 = (char *)caulk::xstring::c_str((as::RouteIdentifierCore *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v4);
    PB::Writer::write();
    if (v6 < 0)
      operator delete(__p);
  }
}

void sub_206828C6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t as::RouteIdentifierCore::formatText(as::RouteIdentifierCore *this, PB::TextFormatter *a2, const char *a3)
{
  int v5;
  char *v6;
  void *__p;
  char v9;

  PB::TextFormatter::beginObject(a2, a3);
  v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) != 0)
  {
    PB::TextFormatter::format(a2, "topologySource");
    v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    v6 = (char *)caulk::xstring::c_str((as::RouteIdentifierCore *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v9 < 0)
      operator delete(__p);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_206828D20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL as::RouteIdentifierCore::operator==(_DWORD *a1, _DWORD *a2)
{
  return a1[2] == a2[2]
      && a1[8] == a2[8]
      && caulk::xstring::compare((caulk::xstring *)(a1 + 4), (const caulk::xstring *)(a2 + 4)) == 0;
}

uint64_t as::RouteIdentifier::default_instance(as::RouteIdentifier *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_QWORD *)v3 = &off_24BFE3AE8;
    *(_QWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 24) = 0;
    as::RouteIdentifier::default_instance(void)::gInstance = v3;
  }
  return as::RouteIdentifier::default_instance(void)::gInstance;
}

void sub_206828E0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::RouteIdentifier::RouteIdentifier(uint64_t this)
{
  *(_QWORD *)this = &off_24BFE3AE8;
  *(_QWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3AE8;
  *(_QWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

as::RouteIdentifier *as::RouteIdentifier::RouteIdentifier(as::RouteIdentifier *this, const as::RouteIdentifier *a2)
{
  *(_QWORD *)this = &off_24BFE3AE8;
  *((_QWORD *)this + 2) = 0;
  as::RouteIdentifier::copy_from(this, a2);
  return this;
}

{
  *(_QWORD *)this = &off_24BFE3AE8;
  *((_QWORD *)this + 2) = 0;
  as::RouteIdentifier::copy_from(this, a2);
  return this;
}

as::RouteIdentifier *as::RouteIdentifier::copy_from(as::RouteIdentifier *this, const as::RouteIdentifier *a2)
{
  as::RouteIdentifier *v3;
  const as::RouteIdentifierCore *v4;
  as::RouteIdentifierCore *v5;

  v3 = this;
  v4 = (const as::RouteIdentifierCore *)*((_QWORD *)a2 + 2);
  if (v4)
  {
    v5 = (as::RouteIdentifierCore *)as::RouteIdentifier::mutableCoreIdentifier(this);
    this = (as::RouteIdentifier *)as::RouteIdentifierCore::copy_from(v5, v4);
  }
  *((_DWORD *)v3 + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)v3 + 6) = *((_DWORD *)a2 + 6);
  return this;
}

as::RouteIdentifier *as::RouteIdentifier::operator=(as::RouteIdentifier *a1, const as::RouteIdentifier *a2)
{
  as::RouteIdentifier::copy_from(a1, a2);
  return a1;
}

uint64_t as::RouteIdentifier::coreIdentifier(as::RouteIdentifier *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return as::RouteIdentifierCore::default_instance(0);
  return result;
}

uint64_t as::RouteIdentifier::mutableCoreIdentifier(as::RouteIdentifier *this)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
  {
    v1 = operator new();
    *(_QWORD *)v1 = &off_24BFE3BC8;
    *(_DWORD *)(v1 + 8) = 0;
    *(_QWORD *)(v1 + 16) = 0;
    *(_QWORD *)(v1 + 24) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    v3 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = v1;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  return v1;
}

uint64_t as::RouteIdentifier::RouteIdentifier(uint64_t result, uint64_t a2)
{
  *(_QWORD *)result = &off_24BFE3AE8;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

{
  *(_QWORD *)result = &off_24BFE3AE8;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t as::RouteIdentifier::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t as::RouteIdentifier::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t as::RouteIdentifier::clear(as::RouteIdentifier *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  return result;
}

uint64_t as::RouteIdentifier::isInitialized(as::RouteIdentifier *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::RouteIdentifier::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  BOOL v20;
  unint64_t v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  unsigned int v30;
  unint64_t v31;
  char v32;

  v3 = a2[1];
  v2 = a2[2];
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        break;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v3 + 1;
        a2[1] = v3 + 1;
        v13 = *(_BYTE *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v3 = v12;
        v14 = v10++ > 8;
        if (v14)
        {
          v11 = 0;
          break;
        }
      }
      v3 = v12;
LABEL_23:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      v21 = v11 >> 3;
      if ((_DWORD)v21 == 2)
      {
        v27 = operator new();
        *(_QWORD *)v27 = &off_24BFE3BC8;
        *(_DWORD *)(v27 + 8) = 0;
        *(_QWORD *)(v27 + 16) = 0;
        *(_QWORD *)(v27 + 24) = 0;
        *(_DWORD *)(v27 + 32) = 0;
        v28 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v27;
        if (v28)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
          v27 = *(_QWORD *)(a1 + 16);
        }
        if (!PB::Reader::placeMark()
          || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v27 + 16))(v27, a2) & 1) == 0)
        {
          return 0;
        }
        PB::Reader::recallMark();
        v3 = a2[1];
        v2 = a2[2];
      }
      else if ((_DWORD)v21 == 1)
      {
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          v29 = 0;
          v30 = 0;
          v24 = 0;
          if (v2 <= v3)
            v25 = v3;
          else
            v25 = v2;
          while (v25 != v3)
          {
            v31 = v3++;
            v32 = *(_BYTE *)(v8 + v31);
            a2[1] = v3;
            v24 |= (unint64_t)(v32 & 0x7F) << v29;
            if ((v32 & 0x80) == 0)
              goto LABEL_46;
            v29 += 7;
            v20 = v30++ >= 9;
            if (v20)
            {
              LODWORD(v24) = 0;
LABEL_46:
              v25 = v31 + 1;
              goto LABEL_48;
            }
          }
          LODWORD(v24) = 0;
          *((_BYTE *)a2 + 24) = 1;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = 0;
          while (1)
          {
            v25 = v3 + 1;
            a2[1] = v3 + 1;
            v26 = *(_BYTE *)(v8 + v3);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0)
              break;
            v22 += 7;
            v3 = v25;
            v14 = v23++ > 8;
            if (v14)
            {
              LODWORD(v24) = 0;
              break;
            }
          }
        }
LABEL_48:
        *(_DWORD *)(a1 + 24) = v24;
        *(_DWORD *)(a1 + 8) |= 1u;
        v3 = v25;
      }
      v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((_BYTE *)a2 + 24))
        return v4 == 0;
    }
    v15 = 0;
    v16 = 0;
    v11 = 0;
    if (v3 <= v2)
      v17 = v2;
    else
      v17 = v3;
    while (v17 != v3)
    {
      v18 = v3++;
      v19 = *(_BYTE *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0)
        goto LABEL_22;
      v15 += 7;
      v20 = v16++ >= 9;
      if (v20)
      {
        v11 = 0;
LABEL_22:
        v3 = v18 + 1;
        goto LABEL_23;
      }
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::RouteIdentifier::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3;
  const PB::Base *v4;

  v3 = this;
  if ((*(_BYTE *)(this + 8) & 1) != 0)
    this = PB::Writer::writeVarInt(a2);
  v4 = *(const PB::Base **)(v3 + 16);
  if (v4)
    return PB::Writer::writeSubmessage(a2, v4);
  return this;
}

uint64_t as::RouteIdentifier::formatText(as::RouteIdentifier *this, PB::TextFormatter *a2, const char *a3)
{
  uint64_t v5;

  PB::TextFormatter::beginObject(a2, a3);
  if ((*((_BYTE *)this + 8) & 1) != 0)
    PB::TextFormatter::format(a2, "topologyClass");
  v5 = *((_QWORD *)this + 2);
  if (v5)
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(_QWORD *)v5 + 32))(v5, a2, "coreIdentifier");
  return PB::TextFormatter::endObject(a2);
}

BOOL as::RouteIdentifier::operator==(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24))
    return 0;
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a2 + 16);
  result = (v3 | v4) == 0;
  if (v3)
    v5 = v4 == 0;
  else
    v5 = 1;
  if (!v5)
    return as::RouteIdentifierCore::operator==((_DWORD *)v3, (_DWORD *)v4);
  return result;
}

uint64_t as::RouteIdentifier::clearCoreIdentifier(as::RouteIdentifier *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void as::ChannelDescription::~ChannelDescription(as::ChannelDescription *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x20BCFDE58);
}

void as::ChannelLayout::~ChannelLayout(as::ChannelLayout *this)
{
  void **v2;

  *(_QWORD *)this = off_24BFE3A30;
  v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

{
  void **v2;

  *(_QWORD *)this = off_24BFE3A30;
  v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
  MEMORY[0x20BCFDE58]();
}

void as::StreamFormat::~StreamFormat(as::StreamFormat *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24BFE39F8;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  PB::Base::~Base(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24BFE39F8;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  PB::Base::~Base(this);
  JUMPOUT(0x20BCFDE58);
}

void as::AvailableStreamFormat::~AvailableStreamFormat(as::AvailableStreamFormat *this)
{
  as::AvailableStreamFormat::~AvailableStreamFormat(this);
  JUMPOUT(0x20BCFDE58);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_24BFE3C00;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::SampleRateRange::~SampleRateRange(as::SampleRateRange *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x20BCFDE58);
}

void as::ActivationContext::~ActivationContext(as::ActivationContext *this)
{
  as::ActivationContext::~ActivationContext(this);
  JUMPOUT(0x20BCFDE58);
}

{
  *(_QWORD *)this = &off_24BFE3B58;
  caulk::xstring::clear((as::ActivationContext *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::AggregateDevice::~AggregateDevice(as::AggregateDevice *this)
{
  as::AggregateDevice::~AggregateDevice(this);
  JUMPOUT(0x20BCFDE58);
}

{
  void **v2;

  *(_QWORD *)this = &off_24BFE3AB0;
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 88));
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 72));
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 56));
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 40));
  v2 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::RouteIdentifierCore::~RouteIdentifierCore(as::RouteIdentifierCore *this)
{
  as::RouteIdentifierCore::~RouteIdentifierCore(this);
  JUMPOUT(0x20BCFDE58);
}

{
  *(_QWORD *)this = &off_24BFE3BC8;
  caulk::xstring::clear((as::RouteIdentifierCore *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::RouteIdentifier::~RouteIdentifier(as::RouteIdentifier *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24BFE3AE8;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  PB::Base::~Base(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24BFE3AE8;
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  PB::Base::~Base(this);
  JUMPOUT(0x20BCFDE58);
}

_UNKNOWN **as::error_category::instance(as::error_category *this)
{
  return &as::error_category::instance(void)::gInstance;
}

void as::error_category::message(int __val@<W1>, _QWORD *a2@<X8>)
{
  char *v4;
  std::string *v5;
  __int128 v6;
  std::string v7;

  switch(__val)
  {
    case -1:
      v4 = "Unknown error";
      goto LABEL_27;
    case 0:
      v4 = "None";
      goto LABEL_27;
    case 1:
      v4 = "Exception caught";
      goto LABEL_27;
    case 2:
      v4 = "Unimplemented";
      goto LABEL_27;
    case 3:
      v4 = "XPC timeout";
      goto LABEL_27;
    case 4:
      v4 = "Invalid session token";
      goto LABEL_27;
    case 5:
      v4 = "Session access permission error";
      goto LABEL_27;
    case 6:
      v4 = "Message parse error";
      goto LABEL_27;
    case 7:
      v4 = "Invalid state change";
      goto LABEL_27;
    case 8:
      v4 = "Too many configuration requests";
      goto LABEL_27;
    case 9:
      v4 = "Invalid parameter";
      goto LABEL_27;
    case 10:
      v4 = "Block already started/stopped";
      goto LABEL_27;
    case 11:
      v4 = "Client session is no longer valid";
      goto LABEL_27;
    case 12:
      v4 = "Invalid IO controller type";
      goto LABEL_27;
    case 13:
      v4 = "Expired AURA object";
      goto LABEL_27;
    case 14:
      v4 = "Expired sub-session object";
      goto LABEL_27;
    case 16:
      v4 = "Restarting I/O after session reconfiguration failed";
      goto LABEL_27;
    case 17:
      v4 = "AURA simulation failed";
      goto LABEL_27;
    case 18:
      v4 = "Multiple I/O blocks with an unmixable output format";
      goto LABEL_27;
    case 19:
      v4 = "Cannot transfer I/O resources of an active session";
      goto LABEL_27;
    case 20:
      v4 = "Process does not own session's I/O resources";
      goto LABEL_27;
    case 21:
      v4 = "Starting I/O timed out";
      goto LABEL_27;
    case 22:
      v4 = "Unknown property";
      goto LABEL_27;
    case 23:
      v4 = "Exception when dispatching property";
      goto LABEL_27;
    case 24:
      v4 = "Bad hardware state (e.g. sample rate 0)";
LABEL_27:
      std::string::basic_string[abi:ne180100]<0>(a2, v4);
      break;
    default:
      std::to_string(&v7, __val);
      v5 = std::string::insert(&v7, 0, "Garbage error code: ", 0x14uLL);
      v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
      a2[2] = *((_QWORD *)&v5->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v6;
      v5->__r_.__value_.__l.__size_ = 0;
      v5->__r_.__value_.__r.__words[2] = 0;
      v5->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v7.__r_.__value_.__l.__data_);
      break;
  }
}

void sub_206829A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_UNKNOWN **as::public_error_category::instance(as::public_error_category *this)
{
  return &as::public_error_category::instance(void)::gInstance;
}

void as::public_error_category::message(int __val@<W1>, _QWORD *a2@<X8>)
{
  char *v4;
  std::string *v5;
  __int128 v6;
  std::string v7;

  if (__val <= 561145186)
  {
    if (__val <= 560161139)
    {
      switch(__val)
      {
        case -50:
          v4 = "Bad parameter";
          goto LABEL_37;
        case 0:
          v4 = (char *)&unk_20682C077;
          goto LABEL_37;
        case 560030580:
          v4 = "Action cannot be performed while I/O is running";
          goto LABEL_37;
      }
    }
    else if (__val > 561015904)
    {
      if (__val == 561015905)
      {
        v4 = "Missing background mode or category is not compatible with background audio usage";
        goto LABEL_37;
      }
      if (__val == 561017449)
      {
        v4 = "Insufficient priority to activate at this time";
        goto LABEL_37;
      }
    }
    else
    {
      if (__val == 560161140)
      {
        v4 = "Operation is incompatible with the current audio category";
        goto LABEL_37;
      }
      if (__val == 560557684)
      {
        v4 = "Activation cannot be performed when the application is backgrounded";
        goto LABEL_37;
      }
    }
  }
  else if (__val > 1768841570)
  {
    if (__val > 1936290408)
    {
      if (__val == 1936290409)
      {
        v4 = "Action cannot be performed because Siri is recording";
        goto LABEL_37;
      }
      if (__val == 2003329396)
      {
        v4 = "An unspecifed error occurred";
        goto LABEL_37;
      }
    }
    else
    {
      if (__val == 1768841571)
      {
        v4 = "Session not active";
        goto LABEL_37;
      }
      if (__val == 1836282486)
      {
        v4 = "Server error";
        goto LABEL_37;
      }
    }
  }
  else if (__val > 561210738)
  {
    if (__val == 561210739)
    {
      v4 = "The session has been destroyed";
      goto LABEL_37;
    }
    if (__val == 1701737535)
    {
      v4 = "Missing entitlement";
      goto LABEL_37;
    }
  }
  else
  {
    if (__val == 561145187)
    {
      v4 = "Cannot start recording at this time";
      goto LABEL_37;
    }
    if (__val == 561145203)
    {
      v4 = "Hardware resource not available";
LABEL_37:
      std::string::basic_string[abi:ne180100]<0>(a2, v4);
      return;
    }
  }
  std::to_string(&v7, __val);
  v5 = std::string::insert(&v7, 0, "Garbage error code: ", 0x14uLL);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  a2[2] = *((_QWORD *)&v5->__r_.__value_.__l + 2);
  *(_OWORD *)a2 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v7.__r_.__value_.__l.__data_);
}

void sub_206829D20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void as::error_category::~error_category(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x20BCFDE58);
}

const char *as::error_category::name(as::error_category *this)
{
  return "Session Manager Error";
}

void as::public_error_category::~public_error_category(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x20BCFDE58);
}

const char *as::public_error_category::name(as::public_error_category *this)
{
  return "AVAudioSession Error";
}

id CreateRootDispatchQueue()
{
  void *v0;
  sched_param v2;
  pthread_attr_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  pthread_attr_init(&v3);
  v2 = 0;
  pthread_attr_getschedparam(&v3, &v2);
  v2.sched_priority = 47;
  pthread_attr_setschedparam(&v3, &v2);
  pthread_attr_setschedpolicy(&v3, 4);
  v0 = (void *)dispatch_pthread_root_queue_create();
  pthread_attr_destroy(&v3);
  return v0;
}

void sub_206829E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, pthread_attr_t *a10)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void CreateDispatchQueueWithTarget(uint64_t a1@<X0>, void *a2@<X1>, id *a3@<X8>)
{
  NSObject *v5;
  NSObject *v6;
  const char *v7;
  void *v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *target;

  target = a2;
  dispatch_queue_attr_make_initially_inactive(0);
  v5 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_autorelease_frequency(v5, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v6 = objc_claimAutoreleasedReturnValue();

  if (*(char *)(a1 + 23) >= 0)
    v7 = (const char *)a1;
  else
    v7 = *(const char **)a1;
  *a3 = dispatch_queue_create_with_target_V2(v7, v6, target);
  applesauce::dispatch::v1::queue::operator*(a3);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v8)
  {
    v10 = _os_crash();
    as::WorkloopPool::WorkloopPool(v10);
  }
  applesauce::dispatch::v1::queue::operator*(a3);
  v9 = objc_claimAutoreleasedReturnValue();
  dispatch_activate(v9);

}

void sub_206829F50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id *v10;
  void *v11;

  applesauce::dispatch::v1::queue::~queue(v10);

  _Unwind_Resume(a1);
}

id applesauce::dispatch::v1::queue::operator*(id *a1)
{
  return *a1;
}

void applesauce::dispatch::v1::queue::~queue(id *this)
{
  id v2;

  v2 = *this;
  *this = 0;

}

void FormatNSErrorForReturn(int a1)
{
  _DWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x24BDAC8D0];
  v1[0] = 67109120;
  v1[1] = a1;
  _os_log_fault_impl(&dword_2067F2000, MEMORY[0x24BDACB70], OS_LOG_TYPE_FAULT, "Not expected to see error code %d!", (uint8_t *)v1, 8u);
}

void as::smipc_Server_types_utility::updateDefaultRoute()
{
  _Unwind_Exception *v0;

  v0 = (_Unwind_Exception *)_os_crash();
  __break(1u);
  _Unwind_Resume(v0);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

uint64_t PB::TextFormatter::beginObject(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x24BE7B1E8](this, a2);
}

uint64_t PB::TextFormatter::format()
{
  return MEMORY[0x24BE7B1F8]();
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x24BE7B200](this, a2);
}

{
  return MEMORY[0x24BE7B218](this, a2);
}

{
  return MEMORY[0x24BE7B220](this, a2);
}

{
  return MEMORY[0x24BE7B230](this, a2);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, double a3)
{
  return MEMORY[0x24BE7B208](this, a2, a3);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, float a3)
{
  return MEMORY[0x24BE7B210](this, a2, a3);
}

uint64_t PB::TextFormatter::endObject(PB::TextFormatter *this)
{
  return MEMORY[0x24BE7B238](this);
}

void PB::Base::~Base(PB::Base *this)
{
  MEMORY[0x24BE7B240](this);
}

uint64_t PB::Reader::recallMark()
{
  return MEMORY[0x24BE7B258]();
}

uint64_t PB::Reader::read()
{
  return MEMORY[0x24BE7B268]();
}

uint64_t PB::Reader::placeMark()
{
  return MEMORY[0x24BE7B278]();
}

uint64_t PB::Writer::writeVarInt(PB::Writer *this)
{
  return MEMORY[0x24BE7B288](this);
}

{
  return MEMORY[0x24BE7B290](this);
}

{
  return MEMORY[0x24BE7B2A0](this);
}

uint64_t PB::Writer::writeSubmessage(PB::Writer *this, const PB::Base *a2)
{
  return MEMORY[0x24BE7B2A8](this, a2);
}

uint64_t PB::Writer::write()
{
  return MEMORY[0x24BE7B2B8]();
}

uint64_t PB::Writer::write(PB::Writer *this)
{
  return MEMORY[0x24BE7B2C0](this);
}

uint64_t PB::Writer::write(PB::Writer *this, double a2)
{
  return MEMORY[0x24BE7B2C8](this, a2);
}

uint64_t PB::Writer::write(PB::Writer *this, float a2)
{
  return MEMORY[0x24BE7B2D0](this, a2);
}

uint64_t caulk::xstring::move()
{
  return MEMORY[0x24BEC6EE0]();
}

uint64_t caulk::xstring::clear(caulk::xstring *this)
{
  return MEMORY[0x24BEC6EE8](this);
}

uint64_t caulk::xstring::assign()
{
  return MEMORY[0x24BEC6EF0]();
}

uint64_t caulk::xstring::assign(caulk::xstring *this, const caulk::xstring *a2)
{
  return MEMORY[0x24BEC6EF8](this, a2);
}

uint64_t caulk::xstring::c_str(caulk::xstring *this)
{
  return MEMORY[0x24BEC6F48](this);
}

uint64_t caulk::xstring::compare(caulk::xstring *this, const caulk::xstring *a2)
{
  return MEMORY[0x24BEC6F50](this, a2);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x24BEDAB48](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
  MEMORY[0x24BEDAB68](this);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC40](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC88](this, __pos, __s, __n);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
  MEMORY[0x24BEDACC0](this, __old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x24BEDACC8](this, __c);
}

void std::error_category::~error_category(std::error_category *this)
{
  MEMORY[0x24BEDB028](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x24BEDB188](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x24BEDB438](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x24BEDB440](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

const std::locale *__cdecl std::locale::operator=(std::locale *this, const std::locale *a2)
{
  return (const std::locale *)MEMORY[0x24BEDB450](this, a2);
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, double a4)
{
  return MEMORY[0x24BEDB5A0](this, a2, a3, a4);
}

{
  return MEMORY[0x24BEDB5B8](this, a2, a3, a4);
}

uint64_t std::to_chars()
{
  return MEMORY[0x24BEDB5A8]();
}

{
  return MEMORY[0x24BEDB5B0]();
}

{
  return MEMORY[0x24BEDB5C0]();
}

{
  return MEMORY[0x24BEDB5C8]();
}

{
  return MEMORY[0x24BEDB5D8]();
}

{
  return MEMORY[0x24BEDB5E0]();
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, float a4)
{
  return MEMORY[0x24BEDB5D0](this, a2, a3, a4);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x24BEDB608](retstr, *(_QWORD *)&__val);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x24BEDB688](this);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_24BFE35E0(__p);
}

uint64_t operator delete()
{
  return off_24BFE35E8();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24BFE35F0(__sz);
}

uint64_t operator new()
{
  return off_24BFE35F8();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x24BEDB940](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x24BEDB958]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

uint64_t __udivti3()
{
  return MEMORY[0x24BDAC940]();
}

uint64_t __umodti3()
{
  return MEMORY[0x24BDAC958]();
}

uint64_t _os_crash()
{
  return MEMORY[0x24BDACB50]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x24BDACB60]();
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB88](dso, log, type, format, buf, *(_QWORD *)&size);
}

void dispatch_activate(dispatch_object_t object)
{
  MEMORY[0x24BDADC58](object);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

uint64_t dispatch_pthread_root_queue_create()
{
  return MEMORY[0x24BDADEA8]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEB0](attr);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEB8](attr, frequency);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED8](label, attr, target);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x24BDAE018](label);
}

void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t workloop, dispatch_autorelease_frequency_t frequency)
{
  MEMORY[0x24BDAE028](workloop, frequency);
}

uint64_t dispatch_workloop_set_scheduler_priority()
{
  return MEMORY[0x24BDAE048]();
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x24BEDCFA8](a1);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x24BEDD2C0](a1);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF460](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF488](lock);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF778](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x24BDAF780](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF790](a1);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x24BDAF7B0](a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x24BDAF7B8](a1, *(_QWORD *)&a2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

