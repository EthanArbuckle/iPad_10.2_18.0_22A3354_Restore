void re::StackScratchAllocator::FreePersistentBlocks(re::StackScratchAllocator *this)
{
  re *v1;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  unint64_t v7;

  std::mutex::lock(&re::StackScratchAllocator::s_mutex);
  if (atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount))
  {
    for (i = 0; i < v7; ++i)
    {
      v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      v5 = *(_QWORD *)(v4 + 8);
      if (v5)
      {
        v6 = re::globalAllocators(v1);
        v1 = (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v6[2] + 40))(v6[2], v5);
        v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      }
      *(_QWORD *)(v4 + 8) = 0;
      v7 = atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
    }
  }
  atomic_store(0, &re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
  std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
}

uint64_t re::Allocator::addDestructor(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t re::Allocator::destructorCalledByDefault(re::Allocator *this)
{
  return 1;
}

double re::HashTable<unsigned long,unsigned long,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = a1[2];
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t *re::globalAllocators(re *this)
{
  unsigned __int8 v1;
  _anonymous_namespace_ *v3;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      re::globalAllocators(void)::s_instance = (uint64_t)&off_24E0704C8;
      byte_25529BA50 = 0;
      *(_OWORD *)algn_25529BA60 = 0u;
      *(_OWORD *)&algn_25529BA60[16] = 0u;
      re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
    }
  }
  return &re::globalAllocators(void)::s_instance;
}

void `anonymous namespace'::internalSystemAllocator(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      byte_25529BAD0 = 0;
      *(_QWORD *)algn_25529BAC8 = "System allocator";
    }
  }
}

_anonymous_namespace_ *re::initGlobalAllocators(re *this)
{
  _anonymous_namespace_ *result;

  result = (_anonymous_namespace_ *)re::globalAllocators(this);
  if (!byte_25529BA50)
  {
    re::globalAllocators(result);
    return re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
  }
  return result;
}

_anonymous_namespace_ *re::GlobalAllocators::init(_anonymous_namespace_ *this)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  re::Allocator *v3;
  uint64_t v4;
  re::Allocator *v5;
  uint64_t v6;
  re::Allocator *v7;
  uint64_t v8;

  if (!*((_BYTE *)this + 8))
  {
    v1 = this;
    re::globalMemoryTracker(this);
    if (!re::globalMemoryTracker(void)::s_instance)
    {
      qword_25529BA90[0] = *((_QWORD *)v1 + 2);
      re::DynamicArray<re::Allocator const*>::setCapacity(qword_25529BA90, 0x400uLL);
      ++dword_25529BAA8;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
    re::MemoryTracker::track((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, *((const re::Allocator **)v1 + 2));
    v2 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 104, 8);
    v3 = re::Allocator::Allocator((re::Allocator *)v2, "SIMD-aligned allocator", 1);
    *((_QWORD *)v3 + 8) = 0;
    *((_QWORD *)v3 + 9) = 0;
    *(_OWORD *)((char *)v3 + 20) = 0u;
    *(_OWORD *)((char *)v3 + 36) = 0u;
    *(_QWORD *)((char *)v3 + 52) = 0;
    *(_QWORD *)v3 = &off_24E0705D8;
    *((_QWORD *)v3 + 10) = 0;
    *((_QWORD *)v3 + 11) = 0;
    re::BaseAllocator::init(v3);
    *(_DWORD *)(v2 + 20) |= 1u;
    *(_QWORD *)(v2 + 80) = 16;
    *((_QWORD *)v1 + 3) = v2;
    v4 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 104, 8);
    v5 = re::Allocator::Allocator((re::Allocator *)v4, "Cache-aligned allocator", 1);
    *((_QWORD *)v5 + 8) = 0;
    *((_QWORD *)v5 + 9) = 0;
    *(_OWORD *)((char *)v5 + 20) = 0u;
    *(_OWORD *)((char *)v5 + 36) = 0u;
    *(_QWORD *)((char *)v5 + 52) = 0;
    *(_QWORD *)v5 = &off_24E0705D8;
    *((_QWORD *)v5 + 10) = 0;
    *((_QWORD *)v5 + 11) = 0;
    re::BaseAllocator::init(v5);
    *(_DWORD *)(v4 + 20) |= 1u;
    *(_QWORD *)(v4 + 80) = 64;
    *((_QWORD *)v1 + 4) = v4;
    v6 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 104, 8);
    v7 = re::Allocator::Allocator((re::Allocator *)v6, "TLB-aligned allocator", 1);
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 9) = 0;
    *(_OWORD *)((char *)v7 + 20) = 0u;
    *(_OWORD *)((char *)v7 + 36) = 0u;
    *(_QWORD *)((char *)v7 + 52) = 0;
    *(_QWORD *)v7 = &off_24E0705D8;
    *((_QWORD *)v7 + 10) = 0;
    *((_QWORD *)v7 + 11) = 0;
    re::BaseAllocator::init(v7);
    *(_DWORD *)(v6 + 20) |= 1u;
    *(_QWORD *)(v6 + 80) = 0x4000;
    *((_QWORD *)v1 + 5) = v6;
    v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 5304, 8);
    *(_BYTE *)v8 = 0;
    *(_QWORD *)(v8 + 88) = 0;
    *(_QWORD *)(v8 + 96) = 0;
    *(_DWORD *)(v8 + 104) = 0;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 68) = 0u;
    *(_QWORD *)(v8 + 108) = 0x1FFFFFFFFLL;
    *(_DWORD *)(v8 + 120) = 0;
    *(_QWORD *)(v8 + 136) = 0;
    *(_QWORD *)(v8 + 144) = 0;
    *(_QWORD *)(v8 + 128) = 0;
    *(_DWORD *)(v8 + 152) = 0;
    bzero((void *)(v8 + 160), 0x1418uLL);
    *((_QWORD *)v1 + 6) = v8;
    this = re::PerFrameAllocatorManager::init((_anonymous_namespace_ *)v8);
    *((_BYTE *)v1 + 8) = 1;
  }
  return this;
}

void re::deinitGlobalAllocators(re *this)
{
  uint64_t *v1;

  v1 = re::globalAllocators(this);
  if (byte_25529BA50)
  {
    re::globalAllocators((re *)v1);
    re::GlobalAllocators::deinit((re **)&re::globalAllocators(void)::s_instance);
  }
}

void re::GlobalAllocators::deinit(re **this)
{
  re *v2;
  const re::Allocator *v3;
  re *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  re *v16;
  re *v17;
  re *v18;
  _anonymous_namespace_ *v19;

  if (*((_BYTE *)this + 8))
  {
    re::StackScratchAllocator::FreePersistentBlocks((re::StackScratchAllocator *)this);
    re::globalMemoryTracker(v2);
    re::PerFrameAllocatorManager::deinit(this[6]);
    v3 = this[2];
    v4 = this[6];
    if (v4)
    {
      v5 = 5120;
      do
      {
        *(_QWORD *)((char *)v4 + v5 + 128) = 0;
        v5 -= 40;
      }
      while (v5);
      v6 = *((_QWORD *)v4 + 16);
      if (v6)
      {
        v7 = *((_QWORD *)v4 + 20);
        if (v7)
        {
          v8 = *((_QWORD *)v4 + 18);
          if (v8)
          {
            v9 = 88 * v8;
            v10 = v7 + 40;
            do
            {
              v11 = *(_QWORD *)(v10 + 8);
              if (v11)
              {
                if (*(_QWORD *)(v10 + 40))
                  (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
                *(_QWORD *)(v10 + 40) = 0;
                *(_QWORD *)(v10 + 16) = 0;
                *(_QWORD *)(v10 + 24) = 0;
                *(_QWORD *)(v10 + 8) = 0;
                ++*(_DWORD *)(v10 + 32);
              }
              v12 = *(_QWORD *)(v10 - 32);
              if (v12)
              {
                if (*(_QWORD *)v10)
                  (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
                *(_QWORD *)v10 = 0;
                *(_QWORD *)(v10 - 24) = 0;
                *(_QWORD *)(v10 - 16) = 0;
                *(_QWORD *)(v10 - 32) = 0;
                ++*(_DWORD *)(v10 - 8);
              }
              v10 += 88;
              v9 -= 88;
            }
            while (v9);
            v6 = *((_QWORD *)v4 + 16);
            v7 = *((_QWORD *)v4 + 20);
          }
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, v7);
        }
        *((_QWORD *)v4 + 20) = 0;
        *((_QWORD *)v4 + 17) = 0;
        *((_QWORD *)v4 + 18) = 0;
        *((_QWORD *)v4 + 16) = 0;
        ++*((_DWORD *)v4 + 38);
      }
      re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)v4 + 56);
      v13 = *((_QWORD *)v4 + 7);
      if (v13)
      {
        if (*((_QWORD *)v4 + 11))
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        *((_QWORD *)v4 + 11) = 0;
        *((_QWORD *)v4 + 8) = 0;
        *((_QWORD *)v4 + 9) = 0;
        *((_QWORD *)v4 + 7) = 0;
        ++*((_DWORD *)v4 + 20);
      }
      v14 = *((_QWORD *)v4 + 4);
      if (v14)
      {
        if (*((_QWORD *)v4 + 5))
        {
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 40))(v14, *((_QWORD *)v4 + 6));
          *((_QWORD *)v4 + 5) = 0;
          *((_QWORD *)v4 + 6) = 0;
        }
        *((_QWORD *)v4 + 4) = 0;
      }
      v15 = *((_QWORD *)v4 + 1);
      if (v15)
      {
        if (*((_QWORD *)v4 + 2))
        {
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 40))(v15, *((_QWORD *)v4 + 3));
          *((_QWORD *)v4 + 2) = 0;
          *((_QWORD *)v4 + 3) = 0;
        }
        *((_QWORD *)v4 + 1) = 0;
      }
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v4);
      v3 = this[2];
    }
    this[6] = 0;
    v16 = this[5];
    if (v16)
    {
      (**(void (***)(re *))v16)(this[5]);
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v16);
      v3 = this[2];
    }
    this[5] = 0;
    v17 = this[4];
    if (v17)
    {
      (**(void (***)(re *))v17)(this[4]);
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v17);
      v3 = this[2];
    }
    this[4] = 0;
    v18 = this[3];
    if (v18)
    {
      (**(void (***)(re *))v18)(this[3]);
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v18);
      v3 = this[2];
    }
    this[3] = 0;
    re::MemoryTracker::untrack((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, v3);
    v19 = (_anonymous_namespace_ *)re::MemoryTracker::deinit(&re::globalMemoryTracker(void)::s_instance);
    *((_BYTE *)this + 8) = 0;
  }
}

void re::GlobalAllocators::~GlobalAllocators(re **this)
{
  *this = (re *)&off_24E0704C8;
  re::GlobalAllocators::deinit(this);
}

{
  *this = (re *)&off_24E0704C8;
  re::GlobalAllocators::deinit(this);
  JUMPOUT(0x220780CD0);
}

char *re::globalMemoryTracker(re *this)
{
  unsigned __int8 v1;
  _anonymous_namespace_ *v3;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      re::globalMemoryTracker(void)::s_instance = 0;
      qword_25529BAB0 = 0;
      *(_OWORD *)&algn_25529BA89[3] = 0u;
      unk_25529BA9C = 0u;
      re::DynamicArray<re::Allocator const*>::setCapacity(qword_25529BA90, 0x400uLL);
      ++dword_25529BAA8;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
  }
  return &re::globalMemoryTracker(void)::s_instance;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::deinit(uint64_t result)
{
  uint64_t *v1;
  double v2;
  _QWORD *v3;

  if (*(_DWORD *)(result + 44))
  {
    v1 = (uint64_t *)result;
    v2 = re::DataArray<re::PerFrameAllocatorImpl>::clear((_QWORD *)result);
    if (!v1[2])
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v3 = (_QWORD *)v1[4];
    (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)*v1 + 40))(*v1, *v3, v2);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v3[1]);
    result = *v1;
    if (*v1)
    {
      if (v1[4])
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      v1[4] = 0;
      v1[1] = 0;
      v1[2] = 0;
      *v1 = 0;
      ++*((_DWORD *)v1 + 6);
    }
    *((_DWORD *)v1 + 11) = 0;
  }
  return result;
}

double re::DataArray<re::PerFrameAllocatorImpl>::clear(_QWORD *a1)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double result;
  _OWORD v12[5];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)v12, (uint64_t)a1, 0);
  if (*(_QWORD **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFFLL || (DWORD2(v12[0]) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v4 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)v12);
      re::DataArray<re::PerFrameAllocatorImpl>::destroy((uint64_t)a1, v4);
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(v12);
    }
    while (*(_QWORD **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFF || WORD5(v12[0]) != 0xFFFF);
  }
  v7 = a1[2];
  v8 = v7 - 1;
  if (v7 != 1)
  {
    v9 = 16 * v7;
    do
    {
      if (a1[2] <= v8)
      {
        memset(v12, 0, sizeof(v12));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v10 = a1[4] + v9;
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, *(_QWORD *)(v10 - 16));
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, *(_QWORD *)(v10 - 8));
      re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt((uint64_t)a1, v8);
      v9 -= 16;
      --v8;
    }
    while (v8);
  }
  result = NAN;
  a1[6] = 0xFFFFFFFF00000000;
  return result;
}

uint64_t (***re::DataArray<re::PerFrameAllocatorImpl>::destroy(uint64_t a1, unint64_t a2))(_QWORD)
{
  int v2;
  unint64_t v4;
  uint64_t (***result)(_QWORD);
  _DWORD *v6;

  v2 = a2;
  v4 = a2 >> 16;
  result = (uint64_t (***)(_QWORD))re::DataArray<re::PerFrameAllocatorImpl>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (result)
  {
    v6 = result;
    result = (uint64_t (***)(_QWORD))(**result)(result);
    if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
  return result;
}

unint64_t re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle(unsigned __int16 *a1)
{
  unint64_t v1;

  v1 = a1[5];
  if (*(_QWORD *)(*(_QWORD *)a1 + 16) <= v1)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return (v1 << 16) | ((unint64_t)(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 16 * v1 + 8)
                                                    + 4 * a1[4]) & 0xFFFFFF) << 32) | a1[4];
}

uint64_t re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = v2 - 1;
  if (v2 - 1 > a2)
  {
    *(_OWORD *)(*(_QWORD *)(result + 32) + 16 * a2) = *(_OWORD *)(*(_QWORD *)(result + 32) + 16 * v2 - 16);
    v3 = *(_QWORD *)(result + 16) - 1;
  }
  *(_QWORD *)(result + 16) = v3;
  ++*(_DWORD *)(result + 24);
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator(uint64_t a1, uint64_t a2, char a3)
{
  *(_QWORD *)a1 = a2;
  if ((a3 & 1) != 0 || !*(_DWORD *)(a2 + 40))
  {
    *(_DWORD *)(a1 + 8) = -1;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    if (!*(_QWORD *)(a2 + 16))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (!**(_DWORD **)(*(_QWORD *)(a2 + 32) + 8))
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment((_WORD *)a1);
  }
  return a1;
}

_WORD *re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(_WORD *result)
{
  uint64_t v1;
  unint64_t v2;
  unsigned __int16 v3;
  unsigned __int16 v4;
  unsigned __int16 v5;

  v1 = *(_QWORD *)result;
  v2 = *(_QWORD *)(*(_QWORD *)result + 16);
  v3 = v2 - 1;
  v4 = result[4];
  v5 = result[5];
  while (1)
  {
    ++v4;
    if (v5 < v3 && *(_DWORD *)(v1 + 44) <= v4)
    {
      v4 = 0;
      result[5] = ++v5;
    }
    if (v5 == v3 && *(_DWORD *)(v1 + 48) <= v4)
      break;
    if (v2 <= v5)
    {
      result[4] = v4;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 16 * v5 + 8) + 4 * v4))
    {
      result[4] = v4;
      return result;
    }
  }
  *((_DWORD *)result + 2) = -1;
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  BOOL v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (v3 = *(_DWORD *)(a1 + 44)) : (v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((v4 = *(_QWORD *)(a1 + 32),
          (v5 = *(_DWORD *)(*(_QWORD *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (v6 = 0),
         v6)))
  {
    return *(_QWORD *)(v4 + 16 * WORD1(a2)) + 184 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

re::MallocZoneAllocator *re::MallocZoneAllocator::MallocZoneAllocator(re::MallocZoneAllocator *this, const char *a2, int a3)
{
  malloc_zone_t *zone;

  *(_QWORD *)re::Allocator::Allocator(this, a2, a3) = &off_24E0704F8;
  zone = malloc_create_zone(0, 0);
  *((_QWORD *)this + 3) = zone;
  malloc_set_zone_name(zone, a2);
  return this;
}

void re::MallocZoneAllocator::~MallocZoneAllocator(malloc_zone_t **this)
{
  *this = (malloc_zone_t *)&off_24E0704F8;
  malloc_destroy_zone(this[3]);
  this[3] = 0;
  re::Allocator::~Allocator((re::Allocator *)this);
}

{
  *this = (malloc_zone_t *)&off_24E0704F8;
  malloc_destroy_zone(this[3]);
  this[3] = 0;
  re::Allocator::~Allocator((re::Allocator *)this);
  JUMPOUT(0x220780CD0);
}

void *re::MallocZoneAllocator::alloc(malloc_zone_t **this, size_t size, unint64_t a3)
{
  uint64_t v3;

  v3 = 16;
  if (a3 > 0x10)
    v3 = a3;
  return malloc_type_zone_memalign(this[3], (v3 + 7) & 0xFFFFFFFFFFFFFFF8, size, 0x2419C6E8uLL);
}

void re::MallocZoneAllocator::free(malloc_zone_t **this, void *a2)
{
  if (a2)
    malloc_zone_free(this[3], a2);
}

uint64_t re::MallocZoneAllocator::parent(re::MallocZoneAllocator *this)
{
  return 0;
}

uint64_t re::MallocZoneAllocator::statistics(re::MallocZoneAllocator *this)
{
  return 0;
}

_QWORD *re::MemoryTracker::deinit(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;

  if (*(_BYTE *)this)
  {
    v1 = this;
    v2 = this + 1;
    this = (_QWORD *)this[1];
    if (this)
    {
      if (v1[5])
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 40))(this);
      v1[5] = 0;
      v2[1] = 0;
      v2[2] = 0;
      *v2 = 0;
      ++*((_DWORD *)v1 + 8);
    }
    *(_BYTE *)v1 = 0;
  }
  return this;
}

void re::MemoryTracker::track(os_unfair_lock_s *this, const re::Allocator *a2)
{
  os_unfair_lock_s *v3;
  const re::Allocator *v4;

  v4 = a2;
  v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::Allocator const*>::add(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

_QWORD *re::DynamicArray<re::Allocator const*>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::Allocator const*>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::MemoryTracker::untrack(os_unfair_lock_s *this, const re::Allocator *a2)
{
  os_unfair_lock_s *v3;
  const re::Allocator *v4;

  v4 = a2;
  v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::Allocator const*>::removeStable(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

BOOL re::DynamicArray<re::Allocator const*>::removeStable(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v2 = a1[4];
  v3 = a1[2];
  if (v3)
  {
    v4 = 8 * v3;
    v5 = (_QWORD *)a1[4];
    while (*v5 != *a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        v5 = (_QWORD *)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    v5 = (_QWORD *)a1[4];
  }
  v6 = (uint64_t)v5 - v2;
  v7 = v6 >> 3;
  if (v6 >> 3 != v3)
    re::DynamicArray<re::Allocator const*>::removeStableAt(a1, v6 >> 3);
  return v7 != v3;
}

_QWORD *re::DynamicArray<re::Allocator const*>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Allocator const*>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::Allocator const*>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Allocator const*>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Allocator const*>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Allocator const*>::removeStableAt(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = result;
  v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    v5 = result[4];
    result = (_QWORD *)(v5 + 8 * a2);
    v6 = (char *)(v5 + 8 * v2);
    if (v6 != (char *)(result + 1))
    {
      result = memmove(result, result + 1, v6 - (char *)(result + 1));
      v4 = v3[2] - 1;
    }
  }
  v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

id *re::ObjCObject::operator=(id *location, id *a2)
{
  if (location != a2)
    objc_storeStrong(location, *a2);
  return location;
}

void **re::ObjCObject::operator=(void **a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = *a1;
  if (*a1 != v3)
  {
    *a1 = v3;

    v3 = 0;
  }

  return a1;
}

re::PoolAllocator *re::PoolAllocator::PoolAllocator(re::PoolAllocator *this, const char *a2, unint64_t a3, uint64_t a4, re::Allocator *a5, unint64_t a6)
{
  re::Allocator *v11;
  uint64_t v12;
  int8x8_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  re::PoolAllocator *result;

  v11 = re::Allocator::Allocator(this, a2, 1);
  *(_QWORD *)v11 = &off_24E070568;
  *((_QWORD *)v11 + 3) = a5;
  *((_DWORD *)v11 + 8) = 0;
  *((_DWORD *)v11 + 10) = 0;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_DWORD *)v11 + 20) = 0;
  *(_QWORD *)((char *)v11 + 84) = 0x7FFFFFFFLL;
  *((_QWORD *)v11 + 16) = 0;
  *((_QWORD *)v11 + 13) = 0;
  *((_QWORD *)v11 + 14) = 0;
  *((_DWORD *)v11 + 30) = 0;
  *((_QWORD *)v11 + 12) = a5;
  re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)v11 + 12, 0);
  ++*((_DWORD *)this + 30);
  *((_QWORD *)this + 17) = a5;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((_QWORD *)this + 17, 0);
  ++*((_DWORD *)this + 40);
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_WORD *)this + 116) = 1;
  v13 = (int8x8_t)16;
  if (a6 > 0x10)
    v13 = (int8x8_t)a6;
  *((int8x8_t *)this + 22) = v13;
  v14 = 32;
  if (a4)
    v14 = a4;
  *((_QWORD *)this + 24) = a3;
  v15 = 8;
  if (a3 > 8)
    v15 = a3;
  if (v15 >= 0x18)
  {
    *((_QWORD *)this + 26) = 8;
    v15 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    *((_QWORD *)this + 28) = v15 - 8;
    *((_BYTE *)this + 233) = 1;
  }
  v16 = v15 + 7;
  *((_QWORD *)this + 27) = v16 & 0xFFFFFFFFFFFFFFF8;
  v17 = (uint8x8_t)vcnt_s8(v13);
  v17.i16[0] = vaddlv_u8(v17);
  v18 = (v16 | 7) + *(_QWORD *)&v13;
  v19 = v18 / *(_QWORD *)&v13 * *(_QWORD *)&v13;
  v20 = v18 & -*(_QWORD *)&v13;
  if (v17.u32[0] != 1)
    v20 = v19;
  *((_QWORD *)this + 23) = v20;
  v21 = v20 * v14;
  *((_QWORD *)this + 25) = v21;
  if (HIDWORD(v21))
  {
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) ", "m_blockSize <= std::numeric_limits<uint32_t>::max()", "PoolAllocator", 52);
    result = (re::PoolAllocator *)_os_crash();
    __break(1u);
  }
  else
  {
    *((_QWORD *)this + 25) = v21 + *(_QWORD *)&v13;
    return this;
  }
  return result;
}

void re::PoolAllocator::~PoolAllocator(re::PoolAllocator *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*((_QWORD *)this + 3))
  {
    v2 = *((_QWORD *)this + 14);
    if (v2)
    {
      v3 = (uint64_t *)*((_QWORD *)this + 16);
      v4 = 8 * v2;
      do
      {
        v5 = *v3++;
        (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), v5);
        v4 -= 8;
      }
      while (v4);
    }
    *((_QWORD *)this + 14) = 0;
    ++*((_DWORD *)this + 30);
    *((_QWORD *)this + 3) = 0;
  }
  v6 = *((_QWORD *)this + 17);
  if (v6)
  {
    if (*((_QWORD *)this + 21))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 18) = 0;
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 17) = 0;
    ++*((_DWORD *)this + 40);
  }
  v7 = *((_QWORD *)this + 12);
  if (v7)
  {
    if (*((_QWORD *)this + 16))
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 12) = 0;
    ++*((_DWORD *)this + 30);
  }
  re::HashTable<unsigned long,unsigned long,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit((uint64_t *)this + 6);
  re::Allocator::~Allocator(this);
}

{
  re::PoolAllocator::~PoolAllocator(this);
  JUMPOUT(0x220780CD0);
}

unint64_t re::PoolAllocator::alloc(re::PoolAllocator *this, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __n128 v27;

  if (!*((_QWORD *)this + 3) || *((_QWORD *)this + 22) < a3 || *((_QWORD *)this + 24) < a2)
    return 0;
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  if (!*((_QWORD *)this + 19))
  {
    v11 = *((_QWORD *)this + 3);
    if (!v11)
      goto LABEL_38;
    v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v11 + 32))(v11, *((_QWORD *)this + 25), *((_QWORD *)this + 22));
    if (v12)
    {
      v4 = (unint64_t)v12;
      *(_OWORD *)v12 = xmmword_21C701870;
      v13 = *((_QWORD *)this + 14);
      if (HIDWORD(v13))
        goto LABEL_41;
      *((_DWORD *)v12 + 2) = v13;
      v14 = *((_QWORD *)this + 23);
      v15 = (unint64_t)v12 + *((_QWORD *)this + 22);
      v16 = (char *)v12 + *((_QWORD *)this + 25) - v14;
      if (v15 <= (unint64_t)v16)
      {
        v19 = *((unsigned __int8 *)this + 233);
        v20 = (char *)v12 + *((_QWORD *)this + 22);
        v17 = *((_QWORD *)this + 26);
        v21 = *((_QWORD *)this + 27);
        do
        {
          *(_QWORD *)&v20[v21] = v12;
          if (v19)
          {
            *(_QWORD *)v20 = 0xFEEFED900143AD35;
            *(_QWORD *)&v20[*((_QWORD *)this + 28)] = 0xDFFDFE9001F00735;
          }
          *(_QWORD *)&v20[v17] = &v20[v14];
          v20 += v14;
        }
        while (v20 <= v16);
      }
      else
      {
        v17 = *((_QWORD *)this + 26);
      }
      *(_QWORD *)&v16[v17] = 0;
      v22 = *((_QWORD *)this + 13);
      if (v13 >= v22)
      {
        v23 = v13 + 1;
        if (v22 < v13 + 1)
        {
          if (*((_QWORD *)this + 12))
          {
            v24 = 2 * v22;
            if (!v22)
              v24 = 8;
            if (v24 <= v23)
              v25 = v23;
            else
              v25 = v24;
            re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)this + 12, v25);
          }
          else
          {
            re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)this + 12, v23);
            ++*((_DWORD *)this + 30);
          }
        }
        v13 = *((_QWORD *)this + 14);
      }
      *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v13) = v4;
      *((_QWORD *)this + 14) = v13 + 1;
      ++*((_DWORD *)this + 30);
      v26 = *((_QWORD *)this + 19);
      v27.n128_u64[0] = v4;
      v27.n128_u64[1] = v15;
      re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)this + 136, &v27);
      *(_DWORD *)(v4 + 12) = v26;
    }
    if (!*((_QWORD *)this + 19))
    {
LABEL_38:
      v4 = 0;
      goto LABEL_39;
    }
  }
  v7 = *((_QWORD *)this + 21);
  v4 = *(_QWORD *)(v7 + 8);
  if (*((_BYTE *)this + 233)
    && (*(_QWORD *)v4 != 0xFEEFED900143AD35 || *(_QWORD *)(v4 + *((_QWORD *)this + 28)) != 0xDFFDFE9001F00735))
  {
    goto LABEL_42;
  }
  v8 = *(_QWORD *)(v4 + *((_QWORD *)this + 27));
  v9 = *(_DWORD *)(v8 + 4) + *((_DWORD *)this + 46);
  *(_DWORD *)(v8 + 4) = v9;
  v10 = *(_QWORD *)(v4 + *((_QWORD *)this + 26));
  if (v10)
  {
    *(_QWORD *)(v7 + 8) = v10;
LABEL_20:
    *(_QWORD *)(v4 + *((_QWORD *)this + 26)) = 0;
LABEL_39:
    os_unfair_lock_unlock((os_unfair_lock_t)this + 8);
    return v4;
  }
  if (*((_QWORD *)this + 22) + v9 == *((_QWORD *)this + 25))
  {
    v18 = *(unsigned int *)(v8 + 12);
    re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt((uint64_t)this + 136, v18);
    if (*((_QWORD *)this + 19) > v18)
      *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 21) + 16 * v18) + 12) = v18;
    goto LABEL_20;
  }
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "isBlockFull(block)", "alloc", 113);
  _os_crash();
  __break(1u);
LABEL_41:
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "m_blocks.size() <= std::numeric_limits<uint32_t>::max()", "addPoolBlock", 281);
  _os_crash();
  __break(1u);
LABEL_42:
  re::internal::assertLog((re::internal *)5, v6, "assertion failure: '%s' (%s:line %i) Free pool entry %p is corrupted", "!hasEntryMemoryBeenStomped(entry)", "alloc", 104, v4);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::PoolAllocator::free(os_unfair_lock_s *this, char *a2)
{
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  char *i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  NSObject *v20;
  uint64_t v21;
  uint32_t os_unfair_lock_opaque;
  uint64_t v23;
  const char *v24;
  const char *v25;
  uint8_t buf[16];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    if (*(_QWORD *)&this[6]._os_unfair_lock_opaque)
    {
      os_unfair_lock_lock(this + 8);
      v5 = *(_DWORD **)&a2[*(_QWORD *)&this[54]._os_unfair_lock_opaque];
      if (!LOBYTE(this[58]._os_unfair_lock_opaque) || *v5 == -1159983635)
      {
        if (!BYTE1(this[58]._os_unfair_lock_opaque)
          || *(_QWORD *)a2 == 0xFEEFED900143AD35
          && *(_QWORD *)&a2[*(_QWORD *)&this[56]._os_unfair_lock_opaque] == 0xDFFDFE9001F00735)
        {
          v6 = *(_QWORD *)&this[38]._os_unfair_lock_opaque;
          if (v6)
          {
            v7 = 0;
            v8 = *(_QWORD *)&this[42]._os_unfair_lock_opaque;
            v9 = v8 + 16 * v6;
            do
            {
              if (!v7)
              {
                for (i = *(char **)(v8 + 8); i; i = *(char **)&i[*(_QWORD *)&this[52]._os_unfair_lock_opaque])
                {
                  v7 = i == a2;
                  if (i == a2)
                    break;
                }
              }
              v8 += 16;
            }
            while (v8 != v9);
            if (v7)
              goto LABEL_35;
          }
        }
        v11 = v5[1];
        v12 = *(_QWORD *)&this[44]._os_unfair_lock_opaque;
        v13 = *(_QWORD *)&this[50]._os_unfair_lock_opaque;
        v14 = v11 - this[46]._os_unfair_lock_opaque;
        v5[1] = v14;
        if (!v14)
        {
          if (!*(_QWORD *)&this[6]._os_unfair_lock_opaque)
          {
LABEL_35:
            os_unfair_lock_unlock(this + 8);
            return;
          }
          v15 = v5[2];
          if (*(_QWORD *)&this[28]._os_unfair_lock_opaque > v15)
          {
            v16 = *(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque + 8 * v15);
            v17 = *(unsigned int *)(v16 + 12);
            re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt((uint64_t)&this[34], v17);
            if (*(_QWORD *)&this[38]._os_unfair_lock_opaque > v17)
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&this[42]._os_unfair_lock_opaque + 16 * v17) + 12) = v17;
            (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)&this[6]._os_unfair_lock_opaque + 40))(*(_QWORD *)&this[6]._os_unfair_lock_opaque, v16);
            v18 = *(_QWORD *)&this[28]._os_unfair_lock_opaque;
            if (v18 > v15)
            {
              v19 = v18 - 1;
              if (v18 - 1 <= v15)
              {
                *(_QWORD *)&this[28]._os_unfair_lock_opaque = v19;
                ++this[30]._os_unfair_lock_opaque;
              }
              else
              {
                *(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque + 8 * v15) = *(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque
                                                                                               + 8 * v18
                                                                                               - 8);
                *(_QWORD *)&this[28]._os_unfair_lock_opaque = v19;
                ++this[30]._os_unfair_lock_opaque;
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque + 8 * v15) + 8) = v15;
              }
              goto LABEL_35;
            }
LABEL_46:
            v29 = 0u;
            v30 = 0u;
            v27 = 0u;
            v28 = 0u;
            *(_OWORD *)buf = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_45:
          v29 = 0u;
          v30 = 0u;
          v27 = 0u;
          v28 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_46;
        }
        if (v12 + v11 == v13)
        {
          os_unfair_lock_opaque = this[38]._os_unfair_lock_opaque;
          *(_QWORD *)buf = v5;
          *(_QWORD *)&buf[8] = 0;
          re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)&this[34], (__n128 *)buf);
          v5[3] = os_unfair_lock_opaque;
        }
        else
        {
          os_unfair_lock_opaque = v5[3];
        }
        if (*(_QWORD *)&this[38]._os_unfair_lock_opaque > (unint64_t)os_unfair_lock_opaque)
        {
          v23 = *(_QWORD *)(*(_QWORD *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8);
          if (BYTE1(this[58]._os_unfair_lock_opaque))
          {
            *(_QWORD *)a2 = 0xFEEFED900143AD35;
            *(_QWORD *)&a2[*(_QWORD *)&this[56]._os_unfair_lock_opaque] = 0xDFFDFE9001F00735;
          }
          *(_QWORD *)&a2[*(_QWORD *)&this[52]._os_unfair_lock_opaque] = v23;
          *(_QWORD *)(*(_QWORD *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8) = a2;
          goto LABEL_35;
        }
LABEL_44:
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      }
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Pool block is invalid. This could mean the memory address was not allocated from this pool, or other corruption. Enable RE_MEMORY_TRACKING to debug", "!m_enableAsserts || block->m_magic == blockGuard", "free", 149);
      _os_crash();
      __break(1u);
LABEL_40:
      if (*(_QWORD *)&this[2]._os_unfair_lock_opaque)
        v25 = *(const char **)&this[2]._os_unfair_lock_opaque;
      else
        v25 = "<UNKNOWN>";
      re::internal::assertLog((re::internal *)5, v21, "assertion failure: '%s' (%s:line %i) Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", "!m_enableAsserts", "free", 133, v25);
      _os_crash();
      __break(1u);
      goto LABEL_44;
    }
    v20 = *re::foundationMemoryLogObjects((re *)this);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v24 = *(const char **)&this[2]._os_unfair_lock_opaque;
      if (!v24)
        v24 = "<UNKNOWN>";
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v24;
      _os_log_error_impl(&dword_21C69B000, v20, OS_LOG_TYPE_ERROR, "Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", buf, 0xCu);
    }
    if (LOBYTE(this[58]._os_unfair_lock_opaque))
      goto LABEL_40;
  }
}

uint64_t re::PoolAllocator::statistics(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = this + 8;
  os_unfair_lock_lock(this + 8);
  v3 = *(_QWORD *)&this[28]._os_unfair_lock_opaque;
  v4 = 16 * *(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * v3;
  v5 = 16 * *(_QWORD *)&this[36]._os_unfair_lock_opaque + 8 * *(_QWORD *)&this[26]._os_unfair_lock_opaque;
  if (v3)
  {
    v6 = *(uint64_t **)&this[32]._os_unfair_lock_opaque;
    v7 = 8 * v3;
    do
    {
      v8 = *v6++;
      v5 += *(_QWORD *)&this[50]._os_unfair_lock_opaque;
      v4 += *(unsigned int *)(v8 + 4);
      v7 -= 8;
    }
    while (v7);
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

__n128 re::DynamicArray<re::PoolAllocator::PoolFreeList>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  __n128 result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  result = *a2;
  *(__n128 *)(*(_QWORD *)(a1 + 32) + 16 * v5) = *a2;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::PoolAllocator::parent(re::PoolAllocator *this)
{
  return *((_QWORD *)this + 3);
}

_QWORD *re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 16 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 16 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const char *__s, re::Allocator *a3)
{
  size_t v6;
  size_t v7;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v6 = strlen(__s);
  if (v6)
  {
    v7 = v6;
    *(_QWORD *)this = a3;
    re::DynamicString::setCapacity(this, v6 + 1);
    re::DynamicString::assign(this, __s, v7);
  }
  else
  {
    *(_QWORD *)this = a3;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

void *re::DynamicString::assign(re::DynamicString *this, const char *__src, size_t __len)
{
  uint64_t v6;
  size_t v7;
  char *v8;
  void *result;
  char *v10;
  uint64_t v11;

  v6 = *((_QWORD *)this + 1);
  if ((v6 & 1) != 0)
    v7 = *((_QWORD *)this + 3);
  else
    v7 = 23;
  if (v7 <= __len)
  {
    re::DynamicString::growCapacity(this, __len + 1);
    v6 = *((_QWORD *)this + 1);
  }
  if ((v6 & 1) != 0)
    v8 = (char *)*((_QWORD *)this + 2);
  else
    v8 = (char *)this + 9;
  result = memmove(v8, __src, __len);
  if ((*((_BYTE *)this + 8) & 1) != 0)
    v10 = (char *)*((_QWORD *)this + 2);
  else
    v10 = (char *)this + 9;
  v10[__len] = 0;
  v11 = *((_QWORD *)this + 1);
  if ((v11 & 1) != 0)
    *((_QWORD *)this + 1) = (2 * __len) | 1;
  else
    *((_BYTE *)this + 8) = v11 & 1 | (2 * __len);
  return result;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const re::DynamicString *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v4 = *((_QWORD *)a2 + 1);
  if ((v4 & 1) != 0)
    v5 = v4 >> 1;
  else
    v5 = v4 >> 1;
  if (v5)
  {
    *(_QWORD *)this = *(_QWORD *)a2;
    re::DynamicString::setCapacity(this, v5 + 1);
    re::DynamicString::copy(this, a2);
  }
  else
  {
    v6 = *(uint64_t **)a2;
    if (!*(_QWORD *)a2)
    {
    }
    *(_QWORD *)this = v6;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

_QWORD *re::DynamicString::copy(_QWORD *this, const re::DynamicString *a2)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;
  _BYTE *v8;
  void *v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v2 = this;
  v3 = *((_QWORD *)a2 + 1);
  v4 = v3 >> 1;
  if ((v3 & 1) == 0)
    v4 = v3 >> 1;
  v5 = this[1];
  if (v4)
  {
    if ((v5 & 1) != 0)
      v7 = this[3];
    else
      v7 = 23;
    if (v4 >= v7)
    {
      re::DynamicString::setCapacity(this, v4 + 1);
      v5 = v2[1];
    }
    if ((v5 & 1) != 0)
      v9 = (void *)v2[2];
    else
      v9 = (char *)v2 + 9;
    v10 = *((_QWORD *)a2 + 1);
    if ((v10 & 1) != 0)
      v11 = (char *)*((_QWORD *)a2 + 2);
    else
      v11 = (char *)a2 + 9;
    v12 = v10 >> 1;
    v13 = v10 >> 1;
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v13 = v12;
    this = memmove(v9, v11, v13 + 1);
    v14 = v2[1];
    if ((v14 & 1) != 0)
    {
      v15 = *((_QWORD *)a2 + 1);
      v16 = 254;
      if ((v15 & 1) != 0)
        v16 = -2;
      v2[1] = v16 & v15 | 1;
    }
    else
    {
      *((_BYTE *)v2 + 8) = *((_BYTE *)a2 + 8) & 0xFE | v14 & 1;
    }
  }
  else
  {
    if ((v5 & 1) != 0)
    {
      this[1] = 1;
      v8 = (_BYTE *)this[2];
    }
    else
    {
      *((_BYTE *)this + 8) = v5 & 1;
      v8 = (char *)this + 9;
    }
    *v8 = 0;
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, uint64_t a2)
{
  size_t v3;
  uint64_t v5;
  _BYTE *v6;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    if (!*(_QWORD *)this)
    {
      re::DynamicString::setCapacity(this, v3 + 1);
    }
    re::DynamicString::assign(this, *(const char **)a2, v3);
  }
  else
  {
    v5 = *((_QWORD *)this + 1);
    if ((v5 & 1) != 0)
    {
      *((_QWORD *)this + 1) = 1;
      v6 = (_BYTE *)*((_QWORD *)this + 2);
    }
    else
    {
      *((_BYTE *)this + 8) = v5 & 1;
      v6 = (char *)this + 9;
    }
    *v6 = 0;
  }
  return this;
}

_QWORD *re::DynamicString::setCapacity(_QWORD *this, size_t __n)
{
  _QWORD *v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  size_t v7;
  const void *v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  const void *v14;
  uint64_t v15;

  v3 = this;
  v4 = this[1];
  if (__n <= 0x17)
  {
    if ((v4 & 1) == 0)
      return this;
    goto LABEL_6;
  }
  if ((v4 & 1) != 0)
  {
LABEL_6:
    v5 = 0;
    v6 = this[3];
    goto LABEL_7;
  }
  v5 = 1;
  v6 = 23;
LABEL_7:
  if (v6 != __n)
  {
    v7 = v5 ? v4 >> 1 : v4 >> 1;
    if (v7 < __n)
    {
      if (__n > 0x16)
      {
        this = (_QWORD *)(*(uint64_t (**)(void))(*(_QWORD *)*this + 32))();
        if (!this)
        {
          re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Out of memory.", "newBuffer", "setCapacity", 455);
          this = (_QWORD *)_os_crash();
          __break(1u);
          return this;
        }
        v11 = this;
        *(_BYTE *)this = 0;
        v12 = v3[1];
        v13 = v12 >> 1;
        if ((v12 & 1) == 0)
          v13 = v12 >> 1;
        if (v13)
        {
          if ((v12 & 1) != 0)
            v14 = (const void *)v3[2];
          else
            v14 = (char *)v3 + 9;
          this = memcpy(this, v14, v13 + 1);
          v12 = v3[1];
        }
        if ((v12 & 1) != 0)
        {
          this = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v3 + 40))(*v3, v3[2]);
          v15 = v3[1];
        }
        else
        {
          v15 = v12 & 0xFE;
        }
        v3[2] = v11;
        v3[3] = __n;
        v9 = v15 | 1;
      }
      else
      {
        v8 = (const void *)this[2];
        *((_BYTE *)this + 8) = v4;
        memcpy((char *)this + 9, v8, __n);
        this = (_QWORD *)(*(uint64_t (**)(_QWORD, const void *))(*(_QWORD *)*v3 + 40))(*v3, v8);
        v9 = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      }
      v3[1] = v9;
    }
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, re::DynamicString *a2)
{
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  unint64_t v8;

  if (this == a2)
    return this;
  v4 = *(_QWORD *)a2;
  if (!*(_QWORD *)this)
  {
    if (!v4)
      return this;
    v7 = *((_QWORD *)a2 + 1);
    if ((v7 & 1) != 0)
      v8 = v7 >> 1;
    else
      v8 = v7 >> 1;
    *(_QWORD *)this = v4;
    re::DynamicString::setCapacity(this, v8 + 1);
LABEL_11:
    re::DynamicString::copy(this, a2);
    return this;
  }
  if (v4)
    goto LABEL_11;
  v5 = *((_QWORD *)this + 1);
  if ((v5 & 1) != 0)
  {
    *((_QWORD *)this + 1) = 1;
    v6 = (_BYTE *)*((_QWORD *)this + 2);
  }
  else
  {
    *((_BYTE *)this + 8) = v5 & 1;
    v6 = (char *)this + 9;
  }
  *v6 = 0;
  return this;
}

{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;

  if (this != a2)
  {
    v3 = *(_QWORD *)this;
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)this)
      v5 = v3 == v4;
    else
      v5 = 1;
    if (v5)
    {
      *(_QWORD *)this = v4;
      *(_QWORD *)a2 = v3;
      v6 = *((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
      *((_QWORD *)a2 + 3) = v6;
      v8 = *((_QWORD *)this + 1);
      v7 = *((_QWORD *)this + 2);
      v9 = *((_QWORD *)a2 + 2);
      *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
      *((_QWORD *)this + 2) = v9;
      *((_QWORD *)a2 + 1) = v8;
      *((_QWORD *)a2 + 2) = v7;
    }
    else if (v4)
    {
      re::DynamicString::copy(this, a2);
    }
    else
    {
      v10 = *((_QWORD *)this + 1);
      if ((v10 & 1) != 0)
      {
        *((_QWORD *)this + 1) = 1;
        v11 = (_BYTE *)*((_QWORD *)this + 2);
      }
      else
      {
        *((_BYTE *)this + 8) = v10 & 1;
        v11 = (char *)this + 9;
      }
      *v11 = 0;
    }
  }
  return this;
}

BOOL re::DynamicString::operator==(uint64_t a1, uint64_t a2)
{
  const char *v2;
  const char *v3;

  if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    v2 = *(const char **)(a1 + 16);
  else
    v2 = (const char *)(a1 + 9);
  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v3 = *(const char **)(a2 + 16);
  else
    v3 = (const char *)(a2 + 9);
  return strcmp(v2, v3) == 0;
}

void *re::DynamicString::append(re::DynamicString *this, const char *__src, size_t __len)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  void *result;
  uint64_t v13;
  size_t v14;
  char *v15;
  size_t v16;

  v6 = *((_QWORD *)this + 1);
  v7 = v6 >> 1;
  if ((v6 & 1) == 0)
    v7 = v6 >> 1;
  v8 = v7 + __len;
  if ((v6 & 1) != 0)
    v9 = *((_QWORD *)this + 3);
  else
    v9 = 23;
  if (v8 >= v9)
  {
    re::DynamicString::growCapacity(this, v8 + 1);
    v6 = *((_QWORD *)this + 1);
  }
  if ((v6 & 1) != 0)
    v10 = (char *)*((_QWORD *)this + 2);
  else
    v10 = (char *)this + 9;
  if ((v6 & 1) != 0)
    v11 = v6 >> 1;
  else
    v11 = v6 >> 1;
  result = memmove(&v10[v11], __src, __len);
  v13 = *((_QWORD *)this + 1);
  if ((v13 & 1) != 0)
  {
    v14 = v13 + 2 * __len;
    *((_QWORD *)this + 1) = v14;
    if ((v14 & 1) != 0)
      goto LABEL_16;
  }
  else
  {
    *((_BYTE *)this + 8) = v13 + 2 * __len;
    v14 = *((_QWORD *)this + 1);
    if ((v14 & 1) != 0)
    {
LABEL_16:
      v15 = (char *)*((_QWORD *)this + 2);
      goto LABEL_19;
    }
  }
  v15 = (char *)this + 9;
LABEL_19:
  if ((v14 & 1) != 0)
    v16 = v14 >> 1;
  else
    v16 = v14 >> 1;
  v15[v16] = 0;
  return result;
}

_QWORD *re::DynamicString::growCapacity(_QWORD *this, size_t a2)
{
  unint64_t v2;
  size_t v3;

  if ((this[1] & 1) != 0)
  {
    v3 = this[3];
    if (v3 >= a2)
      return this;
    v2 = 2 * v3;
  }
  else
  {
    if (a2 <= 0x17)
      return this;
    v2 = 64;
  }
  if (v2 > a2)
    a2 = v2;
  return re::DynamicString::setCapacity(this, a2);
}

uint64_t re::DynamicString::appendf(re::DynamicString *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return re::DynamicString::vappendf(this, a2, va);
}

uint64_t re::DynamicString::vappendf(re::DynamicString *this, const char *__format, va_list a3)
{
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;

  v5 = *((_QWORD *)this + 1);
  if ((v5 & 1) != 0)
  {
    v6 = v5 >> 1;
    v8 = *((_QWORD *)this + 3);
    v7 = (char *)(*((_QWORD *)this + 2) + (v5 >> 1));
  }
  else
  {
    v6 = v5 >> 1;
    v7 = (char *)this + v6 + 9;
    v8 = 23;
  }
  result = vsnprintf(v7, v8 - v6, __format, a3);
  v10 = *((_QWORD *)this + 1);
  if ((result & 0x80000000) == 0)
  {
    v11 = v10 >> 1;
    v12 = v10 >> 1;
    if ((v10 & 1) != 0)
      v12 = v10 >> 1;
    v13 = v12 + result;
    if ((v10 & 1) != 0)
    {
      if (v13 >= *((_QWORD *)this + 3))
      {
        v14 = (char *)*((_QWORD *)this + 2);
        if (!v14)
        {
LABEL_16:
          re::DynamicString::growCapacity(this, result + v11 + 1);
          v17 = *((_QWORD *)this + 1);
          if ((v17 & 1) != 0)
          {
            v18 = v17 >> 1;
            v20 = *((_QWORD *)this + 3);
            v19 = (char *)(*((_QWORD *)this + 2) + (v17 >> 1));
          }
          else
          {
            v18 = v17 >> 1;
            v19 = (char *)this + v18 + 9;
            v20 = 23;
          }
          result = vsnprintf(v19, v20 - v18, __format, a3);
          goto LABEL_25;
        }
LABEL_14:
        v14[v12] = 0;
        v16 = *((_QWORD *)this + 1);
        v11 = v16 >> 1;
        if ((v16 & 1) == 0)
          v11 = v16 >> 1;
        goto LABEL_16;
      }
    }
    else if (v13 >= 0x17)
    {
      v14 = (char *)this + 9;
      goto LABEL_14;
    }
LABEL_25:
    v22 = *((_QWORD *)this + 1);
    if ((v22 & 1) != 0)
      *((_QWORD *)this + 1) = v22 + 2 * (int)result;
    else
      *((_BYTE *)this + 8) = v22 + 2 * result;
    return result;
  }
  if ((v10 & 1) != 0)
  {
    v15 = (char *)*((_QWORD *)this + 2);
    if (!v15)
      return result;
  }
  else
  {
    v15 = (char *)this + 9;
  }
  if ((v10 & 1) != 0)
    v21 = v10 >> 1;
  else
    v21 = v10 >> 1;
  v15[v21] = 0;
  return result;
}

uint64_t re::DynamicString::vassignf(re::DynamicString *this, const char *__format, va_list a3)
{
  uint64_t v3;
  _BYTE *v4;

  v3 = *((_QWORD *)this + 1);
  if ((v3 & 1) != 0)
  {
    *((_QWORD *)this + 1) = 1;
    v4 = (_BYTE *)*((_QWORD *)this + 2);
  }
  else
  {
    *((_BYTE *)this + 8) = v3 & 1;
    v4 = (char *)this + 9;
  }
  *v4 = 0;
  return re::DynamicString::vappendf(this, __format, a3);
}

void *re::DynamicString::substr@<X0>(re::DynamicString *this@<X0>, unint64_t a2@<X1>, size_t a3@<X2>, re::DynamicString *a4@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  size_t v9;
  char *v10;
  void *result;

  v6 = *((_QWORD *)this + 1);
  if ((v6 & 1) != 0)
    v7 = v6 >> 1;
  else
    v7 = v6 >> 1;
  if (v7 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "substr", 610, a2, v7);
    result = (void *)_os_crash();
    __break(1u);
  }
  else
  {
    if (v7 - a2 >= a3)
      v9 = a3;
    else
      v9 = v7 - a2;
    *((_QWORD *)a4 + 1) = 0;
    *((_QWORD *)a4 + 2) = 0;
    *((_QWORD *)a4 + 3) = 0;
    re::DynamicString::setCapacity(a4, 0);
    *(_QWORD *)a4 = *(_QWORD *)this;
    re::DynamicString::setCapacity(a4, v9);
    if ((*((_BYTE *)this + 8) & 1) != 0)
      v10 = (char *)*((_QWORD *)this + 2);
    else
      v10 = (char *)this + 9;
    return re::DynamicString::assign(a4, &v10[a2], v9);
  }
  return result;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  unint64_t v3;
  unint64_t v4;

  v3 = *(_QWORD *)(this + 8);
  if ((v3 & 1) != 0)
    v4 = v3 >> 1;
  else
    v4 = v3 >> 1;
  if (v4)
    return re::DynamicString::rfind(this, a2, v4 - 1, (uint64_t)a3);
  *a3 = 0;
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(this + 8);
  v5 = v4 >> 1;
  if ((v4 & 1) == 0)
    v5 = v4 >> 1;
  if (v5 <= a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset < size()", "rfind", 667, a3, v5);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    if ((v4 & 1) != 0)
      v6 = *(_QWORD *)(this + 16);
    else
      v6 = this + 9;
    v7 = this + 9;
    v8 = a3 + v6;
    v9 = -(uint64_t)(a3 + v6);
    v10 = v8 + 1;
    while (*(unsigned __int8 *)(v10 - 1) != a2)
    {
      v11 = this + 9;
      if ((v4 & 1) != 0)
        v11 = *(_QWORD *)(this + 16);
      ++v9;
      if (--v10 == v11)
      {
        *(_BYTE *)a4 = 0;
        return this;
      }
    }
    if ((v4 & 1) != 0)
      v7 = *(_QWORD *)(this + 16);
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = -(v7 + v9);
  }
  return this;
}

uint64_t re::DynamicString::format@<X0>(re::DynamicString *this@<X0>, re::DynamicString *a2@<X8>, ...)
{
  va_list va;

  va_start(va, a2);
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::DynamicString::vassignf(a2, (const char *)this, va);
}

uint64_t re::internal::assertLog(re::internal *this, uint64_t a2, ...)
{
  return os_log_with_args();
}

uint64_t *re::foundationCoreLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationCoreLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Core");
  }
  return &re::foundationCoreLogObjects(void)::logObjects;
}

BOOL re::internal::enableSignposts(re::internal *this, uint64_t a2)
{
  unsigned __int8 v2;
  int v4;
  BOOL v5;
  char v6;
  unsigned int v7;
  char v8;
  _BYTE v9[4];
  int v10;

  if ((v2 & 1) == 0)
  {
    v7 = a2;
    v8 = (char)this;
    a2 = v7;
    LOBYTE(this) = v8;
    if (v4)
    {
      re::Defaults::intValue((re::Defaults *)"enableSignposts", (const char *)v7, (uint64_t)v9);
      if (v9[0])
        v5 = v10 == 0;
      else
        v5 = 0;
      v6 = !v5;
      re::internal::enableSignposts(BOOL,BOOL)::value = v6;
      a2 = v7;
      LOBYTE(this) = v8;
    }
  }
  if ((this & 1) == 0)
    return re::internal::enableSignposts(BOOL,BOOL)::value != 0;
  re::internal::enableSignposts(BOOL,BOOL)::value = a2;
  return a2;
}

BOOL re::internal::enableHighFrequencyNetworkTracing(re::internal *this, uint64_t a2)
{
  unsigned __int8 v2;
  int v4;
  BOOL v5;
  char v6;
  unsigned int v7;
  char v8;
  _BYTE v9[4];
  int v10;

  if ((v2 & 1) == 0)
  {
    v7 = a2;
    v8 = (char)this;
    a2 = v7;
    LOBYTE(this) = v8;
    if (v4)
    {
      re::Defaults::intValue((re::Defaults *)"enableHighFrequencyNetworkTracing", (const char *)v7, (uint64_t)v9);
      if (v9[0])
        v5 = v10 == 0;
      else
        v5 = 1;
      v6 = !v5;
      re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = v6;
      a2 = v7;
      LOBYTE(this) = v8;
    }
  }
  if ((this & 1) == 0)
    return re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value != 0;
  re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = a2;
  return a2;
}

void re::Defaults::intValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  char v5;
  void *v6;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    *(_DWORD *)(a3 + 4) = objc_msgSend(v4, "intValue");
    v4 = v6;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)a3 = v5;

}

id `anonymous namespace'::getValue(_anonymous_namespace_ *this, const char *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  re *v7;
  void *v8;
  uint64_t v9;
  __CFString *v10;
  void *v11;
  NSObject *v12;
  uint8_t buf[16];

  objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s.%s"), "com.apple.re", this);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v5)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", this);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "objectForKey:", v6);
    v7 = (re *)objc_claimAutoreleasedReturnValue();
    if (v7)
    {
      v5 = v7;
      v8 = v6;
    }
    else
    {
      v9 = objc_msgSend(v4, "rangeOfString:options:", CFSTR("."), 4);
      objc_msgSend(v4, "substringToIndex:", v9);
      v10 = (__CFString *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "substringFromIndex:", v9 + 1);
      v8 = (void *)objc_claimAutoreleasedReturnValue();

      if (-[__CFString isEqualToString:](v10, "isEqualToString:", CFSTR("com.apple.re.network.multipeerservice")))
      {

        v10 = CFSTR("com.apple.renetwork.multipeerservice");
      }
      objc_msgSend(v3, "dictionaryForKey:", v10);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "objectForKey:", v8);
      v5 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v5)
        goto LABEL_9;
    }
    v12 = *re::foundationCoreLogObjects(v7);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
    }
LABEL_9:

  }
  return v5;
}

void re::Defaults::BOOLValue(re::Defaults *this@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  void *v4;
  char v5;
  void *v6;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    a3[1] = objc_msgSend(v4, "BOOLValue");
    v4 = v6;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *a3 = v5;

}

void re::Defaults::uintValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  char v5;
  void *v6;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    *(_DWORD *)(a3 + 4) = objc_msgSend(v4, "unsignedIntValue");
    v4 = v6;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)a3 = v5;

}

uint64_t re::AlignedAllocator::deinit(re::AlignedAllocator *this)
{
  uint64_t result;
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 32);
  result = *((_QWORD *)this + 4);
  if (result)
  {
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 11) = 0;
    if (*((_QWORD *)this + 8))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *((_QWORD *)this + 8) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 14);
  }
  return result;
}

void re::BaseAllocator::~BaseAllocator(re::BaseAllocator *this)
{
  uint64_t v2;
  _QWORD *v3;

  *(_QWORD *)this = off_24E070660;
  v3 = (_QWORD *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 8) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 14);
  }
  re::Allocator::~Allocator(this);
}

void re::AlignedAllocator::~AlignedAllocator(re::AlignedAllocator *this)
{
  re::AlignedAllocator::deinit(this);
  re::BaseAllocator::~BaseAllocator(this);
}

{
  re::AlignedAllocator::deinit(this);
  re::BaseAllocator::~BaseAllocator(this);
  JUMPOUT(0x220780CD0);
}

void *re::AlignedAllocator::alloc(re::AlignedAllocator *this, size_t size)
{
  uint64_t v4;
  void *result;
  size_t v6;
  void *memptr;

  v4 = *((_QWORD *)this + 11);
  if (v4)
  {
    result = (void *)(*(uint64_t (**)(uint64_t, size_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, size, 0);
  }
  else
  {
    v6 = (*((_QWORD *)this + 10) + 7) & 0xFFFFFFFFFFFFFFF8;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, v6, size, 0xC75C8B65uLL);
    result = memptr;
  }
  __dmb(0xBu);
  return result;
}

void re::AlignedAllocator::free(re::AlignedAllocator *this, void *a2)
{
  uint64_t v2;

  __dmb(0xBu);
  v2 = *((_QWORD *)this + 11);
  if (v2)
    (*(void (**)(uint64_t, void *))(*(_QWORD *)v2 + 40))(v2, a2);
  else
    free(a2);
}

uint64_t re::AlignedAllocator::statistics(re::AlignedAllocator *this)
{
  return 0;
}

uint64_t re::AlignedAllocator::parent(re::AlignedAllocator *this)
{
  return *((_QWORD *)this + 11);
}

re::Allocator *re::Allocator::Allocator(re::Allocator *this, const char *a2, int a3)
{
  char *v4;
  char *v5;

  *(_QWORD *)this = off_24E0706B8;
  *((_QWORD *)this + 1) = a2;
  *((_BYTE *)this + 16) = a3;
  if (a3)
  {
    v4 = re::globalMemoryTracker(this);
    if (*v4)
    {
      v5 = re::globalMemoryTracker((re *)v4);
      re::MemoryTracker::track((os_unfair_lock_s *)v5, this);
    }
  }
  return this;
}

void re::Allocator::~Allocator(re::Allocator *this)
{
  char *v2;
  char *v3;

  *(_QWORD *)this = off_24E0706B8;
  if (*((_BYTE *)this + 16))
  {
    v2 = re::globalMemoryTracker(this);
    if (*v2)
    {
      v3 = re::globalMemoryTracker((re *)v2);
      re::MemoryTracker::untrack((os_unfair_lock_s *)v3, this);
    }
  }
}

_anonymous_namespace_ *re::PerFrameAllocatorManager::init(_anonymous_namespace_ *this)
{
  _anonymous_namespace_ *v1;
  _anonymous_namespace_ *v2;
  uint64_t v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  _anonymous_namespace_ *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  char *v23;

  if (*(_BYTE *)this)
    return this;
  v1 = this;
  *((_QWORD *)v1 + 2) = 16;
  *((_QWORD *)v1 + 3) = v2;
  if (!v2)
    goto LABEL_32;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_QWORD *)v1 + 5) = 16;
  *((_QWORD *)v1 + 6) = v4;
  if (!v4)
    goto LABEL_33;
  v6 = 0;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(_BYTE *)v1 = 1;
  do
  {
    if (*((_QWORD *)v1 + 5) <= v6)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_31:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_32:
      re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_33:
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    *(_QWORD *)(*((_QWORD *)v1 + 6) + 8 * v6) = 0;
    if (*((_QWORD *)v1 + 2) <= v6)
      goto LABEL_31;
    *(_QWORD *)(*((_QWORD *)v1 + 3) + 8 * v6++) = 0;
  }
  while (v6 != 16);
  v7 = *((_QWORD *)v1 + 18);
  if (v7 <= 0xE)
  {
    if (*((_QWORD *)v1 + 17) > 0xEuLL
      || (v4 = (_anonymous_namespace_ *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity((_QWORD *)v1 + 16),
          v7 = *((_QWORD *)v1 + 18),
          v7 <= 0xE))
    {
      v8 = v7 - 15;
      v9 = 88 * v7;
      do
      {
        v10 = *((_QWORD *)v1 + 20) + v9;
        *(_QWORD *)(v10 + 80) = 0;
        *(_OWORD *)v10 = 0uLL;
        *(_OWORD *)(v10 + 16) = 0uLL;
        *(_DWORD *)(v10 + 32) = 0;
        *(_OWORD *)(v10 + 40) = 0uLL;
        *(_OWORD *)(v10 + 56) = 0uLL;
        *(_DWORD *)(v10 + 72) = 0;
        v9 += 88;
      }
      while (!__CFADD__(v8++, 1));
    }
    goto LABEL_26;
  }
  if (v7 != 15)
  {
    v12 = 15;
    v13 = 1400;
    do
    {
      v14 = *((_QWORD *)v1 + 20);
      v15 = v14 + v13;
      v16 = *(_QWORD *)(v14 + v13 - 32);
      if (v16)
      {
        if (*(_QWORD *)(v14 + v13))
          (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
        v17 = (_QWORD *)(v14 + v13);
        *v17 = 0;
        *(_QWORD *)(v14 + v13 - 24) = 0;
        *(_QWORD *)(v14 + v13 - 16) = 0;
        *(_QWORD *)(v14 + v13 - 32) = 0;
        *((_DWORD *)v17 - 2) = *(_DWORD *)(v14 + v13 - 8) + 1;
      }
      v19 = *(_anonymous_namespace_ **)(v15 - 72);
      v18 = (_QWORD *)(v15 - 72);
      v4 = v19;
      if (v19)
      {
        v20 = v14 + v13;
        if (*(_QWORD *)(v20 - 40))
          v4 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(_QWORD *)v4 + 40))(v4);
        *(_QWORD *)(v20 - 40) = 0;
        v18[1] = 0;
        v18[2] = 0;
        *v18 = 0;
        ++*(_DWORD *)(v20 - 48);
      }
      ++v12;
      v13 += 88;
    }
    while (v12 < *((_QWORD *)v1 + 18));
LABEL_26:
    *((_QWORD *)v1 + 18) = 15;
    ++*((_DWORD *)v1 + 38);
  }
  v21 = 0;
  v22 = (_QWORD *)*((_QWORD *)v1 + 20);
  do
  {
    *v22 = 0x10000 << v21;
    v22 += 11;
    ++v21;
  }
  while (v21 != 15);
  v23 = (char *)v1 + 56;
  re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(v23, 0);
  ++*((_DWORD *)v23 + 6);
  *((_DWORD *)v23 + 11) = 16;
  return re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(v23);
}

re *re::PerFrameAllocatorManager::deinit(re *this)
{
  re *v1;
  unint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t j;

  if (*(_BYTE *)this)
  {
    v1 = this;
    this = (re *)re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)this + 56);
    v2 = *((_QWORD *)v1 + 18);
    if (v2)
    {
      for (i = 0; i < v2; ++i)
      {
        v4 = *((_QWORD *)v1 + 20);
        v5 = v4 + 88 * i;
        v8 = *(_QWORD *)(v5 + 64);
        v7 = (unint64_t *)(v5 + 64);
        v6 = v8;
        if (v8)
        {
          v9 = 0;
          v10 = (_QWORD *)(v4 + 88 * i + 80);
          do
          {
            v11 = **(_QWORD **)(*v10 + 8 * v9);
            if (v11)
            {
              v12 = re::globalAllocators(this);
              (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v12[2] + 40))(v12[2], v11);
              v6 = *v7;
            }
            if (v6 <= v9)
            {
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_20:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_21:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_22:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            this = re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(*(re **)(*v10 + 8 * v9));
            v6 = *v7;
            if (*v7 <= v9)
              goto LABEL_20;
            *(_QWORD *)(*v10 + 8 * v9++) = 0;
          }
          while (v6 > v9);
          v2 = *((_QWORD *)v1 + 18);
        }
        *v7 = 0;
        v13 = v4 + 88 * i;
        ++*(_DWORD *)(v13 + 72);
        *(_QWORD *)(v13 + 24) = 0;
        ++*(_DWORD *)(v13 + 32);
      }
    }
    for (j = 0; j != 16; ++j)
    {
      if (*((_QWORD *)v1 + 5) <= j)
        goto LABEL_21;
      *(_QWORD *)(*((_QWORD *)v1 + 6) + 8 * j) = 0;
      if (*((_QWORD *)v1 + 2) <= j)
        goto LABEL_22;
      *(_QWORD *)(*((_QWORD *)v1 + 3) + 8 * j) = 0;
    }
    *(_BYTE *)v1 = 0;
  }
  return this;
}

re *re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(re *result)
{
  re *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = re::globalAllocators(result)[2];
    *(_OWORD *)((char *)v1 + 40) = 0u;
    *(_OWORD *)((char *)v1 + 56) = 0u;
    re::HashTable<unsigned long,unsigned long,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit((uint64_t *)v1 + 10);
    re::Allocator::~Allocator((re *)((char *)v1 + 16));
    return (re *)(*(uint64_t (**)(uint64_t, re *))(*(_QWORD *)v2 + 40))(v2, v1);
  }
  return result;
}

_QWORD *re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (result[1] != 15)
  {
    v1 = result;
    if (result[2] <= 0xFuLL)
    {
      v2 = *result;
      if (*v1)
      {
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2 + 32))(v2, 1320, 8);
        if (result)
        {
          v4 = result;
          if (v1[1])
          {
            v5 = v1[4];
            v6 = v1[2];
            if (v6)
            {
              v7 = v5 + 40;
              v8 = 88 * v6;
              v9 = result;
              do
              {
                v10 = *(_QWORD *)(v7 - 40);
                v9[5] = 0;
                v9[1] = 0;
                v9[2] = 0;
                *((_DWORD *)v9 + 8) = 0;
                v9[3] = 0;
                v12 = (_QWORD *)(v7 - 32);
                v11 = *(_QWORD *)(v7 - 32);
                *v9 = v10;
                v13 = *(_QWORD *)(v7 - 24);
                v9[1] = v11;
                *(_QWORD *)(v7 - 32) = 0;
                v9[2] = v13;
                *(_QWORD *)(v7 - 24) = 0;
                v14 = v9[3];
                v9[3] = *(_QWORD *)(v7 - 16);
                *(_QWORD *)(v7 - 16) = v14;
                v15 = v9[5];
                v9[5] = *(_QWORD *)v7;
                *(_QWORD *)v7 = v15;
                ++*(_DWORD *)(v7 - 8);
                ++*((_DWORD *)v9 + 8);
                v9[10] = 0;
                v9[7] = 0;
                v9[8] = 0;
                v9[6] = 0;
                *((_DWORD *)v9 + 18) = 0;
                v9[6] = *(_QWORD *)(v7 + 8);
                *(_QWORD *)(v7 + 8) = 0;
                v16 = v9[10];
                v9[10] = *(_QWORD *)(v7 + 40);
                v17 = *(_QWORD *)(v7 + 8);
                v9[7] = *(_QWORD *)(v7 + 16);
                *(_QWORD *)(v7 + 16) = 0;
                v18 = v9[8];
                v9[8] = *(_QWORD *)(v7 + 24);
                *(_QWORD *)(v7 + 24) = v18;
                ++*(_DWORD *)(v7 + 32);
                ++*((_DWORD *)v9 + 18);
                *(_QWORD *)(v7 + 40) = v16;
                if (v17)
                {
                  if (v16)
                    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
                  *(_QWORD *)(v7 + 40) = 0;
                  *(_QWORD *)(v7 + 16) = 0;
                  *(_QWORD *)(v7 + 24) = 0;
                  *(_QWORD *)(v7 + 8) = 0;
                  ++*(_DWORD *)(v7 + 32);
                }
                if (*v12)
                {
                  if (*(_QWORD *)v7)
                    (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 40))(*v12);
                  *(_QWORD *)v7 = 0;
                  *(_QWORD *)(v7 - 24) = 0;
                  *(_QWORD *)(v7 - 16) = 0;
                  *v12 = 0;
                  ++*(_DWORD *)(v7 - 8);
                }
                v7 += 88;
                v9 += 11;
                v8 -= 88;
              }
              while (v8);
              v5 = v1[4];
            }
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v1 + 40))(*v1, v5);
          }
          v1[4] = v4;
          v1[1] = 15;
        }
        else
        {
          re::internal::assertLog((re::internal *)6, v3, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, 1320, *(_QWORD *)(*v1 + 8));
          result = (_QWORD *)_os_crash();
          __break(1u);
        }
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(v1);
        ++*((_DWORD *)v1 + 6);
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _anonymous_namespace_ *result;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;

  v3 = 184 * *((unsigned int *)a1 + 11);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(_QWORD *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  v6 = v4;
  v1 = 4 * *((unsigned int *)a1 + 11);
  result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(_QWORD *)(*a1 + 8));
    result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  v9 = result;
  v11 = a1[1];
  v10 = a1[2];
  if (v10 >= v11)
  {
    v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        v13 = 2 * v11;
        if (!v11)
          v13 = 8;
        if (v13 <= v12)
          v14 = v12;
        else
          v14 = v13;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v14);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    v10 = a1[2];
  }
  v15 = (uint64_t *)(a1[4] + 16 * v10);
  *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

uint64_t re::InlineString<32ul>::vappendf(unint64_t *a1, char *__format, va_list a3)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;

  result = vsnprintf((char *)a1 + *a1 + 8, 32 - *a1, __format, a3);
  if ((result & 0x80000000) != 0)
  {
    *((_BYTE *)a1 + *a1 + 8) = 0;
  }
  else
  {
    v6 = *a1 + result;
    if (v6 >= 0x20)
    {
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "m_length + result < m_capacity", "vappendf", 446, a3, a3);
      result = _os_crash();
      __break(1u);
    }
    else
    {
      *a1 = v6;
    }
  }
  return result;
}

pthread_t re::BaseAllocator::init(re::BaseAllocator *this)
{
  re::BaseAllocator *v1;
  pthread_t result;

  v1 = this;
  *((_QWORD *)this + 3) = 0;
  v1 = (re::BaseAllocator *)((char *)v1 + 32);
  re::DynamicArray<re::internal::MemBlock>::setCapacity(v1, 0);
  ++*((_DWORD *)v1 + 6);
  result = pthread_self();
  *((_QWORD *)v1 + 5) = result;
  return result;
}

_QWORD *re::DynamicArray<re::internal::MemBlock>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x18uLL))
        {
          v2 = 24 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 24 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::internal::MemBlock>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t *re::foundationMemoryLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationMemoryLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Memory");
  }
  return &re::foundationMemoryLogObjects(void)::logObjects;
}

uint64_t MurmurHash3_x64_128(uint64_t result, int a2, unsigned int a3, unint64_t *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;

  v4 = a3;
  if (a2 < 16)
  {
    v7 = a3;
  }
  else
  {
    v5 = (_QWORD *)(result + 8);
    v6 = (a2 / 16);
    v7 = v4;
    do
    {
      v4 = 5
         * (__ROR8__((0x4CF5AD432745937FLL * ((0x88A129EA80000000 * *(v5 - 1)) | ((0x87C37B91114253D5 * *(v5 - 1)) >> 33))) ^ v4, 37)+ v7)+ 1390208809;
      v7 = 5
         * (v4
          + __ROR8__((0x87C37B91114253D5* ((0x4E8B26FE00000000 * *v5) | ((unint64_t)(0x4CF5AD432745937FLL * *v5) >> 31))) ^ v7, 33))+ 944331445;
      v5 += 2;
      --v6;
    }
    while (v6);
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = (unsigned __int8 *)(result + 16 * (a2 / 16));
  switch(a2 & 0xF)
  {
    case 1:
      goto LABEL_21;
    case 2:
      goto LABEL_20;
    case 3:
      goto LABEL_19;
    case 4:
      goto LABEL_18;
    case 5:
      goto LABEL_17;
    case 6:
      goto LABEL_16;
    case 7:
      goto LABEL_15;
    case 8:
      goto LABEL_14;
    case 9:
      goto LABEL_13;
    case 0xA:
      goto LABEL_12;
    case 0xB:
      goto LABEL_11;
    case 0xC:
      goto LABEL_10;
    case 0xD:
      goto LABEL_9;
    case 0xE:
      goto LABEL_8;
    case 0xF:
      v8 = (unint64_t)v21[14] << 48;
LABEL_8:
      v9 = v8 | ((unint64_t)v21[13] << 40);
LABEL_9:
      v10 = v9 ^ ((unint64_t)v21[12] << 32);
LABEL_10:
      v11 = v10 ^ ((unint64_t)v21[11] << 24);
LABEL_11:
      v12 = v11 ^ ((unint64_t)v21[10] << 16);
LABEL_12:
      v13 = v12 ^ ((unint64_t)v21[9] << 8);
LABEL_13:
      v7 ^= 0x87C37B91114253D5
          * ((0x4E8B26FE00000000 * (v13 ^ v21[8])) | ((0x4CF5AD432745937FLL * (v13 ^ v21[8])) >> 31));
LABEL_14:
      v14 = (unint64_t)v21[7] << 56;
LABEL_15:
      v15 = v14 | ((unint64_t)v21[6] << 48);
LABEL_16:
      v16 = v15 ^ ((unint64_t)v21[5] << 40);
LABEL_17:
      v17 = v16 ^ ((unint64_t)v21[4] << 32);
LABEL_18:
      v18 = v17 ^ ((unint64_t)v21[3] << 24);
LABEL_19:
      v19 = v18 ^ ((unint64_t)v21[2] << 16);
LABEL_20:
      v20 = v19 ^ ((unint64_t)v21[1] << 8);
LABEL_21:
      v4 ^= 0x4CF5AD432745937FLL
          * ((0x88A129EA80000000 * (v20 ^ *v21)) | ((0x87C37B91114253D5 * (v20 ^ *v21)) >> 33));
      break;
    default:
      break;
  }
  v22 = v7 ^ a2;
  v23 = (v4 ^ a2) + v22;
  v24 = v23 + v22;
  v25 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) >> 33));
  v26 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) >> 33));
  v27 = v26 ^ (v26 >> 33);
  v28 = v27 + (v25 ^ (v25 >> 33));
  *a4 = v28;
  a4[1] = v28 + v27;
  return result;
}

uint64_t re::SharedObject::dispose(re::SharedObject *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 2);
  (**(void (***)(re::SharedObject *))this)(this);
  return (*(uint64_t (**)(uint64_t, re::SharedObject *))(*(_QWORD *)v2 + 40))(v2, this);
}

uint64_t re::SharedObject::allocator(re::SharedObject *this)
{
  return *((_QWORD *)this + 2);
}

void re::MallocAllocator::~MallocAllocator(re::MallocAllocator *this)
{
  re::Allocator::~Allocator(this);
  JUMPOUT(0x220780CD0);
}

void *re::MallocAllocator::alloc(re::MallocAllocator *this, size_t size, unint64_t a3)
{
  uint64_t v3;
  void *result;
  void *memptr;

  v3 = 16;
  if (a3 > 0x10)
    v3 = a3;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, (v3 + 7) & 0xFFFFFFFFFFFFFFF8, size, 0xC75C8B65uLL);
  result = memptr;
  __dmb(0xBu);
  return result;
}

void re::MallocAllocator::free(re::MallocAllocator *this, void *a2)
{
  __dmb(0xBu);
  free(a2);
}

uint64_t re::MallocAllocator::statistics(re::MallocAllocator *this)
{
  return 0;
}

uint64_t re::MallocAllocator::parent(re::MallocAllocator *this)
{
  return 0;
}

uint64_t ArcObjectDestroy(char *a1, objc_selector *a2)
{
  if (a1)
    return (*(uint64_t (**)(char *))(*((_QWORD *)a1 - 1) + 16))(a1 - 8);
  else
    return (*(uint64_t (**)(_QWORD))(MEMORY[0] + 16))(0);
}

void ArcSharedObject::ArcSharedObject(ArcSharedObject *this, Class cls)
{
  objc_class *v2;
  unsigned __int8 v4;
  objc_class *v5;
  objc_class *ClassPair;
  objc_class *Class;

  v2 = cls;
  *(_QWORD *)this = &off_24E0707C0;
  if (!cls)
  {
    v4 = atomic_load((unsigned __int8 *)&qword_25529BBD0);
    if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_25529BBD0))
    {
      v5 = (objc_class *)objc_opt_class();
      ClassPair = objc_allocateClassPair(v5, "_REArcObject", 0);
      if (ClassPair)
      {
        Class = ClassPair;
        class_addMethod(ClassPair, sel_dealloc, (IMP)ArcObjectDestroy, (const char *)&unk_21C704343);
        objc_registerClassPair(Class);
      }
      else
      {
        Class = objc_getClass("_REArcObject");
      }
      _MergedGlobals_0 = (uint64_t)Class;
      __cxa_guard_release(&qword_25529BBD0);
    }
    v2 = (objc_class *)_MergedGlobals_0;
  }
  *((_QWORD *)this + 1) = 0;
  objc_constructInstance(v2, (char *)this + 8);
}

void ArcSharedObject::~ArcSharedObject(ArcSharedObject *this)
{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

void ArcSharedObject::dispose(ArcSharedObject *this)
{
  (**(void (***)(ArcSharedObject *))this)(this);
  free(this);
}

unint64_t re::Hash<re::DynamicString>::operator()(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v9[3];

  v9[2] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 8);
  if ((v3 & 1) != 0)
    v4 = v3 >> 1;
  else
    v4 = v3 >> 1;
  if (!v4)
    return 0;
  v5 = a2 + 9;
  v6 = *(_QWORD *)(a2 + 16);
  if ((v3 & 1) != 0)
    v7 = v6;
  else
    v7 = v5;
  MurmurHash3_x64_128(v7, v4, 0, v9);
  return (v9[1] + (v9[0] << 6) + (v9[0] >> 2) - 0x61C8864680B583E9) ^ v9[0];
}

void RESyncCommitListCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 64, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E0707F8;
  *(_QWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 48) = 0;
}

uint64_t RESyncCommitListGetEntryCount(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

uint64_t RESyncCommitListGetEntry(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(_QWORD *)(result + 40) <= a2)
      return 0;
    else
      return *(_QWORD *)(result + 56) + 72 * a2;
  }
  return result;
}

uint64_t RESyncCommitListAddCopy(_QWORD *a1, __int128 *a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)(a1 + 3), a2);
      return a1[7] + 72 * a1[5] - 72;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::SyncCommit>::add(_anonymous_namespace_ *this, __int128 *a2)
{
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  uint64_t result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::SyncCommit>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (_OWORD *)(*((_QWORD *)this + 4) + 72 * v4);
  v6 = *a2;
  *(_OWORD *)((char *)v5 + 13) = *(__int128 *)((char *)a2 + 13);
  *v5 = v6;
  result = re::DynamicArray<re::internal::SyncSnapshotEntry>::DynamicArray((uint64_t)(v5 + 2), (uint64_t *)a2 + 4);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t RESyncCommitListAddNewCommit(uint64_t result)
{
  uint64_t v1;
  _OWORD v2[2];
  _OWORD v3[2];
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v4 = 0;
    memset(v3, 0, sizeof(v3));
    memset(v2, 0, sizeof(v2));
    re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)(result + 24), (uint64_t)v2);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v3);
    return *(_QWORD *)(v1 + 56) + 72 * *(_QWORD *)(v1 + 40) - 72;
  }
  return result;
}

void re::DynamicArray<re::SyncCommit>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::SyncCommit>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  re::SyncCommit::SyncCommit(*((_QWORD *)this + 4) + 72 * v4, a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
}

uint64_t RESyncCommitListClear(uint64_t result)
{
  if (result)
    return re::DynamicArray<re::SyncCommit>::clear(result + 24);
  return result;
}

uint64_t re::DynamicArray<re::SyncCommit>::clear(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = 0;
  if (v2)
  {
    v3 = 72 * v2;
    v4 = *(_QWORD *)(result + 32) + 32;
    do
    {
      result = re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(v4);
      v4 += 72;
      v3 -= 72;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

_BYTE *RESyncCommitIsAtomic(_BYTE *result)
{
  if (result)
    return (_BYTE *)(*result & 1);
  return result;
}

uint64_t RESyncCommitCaptureSnapshot(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t result;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  re::SyncObject *v16;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      v9 = (_QWORD *)(a1 + 32);
      v16 = (re::SyncObject *)a2;
      v10 = a2 + 1;
      v11 = re::SyncSnapshot::writeObject(v9, &v16);
      v13 = v12;

      v14 = *(_QWORD *)(*(_QWORD *)(a2[11] + 16) + 88);
      *(_BYTE *)(v11 + 16) |= 8u;
      result = (*(uint64_t (**)(void))(v14 + 16))();
      if (a5)
      {
        if ((_DWORD)result)
        {
          *(_BYTE *)(v11 + 16) |= 8u;
          LODWORD(v15) = *(_DWORD *)(v13 + 24);
          if (*(_DWORD *)(v13 + 28))
            v15 = (v15 + 1);
          else
            v15 = v15;
          *a5 = v15;
          return 1;
        }
      }
    }
  }
  return result;
}

BOOL RESyncCommitMarkDestroyed(uint64_t a1, uint64_t a2)
{
  _BOOL8 v2;
  _QWORD *v3;
  void *v4;
  id v5;
  re::SyncObject *v7;

  v2 = 0;
  if (a1 && a2)
  {
    v3 = (_QWORD *)(a1 + 32);
    v7 = (re::SyncObject *)a2;
    v4 = (void *)(a2 + 8);
    v5 = (id)(a2 + 8);
    v2 = re::SyncSnapshot::writeDestroyedObject(v3, &v7);

  }
  return v2;
}

uint64_t RESyncCommitEnumerateForRead(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v5;
  uint64_t v6;
  _QWORD v8[2];

  v2 = 0;
  if (a1 && a2)
  {
    if (*(_QWORD *)(a1 + 48))
    {
      v5 = 0;
      LODWORD(v2) = 1;
      do
      {
        v8[0] = re::SyncSnapshot::readAt((re::SyncSnapshot *)(a1 + 32), v5);
        v8[1] = v6;
        v2 = v2 & (*(unsigned int (**)(uint64_t, _QWORD *))(a2 + 16))(a2, v8);
        ++v5;
      }
      while (v5 < *(_QWORD *)(a1 + 48));
    }
    else
    {
      return 1;
    }
  }
  return v2;
}

uint64_t RESyncCommitSetForwarded(uint64_t result)
{
  if (result)
    *(_BYTE *)(result + 28) = 1;
  return result;
}

uint64_t RESyncCommitGetSourcePeerID(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

uint64_t RESyncCommitHoldWithID(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_BYTE *)result |= 2u;
    *(_QWORD *)(result + 16) = a2;
  }
  return result;
}

uint64_t RESyncCommitUnhold(uint64_t result)
{
  if (result)
  {
    *(_BYTE *)result &= ~2u;
    *(_QWORD *)(result + 16) = 0;
  }
  return result;
}

uint64_t RESyncGenerateHoldID()
{
  _QWORD v1[2];

  uuid_generate_random((unsigned __int8 *)v1);
  return (v1[1] + (v1[0] << 6) + (v1[0] >> 2) - 0x61C8864680B583E9) ^ v1[0];
}

uint64_t re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 24 * v4;
        do
        {
          if (*(_QWORD *)v3)
          {

            *(_QWORD *)v3 = 0;
          }
          v3 += 24;
          v5 -= 24;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::SyncCommitList::~SyncCommitList(re::SyncCommitList *this)
{
  *(_QWORD *)this = &off_24E0707F8;
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 24);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0707F8;
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 24);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t re::DynamicArray<re::SyncCommit>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 72 * v4;
        v6 = v3 + 32;
        do
        {
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(v6);
          v6 += 72;
          v5 -= 72;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::SyncCommit>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SyncCommit>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SyncCommit>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::SyncCommit>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SyncCommit>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x48uLL))
        {
          v2 = 72 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 72 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 72, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 72 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::SyncCommit::SyncCommit(v11, v8);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(v8 + 32);
          v8 += 72;
          v11 += 72;
          v10 -= 72;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 re::SyncCommit::SyncCommit(uint64_t a1, uint64_t a2)
{
  __n128 result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 13) = *(_OWORD *)(a2 + 13);
  *(__n128 *)a1 = result;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  v3 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v3;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v4 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v4;
  v5 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v5;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(a1 + 56);
  return result;
}

uint64_t re::DynamicArray<re::internal::SyncSnapshotEntry>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::internal::SyncSnapshotEntry>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t v16;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 24 * a1[2], a1[4]);
    v8 = a1[2];
    if (v8 != v4)
    {
      v9 = *(_QWORD *)(a2 + 32);
      v10 = (uint64_t *)(v9 + 24 * v4);
      v11 = 3 * v8;
      v12 = (uint64_t *)(v9 + 8 * v11);
      v13 = a1[4] + 8 * v11;
      do
      {
        v14 = *v12;
        *(_QWORD *)v13 = *v12;
        if (v14)
          v15 = (id)(v14 + 8);
        v16 = v12[1];
        *(_BYTE *)(v13 + 16) = *((_BYTE *)v12 + 16);
        *(_QWORD *)(v13 + 8) = v16;
        v12 += 3;
        v13 += 24;
      }
      while (v12 != v10);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 24 * v4, a1[4]);
    v5 = a1[2];
    if (v4 != v5)
    {
      v6 = a1[4] + 24 * v4;
      v7 = 24 * v5 - 24 * v4;
      do
      {
        if (*(_QWORD *)v6)
        {

          *(_QWORD *)v6 = 0;
        }
        v6 += 24;
        v7 -= 24;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

_QWORD *re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          v2 = 24 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 24 * v9;
        v11 = v7;
        do
        {
          *v11 = *(_QWORD *)v8;
          *(_QWORD *)v8 = 0;
          v12 = *(_QWORD *)(v8 + 8);
          *((_BYTE *)v11 + 16) = *(_BYTE *)(v8 + 16);
          v11[1] = v12;
          if (*(_QWORD *)v8)
          {

            *(_QWORD *)v8 = 0;
          }
          v8 += 24;
          v11 += 3;
          v10 -= 24;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    re::SharedPtr<re::SyncObject>::reset((uint64_t *)a3, *(_QWORD *)v4);
    v6 = *(_QWORD *)(v4 + 8);
    *(_BYTE *)(a3 + 16) = *(_BYTE *)(v4 + 16);
    *(_QWORD *)(a3 + 8) = v6;
    a3 += 24;
    v4 += 24;
  }
  while (v4 != v5);
  return v5;
}

void re::SharedPtr<re::SyncObject>::reset(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  id v5;

  v2 = *a1;
  if (*a1 != a2)
  {
    if (a2)
    {
      v5 = (id)(a2 + 8);
      v2 = *a1;
    }
    if (v2)

    *a1 = a2;
  }
}

uint64_t RESyncSessionSend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  BOOL v4;
  BOOL v5;
  int v6;
  uint64_t *v7;
  _BYTE v9[64];
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a1)
    v4 = a2 == 0;
  else
    v4 = 1;
  v5 = v4 || a3 == 0;
  v6 = v5;
  if (!v5)
  {
    if (a4)
    {
      v7 = 0;
    }
    else
    {
      a1 = MEMORY[0x24BDAC7A8]();
      v7 = (uint64_t *)v9;
      v10 = 0u;
      v11 = 0;
      memset(v9, 0, sizeof(v9));
      a4 = (uint64_t *)v9;
      HIDWORD(v10) = 0x7FFFFFFF;
    }
    *a4 = a1;
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 88))(a2, *(_QWORD *)(a3 + 56), *(_QWORD *)(a3 + 40));
    if (v7)
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v7 + 5);
  }
  return v6 ^ 1u;
}

uint64_t RESyncSessionSendRaw(re *a1, re *this, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    v7 = 136315394;
    v8 = "RESyncSessionSendRaw";
    v9 = 2080;
    v10 = "service != __null";
LABEL_14:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v7, 0x16u);
    return 0;
  }
  if (!this)
  {
    v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    v7 = 136315394;
    v8 = "RESyncSessionSendRaw";
    v9 = 2080;
    v10 = "session != __null";
    goto LABEL_14;
  }
  if (!a3)
  {
    v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    v7 = 136315394;
    v8 = "RESyncSessionSendRaw";
    v9 = 2080;
    v10 = "peerID != kRESyncInvalidPeerID";
    goto LABEL_14;
  }
  if (a4)
    return (*(uint64_t (**)(re *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)this + 96))(this, a3, a4, a5);
  v6 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    v7 = 136315394;
    v8 = "RESyncSessionSendRaw";
    v9 = 2080;
    v10 = "data != __null";
    goto LABEL_14;
  }
  return 0;
}

BOOL RESyncSessionSendAll(re *a1, uint64_t a2, re **a3)
{
  re **v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  _BOOL8 result;
  NSObject *v13;
  _BYTE v14[64];
  __int128 v15;
  uint64_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v13 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v18 = "RESyncSessionSendAll";
    v19 = 2080;
    v20 = "service != __null";
    goto LABEL_19;
  }
  if (!a2)
  {
    v13 = *re::networkLogObjects(a1);
    result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v18 = "RESyncSessionSendAll";
    v19 = 2080;
    v20 = "commits != __null";
LABEL_19:
    _os_log_error_impl(&dword_21C69B000, v13, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  v4 = a3;
  if (a3)
  {
    v5 = 0;
  }
  else
  {
    a1 = (re *)MEMORY[0x24BDAC7A8]();
    v5 = (uint64_t *)v14;
    v15 = 0u;
    v16 = 0;
    memset(v14, 0, sizeof(v14));
    v4 = (re **)v14;
    HIDWORD(v15) = 0x7FFFFFFF;
  }
  *v4 = a1;
  v6 = (*(uint64_t (**)(re *))(*(_QWORD *)a1 + 128))(a1);
  if (v7)
  {
    v8 = (uint64_t *)v6;
    v9 = 8 * v7;
    do
    {
      v10 = *v8;
      if (*v8)
        v11 = (id)(v10 + 8);
      (*(void (**)(uint64_t, _QWORD, _QWORD, re **))(*(_QWORD *)v10 + 88))(v10, *(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 40), v4);

      ++v8;
      v9 -= 8;
    }
    while (v9);
  }
  if (v5)
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v5 + 5);
  return 1;
}

BOOL RESyncSessionReceive(re *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  uint64_t *v4;
  _BOOL8 result;
  NSObject *v6;
  _BYTE v7[64];
  __int128 v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v6 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v10 = "RESyncSessionReceive";
    v11 = 2080;
    v12 = "service != __null";
    goto LABEL_17;
  }
  if (!a2)
  {
    v6 = *re::networkLogObjects(a1);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v10 = "RESyncSessionReceive";
    v11 = 2080;
    v12 = "session != __null";
    goto LABEL_17;
  }
  if (!a4)
  {
    v6 = *re::networkLogObjects(a1);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v10 = "RESyncSessionReceive";
    v11 = 2080;
    v12 = "handler != __null";
LABEL_17:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  if (a3)
  {
    v4 = 0;
  }
  else
  {
    MEMORY[0x24BDAC7A8]();
    v4 = (uint64_t *)v7;
    v8 = 0u;
    memset(v7, 0, sizeof(v7));
    DWORD1(v8) = 0x7FFFFFFF;
    a3 = v7;
  }
  (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)a2 + 72))(a2, a4, a3);
  if (v4)
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v4 + 4);
  return 1;
}

uint64_t RESyncSessionReceiveRaw(re *a1, re *this, uint64_t a3)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v4 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return 0;
    v5 = 136315394;
    v6 = "RESyncSessionReceiveRaw";
    v7 = 2080;
    v8 = "service != __null";
LABEL_12:
    _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    return 0;
  }
  if (!this)
  {
    v4 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return 0;
    v5 = 136315394;
    v6 = "RESyncSessionReceiveRaw";
    v7 = 2080;
    v8 = "session != __null";
    goto LABEL_12;
  }
  if (a3)
    return (*(uint64_t (**)(re *, uint64_t))(*(_QWORD *)this + 80))(this, a3);
  v4 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    v5 = 136315394;
    v6 = "RESyncSessionReceiveRaw";
    v7 = 2080;
    v8 = "handler != __null";
    goto LABEL_12;
  }
  return 0;
}

uint64_t RESyncSessionReceiveAll(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  BOOL v3;
  uint64_t v4;
  _BYTE *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  _BYTE v15[64];
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a1)
    v3 = a3 == 0;
  else
    v3 = 1;
  v4 = !v3;
  if (!v3)
  {
    v6 = a2;
    if (a2)
    {
      v7 = 0;
    }
    else
    {
      a1 = MEMORY[0x24BDAC7A8]();
      v6 = v15;
      v16 = 0u;
      memset(v15, 0, sizeof(v15));
      DWORD1(v16) = 0x7FFFFFFF;
      v7 = (uint64_t *)v15;
    }
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
    if (v9)
    {
      v10 = (uint64_t *)v8;
      v11 = 8 * v9;
      do
      {
        v12 = *v10;
        if (*v10)
          v13 = (id)(v12 + 8);
        (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v12 + 72))(v12, a3, v6);

        ++v10;
        v11 -= 8;
      }
      while (v11);
    }
    if (v7)
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v7 + 4);
  }
  return v4;
}

uint64_t RESyncSessionSetViewFilterCB(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  uint64_t v3;

  if (a1)
    v2 = a2 == 0;
  else
    v2 = 1;
  v3 = !v2;
  if (!v2)
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  return v3;
}

uint64_t RESyncSessionHasViewFilterCB(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 56))(result) != 0;
  return result;
}

uint64_t RESyncSessionGetNetSession(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  if (!a1)
    return 0;
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)a1 + 32))(&v3);
  v1 = v3;
  if (v3)

  return v1;
}

uint64_t RESyncSessionIsPrivileged(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v1 = a1;
  if (a1)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 32))(&v4, a1);
    if (v4)
    {
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v1 + 32))(&v3, v1);
      v1 = *(_BYTE *)(v3 + 2218) != 0;

      if (v4)
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t RESyncSessionIsLocal(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;

  v1 = a1;
  if (a1)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 32))(&v4, a1);
    if (v4)
    {
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v1 + 32))(&v3, v1);
      v1 = *(_BYTE *)(v3 + 2219) != 0;

      if (v4)
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t RESyncSessionPausePeer(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 120))(result);
  return result;
}

uint64_t RESyncSessionResumePeer(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 128))(result);
  return result;
}

double re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 32 * v3;
      do
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 32;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

re::SyncViewManager *re::SyncViewManager::SyncViewManager(re::SyncViewManager *this)
{
  _anonymous_namespace_ *v2;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E070840;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 22) = 0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *(_QWORD *)((char *)this + 148) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_DWORD *)this + 48) = 0;
  *(_QWORD *)((char *)this + 196) = 0x7FFFFFFFLL;
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)this + 3, 0);
  ++*((_DWORD *)this + 12);
  return this;
}

void re::SyncViewManager::~SyncViewManager(re::SyncViewManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  re::SyncViewer *v7;
  re *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  __n128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  *(_QWORD *)this = &off_24E070840;
  while (*((_DWORD *)this + 47))
  {
    v2 = *((unsigned int *)this + 48);
    v3 = *((_QWORD *)this + 22);
    v4 = 0;
    if ((_DWORD)v2)
    {
      v5 = (int *)(v3 + 8);
      while (1)
      {
        v6 = *v5;
        v5 += 6;
        if (v6 < 0)
          break;
        if (v2 == ++v4)
        {
          LODWORD(v4) = *((_DWORD *)this + 48);
          break;
        }
      }
    }
    v7 = *(re::SyncViewer **)(v3 + 24 * v4 + 16);
    v8 = (re *)re::SyncViewManager::removeViewer(this, v7, 1);
    if (v7)
    {
      v9 = re::globalAllocators(v8)[2];
      (**(void (***)(re::SyncViewer *))v7)(v7);
      (*(void (**)(uint64_t, re::SyncViewer *))(*(_QWORD *)v9 + 40))(v9, v7);
    }
  }
  while (*((_DWORD *)this + 35))
  {
    v10 = *((unsigned int *)this + 36);
    v11 = *((_QWORD *)this + 16);
    v12 = 0;
    if ((_DWORD)v10)
    {
      v13 = (int *)(v11 + 8);
      while (1)
      {
        v14 = *v13;
        v13 += 6;
        if (v14 < 0)
          break;
        if (v10 == ++v12)
        {
          LODWORD(v12) = *((_DWORD *)this + 36);
          break;
        }
      }
    }
    re::SyncViewManager::removeView((uint64_t)this, *(_QWORD *)(v11 + 24 * v12 + 16));
  }
  v16 = (uint64_t *)((char *)this + 24);
  v15 = *((_QWORD *)this + 3);
  if (v15)
  {
    if (*((_QWORD *)this + 7))
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = 0;
    *v16 = 0;
    ++*((_DWORD *)this + 12);
  }
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 20);
  v17.n128_f64[0] = re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 14);
  v18 = *((_QWORD *)this + 3);
  if (v18)
  {
    if (*((_QWORD *)this + 7))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v18 + 40))(v18, v17.n128_f64[0]);
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = 0;
    *v16 = 0;
    ++*((_DWORD *)this + 12);
  }
  v19 = *((_QWORD *)this + 8);
  if (v19)
  {
    if (*((_QWORD *)this + 12))
    {
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v19 + 40))(v19, v17);
      v20 = *v16;
    }
    else
    {
      v20 = 0;
    }
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 8) = 0;
    ++*((_DWORD *)this + 22);
    if (v20)
    {
      if (*((_QWORD *)this + 7))
        (*(void (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
      *((_QWORD *)this + 7) = 0;
      *((_QWORD *)this + 4) = 0;
      *((_QWORD *)this + 5) = 0;
      *v16 = 0;
      ++*((_DWORD *)this + 12);
    }
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::SyncViewManager::~SyncViewManager(this);
  JUMPOUT(0x220780CD0);
}

void re::SyncViewManager::addView(re::SyncViewManager *this, re::SyncView *a2)
{
  char *v3;
  char *v4;
  re::SyncView *v5;

  v3 = (char *)this + 112;
  v5 = a2;
  if (a2)
    v4 = (char *)a2 + 8;
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addNew((uint64_t)v3, (uint64_t *)&v5);
  if (v5)

  re::Event<re::SyncViewManager,re::SyncView *>::raise((uint64_t)this + 24, (uint64_t)this);
}

uint64_t re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addNew(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addAsMove(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

void re::Event<re::SyncViewManager,re::SyncView *>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;

  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
    re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions((_anonymous_namespace_ *)a1);
}

void re::SyncViewManager::removeView(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  id v3;
  uint64_t v4;

  v2 = a1 + 112;
  v4 = a2;
  if (a2)
    v3 = (id)(a2 + 8);
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove(v2, &v4);
  if (v4)

}

uint64_t re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31)) % v2;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(unsigned int *)(v7 + 4 * v6);
  if ((_DWORD)v8 == 0x7FFFFFFF)
    return 0;
  v10 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v10 + 24 * v8 + 16) != v4)
  {
    while (1)
    {
      v11 = v8;
      v12 = *(_DWORD *)(v10 + 24 * v8 + 8);
      v8 = v12 & 0x7FFFFFFF;
      if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      if (*(_QWORD *)(v10 + 24 * v8 + 16) == v4)
      {
        *(_DWORD *)(v10 + 24 * v11 + 8) = *(_DWORD *)(v10 + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(v10 + 24 * v8 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v10 + 24 * v8 + 8) & 0x7FFFFFFF;
LABEL_9:
  v13 = *(_QWORD *)(a1 + 16);
  v14 = v13 + 24 * v8;
  v17 = *(_DWORD *)(v14 + 8);
  v15 = (int *)(v14 + 8);
  v16 = v17;
  if (v17 < 0)
  {
    *v15 = v16 & 0x7FFFFFFF;
    v18 = v13 + 24 * v8;
    v21 = *(_QWORD *)(v18 + 16);
    v20 = (_QWORD *)(v18 + 16);
    v19 = v21;
    if (v21)
    {

      *v20 = 0;
    }
  }
  v22 = *(_QWORD *)(a1 + 16) + 24 * v8;
  v23 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v8;
  *(_DWORD *)(a1 + 40) = v23 + 1;
  return 1;
}

uint64_t re::SyncViewManager::forEachView(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;

  v3 = result;
  v4 = *(unsigned int *)(result + 144);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(result + 128) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(result + 144);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)(v3 + 128) + 24 * v8 + 16);
      result = (*(uint64_t (**)(_QWORD, uint64_t *))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), &v11);
      if (*(_DWORD *)(v3 + 144) <= (v5 + 1))
        v9 = v5 + 1;
      else
        v9 = *(_DWORD *)(v3 + 144);
      v10 = v5;
      while (1)
      {
        v8 = (v10 + 1);
        if (v9 - 1 == v10)
          break;
        ++v10;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*(_QWORD *)(v3 + 128) + 24 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v5) = v9;
LABEL_17:
      ;
    }
    while ((_DWORD)v4 != (_DWORD)v5);
  }
  return result;
}

uint64_t re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addNew(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::SyncViewManager::removeViewer(re::SyncViewManager *this, re::SyncViewer *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  re::SyncView *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  re::SyncViewer **v15;
  int v16;
  int v17;
  re::SyncViewer *v19;

  v19 = a2;
  v6 = *((unsigned int *)this + 36);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = (int *)(*((_QWORD *)this + 16) + 8);
    while (1)
    {
      v9 = *v8;
      v8 += 6;
      if (v9 < 0)
        break;
      if (v6 == ++v7)
      {
        LODWORD(v7) = *((_DWORD *)this + 36);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if ((_DWORD)v6 != (_DWORD)v7)
  {
    v10 = v7;
    do
    {
      v11 = *(re::SyncView **)(*((_QWORD *)this + 16) + 24 * v10 + 16);
      v12 = *((_QWORD *)v11 + 15);
      v13 = *((_QWORD *)v11 + 13);
      if (v13)
      {
        v14 = 8 * v13;
        v15 = (re::SyncViewer **)*((_QWORD *)v11 + 15);
        while (*v15 != a2)
        {
          ++v15;
          v14 -= 8;
          if (!v14)
          {
            v15 = (re::SyncViewer **)(v12 + 8 * v13);
            break;
          }
        }
      }
      else
      {
        v15 = (re::SyncViewer **)*((_QWORD *)v11 + 15);
      }
      if (v13 != ((uint64_t)v15 - v12) >> 3)
      {
        if (a3)
          re::SyncView::removeViewer((uint64_t)v11, a2);
        else
          re::SyncView::removeFromViewersWithoutNotifying(v11, a2);
      }
      if (*((_DWORD *)this + 36) <= (v7 + 1))
        v16 = v7 + 1;
      else
        v16 = *((_DWORD *)this + 36);
      while (1)
      {
        v10 = (v7 + 1);
        if (v16 - 1 == (_DWORD)v7)
          break;
        LODWORD(v7) = v7 + 1;
        v17 = v10;
        if ((*(_DWORD *)(*((_QWORD *)this + 16) + 24 * v10 + 8) & 0x80000000) != 0)
          goto LABEL_26;
      }
      v17 = v16;
LABEL_26:
      LODWORD(v7) = v17;
    }
    while ((_DWORD)v6 != v17);
  }
  return re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove((uint64_t)this + 160, (uint64_t *)&v19);
}

uint64_t re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;
  int v15;
  int v16;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v3 = *a2;
  v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31)) % v2;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v9 + 24 * v7 + 16) != v3)
  {
    while (1)
    {
      v10 = v7;
      LODWORD(v7) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v7 == 0x7FFFFFFF)
        return 0;
      if (*(_QWORD *)(v9 + 24 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 24 * v10 + 8) = *(_DWORD *)(v9 + 24 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  v11 = *(_QWORD *)(a1 + 16);
  v12 = v11 + 24 * v7;
  v15 = *(_DWORD *)(v12 + 8);
  v14 = (int *)(v12 + 8);
  v13 = v15;
  if (v15 < 0)
  {
    *v14 = v13 & 0x7FFFFFFF;
    v11 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v11 + 24 * v7 + 8);
  }
  v16 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v11 + 24 * v7 + 8) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v16 + 1;
  return 1;
}

uint64_t re::SyncViewManager::forEachViewer(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;

  v3 = result;
  v4 = *(unsigned int *)(result + 192);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(result + 176) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(result + 192);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    do
    {
      v11 = *(_QWORD *)(*(_QWORD *)(v3 + 176) + 24 * v8 + 16);
      result = (*(uint64_t (**)(_QWORD, uint64_t *))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), &v11);
      if (*(_DWORD *)(v3 + 192) <= (v5 + 1))
        v9 = v5 + 1;
      else
        v9 = *(_DWORD *)(v3 + 192);
      v10 = v5;
      while (1)
      {
        v8 = (v10 + 1);
        if (v9 - 1 == v10)
          break;
        ++v10;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*(_QWORD *)(v3 + 176) + 24 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v5) = v9;
LABEL_17:
      ;
    }
    while ((_DWORD)v4 != (_DWORD)v5);
  }
  return result;
}

double re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 24;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

_QWORD *re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 32 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  int v10;
  signed int v11;
  uint64_t v12;
  BOOL v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  signed int v23;
  uint64_t v24;
  _BYTE v26[44];

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      v10 = *(_DWORD *)(a1 + 28);
      v11 = 2 * v10;
      v12 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v11)
          v13 = (_DWORD)v8 == v11;
        else
          v13 = 1;
        if (!v13 && (v10 & 0x80000000) == 0)
        {
          memset(v26, 0, 36);
          *(_QWORD *)&v26[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v26, v12, v11);
          v14 = *(_OWORD *)v26;
          *(_OWORD *)v26 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v14;
          v15 = *(_QWORD *)&v26[16];
          v16 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v26[16] = v16;
          *(_QWORD *)(a1 + 16) = v15;
          v18 = *(_OWORD *)&v26[24];
          *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
          v17 = *(_DWORD *)&v26[32];
          *(_OWORD *)(a1 + 24) = v18;
          v19 = v17;
          if (v17)
          {
            v20 = v16 + 16;
            do
            {
              if ((*(_DWORD *)(v20 - 8) & 0x80000000) != 0)
                re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addAsMove(a1, *(_QWORD *)(v20 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v20 - 16), v20, v20);
              v20 += 24;
              --v19;
            }
            while (v19);
          }
          re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v26);
        }
      }
      else
      {
        if (v11)
          v23 = v11;
        else
          v23 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v21 = *(_QWORD *)(a1 + 16);
    v22 = *(_DWORD *)(v21 + 24 * v8 + 8);
  }
  else
  {
    v21 = *(_QWORD *)(a1 + 16);
    v22 = *(_DWORD *)(v21 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v22 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v21 + 24 * v8 + 8) = v22 | 0x80000000;
  v24 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(v24 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *a5 = 0;
  *(_DWORD *)(v24 + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

_QWORD *re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = result;
  v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    v5 = result[4];
    result = (_QWORD *)(v5 + 32 * a2);
    v6 = (char *)(v5 + 32 * v2);
    if (v6 != (char *)(result + 4))
    {
      result = memmove(result, result + 4, v6 - (char *)(result + 4));
      v4 = v3[2] - 1;
    }
  }
  v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions(_anonymous_namespace_ *a1)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t i;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  _OWORD v9[2];
  uint64_t v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  unint64_t v16;
  __int16 v17;
  unint64_t v18;
  _OWORD v19[5];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)a1 + 7);
  if (v1)
  {
    v3 = 0;
    for (i = 0; i != v1; ++i)
    {
      v5 = *((_QWORD *)a1 + 7);
      if (v5 <= i)
      {
        memset(v19, 0, sizeof(v19));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v11 = 136315906;
        v12 = "operator[]";
        v13 = 1024;
        v14 = 789;
        v15 = 2048;
        v16 = i;
        v17 = 2048;
        v18 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v6 = *((_QWORD *)a1 + 9) + v3;
      v7 = *(_QWORD *)(v6 + 32);
      v8 = *(_OWORD *)(v6 + 16);
      v9[0] = *(_OWORD *)v6;
      v9[1] = v8;
      v10 = v7;
      if (LOBYTE(v9[0]))
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)v9 + 1, (uint64_t)v19);
        if (!LOBYTE(v19[0]))
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(a1, (uint64_t)v9 + 8);
      }
      else
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable(a1, (_QWORD *)v9 + 1);
      }
      v3 += 40;
    }
  }
}

__n128 re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  _OWORD *v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (_OWORD *)(*((_QWORD *)this + 4) + 32 * v4);
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *v5 = *(_OWORD *)a2;
  v5[1] = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

BOOL re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable(_QWORD *a1, _QWORD *a2)
{
  int v3;
  _BYTE v5[8];
  unint64_t v6;

  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, a2, (uint64_t)v5);
  v3 = v5[0];
  if (v5[0])
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(a1, v6);
  return v3 != 0;
}

uint64_t re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v8;
  char v9;

  v3 = *(_QWORD *)(result + 32);
  v4 = *(_QWORD *)(result + 16);
  if (v4)
  {
    v5 = 32 * v4;
    v6 = *(_QWORD **)(result + 32);
    while (1)
    {
      if (*v6 == *a2)
      {
        result = a2[2];
        if (v6[1] == a2[1] && v6[2] == result)
          break;
      }
      v6 += 4;
      v5 -= 32;
      if (!v5)
      {
        v6 = (_QWORD *)(v3 + 32 * v4);
        break;
      }
    }
  }
  else
  {
    v6 = *(_QWORD **)(result + 32);
  }
  v8 = ((uint64_t)v6 - v3) >> 5;
  if (v8 == v4)
  {
    v9 = 0;
  }
  else
  {
    *(_QWORD *)(a3 + 8) = v8;
    v9 = 1;
  }
  *(_BYTE *)a3 = v9;
  return result;
}

_QWORD *re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            v14 = *(v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 16) = *v13;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

uint64_t re::UnicastStream::UnicastStream(uint64_t a1, id *a2, uint64_t a3, int a4, char a5, uint64_t a6, const void *a7)
{
  re *v13;
  uint64_t *v14;
  uint64_t v15;
  id to;

  to = 0;
  objc_copyWeak(&to, a2);
  re::TransportStream::TransportStream((_anonymous_namespace_ *)a1, &to, a3, a6);
  objc_destroyWeak(&to);
  to = 0;
  *(_QWORD *)a1 = &off_24E070888;
  *(_QWORD *)(a1 + 24) = &unk_24E0708E0;
  *(_DWORD *)(a1 + 56) = a4;
  *(_BYTE *)(a1 + 60) = a5;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  v14 = re::globalAllocators(v13);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14[2] + 32))(v14[2], 64, 64);
  *(_OWORD *)v15 = 0u;
  *(_OWORD *)(v15 + 16) = 0u;
  *(_DWORD *)(v15 + 32) = 0;
  *(_QWORD *)(v15 + 48) = 0;
  *(_QWORD *)(v15 + 56) = 0;
  *(_QWORD *)(v15 + 40) = 0;
  *(_QWORD *)(a1 + 64) = v15;
  *(_QWORD *)(a1 + 72) = v15;
  atomic_store(0, (unsigned int *)(a1 + 88));
  atomic_store(0, (unint64_t *)(a1 + 80));
  atomic_store(0, (unint64_t *)(a1 + 96));
  *(_QWORD *)(a1 + 104) = _Block_copy(a7);
  return a1;
}

void re::UnicastStream::~UnicastStream(re::UnicastStream *this)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t *v4;
  re *v5;
  uint64_t v6;
  uint64_t *v7;

  *(_QWORD *)this = &off_24E070888;
  *((_QWORD *)this + 3) = &unk_24E0708E0;
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    v3 = re::PacketQueue::dequeue((unint64_t **)this + 8);
    if (v3)
    {
      v4 = v3;
      do
      {
        re::PacketPool::free(*(re::PacketPool **)(v2 + 376), (re::Packet *)v4);
        v4 = re::PacketQueue::dequeue((unint64_t **)this + 8);
      }
      while (v4);
    }
  }
  _Block_release(*((const void **)this + 13));
  *((_QWORD *)this + 13) = 0;
  v6 = *((_QWORD *)this + 8);
  if (v6)
  {
    v7 = re::globalAllocators(v5);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7[2] + 40))(v7[2], v6);
  }
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  re::TransportStream::~TransportStream(this);
}

{
  re::UnicastStream::~UnicastStream(this);
  JUMPOUT(0x220780CD0);
}

void `non-virtual thunk to're::UnicastStream::~UnicastStream(re::UnicastStream *this)
{
  re::UnicastStream::~UnicastStream((re::UnicastStream *)((char *)this - 24));
}

{
  re::UnicastStream::~UnicastStream((re::UnicastStream *)((char *)this - 24));
  JUMPOUT(0x220780CD0);
}

char *re::UnicastStream::createPacket(re::UnicastStream *this, int a2)
{
  uint64_t v2;
  re::PacketPool **v3;

  v2 = *((_QWORD *)this + 4);
  if (v2)
    v3 = (re::PacketPool **)(v2 - 8);
  else
    v3 = 0;
  return re::Transport::createMultiplexedPacket(v3, *((_QWORD *)this + 6), a2);
}

char *`non-virtual thunk to're::UnicastStream::createPacket(re::UnicastStream *this, int a2)
{
  uint64_t v2;
  re::PacketPool **v3;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    v3 = (re::PacketPool **)(v2 - 8);
  else
    v3 = 0;
  return re::Transport::createMultiplexedPacket(v3, *((_QWORD *)this + 3), a2);
}

void re::UnicastStream::destroyPacket(re::UnicastStream *this, re::Packet *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

void `non-virtual thunk to're::UnicastStream::destroyPacket(re::UnicastStream *this, re::Packet *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

uint64_t re::UnicastStream::send(re::UnicastStream *this, re::Packet *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  v3 = *((_QWORD *)this + 4);
  v4 = *((_QWORD *)this + 5);
  if (v3)
    v5 = v3 - 8;
  else
    v5 = 0;
  v6 = *((_DWORD *)this + 14);
  v7 = *((unsigned __int8 *)this + 60);
  re::Packet::offsetTo((uint64_t)a2, 3);
  return re::Transport::send(v5, v4, (unint64_t)a2, 1u, v6, v7, 8);
}

unint64_t *re::UnicastStream::receive(unint64_t **this)
{
  return re::PacketQueue::dequeue(this + 8);
}

uint64_t re::SharedAppUnicast::SharedAppUnicast(uint64_t a1, id *a2, re *a3, uint64_t a4, uint64_t a5, uint64_t a6, id *a7, char a8, char a9)
{
  re::Packet *v16;
  uint64_t v17;
  re::Transport *v18;
  char *WeakRetained;
  char *v20;
  _BOOL4 v21;
  re::Packet *v22;
  uint64_t v23;
  re::Transport *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD v28[5];
  _QWORD *v29;
  unsigned int v30;
  char v31;
  int v32;
  re::Packet *v33;
  uint64_t v34;

  v34 = a4;
  *(_QWORD *)a1 = 0;
  objc_copyWeak((id *)a1, a2);
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = a5;
  *(_QWORD *)(a1 + 24) = a6;
  *(_QWORD *)(a1 + 32) = 0;
  objc_copyWeak((id *)(a1 + 32), a7);
  *(_BYTE *)(a1 + 40) = a8;
  *(_BYTE *)(a1 + 41) = a9;
  *(_WORD *)(a1 + 42) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 84) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 96) = 0x8000000000000000;
  v32 = 0;
  v31 = 1;
  v30 = 1;
  v28[0] = MEMORY[0x24BDAC760];
  v28[1] = 0x40000000;
  v28[2] = ___ZN2re16SharedAppUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbb_block_invoke;
  v28[3] = &__block_descriptor_tmp;
  v28[4] = a1;
  v29 = v28;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(a3, &v34, &v32, &v31, &v30, (const void **)&v29, (uint64_t *)&v33);
  v16 = v33;
  v17 = v34;
  if (*(_QWORD *)a3)
    v18 = (re::Transport *)(*(_QWORD *)a3 - 8);
  else
    v18 = 0;
  WeakRetained = (char *)objc_loadWeakRetained(a2);
  if (WeakRetained)
    v20 = WeakRetained - 8;
  else
    v20 = 0;
  (*(void (**)(re::Packet **__return_ptr, char *))(*(_QWORD *)v20 + 32))(&v33, v20);
  v21 = re::Transport::registerStream(v18, v16, 1uLL, v17);
  if (v33)
  {

    v33 = 0;
  }

  if (v21)
  {
    v22 = *(re::Packet **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v16;
    v16 = v22;
  }
  v33 = 0;
  if (*(_QWORD *)a3)
    v23 = *(_QWORD *)a3 - 8;
  else
    v23 = 0;
  if (re::Transport::receive(v23, v34, 1u, (unint64_t **)&v33))
  {
    do
    {
      if (*(_QWORD *)a3)
        v24 = (re::Transport *)(*(_QWORD *)a3 - 8);
      else
        v24 = 0;
      if (re::Transport::dispatchPacketToStream(v24, v33, v34))
      {
        if (*(_QWORD *)a3)
          v25 = *(_QWORD *)a3 - 8;
        else
          v25 = 0;
        re::PacketPool::free(*(re::PacketPool **)(v25 + 384), v33);
      }
      if (*(_QWORD *)a3)
        v26 = *(_QWORD *)a3 - 8;
      else
        v26 = 0;
    }
    while (re::Transport::receive(v26, v34, 1u, (unint64_t **)&v33));
  }
  if (v16)

  return a1;
}

uint64_t ___ZN2re16SharedAppUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbb_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 43) = 1;
  return result;
}

BOOL re::SharedAppUnicast::shouldForward(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *a2;
  v3 = *(_QWORD *)(*a2 + 80);
  if (v3)
  {
    do
    {
      v4 = v2;
      v2 = v3;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 88) + 16) + 73))
        break;
      v3 = *(_QWORD *)(v3 + 80);
      v4 = v2;
    }
    while (v3);
  }
  else
  {
    v4 = *a2;
  }
  return *(_BYTE *)(v4 + 170) || *(_BYTE *)(a1 + 40) || *(_BYTE *)(a1 + 41) != 0;
}

void re::SharedAppUnicast::send(id *location, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  re *v9;
  uint64_t v10;
  re *v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t *v16;
  _BYTE *v17;
  char *v18;
  char *v19;
  void *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  std::chrono::steady_clock::time_point v26;
  uint64_t v27;
  re *v28;
  re *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  const char *v42;
  const char *v43;
  BOOL v44;
  const char *v45;
  size_t v46;
  size_t v47;
  size_t v48;
  int v49;
  int v50;
  char *WeakRetained;
  char *v52;
  void *v53;
  NSObject *v54;
  double v55;
  char *v56;
  char *v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  re::Transport *v61;
  _BYTE *v62;
  char *v63;
  uint64_t v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  int *v69;
  int v70;
  uint64_t v71;
  char *v72;
  uint64_t *v73;
  char *v74;
  uint64_t *v75;
  uint64_t *v76;
  int v77;
  int v78;
  uint64_t v79;
  re *v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  id v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;
  uint64_t v92;
  char v93;
  _BYTE v94[7];
  _BYTE *v95;
  re::Session *v96;
  uint64_t *v97;
  unint64_t v98;
  char *v99;
  uint64_t v100;
  _QWORD v101[2];
  uint64_t v102;
  int v103;
  re *v104;
  _BYTE buf[12];
  __int16 v106;
  _BYTE *v107;
  __int16 v108;
  char *v109;
  uint64_t v110;

  v110 = *MEMORY[0x24BDAC8D0];
  if (location[1])
  {
    re::SyncCommitDump::log(*(re **)a2, *(_QWORD *)(a2 + 8), "SendCommit");
    v104 = 0;
    v101[1] = 0;
    v102 = 0;
    v101[0] = 0;
    v103 = 0;
    v9 = *(re **)a2;
    v10 = *(_QWORD *)(a2 + 8);
    if (*((_BYTE *)location + 42))
    {
      if (v10)
      {
        v11 = (re *)((char *)v9 + 72 * v10);
        v12 = 1;
        do
        {
          v13 = *((_QWORD *)v9 + 6);
          if (v13)
          {
            v14 = 24 * v13;
            v15 = (_BYTE *)(*((_QWORD *)v9 + 8) + 16);
            do
            {
              v16 = (uint64_t *)(v15 - 16);
              if ((*v15 & 2) != 0)
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace((uint64_t)(location + 6), v16, v15);
              }
              else
              {
                v17 = (_BYTE *)re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add((uint64_t)(location + 6), v16, v15);
                if ((*v17 & 2) != 0)
                  *v17 = *v15;
              }
              v15 += 24;
              v14 -= 24;
            }
            while (v14);
            v12 = 0;
          }
          v9 = (re *)((char *)v9 + 72);
        }
        while (v9 != v11);
      }
      else
      {
        v12 = 1;
      }
      if (std::chrono::steady_clock::now().__d_.__rep_ >= (uint64_t)location[12] && (v12 & 1) == 0)
      {
        v26.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        location[12] = (id)(v26.__d_.__rep_ + 5000000000);
        LODWORD(v89) = 0;
        v87 = 0u;
        v88 = 0u;
        *(_QWORD *)((char *)&v89 + 4) = 0x7FFFFFFFLL;
        v27 = *(_QWORD *)(a2 + 8);
        if (v27)
        {
          v28 = *(re **)a2;
          v29 = (re *)((char *)v28 + 72 * v27);
          do
          {
            v30 = *((_QWORD *)v28 + 6);
            if (v30)
            {
              v31 = (uint64_t *)*((_QWORD *)v28 + 8);
              v32 = 24 * v30;
              do
              {
                v33 = *v31;
                v31 += 3;
                v26.__d_.__rep_ = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v87, (re::DynamicString *)(*(_QWORD *)(*(_QWORD *)(v33 + 88) + 16) + 40));
                v32 -= 24;
              }
              while (v32);
            }
            v28 = (re *)((char *)v28 + 72);
          }
          while (v28 != v29);
        }
        v98 = 0;
        v99 = 0;
        v100 = 0;
        re::DynamicString::setCapacity(&v97, 0);
        v34 = v89;
        if ((_DWORD)v89)
        {
          v35 = 0;
          v36 = (int *)(v88 + 8);
          while (1)
          {
            v37 = *v36;
            v36 += 12;
            if (v37 < 0)
              break;
            if (v89 == ++v35)
            {
              LODWORD(v35) = v89;
              break;
            }
          }
        }
        else
        {
          LODWORD(v35) = 0;
        }
        if ((_DWORD)v89 != (_DWORD)v35)
        {
          v38 = v35;
          v39 = v88;
          do
          {
            v40 = v39 + 48 * v38;
            v41 = *(_QWORD *)(v40 + 24);
            v42 = *(const char **)(v40 + 32);
            v43 = (const char *)(v40 + 25);
            v44 = (v41 & 1) == 0;
            if ((v41 & 1) != 0)
              v45 = v42;
            else
              v45 = v43;
            v46 = v41 >> 1;
            v47 = v41 >> 1;
            if (v44)
              v48 = v47;
            else
              v48 = v46;
            re::DynamicString::append((re::DynamicString *)&v97, v45, v48);
            re::DynamicString::append((re::DynamicString *)&v97, " ", 1uLL);
            v39 = v88;
            if (v89 <= (int)v35 + 1)
              v49 = v35 + 1;
            else
              v49 = v89;
            v50 = v35;
            while (1)
            {
              v38 = (v50 + 1);
              if (v49 - 1 == v50)
                break;
              ++v50;
              LODWORD(v35) = v38;
              if ((*(_DWORD *)(v88 + 48 * v38 + 8) & 0x80000000) != 0)
                goto LABEL_57;
            }
            LODWORD(v35) = v49;
LABEL_57:
            ;
          }
          while (v34 != (_DWORD)v35);
        }
        WeakRetained = (char *)objc_loadWeakRetained(location);
        if (WeakRetained)
          v52 = WeakRetained - 8;
        else
          v52 = 0;
        v53 = v52 + 8;
        (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v52 + 32))(buf);
        v54 = *(NSObject **)(*(_QWORD *)buf + 3272);

        *(_QWORD *)buf = 0;
        if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
        {
          v56 = (char *)objc_loadWeakRetained(location);
          if (v56)
            v57 = v56 - 8;
          else
            v57 = 0;
          (*(void (**)(re::Session **__return_ptr, char *))(*(_QWORD *)v57 + 32))(&v96, v57);
          v58 = re::Session::peerID(v96);
          v59 = location[1];
          v60 = v59[4];
          if (v60)
            v61 = (re::Transport *)(v60 - 8);
          else
            v61 = 0;
          re::Transport::connectionAddress(v61, v59[5], (re::DynamicString *)&v92);
          if ((v93 & 1) != 0)
            v62 = v95;
          else
            v62 = v94;
          if ((v98 & 1) != 0)
            v63 = v99;
          else
            v63 = (char *)&v98 + 1;
          *(_DWORD *)buf = 134218498;
          *(_QWORD *)&buf[4] = v58;
          v106 = 2080;
          v107 = v62;
          v108 = 2080;
          v109 = v63;
          _os_log_impl(&dword_21C69B000, v54, OS_LOG_TYPE_INFO, "Sending sync data on paused connection to %llx ('%s'): %s", buf, 0x20u);
          if (v92 && (v93 & 1) != 0)
            (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v92 + 40))(v92, v95);
          if (v96)
          {

            v96 = 0;
          }

        }
        if (v97)
        {
          if ((v98 & 1) != 0)
            v55 = (*(double (**)(uint64_t *, char *))(*v97 + 40))(v97, v99);
        }
        re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v87, v55);
      }
    }
    else
    {
      if (*((_DWORD *)location + 19))
      {
        v22 = *(unsigned int *)(a4 + 96);
        if ((_DWORD)v22)
        {
          v23 = 0;
          v24 = (int *)(*(_QWORD *)(a4 + 80) + 8);
          while (1)
          {
            v25 = *v24;
            v24 += 8;
            if (v25 < 0)
              break;
            if (v22 == ++v23)
            {
              LODWORD(v23) = *(_DWORD *)(a4 + 96);
              break;
            }
          }
        }
        else
        {
          LODWORD(v23) = 0;
        }
        if ((_DWORD)v22 != (_DWORD)v23)
        {
          v64 = v23;
          do
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)(location + 6), (uint64_t *)(*(_QWORD *)(a4 + 80) + 32 * v64 + 16));
            if (*(_DWORD *)(a4 + 96) <= (v23 + 1))
              v65 = v23 + 1;
            else
              v65 = *(_DWORD *)(a4 + 96);
            v66 = v23;
            while (1)
            {
              v64 = (v66 + 1);
              if (v65 - 1 == v66)
                break;
              ++v66;
              LODWORD(v23) = v64;
              if ((*(_DWORD *)(*(_QWORD *)(a4 + 80) + 32 * v64 + 8) & 0x80000000) != 0)
                goto LABEL_95;
            }
            LODWORD(v23) = v65;
LABEL_95:
            ;
          }
          while ((_DWORD)v22 != (_DWORD)v23);
        }
        v91 = 0;
        v89 = 0u;
        v90 = 0u;
        v87 = 0u;
        v88 = 0u;
        LOBYTE(v87) = 1;
        v67 = *((unsigned int *)location + 20);
        if ((_DWORD)v67)
        {
          v68 = 0;
          v69 = (int *)((char *)location[8] + 8);
          while (1)
          {
            v70 = *v69;
            v69 += 8;
            if (v70 < 0)
              break;
            if (v67 == ++v68)
            {
              LODWORD(v68) = *((_DWORD *)location + 20);
              break;
            }
          }
        }
        else
        {
          LODWORD(v68) = 0;
        }
        if ((_DWORD)v67 != (_DWORD)v68)
        {
          v71 = v68;
          do
          {
            v72 = (char *)location[8] + 32 * v71;
            v75 = (uint64_t *)*((_QWORD *)v72 + 2);
            v74 = v72 + 16;
            v73 = v75;
            v97 = v75;
            if (v75)
              v76 = v73 + 1;
            v98 = re::SyncObject::latestStateHandle(*(re::SyncObject **)v74);
            LOBYTE(v99) = v74[8];
            re::DynamicArray<re::internal::SyncSnapshotEntry>::add(&v89, (uint64_t)&v97);
            if (v97)

            if (*((_DWORD *)location + 20) <= (v68 + 1))
              v77 = v68 + 1;
            else
              v77 = *((_DWORD *)location + 20);
            while (1)
            {
              v71 = (v68 + 1);
              if (v77 - 1 == (_DWORD)v68)
                break;
              LODWORD(v68) = v68 + 1;
              v78 = v71;
              if ((*((_DWORD *)location[8] + 8 * v71 + 2) & 0x80000000) != 0)
                goto LABEL_115;
            }
            v78 = v77;
LABEL_115:
            LODWORD(v68) = v78;
          }
          while ((_DWORD)v67 != v78);
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear((uint64_t)(location + 6));
        re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)v101, (uint64_t)&v87);
        v79 = *(_QWORD *)(a2 + 8);
        if (v79)
        {
          v80 = *(re **)a2;
          v81 = 72 * v79;
          do
          {
            re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)v101, (__int128 *)v80);
            v80 = (re *)((char *)v80 + 72);
            v81 -= 72;
          }
          while (v81);
        }
        v9 = v104;
        v10 = v102;
        re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v89);
      }
      v82 = (char *)location[1] + 24;
      LODWORD(v88) = 0;
      BYTE4(v88) = 0;
      *((_QWORD *)&v88 + 1) = 0;
      *(_QWORD *)&v89 = 0;
      *(_QWORD *)&v87 = &off_24E071758;
      *((_QWORD *)&v87 + 1) = 0;
      *((_QWORD *)&v89 + 1) = v82;
      *(_QWORD *)&v90 = 0;
      LOBYTE(v97) = 0;
      if (v10)
      {
        v83 = 72 * v10;
        do
        {
          re::SharedAppSyncPacker::packCommit((unsigned __int8 *)&v97, (uint64_t)v9, (re::BitWriter *)&v87, a5, 0);
          v9 = (re *)((char *)v9 + 72);
          v83 -= 72;
        }
        while (v83);
        v84 = DWORD2(v88);
        v85 = v90;
        if (HIDWORD(v88))
          v84 = DWORD2(v88) + 1;
        if (v84)
        {
          v86 = location[1];
          *(_DWORD *)(v90 + 24) = v84;
          *((_QWORD *)&v88 + 1) = 0;
          *(_QWORD *)&v89 = 0;
          *((_QWORD *)&v87 + 1) = 0;
          LODWORD(v88) = 0;
          *(_QWORD *)&v90 = 0;
          (*(void (**)(id))(*(_QWORD *)v86 + 48))(v86);
          v85 = v90;
        }
        if (v85)
          (*(void (**)(_QWORD))(**((_QWORD **)&v89 + 1) + 24))(*((_QWORD *)&v89 + 1));
      }
    }
    re::DynamicArray<re::SyncCommit>::deinit((uint64_t)v101);
  }
  else
  {
    v18 = (char *)objc_loadWeakRetained(location);
    if (v18)
      v19 = v18 - 8;
    else
      v19 = 0;
    v20 = v19 + 8;
    (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v19 + 32))(&v87);
    v21 = *(NSObject **)(v87 + 3272);

    *(_QWORD *)&v87 = 0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v87) = 0;
      _os_log_error_impl(&dword_21C69B000, v21, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to send.", (uint8_t *)&v87, 2u);
    }
  }
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16);
    v10 = v13;
    return v12 + 32 * v10 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  *(_BYTE *)(v11 + 32 * v10 + 24) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v12 = *(_QWORD *)(a1 + 16);
  return v12 + 32 * v10 + 24;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 32 * v10;
  return v12 + 24;
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(uint64_t a1, re::DynamicString *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  char v13;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v13, (uint64_t)a2);
  v5 = v4;
  v6 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v6)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  v7 = v4 % v6;
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % v6));
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, v7, v5, (int)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + 48 * v11 + 16;
  }
  v9 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v10 = v9 + 48 * v8 + 16;
    if (re::DynamicString::operator==(v10, (uint64_t)a2))
      return v10;
    v8 = *(_DWORD *)(v9 + 48 * v8 + 8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_21C701D20, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *(unsigned int *)(a1 + 32);
          }
        }
        v4 += 32;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v9;
  }
}

BOOL re::SharedAppUnicast::receive(id *location, uint64_t a2, uint64_t a3)
{
  id *v3;
  id v4;
  uint64_t v6;
  id *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  char *WeakRetained;
  char *v12;
  __int16 v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int *v18;
  int v19;
  _QWORD *v20;
  uint64_t v21;
  re::Transport *v22;
  char *v23;
  char *v24;
  void *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  void *v33;
  re::SyncObjectStore *v34;
  re::SyncObject **v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  id v39;
  void *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  BOOL v44;
  re *v45;
  NSObject *v46;
  uint64_t v47;
  id v48;
  _BYTE *v49;
  _BOOL8 result;
  char *v51;
  char *v52;
  void *v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  id *v57;
  int v59;
  char v60[8];
  uint64_t v61;
  _QWORD v62[2];
  _BYTE v63[24];
  int v64;
  uint64_t v65;
  uint8_t v66[8];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  unsigned int v70;
  uint64_t v71;
  __int16 v72;
  uint64_t v73;
  int v74;
  char v75;
  uint64_t v76;
  uint64_t v77;
  _BYTE v78[12];
  __int16 v79;
  _BYTE *v80;
  _BYTE buf[24];
  uint64_t v82;

  v3 = location;
  v82 = *MEMORY[0x24BDAC8D0];
  v4 = location[1];
  if (v4)
  {
    if (*((_BYTE *)v3 + 43))
    {
      *((_BYTE *)v3 + 43) = 0;
      v6 = (*(uint64_t (**)(id))(*(_QWORD *)v4 + 56))(v4);
      if (v6)
      {
        v7 = v3 + 4;
        v8 = v6;
        v56 = a2;
        v57 = v3;
        while (1)
        {
          v9 = *(_QWORD *)(v8 + 16);
          v55 = v8;
          v10 = *(_DWORD *)(v8 + 24);
          v73 = v9;
          v74 = v10;
          v75 = 0;
          v76 = 0;
          v77 = 0;
          while (v74 != (_DWORD)v76)
          {
            WeakRetained = (char *)objc_loadWeakRetained(v7);
            v12 = WeakRetained - 8;
            if (!WeakRetained)
              v12 = 0;
            v13 = *((_WORD *)v3 + 20);
            *(_QWORD *)v66 = v12;
            v67 = *((_OWORD *)v3 + 1);
            v68 = 0u;
            v69 = 0u;
            v70 = 0;
            v71 = 0x7FFFFFFFLL;
            v72 = v13;
            if (WeakRetained)

            v60[0] = 0;
            v65 = 0;
            memset(v63, 0, sizeof(v63));
            v64 = 0;
            v61 = 0;
            v62[0] = 0;
            *(_QWORD *)((char *)v62 + 5) = 0;
            v14 = re::SharedAppSyncUnpacker::unpackCommit((_anonymous_namespace_ *)v66, (uint64_t)&v73, (uint64_t)v60, a2);
            v15 = v14;
            if (!v14)
            {
              v20 = v3[1];
              v21 = v20[4];
              if (v21)
                v22 = (re::Transport *)(v21 - 8);
              else
                v22 = 0;
              re::Transport::connectionAddress(v22, v20[5], (re::DynamicString *)buf);
              v23 = (char *)objc_loadWeakRetained(v3);
              if (v23)
                v24 = v23 - 8;
              else
                v24 = 0;
              v25 = v24 + 8;
              (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v24 + 32))(v78);
              v26 = *(NSObject **)(*(_QWORD *)v78 + 3272);

              *(_QWORD *)v78 = 0;
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                v48 = v3[2];
                v49 = &buf[9];
                if ((buf[8] & 1) != 0)
                  v49 = *(_BYTE **)&buf[16];
                *(_DWORD *)v78 = 134218242;
                *(_QWORD *)&v78[4] = v48;
                v79 = 2082;
                v80 = v49;
                _os_log_error_impl(&dword_21C69B000, v26, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)", v78, 0x16u);
              }
              (*(void (**)(id, uint64_t))(*(_QWORD *)v3[1] + 40))(v3[1], v55);
              if (*(_QWORD *)buf && (buf[8] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)buf + 40))();
              goto LABEL_30;
            }
            v59 = v14;
            v16 = v70;
            if (v70)
            {
              v17 = 0;
              v18 = (int *)(v69 + 8);
              while (1)
              {
                v19 = *v18;
                v18 += 10;
                if (v19 < 0)
                  break;
                if (v70 == ++v17)
                {
                  LODWORD(v17) = v70;
                  break;
                }
              }
            }
            else
            {
              LODWORD(v17) = 0;
            }
            if (v70 != (_DWORD)v17)
            {
              v27 = v17;
              v28 = v69;
              while (1)
              {
                v29 = v28 + 40 * v27;
                v30 = *(_QWORD *)(v29 + 24);
                v31 = *(_QWORD *)(v29 + 32);
                v32 = (char *)objc_loadWeakRetained(v7);
                v33 = v32;
                if (v32)
                  v34 = (re::SyncObjectStore *)(v32 - 8);
                else
                  v34 = 0;
                re::SyncObjectStore::findObject(v34, v30, v31, (re::SyncObjectTypedStore ***)v78);
                if (v33)

                v35 = (re::SyncObject **)(v29 + 16);
                v36 = *(_QWORD *)v78;
                if (*(_QWORD *)v78)
                  break;
                v39 = objc_loadWeakRetained(v7);
                if (v39)
                {
                  v40 = v39;
                  v41 = (char *)objc_loadWeakRetained(v7);
                  v42 = v41 - 8;
                  if (!v41)
                    v42 = 0;
                  v43 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*v35 + 11) + 16) + 32);
                  *(_QWORD *)buf = *((_QWORD *)*v35 + 3);
                  *(_QWORD *)&buf[8] = v43;
                  *(_QWORD *)&buf[16] = 0;
                  v44 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v42 + 600), (uint64_t *)buf);
                  if (v41)

                  if (!v44)
                  {
                    v46 = *re::networkLogObjects(v45);
                    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                    {
                      v47 = *((_QWORD *)*v35 + 3);
                      *(_DWORD *)buf = 134218240;
                      *(_QWORD *)&buf[4] = v47;
                      *(_WORD *)&buf[12] = 2048;
                      *(_QWORD *)&buf[14] = v31;
                      _os_log_error_impl(&dword_21C69B000, v46, OS_LOG_TYPE_ERROR, "BindFailure: Object %llu with parent %llu", buf, 0x16u);
                    }
                  }
                  v36 = *(_QWORD *)v78;
                  if (*(_QWORD *)v78)
                    goto LABEL_40;
                }
LABEL_41:
                v28 = v69;
                if (v70 <= (int)v17 + 1)
                  v37 = v17 + 1;
                else
                  v37 = v70;
                while (1)
                {
                  v27 = (v17 + 1);
                  if (v37 - 1 == (_DWORD)v17)
                    break;
                  LODWORD(v17) = v17 + 1;
                  v38 = v27;
                  if ((*(_DWORD *)(v69 + 40 * v27 + 8) & 0x80000000) != 0)
                    goto LABEL_48;
                }
                v38 = v37;
LABEL_48:
                LODWORD(v17) = v38;
                if (v16 == v38)
                  goto LABEL_29;
              }
              re::SyncObject::bindWithParent(*v35, *(re::SyncObject **)v78);
LABEL_40:

              goto LABEL_41;
            }
LABEL_29:
            re::SyncCommitDump::log((re *)v60, 1, "RecvCommit");
            a2 = v56;
            (*(void (**)(uint64_t, char *, uint64_t))(a3 + 16))(a3, v60, v56);
            v3 = v57;
            v15 = v59;
LABEL_30:
            re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v63);
            re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)&v68);
            if (!v15)
              return 0;
          }
          (*(void (**)(id, uint64_t))(*(_QWORD *)v3[1] + 40))(v3[1], v55);
          v8 = (*(uint64_t (**)(id))(*(_QWORD *)v3[1] + 56))(v3[1]);
          result = 1;
          if (!v8)
            return result;
        }
      }
    }
    return 1;
  }
  else
  {
    v51 = (char *)objc_loadWeakRetained(v3);
    if (v51)
      v52 = v51 - 8;
    else
      v52 = 0;
    v53 = v52 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v52 + 32))(v66);
    v54 = *(NSObject **)(*(_QWORD *)v66 + 3272);

    *(_QWORD *)v66 = 0;
    result = os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)v66 = 0;
      _os_log_error_impl(&dword_21C69B000, v54, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", v66, 2u);
      return 0;
    }
  }
  return result;
}

double re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1, double result)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 v7;
  uint64_t v8;
  __n128 *v9;
  int v10;
  uint64_t v11;
  __n128 *v12;
  uint64_t v13;

  v3 = *a1;
  if (v3)
  {
    v4 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0uLL;
      do
      {
        v8 = a1[2];
        v9 = (__n128 *)(v8 + v5);
        v10 = *(_DWORD *)(v8 + v5 + 8);
        if (v10 < 0)
        {
          v9->n128_u32[2] = v10 & 0x7FFFFFFF;
          v13 = v9[1].n128_i64[0];
          v12 = v9 + 1;
          v11 = v13;
          if (v13)
          {
            if ((*(_BYTE *)(v8 + v5 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v8 + v5 + 32), v7);
              v7 = 0uLL;
            }
            *v12 = v7;
            v12[1] = v7;
            v4 = *((unsigned int *)a1 + 8);
          }
        }
        ++v6;
        v5 += 48;
      }
      while (v6 < v4);
      v3 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 40;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(re *a1@<X0>, uint64_t *a2@<X1>, int *a3@<X2>, char *a4@<X3>, unsigned int *a5@<X4>, const void **a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t *v14;
  uint64_t v15;
  id to;

  v14 = re::globalAllocators(a1);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14[2] + 32))(v14[2], 112, 8);
  to = 0;
  objc_copyWeak(&to, (id *)a1);
  re::UnicastStream::UnicastStream(v15, &to, *a2, *a3, *a4, *a5, *a6);
  *a7 = v15;
  objc_destroyWeak(&to);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, _BYTE *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  id v15;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  v13 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  v14 = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  if (v14)
    v15 = (id)(v14 + 8);
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 24);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 32;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, int a4, re::DynamicString *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 48 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 48 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 48 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 16), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_OWORD *)&v13[24];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = DWORD2(v7);
      if (DWORD2(v7))
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 48;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 48 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 48 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 48 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 48 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v8) = a3;
  v12 = *(_QWORD *)(a1 + 16) + 48 * v8;
  *(_OWORD *)(v12 + 16) = 0u;
  *(_OWORD *)(v12 + 32) = 0u;
  *(_QWORD *)(v12 + 40) = a5[3];
  v13 = a5[1];
  *(_QWORD *)(v12 + 16) = *a5;
  *a5 = 0;
  v14 = a5[2];
  a5[3] = 0;
  v16 = *(_QWORD *)(v12 + 24);
  v15 = *(_QWORD *)(v12 + 32);
  *(_QWORD *)(v12 + 24) = v13;
  *(_QWORD *)(v12 + 32) = v14;
  a5[1] = v16;
  a5[2] = v15;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  int v19;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = *a2;
  v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  v10 = v9 + 32 * v7;
  if (*(_QWORD *)(v10 + 16) != v3)
  {
    while (1)
    {
      v11 = v7;
      v12 = *(_DWORD *)(v9 + 32 * v7 + 8);
      v7 = v12 & 0x7FFFFFFF;
      if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      v13 = v9 + 32 * v7;
      if (*(_QWORD *)(v13 + 16) == v3)
      {
        *(_DWORD *)(v9 + 32 * v11 + 8) = *(_DWORD *)(v9 + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v13 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v10 + 8) & 0x7FFFFFFF;
LABEL_9:
  v14 = *(_QWORD *)(a1 + 16) + 32 * v7;
  v15 = *(_DWORD *)(v14 + 8);
  if (v15 < 0)
  {
    *(_DWORD *)(v14 + 8) = v15 & 0x7FFFFFFF;
    v18 = *(_QWORD *)(v14 + 16);
    v17 = (_QWORD *)(v14 + 16);
    v16 = v18;
    if (v18)
    {

      *v17 = 0;
    }
  }
  v19 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v19 + 1;
  return 1;
}

uint64_t re::UnreliableAckedUnicastStream::UnreliableAckedUnicastStream(uint64_t a1, id *a2, uint64_t a3, char a4, uint64_t a5, const void *a6)
{
  id to;

  to = 0;
  objc_copyWeak(&to, a2);
  re::UnicastStream::UnicastStream(a1, &to, a3, 2, a4, a5, a6);
  objc_destroyWeak(&to);
  *(_QWORD *)a1 = &off_24E070948;
  *(_QWORD *)(a1 + 24) = &unk_24E0709A0;
  *(_WORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_WORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_WORD *)(a1 + 192) = 0;
  return a1;
}

char *re::UnreliableAckedUnicastStream::createPacket(re::UnreliableAckedUnicastStream *this, int a2)
{
  uint64_t v2;
  re::PacketPool **v3;
  char *MultiplexedPacket;
  char *v5;

  v2 = *((_QWORD *)this + 4);
  if (v2)
    v3 = (re::PacketPool **)(v2 - 8);
  else
    v3 = 0;
  MultiplexedPacket = re::Transport::createMultiplexedPacket(v3, *((_QWORD *)this + 6), a2 + 36);
  v5 = MultiplexedPacket;
  if (MultiplexedPacket)
    re::Packet::offsetBy((uint64_t)MultiplexedPacket, 36);
  return v5;
}

uint64_t re::Packet::offsetBy(uint64_t this, uint64_t a2)
{
  unsigned int v2;
  BOOL v3;
  int v4;
  uint64_t v5;

  v2 = *(_DWORD *)(this + 28);
  v3 = v2 >= a2;
  v4 = v2 - a2;
  if (v3)
    goto LABEL_5;
  if ((a2 & 0x80000000) == 0 || (v5 = *(_QWORD *)(this + 16), v5 - *(_QWORD *)(this + 8) < -(int)a2))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "capacity() >= offset || (offset < 0 && -offset <= (static_cast<uint8_t*>(m_data) - static_cast<uint8_t*>(m_buffer)))", "offsetBy", 117);
    this = _os_crash();
    __break(1u);
LABEL_5:
    v5 = *(_QWORD *)(this + 16);
  }
  *(_QWORD *)(this + 16) = v5 + (int)a2;
  *(_DWORD *)(this + 24) -= a2;
  *(_DWORD *)(this + 28) = v4;
  return this;
}

char *`non-virtual thunk to're::UnreliableAckedUnicastStream::createPacket(re::UnreliableAckedUnicastStream *this, int a2)
{
  return re::UnreliableAckedUnicastStream::createPacket((re::UnreliableAckedUnicastStream *)((char *)this - 24), a2);
}

void re::UnreliableAckedUnicastStream::destroyPacket(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

void `non-virtual thunk to're::UnreliableAckedUnicastStream::destroyPacket(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

uint64_t re::UnreliableAckedUnicastStream::send(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  re::Packet::offsetBy((uint64_t)a2, 4294967260);
  re::UnreliableAckedUnicastStream::writeHeader(this, a2);
  re::UnicastStream::send(this, a2);
  ++*((_WORD *)this + 96);
  v4 = *((_QWORD *)this + 4);
  if (v4)
    v5 = v4 - 8;
  else
    v5 = 0;
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 568) + 32))(*(_QWORD *)(v5 + 568));
  *((_QWORD *)this + 25) = result;
  return result;
}

uint64_t re::UnreliableAckedUnicastStream::writeHeader(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  _QWORD v7[2];
  unsigned int v8;
  char v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *((_DWORD *)a2 + 7);
  if (v2 <= 0x23)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "packet.capacity() >= kHeaderSize", "writeHeader", 142);
    _os_crash();
    __break(1u);
    goto LABEL_5;
  }
  v4 = *((_QWORD *)a2 + 2);
  v7[0] = &off_24E072668;
  v7[1] = v4;
  v8 = v2;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)v7, *((unsigned __int16 *)this + 96), 0x10u);
  result = re::AckWindow<256ul>::write((unsigned __int16 *)this + 56, (re::BitWriter *)v7);
  if (v9)
  {
LABEL_5:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "!writer.isOverflow()", "writeHeader", 148);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

unint64_t *re::UnreliableAckedUnicastStream::receive(re::UnreliableAckedUnicastStream *this)
{
  unint64_t **v2;
  unint64_t *v3;
  _OWORD *v4;
  int v5;
  uint64_t i;
  uint64_t v7;
  re *v8;
  NSObject *v9;
  re *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  NSObject *v15;
  uint64_t v16;
  re::Transport *v17;
  _BYTE *v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  re::Transport *v29;
  _BYTE *v30;
  unint64_t v31;
  unint64_t v32;
  __int128 v33;
  uint64_t j;
  uint64_t v35;
  unsigned __int16 v36;
  int v37;
  unsigned int v38;
  unint64_t v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t v46;
  unint64_t v47;
  __int128 v48;
  unint64_t **v50;
  _BYTE *v51;
  __int128 v52;
  _OWORD v53[2];
  unsigned int v54;
  _BYTE v55[12];
  __int16 v56;
  _BYTE v57[10];
  uint64_t v58;
  _BYTE buf[32];
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v2 = (unint64_t **)((char *)this + 64);
  v3 = re::PacketQueue::dequeue((unint64_t **)this + 8);
  if (v3)
  {
    v51 = (char *)this + 120;
    v4 = (_OWORD *)((char *)this + 160);
    v50 = v2;
    do
    {
      *(_OWORD *)&buf[16] = 0u;
      v60 = 0u;
      v5 = *((_DWORD *)v3 + 6);
      *(_QWORD *)v55 = v3[2];
      *(_DWORD *)&v55[8] = v5;
      LOBYTE(v56) = 0;
      *(_QWORD *)&v57[2] = 0;
      v58 = 0;
      v54 = 0;
      re::BitReader::readUInt32Bits((uint64_t *)v55, 0x10u, &v54);
      *(_WORD *)buf = v54;
      v54 = 0;
      re::BitReader::readUInt32Bits((uint64_t *)v55, 0x10u, &v54);
      *(_WORD *)&buf[8] = v54;
      for (i = 16; i != 48; i += 8)
      {
        v54 = 0;
        re::BitReader::readUInt32Bits((uint64_t *)v55, 0x20u, &v54);
        v7 = v54;
        v54 = 0;
        re::BitReader::readUInt32Bits((uint64_t *)v55, 0x20u, &v54);
        *(_QWORD *)&buf[i] = v7 | ((unint64_t)v54 << 32);
      }
      if ((_BYTE)v56)
      {
        v8 = (re *)(*(uint64_t (**)(re::UnreliableAckedUnicastStream *, unint64_t *))(*(_QWORD *)this + 40))(this, v3);
        v9 = *re::networkLogObjects(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "Corrupt packet received. Will drop.", buf, 2u);
        }
        goto LABEL_100;
      }
      v10 = (re *)re::Packet::offsetBy((uint64_t)v3, 36);
      v53[0] = *(_OWORD *)&buf[16];
      v53[1] = v60;
      v52 = *(_OWORD *)buf;
      v11 = *(unsigned __int16 *)buf;
      v12 = *((unsigned __int16 *)this + 56);
      v13 = v12 - *(unsigned __int16 *)buf;
      if (v12 >= *(unsigned __int16 *)buf && v13 < 0x8000
        || v12 < *(unsigned __int16 *)buf && *(unsigned __int16 *)buf - v12 >= 0x8000)
      {
        v14 = v13 >= 0x8000 ? v13 + 0x10000 : v12 - *(unsigned __int16 *)buf;
        if (v14 <= 0xFF)
        {
          v10 = (re *)re::Bitset<256>::toWordIndex((uint64_t)v51, v14);
          if (((*(_QWORD *)&v51[8 * v10] >> v14) & 1) != 0)
          {
            v15 = *re::networkLogObjects(v10);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              v16 = *((_QWORD *)this + 4);
              if (v16)
                v17 = (re::Transport *)(v16 - 8);
              else
                v17 = 0;
              re::Transport::connectionAddress(v17, *((_QWORD *)this + 5), (re::DynamicString *)buf);
              v18 = &buf[9];
              if ((buf[8] & 1) != 0)
                v18 = *(_BYTE **)&buf[16];
              *(_DWORD *)v55 = 134218242;
              *(_QWORD *)&v55[4] = (unsigned __int16)v52;
              v56 = 2082;
              *(_QWORD *)v57 = v18;
              _os_log_impl(&dword_21C69B000, v15, OS_LOG_TYPE_DEFAULT, "Received duplicate packet with seqNo=%zu. Ignoring.(address=%{public}s)", v55, 0x16u);
              if (*(_QWORD *)buf && (buf[8] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)buf + 40))();
            }
LABEL_53:
            (*(void (**)(re::UnreliableAckedUnicastStream *, unint64_t *))(*(_QWORD *)this + 40))(this, v3);
            goto LABEL_100;
          }
          v11 = (unsigned __int16)v52;
          LODWORD(v12) = *((unsigned __int16 *)this + 56);
          v13 = v12 - (unsigned __int16)v52;
        }
      }
      if ((v12 >= v11 && v13 < 0x8000 || v12 < v11 && v11 - v12 >= 0x8000)
        && ((_DWORD)v12 != v11 || (*v51 & 1) != 0))
      {
        v26 = *re::networkLogObjects(v10);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          v27 = *((unsigned __int16 *)this + 56);
          v28 = *((_QWORD *)this + 4);
          if (v28)
            v29 = (re::Transport *)(v28 - 8);
          else
            v29 = 0;
          re::Transport::connectionAddress(v29, *((_QWORD *)this + 5), (re::DynamicString *)v55);
          v30 = &v55[9];
          if ((v55[8] & 1) != 0)
            v30 = *(_BYTE **)&v57[2];
          *(_DWORD *)buf = 134218754;
          *(_QWORD *)&buf[4] = (unsigned __int16)v52;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v27 - 256;
          *(_WORD *)&buf[22] = 2048;
          *(_QWORD *)&buf[24] = v27;
          LOWORD(v60) = 2082;
          *(_QWORD *)((char *)&v60 + 2) = v30;
          _os_log_impl(&dword_21C69B000, v26, OS_LOG_TYPE_INFO, "Received out of order packet with seqNo=%zu. Ignoring.Current window=[%zu, %zu].(address=%{public}s)", buf, 0x2Au);
          if (*(_QWORD *)v55 && (v55[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)v55 + 40))();
          v2 = v50;
        }
        goto LABEL_53;
      }
      v19 = *((unsigned __int16 *)this + 76);
      v20 = WORD4(v52);
      if ((v53[0] & 1) != 0)
      {
        v21 = v19 - WORD4(v52);
        if (v19 >= WORD4(v52) && v21 < 0x8000 || (v22 = WORD4(v52) - v19, v19 < WORD4(v52)) && v22 >= 0x8000)
        {
          if (v21 >= 0x8000)
            v23 = v21 + 0x10000;
          else
            v23 = (int)v21;
          if (v23 < 0x100)
          {
            v24 = 1 << v23;
            v25 = (_QWORD *)v4 + re::Bitset<256>::toWordIndex((uint64_t)this + 160, v23);
LABEL_63:
            *v25 |= v24;
            v19 = *((unsigned __int16 *)this + 76);
            v20 = WORD4(v52);
            goto LABEL_64;
          }
          v22 = WORD4(v52) - v19;
        }
        if (v19 <= WORD4(v52) && v22 < 0x8000 || v19 > WORD4(v52) && v21 >= 0x8000)
        {
          v31 = WORD4(v52) + (v19 ^ 0xFFFF) + 1;
          if (v22 >= 0x8000)
            v32 = v31;
          else
            v32 = (int)v22;
          *((_WORD *)this + 76) = WORD4(v52);
          re::Bitset<256>::operator<<(buf, (uint64_t)this + 160, v32);
          v33 = *(_OWORD *)&buf[16];
          *v4 = *(_OWORD *)buf;
          *((_OWORD *)this + 11) = v33;
          v25 = (_QWORD *)((char *)this + 160);
          v24 = 1;
          goto LABEL_63;
        }
      }
LABEL_64:
      if (v19 != v20)
      {
        v35 = 0;
        while (1)
        {
          v36 = WORD4(v52) - v35;
          v37 = (unsigned __int16)(WORD4(v52) - v35);
          v38 = WORD4(v52) - v37;
          if ((WORD4(v52) < (unsigned __int16)v35 || v38 >= 0x8000)
            && (WORD4(v52) >= (unsigned __int16)v35 || v37 - WORD4(v52) < 0x8000))
          {
            goto LABEL_97;
          }
          v39 = v38 >= 0x8000 ? v38 + 0x10000 : (int)v38;
          if (v39 > 0xFF
            || ((*((_QWORD *)v53 + re::Bitset<256>::toWordIndex((uint64_t)v53, v39)) >> v39) & 1) == 0)
          {
            goto LABEL_97;
          }
          v40 = *((unsigned __int16 *)this + 76);
          v41 = v40 - v37;
          if (v40 >= v36 && v41 < 0x8000 || (v42 = v37 - v40, v40 < v36) && v42 >= 0x8000)
          {
            if (v41 >= 0x8000)
              v43 = v41 + 0x10000;
            else
              v43 = (int)v41;
            if (v43 < 0x100)
            {
              v44 = 1 << v43;
              v45 = (_QWORD *)v4 + re::Bitset<256>::toWordIndex((uint64_t)this + 160, v43);
              goto LABEL_96;
            }
            v42 = v37 - v40;
          }
          if ((v40 > v36 || v42 >= 0x8000) && (v40 <= v36 || v41 < 0x8000))
            goto LABEL_97;
          v46 = v37 + (v40 ^ 0xFFFF) + 1;
          if (v42 >= 0x8000)
            v47 = v46;
          else
            v47 = (int)v42;
          *((_WORD *)this + 76) = v36;
          re::Bitset<256>::operator<<(buf, (uint64_t)this + 160, v47);
          v48 = *(_OWORD *)&buf[16];
          *v4 = *(_OWORD *)buf;
          *((_OWORD *)this + 11) = v48;
          v45 = (_QWORD *)((char *)this + 160);
          v44 = 1;
LABEL_96:
          *v45 |= v44;
LABEL_97:
          if (++v35 == 256)
            goto LABEL_98;
        }
      }
      for (j = 0; j != 2; ++j)
        v4[j] = vorrq_s8((int8x16_t)v4[j], (int8x16_t)v53[j]);
LABEL_98:
      if (*((_DWORD *)v3 + 6))
        return v3;
      (*(void (**)(re::UnreliableAckedUnicastStream *, unint64_t *))(*(_QWORD *)this + 40))(this, v3);
      v2 = v50;
LABEL_100:
      v3 = re::PacketQueue::dequeue(v2);
    }
    while (v3);
  }
  return v3;
}

uint64_t re::UnreliableAckedUnicastStream::ack(uint64_t this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  __int128 v12;
  _OWORD v13[2];

  v2 = this;
  v3 = *(unsigned __int16 *)(this + 112);
  v4 = v3 - a2;
  if (v3 >= a2 && v4 < 0x8000 || (v5 = a2 - v3, v3 < a2) && v5 >= 0x8000)
  {
    v6 = v4 + 0x10000;
    if (v4 < 0x8000)
      v6 = v3 - a2;
    if (v6 < 0x100)
    {
      v7 = this + 120;
      v8 = 1 << v6;
      this = re::Bitset<256>::toWordIndex(this + 120, v6);
      v9 = (_QWORD *)(v7 + 8 * this);
LABEL_18:
      *v9 |= v8;
      return this;
    }
    v5 = a2 - v3;
  }
  if (v3 <= a2 && v5 < 0x8000 || v3 > a2 && v4 >= 0x8000)
  {
    v10 = a2 + (v3 ^ 0xFFFF) + 1;
    if (v5 >= 0x8000)
      v11 = v10;
    else
      v11 = (int)v5;
    *(_WORD *)(this + 112) = a2;
    v9 = (_QWORD *)(this + 120);
    this = (uint64_t)re::Bitset<256>::operator<<(v13, this + 120, v11);
    v12 = v13[1];
    *(_OWORD *)(v2 + 120) = v13[0];
    *(_OWORD *)(v2 + 136) = v12;
    v8 = 1;
    goto LABEL_18;
  }
  return this;
}

char *re::UnreliableAckedUnicastStream::update(re::UnreliableAckedUnicastStream *this)
{
  uint64_t v2;
  uint64_t v3;
  char *result;
  char *v5;
  uint64_t v6;
  re::PacketPool **v7;
  char *v8;

  v2 = *((_QWORD *)this + 4);
  if (v2)
    v3 = v2 - 8;
  else
    v3 = 0;
  result = (char *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 568) + 32))(*(_QWORD *)(v3 + 568));
  if ((unint64_t)&result[-*((_QWORD *)this + 25)] >= 0xA)
  {
    v5 = result;
    v6 = *((_QWORD *)this + 4);
    if (v6)
      v7 = (re::PacketPool **)(v6 - 8);
    else
      v7 = 0;
    result = re::Transport::createMultiplexedPacket(v7, *((_QWORD *)this + 6), 36);
    if (result)
    {
      v8 = result;
      re::UnreliableAckedUnicastStream::writeHeader(this, (re::Packet *)result);
      *((_DWORD *)v8 + 6) = 36;
      result = (char *)re::UnicastStream::send(this, (re::Packet *)v8);
      ++*((_WORD *)this + 96);
      *((_QWORD *)this + 25) = v5;
    }
  }
  return result;
}

BOOL re::AckWindow<256ul>::write(unsigned __int16 *a1, re::BitWriter *this)
{
  unsigned __int16 *v3;
  uint64_t i;
  unsigned int v5;

  v3 = a1 + 4;
  re::BitWriter::writeUInt32Bits((uint64_t)this, *a1, 0x10u);
  for (i = 0; i != 16; i += 4)
  {
    v5 = *(_DWORD *)&v3[i + 2];
    re::BitWriter::writeUInt32Bits((uint64_t)this, *(_DWORD *)&v3[i], 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v5, 0x20u);
  }
  return *((_BYTE *)this + 20) == 0;
}

void re::UnreliableAckedUnicastStream::~UnreliableAckedUnicastStream(re::UnreliableAckedUnicastStream *this)
{
  re::UnicastStream::~UnicastStream(this);
  JUMPOUT(0x220780CD0);
}

void `non-virtual thunk to're::UnreliableAckedUnicastStream::~UnreliableAckedUnicastStream(re::UnreliableAckedUnicastStream *this)
{
  re::UnicastStream::~UnicastStream((re::UnreliableAckedUnicastStream *)((char *)this - 24));
}

{
  re::UnicastStream::~UnicastStream((re::UnreliableAckedUnicastStream *)((char *)this - 24));
  JUMPOUT(0x220780CD0);
}

uint64_t re::Bitset<256>::toWordIndex(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  if (a2 < 0x100)
    return a2 >> 6;
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %d.", "b < kBitCount", "toWordIndex", 345, a2, 256, v2, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

_OWORD *re::Bitset<256>::operator<<(_OWORD *result, uint64_t a2, unint64_t a3)
{
  char v3;
  unint64_t *v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  *result = 0u;
  result[1] = 0u;
  if (a3 <= 0xFF)
  {
    v3 = a3;
    v4 = (unint64_t *)a2;
    v5 = result;
    result = (_OWORD *)re::Bitset<256>::toWordIndex(a2, a3);
    if (result <= 3)
    {
      v6 = 0;
      v7 = (4 - (_DWORD)result);
      v8 = (uint64_t *)v5 + result;
      do
      {
        v10 = *v4++;
        v9 = v10;
        v11 = v10 >> (64 - (v3 & 0x3Fu));
        if ((v3 & 0x3F) == 0)
          v11 = 0;
        *v8++ = (v9 << (v3 & 0x3F)) | v6;
        v6 = v11 & ~(-1 << v3);
        --v7;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t re::LeaderElectionNone::setSession(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

uint64_t re::LeaderElectionNone::setup(re::LeaderElectionNone *this, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(re::LeaderElectionNone *))(*(_QWORD *)this + 72))(this);
  if ((_DWORD)result)
    *(_QWORD *)(*((_QWORD *)this + 4) + 3136) = a2;
  return result;
}

uint64_t re::LeaderElectionNone::processCapabilities(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 32);
  if (*(_BYTE *)(v1 + 2184))
    *(_DWORD *)(v1 + 3280) |= 1u;
  return this;
}

uint64_t re::LeaderElectionNone::handleMigration(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 3280) |= 1u;
  return a2;
}

uint64_t re::LeaderElectionNone::removePeer(uint64_t this, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 32);
  if (*(_QWORD *)(v2 + 3136) == a2)
    *(_DWORD *)(v2 + 3032) = 12;
  return this;
}

uint64_t re::LeaderElectionNone::isLeader(re::LeaderElectionNone *this)
{
  return *(_DWORD *)(*((_QWORD *)this + 4) + 3280) & 1;
}

uint64_t re::LeaderElectionNone::processPeerHelloSetLeader(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(this + 32) + 3136) = a2;
  return this;
}

void re::LeaderElectionNone::~LeaderElectionNone(re::LeaderElectionNone *this)
{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t re::LeaderElection::receiveMsg()
{
  return 0;
}

uint64_t re::SyncObjectManager::SyncObjectManager(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  int v9;
  __int128 v10;
  __int128 v11;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_QWORD *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_DWORD *)(a1 + 352) = 0;
  *(_QWORD *)a1 = &off_24E070AA0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 384) = 30;
  *(_QWORD *)(a1 + 392) = 0xFFFFFFFF00010000;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_BYTE *)(a1 + 400) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_BYTE *)(a1 + 440) = 1;
  *(_DWORD *)(a1 + 444) = 500;
  *(_BYTE *)(a1 + 448) = 1;
  *(_BYTE *)(a1 + 456) = 0;
  *(_QWORD *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 504) = 0;
  *(_DWORD *)(a1 + 544) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_QWORD *)(a1 + 548) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 560) = 0;
  *(_QWORD *)(a1 + 584) = 0;
  *(_DWORD *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_QWORD *)(a1 + 608) = 0;
  *(_QWORD *)(a1 + 600) = 0;
  *(_DWORD *)(a1 + 616) = 2;
  *(_QWORD *)(a1 + 656) = 0;
  *(_OWORD *)(a1 + 620) = 0u;
  *(_OWORD *)(a1 + 636) = 0u;
  v4 = *((_QWORD *)a2 + 4);
  v5 = *(_DWORD *)(v4 + 2832);
  v6 = *((_DWORD *)a2 + 5);
  if (v6 >= v5)
    v6 = *(_DWORD *)(v4 + 2832);
  if (v5 >= *((_DWORD *)a2 + 4))
    v7 = v6;
  else
    v7 = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 504) = v7;
  *(_DWORD *)(a1 + 560) = *(_DWORD *)(v4 + 2232);
  v8 = *((unsigned __int8 *)a2 + 64);
  *(_DWORD *)(a1 + 616) = 2 * (*((_BYTE *)a2 + 64) == 0);
  if (v8)
    v9 = 2 * *(unsigned __int8 *)(v4 + 2219);
  else
    v9 = 0;
  *(_DWORD *)(a1 + 620) = v9;
  v10 = *a2;
  *(_OWORD *)(a1 + 385) = *(__int128 *)((char *)a2 + 9);
  *(_OWORD *)(a1 + 376) = v10;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 408), *((_QWORD *)a2 + 4));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 416), *((_QWORD *)a2 + 5));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 424), *((_QWORD *)a2 + 6));
  v11 = *(__int128 *)((char *)a2 + 56);
  *(_BYTE *)(a1 + 448) = *((_BYTE *)a2 + 72);
  *(_OWORD *)(a1 + 432) = v11;
  return a1;
}

void re::SyncObjectManager::~SyncObjectManager(re::SyncObjectManager *this)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  re::SyncObjectManager **v14;
  __int128 v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  __int128 v19;
  unint64_t v20;
  re::SyncObjectManager **v21;
  __int128 v22;
  unint64_t v23;
  re::SyncObjectManager **v24;
  __int128 v25;
  const void *v26;
  __n128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  re::SyncObjectManager *v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24E070AA0;
  if (!*((_BYTE *)this + 456))
    goto LABEL_49;
  *((_BYTE *)this + 456) = 0;
  v2 = *((_QWORD *)this + 53);
  if (v2)
  {
    v39 = this;
    *(_QWORD *)&v40 = re::SyncObjectManager::onViewAdded;
    *((_QWORD *)&v40 + 1) = 0;
    *(_QWORD *)&v41 = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::SyncViewManager,re::SyncView *>::removeSubscription(v2 + 24, (__int128 *)&v39);
  }
  v3 = (_BYTE *)*((_QWORD *)this + 51);
  if (!v3[2272])
    goto LABEL_49;
  v4 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v3 + 40))(v3);
  if (v5)
  {
    v6 = (uint64_t *)v4;
    v7 = 8 * v5;
    do
    {
      v8 = *v6;
      if (*v6)
      {
        v9 = (id)(v8 + 8);
        v38 = v8;
        v10 = (id)(v8 + 8);
        re::SyncObjectManager::removePeerStateForParticipant((uint64_t)this, (uint64_t)&v38);

        v38 = 0;
      }
      else
      {
        v38 = 0;
        re::SyncObjectManager::removePeerStateForParticipant((uint64_t)this, (uint64_t)&v38);
      }
      ++v6;
      v7 -= 8;
    }
    while (v7);
  }
  v11 = *((_QWORD *)this + 51);
  v12 = *(_QWORD *)(v11 + 7520);
  if (v12 && *(_QWORD *)(v12 + 240))
  {
    v13 = 0;
    while (1)
    {
      v14 = (re::SyncObjectManager **)(*(_QWORD *)(v12 + 256) + 32 * v13);
      if (*v14 == this)
      {
        if (!*(_DWORD *)(v12 + 304))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v12 + 224), v13);
          goto LABEL_18;
        }
        LOBYTE(v39) = 0;
        v15 = *((_OWORD *)v14 + 1);
        v40 = *(_OWORD *)v14;
        v41 = v15;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v12 + 264), (uint64_t)&v39);
      }
      ++v13;
LABEL_18:
      if (v13 >= *(_QWORD *)(v12 + 240))
      {
        v11 = *((_QWORD *)this + 51);
        break;
      }
    }
  }
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v11 + 2056, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((_QWORD *)this + 51) + 1968, (uint64_t)this);
  v16 = *((_QWORD *)this + 51);
  if (!*(_QWORD *)(v16 + 400))
    goto LABEL_30;
  v17 = 0;
  do
  {
    v18 = *(_QWORD *)(v16 + 416) + 32 * v17;
    if (*(re::SyncObjectManager **)v18 != this)
      goto LABEL_26;
    if (*(_DWORD *)(v16 + 464))
    {
      LOBYTE(v39) = 0;
      v19 = *(_OWORD *)(v18 + 16);
      v40 = *(_OWORD *)v18;
      v41 = v19;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v16 + 424), (uint64_t)&v39);
LABEL_26:
      ++v17;
      continue;
    }
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v16 + 384), v17);
  }
  while (v17 < *(_QWORD *)(v16 + 400));
  v16 = *((_QWORD *)this + 51);
LABEL_30:
  if (!*(_QWORD *)(v16 + 312))
    goto LABEL_39;
  v20 = 0;
  while (2)
  {
    v21 = (re::SyncObjectManager **)(*(_QWORD *)(v16 + 328) + 32 * v20);
    if (*v21 == this)
    {
      if (*(_DWORD *)(v16 + 376))
      {
        LOBYTE(v39) = 0;
        v22 = *((_OWORD *)v21 + 1);
        v40 = *(_OWORD *)v21;
        v41 = v22;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v16 + 336), (uint64_t)&v39);
        goto LABEL_35;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v16 + 296), v20);
    }
    else
    {
LABEL_35:
      ++v20;
    }
    if (v20 < *(_QWORD *)(v16 + 312))
      continue;
    break;
  }
  v16 = *((_QWORD *)this + 51);
LABEL_39:
  if (!*(_QWORD *)(v16 + 224))
    goto LABEL_48;
  v23 = 0;
  while (2)
  {
    v24 = (re::SyncObjectManager **)(*(_QWORD *)(v16 + 240) + 32 * v23);
    if (*v24 == this)
    {
      if (*(_DWORD *)(v16 + 288))
      {
        LOBYTE(v39) = 0;
        v25 = *((_OWORD *)v24 + 1);
        v40 = *(_OWORD *)v24;
        v41 = v25;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v16 + 248), (uint64_t)&v39);
        goto LABEL_44;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v16 + 208), v23);
    }
    else
    {
LABEL_44:
      ++v23;
    }
    if (v23 < *(_QWORD *)(v16 + 224))
      continue;
    break;
  }
  v16 = *((_QWORD *)this + 51);
LABEL_48:
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v16 + 120, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((_QWORD *)this + 51) + 32, (uint64_t)this);
LABEL_49:
  v26 = (const void *)*((_QWORD *)this + 76);
  if (v26)
  {
    _Block_release(v26);
    *((_QWORD *)this + 76) = 0;
  }
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 624);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 568);
  v27.n128_f64[0] = re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 64);
  v28 = *((_QWORD *)this + 58);
  if (v28)
  {
    v29 = *((_QWORD *)this + 62);
    if (v29)
    {
      v30 = *((_QWORD *)this + 60);
      if (v30)
      {
        v31 = v30 << 6;
        v32 = v29 + 16;
        do
        {
          re::DynamicArray<re::SyncOwnershipRequest>::deinit(v32);
          v33 = *(_QWORD *)(v32 - 8);
          if (v33)
          {

            *(_QWORD *)(v32 - 8) = 0;
          }
          v34 = *(_QWORD *)(v32 - 16);
          if (v34)
          {

            *(_QWORD *)(v32 - 16) = 0;
          }
          v32 += 64;
          v31 -= 64;
        }
        while (v31);
        v28 = *((_QWORD *)this + 58);
        v29 = *((_QWORD *)this + 62);
      }
      (*(void (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v28 + 40))(v28, v29, v27);
    }
    *((_QWORD *)this + 62) = 0;
    *((_QWORD *)this + 59) = 0;
    *((_QWORD *)this + 60) = 0;
    *((_QWORD *)this + 58) = 0;
    ++*((_DWORD *)this + 122);
  }
  v35 = *((_QWORD *)this + 53);
  if (v35)
  {

    *((_QWORD *)this + 53) = 0;
  }
  v36 = *((_QWORD *)this + 52);
  if (v36)
  {

    *((_QWORD *)this + 52) = 0;
  }
  v37 = *((_QWORD *)this + 51);
  if (v37)
  {

    *((_QWORD *)this + 51) = 0;
  }
  re::SyncSession::~SyncSession(this);
}

{
  re::SyncObjectManager::~SyncObjectManager(this);
  JUMPOUT(0x220780CD0);
}

void re::SyncSession::~SyncSession(re::SyncSession *this)
{
  uint64_t *v2;

  *(_QWORD *)this = off_24E070D00;
  v2 = (uint64_t *)((char *)this + 24);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 36);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 25);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 14);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(v2);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

_QWORD *re::SyncObjectManager::startSync(re::SyncObjectManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  id v9;
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  re::SyncObjectManager *v21;
  uint64_t (*v22)(re::SyncObjectManager *, re::Session *);
  uint64_t v23;
  void *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 51) + 40))(*((_QWORD *)this + 51));
  if (v3)
  {
    v4 = (uint64_t *)v2;
    v5 = 8 * v3;
    do
    {
      v6 = *v4;
      if (*v4)
        v7 = (id)(v6 + 8);
      v8 = *(_QWORD *)(v6 + 152);
      if (v8 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8) & 1) == 0)
      {
        v20 = v6;
        v9 = (id)(v6 + 8);
        re::SyncObjectManager::addPeerStateForParticipant((uint64_t)this, &v20);

        v20 = 0;
      }

      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  v10 = (_DWORD *)(*((_QWORD *)this + 51) + 32);
  v21 = this;
  v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onSessionWillDeinit;
  v23 = 0;
  v24 = re::Event<re::Session>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v10, (uint64_t)&v21);
  v11 = (_DWORD *)(*((_QWORD *)this + 51) + 120);
  v21 = this;
  v22 = re::SyncObjectManager::onSessionStarted;
  v23 = 0;
  v24 = re::Event<re::Session>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v11, (uint64_t)&v21);
  v12 = (_DWORD *)(*((_QWORD *)this + 51) + 208);
  v21 = this;
  v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onSessionStopped;
  v23 = 0;
  v24 = re::Event<re::Session,re::SessionError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v12, (uint64_t)&v21);
  v13 = (_DWORD *)(*((_QWORD *)this + 51) + 296);
  v21 = this;
  v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerJoined;
  v23 = 0;
  v24 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v13, (uint64_t)&v21);
  v14 = (_DWORD *)(*((_QWORD *)this + 51) + 384);
  v21 = this;
  v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerLeft;
  v23 = 0;
  v24 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v14, (uint64_t)&v21);
  v15 = (_DWORD *)(*((_QWORD *)this + 51) + 1968);
  v21 = this;
  v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerPaused;
  v23 = 0;
  v24 = re::Event<re::Session,unsigned long long>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v15, (uint64_t)&v21);
  v16 = (_DWORD *)(*((_QWORD *)this + 51) + 2056);
  v21 = this;
  v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerResumed;
  v23 = 0;
  v24 = re::Event<re::Session,unsigned long long>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v16, (uint64_t)&v21);
  v17 = *(_QWORD *)(*((_QWORD *)this + 51) + 7520);
  if (v17)
  {
    v21 = this;
    v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::handleCongestionEvent;
    v23 = 0;
    v24 = re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke;
    re::Event<re::Session>::addSubscription((_DWORD *)(v17 + 224), (uint64_t)&v21);
  }
  v18 = *((_QWORD *)this + 53);
  if (v18)
  {
    v21 = this;
    v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onViewAdded;
    v23 = 0;
    v24 = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::SyncViewManager,re::SyncView *>::addSubscription((_DWORD *)(v18 + 24), (uint64_t)&v21);
  }
  *((_BYTE *)this + 456) = 1;
  return re::SyncObjectManager::reevaluateAllViewers(this);
}

_QWORD *re::SyncObjectManager::reevaluateAllViewers(re::SyncObjectManager *this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *result;
  _QWORD v5[3];
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 53);
  v3 = re::globalAllocators(this)[2];
  v5[0] = &off_24E070B78;
  v5[1] = this;
  v6 = v3;
  v7 = v5;
  re::SyncViewManager::forEachView(v2, (uint64_t)v5);
  result = v7;
  if (v7)
  {
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *))*v7)(v7);
    if (v7 != v5)
      return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  }
  return result;
}

uint64_t re::SyncObjectManager::sendRate(re::SyncObjectManager *this)
{
  return *((_QWORD *)this + 47);
}

_QWORD *re::SyncObjectManager::setViewFilter(uint64_t a1, void *aBlock)
{
  const void *v4;
  _QWORD *result;

  v4 = *(const void **)(a1 + 608);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 608) = result;
  if (*(_BYTE *)(a1 + 456))
    return re::SyncObjectManager::reevaluateAllViewers((re::SyncObjectManager *)a1);
  return result;
}

uint64_t re::SyncObjectManager::viewFilter(re::SyncObjectManager *this)
{
  return *((_QWORD *)this + 76);
}

void re::SyncObjectManager::addPeerStateForParticipant(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  _BOOL8 v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  re *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  _BOOL8 v24;
  uint64_t v25;
  NSObject *v26;
  _BOOL4 v27;
  uint64_t v28;
  re *v29;
  uint64_t v30;
  int v31;
  uint64_t *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  re *v36;
  uint64_t v37;
  int v38;
  uint64_t *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  id v55;
  uint64_t v56;
  id v57;
  re *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  id v65;
  id location;
  _BYTE buf[32];
  __int128 v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char v72[24];
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects((re *)a1);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    v6 = *(_QWORD *)(*a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v6;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Adding new peer state. PeerID=%llu.", buf, 0xCu);
  }
  v70 = 0;
  v7 = *(_QWORD *)(a1 + 472);
  v8 = *(_QWORD *)(a1 + 480);
  if (v8 >= v7)
  {
    v9 = v8 + 1;
    if (v7 < v8 + 1)
    {
      if (*(_QWORD *)(a1 + 464))
      {
        v10 = 2 * v7;
        v11 = v7 == 0;
        v12 = 8;
        if (!v11)
          v12 = v10;
        if (v12 <= v9)
          v13 = v9;
        else
          v13 = v12;
        re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity((_QWORD *)(a1 + 464), v13);
      }
      else
      {
        re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity((_QWORD *)(a1 + 464), v9);
        ++*(_DWORD *)(a1 + 488);
      }
    }
    v8 = *(_QWORD *)(a1 + 480);
  }
  v14 = *(_QWORD *)(a1 + 496) + (v8 << 6);
  *(_OWORD *)v14 = 0u;
  *(_OWORD *)buf = 0u;
  *(_DWORD *)(v14 + 40) = 0;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_QWORD *)(v14 + 16) = 0;
  *(_OWORD *)&buf[16] = 0u;
  *(_QWORD *)&v68 = 0;
  v69 = 0;
  DWORD2(v68) = 1;
  *(_DWORD *)(v14 + 40) = 1;
  *(_OWORD *)(v14 + 48) = 0u;
  ++*(_QWORD *)(a1 + 480);
  ++*(_DWORD *)(a1 + 488);
  re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)&buf[16]);
  if (*(_QWORD *)&buf[8])

  if (*(_QWORD *)buf)
  v15 = *(_QWORD *)(a1 + 496);
  v16 = *(_QWORD *)(a1 + 480) - 1;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v15 + (v16 << 6)), *a2);
  v18 = *(_QWORD *)(*a2 + 24);
  v19 = *(_QWORD *)(a1 + 480);
  if (v19)
  {
    v20 = *(unsigned __int8 *)(a1 + 440);
    v21 = *(_QWORD *)(a1 + 496);
    v22 = v19 << 6;
    while (*(_QWORD *)(*(_QWORD *)v21 + 24) != v18)
    {
      v21 += 64;
      v22 -= 64;
      if (!v22)
        goto LABEL_22;
    }
    v26 = *re::networkLogObjects(v17);
    v27 = os_log_type_enabled(v26, OS_LOG_TYPE_INFO);
    if (v20)
    {
      if (v27)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_21C69B000, v26, OS_LOG_TYPE_INFO, "UNICAST reliable", buf, 2u);
      }
      v28 = *(_QWORD *)(a1 + 408);
      v61 = *(_QWORD *)(*(_QWORD *)v21 + 24);
      v63 = *(_QWORD *)(*(_QWORD *)v21 + 32);
      v29 = (re *)re::Session::peerID((re::Session *)v28);
      v30 = *(_QWORD *)(a1 + 416);
      v31 = (*(_DWORD *)(*(_QWORD *)v21 + 72) >> 1) & 1;
      v32 = re::globalAllocators(v29);
      v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v32[2] + 32))(v32[2], 152, 8);
      if (a1)
        v33 = (void *)(a1 + 8);
      else
        v33 = 0;
      objc_initWeak((id *)buf, v33);
      objc_initWeak(&location, (id)(v28 + 2328));
      if (v30)
        v34 = (void *)(v30 + 8);
      else
        v34 = 0;
      objc_initWeak(&v65, v34);
      re::SyncReliableOrderedUnicast::SyncReliableOrderedUnicast(v25, (id *)buf, (re *)&location, v63, v61, (uint64_t)v29, &v65, *(_BYTE *)(a1 + 400), v31, *(_BYTE *)(a1 + 448));
    }
    else
    {
      if (v27)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_21C69B000, v26, OS_LOG_TYPE_INFO, "UNICAST selective acked", buf, 2u);
      }
      v35 = *(_QWORD *)(a1 + 408);
      v62 = *(_QWORD *)(*(_QWORD *)v21 + 24);
      v64 = *(_QWORD *)(*(_QWORD *)v21 + 32);
      v36 = (re *)re::Session::peerID((re::Session *)v35);
      v37 = *(_QWORD *)(a1 + 416);
      v38 = (*(_DWORD *)(*(_QWORD *)v21 + 72) >> 1) & 1;
      v39 = re::globalAllocators(v36);
      v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v39[2] + 32))(v39[2], 288, 8);
      if (a1)
        v40 = (void *)(a1 + 8);
      else
        v40 = 0;
      objc_initWeak((id *)buf, v40);
      objc_initWeak(&location, (id)(v35 + 2328));
      if (v37)
        v41 = (void *)(v37 + 8);
      else
        v41 = 0;
      objc_initWeak(&v65, v41);
      re::SyncSelectiveAckedUnicast::SyncSelectiveAckedUnicast(v25, (id *)buf, &location, v64, v62, (uint64_t)v36, &v65, *(_BYTE *)(a1 + 400), v38, *(_BYTE *)(a1 + 448), *(_DWORD *)(a1 + 444));
    }
    objc_destroyWeak(&v65);
    v65 = 0;
    objc_destroyWeak(&location);
    location = 0;
    objc_destroyWeak((id *)buf);
  }
  else
  {
LABEL_22:
    v23 = *re::networkLogObjects(v17);
    v24 = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    if (v24)
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v18;
      _os_log_error_impl(&dword_21C69B000, v23, OS_LOG_TYPE_ERROR, "Invalid peerID %llu", buf, 0xCu);
    }
    v25 = 0;
  }
  v42 = v15 + (v16 << 6);
  v45 = *(_QWORD *)(v42 + 8);
  v44 = (uint64_t *)(v42 + 8);
  v43 = v45;
  *v44 = v25;
  if (v45)

  v46 = *(_QWORD *)(*a2 + 24);
  v47 = re::globalAllocators((re *)v24);
  v48 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v47[2] + 32))(v47[2], 112, 8);
  v49 = v48;
  *(_DWORD *)(v48 + 32) = 0;
  *(_QWORD *)(v48 + 16) = 0;
  *(_QWORD *)(v48 + 24) = 0;
  *(_QWORD *)(v48 + 40) = 0;
  *(_QWORD *)(v48 + 48) = a1;
  *(_QWORD *)v48 = &off_24E072818;
  *(_QWORD *)(v48 + 8) = 0;
  *(_OWORD *)(v48 + 64) = 0u;
  *(_OWORD *)(v48 + 80) = 0u;
  *(_DWORD *)(v48 + 96) = 0;
  *(_QWORD *)(v48 + 100) = 0x7FFFFFFFLL;
  *(_QWORD *)(v48 + 56) = v46;
  v50 = *(_QWORD *)(a1 + 424);
  if (v50)
  {
    *(_QWORD *)buf = v48;
    re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addNew(v50 + 160, (uint64_t *)buf);
    v51 = *(_QWORD *)(a1 + 424);
    v52 = v15 + (v16 << 6);
    *(_QWORD *)(v52 + 56) = v49;
    v53 = (uint64_t *)(v52 + 56);
    if (v51 && *(_QWORD *)(a1 + 608))
    {
      *(_QWORD *)buf = a1;
      v54 = *(_QWORD *)(v15 + (v16 << 6));
      *(_QWORD *)&buf[8] = v54;
      if (v54)
        v55 = (id)(v54 + 8);
      v56 = *v44;
      *(_QWORD *)&buf[16] = v56;
      if (v56)
        v57 = (id)(v56 + 8);
      v58 = (re *)re::DynamicArray<re::SyncOwnershipRequest>::DynamicArray((uint64_t)&buf[24], (uint64_t *)(v15 + (v16 << 6) + 16));
      v71 = *v53;
      v59 = re::globalAllocators(v58)[2];
      v73 = v59;
      v60 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v59 + 32))(v59, 80, 0);
      *(_QWORD *)v60 = &off_24E070C28;
      *(_OWORD *)(v60 + 8) = *(_OWORD *)buf;
      *(_QWORD *)(v60 + 24) = *(_QWORD *)&buf[16];
      *(_OWORD *)&buf[8] = 0u;
      *(_DWORD *)(v60 + 56) = 0;
      *(_QWORD *)(v60 + 32) = *(_QWORD *)&buf[24];
      *(_QWORD *)&buf[24] = 0;
      *(_QWORD *)(v60 + 40) = v68;
      *(_QWORD *)(v60 + 48) = 0;
      *(_QWORD *)(v60 + 48) = *((_QWORD *)&v68 + 1);
      v68 = 0u;
      *(_QWORD *)(v60 + 64) = v70;
      v70 = 0;
      LODWORD(v69) = v69 + 1;
      *(_DWORD *)(v60 + 56) = 1;
      *(_QWORD *)(v60 + 72) = v71;
      v74 = v60;
      re::SyncViewManager::forEachView(v51, (uint64_t)v72);
      (**(void (***)(uint64_t))v60)(v60);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v59 + 40))(v59, v60);
      re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)&buf[24]);
      if (*(_QWORD *)&buf[16])
      {

        *(_QWORD *)&buf[16] = 0;
      }
      if (*(_QWORD *)&buf[8])

    }
  }
  else
  {
    *(_QWORD *)(v15 + (v16 << 6) + 56) = v48;
  }
}

uint64_t re::SyncObjectManager::onSessionWillDeinit(re::NetworkSyncManager **this, re::Session *a2)
{
  re::NetworkSyncManager::removeSession(this[54], this[51]);
  return 0;
}

uint64_t re::SyncObjectManager::onSessionStarted(re::SyncObjectManager *this, re::Session *a2)
{
  NSObject *v3;
  int v5;
  re::Session *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 134217984;
    v6 = a2;
    _os_log_impl(&dword_21C69B000, v3, OS_LOG_TYPE_DEFAULT, "SyncObjectManager: session started (%p).", (uint8_t *)&v5, 0xCu);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onSessionStopped(re *a1, uint64_t a2, int a3)
{
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134218240;
    v8 = a2;
    v9 = 1024;
    v10 = a3;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "SyncObjectManager: session stopped (%p) with error: %d.", (uint8_t *)&v7, 0x12u);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onPeerJoined(re *a1, uint64_t a2, uint64_t *a3)
{
  NSObject *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  id v13;
  uint64_t v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (_QWORD *)*a3;
    if ((*(_BYTE *)(*a3 + 48) & 1) != 0)
      v7 = (char *)v6[7];
    else
      v7 = (char *)v6 + 49;
    v8 = v6[3];
    v9 = v6[19];
    if (v9)
      v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(v9);
    else
      v10 = "nullptr";
    *(_DWORD *)buf = 134218498;
    v17 = v8;
    v18 = 2080;
    v19 = v7;
    v20 = 2080;
    v21 = v10;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "New peer joined object syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  v11 = *a3;
  v15 = v11;
  if (v11)
  {
    v12 = (void *)(v11 + 8);
    v13 = (id)(v11 + 8);
    re::SyncObjectManager::addPeerStateForParticipant((uint64_t)a1, &v15);

  }
  else
  {
    re::SyncObjectManager::addPeerStateForParticipant((uint64_t)a1, &v15);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onPeerLeft(re *a1, uint64_t a2, uint64_t *a3)
{
  NSObject *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  id v13;
  uint64_t v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (_QWORD *)*a3;
    if ((*(_BYTE *)(*a3 + 48) & 1) != 0)
      v7 = (char *)v6[7];
    else
      v7 = (char *)v6 + 49;
    v8 = v6[3];
    v9 = v6[19];
    if (v9)
      v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(v9);
    else
      v10 = "nullptr";
    *(_DWORD *)buf = 134218498;
    v17 = v8;
    v18 = 2080;
    v19 = v7;
    v20 = 2080;
    v21 = v10;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "Peer left syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  v11 = *a3;
  v15 = v11;
  if (v11)
  {
    v12 = (void *)(v11 + 8);
    v13 = (id)(v11 + 8);
    re::SyncObjectManager::removePeerStateForParticipant((uint64_t)a1, (uint64_t)&v15);

  }
  else
  {
    re::SyncObjectManager::removePeerStateForParticipant((uint64_t)a1, (uint64_t)&v15);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onPeerPaused(re::SyncObjectManager *this, re::Session *a2, uint64_t a3)
{
  NSObject *v5;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134217984;
    v8 = a3;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "Pausing peerID %llu.", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SyncObjectManager *, uint64_t))(*(_QWORD *)this + 120))(this, a3);
  return 0;
}

uint64_t re::SyncObjectManager::onPeerResumed(re::SyncObjectManager *this, re::Session *a2, uint64_t a3)
{
  NSObject *v5;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134217984;
    v8 = a3;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "Resuming peerID %llu", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SyncObjectManager *, uint64_t))(*(_QWORD *)this + 128))(this, a3);
  return 0;
}

uint64_t re::SyncObjectManager::handleCongestionEvent(re *a1)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v3 = 0;
    _os_log_debug_impl(&dword_21C69B000, v1, OS_LOG_TYPE_DEBUG, "Emiting congestion event.", v3, 2u);
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  return 0;
}

void re::SyncObjectManager::removePeerStateForParticipant(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  re::SyncViewer **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  re::SyncObject **v17;
  re::SyncObject **v18;
  re::SyncObject *v19;
  re::SyncObject *v20;
  re::SyncObject *v21;
  re::SyncObject *v22;
  re::SyncObject *v23;
  re::SyncObject *v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  re::SyncObject *v28;
  re::SyncObject *v29;
  re::SyncObject *v30;
  re::SyncObject *v31;
  uint64_t v32;
  re::SyncObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v41;
  int v42;
  uint64_t v43;
  re::SyncObject *v44;
  re::SyncObject *v45;
  re::SyncObject *v46;
  re::SyncObject *v47;
  BOOL v48;
  uint64_t v49;
  char v50;
  NSObject *v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  re *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  NSObject *v63;
  uint64_t v64;
  re::SyncViewer *v65;
  re::SyncViewManager *v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  __int128 *v72;
  __int128 v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  BOOL v77;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  _BYTE v87[38];
  uint8_t buf[32];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(*(_QWORD *)a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v5;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Removing peer state. PeerID=%llu.", buf, 0xCu);
  }
  v6 = *(_QWORD *)(a1 + 480);
  if (v6)
  {
    v7 = *(_QWORD *)(*(_QWORD *)a2 + 24);
    v8 = *(_QWORD *)(a1 + 496);
    v9 = -v8;
    v10 = (re::SyncViewer **)(v8 + 56);
    v11 = v6 << 6;
    while (*((_QWORD *)*(v10 - 7) + 3) != v7)
    {
      v9 -= 64;
      v10 += 8;
      v11 -= 64;
      if (!v11)
        return;
    }
    v85 = v9;
    re::SyncObjectStore::types(*(_QWORD **)(a1 + 416), (uint64_t)buf);
    if (*(_QWORD *)&buf[16])
    {
      v13 = 0;
      v14 = (uint64_t *)v89;
      v86 = (uint64_t *)(v89 + 8 * *(_QWORD *)&buf[16]);
      while (1)
      {
        v15 = *v14;
        if (*(_BYTE *)(*(_QWORD *)(*v14 + 16) + 73))
        {
          v16 = *(_QWORD *)(v15 + 64);
          if (v16)
            break;
        }
LABEL_69:
        if (++v14 == v86)
          goto LABEL_72;
      }
      v17 = *(re::SyncObject ***)(v15 + 80);
      v18 = &v17[v16];
      while (re::SyncObject::fromPeerID(*v17) != v7)
      {
        v19 = *v17;
        v20 = (re::SyncObject *)*((_QWORD *)*v17 + 10);
        if (v20)
        {
          v21 = (re::SyncObject *)*((_QWORD *)*v17 + 10);
          v22 = *v17;
          do
          {
            v23 = v22;
            v22 = v21;
            if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v23 + 11) + 16) + 73))
              break;
            v21 = (re::SyncObject *)*((_QWORD *)v21 + 10);
            v23 = v22;
          }
          while (v21);
          if (*((_QWORD *)v23 + 20) == v7)
            break;
          do
          {
            v24 = v19;
            v19 = v20;
            if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v24 + 11) + 16) + 73))
              break;
            v20 = (re::SyncObject *)*((_QWORD *)v20 + 10);
            v24 = v19;
          }
          while (v20);
        }
        else
        {
          v24 = *v17;
          if (*((_QWORD *)v19 + 20) == v7)
            break;
        }
        v25 = *((_QWORD *)v24 + 17);
        if (v25)
          v26 = v25 == v7;
        else
          v26 = 0;
        if (v26)
          break;
LABEL_68:
        if (++v17 == v18)
          goto LABEL_69;
      }
      v27 = re::Session::peerID(*(re::Session **)(a1 + 408));
      v28 = *v17;
      v29 = (re::SyncObject *)*((_QWORD *)*v17 + 10);
      v30 = *v17;
      if (!v29)
        goto LABEL_33;
      v31 = *v17;
      do
      {
        v30 = v31;
        v31 = v29;
        if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v30 + 11) + 16) + 73))
          break;
        v29 = (re::SyncObject *)*((_QWORD *)v29 + 10);
        v30 = v31;
      }
      while (v29);
      if (v28)
      {
LABEL_33:
        v32 = *((_QWORD *)v30 + 20);
        v33 = *v17;
        while (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v33 + 11) + 16) + 74))
        {
          v33 = (re::SyncObject *)*((_QWORD *)v33 + 10);
          if (!v33)
            goto LABEL_46;
        }
        v34 = *((_QWORD *)v33 + 12);
        if (v34)
        {
          v35 = *(_QWORD *)(v34 + 104);
          if (v35)
          {
            v36 = *(uint64_t **)(v34 + 120);
            v37 = 8 * v35;
            do
            {
              v38 = *v36++;
              v39 = *(_QWORD *)(v38 + 56);
              if (v27 - 1 >= v39 && v39 != v32)
                v27 = v39;
              v37 -= 8;
            }
            while (v37);
          }
        }
      }
LABEL_46:
      v41 = re::SyncObject::latestStateHandle(v28);
      if (v41 == -1)
      {
        v51 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          v52 = *((_QWORD *)*v17 + 3);
          v53 = *(_QWORD **)(*((_QWORD *)*v17 + 11) + 16);
          v54 = v53[4];
          v55 = v53[6];
          v56 = (char *)v53[7];
          v57 = (char *)v53 + 49;
          if ((v55 & 1) != 0)
            v57 = v56;
          *(_DWORD *)v87 = 134218498;
          *(_QWORD *)&v87[4] = v52;
          *(_WORD *)&v87[12] = 2048;
          *(_QWORD *)&v87[14] = v54;
          *(_WORD *)&v87[22] = 2080;
          *(_QWORD *)&v87[24] = v57;
          _os_log_error_impl(&dword_21C69B000, v51, OS_LOG_TYPE_ERROR, "Sync object without snapshot while gathering orphans (id: %llu, type: %llu[%s]).", v87, 0x20u);
        }
        goto LABEL_66;
      }
      v42 = *(unsigned __int8 *)(a1 + 400);
      v43 = re::Session::peerID(*(re::Session **)(a1 + 408));
      v44 = *v17;
      v45 = (re::SyncObject *)*((_QWORD *)*v17 + 10);
      v46 = *v17;
      if (v45)
      {
        v47 = *v17;
        do
        {
          v46 = v47;
          v47 = v45;
          if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v46 + 11) + 16) + 73))
            break;
          v45 = (re::SyncObject *)*((_QWORD *)v45 + 10);
          v46 = v47;
        }
        while (v45);
      }
      if (*((_BYTE *)v46 + 171))
      {
        v48 = v42 != 0;
        if (v43 == v27)
          v49 = 0;
        else
          v49 = v27;
        *((_QWORD *)v44 + 17) = 0;
        *((_QWORD *)v44 + 20) = v49;
        if (v43 == v27)
          v48 = 1;
        *((_BYTE *)v44 + 170) = v48;
        *(_QWORD *)v87 = v44;
        v50 = 4;
      }
      else
      {
        *((_BYTE *)v44 + 128) |= 4u;
        v44 = *v17;
        *(_QWORD *)v87 = v44;
        v50 = 2;
        if (!v44)
          goto LABEL_64;
      }
      v58 = (char *)v44 + 8;
LABEL_64:
      *(_QWORD *)&v87[8] = v41;
      v87[16] = v50;
      re::DynamicArray<re::internal::SyncSnapshotEntry>::add((_QWORD *)(a1 + 624), (uint64_t)v87);
      if (*(_QWORD *)v87)

LABEL_66:
      if (v41 != -1)
        ++v13;
      goto LABEL_68;
    }
    v13 = 0;
LABEL_72:
    v59 = *(re **)buf;
    if (*(_QWORD *)buf)
    {
      v12 = v89;
      if ((_QWORD)v89)
        v59 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
    }
    v60 = *(_QWORD *)(a1 + 640);
    if (v60)
    {
      v61 = *(_QWORD *)(a1 + 656);
      v62 = 24 * v60;
      do
      {
        if ((*(_BYTE *)(*(_QWORD *)v61 + 128) & 4) != 0)
          re::SyncObjectManager::destroyObject(v61);
        v61 += 24;
        v62 -= 24;
      }
      while (v62);
    }
    if (v13)
    {
      v63 = *re::networkLogObjects(v59);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        v64 = re::Session::peerID(*(re::Session **)(a1 + 408));
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v64;
        _os_log_impl(&dword_21C69B000, v63, OS_LOG_TYPE_DEFAULT, "Found %zu orphaned objects. localPeerID=%llu. ", buf, 0x16u);
      }
    }
    v65 = *v10;
    v66 = *(re::SyncViewManager **)(a1 + 424);
    if (v66)
      v66 = (re::SyncViewManager *)re::SyncViewManager::removeViewer(v66, *v10, 0);
    if (v65)
    {
      v67 = re::globalAllocators(v66)[2];
      (**(void (***)(re::SyncViewer *))v65)(v65);
      (*(void (**)(uint64_t, re::SyncViewer *))(*(_QWORD *)v67 + 40))(v67, v65);
    }
    *v10 = 0;
    v68 = *(_QWORD *)(a1 + 496);
    v69 = (-v85 - v68) >> 6;
    v70 = *(_QWORD *)(a1 + 480);
    if (v70 <= v69)
    {
      v90 = 0u;
      v91 = 0u;
      v89 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v87 = 136315906;
      *(_QWORD *)&v87[4] = "removeAt";
      *(_WORD *)&v87[12] = 1024;
      *(_DWORD *)&v87[14] = 931;
      *(_WORD *)&v87[18] = 2048;
      *(_QWORD *)&v87[20] = v69;
      *(_WORD *)&v87[28] = 2048;
      *(_QWORD *)&v87[30] = v70;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_107;
    }
    if (v70 - 1 > v69)
    {
      v71 = v68 + (v70 << 6);
      v72 = (__int128 *)(v68 + (v69 << 6));
      v73 = *v72;
      *v72 = *(_OWORD *)(v71 - 64);
      v74 = (uint64_t *)(v72 + 1);
      *(_OWORD *)(v71 - 64) = v73;
      if (v72 != (__int128 *)(v71 - 64))
      {
        v75 = *v74;
        v76 = *(_QWORD *)(v71 - 48);
        if (*v74)
          v77 = v76 == 0;
        else
          v77 = 1;
        if (!v77 && v75 != v76)
        {
LABEL_107:
          re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
          _os_crash();
          __break(1u);
        }
        *v74 = v76;
        *(_QWORD *)(v71 - 48) = v75;
        v79 = v68 + (v69 << 6);
        v80 = *(_OWORD *)(v79 + 24);
        *(_OWORD *)(v79 + 24) = *(_OWORD *)(v71 - 40);
        *(_OWORD *)(v71 - 40) = v80;
        v81 = *(_QWORD *)(v79 + 48);
        *(_QWORD *)(v79 + 48) = *(_QWORD *)(v71 - 16);
        *(_QWORD *)(v71 - 16) = v81;
        ++*(_DWORD *)(v71 - 24);
        ++*(_DWORD *)(v79 + 40);
        v70 = *(_QWORD *)(a1 + 480);
      }
      *((_QWORD *)v72 + 7) = *(_QWORD *)(v71 - 8);
      v68 = *(_QWORD *)(a1 + 496);
    }
    v82 = v68 + (v70 << 6);
    re::DynamicArray<re::SyncOwnershipRequest>::deinit(v82 - 48);
    v83 = *(_QWORD *)(v82 - 56);
    if (v83)
    {

      *(_QWORD *)(v82 - 56) = 0;
    }
    v84 = *(_QWORD *)(v82 - 64);
    if (v84)
    {

      *(_QWORD *)(v82 - 64) = 0;
    }
    --*(_QWORD *)(a1 + 480);
    ++*(_DWORD *)(a1 + 488);
  }
}

void re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _anonymous_namespace_ *v5;
  __int128 *v6;
  __int128 v7;
  _BYTE v8[8];
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 16))
  {
    v4 = 0;
    v5 = (_anonymous_namespace_ *)(a1 + 40);
    do
    {
      v6 = (__int128 *)(*(_QWORD *)(a1 + 32) + 32 * v4);
      if (*(_QWORD *)v6 == a2)
      {
        if (!*(_DWORD *)(a1 + 80))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v4);
          continue;
        }
        v8[0] = 0;
        v7 = v6[1];
        v9 = *v6;
        v10 = v7;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add(v5, (uint64_t)v8);
      }
      ++v4;
    }
    while (v4 < *(_QWORD *)(a1 + 16));
  }
}

uint64_t re::SyncObjectManager::onViewAdded(re::SyncObjectManager *this, re::SyncViewManager *a2, re::SyncView *a3)
{
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = re::globalAllocators(this)[2];
  v8[0] = &off_24E070BD0;
  v8[1] = this;
  v8[2] = a3;
  v9 = v6;
  v10 = v8;
  re::SyncViewManager::forEachViewer((uint64_t)a2, (uint64_t)v8);
  if (v10)
  {
    (*(void (**)(_QWORD *))*v10)(v10);
    if (v10 != v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
  }
  return 0;
}

void re::SyncObjectManager::receive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  re *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  re *v16;
  NSObject *v17;
  _BOOL8 v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  std::chrono::steady_clock::time_point v31;
  unint64_t *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t i;
  unint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[7];
  uint8_t v48[16];
  uint8_t buf[16];
  _BYTE v50[32];
  _QWORD v51[3];
  int v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v48, 6008, a1);
  *(_QWORD *)a3 = a1;
  v6 = *(_QWORD *)(a1 + 480);
  if (v6)
  {
    v7 = *(_QWORD **)(a1 + 496);
    v8 = &v7[8 * v6];
    while (1)
    {
      v9 = *v7;
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(*v7 + 24);
      *(_DWORD *)(a3 + 24) = *(_DWORD *)(v9 + 72);
      v10 = v7[1];
      v47[0] = MEMORY[0x24BDAC760];
      v47[1] = 0x40000000;
      v47[2] = ___ZN2re17SyncObjectManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke;
      v47[3] = &unk_24E070B30;
      v47[5] = a1;
      v47[6] = a3;
      v47[4] = a2;
      v11 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v10 + 40))(v10, a3, v47);
      if ((v11 & 1) == 0)
        break;
      v12 = v7[1];
      v13 = *(_QWORD *)(*v7 + 24);
      v14 = re::globalAllocators(v11)[2];
      *(_QWORD *)v50 = &off_24E070C80;
      *(_QWORD *)&v50[8] = a1;
      *(_QWORD *)&v50[16] = v13;
      *(_QWORD *)&v50[24] = v14;
      v51[0] = v50;
      v15 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v12 + 56))(v12, v50);
      v16 = (re *)v51[0];
      if (v51[0])
      {
        v16 = (re *)(**(uint64_t (***)(_QWORD))v51[0])(v51[0]);
        if ((_BYTE *)v51[0] != v50)
          v16 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)&v50[24] + 40))(*(_QWORD *)&v50[24]);
        v51[0] = 0;
      }
      if ((v15 & 1) == 0)
      {
        v17 = *re::networkLogObjects(v16);
        v18 = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
        if (v18)
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_21C69B000, v17, OS_LOG_TYPE_ERROR, "[Ownership] Corrupt ownership request.", buf, 2u);
        }
        v19 = *re::networkLogObjects((re *)v18);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          if ((*(_BYTE *)(v9 + 48) & 1) != 0)
            v20 = *(_QWORD *)(v9 + 56);
          else
            v20 = v9 + 49;
          v21 = *(_QWORD *)(v9 + 24);
          v22 = *(_QWORD *)(v9 + 152);
          v23 = "nullptr";
          if (v22)
          {
            v46 = *(_QWORD *)(v9 + 24);
            v23 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 32))(v22);
            v21 = v46;
          }
          *(_DWORD *)v50 = 134218498;
          *(_QWORD *)&v50[4] = v21;
          *(_WORD *)&v50[12] = 2082;
          *(_QWORD *)&v50[14] = v20;
          *(_WORD *)&v50[22] = 2082;
          *(_QWORD *)&v50[24] = v23;
          _os_log_error_impl(&dword_21C69B000, v19, OS_LOG_TYPE_ERROR, "Failed to parse ownership requests. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)", v50, 0x20u);
        }
        re::Transport::disconnect((re::Transport *)(*(_QWORD *)(a1 + 408) + 2320), *(_QWORD *)(v9 + 32), 0);
      }
      v7 += 8;
      if (v7 == v8)
        goto LABEL_23;
    }
    v24 = *re::networkLogObjects(v11);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      if ((*(_BYTE *)(v9 + 48) & 1) != 0)
        v42 = *(_QWORD *)(v9 + 56);
      else
        v42 = v9 + 49;
      v43 = *(_QWORD *)(v9 + 24);
      v44 = *(_QWORD *)(v9 + 152);
      if (v44)
        v45 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 32))(v44);
      else
        v45 = "nullptr";
      *(_DWORD *)v50 = 134218498;
      *(_QWORD *)&v50[4] = v43;
      *(_WORD *)&v50[12] = 2082;
      *(_QWORD *)&v50[14] = v42;
      *(_WORD *)&v50[22] = 2082;
      *(_QWORD *)&v50[24] = v45;
      _os_log_error_impl(&dword_21C69B000, v24, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)", v50, 0x20u);
    }
    re::Transport::disconnect((re::Transport *)(*(_QWORD *)(a1 + 408) + 2320), *(_QWORD *)(v9 + 32), 0);
  }
LABEL_23:
  if (*(_QWORD *)(a1 + 640))
  {
    v50[0] = 0;
    v53 = 0;
    memset(v51, 0, sizeof(v51));
    v52 = 0;
    *(_QWORD *)&v50[8] = 0;
    *(_QWORD *)&v50[16] = 0;
    *(_QWORD *)&v50[21] = 0;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v51, (uint64_t *)(a1 + 624));
    (*(void (**)(uint64_t, uint64_t, _BYTE *))(a2 + 16))(a2, a1, v50);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(a1 + 624);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v51);
  }
  v25 = *(unsigned int *)(a1 + 544);
  if ((_DWORD)v25)
  {
    v26 = 0;
    v27 = (int *)(*(_QWORD *)(a1 + 528) + 8);
    while (1)
    {
      v28 = *v27;
      v27 += 8;
      if (v28 < 0)
        break;
      if (v25 == ++v26)
      {
        LODWORD(v26) = *(_DWORD *)(a1 + 544);
        break;
      }
    }
  }
  else
  {
    LODWORD(v26) = 0;
  }
  if ((_DWORD)v25 != (_DWORD)v26)
  {
    v29 = v26;
    do
    {
      v30 = *(_QWORD *)(a1 + 528) + 32 * v29;
      v31.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
      if (*(_QWORD *)(v30 + 24) < v31.__d_.__rep_)
      {
        v32 = (unint64_t *)(v30 + 16);
        v33 = *re::networkLogObjects((re *)v31.__d_.__rep_);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          v41 = *(_QWORD *)(*v32 + 24);
          *(_DWORD *)v50 = 134217984;
          *(_QWORD *)&v50[4] = v41;
          _os_log_debug_impl(&dword_21C69B000, v33, OS_LOG_TYPE_DEBUG, "[Ownership] Ownership response for: %llu timed out", v50, 0xCu);
        }
        v34 = *(_QWORD *)(a1 + 432);
        if (v34)
        {
          v35 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v34 + 56))(v34);
          v36 = *v32;
          if (*v32)
          {
            for (i = *(_QWORD *)(v36 + 80); i; i = *(_QWORD *)(i + 80))
            {
              v38 = v36;
              v36 = i;
              if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v38 + 88) + 16) + 73))
                break;
            }
          }
          re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::raise(v35, a1);
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(a1 + 512, *v32);
      }
      if (*(_DWORD *)(a1 + 544) <= (v26 + 1))
        v39 = v26 + 1;
      else
        v39 = *(_DWORD *)(a1 + 544);
      while (1)
      {
        v29 = (v26 + 1);
        if (v39 - 1 == (_DWORD)v26)
          break;
        LODWORD(v26) = v26 + 1;
        v40 = v29;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 528) + 32 * v29 + 8) & 0x80000000) != 0)
          goto LABEL_51;
      }
      v40 = v39;
LABEL_51:
      LODWORD(v26) = v40;
    }
    while ((_DWORD)v25 != v40);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v48);
}

uint64_t ___ZN2re17SyncObjectManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  re *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  re *v36;
  NSObject *v37;
  uint64_t v38;
  _BYTE buf[24];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD **)(a1 + 40);
  v4 = *(_QWORD *)(a2 + 48);
  if (v4)
  {
    v5 = *(uint64_t **)(a2 + 64);
    v6 = &v5[3 * v4];
    do
    {
      if ((*(_BYTE *)(*v5 + 128) & 4) != 0)
        re::SyncObjectManager::destroyObject((uint64_t)v5);
      if ((v5[2] & 4) == 0)
        goto LABEL_32;
      (*(void (**)(_BYTE *__return_ptr))(***(_QWORD ***)(a1 + 48) + 32))(buf);
      v7 = re::Session::peerID(*(re::Session **)buf);
      if (*(_QWORD *)buf)

      v8 = *v5;
      v9 = *(_QWORD *)(*v5 + 136);
      if (v9)
        v10 = v9 == v7;
      else
        v10 = 0;
      if (v10)
      {
        v18 = *(_QWORD *)(v8 + 80);
        if (v18)
        {
          v19 = *v5;
          do
          {
            v20 = v19;
            v19 = v18;
            if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v20 + 88) + 16) + 73))
              break;
            v18 = *(_QWORD *)(v18 + 80);
          }
          while (v18);
        }
        v21 = *(_WORD *)(v8 + 144);
        *(_QWORD *)(v8 + 136) = 0;
        *(_QWORD *)(v8 + 160) = 0;
        *(_WORD *)(v8 + 168) = v21;
        *(_BYTE *)(v8 + 170) = 1;
        v22 = v3[73];
        re::SyncObjectManager::gatherObjectsWithChildren(v5, v3 + 71);
        while (v22 < v3[73])
        {
          v23 = *(_QWORD *)(v3[75] + 8 * v22);
          v24 = *(_QWORD *)(v23 + 80);
          v25 = v23;
          if (v24)
          {
            v26 = *(_QWORD *)(v3[75] + 8 * v22);
            do
            {
              v25 = v26;
              v26 = v24;
              if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v25 + 88) + 16) + 73))
                break;
              v24 = *(_QWORD *)(v24 + 80);
              v25 = v26;
            }
            while (v24);
          }
          v27 = *(_OWORD *)(v25 + 136);
          v28 = *(_OWORD *)(v25 + 152);
          *(_DWORD *)(v23 + 168) = *(_DWORD *)(v25 + 168);
          *(_OWORD *)(v23 + 152) = v28;
          *(_OWORD *)(v23 + 136) = v27;
          ++v22;
        }
        v29 = re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)(v3 + 64), *v5);
        v30 = v3[54];
        if (v29)
        {
          if (!v30)
            goto LABEL_32;
          v31 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v30 + 56))(v30);
          re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::raise(v31, (uint64_t)v3);
          v33 = *re::networkLogObjects(v32);
          if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            goto LABEL_32;
          v34 = *(_QWORD *)(*v5 + 24);
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v34;
          v16 = v33;
          v17 = "[Ownership] Received ownership granted response for: %llu";
        }
        else
        {
          if (!v30)
            goto LABEL_32;
          v35 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v30 + 64))(v30);
          re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::raise(v35, (uint64_t)v3);
          v37 = *re::networkLogObjects(v36);
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
            goto LABEL_32;
          v38 = *(_QWORD *)(*v5 + 24);
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v38;
          v16 = v37;
          v17 = "[Ownership] Received ownership handoff for: %llu";
        }
      }
      else
      {
        v11 = v3[54];
        if (!v11)
          goto LABEL_32;
        v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 72))(v11);
        re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::raise(v12, (uint64_t)v3);
        v14 = *re::networkLogObjects(v13);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          goto LABEL_32;
        v15 = *(_QWORD *)(*v5 + 24);
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v15;
        v16 = v14;
        v17 = "[Ownership] Received ownership change: %llu";
      }
      _os_log_debug_impl(&dword_21C69B000, v16, OS_LOG_TYPE_DEBUG, v17, buf, 0xCu);
LABEL_32:
      v5 += 3;
    }
    while (v5 != v6);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void re::SyncObjectManager::destroyObject(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD v12[2];
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  unint64_t v20;
  _OWORD v21[5];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 200);
  if (v3)
  {
    v4 = v3 - 1;
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)a1 + 200);
      if (v5 <= v4)
      {
        v12[1] = 0;
        memset(v21, 0, sizeof(v21));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v13 = 136315906;
        v14 = "operator[]";
        v15 = 1024;
        v16 = 789;
        v17 = 2048;
        v18 = v4;
        v19 = 2048;
        v20 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 216) + 8 * v4);
      *(_QWORD *)&v21[0] = v6;
      if (v6)
      {
        v7 = (void *)(v6 + 8);
        v8 = (id)(v6 + 8);
        re::SyncObjectManager::destroyObject(v21);

      }
      else
      {
        re::SyncObjectManager::destroyObject(v21);
      }
      --v4;
    }
    while (v4 != -1);
    v2 = *(_QWORD **)a1;
  }
  v9 = v2[11];
  if (*(_BYTE *)(*(_QWORD *)(v9 + 16) + 74))
  {
    v10 = v2[12];
    if (v10)
    {
      re::SyncView::removeObject(v10, (uint64_t)(v2 + 12));
      v2 = *(_QWORD **)a1;
      v9 = *(_QWORD *)(*(_QWORD *)a1 + 88);
    }
  }
  v12[0] = v2;
  v11 = v2 + 1;
  re::SyncObjectTypedStore::removeObject(v9, (uint64_t)v12);
  if (v12[0])

}

void re::SyncObjectManager::gatherObjectsWithChildren(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  uint64_t v9;

  re::DynamicArray<re::SharedPtr<re::SyncObject>>::add(a2, a1);
  v4 = *(_QWORD *)(*a1 + 200);
  if (v4)
  {
    v5 = *(uint64_t **)(*a1 + 216);
    v6 = 8 * v4;
    do
    {
      v7 = *v5;
      v9 = v7;
      if (v7)
        v8 = (id)(v7 + 8);
      re::SyncObjectManager::gatherObjectsWithChildren(&v9, a2);
      if (v9)

      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(unsigned int *)(v5 + 4 * v4);
  if ((_DWORD)v6 == 0x7FFFFFFF)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  v9 = v8 + 32 * v6;
  if (*(_QWORD *)(v9 + 16) != a2)
  {
    while (1)
    {
      v10 = v6;
      v11 = *(_DWORD *)(v8 + 32 * v6 + 8);
      v6 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      v12 = v8 + 32 * v6;
      if (*(_QWORD *)(v12 + 16) == a2)
      {
        *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v12 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_9:
  v13 = *(_QWORD *)(a1 + 16) + 32 * v6;
  v14 = *(_DWORD *)(v13 + 8);
  if (v14 < 0)
  {
    *(_DWORD *)(v13 + 8) = v14 & 0x7FFFFFFF;
    v17 = *(_QWORD *)(v13 + 16);
    v16 = (_QWORD *)(v13 + 16);
    v15 = v17;
    if (v17)
    {

      *v16 = 0;
    }
  }
  v18 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v6 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v6 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v18 + 1;
  return 1;
}

void re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  _OWORD v23[5];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *(_QWORD *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v15 = 136315906;
          v16 = "operator[]";
          v17 = 1024;
          v18 = 789;
          v19 = 2048;
          v20 = i;
          v21 = 2048;
          v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *(_QWORD *)(a1 + 72) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, *((unint64_t *)&v23[0] + 1));
        }
        v7 += 40;
      }
    }
  }
}

void re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  _OWORD v23[5];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *(_QWORD *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v15 = 136315906;
          v16 = "operator[]";
          v17 = 1024;
          v18 = 789;
          v19 = 2048;
          v20 = i;
          v21 = 2048;
          v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *(_QWORD *)(a1 + 72) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, *((unint64_t *)&v23[0] + 1));
        }
        v7 += 40;
      }
    }
  }
}

void re::SyncObjectManager::send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE v41[16];
  uint64_t v42;
  uint64_t v43;

  v5 = a3;
  v6 = a2;
  *(_QWORD *)(a4 + 8) = a1;
  v42 = a2;
  v43 = a3;
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v41, 6018, a1);
  if (v5)
  {
    v8 = v6;
    do
    {
      v9 = *(_QWORD *)(v8 + 48);
      if (v9)
      {
        v10 = *(uint64_t **)(v8 + 64);
        v11 = &v10[3 * v9];
        do
        {
          v12 = *v10;
          v13 = *(_QWORD *)(*v10 + 80);
          v14 = *v10;
          if (v13)
          {
            v15 = *v10;
            do
            {
              v14 = v15;
              v15 = v13;
              if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v14 + 88) + 16) + 73))
                break;
              v13 = *(_QWORD *)(v13 + 80);
              v14 = v15;
            }
            while (v13);
          }
          if ((*(_BYTE *)(v14 + 170) || *(_BYTE *)(a1 + 400)) && (*(_BYTE *)(v12 + 128) & 4) != 0)
          {
            if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 88) + 16) + 74))
            {
              v18 = *(_QWORD *)(v12 + 96);
              v17 = v12 + 96;
              v16 = v18;
              if (v18)
                re::SyncView::removeObject(v16, v17);
            }
          }
          v10 += 3;
        }
        while (v10 != v11);
      }
      v8 += 72;
    }
    while (v8 != v6 + 72 * v5);
  }
  v19 = *(_QWORD *)(a1 + 480);
  if (v19)
  {
    v20 = *(uint64_t **)(a1 + 496);
    v21 = &v20[8 * v19];
    do
    {
      v22 = *v20;
      v23 = *(_QWORD *)(*v20 + 152);
      if (!v23 || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v23 + 48))(v23) & 1) == 0)
      {
        *(_QWORD *)(a4 + 16) = *(_QWORD *)(v22 + 24);
        *(_DWORD *)(a4 + 32) = *(_DWORD *)(v22 + 72);
        v24 = v20[1];
        v25 = *(_QWORD *)(a1 + 584);
        v39 = *(_QWORD *)(a1 + 600);
        v40 = v25;
        (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v24 + 32))(v24, &v42, &v39, v20[7], a4);
        v26 = v20[1];
        v27 = v20[4];
        v39 = v20[6];
        v40 = v27;
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v26 + 48))(v26, &v39);
        v28 = v20[4];
        v20[4] = 0;
        if (v28)
        {
          v29 = 80 * v28;
          v30 = (_QWORD *)(v20[6] + 56);
          do
          {
            v31 = *(v30 - 4);
            if (v31)
            {
              if (*v30)
                (*(void (**)(uint64_t))(*(_QWORD *)v31 + 40))(v31);
              *v30 = 0;
              *(v30 - 3) = 0;
              *(v30 - 2) = 0;
              *(v30 - 4) = 0;
              ++*((_DWORD *)v30 - 2);
            }
            v30 += 10;
            v29 -= 80;
          }
          while (v29);
        }
        ++*((_DWORD *)v20 + 10);
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(v20[7] + 64);
      }
      v20 += 8;
    }
    while (v20 != v21);
    v6 = v42;
    v5 = v43;
  }
  if (v5)
  {
    v32 = v6 + 72 * v5;
    do
    {
      v33 = *(_QWORD *)(v6 + 48);
      if (v33)
      {
        v34 = *(_QWORD *)(v6 + 64);
        v35 = v34 + 24 * v33;
        do
        {
          v36 = *(_QWORD *)(*(_QWORD *)v34 + 80);
          v37 = *(_QWORD *)v34;
          if (v36)
          {
            v38 = *(_QWORD *)v34;
            do
            {
              v37 = v38;
              v38 = v36;
              if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v37 + 88) + 16) + 73))
                break;
              v36 = *(_QWORD *)(v36 + 80);
              v37 = v38;
            }
            while (v36);
          }
          if ((*(_BYTE *)(v37 + 170) || *(_BYTE *)(a1 + 400)) && (*(_BYTE *)(*(_QWORD *)v34 + 128) & 4) != 0)
            re::SyncObjectManager::destroyObject(v34);
          v34 += 24;
        }
        while (v34 != v35);
      }
      v6 += 72;
    }
    while (v6 != v32);
  }
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::clear(a1 + 568);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v41);
}

void re::DynamicArray<re::SharedPtr<re::SyncObject>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = 8 * v2;
    do
    {
      if (*(_QWORD *)v3)
      {

        *(_QWORD *)v3 = 0;
      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::SyncObjectManager::session@<X0>(_QWORD *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  v2 = this[51];
  *a2 = v2;
  if (v2)
    return (id)(v2 + 8);
  return this;
}

_QWORD *re::DynamicArray<re::SharedPtr<re::SyncObject>>::add(_QWORD *this, uint64_t *a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SharedPtr<re::SyncObject>>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = *a2;
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  if (v5)
  {
    this = (id)(v5 + 8);
    v4 = v3[2];
  }
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::SyncObjectManager::requestOwnership(uint64_t a1, uint64_t *a2, char a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::chrono::steady_clock::time_point v15;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  _anonymous_namespace_ *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  BOOL v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD v51[2];
  uint8_t buf[16];
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  __int128 v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  v12 = *a2;
  v13 = *(_QWORD *)(*a2 + 80);
  if (v13)
  {
    do
    {
      v14 = v12;
      v12 = v13;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v14 + 88) + 16) + 73))
        break;
      v13 = *(_QWORD *)(v13 + 80);
      v14 = v12;
    }
    while (v13);
  }
  else
  {
    v14 = *a2;
  }
  if (!*(_QWORD *)(v14 + 160))
    return;
  v15.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  rep = v15.__d_.__rep_;
  v17 = *a2;
  v18 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v19 = (0x94D049BB133111EBLL * (v18 ^ (v18 >> 27))) ^ ((0x94D049BB133111EBLL * (v18 ^ (v18 >> 27))) >> 31);
  v20 = *(_QWORD *)(a1 + 512);
  if (v20)
  {
    v20 = v19 % *(unsigned int *)(a1 + 536);
    v21 = *(unsigned int *)(*(_QWORD *)(a1 + 520) + 4 * v20);
    if ((_DWORD)v21 != 0x7FFFFFFF)
    {
      v46 = *(_QWORD *)(a1 + 528);
      if (*(_QWORD *)(v46 + 32 * v21 + 16) == v17)
        goto LABEL_17;
      while (1)
      {
        v21 = *(_DWORD *)(v46 + 32 * v21 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v21 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v46 + 32 * v21 + 16) == v17)
          goto LABEL_17;
      }
    }
  }
  v22 = *(unsigned int *)(a1 + 548);
  if ((_DWORD)v22 == 0x7FFFFFFF)
  {
    v22 = *(unsigned int *)(a1 + 544);
    v23 = v22;
    if ((_DWORD)v22 == *(_DWORD *)(a1 + 536))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1 + 512, 2 * *(_DWORD *)(a1 + 540));
      LODWORD(v20) = v19 % *(unsigned int *)(a1 + 536);
      v23 = *(_DWORD *)(a1 + 544);
      v17 = *a2;
    }
    *(_DWORD *)(a1 + 544) = v23 + 1;
    v24 = *(_QWORD *)(a1 + 528);
    v25 = *(_DWORD *)(v24 + 32 * v22 + 8);
  }
  else
  {
    v24 = *(_QWORD *)(a1 + 528);
    v25 = *(_DWORD *)(v24 + 32 * v22 + 8);
    *(_DWORD *)(a1 + 548) = v25 & 0x7FFFFFFF;
  }
  v26 = rep + (uint64_t)(a6 * 1000000000.0);
  *(_DWORD *)(v24 + 32 * v22 + 8) = v25 | 0x80000000;
  v27 = *(_QWORD *)(a1 + 520);
  v28 = v20;
  *(_DWORD *)(*(_QWORD *)(a1 + 528) + 32 * v22 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 528) + 32 * v22 + 8) & 0x80000000 | *(_DWORD *)(v27 + 4 * v20);
  *(_QWORD *)(*(_QWORD *)(a1 + 528) + 32 * v22) = v19;
  *(_QWORD *)(*(_QWORD *)(a1 + 528) + 32 * v22 + 16) = v17;
  if (v17)
  {
    v15.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)(id)(v17 + 8);
    v27 = *(_QWORD *)(a1 + 520);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 528) + 32 * v22 + 24) = v26;
  *(_DWORD *)(v27 + 4 * v28) = v22;
  ++*(_DWORD *)(a1 + 540);
  ++*(_DWORD *)(a1 + 552);
  v17 = *a2;
LABEL_17:
  v29 = *(_QWORD *)(v17 + 80);
  if (v29)
  {
    do
    {
      v30 = v17;
      v17 = v29;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v30 + 88) + 16) + 73))
        break;
      v29 = *(_QWORD *)(v29 + 80);
      v30 = v17;
    }
    while (v29);
  }
  else
  {
    v30 = v17;
  }
  v31 = *(_QWORD *)(a1 + 480);
  if (v31)
  {
    v32 = *(_QWORD *)(v30 + 160);
    v33 = (_QWORD *)(*(_QWORD *)(a1 + 496) + 48);
    v34 = v31 << 6;
    while (*(_QWORD *)(*(v33 - 6) + 24) != v32)
    {
      v33 += 8;
      v34 -= 64;
      if (!v34)
        return;
    }
    v35 = *re::networkLogObjects((re *)v15.__d_.__rep_);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
    {
      v36 = *(_QWORD *)(*a2 + 24);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v36;
      _os_log_impl(&dword_21C69B000, v35, OS_LOG_TYPE_INFO, "[Ownership] Requesting ownership for: %llu", buf, 0xCu);
    }
    v37 = *(_QWORD *)(*a2 + 24);
    *(_QWORD *)buf = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a2 + 88) + 16) + 32);
    *(_QWORD *)&buf[8] = v37;
    v53 = a3;
    v51[0] = a4;
    v51[1] = a5;
    v38 = (_anonymous_namespace_ *)re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v54, (uint64_t)v51);
    *(_QWORD *)&v59 = v58;
    *((_QWORD *)&v59 + 1) = v56;
    v39 = *(v33 - 3);
    v40 = *(v33 - 2);
    if (v40 >= v39)
    {
      v41 = v40 + 1;
      if (v39 < v40 + 1)
      {
        if (*(v33 - 4))
        {
          v42 = 2 * v39;
          v43 = v39 == 0;
          v44 = 8;
          if (!v43)
            v44 = v42;
          if (v44 <= v41)
            v45 = v41;
          else
            v45 = v44;
          re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(v33 - 4, v45);
        }
        else
        {
          re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(v33 - 4, v41);
          ++*((_DWORD *)v33 - 2);
        }
      }
      v40 = *(v33 - 2);
    }
    v47 = *v33 + 80 * v40;
    v48 = *(_OWORD *)buf;
    *(_BYTE *)(v47 + 16) = v53;
    *(_OWORD *)v47 = v48;
    *(_QWORD *)(v47 + 56) = 0;
    *(_QWORD *)(v47 + 32) = 0;
    *(_QWORD *)(v47 + 40) = 0;
    *(_QWORD *)(v47 + 24) = 0;
    *(_DWORD *)(v47 + 48) = 0;
    *(_QWORD *)(v47 + 24) = v54;
    v54 = 0;
    *(_QWORD *)(v47 + 32) = v55;
    v55 = 0;
    v49 = *(_QWORD *)(v47 + 40);
    *(_QWORD *)(v47 + 40) = v56;
    v56 = v49;
    v50 = *(_QWORD *)(v47 + 56);
    *(_QWORD *)(v47 + 56) = v58;
    v58 = v50;
    ++v57;
    ++*(_DWORD *)(v47 + 48);
    *(_OWORD *)(v47 + 64) = v59;
    ++*(v33 - 2);
    ++*((_DWORD *)v33 - 2);
    if (v54)
    {
      if (v58)
        (*(void (**)(void))(*(_QWORD *)v54 + 40))();
    }
  }
}

double re::SyncObjectManager::adjustTimeForSender(re::SyncObjectManager *this, double a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _BYTE v9[4];
  int v10;

  v4 = *((_QWORD *)this + 60);
  if (v4)
  {
    v5 = *((_QWORD *)this + 62);
    v6 = v4 << 6;
    while (*(_QWORD *)(*(_QWORD *)v5 + 24) != a3)
    {
      v5 += 64;
      v6 -= 64;
      if (!v6)
        return a2;
    }
    re::Transport::connectionStats((re::Transport *)(*((_QWORD *)this + 51) + 2320), *(_QWORD *)(*(_QWORD *)v5 + 32), (uint64_t)v9);
    if (v9[0])
    {
      LODWORD(v7) = v10;
      return a2 + (double)v7 / 1000.0 * 0.5;
    }
  }
  return a2;
}

uint64_t re::SyncObjectManager::pausePeer(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = *(_QWORD *)(this + 480);
  if (v2)
  {
    v3 = (_QWORD *)(*(_QWORD *)(this + 496) + 8);
    v4 = v2 << 6;
    while (*(_QWORD *)(*(v3 - 1) + 24) != a2)
    {
      v3 += 8;
      v4 -= 64;
      if (!v4)
        return this;
    }
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v3 + 64))(*v3);
  }
  return this;
}

uint64_t re::SyncObjectManager::resumePeer(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = *(_QWORD *)(this + 480);
  if (v2)
  {
    v3 = (_QWORD *)(*(_QWORD *)(this + 496) + 8);
    v4 = v2 << 6;
    while (*(_QWORD *)(*(v3 - 1) + 24) != a2)
    {
      v3 += 8;
      v4 -= 64;
      if (!v4)
        return this;
    }
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v3 + 72))(*v3);
  }
  return this;
}

uint64_t re::SyncSession::receive()
{
  return 0;
}

uint64_t re::SyncSession::send()
{
  return 0;
}

uint64_t *re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *a1;
  if (v2)
  {
    if (a1[4])
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  v3 = a1[5];
  if (v3)
  {
    if (a1[9])
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
      v4 = *a1;
    }
    else
    {
      v4 = 0;
    }
    a1[9] = 0;
    a1[6] = 0;
    a1[7] = 0;
    a1[5] = 0;
    ++*((_DWORD *)a1 + 16);
    if (v4)
    {
      if (a1[4])
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      a1[4] = 0;
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      ++*((_DWORD *)a1 + 6);
    }
  }
  return a1;
}

void re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  re::SyncViewer *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  re::SyncViewer **v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  re::SyncViewer **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  re::SyncViewer **v21;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = v2[60];
  if (v3)
  {
    v4 = *a2;
    v5 = v2[62];
    v6 = v5 + (v3 << 6);
    do
    {
      v7 = *(re::SyncViewer **)(v5 + 56);
      if (v7)
      {
        if (*((_QWORD *)v7 + 7) == *(_QWORD *)(v4 + 24))
        {
          v8 = *(_QWORD *)(v4 + 120);
          v9 = *(_QWORD *)(v4 + 104);
          if (v9)
          {
            v10 = 8 * v9;
            v11 = *(re::SyncViewer ***)(v4 + 120);
            while (*v11 != v7)
            {
              ++v11;
              v10 -= 8;
              if (!v10)
              {
                v11 = (re::SyncViewer **)(v8 + 8 * v9);
                break;
              }
            }
          }
          else
          {
            v11 = *(re::SyncViewer ***)(v4 + 120);
          }
          if (v9 != ((uint64_t)v11 - v8) >> 3)
            goto LABEL_31;
        }
        else
        {
          v12 = v2[76];
          if (!v12)
          {
            v18 = *(_QWORD *)(v4 + 120);
            v19 = *(_QWORD *)(v4 + 104);
            if (v19)
            {
              v20 = 8 * v19;
              v21 = *(re::SyncViewer ***)(v4 + 120);
              while (*v21 != v7)
              {
                ++v21;
                v20 -= 8;
                if (!v20)
                {
                  v21 = (re::SyncViewer **)(v18 + 8 * v19);
                  break;
                }
              }
            }
            else
            {
              v21 = *(re::SyncViewer ***)(v4 + 120);
            }
            if (v19 == ((uint64_t)v21 - v18) >> 3)
              goto LABEL_31;
LABEL_30:
            re::SyncView::removeViewer(v4, v7);
            goto LABEL_31;
          }
          v13 = (*(uint64_t (**)(uint64_t, _QWORD *))(v12 + 16))(v12, v2);
          v14 = *(_QWORD *)(v4 + 120);
          v15 = *(_QWORD *)(v4 + 104);
          if (v15)
          {
            v16 = 8 * v15;
            v17 = *(re::SyncViewer ***)(v4 + 120);
            while (*v17 != v7)
            {
              ++v17;
              v16 -= 8;
              if (!v16)
              {
                v17 = (re::SyncViewer **)(v14 + 8 * v15);
                break;
              }
            }
          }
          else
          {
            v17 = *(re::SyncViewer ***)(v4 + 120);
          }
          if (v13 == (v15 != ((uint64_t)v17 - v14) >> 3))
            goto LABEL_31;
          if (!v13)
            goto LABEL_30;
        }
        re::SyncView::addViewer((re::SyncViewer ***)v4, v7);
      }
LABEL_31:
      v5 += 64;
    }
    while (v5 != v6);
  }
}

_QWORD *re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E070B78;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E070B78;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::size()
{
  return 16;
}

void re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::operator()(uint64_t a1, re::SyncViewer **a2)
{
  _QWORD *v3;
  uint64_t v4;
  re::SyncViewer *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *(_QWORD **)(a1 + 8);
  v4 = v3[60];
  if (v4)
  {
    v6 = *a2;
    v7 = *((_QWORD *)*a2 + 7);
    v8 = v3[62];
    v9 = v4 << 6;
    while (*(_QWORD *)(*(_QWORD *)v8 + 24) != v7)
    {
      v8 += 64;
      v9 -= 64;
      if (!v9)
        return;
    }
    v10 = *(_QWORD *)(a1 + 16);
    if (v7 == *(_QWORD *)(v10 + 24) || v7 == *(_QWORD *)(v10 + 32))
      goto LABEL_11;
    v11 = v3[76];
    if (v11 && (*(unsigned int (**)(void))(v11 + 16))())
    {
      v10 = *(_QWORD *)(a1 + 16);
LABEL_11:
      re::SyncView::addViewer((re::SyncViewer ***)v10, v6);
    }
  }
}

uint64_t re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E070BD0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E070BD0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::size()
{
  return 24;
}

uint64_t re::DynamicArray<re::SyncOwnershipRequest>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 80 * v4;
        v6 = (_QWORD *)(v3 + 56);
        do
        {
          v7 = *(v6 - 4);
          if (v7)
          {
            if (*v6)
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *v6 = 0;
            *(v6 - 3) = 0;
            *(v6 - 2) = 0;
            *(v6 - 4) = 0;
            ++*((_DWORD *)v6 - 2);
          }
          v6 += 10;
          v5 -= 80;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::SyncOwnershipRequest>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  __n128 v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::SyncOwnershipRequest>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    v6 = a2[2];
    if (v6 >= *(_QWORD *)(a1 + 16))
    {
      re::DynamicArray<re::SyncOwnershipRequest>::setCapacity((_QWORD *)a1, a2[2]);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,0>((__int128 *)a2[4], (__int128 *)(a2[4] + 80 * *(_QWORD *)(a1 + 16)), *(_QWORD *)(a1 + 32));
      v12 = *(_QWORD *)(a1 + 16);
      if (v12 != v6)
      {
        v13 = a2[4];
        v14 = v13 + 80 * v6;
        v15 = 80 * v12 + 24;
        v16 = v13 + v15;
        v17 = *(_QWORD *)(a1 + 32) + v15;
        do
        {
          v18 = *(_OWORD *)(v16 - 24);
          *(_BYTE *)(v17 - 8) = *(_BYTE *)(v16 - 8);
          *(_OWORD *)(v17 - 24) = v18;
          v19 = re::DynamicArray<unsigned char>::DynamicArray(v17, (uint64_t *)v16);
          *(_OWORD *)(v19 + 40) = *(_OWORD *)(v16 + 40);
          v20 = v16 + 56;
          v16 += 80;
          v17 = v19 + 80;
        }
        while (v20 != v14);
      }
    }
    else
    {
      v7 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,0>((__int128 *)a2[4], (__int128 *)(a2[4] + 80 * v6), *(_QWORD *)(a1 + 32));
      v8 = *(_QWORD *)(a1 + 16);
      if (v6 != v8)
      {
        v9 = 80 * v8 - 80 * v6;
        v10 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 80 * v6 + 56);
        do
        {
          v11 = *(v10 - 4);
          if (v11)
          {
            if (*v10)
              (*(void (**)(uint64_t, __n128))(*(_QWORD *)v11 + 40))(v11, v7);
            *v10 = 0;
            *(v10 - 3) = 0;
            *(v10 - 2) = 0;
            *(v10 - 4) = 0;
            ++*((_DWORD *)v10 - 2);
          }
          v10 += 10;
          v9 -= 80;
        }
        while (v9);
      }
    }
    *(_QWORD *)(a1 + 16) = v6;
  }
  return a1;
}

_QWORD *re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          v2 = 80 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 80 * v9;
        v11 = (uint64_t *)(v8 + 32);
        v12 = v7;
        do
        {
          v13 = *((_OWORD *)v11 - 2);
          *((_BYTE *)v12 + 16) = *((_BYTE *)v11 - 16);
          *(_OWORD *)v12 = v13;
          v12[7] = 0;
          v12[4] = 0;
          v12[5] = 0;
          v12[3] = 0;
          *((_DWORD *)v12 + 12) = 0;
          v14 = *v11;
          v12[3] = *(v11 - 1);
          *(v11 - 1) = 0;
          v12[4] = v14;
          *v11 = 0;
          v15 = v12[5];
          v12[5] = v11[1];
          v11[1] = v15;
          v16 = v12[7];
          v12[7] = v11[3];
          v11[3] = v16;
          ++*((_DWORD *)v11 + 4);
          ++*((_DWORD *)v12 + 12);
          *((_OWORD *)v12 + 4) = *((_OWORD *)v11 + 2);
          v17 = *(v11 - 1);
          if (v17)
          {
            if (v11[3])
              (*(void (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
            v11[3] = 0;
            *v11 = 0;
            v11[1] = 0;
            *(v11 - 1) = 0;
            ++*((_DWORD *)v11 + 4);
          }
          v11 += 10;
          v12 += 10;
          v10 -= 80;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,0>(__int128 *a1, __int128 *a2, uint64_t a3)
{
  __int128 *v5;
  __int128 v6;
  __n128 result;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *v5;
      *(_BYTE *)(a3 + 16) = *((_BYTE *)v5 + 16);
      *(_OWORD *)a3 = v6;
      re::DynamicArray<unsigned char>::operator=(a3 + 24, (uint64_t *)v5 + 3);
      result = (__n128)v5[4];
      *(__n128 *)(a3 + 64) = result;
      v5 += 5;
      a3 += 80;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
        re::DynamicArray<unsigned char>::copy((void **)a1, (uint64_t)a2);
      else
        *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<unsigned char>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<unsigned char>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void **re::DynamicArray<unsigned char>::copy(void **result, uint64_t a2)
{
  void **v3;
  size_t v4;
  size_t v5;
  char *v6;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<unsigned char>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = (size_t)v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), v5);
      v6 = (char *)v3[2];
    }
    else
    {
      v6 = 0;
    }
    result = (void **)memcpy(&v6[(_QWORD)v3[4]], &v6[*(_QWORD *)(a2 + 32)], v4 - (_QWORD)v6);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), v4);
  }
  v3[2] = (void *)v4;
  return result;
}

_QWORD *re::DynamicArray<unsigned char>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  void *v6;

  v2 = result[1];
  if (v2 != a2)
  {
    v4 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v4)
      {
        if (!a2)
        {
          v6 = 0;
          if (!v2)
            goto LABEL_8;
          goto LABEL_7;
        }
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2, 1);
        if (result)
        {
          v6 = result;
          if (!v4[1])
          {
LABEL_8:
            v4[4] = v6;
            v4[1] = a2;
            return result;
          }
LABEL_7:
          memcpy(v6, (const void *)v4[4], v4[2]);
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[4]);
          goto LABEL_8;
        }
        re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, a2, *(_QWORD *)(*v4 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<unsigned char>::setCapacity(v4, a2);
        ++*((_DWORD *)v4 + 6);
      }
    }
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<unsigned char>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<unsigned char>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

_QWORD *re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::~Callable(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  *a1 = &off_24E070C28;
  re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)(a1 + 4));
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  v3 = a1[2];
  if (v3)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::~Callable(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  *a1 = &off_24E070C28;
  re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)(a1 + 4));
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  v3 = a1[2];
  if (v3)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  re::SyncViewer *v3;

  v2 = *a2;
  v3 = *(re::SyncViewer **)(a1 + 72);
  if (*((_QWORD *)v3 + 7) != *(_QWORD *)(v2 + 24))
  {
    if (!(*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 608) + 16))())
      return;
    v3 = *(re::SyncViewer **)(a1 + 72);
  }
  re::SyncView::addViewer((re::SyncViewer ***)v2, v3);
}

_QWORD *re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::cloneInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  id v8;

  v5 = a1[1];
  v4 = a1[2];
  *a2 = &off_24E070C28;
  a2[1] = v5;
  a2[2] = v4;
  if (v4)
    v6 = (id)(v4 + 8);
  v7 = a1[3];
  a2[3] = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  re::DynamicArray<re::SyncOwnershipRequest>::DynamicArray((uint64_t)(a2 + 4), a1 + 4);
  a2[9] = a1[9];
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a2 = &off_24E070C28;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_DWORD *)(a2 + 56) = 0;
  v2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a2 + 40) = v2;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v3 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = v3;
  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v4;
  ++*(_DWORD *)(a1 + 56);
  ++*(_DWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(a1 + 72);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::size()
{
  return 80;
}

re::internal::AriadneSignpostScopeGuard *re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this, int a2, uint64_t a3)
{
  *(_DWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  return this;
}

uint64_t re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::internal::SyncSnapshotEntry>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::internal::SyncSnapshotEntry>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = 24 * v2;
    do
    {
      if (*(_QWORD *)v3)
      {

        *(_QWORD *)v3 = 0;
      }
      v3 += 24;
      v4 -= 24;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this)
{
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
}

void re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t Object;
  re::SyncObject *v6;
  re::SyncObject *v7;
  re::SyncObject *v8;
  re::SyncObject *v9;
  re::SyncObject *v10;
  re::SyncObject *v11;
  re::SyncObject *v12;
  re::SyncObject *v13;
  BOOL v14;
  re::SyncObject *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  re::SyncObject *v19;
  re::SyncObject *v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t i;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  NSObject *v30;
  re::SyncObject *v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  re::SyncObject *v39[5];
  _OWORD v40[2];
  uint64_t v41;
  int v42;
  const char *v43;
  __int16 v44;
  int v45;
  __int16 v46;
  unint64_t v47;
  __int16 v48;
  unint64_t v49;
  _OWORD buf[5];
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 8);
  Object = (uint64_t)re::SyncObjectStore::findObject(*(re::SyncObjectStore **)(v4 + 416), *(_QWORD *)a2, *(_QWORD *)(a2 + 8), (re::SyncObjectTypedStore ***)v39);
  v6 = v39[0];
  if (v39[0])
  {
    if (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v39[0] + 11) + 16) + 73))
      goto LABEL_52;
    v7 = (re::SyncObject *)*((_QWORD *)v39[0] + 10);
    v8 = v39[0];
    if (v7)
    {
      v9 = (re::SyncObject *)*((_QWORD *)v39[0] + 10);
      v10 = v39[0];
      do
      {
        v8 = v10;
        v10 = v9;
        if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v8 + 11) + 16) + 73))
          break;
        v9 = (re::SyncObject *)*((_QWORD *)v9 + 10);
        v8 = v10;
      }
      while (v9);
    }
    if (*((_QWORD *)v8 + 20) || !*((_QWORD *)v39[0] + 20) && *((_QWORD *)v39[0] + 17))
    {
LABEL_52:

      return;
    }
    if (v7)
    {
      v11 = (re::SyncObject *)*((_QWORD *)v39[0] + 10);
      v12 = v39[0];
      do
      {
        v13 = v12;
        v12 = v11;
        if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v13 + 11) + 16) + 73))
          break;
        v11 = (re::SyncObject *)*((_QWORD *)v11 + 10);
        v13 = v12;
      }
      while (v11);
      v14 = *((_BYTE *)v13 + 152) != 0;
      v38 = *((_BYTE *)v13 + 152) == 0;
      do
      {
        v15 = v6;
        v6 = v7;
        if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v15 + 11) + 16) + 73))
          break;
        v7 = (re::SyncObject *)*((_QWORD *)v7 + 10);
        v15 = v6;
      }
      while (v7);
      v16 = *((unsigned __int8 *)v15 + 152);
    }
    else
    {
      v16 = *((unsigned __int8 *)v39[0] + 152);
      v14 = v16 != 0;
      v38 = *((_BYTE *)v39[0] + 152) == 0;
    }
    if (!v16)
      goto LABEL_48;
    v17 = *(_QWORD *)(v4 + 432);
    if (v17)
    {
      Object = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 48))(v17);
      v18 = Object;
      v19 = *(re::SyncObject **)(a1 + 16);
      v20 = *(re::SyncObject **)(a2 + 72);
      v39[2] = *(re::SyncObject **)(a2 + 64);
      v39[3] = v19;
      v39[1] = v20;
      v21 = *(_DWORD *)(Object + 80);
      *(_DWORD *)(Object + 80) = v21 + 1;
      if (*(_QWORD *)(Object + 16))
      {
        v22 = 0;
        do
        {
          Object = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v18 + 32) + 32 * v22 + 24))(v4);
          if ((_DWORD)Object == 1)
            Object = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)v18, v22);
          else
            ++v22;
        }
        while (v22 < *(_QWORD *)(v18 + 16));
        v21 = *(_DWORD *)(v18 + 80) - 1;
      }
      *(_DWORD *)(v18 + 80) = v21;
      if (!v21)
      {
        v23 = *(_QWORD *)(v18 + 56);
        if (v23)
        {
          v24 = 0;
          for (i = 0; i != v23; ++i)
          {
            v26 = *(_QWORD *)(v18 + 56);
            if (v26 <= i)
            {
              v39[4] = 0;
              memset(buf, 0, sizeof(buf));
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              v42 = 136315906;
              v43 = "operator[]";
              v44 = 1024;
              v45 = 789;
              v46 = 2048;
              v47 = i;
              v48 = 2048;
              v49 = v26;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v27 = *(_QWORD *)(v18 + 72) + v24;
            v28 = *(_QWORD *)(v27 + 32);
            v29 = *(_OWORD *)(v27 + 16);
            v40[0] = *(_OWORD *)v27;
            v40[1] = v29;
            v41 = v28;
            if (LOBYTE(v40[0]))
            {
              Object = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v18, (_QWORD *)v40 + 1, (uint64_t)buf);
              if (!LOBYTE(buf[0]))
                re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)v18, (uint64_t)v40 + 8);
            }
            else
            {
              Object = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v18, (_QWORD *)v40 + 1, (uint64_t)buf);
              if (LOBYTE(buf[0]))
                Object = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)v18, *((unint64_t *)&buf[0] + 1));
            }
            v24 += 40;
          }
        }
      }
      if (v38)
        goto LABEL_40;
LABEL_49:
      v33 = *re::networkLogObjects((re *)Object);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        v37 = *(_QWORD *)a2;
        v36 = *(_QWORD *)(a2 + 8);
        LODWORD(buf[0]) = 134218240;
        *(_QWORD *)((char *)buf + 4) = v36;
        WORD6(buf[0]) = 2048;
        *(_QWORD *)((char *)buf + 14) = v37;
        _os_log_debug_impl(&dword_21C69B000, v33, OS_LOG_TYPE_DEBUG, "[Ownership] Rejected request for locked object %llu (%llu)", (uint8_t *)buf, 0x16u);
      }
LABEL_51:
      v6 = v39[0];
      if (!v39[0])
        return;
      goto LABEL_52;
    }
    v32 = *re::networkLogObjects(0);
    Object = os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
    if ((_DWORD)Object)
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl(&dword_21C69B000, v32, OS_LOG_TYPE_ERROR, "[Ownership] No NetworkSyncManager found, ownership request not forwarded.", (uint8_t *)buf, 2u);
      if (v14)
        goto LABEL_49;
    }
    else
    {
LABEL_48:
      if (v14)
        goto LABEL_49;
    }
LABEL_40:
    v30 = *re::networkLogObjects((re *)Object);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      v35 = *(_QWORD *)a2;
      v34 = *(_QWORD *)(a2 + 8);
      LODWORD(buf[0]) = 134218240;
      *(_QWORD *)((char *)buf + 4) = v34;
      WORD6(buf[0]) = 2048;
      *(_QWORD *)((char *)buf + 14) = v35;
      _os_log_debug_impl(&dword_21C69B000, v30, OS_LOG_TYPE_DEBUG, "[Ownership] Granted request for object %llu (%llu)", (uint8_t *)buf, 0x16u);
    }
    v31 = v39[0];
    if (!*((_QWORD *)v39[0] + 20) && !*((_QWORD *)v39[0] + 17))
      *((_BYTE *)v39[0] + 152) = *(_BYTE *)(a2 + 16);
    if (re::SyncObject::handOff(v31, *(_QWORD *)(a1 + 16)))
      re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((_QWORD *)(v4 + 568), (uint64_t *)v39);
    goto LABEL_51;
  }
}

uint64_t re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E070C80;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E070C80;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::size()
{
  return 24;
}

__n128 re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  _OWORD *v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (_OWORD *)(*((_QWORD *)this + 4) + 32 * v4);
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *v5 = *(_OWORD *)a2;
  v5[1] = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 32 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 8 * v4;
        do
        {
          if (*(_QWORD *)v3)
          {

            *(_QWORD *)v3 = 0;
          }
          v3 += 8;
          v5 -= 8;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::Event<re::Session>::addSubscription(_DWORD *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (a1[20])
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 10), (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)v5 = result;
  *(_OWORD *)(v5 + 16) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 40 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::Event<re::Session>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t *);
  _QWORD *v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  uint64_t v11;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *))a2[1];
  v4 = a2[2];
  v6 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *))(*v6 + v5);
  v7 = *a3;
  v11 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v9 = v5(v6, a1, &v11);
  if (v11)

  return v9;
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v6;
  uint64_t (*v7)(_QWORD *, uint64_t, uint64_t *, _QWORD);
  _QWORD *v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  uint64_t v13;

  v7 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *, _QWORD))a2[1];
  v6 = a2[2];
  v8 = (_QWORD *)(*a2 + (v6 >> 1));
  if ((v6 & 1) != 0)
    v7 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *, _QWORD))(*v8 + v7);
  v9 = *a3;
  v13 = v9;
  if (v9)
    v10 = (id)(v9 + 8);
  v11 = v7(v8, a1, &v13, *a4);
  if (v13)

  return v11;
}

uint64_t re::Event<re::Session,unsigned long long>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

double re::Event<re::SyncViewManager,re::SyncView *>::addSubscription(_DWORD *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (a1[20])
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 10), (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, a2).n128_u64[0];
    }
  }
  return result;
}

uint64_t re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

void re::Event<re::SyncViewManager,re::SyncView *>::removeSubscription(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  _BYTE v5[8];
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, a2, (uint64_t)v5);
  if (v5[0])
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v5[0] = 0;
      v4 = a2[1];
      v6 = *a2;
      v7 = v4;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 40), (uint64_t)v5);
    }
    else
    {
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable((_QWORD *)a1, a2);
    }
  }
}

_QWORD *re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = a2 << 6;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 32;
        v11 = v9 << 6;
        v12 = v7;
        do
        {
          *(_OWORD *)v12 = *(_OWORD *)(v10 - 32);
          *(_OWORD *)(v10 - 32) = 0u;
          v12[6] = 0;
          v12[2] = 0;
          *(_OWORD *)(v12 + 3) = 0u;
          *((_DWORD *)v12 + 10) = 0;
          v13 = *(_QWORD *)(v10 - 8);
          v12[2] = *(_QWORD *)(v10 - 16);
          *(_QWORD *)(v10 - 16) = 0;
          v12[3] = v13;
          *(_QWORD *)(v10 - 8) = 0;
          v14 = v12[4];
          v12[4] = *(_QWORD *)v10;
          *(_QWORD *)v10 = v14;
          v15 = v12[6];
          v12[6] = *(_QWORD *)(v10 + 16);
          *(_QWORD *)(v10 + 16) = v15;
          ++*(_DWORD *)(v10 + 8);
          ++*((_DWORD *)v12 + 10);
          v12[7] = *(_QWORD *)(v10 + 24);
          re::DynamicArray<re::SyncOwnershipRequest>::deinit(v10 - 16);
          v16 = *(_QWORD *)(v10 - 24);
          if (v16)
          {

            *(_QWORD *)(v10 - 24) = 0;
          }
          v17 = *(_QWORD *)(v10 - 32);
          if (v17)
          {

            *(_QWORD *)(v10 - 32) = 0;
          }
          v10 += 64;
          v12 += 8;
          v11 -= 64;
        }
        while (v11);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::SharedPtr<re::SyncObject>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_15;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        v12 = (_QWORD *)v5[4];
        do
        {
          *v11++ = *v12;
          *v12++ = 0;
          v10 -= 8;
        }
        while (v10);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  id v22;
  signed int v23;
  _BYTE v24[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(_QWORD *)&v24[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v24, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v24;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)v24 = v5;
      *(_QWORD *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (uint64_t *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            v14 = *(v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17) = v14;
            v21 = *v13;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 16) = *v13;
            if (v21)
            {
              v22 = (id)(v21 + 8);
              v12 = *(_QWORD *)(a1 + 8);
            }
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 24) = v13[1];
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 4;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2)
      v23 = a2;
    else
      v23 = 3;
  }
}

void re::MultipeerManager::applySessionConfigDefaults(uint64_t a1, const char *a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  char v12;
  _BYTE v13[4];
  int v14;
  _BYTE v15[4];
  int v16;
  char v17[2];
  char v18[2];
  char v19[2];
  char v20[2];
  char v21[2];
  char v22[2];
  _BYTE v23[4];
  int v24;
  _BYTE v25[4];
  int v26;

  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.sessionInitTimeOutMs", a2, (uint64_t)v25);
  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.sessionHandshakeTimeOutMs", v3, (uint64_t)v23);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionIsLeader", v4, v22);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionForceAuthorityOverIncomingObjects", v5, v21);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionShutdownOnVersionMismatch", v6, v20);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionUseReliableSync", v7, v19);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.enableThrottling", v8, v18);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.enableMessageFragmentation", v9, v17);
  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.sessionResendPeriodMs", v10, (uint64_t)v15);
  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.syncPacketSizeLimit", v11, (uint64_t)v13);
  if (v25[0])
    *(_DWORD *)(a1 + 24) = v26;
  if (v23[0])
    *(_DWORD *)(a1 + 28) = v24;
  if (v22[0])
    *(_BYTE *)(a1 + 40) = v22[1];
  if (v21[0])
    *(_BYTE *)(a1 + 72) = v21[1];
  if (v20[0])
    *(_BYTE *)(a1 + 78) = v20[1];
  if (v19[0])
    v12 = v19[1];
  else
    v12 = 0;
  *(_BYTE *)(a1 + 79) = v12;
  if (v18[0])
    *(_BYTE *)(a1 + 76) = v18[1];
  if (v17[0])
    *(_BYTE *)(a1 + 77) = v17[1];
  if (v15[0])
    *(_DWORD *)(a1 + 80) = v16;
  if (v13[0])
    *(_DWORD *)(a1 + 84) = v14;
}

BOOL re::MultipeerManager::initView(uint64_t *a1, id *a2)
{
  uint64_t *v4;
  uint64_t v5;
  ObjCObject v6;
  _BOOL8 v7;
  re *v8;
  NSObject *v9;
  id v11;
  NSObject *v12;
  void *v13;
  id v14;
  uint64_t v15;
  id v16;
  uint8_t buf[4];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v4 = re::globalAllocators((re *)a1);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 248, 8);
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_QWORD *)(v5 + 240) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v5, 0);
  *(_QWORD *)v5 = &off_24E073128;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 96) = 0;
  *(_DWORD *)(v5 + 104) = 0;
  *(_OWORD *)(v5 + 56) = 0u;
  *(_OWORD *)(v5 + 72) = 0u;
  *(_DWORD *)(v5 + 88) = 0;
  *(_QWORD *)(v5 + 120) = 0;
  *(_QWORD *)(v5 + 128) = 0;
  *(_QWORD *)(v5 + 112) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  *(_QWORD *)(v5 + 184) = 0;
  *(_DWORD *)(v5 + 192) = 0;
  *(_DWORD *)(v5 + 176) = 0;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_QWORD *)(v5 + 240) = 0;
  *(_OWORD *)(v5 + 200) = 0u;
  *(_OWORD *)(v5 + 216) = 0u;
  *(_DWORD *)(v5 + 232) = 0;
  v16 = *a2;
  v6.var0 = &v16;
  v7 = re::MultipeerDiscoveryView::init((id *)v5, v6);

  if (v7)
  {
    re::SharedPtr<re::SyncObject>::reset(a1 + 8, v5);
  }
  else
  {
    v9 = *re::networkLogObjects(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = *a2;
      v12 = v9;
      objc_msgSend(v11, "myPeerID");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "displayName");
      v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v15 = objc_msgSend(v14, "UTF8String");
      *(_DWORD *)buf = 136315138;
      v18 = v15;
      _os_log_error_impl(&dword_21C69B000, v12, OS_LOG_TYPE_ERROR, "Failed to initiate RE discovery with MCSession (%s).", buf, 0xCu);

    }
  }

  return v7;
}

void re::MultipeerManager::~MultipeerManager(id *this)
{
  char *v2;
  char *v3;
  id v4;

  *this = &off_24E070DB8;
  if (*((_BYTE *)this + 24))
  {
    re::MultipeerManager::stopSync((re::MultipeerManager *)this);
    v2 = (char *)this[4];
    if (v2)
    {

      this[4] = 0;
    }
    *((_BYTE *)this + 24) = 0;
  }
  else
  {
    v3 = (char *)this[4];
    if (v3)
    {

      this[4] = 0;
    }
  }
  v4 = this[1];
  this[1] = 0;

}

{
  re::MultipeerManager::~MultipeerManager(this);
  JUMPOUT(0x220780CD0);
}

uint64_t re::MultipeerManager::setHandshakeTimeoutAndCountMs(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 40) = a2;
  *(_DWORD *)(this + 44) = a3;
  return this;
}

BOOL re::MultipeerManager::createSessionAndStartSync(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  id v5;
  NSObject *v6;
  _BOOL8 result;
  const char *v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  id v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  id v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  _QWORD v34[5];

  v34[4] = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a2 + 64);
  if (!v2 || (v5 = *(id *)(v2 + 200), v5, !v5))
  {
    v6 = *re::networkLogObjects((re *)a1);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(v21) = 0;
    v8 = "No MCSession object provided.";
    goto LABEL_8;
  }
  if (*(_QWORD *)(a1 + 32))
  {
    v6 = *re::networkLogObjects((re *)a1);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(v21) = 0;
    v8 = "Already syncing over another session. Stop it first.";
LABEL_8:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v21, 2u);
    return 0;
  }
  v21 = *(id *)a2;
  v22 = *(_OWORD *)(a2 + 8);
  v9 = *(_QWORD *)(a2 + 32);
  v23 = *(_QWORD *)(a2 + 24);
  v24 = v9;
  if (v9)
    v10 = (id)(v9 + 8);
  v25 = *(_OWORD *)(a2 + 40);
  v11 = *(_QWORD *)(a2 + 64);
  v26 = *(_QWORD *)(a2 + 56);
  v27 = v11;
  if (v11)
    v12 = (id)(v11 + 8);
  v28 = *(_OWORD *)(a2 + 72);
  v13 = *(_QWORD *)(a2 + 104);
  v29 = *(_QWORD *)(a2 + 88);
  v31 = v13;
  if (v13)
    v14 = (id)(v13 + 8);
  v15 = *(_QWORD *)(a2 + 112);
  v32 = v15;
  if (v15)
    v16 = (id)(v15 + 8);
  v33 = *(_DWORD *)(a2 + 120);
  v17 = *(_DWORD *)(a1 + 40);
  if (v17 <= 1)
    v17 = 1;
  HIDWORD(v23) = *(_DWORD *)(a1 + 44);
  v30 = v17;
  v21 = *(id *)(a1 + 8);

  v18 = *(_QWORD *)(a1 + 16);
  (*(void (**)(_QWORD *__return_ptr, uint64_t, id *))(*(_QWORD *)v18 + 104))(v34, v18, &v21);
  v19 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v34[0];
  v34[0] = v19;
  if (v19)

  v20 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
  v34[0] = a1;
  v34[1] = re::MultipeerManager::sessionRemovedFromSync;
  v34[2] = 0;
  v34[3] = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::MultipeerManager>(re::MultipeerManager *,REEventHandlerResult (re::MultipeerManager::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke;
  re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::addSubscription(v20, (uint64_t)v34);
  if (v32)
  {

    v32 = 0;
  }
  if (v31)
  {

    v31 = 0;
  }
  if (v27)
  {

    v27 = 0;
  }
  if (v24)

  return 1;
}

uint64_t re::MultipeerManager::sessionRemovedFromSync(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 32);
  if (*a3 != v3)
    return 0;
  if (v3)
  {

    *(_QWORD *)(a1 + 32) = 0;
  }
  return 1;
}

void re::MultipeerManager::stopSync(re::MultipeerManager *this)
{
  uint64_t v1;
  uint64_t v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _anonymous_namespace_ *v8;
  re::MultipeerManager **v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 4);
  if (v1)
  {
    v3 = *((_QWORD *)this + 2);
    v12 = *((_QWORD *)this + 4);
    v4 = (id)(v1 + 8);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 112))(v3, &v12);
    if (v12)
    {

      v12 = 0;
    }
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    if (*(_QWORD *)(v5 + 16))
    {
      v6 = v5;
      v7 = 0;
      v8 = (_anonymous_namespace_ *)(v5 + 40);
      do
      {
        v9 = (re::MultipeerManager **)(*(_QWORD *)(v6 + 32) + 32 * v7);
        if (*v9 == this)
        {
          if (!*(_DWORD *)(v6 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)v6, v7);
            continue;
          }
          v13[0] = 0;
          v10 = *((_OWORD *)v9 + 1);
          v14 = *(_OWORD *)v9;
          v15 = v10;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::add(v8, (uint64_t)v13);
        }
        ++v7;
      }
      while (v7 < *(_QWORD *)(v6 + 16));
    }
    v11 = *((_QWORD *)this + 4);
    if (v11)
    {

      *((_QWORD *)this + 4) = 0;
    }
  }
}

void re::MultipeerManager::session(re::MultipeerManager *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v3 = *((_QWORD *)this + 4);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 2208);
    if (v4)
      v5 = (id)(v4 + 8);
    *a2 = *(id *)(v4 + 200);

  }
  else
  {
    *a2 = 0;
  }
}

_QWORD *re::MultipeerManager::internalSession@<X0>(_QWORD *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  v2 = this[4];
  *a2 = v2;
  if (v2)
    return (id)(v2 + 8);
  return this;
}

void re::MultipeerManager::mcPeerID(re::MultipeerManager *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *v5;
  re::MultipeerDiscoveryView *v6;
  char *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;
  unint64_t v15;
  BOOL v16;
  uint64_t v17;
  _OWORD v18[2];

  v5 = (_QWORD *)*((_QWORD *)this + 4);
  v6 = (re::MultipeerDiscoveryView *)v5[276];
  if (v6)
  {
    v8 = (char *)v6 + 8;

    v5 = (_QWORD *)*((_QWORD *)this + 4);
  }
  v9 = v5[287];
  if (v9)
  {
    v10 = (uint64_t *)v5[289];
    v11 = 8 * v9;
    while (1)
    {
      v12 = *v10;
      if (*(_QWORD *)(*v10 + 24) == a2)
        break;
      ++v10;
      v11 -= 8;
      if (!v11)
        goto LABEL_20;
    }
    v13 = (void *)(v12 + 8);
    v14 = (id)(v12 + 8);
    if ((*(uint64_t (**)(re::MultipeerDiscoveryView *))(*(_QWORD *)v6 + 48))(v6))
    {
      v15 = 0;
      do
      {
        (*(void (**)(uint64_t *__return_ptr, re::MultipeerDiscoveryView *, unint64_t))(*(_QWORD *)v6 + 56))(&v17, v6, v15);
        (*(void (**)(_OWORD *__return_ptr))(*(_QWORD *)v17 + 40))(v18);
        v16 = re::DynamicString::operator==(v12 + 40, (uint64_t)v18);
        if (*(_QWORD *)&v18[0])
        {
          if ((BYTE8(v18[0]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v18[0] + 40))();
          memset(v18, 0, sizeof(v18));
        }
        if (v17)

        if (v16)
        {
          re::MultipeerDiscoveryView::multipeerIdAtIndex(v6, v15, a3);

          return;
        }
        ++v15;
      }
      while (v15 < (*(uint64_t (**)(re::MultipeerDiscoveryView *))(*(_QWORD *)v6 + 48))(v6));
      if (!v12)
        goto LABEL_20;
    }

  }
LABEL_20:
  *a3 = 0;
}

uint64_t re::MultipeerManager::internalPeerID(re::MultipeerManager *this, ObjCObject a2)
{
  uint64_t v2;
  uint64_t v5;
  id v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  char *v15;

  v5 = *(_QWORD *)(*((_QWORD *)this + 4) + 2208);
  if (v5)
  {
    v6 = (id)(v5 + 8);

  }
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5))
  {
    v7 = 0;
    while (1)
    {
      re::MultipeerDiscoveryView::multipeerIdAtIndex((re::MultipeerDiscoveryView *)v5, v7, &v15);
      v8 = *(_QWORD *)a2.var0;
      v9 = v15;
      LODWORD(v8) = objc_msgSend(v9, "isEqual:", v8);

      if ((_DWORD)v8)
        break;
LABEL_13:
      if (++v7 >= (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5))
        return 0;
    }
    (*(void (**)(char **__return_ptr, uint64_t, unint64_t))(*(_QWORD *)v5 + 56))(&v15, v5, v7);
    v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 40))(*((_QWORD *)this + 4));
    if (v11)
    {
      v12 = 8 * v11;
      while (*(char **)(*(_QWORD *)v10 + 152) != v15)
      {
        v10 += 8;
        v12 -= 8;
        if (!v12)
          goto LABEL_10;
      }
      v13 = 0;
      v2 = *(_QWORD *)(*(_QWORD *)v10 + 24);
      if (!v15)
      {
LABEL_12:
        if (!v13)
          return v2;
        goto LABEL_13;
      }
    }
    else
    {
LABEL_10:
      v13 = 1;
      if (!v15)
        goto LABEL_12;
    }

    goto LABEL_12;
  }
  return 0;
}

double re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::addSubscription(_DWORD *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (a1[20])
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 10), (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)v5 = result;
  *(_OWORD *)(v5 + 16) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 40 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::MultipeerManager>(re::MultipeerManager *,REEventHandlerResult (re::MultipeerManager::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t *);
  _QWORD *v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  uint64_t v11;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *))a2[1];
  v4 = a2[2];
  v6 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *))(*v6 + v5);
  v7 = *a3;
  v11 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v9 = v5(v6, a1, &v11);
  if (v11)

  return v9;
}

uint64_t RESyncBitReaderGetRequiredSize()
{
  return 32;
}

uint64_t RESyncBitReaderConstructNoAlloc(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;

  v4 = 0;
  if (a1 && a2 >= 0x20)
  {
    *(_QWORD *)a1 = a3;
    *(_DWORD *)(a1 + 8) = a4;
    *(_BYTE *)(a1 + 12) = 0;
    v4 = a1;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
  }
  return v4;
}

uint64_t RESyncBitReaderReadData(uint64_t a1, void *__dst, size_t __n)
{
  uint64_t result;
  int v4;
  int v6;
  uint64_t v7;

  if (*(_BYTE *)(a1 + 12))
    return 0;
  v4 = __n;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(unsigned int *)(a1 + 16);
  if (v6 - (int)v7 >= __n)
  {
    *(_DWORD *)(a1 + 20) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    memcpy(__dst, (const void *)(*(_QWORD *)a1 + v7), __n);
    *(_DWORD *)(a1 + 16) += v4;
    return 1;
  }
  else
  {
    result = 0;
    *(_BYTE *)(a1 + 12) = 1;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 20) = 0;
  }
  return result;
}

uint64_t RESyncBitReaderDataPtr(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 12))
    return 0;
  else
    return *(_QWORD *)a1 + *(unsigned int *)(a1 + 16);
}

uint64_t RESyncBitReaderSkipData(uint64_t result, int a2)
{
  unsigned int v2;

  if (!*(_BYTE *)(result + 12))
  {
    *(_QWORD *)(result + 24) = 0;
    v2 = *(_DWORD *)(result + 16) + a2;
    *(_QWORD *)(result + 16) = v2;
    if (v2 > *(_DWORD *)(result + 8))
      *(_BYTE *)(result + 12) = 1;
  }
  return result;
}

uint64_t *RESyncBitReaderReadUInt8(uint64_t *a1, _BYTE *a2)
{
  uint64_t *result;
  unsigned int v4;

  v4 = 0;
  result = re::BitReader::readUInt32Bits(a1, 8u, &v4);
  *a2 = v4;
  return result;
}

uint64_t *RESyncBitReaderReadUInt16(uint64_t *a1, _WORD *a2)
{
  uint64_t *result;
  unsigned int v4;

  v4 = 0;
  result = re::BitReader::readUInt32Bits(a1, 0x10u, &v4);
  *a2 = v4;
  return result;
}

uint64_t *RESyncBitReaderReadUInt32(uint64_t *a1, unsigned int *a2)
{
  uint64_t *result;
  unsigned int v4;

  v4 = 0;
  result = re::BitReader::readUInt32Bits(a1, 0x20u, &v4);
  *a2 = v4;
  return result;
}

uint64_t *RESyncBitReaderReadBool(uint64_t *a1, BOOL *a2)
{
  uint64_t *result;
  unsigned int v4;

  v4 = 0;
  result = re::BitReader::readUInt32Bits(a1, 1u, &v4);
  *a2 = v4 != 0;
  return result;
}

float RESyncBitReaderReadFloat(uint64_t *a1, unsigned int *a2)
{
  float result;
  unsigned int v4;

  re::BitReader::readUInt32Bits(a1, 0x20u, &v4);
  result = *(float *)&v4;
  *a2 = v4;
  return result;
}

uint64_t RESyncBitReaderAlignToByte(uint64_t result)
{
  *(_DWORD *)(result + 20) = 0;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

uint64_t RESyncBitReaderMakeMarker(uint64_t a1)
{
  int v1;
  uint64_t v2;
  BOOL v3;
  _BOOL4 v4;
  uint64_t v5;

  v1 = *(_DWORD *)(a1 + 20);
  v2 = (8 - v1);
  v3 = v1 == 0;
  v4 = v1 != 0;
  v5 = v2 << 32;
  if (v3)
    v5 = 0;
  return v5 | (*(_DWORD *)(a1 + 16) - v4);
}

uint64_t RESyncBitReaderIsOverflow(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 12);
}

uint64_t RESyncBitReaderBitsLeft(_DWORD *a1)
{
  return (a1[5] + 8 * (a1[2] - a1[4]));
}

uint64_t RESyncBitReaderBytesLeft(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16));
}

uint64_t RESyncBitReaderBytesRead(uint64_t a1)
{
  unsigned int v1;

  v1 = *(_DWORD *)(a1 + 16);
  if (*(_DWORD *)(a1 + 20))
    return v1 + 1;
  else
    return v1;
}

uint64_t RESyncBitReaderSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t RESyncBitReaderBuffer(uint64_t a1)
{
  return *(_QWORD *)a1;
}

nw_protocol_definition_t re::NWProtocolFramer::create(re::NWProtocolFramer *this)
{
  void *v1;
  nw_protocol_definition_t definition;
  _QWORD v4[4];
  id v5;
  id v6;

  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZN2re16NWProtocolFramer6createEv_block_invoke_3;
  v4[3] = &unk_24E070F18;
  v5 = &__block_literal_global;
  v6 = &__block_literal_global_6;
  v1 = _Block_copy(v4);
  definition = nw_framer_create_definition("re-net-header", 0, v1);

  return definition;
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke(uint64_t a1, void *a2)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  BOOL v6;
  NSObject *v7;
  uint8_t temp_buffer[4];
  unsigned __int8 value;
  _QWORD value_4[6];

  value_4[5] = *MEMORY[0x24BDAC8D0];
  v2 = a2;
  *(_DWORD *)temp_buffer = 0;
  value = 0;
  v3 = 8;
  if (nw_framer_parse_input(v2, 8uLL, 8uLL, temp_buffer, &__block_literal_global_2))
  {
    v3 = 8;
    while (1)
    {
      *(_DWORD *)temp_buffer = bswap32(*(unsigned int *)temp_buffer);
      v4 = re::internal::enableSignposts(0, 0);
      if ((_DWORD)v4)
      {
        v4 = re::internal::enableHighFrequencyNetworkTracing(0, 0);
        if ((_DWORD)v4)
          v4 = kdebug_trace();
      }
      if (value > 9u)
        break;
      v5 = nw_framer_message_create(v2);
      nw_framer_message_set_value(v5, "channel", (void *)value, 0);
      v6 = nw_framer_deliver_input_no_copy(v2, *(unsigned int *)temp_buffer, v5, 1);

      if (!v6)
        goto LABEL_13;
      *(_DWORD *)temp_buffer = 0;
      value = 0;
      if (!nw_framer_parse_input(v2, 8uLL, 8uLL, temp_buffer, &__block_literal_global_2))
        goto LABEL_14;
    }
    v7 = *re::networkLogObjects((re *)v4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(value_4[0]) = 67109120;
      HIDWORD(value_4[0]) = value;
      _os_log_impl(&dword_21C69B000, v7, OS_LOG_TYPE_DEFAULT, "Message received on unknown channel %d", (uint8_t *)value_4, 8u);
    }
    value_4[0] = MEMORY[0x24BDAC760];
    value_4[1] = 3221225472;
    value_4[2] = ___Z20nw_framer_skip_bytesPU23objcproto12OS_nw_framer8NSObjectm_block_invoke;
    value_4[3] = &__block_descriptor_40_e14_Q28__0_8Q16B24l;
    value_4[4] = *(unsigned int *)temp_buffer;
    nw_framer_parse_input(v2, 0, 0, 0, value_4);
LABEL_13:
    v3 = 0;
  }
LABEL_14:

  return v3;
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke_2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 8 || a2 == 0)
    return 0;
  else
    return 8;
}

void ___ZN2re16NWProtocolFramer6createEv_block_invoke_4(uint64_t a1, void *a2, NSObject *a3, size_t a4)
{
  NSObject *v6;
  unsigned int v7;
  char v8;
  _QWORD access_value[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  access_value[0] = MEMORY[0x24BDAC760];
  access_value[1] = 3221225472;
  access_value[2] = ___ZN2re16NWProtocolFramer6createEv_block_invoke_2_7;
  access_value[3] = &unk_24E070EF0;
  access_value[4] = &v10;
  v6 = a2;
  nw_framer_message_access_value(a3, "channel", access_value);
  v7 = bswap32(a4);
  v8 = *((_BYTE *)v11 + 24);
  nw_framer_write_output(v6, (const uint8_t *)&v7, 8uLL);
  nw_framer_write_output_no_copy(v6, a4);

  if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyNetworkTracing(0, 0))
    kdebug_trace();
  _Block_object_dispose(&v10, 8);
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke_2_7(uint64_t a1, char a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke_3(uint64_t a1, void *a2)
{
  void *v3;
  NSObject *v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  nw_framer_set_input_handler(v4, v3);
  nw_framer_set_output_handler(v4, *(nw_framer_output_handler_t *)(a1 + 40));

  return 1;
}

id re::NWProtocolFramer::definition(re::NWProtocolFramer *this)
{
  unsigned __int8 v1;
  void **p_cache;
  re::NWProtocolFramer *v4;

  p_cache = MCSessionHandler.cache;
  if ((v1 & 1) == 0)
  {
    p_cache = (void **)(MCSessionHandler + 16);
    if ((_DWORD)v4)
    {
      re::NWProtocolFramer::create(v4);
      re::NWProtocolFramer::definition(void)::definition = objc_claimAutoreleasedReturnValue();
      p_cache = (void **)(MCSessionHandler + 16);
    }
  }
  return p_cache[356];
}

uint64_t RESyncCapabilityAlmond()
{
  return 8;
}

uint64_t RESyncCapabilityPistachio()
{
  return 16;
}

uint64_t RESyncCapabilityWalnut()
{
  return 32;
}

_QWORD *RESyncMCServiceConfigCreateNoAlloc(_QWORD *a1, unint64_t a2)
{
  _QWORD *result;
  uint64_t v4;
  id v5;

  result = 0;
  if (a1)
  {
    if (a2 >= 0x10)
    {
      v4 = MEMORY[0x24BDAC9B8];
      v5 = MEMORY[0x24BDAC9B8];
      *a1 = v4;
      return a1;
    }
  }
  return result;
}

void RESyncMCServiceConfigDestroyNoDealloc(id *a1)
{
  id v2;

  v2 = *a1;
  *a1 = 0;

}

uint64_t RESyncMCServiceCreate(re *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  id v5;

  if (!a1)
    return 0;
  v2 = re::globalAllocators(a1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 48, 8);
  *(_OWORD *)(v3 + 24) = 0u;
  *(_QWORD *)(v3 + 40) = 0;
  *(_OWORD *)(v3 + 8) = 0u;
  *(_QWORD *)v3 = &off_24E070DB8;
  v4 = MEMORY[0x24BDAC9B8];
  v5 = MEMORY[0x24BDAC9B8];
  *(_QWORD *)(v3 + 8) = v4;
  *(_BYTE *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = 0x61A800000002;
  objc_storeStrong((id *)(v3 + 8), *(id *)a1);
  *(_QWORD *)(v3 + 16) = *((_QWORD *)a1 + 1);
  *(_BYTE *)(v3 + 24) = 1;
  return v3;
}

re *RESyncMCServiceDestroy(re *result)
{
  re *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = re::globalAllocators(result)[2];
    (**(void (***)(re *))v1)(v1);
    return (re *)(*(uint64_t (**)(uint64_t, re *))(*(_QWORD *)v2 + 40))(v2, v1);
  }
  return result;
}

uint64_t RESyncMCServiceConfigGetSize()
{
  return 16;
}

void RESyncMCServiceConfigSetDispatchQueue(id *a1, void *a2)
{
  id v4;
  id v5;

  v4 = a2;
  if (a1 && v4)
  {
    v5 = v4;
    objc_storeStrong(a1, a2);
    v4 = v5;
  }

}

uint64_t RESyncMCServiceConfigSetSyncService(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
      *(_QWORD *)(result + 8) = a2;
  }
  return result;
}

uint64_t RESyncMCServiceStartSyncWithMCSession(uint64_t a1, void *a2)
{
  id v3;
  const char *v4;
  re *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  id v11;
  uint64_t v12;
  uint64_t v13[4];
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;

  v3 = a2;
  v13[0] = MEMORY[0x24BDAC9B8];
  v13[1] = 0x7B61A86B3;
  v13[2] = 0;
  v13[3] = 0x61A800000000;
  v14 = 0;
  v15 = 0;
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v19 = 0;
  v20 = 16777473;
  v21 = 500;
  v22 = 10485760;
  v23 = 257;
  v24 = 10;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  re::MultipeerManager::applySessionConfigDefaults((uint64_t)v13, v4);
  re::make::shared::object<re::LeaderElectionLowestPeerID>(v5, &v12);
  v6 = v12;
  v12 = 0;
  v7 = v14;
  v14 = v6;
  if (v7)
  {

    if (v12)
  }
  v8 = v3;
  v11 = v8;
  if (re::MultipeerManager::initView(v13, &v11))
    v9 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 24))(a1, v13);
  else
    v9 = 0;

  if (v26)
  {

    v26 = 0;
  }
  if (v25)
  {

    v25 = 0;
  }
  if (v18)
  {

    v18 = 0;
  }
  if (v14)

  return v9;
}

uint64_t RESyncMCServiceStopSync(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
}

id RESyncMCServiceGetMCSession(uint64_t a1)
{
  id v1;
  id v3;

  (*(void (**)(id *__return_ptr))(*(_QWORD *)a1 + 40))(&v3);
  v1 = v3;

  return v1;
}

uint64_t RESyncMCServiceGetInternalSession(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)a1 + 48))(&v3);
  v1 = v3;
  if (v3)

  return v1;
}

id RESyncMCServiceGetMCPeerID(uint64_t a1)
{
  id v1;
  id v3;

  (*(void (**)(id *__return_ptr))(*(_QWORD *)a1 + 56))(&v3);
  v1 = v3;

  return v1;
}

uint64_t RESyncMCServiceGetInternalPeerID(uint64_t a1, void *a2)
{
  uint64_t v3;
  id v5;

  v5 = a2;
  v3 = (*(uint64_t (**)(uint64_t, id *))(*(_QWORD *)a1 + 64))(a1, &v5);

  return v3;
}

uint64_t RESyncMCServiceSetHandshakeCountAndTimeoutMs(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

void re::make::shared::object<re::LeaderElectionLowestPeerID>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;

  v3 = re::globalAllocators(a1);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 40, 8);
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_QWORD *)(v4 + 32) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(_QWORD *)v4 = &off_24E0728A8;
  *a2 = v4;
}

uint64_t re::SyncHistoryResetRequest::write(re::SyncHistoryResetRequest *this, re::BitWriter *a2)
{
  unsigned int v4;
  unsigned int v5;

  v4 = *((_DWORD *)this + 1);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *(_DWORD *)this, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v4, 0x20u);
  v5 = *((_DWORD *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 2), 0x20u);
  return re::BitWriter::writeUInt32Bits((uint64_t)a2, v5, 0x20u);
}

void *re::SyncOpaqueTypeInfo::make@<X0>(re::SyncOpaqueTypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  _QWORD v5[2];

  re::SyncObjectTypeInfo::SyncObjectTypeInfo((re::SyncObjectTypeInfo *)a2);
  *(_BYTE *)(a2 + 72) = 1;
  *(_QWORD *)(a2 + 32) = this;
  v5[0] = "Opaque";
  v5[1] = 6;
  re::DynamicString::operator=((re::DynamicString *)(a2 + 40), (uint64_t)v5);
  re::SyncObjectTypeInfo::setReadSnapshotCb(a2, &__block_literal_global_0);
  re::SyncObjectTypeInfo::setWriteSnapshotCb(a2, &__block_literal_global_4);
  re::SyncObjectTypeInfo::setReadPayloadCb(a2, &__block_literal_global_7);
  return re::SyncObjectTypeInfo::setWritePayloadCb(a2, &__block_literal_global_10);
}

uint64_t ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke()
{
  return 0;
}

uint64_t ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke_2()
{
  return 0;
}

BOOL ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke_3(int a1, uint64_t a2, re::BitWriter *this)
{
  const void *v5;
  uint64_t v6;
  unsigned int v7;

  if (*(_BYTE *)(a2 + 12))
  {
    v5 = 0;
    LODWORD(v6) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    v6 = *(unsigned int *)(a2 + 16);
    v5 = (const void *)(*(_QWORD *)a2 + v6);
  }
  re::BitWriter::writeData(this, v5, (*(_DWORD *)(a2 + 8) - v6));
  if (!*(_BYTE *)(a2 + 12))
  {
    v7 = *(_DWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 16) = v7;
  }
  return *((_BYTE *)this + 20) == 0;
}

uint64_t ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke_4(int a1, uint64_t a2, re::BitWriter *this)
{
  const void *v3;
  uint64_t v4;

  if (*(_BYTE *)(a2 + 12))
  {
    v3 = 0;
    LODWORD(v4) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    v4 = *(unsigned int *)(a2 + 16);
    v3 = (const void *)(*(_QWORD *)a2 + v4);
  }
  return re::BitWriter::writeData(this, v3, (*(_DWORD *)(a2 + 8) - v4));
}

re::SyncObjectTypeInfo *re::SyncObjectTypeInfo::SyncObjectTypeInfo(re::SyncObjectTypeInfo *this)
{
  _anonymous_namespace_ *v2;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E0736A8;
  *((_BYTE *)this + 24) = 1;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  re::DynamicString::setCapacity((_QWORD *)this + 5, 0);
  *((_WORD *)this + 36) = 0;
  *((_BYTE *)this + 74) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  return this;
}

double RESyncProtocolLayerObserverCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 168, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_QWORD *)(v2 + 160) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E071048;
  result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  return result;
}

void RESyncProtocolLayerObserverOnCreate(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[3]);
      a1[3] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnCreate";
      v7 = 2080;
      v8 = "protocolLayerCreate != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnCreate";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnDestroy(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[4]);
      a1[4] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnDestroy";
      v7 = 2080;
      v8 = "protocolLayerDestroy != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnDestroy";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnInit(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[5]);
      a1[5] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnInit";
      v7 = 2080;
      v8 = "protocolLayerInit != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnInit";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnInitWithConfig(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[6]);
      a1[6] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnInitWithConfig";
      v7 = 2080;
      v8 = "protocolLayerInitWithConfig != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnInitWithConfig";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnDeinit(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[7]);
      a1[7] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnDeinit";
      v7 = 2080;
      v8 = "protocolLayerDeinit != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnDeinit";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnOpen(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[8]);
      a1[8] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnOpen";
      v7 = 2080;
      v8 = "protocolLayerOpen != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnOpen";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnOpenNullable(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[9]);
      a1[9] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnOpenNullable";
      v7 = 2080;
      v8 = "protocolLayerOpenNullable != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnOpenNullable";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnClose(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[10]);
      a1[10] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnClose";
      v7 = 2080;
      v8 = "protocolLayerClose != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnClose";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnDisconnect(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[11]);
      a1[11] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnDisconnect";
      v7 = 2080;
      v8 = "protocolLayerDisconnect != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnDisconnect";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnSend(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[12]);
      a1[12] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnSend";
      v7 = 2080;
      v8 = "protocolLayerSend != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnSend";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnUpdate(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[13]);
      a1[13] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnUpdate";
      v7 = 2080;
      v8 = "protocolLayerUpdate != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnUpdate";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnWait(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[14]);
      a1[14] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnWait";
      v7 = 2080;
      v8 = "protocolLayerWait != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnWait";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnWakeup(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[15]);
      a1[15] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnWakeup";
      v7 = 2080;
      v8 = "protocolLayerWakeup != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnWakeup";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnLocalAddresses(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[16]);
      a1[16] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnLocalAddresses";
      v7 = 2080;
      v8 = "protocolLayerLocalAddresses != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnLocalAddresses";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnHostStats(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[17]);
      a1[17] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnHostStats";
      v7 = 2080;
      v8 = "protocolLayerHostStats != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnHostStats";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnSetDisconnectTimeout(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[18]);
      a1[18] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnSetDisconnectTimeout";
      v7 = 2080;
      v8 = "protocolLayerSetDisconnectTimeout != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnSetDisconnectTimeout";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnPreferredPacketSize(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[19]);
      a1[19] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnPreferredPacketSize";
      v7 = 2080;
      v8 = "protocolLayerPreferredPacketSize != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnPreferredPacketSize";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnSetListener(const void **a1, const void *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[20]);
      a1[20] = _Block_copy(a2);
      return;
    }
    v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnSetListener";
      v7 = 2080;
      v8 = "protocolLayerSetListener != __null";
      goto LABEL_9;
    }
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolLayerObserverOnSetListener";
      v7 = 2080;
      v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

uint64_t RESyncProtocolLayerConfigGetPacketPool(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 24);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncProtocolLayerConfigGetPacketPool";
    v5 = 2080;
    v6 = "config != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncProtocolLayerConfigGetNetworkQueue(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 32);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncProtocolLayerConfigGetNetworkQueue";
    v5 = 2080;
    v6 = "config != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncCreateDefaultProtocolLayerUDP()
{
  return 0;
}

uint64_t RESyncCreateDefaultProtocolLayerTCP(_anonymous_namespace_ *a1, uint64_t a2)
{
  __int16 v2;
  re *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  char v9;
  __int16 v10;

  v2 = (__int16)a1;
  if (a1 >= 0x10000)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) listenPort %u exceeds numeric limits of type Port", "!overflow", "RESyncCreateDefaultProtocolLayerTCP", 513, a1);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v7 = 128;
    v10 = v2;
    v4 = re::globalAllocators(v3);
    v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 208, 8);
    re::TcpProtocolLayer::TcpProtocolLayer(v5, (uint64_t)&v7);
    if (v8)
    {
      if ((v9 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    return v5;
  }
  return result;
}

uint64_t RESyncCreateDefaultProtocolLayerNW(_anonymous_namespace_ *a1, uint64_t a2)
{
  __int16 v2;
  re *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t result;
  char v7[8];
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v2 = (__int16)a1;
  if (a1 >= 0x10000)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) listenPort %u exceeds numeric limits of type Port", "!overflow", "RESyncCreateDefaultProtocolLayerNW", 524, a1);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v10 = 0;
    v11 = 0;
    v9 = 0;
    v3 = (re *)re::DynamicString::setCapacity(&v8, 0);
    v13 = 0;
    v14 = 0;
    v7[0] = 1;
    v12 = v2;
    v4 = re::globalAllocators(v3);
    v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 224, 8);
    re::NWProtocolLayer::NWProtocolLayer(v5, (uint64_t)v7);
    if (v8)
    {
      if ((v9 & 1) != 0)
        (*(void (**)(void))(*v8 + 40))();
    }
    return v5;
  }
  return result;
}

uint64_t RESyncCreateProtocolLayerNWWithoutListener(_anonymous_namespace_ *a1)
{
  re *v1;
  uint64_t *v2;
  uint64_t v3;
  _BYTE v5[8];
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v8 = 0;
  v9 = 0;
  v7 = 0;
  v1 = (re *)re::DynamicString::setCapacity(&v6, 0);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v5[0] = 0;
  v2 = re::globalAllocators(v1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 224, 8);
  re::NWProtocolLayer::NWProtocolLayer(v3, (uint64_t)v5);
  if (v6 && (v7 & 1) != 0)
    (*(void (**)(uint64_t *))(*v6 + 40))(v6);
  return v3;
}

re::DebugProtocolLayer *RESyncCreateDefaultProtocolLayerDebug(re *a1)
{
  uint64_t *v1;
  re::DebugProtocolLayer *v2;

  v1 = re::globalAllocators(a1);
  v2 = (re::DebugProtocolLayer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 184, 8);
  return re::DebugProtocolLayer::DebugProtocolLayer(v2);
}

uint64_t RESyncCustomProtocolLayerCreate(_QWORD *a1)
{
  void *v2;
  re *v3;
  uint64_t *v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v2 = a1 + 1;
    v3 = a1 + 1;
    if ((a1[5] != 0) == (a1[6] == 0))
    {
      if (a1[7])
      {
        if ((a1[8] != 0) == (a1[9] == 0))
        {
          if (a1[10])
          {
            if (a1[11])
            {
              if (!a1[12] && !a1[13])
              {
                v11 = *re::networkLogObjects(v3);
                if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                {
                  v12 = 136315394;
                  v13 = "RESyncCustomProtocolLayerCreate";
                  v14 = 2080;
                  v15 = "RESyncProtocolLayerObserverOnUpdate() observer implementation is required.";
                  goto LABEL_44;
                }
                goto LABEL_45;
              }
              if ((a1[14] == 0) == (a1[15] == 0))
              {
                if (a1[16])
                {
                  if (a1[17])
                  {
                    if (a1[18])
                    {
                      if (a1[19])
                      {
                        v4 = re::globalAllocators(v3);
                        v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 160, 8);
                        ArcSharedObject::ArcSharedObject((ArcSharedObject *)v5, 0);
                        *(_QWORD *)v5 = &off_24E071090;
                        *(_QWORD *)(v5 + 24) = a1;
                        v6 = v2;
                        v7 = *(_QWORD *)(v5 + 24);
                        *(_QWORD *)(v5 + 32) = 0;
                        *(_DWORD *)(v5 + 40) = 0;
                        *(_QWORD *)(v5 + 48) = 850045863;
                        *(_OWORD *)(v5 + 88) = 0u;
                        *(_OWORD *)(v5 + 72) = 0u;
                        *(_OWORD *)(v5 + 56) = 0u;
                        *(_QWORD *)(v5 + 104) = 0;
                        *(_QWORD *)(v5 + 112) = 1018212795;
                        *(_OWORD *)(v5 + 120) = 0u;
                        *(_OWORD *)(v5 + 136) = 0u;
                        *(_QWORD *)(v5 + 152) = 0;
                        v8 = *(_QWORD *)(v7 + 24);
                        if (v8)
                          (*(void (**)(void))(v8 + 16))();

                        goto LABEL_17;
                      }
                      v11 = *re::networkLogObjects(v3);
                      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                      {
                        v12 = 136315394;
                        v13 = "RESyncCustomProtocolLayerCreate";
                        v14 = 2080;
                        v15 = "RESyncProtocolLayerObserverOnPreferredPacketSize() observer implementation is required.";
                        goto LABEL_44;
                      }
LABEL_45:
                      v5 = 0;
LABEL_17:

                      return v5;
                    }
                    v11 = *re::networkLogObjects(v3);
                    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                      goto LABEL_45;
                    v12 = 136315394;
                    v13 = "RESyncCustomProtocolLayerCreate";
                    v14 = 2080;
                    v15 = "RESyncProtocolLayerObserverOnSetDisconnectTimeout() observer implementation is required.";
                  }
                  else
                  {
                    v11 = *re::networkLogObjects(v3);
                    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                      goto LABEL_45;
                    v12 = 136315394;
                    v13 = "RESyncCustomProtocolLayerCreate";
                    v14 = 2080;
                    v15 = "RESyncProtocolLayerObserverOnHostStats() observer implementation is required.";
                  }
                }
                else
                {
                  v11 = *re::networkLogObjects(v3);
                  if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                    goto LABEL_45;
                  v12 = 136315394;
                  v13 = "RESyncCustomProtocolLayerCreate";
                  v14 = 2080;
                  v15 = "RESyncProtocolLayerObserverOnLocalAddresses() observer implementation is required.";
                }
              }
              else
              {
                v11 = *re::networkLogObjects(v3);
                if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                  goto LABEL_45;
                v12 = 136315394;
                v13 = "RESyncCustomProtocolLayerCreate";
                v14 = 2080;
                v15 = "None or both RESyncProtocolLayerObserverOnWait() and RESyncProtocolLayerObserverOnWakeup() observe"
                      "r implementations are required.";
              }
            }
            else
            {
              v11 = *re::networkLogObjects(v3);
              if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                goto LABEL_45;
              v12 = 136315394;
              v13 = "RESyncCustomProtocolLayerCreate";
              v14 = 2080;
              v15 = "RESyncProtocolLayerObserverOnDisconnect() observer implementation is required.";
            }
          }
          else
          {
            v11 = *re::networkLogObjects(v3);
            if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
              goto LABEL_45;
            v12 = 136315394;
            v13 = "RESyncCustomProtocolLayerCreate";
            v14 = 2080;
            v15 = "RESyncProtocolLayerObserverOnClose() observer implementation is required.";
          }
        }
        else
        {
          v11 = *re::networkLogObjects(v3);
          if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            goto LABEL_45;
          v12 = 136315394;
          v13 = "RESyncCustomProtocolLayerCreate";
          v14 = 2080;
          v15 = "Either RESyncProtocolLayerObserverOnOpen() or RESyncProtocolLayerObserverOnOpenNullable() observer imple"
                "mentation is required.";
        }
      }
      else
      {
        v11 = *re::networkLogObjects(v3);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          goto LABEL_45;
        v12 = 136315394;
        v13 = "RESyncCustomProtocolLayerCreate";
        v14 = 2080;
        v15 = "RESyncProtocolLayerObserverOnDeinit() observer implementation is required.";
      }
    }
    else
    {
      v11 = *re::networkLogObjects(v3);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        goto LABEL_45;
      v12 = 136315394;
      v13 = "RESyncCustomProtocolLayerCreate";
      v14 = 2080;
      v15 = "Either RESyncProtocolLayerObserverOnInit() or RESyncProtocolLayerObserverOnInitWithConfig() observer impleme"
            "ntation is required.";
    }
LABEL_44:
    _os_log_error_impl(&dword_21C69B000, v11, OS_LOG_TYPE_ERROR, "%s: %s", (uint8_t *)&v12, 0x16u);
    goto LABEL_45;
  }
  v10 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    v12 = 136315394;
    v13 = "RESyncCustomProtocolLayerCreate";
    v14 = 2080;
    v15 = "observer != __null";
    _os_log_error_impl(&dword_21C69B000, v10, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v12, 0x16u);
  }
  return 0;
}

void RESyncCustomProtocolLayerSetThreadModeDispatchTransport(uint64_t a1)
{
  NSObject *v1;
  int v2;
  const char *v3;
  __int16 v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_DWORD *)(a1 + 40) = 2;
  }
  else
  {
    v1 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      v2 = 136315394;
      v3 = "RESyncCustomProtocolLayerSetThreadModeDispatchTransport";
      v4 = 2080;
      v5 = "protocolLayer != __null";
      _os_log_error_impl(&dword_21C69B000, v1, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v2, 0x16u);
    }
  }
}

void RESyncCustomProtocolLayerOnConnected(re *a1, uint64_t a2, const char *a3)
{
  void (***v5)(_QWORD, re *, uint64_t, uint8_t *);
  NSObject *v7;
  uint64_t v8;
  char v9;
  uint8_t buf[40];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "RESyncCustomProtocolLayerOnConnected";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "protocolLayer != __null";
    goto LABEL_16;
  }
  if (!a2)
  {
    v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "RESyncCustomProtocolLayerOnConnected";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "handle != __null";
LABEL_16:
    _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return;
  }
  v5 = (void (***)(_QWORD, re *, uint64_t, uint8_t *))*((_QWORD *)a1 + 4);
  if (v5)
  {
    re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)&v8);
    (**v5)(v5, a1, a2, buf);
    if (*(_QWORD *)buf)
    {
      if ((buf[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)buf + 40))();
      memset(buf, 0, 32);
    }
    if (v8)
    {
      if ((v9 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
  }
}

void RESyncCustomProtocolLayerOnDisconnected(re *a1, uint64_t a2, const char *a3)
{
  uint64_t v5;
  NSObject *v7;
  uint64_t v8;
  char v9;
  uint8_t buf[40];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "RESyncCustomProtocolLayerOnDisconnected";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "protocolLayer != __null";
    goto LABEL_16;
  }
  if (!a2)
  {
    v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "RESyncCustomProtocolLayerOnDisconnected";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "handle != __null";
LABEL_16:
    _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return;
  }
  v5 = *((_QWORD *)a1 + 4);
  if (v5)
  {
    re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)&v8);
    (*(void (**)(uint64_t, re *, uint64_t, uint8_t *))(*(_QWORD *)v5 + 8))(v5, a1, a2, buf);
    if (*(_QWORD *)buf)
    {
      if ((buf[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)buf + 40))();
      memset(buf, 0, 32);
    }
    if (v8)
    {
      if ((v9 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
  }
}

void RESyncCustomProtocolLayerOnError(re *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnError";
    v10 = 2080;
    v11 = "protocolLayer != __null";
    goto LABEL_10;
  }
  if (!a2)
  {
    v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnError";
    v10 = 2080;
    v11 = "handle != __null";
LABEL_10:
    _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    return;
  }
  v6 = *((_QWORD *)a1 + 4);
  if (v6)
    (*(void (**)(uint64_t, re *, uint64_t, uint64_t))(*(_QWORD *)v6 + 16))(v6, a1, a2, a3);
}

void RESyncCustomProtocolLayerOnReceiveData(re *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnReceiveData";
    v10 = 2080;
    v11 = "protocolLayer != __null";
    goto LABEL_13;
  }
  if (!a2)
  {
    v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnReceiveData";
    v10 = 2080;
    v11 = "fromHandle != __null";
    goto LABEL_13;
  }
  if (a3 >= 0xA)
  {
    v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnReceiveData";
    v10 = 2080;
    v11 = "channel < kRESyncChannelIdMaxChannels";
LABEL_13:
    _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    return;
  }
  v6 = *((_QWORD *)a1 + 4);
  if (v6)
    (*(void (**)(uint64_t, re *, uint64_t))(*(_QWORD *)v6 + 24))(v6, a1, a2);
}

void RESyncCustomProtocolLayerOnReceiveDataNoAsync(re *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnReceiveDataNoAsync";
    v10 = 2080;
    v11 = "protocolLayer != __null";
    goto LABEL_13;
  }
  if (!a2)
  {
    v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnReceiveDataNoAsync";
    v10 = 2080;
    v11 = "fromHandle != __null";
    goto LABEL_13;
  }
  if (a3 >= 0xA)
  {
    v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    v8 = 136315394;
    v9 = "RESyncCustomProtocolLayerOnReceiveDataNoAsync";
    v10 = 2080;
    v11 = "channel < kRESyncChannelIdMaxChannels";
LABEL_13:
    _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    return;
  }
  v6 = *((_QWORD *)a1 + 4);
  if (v6)
    (*(void (**)(uint64_t, re *, uint64_t))(*(_QWORD *)v6 + 32))(v6, a1, a2);
}

void RESyncCustomProtocolLayerOnReceive(re *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  RESyncCustomProtocolLayerOnReceiveData(a1, a2, a3);
  *a6 = 1;
}

void RESyncCustomProtocolLayerOnUnresponsive(re *a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncCustomProtocolLayerOnUnresponsive";
    v8 = 2080;
    v9 = "protocolLayer != __null";
    goto LABEL_10;
  }
  if (!a2)
  {
    v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncCustomProtocolLayerOnUnresponsive";
    v8 = 2080;
    v9 = "handle != __null";
LABEL_10:
    _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  v4 = *((_QWORD *)a1 + 4);
  if (v4)
    (*(void (**)(uint64_t, re *, uint64_t))(*(_QWORD *)v4 + 40))(v4, a1, a2);
}

void RESyncCustomProtocolLayerOnResponsive(re *a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncCustomProtocolLayerOnResponsive";
    v8 = 2080;
    v9 = "protocolLayer != __null";
    goto LABEL_10;
  }
  if (!a2)
  {
    v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncCustomProtocolLayerOnResponsive";
    v8 = 2080;
    v9 = "handle != __null";
LABEL_10:
    _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  v4 = *((_QWORD *)a1 + 4);
  if (v4)
    (*(void (**)(uint64_t, re *, uint64_t))(*(_QWORD *)v4 + 48))(v4, a1, a2);
}

char *RESyncPacketPoolAllocPacket(re::PacketPool *a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return re::PacketPool::allocate(a1, a2);
  v3 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v4 = 136315394;
    v5 = "RESyncPacketPoolAllocPacket";
    v6 = 2080;
    v7 = "pool != __null";
    _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v4, 0x16u);
  }
  return 0;
}

void RESyncPacketPoolFreePacket(re::PacketPool *a1, re::Packet *a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v2 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      return;
    v3 = 136315394;
    v4 = "RESyncPacketPoolFreePacket";
    v5 = 2080;
    v6 = "pool != __null";
LABEL_9:
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return;
  }
  if (a2)
  {
    re::PacketPool::free(a1, a2);
    return;
  }
  v2 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncPacketPoolFreePacket";
    v5 = 2080;
    v6 = "packet != __null";
    goto LABEL_9;
  }
}

_anonymous_namespace_::AddressList *RESyncAddressListCreate(re *a1, uint64_t a2)
{
  uint64_t *v4;
  _anonymous_namespace_::AddressList *v5;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1 && a2)
  {
    v7 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = 136315394;
      v9 = "RESyncAddressListCreate";
      v10 = 2080;
      v11 = "addresses != __null || addressesCount == 0";
      _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    }
    return 0;
  }
  else
  {
    v4 = re::globalAllocators(a1);
    v5 = (_anonymous_namespace_::AddressList *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 64, 8);
  }
}

_anonymous_namespace_::AddressList *RESyncAddressListCreateWithAddress(char *a1)
{
  uint64_t *v1;
  _anonymous_namespace_::AddressList *v2;
  NSObject *v4;
  char *v5;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  if (a1)
  {
    v1 = re::globalAllocators((re *)a1);
    v2 = (_anonymous_namespace_::AddressList *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 64, 8);
  }
  else
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v7 = "RESyncAddressListCreateWithAddress";
      v8 = 2080;
      v9 = "address != __null";
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
    return 0;
  }
}

uint64_t RESyncAddressListGetAddressAtIndex(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncAddressListGetAddressAtIndex";
      v7 = 2080;
      v8 = "addressList != __null";
      _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
    return 0;
  }
  if (*(_QWORD *)(a1 + 40) <= a2)
    return 0;
  v2 = *(_QWORD *)(a1 + 56) + 32 * a2;
  if ((*(_BYTE *)(v2 + 8) & 1) != 0)
    return *(_QWORD *)(v2 + 16);
  else
    return v2 + 9;
}

uint64_t RESyncAddressListGetSize(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 40);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncAddressListGetSize";
    v5 = 2080;
    v6 = "addressList != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncPacketGetData(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 16);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncPacketGetData";
    v5 = 2080;
    v6 = "packet != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncPacketGetSize(uint64_t a1)
{
  uint64_t result;
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(unsigned int *)(a1 + 24);
  v2 = *re::networkLogObjects(0);
  result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    v3 = 136315394;
    v4 = "RESyncPacketGetSize";
    v5 = 2080;
    v6 = "packet != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  return result;
}

void RESyncPacketSetSize(uint64_t a1, int a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_DWORD *)(a1 + 24) = a2;
  }
  else
  {
    v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136315394;
      v4 = "RESyncPacketSetSize";
      v5 = 2080;
      v6 = "packet != __null";
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncPacketGetCapacity(uint64_t a1)
{
  uint64_t result;
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(unsigned int *)(a1 + 28);
  v2 = *re::networkLogObjects(0);
  result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    v3 = 136315394;
    v4 = "RESyncPacketGetCapacity";
    v5 = 2080;
    v6 = "packet != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  return result;
}

uint64_t RESyncPacketGetDeliveryMethod(uint64_t a1)
{
  uint64_t result;
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(unsigned int *)(a1 + 32);
  v2 = *re::networkLogObjects(0);
  result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    v3 = 136315394;
    v4 = "RESyncPacketGetDeliveryMethod";
    v5 = 2080;
    v6 = "packet != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  return result;
}

re::ProtocolHandle *RESyncProtocolHandleCreate(re *a1)
{
  uint64_t *v1;
  void *v2;

  v1 = re::globalAllocators(a1);
  v2 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 1768, 8);
  bzero(v2, 0x6E8uLL);
  return re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v2);
}

uint64_t RESyncProtocolHandleGetConnection(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 24);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncProtocolHandleGetConnection";
    v5 = 2080;
    v6 = "handle != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncProtocolHandleConnectionSetStats(uint64_t a1, int *a2)
{
  int v3;
  int v4;
  os_unfair_lock_s *v5;
  NSObject *v6;
  __int128 v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136315394;
    v9 = "RESyncProtocolHandleConnectionSetStats";
    v10 = 2080;
    v11 = "handle != __null";
LABEL_9:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return;
  }
  if (a2)
  {
    v3 = *a2;
    v4 = a2[1];
    v5 = (os_unfair_lock_s *)(a1 + 1760);
    v7 = *(_OWORD *)(a2 + 2);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1760));
    *(_DWORD *)(a1 + 1736) = v3;
    *(_DWORD *)(a1 + 1740) = v4;
    *(_OWORD *)(a1 + 1744) = v7;
    os_unfair_lock_unlock(v5);
    return;
  }
  v6 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    v9 = "RESyncProtocolHandleConnectionSetStats";
    v10 = 2080;
    v11 = "stats != __null";
    goto LABEL_9;
  }
}

void RESyncProtocolHandleConnectionGetStats(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  os_unfair_lock_s *v4;
  int v5;
  int v6;
  NSObject *v7;
  __int128 v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 1760);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1760));
    v5 = *(_DWORD *)(a1 + 1736);
    v6 = *(_DWORD *)(a1 + 1740);
    v8 = *(_OWORD *)(a1 + 1744);
    os_unfair_lock_unlock(v4);
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v6;
    *(_OWORD *)(a2 + 8) = v8;
  }
  else
  {
    v7 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v10 = "RESyncProtocolHandleConnectionGetStats";
      v11 = 2080;
      v12 = "handle != __null";
      _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
}

uint64_t RESyncProtocolHandleGetUserData(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 1728);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncProtocolHandleGetUserData";
    v5 = 2080;
    v6 = "handle != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncProtocolHandleSetUserData(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_QWORD *)(a1 + 1728) = a2;
  }
  else
  {
    v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136315394;
      v4 = "RESyncProtocolHandleSetUserData";
      v5 = 2080;
      v6 = "handle != __null";
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncGetChannelIdMaxChannels()
{
  return 10;
}

unint64_t *RESyncProtocolHandleQueueDeqeue(re *a1, unsigned int a2, unsigned int a3)
{
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolHandleQueueDeqeue";
      v7 = 2080;
      v8 = "handle != __null";
      goto LABEL_15;
    }
    return 0;
  }
  if (a3 >= 0xA)
  {
    v4 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315394;
      v6 = "RESyncProtocolHandleQueueDeqeue";
      v7 = 2080;
      v8 = "channelId < kRESyncChannelIdMaxChannels";
      goto LABEL_15;
    }
    return 0;
  }
  if (a2 >= 2)
  {
    v4 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return 0;
    v5 = 136315394;
    v6 = "RESyncProtocolHandleQueueDeqeue";
    v7 = 2080;
    v8 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
LABEL_15:
    _os_log_error_impl(&dword_21C69B000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    return 0;
  }
  if (a2)
    return re::PacketQueue::dequeue((unint64_t **)a1 + 5 * a3 + 164);
  else
    return re::PacketQueue::dequeue((unint64_t **)a1 + 5 * a3 + 114);
}

void RESyncProtocolHandleQueueEnqeue(re *a1, unsigned int a2, unsigned int a3, unint64_t a4)
{
  int v4;
  char *v5;
  unint64_t **v6;
  unsigned int *v7;
  unsigned int v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  NSObject *v21;
  int v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v21 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      return;
    v22 = 136315394;
    v23 = "RESyncProtocolHandleQueueEnqeue";
    v24 = 2080;
    v25 = "handle != __null";
    goto LABEL_29;
  }
  if (a3 >= 0xA)
  {
    v21 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      return;
    v22 = 136315394;
    v23 = "RESyncProtocolHandleQueueEnqeue";
    v24 = 2080;
    v25 = "channelId < kRESyncChannelIdMaxChannels";
    goto LABEL_29;
  }
  if (a2 >= 2)
  {
    v21 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      return;
    v22 = 136315394;
    v23 = "RESyncProtocolHandleQueueEnqeue";
    v24 = 2080;
    v25 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
    goto LABEL_29;
  }
  if (!a4)
  {
    v21 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      return;
    v22 = 136315394;
    v23 = "RESyncProtocolHandleQueueEnqeue";
    v24 = 2080;
    v25 = "_packet != __null";
LABEL_29:
    _os_log_error_impl(&dword_21C69B000, v21, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v22, 0x16u);
    return;
  }
  v4 = *(_DWORD *)(a4 + 24);
  v5 = (char *)a1 + 40 * a3;
  if (a2)
  {
    v6 = (unint64_t **)(v5 + 1312);
    v7 = (unsigned int *)(v5 + 1336);
    do
      v8 = __ldxr(v7);
    while (__stlxr(v8 + v4, v7));
    v9 = (unint64_t *)((char *)a1 + 40 * a3 + 1344);
    v10 = *(unsigned int *)(a4 + 28);
    do
      v11 = __ldxr(v9);
    while (__stlxr(v11 + v10, v9));
    v12 = (unint64_t *)((char *)a1 + 40 * a3 + 1328);
    do
      v13 = __ldxr(v12);
    while (__stlxr(v13 + 1, v12));
  }
  else
  {
    v6 = (unint64_t **)(v5 + 912);
    v14 = (unsigned int *)(v5 + 936);
    do
      v15 = __ldxr(v14);
    while (__stlxr(v15 + v4, v14));
    v16 = (unint64_t *)((char *)a1 + 40 * a3 + 944);
    v17 = *(unsigned int *)(a4 + 28);
    do
      v18 = __ldxr(v16);
    while (__stlxr(v18 + v17, v16));
    v19 = (unint64_t *)((char *)a1 + 40 * a3 + 928);
    do
      v20 = __ldxr(v19);
    while (__stlxr(v20 + 1, v19));
  }
  atomic_store(a4, *v6);
  *v6 = (unint64_t *)a4;
}

uint64_t RESyncProtocolHandleQueueGetSizeInBytes(re *a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t result;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v9 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return 0;
    v10 = 136315394;
    v11 = "RESyncProtocolHandleQueueGetSizeInBytes";
    v12 = 2080;
    v13 = "handle != __null";
LABEL_15:
    _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v10, 0x16u);
    return 0;
  }
  if (a2 >= 2)
  {
    v9 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return 0;
    v10 = 136315394;
    v11 = "RESyncProtocolHandleQueueGetSizeInBytes";
    v12 = 2080;
    v13 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
    goto LABEL_15;
  }
  v3 = 0;
  result = 0;
  if (a2)
  {
    v5 = (char *)a1 + 1336;
    do
    {
      v6 = atomic_load((unsigned int *)&v5[v3]);
      result += v6;
      v3 += 40;
    }
    while (v3 != 400);
  }
  else
  {
    v7 = (char *)a1 + 936;
    do
    {
      v8 = atomic_load((unsigned int *)&v7[v3]);
      result += v8;
      v3 += 40;
    }
    while (v3 != 400);
  }
  return result;
}

uint64_t RESyncProtocolHandleQueueGetCapacityInBytes(re *a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t result;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  NSObject *v9;
  int v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v9 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return 0;
    v10 = 136315394;
    v11 = "RESyncProtocolHandleQueueGetCapacityInBytes";
    v12 = 2080;
    v13 = "handle != __null";
LABEL_15:
    _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v10, 0x16u);
    return 0;
  }
  if (a2 >= 2)
  {
    v9 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return 0;
    v10 = 136315394;
    v11 = "RESyncProtocolHandleQueueGetCapacityInBytes";
    v12 = 2080;
    v13 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
    goto LABEL_15;
  }
  v3 = 0;
  result = 0;
  if (a2)
  {
    v5 = (char *)a1 + 1344;
    do
    {
      v6 = atomic_load((unint64_t *)&v5[v3]);
      result += v6;
      v3 += 40;
    }
    while (v3 != 400);
  }
  else
  {
    v7 = (char *)a1 + 944;
    do
    {
      v8 = atomic_load((unint64_t *)&v7[v3]);
      result += v8;
      v3 += 40;
    }
    while (v3 != 400);
  }
  return result;
}

unint64_t RESyncProtocolHandleQueueGetSize(re *a1, unsigned int a2, unsigned int a3)
{
  char *v3;
  unint64_t *v4;
  NSObject *v6;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v6 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = 136315394;
      v8 = "RESyncProtocolHandleQueueGetSize";
      v9 = 2080;
      v10 = "handle != __null";
      goto LABEL_16;
    }
    return 0;
  }
  if (a3 >= 0xA)
  {
    v6 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = 136315394;
      v8 = "RESyncProtocolHandleQueueGetSize";
      v9 = 2080;
      v10 = "channelId < kRESyncChannelIdMaxChannels";
      goto LABEL_16;
    }
    return 0;
  }
  if (a2 >= 2)
  {
    v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    v7 = 136315394;
    v8 = "RESyncProtocolHandleQueueGetSize";
    v9 = 2080;
    v10 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
LABEL_16:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v7, 0x16u);
    return 0;
  }
  v3 = (char *)a1 + 40 * a3;
  if (a2)
    v4 = (unint64_t *)(v3 + 1328);
  else
    v4 = (unint64_t *)(v3 + 928);
  return atomic_load(v4);
}

re::ProtocolHandle *re::ProtocolHandle::ProtocolHandle(re::ProtocolHandle *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E071238;
  *((_QWORD *)this + 3) = 0;
  v3 = 32;
  do
  {
    v4 = (uint64_t *)((char *)this + v3);
    *v4 = 0;
    v4[1] = 0;
    v5 = re::globalAllocators((re *)v2);
    v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 64, 64);
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 32) = 0;
    *(_QWORD *)(v2 + 48) = 0;
    *(_QWORD *)(v2 + 56) = 0;
    *(_QWORD *)(v2 + 40) = 0;
    *v4 = v2;
    v4[1] = v2;
    atomic_store(0, (unsigned int *)((char *)this + v3 + 24));
    atomic_store(0, (unint64_t *)((char *)this + v3 + 16));
    v3 += 40;
    atomic_store(0, (unint64_t *)v4 + 4);
  }
  while (v4 + 5 != (uint64_t *)((char *)this + 432));
  v6 = 432;
  do
  {
    v7 = (char *)this + v6;
    *((_DWORD *)v7 + 8) = 0;
    *(_OWORD *)v7 = 0uLL;
    *((_OWORD *)v7 + 1) = 0uLL;
    *(_QWORD *)(v7 + 36) = 0x7FFFFFFFLL;
    v6 += 48;
  }
  while (v7 + 48 != (char *)this + 912);
  v8 = 912;
  do
  {
    v9 = (uint64_t *)((char *)this + v8);
    *v9 = 0;
    v9[1] = 0;
    v10 = re::globalAllocators((re *)v2);
    v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 64, 64);
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 32) = 0;
    *(_QWORD *)(v2 + 48) = 0;
    *(_QWORD *)(v2 + 56) = 0;
    *(_QWORD *)(v2 + 40) = 0;
    *v9 = v2;
    v9[1] = v2;
    atomic_store(0, (unsigned int *)((char *)this + v8 + 24));
    atomic_store(0, (unint64_t *)((char *)this + v8 + 16));
    v8 += 40;
    atomic_store(0, (unint64_t *)v9 + 4);
  }
  while (v9 + 5 != (uint64_t *)((char *)this + 1312));
  v11 = (uint64_t *)((char *)this + 1712);
  v12 = 1312;
  do
  {
    v13 = (uint64_t *)((char *)this + v12);
    *v13 = 0;
    v13[1] = 0;
    v14 = re::globalAllocators((re *)v2);
    v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14[2] + 32))(v14[2], 64, 64);
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 32) = 0;
    *(_QWORD *)(v2 + 48) = 0;
    *(_QWORD *)(v2 + 56) = 0;
    *(_QWORD *)(v2 + 40) = 0;
    *v13 = v2;
    v13[1] = v2;
    atomic_store(0, (unsigned int *)((char *)this + v12 + 24));
    atomic_store(0, (unint64_t *)((char *)this + v12 + 16));
    v12 += 40;
    atomic_store(0, (unint64_t *)v13 + 4);
  }
  while (v13 + 5 != v11);
  *((_QWORD *)this + 220) = 0;
  *((_QWORD *)this + 215) = 0;
  *((_QWORD *)this + 216) = 0;
  *v11 = 0;
  return this;
}

void re::ProtocolHandle::~ProtocolHandle(re::ProtocolHandle *this)
{
  re::ProtocolHandle::~ProtocolHandle(this);
  JUMPOUT(0x220780CD0);
}

{
  re::ProtocolHandle *v1;
  uint64_t i;
  _QWORD *v3;
  uint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t j;
  re *v10;
  uint64_t k;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;

  v1 = this;
  *(_QWORD *)this = &off_24E071238;
  for (i = 1672; i != 1272; i -= 40)
  {
    v3 = (_QWORD *)((char *)v1 + i);
    v4 = *(_QWORD *)((char *)v1 + i);
    if (v4)
    {
      v5 = re::globalAllocators(this);
      this = (re::ProtocolHandle *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5[2] + 40))(v5[2], v4);
    }
    *v3 = 0;
    v3[1] = 0;
  }
  do
  {
    v6 = (_QWORD *)((char *)v1 + i);
    v7 = *(_QWORD *)((char *)v1 + i);
    if (v7)
    {
      v8 = re::globalAllocators(this);
      this = (re::ProtocolHandle *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v8[2] + 40))(v8[2], v7);
    }
    *v6 = 0;
    v6[1] = 0;
    i -= 40;
  }
  while (i != 872);
  for (j = 864; j != 384; j -= 48)
    re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)((char *)v1 + j));
  for (k = 392; k != -8; k -= 40)
  {
    v12 = (_QWORD *)((char *)v1 + k);
    v13 = *(_QWORD *)((char *)v1 + k);
    if (v13)
    {
      v14 = re::globalAllocators(v10);
      v10 = (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v14[2] + 40))(v14[2], v13);
    }
    *v12 = 0;
    v12[1] = 0;
  }
  *(_QWORD *)v1 = &off_24E0707C0;
  objc_destructInstance((char *)v1 + 8);
}

double re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 80;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1;
  _QWORD *v2;
  uint64_t v3;

  v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    v2 = (_QWORD *)result;
    *(_DWORD *)(result + 8) = v1 & 0x7FFFFFFF;
    v3 = *(_QWORD *)(result + 40);
    if (v3)
    {
      if (v2[6])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, v2[7]);
        v2[6] = 0;
        v2[7] = 0;
      }
      v2[5] = 0;
    }
    result = v2[2];
    if (result)
    {
      if (v2[3])
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, v2[4]);
        v2[3] = 0;
        v2[4] = 0;
      }
      v2[2] = 0;
    }
  }
  return result;
}

void `anonymous namespace'::ProtocolLayerObserver::~ProtocolLayerObserver(const void **this)
{
  *this = &off_24E071048;
  _Block_release(this[3]);
  _Block_release(this[4]);
  _Block_release(this[5]);
  _Block_release(this[6]);
  _Block_release(this[7]);
  _Block_release(this[8]);
  _Block_release(this[9]);
  _Block_release(this[10]);
  _Block_release(this[11]);
  _Block_release(this[12]);
  _Block_release(this[13]);
  _Block_release(this[14]);
  _Block_release(this[15]);
  _Block_release(this[16]);
  _Block_release(this[17]);
  _Block_release(this[18]);
  _Block_release(this[19]);
  _Block_release(this[20]);
  *this = &off_24E0707C0;
  objc_destructInstance(this + 1);
}

{
  JUMPOUT(0x220780CD0);
}

void `anonymous namespace'::SyncCustomProtocolLayer::~SyncCustomProtocolLayer(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(*((_QWORD *)this + 3) + 32);
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 112));
  std::mutex::~mutex((std::mutex *)((char *)this + 48));
  v3 = *((_QWORD *)this + 3);
  if (v3)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  JUMPOUT(0x220780CD0);
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::init(re *a1, int8x16_t *a2)
{
  uint64_t v3;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *((_QWORD *)a1 + 3);
  if (!*(_QWORD *)(v3 + 48))
    return (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 40) + 16))();
  v5 = re::globalAllocators(a1);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 40, 8);
  *(_OWORD *)v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_QWORD *)(v6 + 32) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v6, 0);
  *(_QWORD *)v6 = &off_24E071158;
  *(int8x16_t *)(v6 + 24) = vextq_s8(*a2, *a2, 8uLL);
  v7 = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)a1 + 3) + 48) + 16))();

  return v7;
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::deinit(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 56) + 16))();
  *((_QWORD *)this + 4) = 0;
  return result;
}

char *`anonymous namespace'::SyncCustomProtocolLayer::open@<X0>(_anonymous_namespace_::SyncCustomProtocolLayer *this@<X0>, const Address *a2@<X1>, char **a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  char *var1;
  char *result;

  v4 = *((_QWORD *)this + 3);
  v5 = *(_QWORD *)(v4 + 64);
  if (!v5)
    v5 = *(_QWORD *)(v4 + 72);
  if ((a2->var0.var1.var0.var0.var1 & 1) != 0)
    var1 = a2->var0.var1.var0.var1;
  else
    var1 = a2->var0.var1.var1.var2;
  result = (char *)(*(uint64_t (**)(uint64_t, char *))(v5 + 16))(v5, var1);
  *a3 = result;
  if (result)
    return result + 8;
  return result;
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::close(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 80) + 16))();
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::disconnect(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 88) + 16))();
}

BOOL `anonymous namespace'::SyncCustomProtocolLayer::drainsPacketSink(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 3) + 96) != 0;
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::send(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t);
  void *v8;
  uint64_t v9;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 96);
  v5 = MEMORY[0x24BDAC760];
  v6 = 0x40000000;
  v7 = ___ZN12_GLOBAL__N_123SyncCustomProtocolLayer4sendEPN2re14ProtocolHandleERNS2_10PacketSinkE_block_invoke;
  v8 = &__block_descriptor_tmp_2;
  v9 = a3;
  return (*(uint64_t (**)(void))(v3 + 16))();
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::update(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t result;

  result = *(_QWORD *)(*((_QWORD *)this + 3) + 104);
  if (result)
    return (*(uint64_t (**)(void))(result + 16))();
  return result;
}

void `anonymous namespace'::SyncCustomProtocolLayer::wait(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t v2;
  std::unique_lock<std::mutex> v3;

  v2 = *(_QWORD *)(*((_QWORD *)this + 3) + 112);
  if (v2)
  {
    (*(void (**)(void))(v2 + 16))();
  }
  else
  {
    v3.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 48);
    v3.__owns_ = 1;
    std::mutex::lock((std::mutex *)((char *)this + 48));
    std::condition_variable::wait((std::condition_variable *)((char *)this + 112), &v3);
    if (v3.__owns_)
      std::mutex::unlock(v3.__m_);
  }
}

void `anonymous namespace'::SyncCustomProtocolLayer::wakeup(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t v2;

  v2 = *(_QWORD *)(*((_QWORD *)this + 3) + 120);
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  else
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 112));
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::setListener(_anonymous_namespace_::SyncCustomProtocolLayer *this, ProtocolLayerListener *a2)
{
  uint64_t result;

  *((_QWORD *)this + 4) = a2;
  result = *(_QWORD *)(*((_QWORD *)this + 3) + 160);
  if (result)
    return (*(uint64_t (**)(void))(result + 16))();
  return result;
}

unint64_t `anonymous namespace'::SyncCustomProtocolLayer::localAddresses(_anonymous_namespace_::SyncCustomProtocolLayer *this, re::Address *a2, unint64_t a3)
{
  uint64_t v5;
  unint64_t Size;
  unint64_t v7;
  unint64_t i;
  _anonymous_namespace_ *AddressAtIndex;
  uint64_t v11;
  char v12;
  _OWORD v13[2];

  v5 = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 128) + 16))();
  Size = RESyncAddressListGetSize(v5);
  v7 = Size;
  if (a2)
  {
    if (Size >= a3)
      v7 = a3;
    if (v7)
    {
      for (i = 0; i != v7; ++i)
      {
        AddressAtIndex = (_anonymous_namespace_ *)RESyncAddressListGetAddressAtIndex(v5, i);
        re::DynamicString::DynamicString((re::DynamicString *)v13, (const re::DynamicString *)&v11);
        re::DynamicString::operator=(a2, (re::DynamicString *)v13);
        if (*(_QWORD *)&v13[0])
        {
          if ((BYTE8(v13[0]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v13[0] + 40))();
          memset(v13, 0, sizeof(v13));
        }
        if (v11 && (v12 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
        a2 = (re::Address *)((char *)a2 + 32);
      }
    }
  }

  return v7;
}

double `anonymous namespace'::SyncCustomProtocolLayer::hostStats(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v4;
  __int128 v5;

  v5 = 0uLL;
  v4 = 0;
  if ((*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 136) + 16))())
  {
    *(_QWORD *)a2 = v4;
    result = *(double *)&v5;
    *(_OWORD *)(a2 + 8) = v5;
  }
  return result;
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::setDisconnectTimeout(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 144) + 16))();
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::preferredPacketSize(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 152) + 16))();
}

uint64_t `anonymous namespace'::SyncCustomProtocolLayer::preferredThreadMode(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return *((unsigned int *)this + 10);
}

void `anonymous namespace'::CustomProtocolLayerConfig::~CustomProtocolLayerConfig(_anonymous_namespace_::CustomProtocolLayerConfig *this)
{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

void ___ZN12_GLOBAL__N_123SyncCustomProtocolLayer4sendEPN2re14ProtocolHandleERNS2_10PacketSinkE_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  re::PacketPool **v8;
  uint64_t v9;

  v2 = *(unsigned __int8 **)(a1 + 32);
  v3 = *(_QWORD *)v2;
  if (*(_QWORD *)v2 != *((_QWORD *)v2 + 1))
  {
    do
    {
      v5 = atomic_load(*(unint64_t **)(v3 + 8));
      v6 = atomic_load((unint64_t *)(*(_QWORD *)v2 + 16));
      if (v5)
      {
        v7 = v6 + 1;
        do
        {
          if (!--v7)
            break;
          if (!(*(unsigned int (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a2 + 16))(a2, v2[16], *(_QWORD *)(v5 + 16), *(unsigned int *)(v5 + 24), *(unsigned int *)(v5 + 32)))return;
          v8 = (re::PacketPool **)re::PacketQueue::dequeue(*(unint64_t ***)v2);
          re::PacketPool::free(v8[7], (re::Packet *)v8);
          v5 = atomic_load(*(unint64_t **)(*(_QWORD *)v2 + 8));
        }
        while (v5);
      }
      v9 = *((_QWORD *)v2 + 1);
      v3 = *(_QWORD *)v2 + 40;
      *(_QWORD *)v2 = v3;
      ++v2[16];
    }
    while (v3 != v9);
  }
}

_anonymous_namespace_::AddressList *`anonymous namespace'::AddressList::AddressList(_anonymous_namespace_::AddressList *this, const char **a2, uint64_t a3)
{
  _anonymous_namespace_ *v6;
  const char *v7;
  _anonymous_namespace_ *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _anonymous_namespace_ *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E0711C0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  for (*((_DWORD *)this + 12) = 0; a3; --a3)
  {
    v7 = *a2;
    if (*a2)
    {
      v9 = *((_QWORD *)this + 4);
      v10 = *((_QWORD *)this + 5);
      if (v10 >= v9)
      {
        v11 = v10 + 1;
        if (v9 < v10 + 1)
        {
          if (*((_QWORD *)this + 3))
          {
            if (v9)
              v12 = 2 * v9;
            else
              v12 = 8;
            if (v12 <= v11)
              v13 = v10 + 1;
            else
              v13 = v12;
            re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)this + 3, v13);
          }
          else
          {
            re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)this + 3, v11);
            ++*((_DWORD *)this + 12);
          }
        }
        v10 = *((_QWORD *)this + 5);
      }
      v14 = *((_QWORD *)this + 7) + 32 * v10;
      *(_OWORD *)v14 = 0u;
      *(_OWORD *)(v14 + 16) = 0u;
      *(_QWORD *)v14 = v18;
      v18 = 0;
      v15 = *(_QWORD *)(v14 + 16);
      *(_QWORD *)(v14 + 16) = v20;
      v20 = v15;
      *(_QWORD *)(v14 + 24) = v21;
      v21 = 0;
      v16 = *(_QWORD *)(v14 + 8);
      *(_QWORD *)(v14 + 8) = v19;
      v19 = v16;
      ++*((_QWORD *)this + 5);
      ++*((_DWORD *)this + 12);
      v6 = v18;
      if (v18 && (v16 & 1) != 0)
        v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v18 + 40))();
    }
    ++a2;
  }
  return this;
}

void `anonymous namespace'::AddressList::~AddressList(_anonymous_namespace_::AddressList *this)
{
  *(_QWORD *)this = &off_24E0711C0;
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 24);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0711C0;
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 24);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

_QWORD *re::DynamicArray<re::DynamicString>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::DynamicString>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = (_QWORD *)(v8 + 16);
        v11 = 32 * v9;
        v12 = 0uLL;
        v13 = v7;
        do
        {
          *(_OWORD *)v13 = v12;
          *((_OWORD *)v13 + 1) = v12;
          *v13 = *(v10 - 2);
          *(v10 - 2) = 0;
          v14 = *v10;
          v13[3] = v10[1];
          v10[1] = 0;
          v15 = v13[1];
          v16 = v13[2];
          v17 = *(v10 - 1);
          v13[2] = v14;
          *v10 = v16;
          v13[1] = v17;
          *(v10 - 1) = v15;
          v18 = *(v10 - 2);
          if (v18)
          {
            if ((v15 & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 40))(v18, *v10);
              v12 = 0uLL;
            }
            *((_OWORD *)v10 - 1) = v12;
            *(_OWORD *)v10 = v12;
          }
          v10 += 4;
          v13 += 4;
          v11 -= 32;
        }
        while (v11);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::DynamicString>::deinit(uint64_t a1)
{
  uint64_t result;
  __n128 *v3;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(__n128 **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 32 * v4;
        v6 = 0uLL;
        do
        {
          if (v3->n128_u64[0])
          {
            if ((v3->n128_u8[8] & 1) != 0)
            {
              (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v3->n128_u64[0] + 40))(v3->n128_u64[0], v3[1].n128_u64[0], v6);
              v6 = 0uLL;
            }
            *v3 = v6;
            v3[1] = v6;
          }
          v3 += 2;
          v5 -= 32;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(__n128 **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, __n128 *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::SharedAppSyncManager::~SharedAppSyncManager(re::SharedAppSyncManager *this)
{
  const void *v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  re::SharedAppSyncManager **v16;
  __int128 v17;
  unint64_t v18;
  uint64_t v19;
  __int128 v20;
  unint64_t v21;
  re::SharedAppSyncManager **v22;
  __int128 v23;
  uint64_t v24;
  re *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  re::SharedAppSyncManager *v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_24E0712A0;
  if (!*((_BYTE *)this + 448))
    goto LABEL_47;
  *((_BYTE *)this + 448) = 0;
  v2 = (const void *)*((_QWORD *)this + 63);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 63) = 0;
  }
  v3 = *((_QWORD *)this + 53);
  if (v3)
  {
    v34 = this;
    *(_QWORD *)&v35 = re::SharedAppSyncManager::onViewAdded;
    *((_QWORD *)&v35 + 1) = 0;
    *(_QWORD *)&v36 = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::SyncViewManager,re::SyncView *>::removeSubscription(v3 + 24, (__int128 *)&v34);
  }
  v4 = (_BYTE *)*((_QWORD *)this + 51);
  if (!v4[2272])
    goto LABEL_47;
  v5 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v4 + 40))(v4);
  if (v6)
  {
    v7 = (uint64_t *)v5;
    v8 = 8 * v6;
    do
    {
      v9 = *v7;
      if (*v7)
      {
        v10 = (id)(v9 + 8);
        v31 = v9;
        v11 = (id)(v9 + 8);
        re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)this, (uint64_t)&v31);

        v31 = 0;
      }
      else
      {
        v31 = 0;
        re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)this, (uint64_t)&v31);
      }
      ++v7;
      v8 -= 8;
    }
    while (v8);
  }
  v12 = *((_QWORD *)this + 51);
  v13 = *(_QWORD *)(v12 + 7520);
  if (v13)
  {
    *(_QWORD *)&v32 = this;
    *((_QWORD *)&v32 + 1) = re::SharedAppSyncManager::handleCongestionEvent;
    *(_QWORD *)&v33 = 0;
    *((_QWORD *)&v33 + 1) = re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v13 + 224, &v32, (uint64_t)&v34);
    if ((_BYTE)v34)
    {
      if (*(_DWORD *)(v13 + 304))
      {
        LOBYTE(v34) = 0;
        v35 = v32;
        v36 = v33;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v13 + 264), (uint64_t)&v34);
      }
      else
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable((_QWORD *)(v13 + 224), &v32);
      }
    }
    v12 = *((_QWORD *)this + 51);
  }
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v12 + 2056, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((_QWORD *)this + 51) + 1968, (uint64_t)this);
  v14 = *((_QWORD *)this + 51);
  if (*(_QWORD *)(v14 + 400))
  {
    v15 = 0;
    while (1)
    {
      v16 = (re::SharedAppSyncManager **)(*(_QWORD *)(v14 + 416) + 32 * v15);
      if (*v16 == this)
      {
        if (!*(_DWORD *)(v14 + 464))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v14 + 384), v15);
          goto LABEL_25;
        }
        LOBYTE(v34) = 0;
        v17 = *((_OWORD *)v16 + 1);
        v35 = *(_OWORD *)v16;
        v36 = v17;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v14 + 424), (uint64_t)&v34);
      }
      ++v15;
LABEL_25:
      if (v15 >= *(_QWORD *)(v14 + 400))
      {
        v14 = *((_QWORD *)this + 51);
        break;
      }
    }
  }
  if (!*(_QWORD *)(v14 + 312))
    goto LABEL_37;
  v18 = 0;
  do
  {
    v19 = *(_QWORD *)(v14 + 328) + 32 * v18;
    if (*(re::SharedAppSyncManager **)v19 != this)
      goto LABEL_33;
    if (*(_DWORD *)(v14 + 376))
    {
      LOBYTE(v34) = 0;
      v20 = *(_OWORD *)(v19 + 16);
      v35 = *(_OWORD *)v19;
      v36 = v20;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v14 + 336), (uint64_t)&v34);
LABEL_33:
      ++v18;
      continue;
    }
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v14 + 296), v18);
  }
  while (v18 < *(_QWORD *)(v14 + 312));
  v14 = *((_QWORD *)this + 51);
LABEL_37:
  if (!*(_QWORD *)(v14 + 224))
    goto LABEL_46;
  v21 = 0;
  while (2)
  {
    v22 = (re::SharedAppSyncManager **)(*(_QWORD *)(v14 + 240) + 32 * v21);
    if (*v22 == this)
    {
      if (*(_DWORD *)(v14 + 288))
      {
        LOBYTE(v34) = 0;
        v23 = *((_OWORD *)v22 + 1);
        v35 = *(_OWORD *)v22;
        v36 = v23;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v14 + 248), (uint64_t)&v34);
        goto LABEL_42;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v14 + 208), v21);
    }
    else
    {
LABEL_42:
      ++v21;
    }
    if (v21 < *(_QWORD *)(v14 + 224))
      continue;
    break;
  }
  v14 = *((_QWORD *)this + 51);
LABEL_46:
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v14 + 120, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((_QWORD *)this + 51) + 32, (uint64_t)this);
LABEL_47:
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 512);
  v24 = *((_QWORD *)this + 57);
  if (v24)
  {
    v25 = (re *)*((_QWORD *)this + 61);
    if (v25)
    {
      v26 = *((_QWORD *)this + 59);
      if (v26)
      {
        v27 = 8 * v26;
        do
        {
          std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::reset[abi:nn180100](v25, 0);
          v25 = (re *)((char *)v25 + 8);
          v27 -= 8;
        }
        while (v27);
        v24 = *((_QWORD *)this + 57);
        v25 = (re *)*((_QWORD *)this + 61);
      }
      (*(void (**)(uint64_t, re *))(*(_QWORD *)v24 + 40))(v24, v25);
    }
    *((_QWORD *)this + 61) = 0;
    *((_QWORD *)this + 58) = 0;
    *((_QWORD *)this + 59) = 0;
    *((_QWORD *)this + 57) = 0;
    ++*((_DWORD *)this + 120);
  }
  v28 = *((_QWORD *)this + 53);
  if (v28)
  {

    *((_QWORD *)this + 53) = 0;
  }
  v29 = *((_QWORD *)this + 52);
  if (v29)
  {

    *((_QWORD *)this + 52) = 0;
  }
  v30 = *((_QWORD *)this + 51);
  if (v30)
  {

    *((_QWORD *)this + 51) = 0;
  }
  re::SyncSession::~SyncSession(this);
}

{
  re::SharedAppSyncManager::~SharedAppSyncManager(this);
  JUMPOUT(0x220780CD0);
}

void re::SharedAppSyncManager::init(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[5];

  v11[4] = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)a2 + 4);
  v5 = *(_DWORD *)(v4 + 2832);
  v6 = *((_DWORD *)a2 + 5);
  if (v6 >= v5)
    v6 = *(_DWORD *)(v4 + 2832);
  if (v5 >= *((_DWORD *)a2 + 4))
    v7 = v6;
  else
    v7 = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 496) = v7;
  *(_DWORD *)(a1 + 500) = *(_DWORD *)(v4 + 2232);
  v8 = *a2;
  *(_OWORD *)(a1 + 385) = *(__int128 *)((char *)a2 + 9);
  *(_OWORD *)(a1 + 376) = v8;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 408), *((_QWORD *)a2 + 4));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 416), *((_QWORD *)a2 + 5));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 424), *((_QWORD *)a2 + 6));
  v9 = *((_QWORD *)a2 + 7);
  *(_DWORD *)(a1 + 440) = *((_DWORD *)a2 + 16);
  *(_QWORD *)(a1 + 432) = v9;
  re::SharedAppSyncManager::registerForSessionEvents((re::SharedAppSyncManager *)a1);
  v10 = *(_QWORD *)(a1 + 424);
  if (v10)
  {
    v11[0] = a1;
    v11[1] = re::SharedAppSyncManager::onViewAdded;
    v11[2] = 0;
    v11[3] = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::SyncViewManager,re::SyncView *>::addSubscription((_DWORD *)(v10 + 24), (uint64_t)v11);
  }
  *(_BYTE *)(a1 + 448) = 1;
}

double re::SharedAppSyncManager::registerForSessionEvents(re::SharedAppSyncManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  id v9;
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *v12;
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD *v16;
  double result;
  uint64_t v18;
  uint64_t v19;
  re::SharedAppSyncManager *v20;
  uint64_t (*v21)(re::SharedAppSyncManager *, re::Session *);
  uint64_t v22;
  void *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 51) + 40))(*((_QWORD *)this + 51));
  if (v3)
  {
    v4 = (uint64_t *)v2;
    v5 = 8 * v3;
    do
    {
      v6 = *v4;
      if (*v4)
        v7 = (id)(v6 + 8);
      v8 = *(_QWORD *)(v6 + 152);
      if (v8 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 48))(v8) & 1) == 0)
      {
        v19 = v6;
        v9 = (id)(v6 + 8);
        re::SharedAppSyncManager::addPeerStateForParticipant((uint64_t)this, &v19);

        v19 = 0;
      }

      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  v10 = (_DWORD *)(*((_QWORD *)this + 51) + 32);
  v20 = this;
  v21 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onSessionWillDeinit;
  v22 = 0;
  v23 = re::Event<re::Session>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v10, (uint64_t)&v20);
  v11 = (_DWORD *)(*((_QWORD *)this + 51) + 120);
  v20 = this;
  v21 = re::SharedAppSyncManager::onSessionStarted;
  v22 = 0;
  v23 = re::Event<re::Session>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v11, (uint64_t)&v20);
  v12 = (_DWORD *)(*((_QWORD *)this + 51) + 208);
  v20 = this;
  v21 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onSessionStopped;
  v22 = 0;
  v23 = re::Event<re::Session,re::SessionError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v12, (uint64_t)&v20);
  v13 = (_DWORD *)(*((_QWORD *)this + 51) + 296);
  v20 = this;
  v21 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerJoined;
  v22 = 0;
  v23 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v13, (uint64_t)&v20);
  v14 = (_DWORD *)(*((_QWORD *)this + 51) + 384);
  v20 = this;
  v21 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerLeft;
  v22 = 0;
  v23 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v14, (uint64_t)&v20);
  v15 = (_DWORD *)(*((_QWORD *)this + 51) + 1968);
  v20 = this;
  v21 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerPaused;
  v22 = 0;
  v23 = re::Event<re::Session,unsigned long long>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v15, (uint64_t)&v20);
  v16 = (_DWORD *)(*((_QWORD *)this + 51) + 2056);
  v20 = this;
  v21 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerResumed;
  v22 = 0;
  v23 = re::Event<re::Session,unsigned long long>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  result = re::Event<re::Session>::addSubscription(v16, (uint64_t)&v20);
  v18 = *(_QWORD *)(*((_QWORD *)this + 51) + 7520);
  if (v18)
  {
    v20 = this;
    v21 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::handleCongestionEvent;
    v22 = 0;
    v23 = re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke;
    return re::Event<re::Session>::addSubscription((_DWORD *)(v18 + 224), (uint64_t)&v20);
  }
  return result;
}

uint64_t re::SharedAppSyncManager::sendRate(re::SharedAppSyncManager *this)
{
  return *((_QWORD *)this + 47);
}

_QWORD *re::SharedAppSyncManager::setViewFilter(uint64_t a1, void *aBlock)
{
  const void *v4;
  re *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *result;
  _QWORD v9[3];
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v4 = *(const void **)(a1 + 504);
  if (v4)
    _Block_release(v4);
  v5 = (re *)_Block_copy(aBlock);
  *(_QWORD *)(a1 + 504) = v5;
  v6 = *(_QWORD *)(a1 + 424);
  v7 = re::globalAllocators(v5)[2];
  v9[0] = &off_24E071390;
  v9[1] = a1;
  v10 = v7;
  v11 = v9;
  re::SyncViewManager::forEachView(v6, (uint64_t)v9);
  result = v11;
  if (v11)
  {
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *))*v11)(v11);
    if (v11 != v9)
      return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  }
  return result;
}

uint64_t re::SharedAppSyncManager::viewFilter(re::SharedAppSyncManager *this)
{
  return *((_QWORD *)this + 63);
}

re *re::SharedAppSyncManager::addPeerStateForParticipant(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  _BOOL8 v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  id v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  re *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  id v28;
  id v30;
  id location;
  _QWORD v32[3];
  uint64_t v33;
  re *v34;
  _BYTE buf[24];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects((re *)a1);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    v6 = *(_QWORD *)(*a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v6;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Adding new peer state. PeerID=%llu.", buf, 0xCu);
  }
  v7 = re::globalAllocators((re *)v5);
  v8 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7[2] + 32))(v7[2], 296, 8);
  v9 = *a2;
  if (*a2)
    v10 = (id)(v9 + 8);
  v8[2] = 0;
  v8[3] = 0;
  *((_DWORD *)v8 + 8) = 0;
  v8[5] = 0;
  v8[6] = a1;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_DWORD *)v8 + 24) = 0;
  *v8 = (uint64_t)&off_24E071268;
  v8[1] = 0;
  v8[14] = v9;
  v11 = v8 + 14;
  *(uint64_t *)((char *)v8 + 100) = 0x7FFFFFFFLL;
  objc_initWeak((id *)buf, (id)(a1 + 8));
  objc_initWeak(&location, (id)(*(_QWORD *)(a1 + 408) + 2328));
  v13 = *(_QWORD *)(v8[14] + 24);
  v12 = *(_QWORD *)(v8[14] + 32);
  v14 = re::Session::peerID(*(re::Session **)(a1 + 408));
  v15 = *(_QWORD *)(a1 + 416);
  if (v15)
    v16 = (void *)(v15 + 8);
  else
    v16 = 0;
  objc_initWeak(&v30, v16);
  re::SharedAppUnicast::SharedAppUnicast((uint64_t)(v8 + 15), (id *)buf, (re *)&location, v12, v13, v14, &v30, *(_BYTE *)(a1 + 400), (*(_DWORD *)(*v11 + 72) & 2) != 0);
  objc_destroyWeak(&v30);
  v30 = 0;
  objc_destroyWeak(&location);
  location = 0;
  objc_destroyWeak((id *)buf);
  v17 = *v11;
  v8[29] = *(_QWORD *)(*v11 + 24);
  v8[30] = 0;
  *((_DWORD *)v8 + 62) = 0;
  *((_BYTE *)v8 + 252) = 0;
  v8[36] = 0;
  v8[33] = 0;
  v8[34] = 0;
  v8[32] = 0;
  *((_DWORD *)v8 + 70) = 0;
  v8[7] = *(_QWORD *)(v17 + 24);
  *((_BYTE *)v8 + 224) = 1;
  location = v8;
  re::SharedPtr<re::SyncObject>::reset(v8 + 14, *a2);
  v19 = *(_QWORD *)(a1 + 424);
  if (v19)
  {
    *(_QWORD *)buf = v8;
    v18 = (re *)re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addNew(v19 + 160, (uint64_t *)buf);
    v20 = *(_QWORD *)(a1 + 424);
    if (v20)
    {
      if (*(_QWORD *)(a1 + 504))
      {
        v21 = re::globalAllocators(v18)[2];
        v32[0] = &off_24E071440;
        v32[1] = a1;
        v32[2] = &location;
        v33 = v21;
        v34 = (re *)v32;
        re::SyncViewManager::forEachView(v20, (uint64_t)v32);
        v18 = v34;
        if (v34)
        {
          v18 = (re *)(**(uint64_t (***)(re *))v34)(v34);
          if (v34 != (re *)v32)
            v18 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v33 + 40))(v33);
          v34 = 0;
        }
      }
    }
  }
  v23 = *(_QWORD *)(a1 + 464);
  v22 = *(_QWORD *)(a1 + 472);
  if (v22 >= v23)
  {
    v24 = v22 + 1;
    if (v23 < v22 + 1)
    {
      if (*(_QWORD *)(a1 + 456))
      {
        v25 = 2 * v23;
        if (!v23)
          v25 = 8;
        if (v25 <= v24)
          v26 = v24;
        else
          v26 = v25;
        re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity((_QWORD *)(a1 + 456), v26);
      }
      else
      {
        re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity((_QWORD *)(a1 + 456), v24);
        ++*(_DWORD *)(a1 + 480);
      }
    }
    v22 = *(_QWORD *)(a1 + 472);
  }
  v27 = *(_QWORD *)(a1 + 488);
  v28 = location;
  location = 0;
  *(_QWORD *)(v27 + 8 * v22) = v28;
  *(_QWORD *)(a1 + 472) = v22 + 1;
  ++*(_DWORD *)(a1 + 480);
  return std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::reset[abi:nn180100]((re *)&location, 0);
}

uint64_t re::SharedAppSyncManager::onSessionWillDeinit(re::NetworkSyncManager **this, re::Session *a2)
{
  re::NetworkSyncManager::removeSession(this[54], this[51]);
  return 0;
}

uint64_t re::SharedAppSyncManager::onSessionStarted(re::SharedAppSyncManager *this, re::Session *a2)
{
  NSObject *v3;
  int v5;
  re::Session *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 134217984;
    v6 = a2;
    _os_log_impl(&dword_21C69B000, v3, OS_LOG_TYPE_DEFAULT, "SharedAppSyncManager: session started (%p).", (uint8_t *)&v5, 0xCu);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onSessionStopped(re *a1, uint64_t a2, int a3)
{
  NSObject *v5;
  int v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134218240;
    v8 = a2;
    v9 = 1024;
    v10 = a3;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "SharedAppSyncManager: session stopped (%p) with error: %d.", (uint8_t *)&v7, 0x12u);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerJoined(re *a1, uint64_t a2, uint64_t *a3)
{
  NSObject *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  id v13;
  uint64_t v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (_QWORD *)*a3;
    if ((*(_BYTE *)(*a3 + 48) & 1) != 0)
      v7 = (char *)v6[7];
    else
      v7 = (char *)v6 + 49;
    v8 = v6[3];
    v9 = v6[19];
    if (v9)
      v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(v9);
    else
      v10 = "nullptr";
    *(_DWORD *)buf = 134218498;
    v17 = v8;
    v18 = 2080;
    v19 = v7;
    v20 = 2080;
    v21 = v10;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "New peer joined object syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  v11 = *a3;
  v15 = v11;
  if (v11)
  {
    v12 = (void *)(v11 + 8);
    v13 = (id)(v11 + 8);
    re::SharedAppSyncManager::addPeerStateForParticipant((uint64_t)a1, &v15);

  }
  else
  {
    re::SharedAppSyncManager::addPeerStateForParticipant((uint64_t)a1, &v15);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerLeft(re *a1, uint64_t a2, uint64_t *a3)
{
  NSObject *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  id v13;
  uint64_t v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (_QWORD *)*a3;
    if ((*(_BYTE *)(*a3 + 48) & 1) != 0)
      v7 = (char *)v6[7];
    else
      v7 = (char *)v6 + 49;
    v8 = v6[3];
    v9 = v6[19];
    if (v9)
      v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(v9);
    else
      v10 = "nullptr";
    *(_DWORD *)buf = 134218498;
    v17 = v8;
    v18 = 2080;
    v19 = v7;
    v20 = 2080;
    v21 = v10;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "Peer left syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  v11 = *a3;
  v15 = v11;
  if (v11)
  {
    v12 = (void *)(v11 + 8);
    v13 = (id)(v11 + 8);
    re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)a1, (uint64_t)&v15);

  }
  else
  {
    re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)a1, (uint64_t)&v15);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerPaused(re::SharedAppSyncManager *this, re::Session *a2, uint64_t a3)
{
  NSObject *v5;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134217984;
    v8 = a3;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "Pausing peerID %llu.", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SharedAppSyncManager *, uint64_t))(*(_QWORD *)this + 120))(this, a3);
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerResumed(re::SharedAppSyncManager *this, re::Session *a2, uint64_t a3)
{
  NSObject *v5;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134217984;
    v8 = a3;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "Resuming peerID %llu", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SharedAppSyncManager *, uint64_t))(*(_QWORD *)this + 128))(this, a3);
  return 0;
}

uint64_t re::SharedAppSyncManager::handleCongestionEvent(re *a1)
{
  NSObject *v1;
  uint8_t v3[16];

  v1 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v3 = 0;
    _os_log_debug_impl(&dword_21C69B000, v1, OS_LOG_TYPE_DEBUG, "Emiting congestion event.", v3, 2u);
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  return 0;
}

void re::SharedAppSyncManager::removePeerStateForParticipant(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  re::SyncObject **v14;
  re::SyncObject **v15;
  uint64_t v16;
  re::SyncObject *v17;
  re::SyncObject *v18;
  re::SyncObject *v19;
  re::SyncObject *v20;
  unint64_t v21;
  re::SyncObject *v22;
  char *v23;
  NSObject *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  re::SyncViewManager *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  _BYTE v44[38];
  uint8_t buf[32];
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(*(_QWORD *)a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v5;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Removing peer state. PeerID=%llu.", buf, 0xCu);
  }
  v6 = *(_QWORD *)(a1 + 472);
  if (v6)
  {
    v7 = 0;
    v8 = *(_QWORD *)(*(_QWORD *)a2 + 24);
    while (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 488) + 8 * v7) + 56) != v8)
    {
      if (v6 == ++v7)
        return;
    }
    if ((v7 & 0x80000000) == 0)
    {
      re::SyncObjectStore::types(*(_QWORD **)(a1 + 416), (uint64_t)buf);
      v42 = a1;
      v9 = 0;
      if (*(_QWORD *)&buf[16])
      {
        v10 = (_QWORD *)(a1 + 512);
        v11 = (uint64_t *)v46;
        v43 = (uint64_t *)(v46 + 8 * *(_QWORD *)&buf[16]);
        do
        {
          v12 = *v11;
          if (*(_BYTE *)(*(_QWORD *)(*v11 + 16) + 73))
          {
            v13 = *(_QWORD *)(v12 + 64);
            if (v13)
            {
              v14 = *(re::SyncObject ***)(v12 + 80);
              v15 = &v14[v13];
              do
              {
                v16 = re::SyncObject::fromPeerID(*v14);
                v17 = *v14;
                if (v16 == v8)
                  goto LABEL_20;
                v18 = (re::SyncObject *)*((_QWORD *)v17 + 10);
                v19 = *v14;
                if (v18)
                {
                  v20 = *v14;
                  do
                  {
                    v19 = v20;
                    v20 = v18;
                    if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v19 + 11) + 16) + 73))
                      break;
                    v18 = (re::SyncObject *)*((_QWORD *)v18 + 10);
                    v19 = v20;
                  }
                  while (v18);
                }
                if (*((_QWORD *)v19 + 20) == v8)
                {
LABEL_20:
                  v21 = re::SyncObject::latestStateHandle(v17);
                  if (v21 == -1)
                  {
                    v24 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
                    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                    {
                      v25 = *((_QWORD *)*v14 + 3);
                      v26 = *(_QWORD **)(*((_QWORD *)*v14 + 11) + 16);
                      v27 = v26[4];
                      v28 = v26[6];
                      v29 = (char *)v26[7];
                      v30 = (char *)v26 + 49;
                      if ((v28 & 1) != 0)
                        v30 = v29;
                      *(_DWORD *)v44 = 134218498;
                      *(_QWORD *)&v44[4] = v25;
                      *(_WORD *)&v44[12] = 2048;
                      *(_QWORD *)&v44[14] = v27;
                      *(_WORD *)&v44[22] = 2080;
                      *(_QWORD *)&v44[24] = v30;
                      _os_log_error_impl(&dword_21C69B000, v24, OS_LOG_TYPE_ERROR, "Sync object without snapshot while gathering orphans (id: %llu, type: %llu[%s]).", v44, 0x20u);
                    }
                  }
                  else
                  {
                    *((_BYTE *)*v14 + 128) |= 4u;
                    v22 = *v14;
                    *(_QWORD *)v44 = v22;
                    if (v22)
                      v23 = (char *)v22 + 8;
                    *(_QWORD *)&v44[8] = v21;
                    v44[16] = 2;
                    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v10, (uint64_t)v44);
                    if (*(_QWORD *)v44)

                  }
                  if (v21 != -1)
                    ++v9;
                }
                ++v14;
              }
              while (v14 != v15);
            }
          }
          ++v11;
        }
        while (v11 != v43);
      }
      v31 = *(re **)buf;
      if (*(_QWORD *)buf && (_QWORD)v46)
        v31 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
      v32 = *(_QWORD *)(v42 + 528);
      if (v32)
      {
        v33 = *(_QWORD *)(v42 + 544);
        v34 = 24 * v32;
        do
        {
          if ((*(_BYTE *)(*(_QWORD *)v33 + 128) & 4) != 0)
            re::SyncObjectManager::destroyObject(v33);
          v33 += 24;
          v34 -= 24;
        }
        while (v34);
      }
      if (v9)
      {
        v35 = *re::networkLogObjects(v31);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          v36 = re::Session::peerID(*(re::Session **)(v42 + 408));
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v9;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v36;
          _os_log_impl(&dword_21C69B000, v35, OS_LOG_TYPE_DEFAULT, "Found %zu orphaned objects. localPeerID=%llu. ", buf, 0x16u);
        }
      }
      v37 = *(re::SyncViewManager **)(v42 + 424);
      if (v37)
      {
        v38 = *(_QWORD *)(v42 + 472);
        if (v38 <= v7)
          goto LABEL_54;
        re::SyncViewManager::removeViewer(v37, *(re::SyncViewer **)(*(_QWORD *)(v42 + 488) + 8 * v7), 0);
      }
      v38 = *(_QWORD *)(v42 + 472);
      if (v38 > v7)
      {
        if (v38 - 1 > v7)
        {
          v39 = *(_QWORD *)(v42 + 488);
          v40 = v39 + 8 * v38;
          v41 = *(_QWORD *)(v40 - 8);
          *(_QWORD *)(v40 - 8) = 0;
          std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::reset[abi:nn180100]((re *)(v39 + 8 * v7), v41);
          v38 = *(_QWORD *)(v42 + 472);
        }
        std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::reset[abi:nn180100]((re *)(*(_QWORD *)(v42 + 488) + 8 * v38 - 8), 0);
        --*(_QWORD *)(v42 + 472);
        ++*(_DWORD *)(v42 + 480);
        return;
      }
      v47 = 0u;
      v48 = 0u;
      v46 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v44 = 136315906;
      *(_QWORD *)&v44[4] = "removeAt";
      *(_WORD *)&v44[12] = 1024;
      *(_DWORD *)&v44[14] = 931;
      *(_WORD *)&v44[18] = 2048;
      *(_QWORD *)&v44[20] = v7;
      *(_WORD *)&v44[28] = 2048;
      *(_QWORD *)&v44[30] = v38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      v47 = 0u;
      v48 = 0u;
      v46 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v44 = 136315906;
      *(_QWORD *)&v44[4] = "operator[]";
      *(_WORD *)&v44[12] = 1024;
      *(_DWORD *)&v44[14] = 789;
      *(_WORD *)&v44[18] = 2048;
      *(_QWORD *)&v44[20] = v7;
      *(_WORD *)&v44[28] = 2048;
      *(_QWORD *)&v44[30] = v38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
}

uint64_t re::SharedAppSyncManager::onViewAdded(re::SharedAppSyncManager *this, re::SyncViewManager *a2, re::SyncView *a3)
{
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = re::globalAllocators(this)[2];
  v8[0] = &off_24E0713E8;
  v8[1] = this;
  v8[2] = a3;
  v9 = v6;
  v10 = v8;
  re::SyncViewManager::forEachViewer((uint64_t)a2, (uint64_t)v8);
  if (v10)
  {
    (*(void (**)(_QWORD *))*v10)(v10);
    if (v10 != v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::findPeer(re::SharedAppSyncManager *this, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 59);
  if (!v2)
    return 0;
  v3 = 0;
  v4 = *((_QWORD *)this + 61);
  while (*(_QWORD *)(*(_QWORD *)(v4 + 8 * v3) + 56) != a2)
  {
    if (v2 == ++v3)
      return 0;
  }
  if ((v3 & 0x80000000) != 0)
    return 0;
  if (v2 <= v3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(v4 + 8 * v3);
}

uint64_t re::SharedAppSyncManager::receive(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;

  v2 = *(_QWORD *)(a1 + 472);
  if (!v2)
    return 1;
  v4 = *(uint64_t **)(a1 + 488);
  v5 = &v4[v2];
  do
  {
    v6 = *v4;
    v7 = *(_QWORD *)(*v4 + 128);
    v8 = v7 != 0;
    if (!v7)
      break;
    if (*(_BYTE *)(v6 + 163))
    {
      v9 = *(_QWORD *)(v6 + 112);
      *(_BYTE *)(v6 + 163) = 0;
      while (1)
      {
        v10 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 128) + 56))(*(_QWORD *)(v6 + 128));
        if (!v10)
          break;
        v11 = v10;
        v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, v9, *(_QWORD *)(v10 + 16), *(unsigned int *)(v10 + 24));
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 128) + 40))(*(_QWORD *)(v6 + 128), v11);
        if ((v12 & 1) == 0)
          return 0;
      }
    }
    ++v4;
  }
  while (v4 != v5);
  return v8;
}

void re::SharedAppSyncManager::receive(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL8 v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  _QWORD v18[6];
  uint8_t v19[16];
  uint8_t buf[4];
  _BYTE v21[28];
  _QWORD v22[3];
  int v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v19, 6008, (uint64_t)a1);
  *(_QWORD *)a3 = a1;
  v6 = a1[59];
  if (v6)
  {
    v7 = (uint64_t *)a1[61];
    v8 = 8 * v6;
    v9 = MEMORY[0x24BDAC760];
    while (1)
    {
      v10 = *v7;
      v11 = *(_QWORD *)(*v7 + 112);
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(v11 + 24);
      *(_DWORD *)(a3 + 24) = *(_DWORD *)(v11 + 72);
      v18[0] = v9;
      v18[1] = 0x40000000;
      v18[2] = ___ZN2re20SharedAppSyncManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke;
      v18[3] = &unk_24E071330;
      v18[4] = a2;
      v18[5] = a1;
      v12 = re::SharedAppUnicast::receive((id *)(v10 + 120), a3, (uint64_t)v18);
      if (!v12)
        break;
      ++v7;
      v8 -= 8;
      if (!v8)
        goto LABEL_8;
    }
    v13 = *re::networkLogObjects((re *)v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if ((*(_BYTE *)(v11 + 48) & 1) != 0)
        v14 = *(_QWORD *)(v11 + 56);
      else
        v14 = v11 + 49;
      v15 = *(_QWORD *)(v11 + 24);
      v16 = *(_QWORD *)(v11 + 152);
      if (v16)
        v17 = (const char *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 32))(v16);
      else
        v17 = "nullptr";
      *(_DWORD *)buf = 134218498;
      *(_QWORD *)v21 = v15;
      *(_WORD *)&v21[8] = 2082;
      *(_QWORD *)&v21[10] = v14;
      *(_WORD *)&v21[18] = 2082;
      *(_QWORD *)&v21[20] = v17;
      _os_log_error_impl(&dword_21C69B000, v13, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)", buf, 0x20u);
    }
    re::Transport::disconnect((re::Transport *)(a1[51] + 2320), *(_QWORD *)(v11 + 32), 0);
  }
LABEL_8:
  if (a1[66])
  {
    buf[0] = 0;
    v24 = 0;
    memset(v22, 0, sizeof(v22));
    v23 = 0;
    *(_QWORD *)&v21[4] = 0;
    *(_QWORD *)&v21[12] = 0;
    *(_QWORD *)&v21[17] = 0;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v22, a1 + 64);
    (*(void (**)(uint64_t, _QWORD *, uint8_t *))(a2 + 16))(a2, a1, buf);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::clear((uint64_t)(a1 + 64));
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v22);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v19);
}

uint64_t ___ZN2re20SharedAppSyncManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a2 + 48);
  if (v3)
  {
    v4 = *(_QWORD *)(a2 + 64);
    v5 = 24 * v3;
    do
    {
      if ((*(_BYTE *)(*(_QWORD *)v4 + 128) & 4) != 0)
        re::SyncObjectManager::destroyObject(v4);
      v4 += 24;
      v5 -= 24;
    }
    while (v5);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void re::SharedAppSyncManager::send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  re::SyncObject **v29;
  int v30;
  int v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  re::SyncObjectViewer **v44;
  uint64_t v45;
  re::SyncObjectViewer *v46;
  BOOL v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  re::SyncObjectViewer **v56;
  uint64_t v57;
  re::SyncObjectViewer *v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v73;
  re::SyncObject *v74[2];
  _BYTE v75[16];
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t *v80;

  *(_QWORD *)(a4 + 8) = a1;
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v75, 6018, a1);
  v7 = a2 + 72 * a3;
  v73 = a3;
  if (a3)
  {
    v8 = a2;
    do
    {
      v9 = *(_QWORD *)(v8 + 48);
      if (v9)
      {
        v10 = *(uint64_t **)(v8 + 64);
        v11 = &v10[3 * v9];
        do
        {
          v12 = *v10;
          v13 = *(_QWORD *)(*v10 + 80);
          v14 = *v10;
          if (v13)
          {
            v15 = *v10;
            do
            {
              v14 = v15;
              v15 = v13;
              if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v14 + 88) + 16) + 73))
                break;
              v13 = *(_QWORD *)(v13 + 80);
              v14 = v15;
            }
            while (v13);
          }
          if ((*(_BYTE *)(v14 + 170) || *(_BYTE *)(a1 + 400)) && (*(_BYTE *)(v12 + 128) & 4) != 0)
          {
            if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 88) + 16) + 74))
            {
              v18 = *(_QWORD *)(v12 + 96);
              v17 = v12 + 96;
              v16 = v18;
              if (v18)
                re::SyncView::removeObject(v16, v17);
            }
          }
          v10 += 3;
        }
        while (v10 != v11);
      }
      v8 += 72;
    }
    while (v8 != v7);
  }
  v19 = *(_QWORD *)(a1 + 472);
  if (v19)
  {
    v20 = *(uint64_t **)(a1 + 488);
    v21 = &v20[v19];
    do
    {
      v80 = 0;
      v77 = 0;
      v78 = 0;
      v76 = 0;
      v79 = 0;
      v22 = *v20;
      v23 = *(unsigned int *)(*v20 + 96);
      if ((_DWORD)v23)
      {
        v24 = 0;
        v25 = (int *)(*(_QWORD *)(v22 + 80) + 8);
        while (1)
        {
          v26 = *v25;
          v25 += 8;
          if (v26 < 0)
            break;
          if (v23 == ++v24)
          {
            LODWORD(v24) = *(_DWORD *)(*v20 + 96);
            break;
          }
        }
      }
      else
      {
        LODWORD(v24) = 0;
      }
      if ((_DWORD)v23 != (_DWORD)v24)
      {
        v27 = v24;
        do
        {
          v28 = *(_QWORD *)(v22 + 80) + 32 * v27;
          v29 = (re::SyncObject **)(v28 + 16);
          v30 = *(_DWORD *)(v28 + 24);
          if (re::SharedAppUnicast::shouldForward(*v20 + 120, (uint64_t *)(v28 + 16)))
          {
            if (v30)
            {
              v74[0] = *v29;
              re::DynamicArray<re::SyncCommit const*>::add(&v76, v74);
            }
            else
            {
              addToViewRecursive(v29, *v20 + 224, *(_QWORD *)(*v20 + 56));
            }
          }
          if (*(_DWORD *)(v22 + 96) <= (v24 + 1))
            v31 = v24 + 1;
          else
            v31 = *(_DWORD *)(v22 + 96);
          while (1)
          {
            v27 = (v24 + 1);
            if (v31 - 1 == (_DWORD)v24)
              break;
            LODWORD(v24) = v24 + 1;
            v32 = v27;
            if ((*(_DWORD *)(*(_QWORD *)(v22 + 80) + 32 * v27 + 8) & 0x80000000) != 0)
              goto LABEL_38;
          }
          v32 = v31;
LABEL_38:
          LODWORD(v24) = v32;
        }
        while ((_DWORD)v23 != v32);
        if (v78)
        {
          v33 = v80;
          v34 = 8 * v78;
          do
          {
            v35 = *v33;
            v74[0] = (re::SyncObject *)v35;
            if (v35)
              v36 = (id)(v35 + 8);
            removeFromViewRecursive(v74, *v20 + 224, *(_QWORD *)(*v20 + 56));
            if (v74[0])

            ++v33;
            v34 -= 8;
          }
          while (v34);
        }
      }
      if (v76 && v80)
        (*(void (**)(void))(*(_QWORD *)v76 + 40))();
      ++v20;
    }
    while (v20 != v21);
  }
  v80 = 0;
  v77 = 0;
  v78 = 0;
  v76 = 0;
  v79 = 0;
  if (v73)
  {
    v37 = a2;
    do
    {
      if (*(_BYTE *)(v37 + 28))
      {
        v38 = *(_QWORD *)(v37 + 48);
        if (v38)
        {
          v39 = *(uint64_t **)(v37 + 64);
          v40 = &v39[3 * v38];
          do
          {
            v41 = (_QWORD *)*v39;
            if (*v39)
            {
              while (!*(_BYTE *)(*(_QWORD *)(v41[11] + 16) + 74))
              {
                v41 = (_QWORD *)v41[10];
                if (!v41)
                  goto LABEL_71;
              }
              v42 = v41[12];
              if (v42)
              {
                v43 = *(_QWORD *)(v42 + 104);
                if (v43)
                {
                  v44 = *(re::SyncObjectViewer ***)(v42 + 120);
                  v45 = 8 * v43;
                  do
                  {
                    v46 = *v44;
                    if (*((_QWORD *)*v44 + 6) == a1)
                    {
                      v47 = *(_BYTE *)(v37 + 28) && *(_QWORD *)(v37 + 8) == *((_QWORD *)v46 + 7);
                      if (!v47
                        && re::SharedAppUnicast::shouldForward((uint64_t)v46 + 120, v39)
                        && entryIsAddable((re::SyncObject **)v39, v46))
                      {
                        re::DynamicArray<re::internal::SyncSnapshotEntry>::add((_QWORD *)v46 + 32, v39);
                      }
                    }
                    ++v44;
                    v45 -= 8;
                  }
                  while (v45);
                }
              }
            }
LABEL_71:
            v39 += 3;
          }
          while (v39 != v40);
        }
      }
      else
      {
        v74[0] = (re::SyncObject *)v37;
        re::DynamicArray<re::SyncCommit const*>::add(&v76, v74);
      }
      v37 += 72;
    }
    while (v37 != v7);
    if (v78)
    {
      v48 = v80;
      v49 = &v80[v78];
      do
      {
        v50 = *(_QWORD *)(*v48 + 48);
        if (v50)
        {
          v51 = *(uint64_t **)(*v48 + 64);
          v52 = &v51[3 * v50];
          do
          {
            v53 = (_QWORD *)*v51;
            if (*v51)
            {
              while (!*(_BYTE *)(*(_QWORD *)(v53[11] + 16) + 74))
              {
                v53 = (_QWORD *)v53[10];
                if (!v53)
                  goto LABEL_91;
              }
              v54 = v53[12];
              if (v54)
              {
                v55 = *(_QWORD *)(v54 + 104);
                if (v55)
                {
                  v56 = *(re::SyncObjectViewer ***)(v54 + 120);
                  v57 = 8 * v55;
                  do
                  {
                    v58 = *v56;
                    if (*((_QWORD *)*v56 + 6) == a1
                      && re::SharedAppUnicast::shouldForward((uint64_t)v58 + 120, v51)
                      && entryIsAddable((re::SyncObject **)v51, v58))
                    {
                      re::DynamicArray<re::internal::SyncSnapshotEntry>::add((_QWORD *)v58 + 32, v51);
                    }
                    ++v56;
                    v57 -= 8;
                  }
                  while (v57);
                }
              }
            }
LABEL_91:
            v51 += 3;
          }
          while (v51 != v52);
        }
        ++v48;
      }
      while (v48 != v49);
    }
    if (v76 && v80)
      (*(void (**)(void))(*(_QWORD *)v76 + 40))();
  }
  v59 = *(_QWORD *)(a1 + 472);
  if (v59)
  {
    v60 = *(uint64_t **)(a1 + 488);
    v61 = 8 * v59;
    do
    {
      v62 = *v60;
      v63 = *(_QWORD *)(*v60 + 112);
      v64 = *(_QWORD *)(v63 + 152);
      if (v64 && (v65 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v64 + 48))(v64), v62 = *v60, v65))
      {
        re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(v62 + 256);
      }
      else
      {
        if (*(_QWORD *)(v62 + 272))
        {
          *(_QWORD *)(a4 + 16) = *(_QWORD *)(v63 + 24);
          *(_DWORD *)(a4 + 32) = *(_DWORD *)(v63 + 72);
          v76 = v62 + 224;
          v77 = 1;
          v74[0] = 0;
          v74[1] = 0;
          re::SharedAppUnicast::send((id *)(v62 + 120), (uint64_t)&v76, (uint64_t)v74, v62, a4);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(*v60 + 256);
          v62 = *v60;
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(v62 + 64);
      }
      ++v60;
      v61 -= 8;
    }
    while (v61);
  }
  if (v73)
  {
    do
    {
      v66 = *(_QWORD *)(a2 + 48);
      if (v66)
      {
        v67 = *(_QWORD *)(a2 + 64);
        v68 = v67 + 24 * v66;
        do
        {
          v69 = *(_QWORD *)(*(_QWORD *)v67 + 80);
          v70 = *(_QWORD *)v67;
          if (v69)
          {
            v71 = *(_QWORD *)v67;
            do
            {
              v70 = v71;
              v71 = v69;
              if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v70 + 88) + 16) + 73))
                break;
              v69 = *(_QWORD *)(v69 + 80);
              v70 = v71;
            }
            while (v69);
          }
          if ((*(_BYTE *)(v70 + 170) || *(_BYTE *)(a1 + 400)) && (*(_BYTE *)(*(_QWORD *)v67 + 128) & 4) != 0)
            re::SyncObjectManager::destroyObject(v67);
          v67 += 24;
        }
        while (v67 != v68);
      }
      a2 += 72;
    }
    while (a2 != v7);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v75);
}

BOOL re::SharedAppSyncManager::send(re::SharedAppSyncManager *a1, uint64_t a2, const void *a3, size_t a4)
{
  uint64_t Peer;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  Peer = re::SharedAppSyncManager::findPeer(a1, a2);
  v7 = Peer;
  if (Peer)
  {
    if (a4)
    {
      v8 = (*(uint64_t (**)(_QWORD, size_t))(**(_QWORD **)(Peer + 128) + 32))(*(_QWORD *)(Peer + 128), a4);
      if (v8)
      {
        v9 = v8;
        memcpy(*(void **)(v8 + 16), a3, a4);
        *(_DWORD *)(v9 + 24) = a4;
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v7 + 128) + 48))(*(_QWORD *)(v7 + 128), v9);
      }
    }
  }
  return v7 != 0;
}

void removeFromViewRecursive(re::SyncObject **a1, uint64_t a2, uint64_t a3)
{
  re::SyncObject *v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  unint64_t LatestState;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  _BYTE v20[12];
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  if (*((_QWORD *)v4 + 8) == *((_QWORD *)v4 + 9))
  {
    v5 = *re::networkLogObjects(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = *((_QWORD *)*a1 + 3);
      v7 = *(_QWORD **)(*((_QWORD *)*a1 + 11) + 16);
      v8 = v7[4];
      v9 = v7[6];
      v10 = (char *)v7[7];
      v11 = (char *)v7 + 49;
      if ((v9 & 1) != 0)
        v11 = v10;
      *(_DWORD *)v20 = 134218498;
      *(_QWORD *)&v20[4] = v6;
      v21 = 2048;
      v22 = v8;
      v23 = 2080;
      v24 = v11;
      _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "Sync object without snapshot while removing view (id: %llu, type: %llu[%s]).", v20, 0x20u);
    }
  }
  else
  {
    if ((*((_BYTE *)v4 + 128) & 4) == 0
      || (LatestState = re::SyncObject::getLatestState(v4)) == 0
      || *(_QWORD *)(LatestState + 88) != a3)
    {
      re::SyncSnapshot::removeFromView((_QWORD *)(a2 + 32), a1);
    }
    v15 = *((_QWORD *)*a1 + 25);
    if (v15)
    {
      v16 = (uint64_t *)*((_QWORD *)*a1 + 27);
      v17 = 8 * v15;
      do
      {
        v18 = *v16;
        *(_QWORD *)v20 = v18;
        if (v18)
          v19 = (id)(v18 + 8);
        removeFromViewRecursive(v20, a2, a3);
        if (*(_QWORD *)v20)

        ++v16;
        v17 -= 8;
      }
      while (v17);
    }
  }
}

_QWORD *re::DynamicArray<re::SyncCommit const*>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SyncObject *>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

re::SyncObject *entryIsAddable(re::SyncObject **a1, re::SyncObjectViewer *a2)
{
  re::SyncObject *result;
  re::SyncObject *v4;
  uint64_t v5;
  re::SyncObjectViewer **v6;
  uint64_t v7;
  uint64_t v8;
  re::SyncObjectViewer **v9;
  uint64_t v10;
  unint64_t LatestState;

  result = *a1;
  if (result)
  {
    v4 = result;
    while (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v4 + 11) + 16) + 74))
    {
      v4 = (re::SyncObject *)*((_QWORD *)v4 + 10);
      if (!v4)
        return 0;
    }
    v5 = *((_QWORD *)v4 + 12);
    if (!v5)
      return 0;
    v6 = *(re::SyncObjectViewer ***)(v5 + 120);
    v7 = *(_QWORD *)(v5 + 104);
    if (v7)
    {
      v8 = 8 * v7;
      v9 = v6;
      while (*v9 != a2)
      {
        ++v9;
        v8 -= 8;
        if (!v8)
        {
          v9 = &v6[v7];
          break;
        }
      }
    }
    else
    {
      v9 = v6;
    }
    if (v7 == v9 - v6)
      return 0;
    v10 = *((_QWORD *)a2 + 7);
    LatestState = re::SyncObject::getLatestState(result);
    if (LatestState)
    {
      if (*(_QWORD *)(LatestState + 88) == v10)
        return 0;
    }
    return (re::SyncObject *)!re::SyncObjectViewer::isViewChangePending(a2, v4);
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::SyncSnapshotEntry>::add(_QWORD *this, uint64_t *a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::internal::SyncSnapshotEntry>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = v3[4];
  v6 = *a2;
  *(_QWORD *)(v5 + 24 * v4) = *a2;
  if (v6)
    this = (id)(v6 + 8);
  v7 = v5 + 24 * v4;
  v8 = a2[1];
  *(_BYTE *)(v7 + 16) = *((_BYTE *)a2 + 16);
  *(_QWORD *)(v7 + 8) = v8;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

_QWORD *re::SharedAppSyncManager::session@<X0>(_QWORD *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  v2 = this[51];
  *a2 = v2;
  if (v2)
    return (id)(v2 + 8);
  return this;
}

void re::SharedAppSyncManager::requestOwnership(re *a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v4 = *(_QWORD *)(*(_QWORD *)a2 + 24);
    v5 = 134217984;
    v6 = v4;
    _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "[Ownership] Requesting ownership when using Shared App Sync (guid: %llu)", (uint8_t *)&v5, 0xCu);
  }
}

double re::SharedAppSyncManager::adjustTimeForSender(re::SharedAppSyncManager *this, double a2, uint64_t a3)
{
  uint64_t Peer;
  uint64_t v6;
  unint64_t v7;
  _BYTE v9[4];
  int v10;

  Peer = re::SharedAppSyncManager::findPeer(this, a3);
  if (Peer)
  {
    v6 = *(_QWORD *)(Peer + 112);
    if (v6)
    {
      re::Transport::connectionStats((re::Transport *)(*((_QWORD *)this + 51) + 2320), *(_QWORD *)(v6 + 32), (uint64_t)v9);
      if (v9[0])
      {
        LODWORD(v7) = v10;
        return a2 + (double)v7 / 1000.0 * 0.5;
      }
    }
  }
  return a2;
}

uint64_t re::SharedAppSyncManager::pausePeer(re::SharedAppSyncManager *this, uint64_t a2)
{
  uint64_t result;

  result = re::SharedAppSyncManager::findPeer(this, a2);
  if (result)
  {
    if (*(_QWORD *)(result + 112))
      *(_BYTE *)(result + 162) = 1;
  }
  return result;
}

uint64_t re::SharedAppSyncManager::resumePeer(re::SharedAppSyncManager *this, uint64_t a2)
{
  uint64_t result;

  result = re::SharedAppSyncManager::findPeer(this, a2);
  if (result)
  {
    if (*(_QWORD *)(result + 112))
      *(_BYTE *)(result + 162) = 0;
  }
  return result;
}

void re::SharedAppSyncManager::PeerState::~PeerState(re::SharedAppSyncManager::PeerState *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24E071268;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 256);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 21);
  objc_destroyWeak((id *)this + 19);
  *((_QWORD *)this + 19) = 0;
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {

    *((_QWORD *)this + 16) = 0;
  }
  objc_destroyWeak((id *)this + 15);
  *((_QWORD *)this + 15) = 0;
  v3 = *((_QWORD *)this + 14);
  if (v3)
  {

    *((_QWORD *)this + 14) = 0;
  }
  *(_QWORD *)this = &off_24E072818;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24E071268;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 256);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 21);
  objc_destroyWeak((id *)this + 19);
  *((_QWORD *)this + 19) = 0;
  v2 = *((_QWORD *)this + 16);
  if (v2)
  {

    *((_QWORD *)this + 16) = 0;
  }
  objc_destroyWeak((id *)this + 15);
  *((_QWORD *)this + 15) = 0;
  v3 = *((_QWORD *)this + 14);
  if (v3)
  {

    *((_QWORD *)this + 14) = 0;
  }
  *(_QWORD *)this = &off_24E072818;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  re::SyncViewer **v5;
  re::SyncViewer **v6;
  re::SyncViewer *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  re::SyncViewer **v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  re::SyncViewer **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  re::SyncViewer **v21;

  v2 = *(_QWORD **)(a1 + 8);
  v3 = v2[59];
  if (v3)
  {
    v4 = *a2;
    v5 = (re::SyncViewer **)v2[61];
    v6 = &v5[v3];
    do
    {
      v7 = *v5;
      if (*((_QWORD *)*v5 + 7) == *(_QWORD *)(v4 + 24))
      {
        v8 = *(_QWORD *)(v4 + 120);
        v9 = *(_QWORD *)(v4 + 104);
        if (v9)
        {
          v10 = 8 * v9;
          v11 = *(re::SyncViewer ***)(v4 + 120);
          while (*v11 != v7)
          {
            ++v11;
            v10 -= 8;
            if (!v10)
            {
              v11 = (re::SyncViewer **)(v8 + 8 * v9);
              break;
            }
          }
        }
        else
        {
          v11 = *(re::SyncViewer ***)(v4 + 120);
        }
        if (v9 != ((uint64_t)v11 - v8) >> 3)
          goto LABEL_30;
      }
      else
      {
        v12 = v2[63];
        if (!v12)
        {
          v18 = *(_QWORD *)(v4 + 120);
          v19 = *(_QWORD *)(v4 + 104);
          if (v19)
          {
            v20 = 8 * v19;
            v21 = *(re::SyncViewer ***)(v4 + 120);
            while (*v21 != v7)
            {
              ++v21;
              v20 -= 8;
              if (!v20)
              {
                v21 = (re::SyncViewer **)(v18 + 8 * v19);
                break;
              }
            }
          }
          else
          {
            v21 = *(re::SyncViewer ***)(v4 + 120);
          }
          if (v19 == ((uint64_t)v21 - v18) >> 3)
            goto LABEL_30;
LABEL_29:
          re::SyncView::removeViewer(v4, v7);
          goto LABEL_30;
        }
        v13 = (*(uint64_t (**)(uint64_t, _QWORD *))(v12 + 16))(v12, v2);
        v7 = *v5;
        v14 = *(_QWORD *)(v4 + 120);
        v15 = *(_QWORD *)(v4 + 104);
        if (v15)
        {
          v16 = 8 * v15;
          v17 = *(re::SyncViewer ***)(v4 + 120);
          while (*v17 != v7)
          {
            ++v17;
            v16 -= 8;
            if (!v16)
            {
              v17 = (re::SyncViewer **)(v14 + 8 * v15);
              break;
            }
          }
        }
        else
        {
          v17 = *(re::SyncViewer ***)(v4 + 120);
        }
        if (v13 == (v15 != ((uint64_t)v17 - v14) >> 3))
          goto LABEL_30;
        if (!v13)
          goto LABEL_29;
      }
      re::SyncView::addViewer((re::SyncViewer ***)v4, v7);
LABEL_30:
      ++v5;
    }
    while (v5 != v6);
  }
}

_QWORD *re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071390;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071390;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::size()
{
  return 16;
}

void re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::operator()(uint64_t a1, re::SyncViewer **a2)
{
  re::SyncViewer *v3;
  re::SharedAppSyncManager *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *a2;
  v4 = *(re::SharedAppSyncManager **)(a1 + 8);
  if (re::SharedAppSyncManager::findPeer(v4, *((_QWORD *)*a2 + 7)))
  {
    v5 = *((_QWORD *)v3 + 7);
    v6 = *(_QWORD *)(a1 + 16);
    if (v5 == *(_QWORD *)(v6 + 24) || v5 == *(_QWORD *)(v6 + 32))
      goto LABEL_7;
    v7 = *((_QWORD *)v4 + 63);
    if (v7 && (*(unsigned int (**)(uint64_t, re::SharedAppSyncManager *))(v7 + 16))(v7, v4))
    {
      v6 = *(_QWORD *)(a1 + 16);
LABEL_7:
      re::SyncView::addViewer((re::SyncViewer ***)v6, v3);
    }
  }
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E0713E8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E0713E8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::size()
{
  return 24;
}

void re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  re::SyncViewer *v3;

  v2 = *a2;
  v3 = **(re::SyncViewer ***)(a1 + 16);
  if (*((_QWORD *)v3 + 7) != *(_QWORD *)(v2 + 24))
  {
    if (!(*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 504) + 16))())
      return;
    v3 = **(re::SyncViewer ***)(a1 + 16);
  }
  re::SyncView::addViewer((re::SyncViewer ***)v2, v3);
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E071440;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E071440;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::size()
{
  return 24;
}

BOOL re::SyncObjectViewer::isViewChangePending(re::SyncObjectViewer *this, re::SyncObject *a2)
{
  char *v2;
  char *v3;
  _BOOL8 v4;
  re::SyncObject *v6;

  v2 = (char *)this + 64;
  v6 = a2;
  if (a2)
    v3 = (char *)a2 + 8;
  v4 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::containsKey((uint64_t)v2, (uint64_t *)&v6);
  if (v6)

  return v4;
}

BOOL re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 32 * v4 + 16) == v2)
    return 1;
  do
  {
    v4 = *(_DWORD *)(v6 + 32 * v4 + 8) & 0x7FFFFFFF;
    result = (_DWORD)v4 != 0x7FFFFFFF;
  }
  while ((_DWORD)v4 != 0x7FFFFFFF && *(_QWORD *)(v6 + 32 * v4 + 16) != v2);
  return result;
}

uint64_t re::Event<re::Session>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t *);
  _QWORD *v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  uint64_t v11;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *))a2[1];
  v4 = a2[2];
  v6 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *))(*v6 + v5);
  v7 = *a3;
  v11 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v9 = v5(v6, a1, &v11);
  if (v11)

  return v9;
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v6;
  uint64_t (*v7)(_QWORD *, uint64_t, uint64_t *, _QWORD);
  _QWORD *v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  uint64_t v13;

  v7 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *, _QWORD))a2[1];
  v6 = a2[2];
  v8 = (_QWORD *)(*a2 + (v6 >> 1));
  if ((v6 & 1) != 0)
    v7 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *, _QWORD))(*v8 + v7);
  v9 = *a3;
  v13 = v9;
  if (v9)
    v10 = (id)(v9 + 8);
  v11 = v7(v8, a1, &v13, *a4);
  if (v13)

  return v11;
}

uint64_t re::Event<re::Session,unsigned long long>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

uint64_t re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

re *std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::reset[abi:nn180100](re *result, uint64_t a2)
{
  void (***v2)(_QWORD);
  uint64_t v3;

  v2 = *(void (****)(_QWORD))result;
  *(_QWORD *)result = a2;
  if (v2)
  {
    v3 = re::globalAllocators(result)[2];
    (**v2)(v2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

_QWORD *re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  re *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  re *v12;
  uint64_t v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (re *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        v12 = (re *)v5[4];
        do
        {
          v13 = *(_QWORD *)v8;
          *(_QWORD *)v12 = 0;
          v12 = (re *)((char *)v12 + 8);
          *v11++ = v13;
          std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::reset[abi:nn180100](v8, 0);
          v8 = v12;
          v10 -= 8;
        }
        while (v10);
        v8 = (re *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, re *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void addToViewRecursive(re::SyncObject **a1, uint64_t a2, uint64_t a3)
{
  re::SyncObject *v4;
  unint64_t LatestState;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  uint64_t v13;

  v4 = *a1;
  if (*((_QWORD *)v4 + 8) != *((_QWORD *)v4 + 9))
  {
    LatestState = re::SyncObject::getLatestState(v4);
    if ((!LatestState || *(_QWORD *)(LatestState + 88) != a3) && (*((_BYTE *)*a1 + 128) & 4) == 0)
      re::SyncSnapshot::addToView((_QWORD *)(a2 + 32), a1);
    v8 = *((_QWORD *)*a1 + 25);
    if (v8)
    {
      v9 = (uint64_t *)*((_QWORD *)*a1 + 27);
      v10 = 8 * v8;
      do
      {
        v11 = *v9;
        v13 = v11;
        if (v11)
          v12 = (id)(v11 + 8);
        addToViewRecursive(&v13, a2, a3);
        if (v13)

        ++v9;
        v10 -= 8;
      }
      while (v10);
    }
  }
}

_QWORD *re::DynamicArray<re::SyncObject *>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::internal::SyncSnapshotEntry>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

double RESyncDiscoveryViewObserverCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 80, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E071500;
  result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_QWORD *)(v2 + 72) = 0;
  return result;
}

void *RESyncDiscoveryViewObserverOnCreate(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 24);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnDestroy(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 32);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnGetIdentitiesCount(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 40);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnGetIdentityAtIndex(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 48);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 48) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnGetAuthData(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 56);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnRequestIdentity(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 64);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnCreateProtocolLayer(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 72);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

double RESyncDiscoveryIdentityObserverCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 64, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E071548;
  result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_QWORD *)(v2 + 56) = 0;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnCreate(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 24);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnDestroy(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 32);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnGetDisplayName(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 40);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnGetAddress(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 48);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 48) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnIsLocal(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 56);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

uint64_t RESyncDiscoveryViewCreateWithAddresses(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  const char **v5;
  const char *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  id v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  id v19;
  _anonymous_namespace_ *v21;
  char v22;
  _OWORD v23[2];
  uint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  _anonymous_namespace_ *v28;
  _QWORD v29[3];
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;

  v4 = a2;
  v5 = (const char **)a1;
  v32 = *MEMORY[0x24BDAC8D0];
  if (!a1 && a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid addresses.", "addresses != nullptr || addressesCount == 0", "RESyncDiscoveryViewCreateWithAddresses", 359);
    _os_crash();
    __break(1u);
LABEL_34:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid protocol provided.", "protocolLayer != nullptr", "RESyncDiscoveryViewCreateWithAddresses", 360);
    _os_crash();
    __break(1u);
  }
  if (!a3)
    goto LABEL_34;
  v28 = 0;
  v25 = 0;
  v26 = 0;
  v24 = 0;
  v27 = 0;
  if (a2)
  {
    do
    {
      v6 = *v5;
      if (*v5)
      {
        v7 = re::DynamicString::DynamicString((re::DynamicString *)v23, (const re::DynamicString *)&v21);
        v8 = v26;
        if (v26 >= v25)
        {
          v9 = v26 + 1;
          if (v25 < v26 + 1)
          {
            if (v24)
            {
              if (v25)
                v10 = 2 * v25;
              else
                v10 = 8;
              if (v10 <= v9)
                v11 = v26 + 1;
              else
                v11 = v10;
              re::DynamicArray<re::Address>::setCapacity(&v24, v11);
            }
            else
            {
              re::DynamicArray<re::Address>::setCapacity(&v24, v9);
              ++v27;
            }
          }
          v8 = v26;
        }
        re::DynamicString::DynamicString((_anonymous_namespace_ *)((char *)v28 + 32 * v8), (const re::DynamicString *)v23);
        ++v26;
        ++v27;
        if (*(_QWORD *)&v23[0])
        {
          if ((BYTE8(v23[0]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v23[0] + 40))();
          memset(v23, 0, sizeof(v23));
        }
        a1 = v21;
        if (v21 && (v22 & 1) != 0)
          a1 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v21 + 40))();
      }
      ++v5;
      --v4;
    }
    while (v4);
  }
  v12 = (void *)(a3 + 8);
  v13 = (id)(a3 + 8);
  v14 = v28;
  v15 = v26;
  v16 = re::globalAllocators((re *)(id)(a3 + 8))[2];
  v29[0] = &off_24E071498;
  v29[1] = a3;
  v30 = v16;
  v31 = v29;
  re::DebugDiscoveryView::createWithAddresses(v14, v15, (uint64_t)v29, (uint64_t *)v23);
  if (v31)
  {
    (*(void (**)(_QWORD *))*v31)(v31);
    if (v31 != v29)
      (*(void (**)(uint64_t))(*(_QWORD *)v30 + 40))(v30);
    v31 = 0;
  }
  v17 = *(_QWORD *)&v23[0];
  v18 = (void *)(*(_QWORD *)&v23[0] + 8);
  v19 = (id)(*(_QWORD *)&v23[0] + 8);
  if (v17)

  re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v24);
  return v17;
}

uint64_t RESyncDiscoveryViewAddAddress(_anonymous_namespace_ *a1, const char *a2)
{
  uint64_t result;
  uint64_t v5;
  char v6;
  _OWORD v7[2];

  re::DynamicString::DynamicString((re::DynamicString *)v7, (const re::DynamicString *)&v5);
  re::DebugDiscoveryView::addIdentityWithAddress(a1, (const re::Address *)v7);
  if (*(_QWORD *)&v7[0])
  {
    if ((BYTE8(v7[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v7[0] + 40))();
    memset(v7, 0, sizeof(v7));
  }
  result = v5;
  if (v5)
  {
    if ((v6 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
  }
  return result;
}

uint64_t RESyncDiscoveryViewRemoveAddress(_anonymous_namespace_ *a1, const char *a2)
{
  uint64_t result;
  uint64_t v5;
  char v6;
  _OWORD v7[2];

  re::DynamicString::DynamicString((re::DynamicString *)v7, (const re::DynamicString *)&v5);
  re::DebugDiscoveryView::removeIdentityWithAddress(a1, (const re::Address *)v7);
  if (*(_QWORD *)&v7[0])
  {
    if ((BYTE8(v7[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v7[0] + 40))();
    memset(v7, 0, sizeof(v7));
  }
  result = v5;
  if (v5)
  {
    if ((v6 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
  }
  return result;
}

uint64_t RESyncDiscoveryViewGetIdentitiesCount(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t RESyncDiscoveryViewGetIdentityAtIndex(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v6;

  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1) <= a2)
    return 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unint64_t))(*(_QWORD *)a1 + 56))(&v6, a1, a2);
  v4 = v6;
  if (v6)

  return v4;
}

uint64_t RESyncDiscoveryViewGetIdentityWithAddress(uint64_t a1, const char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  int v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v13;
  char v14;
  _BYTE v15[23];
  uint64_t v16;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  if (v4)
  {
    v5 = v4;
    v6 = 0;
    do
    {
      while (1)
      {
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(&v16, a1, v6);
        if (v16)
          break;
LABEL_12:
        if (++v6 == v5)
          return 0;
      }
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v16 + 40))(&v13);
      v7 = v14 & 1;
      if ((v14 & 1) != 0)
        v8 = *(const char **)&v15[7];
      else
        v8 = v15;
      v9 = strcmp(v8, a2);
      if (v13 && v7)
        (*(void (**)(void))(*(_QWORD *)v13 + 40))();
      v10 = v16;
      if (v16)
      {

        if (!v9)
          return v10;
        goto LABEL_12;
      }
      ++v6;
      if (v9)
        v11 = v6 == v5;
      else
        v11 = 1;
    }
    while (!v11);
  }
  return 0;
}

void RESyncDiscoveryViewNotifyJoin(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  id v5;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  if (a2)
    v5 = (id)(a2 + 8);
  re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(v4, a1);
  if (a2)

}

void re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;

  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
    re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions((_anonymous_namespace_ *)a1);
}

void RESyncDiscoveryViewNotifyLeave(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  id v5;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (a2)
    v5 = (id)(a2 + 8);
  re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(v4, a1);
  if (a2)

}

uint64_t RESyncDiscoveryViewCreateWithObserver(char *a1)
{
  char *v1;
  uint64_t *v2;
  uint64_t v3;
  void *v4;
  id v5;
  uint64_t v6;
  uint64_t (**v7)(void);
  _anonymous_namespace_ *v8;
  id v9;

  v1 = a1;
  if (a1)
    a1 = a1 + 8;
  v2 = re::globalAllocators((re *)a1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 208, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v3, 0);
  *(_QWORD *)v3 = &off_24E071590;
  *(_QWORD *)(v3 + 24) = v1;
  v4 = v1 + 8;
  v5 = v4;
  v6 = *(_QWORD *)(v3 + 24);
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_QWORD *)(v3 + 104) = 0;
  *(_DWORD *)(v3 + 112) = 0;
  *(_DWORD *)(v3 + 96) = 0;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_QWORD *)(v3 + 120) = 0;
  *(_QWORD *)(v3 + 128) = 0;
  *(_QWORD *)(v3 + 136) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  *(_QWORD *)(v3 + 192) = 0;
  *(_DWORD *)(v3 + 200) = 0;
  *(_DWORD *)(v3 + 184) = 0;
  *(_OWORD *)(v3 + 168) = 0u;
  *(_OWORD *)(v3 + 152) = 0u;
  v7 = *(uint64_t (***)(void))(v6 + 24);
  if (v7)
    v7 = (uint64_t (**)(void))v7[2]();
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(v3 + 32), 0);
  ++*(_DWORD *)(v3 + 56);
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(v3 + 120), 0);
  ++*(_DWORD *)(v3 + 144);

  v9 = (id)(v3 + 8);
  return v3;
}

_QWORD *RESyncIdentityCreateWithObserver(char *a1)
{
  char *v1;
  uint64_t *v2;
  _QWORD *v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD *v7;

  v1 = a1;
  if (a1)
    a1 = a1 + 8;
  v2 = re::globalAllocators((re *)a1);
  v3 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 32, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v3, 0);
  *v3 = &off_24E071618;
  v3[3] = v1;
  v4 = v1 + 8;
  v5 = v4;
  v6 = *(_QWORD *)(v3[3] + 24);
  if (v6)
    (*(void (**)(void))(v6 + 16))();

  v7 = v3 + 1;
  return v3;
}

uint64_t RESyncIdentityGetDisplayName(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
}

size_t RESyncIdentityGetAddress(uint64_t a1, char *a2, size_t a3)
{
  char v5;
  const char *v6;
  size_t v7;
  size_t v8;
  BOOL v9;
  uint64_t v11;
  char v12;
  _BYTE v13[23];

  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)a1 + 40))(&v11);
  v5 = v12;
  if ((v12 & 1) != 0)
    v6 = *(const char **)&v13[7];
  else
    v6 = v13;
  v7 = strlen(v6);
  v8 = v7;
  if (a2 && v7 < a3)
    strcpy(a2, v6);
  if (v11)
    v9 = (v5 & 1) == 0;
  else
    v9 = 1;
  if (!v9)
    (*(void (**)(void))(*(_QWORD *)v11 + 40))();
  return v8;
}

uint64_t RESyncIdentityIsLocal(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

_QWORD *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071498;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071498;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x220780CD0);
}

_QWORD *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator()@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  v2 = result[1];
  *a2 = v2;
  if (v2)
    return (id)(v2 + 8);
  return result;
}

_QWORD *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  id v4;

  v3 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071498;
  a2[1] = v3;
  if (v3)
    v4 = (id)(v3 + 8);
  return a2;
}

_QWORD *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071498;
  a2[1] = v2;
  *(_QWORD *)(a1 + 8) = 0;
  return a2;
}

uint64_t re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::size()
{
  return 16;
}

void `anonymous namespace'::DiscoveryViewObserver::~DiscoveryViewObserver(_anonymous_namespace_::DiscoveryViewObserver *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  *(_QWORD *)this = &off_24E071500;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    _Block_release(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    _Block_release(v3);
  v4 = (const void *)*((_QWORD *)this + 5);
  if (v4)
    _Block_release(v4);
  v5 = (const void *)*((_QWORD *)this + 6);
  if (v5)
    _Block_release(v5);
  v6 = (const void *)*((_QWORD *)this + 7);
  if (v6)
    _Block_release(v6);
  v7 = (const void *)*((_QWORD *)this + 8);
  if (v7)
    _Block_release(v7);
  v8 = (const void *)*((_QWORD *)this + 9);
  if (v8)
    _Block_release(v8);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  JUMPOUT(0x220780CD0);
}

void `anonymous namespace'::DiscoveryIdentityObserver::~DiscoveryIdentityObserver(_anonymous_namespace_::DiscoveryIdentityObserver *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_24E071548;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    _Block_release(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    _Block_release(v3);
  v4 = (const void *)*((_QWORD *)this + 5);
  if (v4)
    _Block_release(v4);
  v5 = (const void *)*((_QWORD *)this + 6);
  if (v5)
    _Block_release(v5);
  v6 = (const void *)*((_QWORD *)this + 7);
  if (v6)
    _Block_release(v6);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  JUMPOUT(0x220780CD0);
}

_QWORD *re::DynamicArray<re::Address>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  re::DynamicString *v7;
  const re::DynamicString *v8;
  uint64_t v9;
  uint64_t v10;
  re::DynamicString *v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::Address>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = (re::DynamicString *)result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (const re::DynamicString *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 32 * v9;
        v11 = v7;
        do
        {
          re::DynamicString::DynamicString(v11, v8);
          if (*(_QWORD *)v8)
          {
            if ((*((_BYTE *)v8 + 8) & 1) != 0)
              (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v8 + 40))(*(_QWORD *)v8, *((_QWORD *)v8 + 2));
            *(_OWORD *)v8 = 0u;
            *((_OWORD *)v8 + 1) = 0u;
          }
          v8 = (const re::DynamicString *)((char *)v8 + 32);
          v11 = (re::DynamicString *)((char *)v11 + 32);
          v10 -= 32;
        }
        while (v10);
        v8 = (const re::DynamicString *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, const re::DynamicString *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

void `anonymous namespace'::DiscoveryViewProxy::~DiscoveryViewProxy(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(*((_QWORD *)this + 3) + 32);
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  v3 = *((_QWORD *)this + 15);
  if (v3)
  {
    if (*((_QWORD *)this + 19))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    *((_QWORD *)this + 15) = 0;
    ++*((_DWORD *)this + 36);
  }
  v4 = *((_QWORD *)this + 4);
  if (v4)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    ++*((_DWORD *)this + 14);
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 15);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 4);
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  JUMPOUT(0x220780CD0);
}

uint64_t `anonymous namespace'::DiscoveryViewProxy::didJoinEvent(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  return (uint64_t)this + 32;
}

uint64_t `anonymous namespace'::DiscoveryViewProxy::didLeaveEvent(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  return (uint64_t)this + 120;
}

uint64_t `anonymous namespace'::DiscoveryViewProxy::identitiesCount(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 40) + 16))();
}

char *`anonymous namespace'::DiscoveryViewProxy::identityAtIndex@<X0>(_anonymous_namespace_::DiscoveryViewProxy *this@<X0>, char **a2@<X8>)
{
  char *result;

  result = (char *)(*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 48) + 16))();
  *a2 = result;
  if (result)
    return result + 8;
  return result;
}

uint64_t `anonymous namespace'::DiscoveryViewProxy::authData(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v3 = 0;
  v4 = 0;
  v2 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)(*((_QWORD *)this + 3) + 56) + 16))(&v2);
  return v3;
}

uint64_t `anonymous namespace'::DiscoveryViewProxy::requestIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[3];

  v7[0] = 0;
  v7[1] = a3;
  v7[2] = a4;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 64);
  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v5 = *(_QWORD *)(a2 + 16);
  else
    v5 = a2 + 9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD *))(v4 + 16))(v4, v5, v7);
}

uint64_t `anonymous namespace'::DiscoveryViewProxy::removeIdentity()
{
  return 0;
}

uint64_t `anonymous namespace'::DiscoveryViewProxy::createProtocolLayer@<X0>(_anonymous_namespace_::DiscoveryViewProxy *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 72) + 16))();
  *a2 = result;
  return result;
}

void `anonymous namespace'::DiscoveryIdentityProxy::~DiscoveryIdentityProxy(_anonymous_namespace_::DiscoveryIdentityProxy *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 3);
  v3 = *(_QWORD *)(v2 + 32);
  if (!v3 || ((*(void (**)(void))(v3 + 16))(), (v2 = *((_QWORD *)this + 3)) != 0))
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  JUMPOUT(0x220780CD0);
}

uint64_t `anonymous namespace'::DiscoveryIdentityProxy::displayName(_anonymous_namespace_::DiscoveryIdentityProxy *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 40) + 16))();
}

uint64_t `anonymous namespace'::DiscoveryIdentityProxy::address@<X0>(_anonymous_namespace_::DiscoveryIdentityProxy *this@<X0>, re::DynamicString *a2@<X8>)
{
  _anonymous_namespace_ *v3;
  uint64_t result;
  uint64_t v5;
  char v6;

  v3 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 48) + 16))();
  re::DynamicString::DynamicString(a2, (const re::DynamicString *)&v5);
  result = v5;
  if (v5)
  {
    if ((v6 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
  }
  return result;
}

uint64_t `anonymous namespace'::DiscoveryIdentityProxy::isLocal(_anonymous_namespace_::DiscoveryIdentityProxy *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 3) + 56) + 16))();
}

re::RoutingTable *re::RoutingTable::RoutingTable(re::RoutingTable *this)
{
  _anonymous_namespace_ *v2;
  _QWORD v4[2];

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E0716A8;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *(_QWORD *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 15) = 0;
  uuid_generate_random((unsigned __int8 *)v4);
  *((_QWORD *)this + 3) = (v4[1] + (v4[0] << 6) + (v4[0] >> 2) - 0x61C8864680B583E9) ^ v4[0];
  return this;
}

unint64_t *re::RoutingTable::getRoute@<X0>(re::RoutingTable *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t *result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9[2];
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  __int16 v16;
  unint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v9[0] = a2;
  result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 72, v9);
  if (result)
  {
    v6 = *result;
    v7 = *((_QWORD *)this + 6);
    if (v7 <= *result)
    {
      v9[1] = 0;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v18 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v10 = 136315906;
      v11 = "operator[]";
      v12 = 1024;
      v13 = 789;
      v14 = 2048;
      v15 = v6;
      v16 = 2048;
      v17 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v8 = *((_QWORD *)this + 8) + 40 * v6;
    *(_QWORD *)(v8 + 32) = *((_QWORD *)this + 15);
    *(_BYTE *)a3 = 1;
    *(_OWORD *)(a3 + 8) = *(_OWORD *)(v8 + 8);
    *(_QWORD *)(a3 + 24) = *(_QWORD *)(v8 + 24);
  }
  else
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 32 * v4 + 16) != v2)
  {
    while (1)
    {
      v4 = *(_DWORD *)(v6 + 32 * v4 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v6 + 32 * v4 + 16) == v2)
        return v6 + 32 * v4 + 24;
    }
    return 0;
  }
  return v6 + 32 * v4 + 24;
}

unint64_t *re::RoutingTable::addRoute(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  unint64_t *result;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  BOOL v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23[2];
  _BYTE v24[12];
  __int16 v25;
  int v26;
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  unint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v23[0] = a2;
  v5 = a1 + 72;
  result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 72, v23);
  if (result)
  {
    v7 = *result;
    v8 = *(_QWORD *)(a1 + 48);
    if (v8 <= *result)
    {
      v23[1] = 0;
      v34 = 0u;
      v35 = 0u;
      v32 = 0u;
      v33 = 0u;
      v31 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v24 = 136315906;
      *(_QWORD *)&v24[4] = "operator[]";
      v25 = 1024;
      v26 = 789;
      v27 = 2048;
      v28 = v7;
      v29 = 2048;
      v30 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = *(_QWORD *)(a1 + 64);
    if (*((_DWORD *)a3 + 4) < *(_DWORD *)(v9 + 40 * v7 + 24))
    {
      v10 = *a3;
      v11 = v9 + 40 * v7;
      *(_DWORD *)(v11 + 24) = *((_DWORD *)a3 + 4);
      *(_OWORD *)(v11 + 8) = v10;
    }
  }
  else
  {
    v12 = v23[0];
    v31 = *a3;
    LODWORD(v32) = *((_DWORD *)a3 + 4);
    v13 = *(_QWORD *)(a1 + 120);
    v14 = *(_QWORD *)(a1 + 40);
    v15 = *(_QWORD *)(a1 + 48);
    if (v15 >= v14)
    {
      v16 = v15 + 1;
      if (v14 < v15 + 1)
      {
        if (*(_QWORD *)(a1 + 32))
        {
          v17 = 2 * v14;
          v18 = v14 == 0;
          v19 = 8;
          if (!v18)
            v19 = v17;
          if (v19 <= v16)
            v20 = v16;
          else
            v20 = v19;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity((_QWORD *)(a1 + 32), v20);
        }
        else
        {
          re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity((_QWORD *)(a1 + 32), v16);
          ++*(_DWORD *)(a1 + 56);
        }
      }
      v15 = *(_QWORD *)(a1 + 48);
    }
    v21 = *(_QWORD *)(a1 + 64) + 40 * v15;
    *(_QWORD *)v21 = v12;
    *(_OWORD *)(v21 + 8) = v31;
    *(_DWORD *)(v21 + 24) = v32;
    *(_QWORD *)(v21 + 32) = v13;
    v22 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v22 + 1;
    ++*(_DWORD *)(a1 + 56);
    *(_QWORD *)v24 = v22;
    return (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(v5, v23, v24);
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 32 * v10;
  return v12 + 24;
}

unint64_t *re::RoutingTable::removeRouteForPeerID(re::RoutingTable *this, uint64_t a2)
{
  unint64_t *result;
  uint64_t v4;

  v4 = a2;
  result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 72, &v4);
  if (result)
    return (unint64_t *)re::RoutingTable::removeEntryAtIndex(this, *result);
  return result;
}

uint64_t re::RoutingTable::removeEntryAtIndex(re::RoutingTable *this, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  __int128 *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;

  v2 = *((_QWORD *)this + 6);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v4 = *((_QWORD *)this + 8);
  v5 = (__int128 *)(v4 + 40 * a2);
  v6 = v4 + 40 * v2;
  v7 = *v5;
  v8 = v5[1];
  v9 = *((_QWORD *)v5 + 4);
  v10 = *(_QWORD *)(v6 - 8);
  v11 = *(_OWORD *)(v6 - 24);
  *v5 = *(_OWORD *)(v6 - 40);
  v5[1] = v11;
  *((_QWORD *)v5 + 4) = v10;
  *(_QWORD *)(v6 - 8) = v9;
  *(_OWORD *)(v6 - 24) = v8;
  *(_OWORD *)(v6 - 40) = v7;
  if (*((_QWORD *)this + 6) <= a2)
    goto LABEL_13;
  v12 = (char *)this + 72;
  v13 = *((_QWORD *)this + 8);
  LODWORD(v14) = 0x7FFFFFFF;
  if (*((_QWORD *)this + 9))
  {
    v15 = *(_QWORD *)(v13 + 40 * a2);
    v16 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
    v17 = *(unsigned int *)(*((_QWORD *)this + 10) + 4 * ((v16 ^ (v16 >> 31)) % *((unsigned int *)this + 24)));
    if ((_DWORD)v17 != 0x7FFFFFFF)
    {
      v18 = *((_QWORD *)this + 11);
      LODWORD(v14) = v17;
      if (*(_QWORD *)(v18 + 32 * v17 + 16) != v15)
      {
        v14 = v17;
        while (1)
        {
          v14 = *(_DWORD *)(v18 + 32 * v14 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v14 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v18 + 32 * v14 + 16) == v15)
            goto LABEL_11;
        }
        LODWORD(v14) = 0x7FFFFFFF;
      }
    }
  }
LABEL_11:
  *(_QWORD *)(*((_QWORD *)this + 11) + 32 * v14 + 24) = a2;
  result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v12, (uint64_t *)(v13 + 40 * *((_QWORD *)this + 6) - 40));
  --*((_QWORD *)this + 6);
  ++*((_DWORD *)this + 14);
  return result;
}

re::RoutingTable *re::RoutingTable::removeRoutesForTransport(re::RoutingTable *this, re::Transport *a2)
{
  uint64_t v2;
  re::RoutingTable *v4;
  unint64_t v5;
  uint64_t v6;

  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    v4 = this;
    v5 = v2 - 1;
    v6 = 40 * v2 - 32;
    do
    {
      if (*((_QWORD *)v4 + 6) <= v5)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (*(re::Transport **)(*((_QWORD *)v4 + 8) + v6) == a2)
        this = (re::RoutingTable *)re::RoutingTable::removeEntryAtIndex(v4, v5);
      --v5;
      v6 -= 40;
    }
    while (v5 != -1);
  }
  return this;
}

re::RoutingTable *re::RoutingTable::removeRoutesForConnection(re::RoutingTable *this, re::Transport *a2, uint64_t a3)
{
  uint64_t v3;
  re::RoutingTable *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *((_QWORD *)this + 6);
  if (v3)
  {
    v6 = this;
    v7 = v3 - 1;
    v8 = 40 * v3;
    do
    {
      if (*((_QWORD *)v6 + 6) <= v7)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v9 = *((_QWORD *)v6 + 8) + v8;
      if (*(re::Transport **)(v9 - 32) == a2 && *(_QWORD *)(v9 - 24) == a3)
        this = (re::RoutingTable *)re::RoutingTable::removeEntryAtIndex(v6, v7);
      --v7;
      v8 -= 40;
    }
    while (v7 != -1);
  }
  return this;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  int v16;
  int v17;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(unsigned int *)(v5 + 4 * v4);
  if ((_DWORD)v6 == 0x7FFFFFFF)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  v9 = v8 + 32 * v6;
  if (*(_QWORD *)(v9 + 16) != v2)
  {
    while (1)
    {
      v10 = v6;
      v6 = *(_DWORD *)(v8 + 32 * v6 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v6 == 0x7FFFFFFF)
        return 0;
      v11 = v8 + 32 * v6;
      if (*(_QWORD *)(v11 + 16) == v2)
      {
        *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_9:
  v12 = *(_QWORD *)(a1 + 16);
  v13 = v12 + 32 * v6;
  v16 = *(_DWORD *)(v13 + 8);
  v15 = (int *)(v13 + 8);
  v14 = v16;
  if (v16 < 0)
  {
    *v15 = v14 & 0x7FFFFFFF;
    v12 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v12 + 32 * v6 + 8);
  }
  v17 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v12 + 32 * v6 + 8) = *(_DWORD *)(a1 + 36) | v14 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v17 + 1;
  return 1;
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep re::RoutingTable::update(re::RoutingTable *this)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = std::chrono::steady_clock::now().__d_.__rep_;
  *((_QWORD *)this + 15) = result / 1000000000;
  v3 = *((_QWORD *)this + 6);
  if (v3 >= 0x200)
  {
    v4 = v3 - 1;
    v5 = 40 * v3;
    do
    {
      if (*((_QWORD *)this + 6) <= v4)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v6 = *((_QWORD *)this + 8) + v5;
      if (*(_DWORD *)(v6 - 16) >= 2u && *((_QWORD *)this + 15) - *(_QWORD *)(v6 - 8) >= 0x258uLL)
        result = re::RoutingTable::removeEntryAtIndex(this, v4);
      --v4;
      v5 -= 40;
    }
    while (v4 != -1);
  }
  return result;
}

void re::RoutingTable::~RoutingTable(re::RoutingTable *this)
{
  double v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24E0716A8;
  v2 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  v3 = *((_QWORD *)this + 4);
  if (v3)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    ++*((_DWORD *)this + 14);
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  double v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24E0716A8;
  v2 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  v3 = *((_QWORD *)this + 4);
  if (v3)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    ++*((_DWORD *)this + 14);
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  v13 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 16), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 24));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep re::NetworkClockDefault::timestampMs(re::NetworkClockDefault *this)
{
  return std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
}

void re::NetworkClockDefault::~NetworkClockDefault(re::NetworkClockDefault *this)
{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

void re::DynamicPacketBitWriter::~DynamicPacketBitWriter(re::DynamicPacketBitWriter *this)
{
  if (*((_QWORD *)this + 6))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 5) + 24))(*((_QWORD *)this + 5));
    *((_QWORD *)this + 6) = 0;
  }
}

{
  if (*((_QWORD *)this + 6))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 5) + 24))(*((_QWORD *)this + 5));
    *((_QWORD *)this + 6) = 0;
  }
  JUMPOUT(0x220780CD0);
}

void *re::DynamicPacketBitWriter::grow(void *this, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;

  v2 = a2;
  v3 = (uint64_t)this;
  if (a2 <= 0x10000)
    a2 = 0x10000;
  else
    a2 = a2;
  v4 = *((_QWORD *)this + 6);
  if (!v4
    || ((v5 = *((_DWORD *)this + 4), v6 = v5 + v2, 2 * v5 <= v6) ? (a2 = v6) : (a2 = (2 * v5)),
        a2 > *(_DWORD *)(v4 + 28)))
  {
    this = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 5) + 16))(*((_QWORD *)this + 5), a2);
    if (this)
    {
      v7 = this;
      this = memmove(*((void **)this + 2), *(const void **)(v3 + 8), *(unsigned int *)(v3 + 16));
      if (*(_QWORD *)(v3 + 48))
        this = (void *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 40) + 24))(*(_QWORD *)(v3 + 40));
      *(_QWORD *)(v3 + 48) = v7;
      *(_QWORD *)(v3 + 8) = v7[2];
      *(_DWORD *)(v3 + 16) = *((_DWORD *)v7 + 7);
    }
    else
    {
      *(_BYTE *)(v3 + 20) = 1;
    }
  }
  return this;
}

re::SyncObjectTypeInfo *RESyncSyncableTypeInfoCreate(re *a1)
{
  uint64_t *v1;
  re::SyncObjectTypeInfo *v2;

  v1 = re::globalAllocators(a1);
  v2 = (re::SyncObjectTypeInfo *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 144, 8);
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  return re::SyncObjectTypeInfo::SyncObjectTypeInfo(v2);
}

uint64_t RESyncSyncableTypeInfoSetTypeId(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 32) = a2;
  return result;
}

uint64_t RESyncSyncableTypeInfoGetTypeId(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

_anonymous_namespace_ *RESyncSyncableTypeInfoSetDebugName(_anonymous_namespace_ *result, const char *a2)
{
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;
  char v5;

  if (result)
  {
    if (a2)
    {
      v3 = result;
      re::DynamicString::operator=((_anonymous_namespace_ *)((char *)v3 + 40), (re::DynamicString *)&v4);
      result = v4;
      if (v4)
      {
        if ((v5 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v4 + 40))();
      }
    }
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoGetDebugName(uint64_t result)
{
  if (result)
  {
    if ((*(_BYTE *)(result + 48) & 1) != 0)
      return *(_QWORD *)(result + 56);
    else
      result += 49;
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetSupportsNetworkSync(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 24) = a2;
  return result;
}

BOOL RESyncSyncableTypeInfoSupportsNetworkSync(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 24) != 0;
  return result;
}

uint64_t RESyncSyncableTypeInfoSetSupportsOwnershipTransfer(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 73) = a2;
  return result;
}

BOOL RESyncSyncableTypeInfoSupportsOwnershipTransfer(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 73) != 0;
  return result;
}

uint64_t RESyncSyncableTypeInfoSetSupportsViews(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 74) = a2;
  return result;
}

BOOL RESyncSyncableTypeInfoSupportsViews(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 74) != 0;
  return result;
}

uint64_t RESyncSyncableTypeInfoGetReadSnapshotCb(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 80);
  return result;
}

uint64_t RESyncSyncableTypeInfoSetReadSnapshotCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setReadSnapshotCb(a1, aBlock);
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetWriteSnapshotCb(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 88);
  return result;
}

uint64_t RESyncSyncableTypeInfoSetWriteSnapshotCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setWriteSnapshotCb(a1, aBlock);
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetReadPayloadCb(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 96);
  return result;
}

uint64_t RESyncSyncableTypeInfoSetReadPayloadCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setReadPayloadCb(a1, aBlock);
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetReadPayloadDeltaCb(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 104);
  return result;
}

uint64_t RESyncSyncableTypeInfoSetReadPayloadDeltaCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setReadPayloadDeltaCb(a1, aBlock);
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetWritePayloadCb(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 112);
  return result;
}

uint64_t RESyncSyncableTypeInfoSetWritePayloadCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setWritePayloadCb(a1, aBlock);
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetWritePayloadDeltaCb(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 120);
  return result;
}

uint64_t RESyncSyncableTypeInfoSetWritePayloadDeltaCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setWritePayloadDeltaCb(a1, aBlock);
  return a1;
}

uint64_t RESyncSyncableTypeInfoSetShouldPackCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setShouldPackCb(a1, aBlock);
  return a1;
}

uint64_t RESyncSyncableTypeInfoSetShouldUnpackCb(uint64_t a1, void *aBlock)
{
  if (a1)
    return (uint64_t)re::SyncObjectTypeInfo::setShouldUnpackCb(a1, aBlock);
  return a1;
}

uint64_t RESyncCongestionGetBandwidthEventDataSize()
{
  return 24;
}

_QWORD *RESyncCongestionCreateBandwidthEventDataNoAlloc(_QWORD *a1, unint64_t a2)
{
  _QWORD *v2;

  v2 = 0;
  if (a1 && a2 >= 0x18)
  {
    *a1 = 0;
    a1[1] = 0;
    v2 = a1;
    a1[2] = 0;
  }
  return v2;
}

uint64_t RESyncCongestionBandwidthEventDataSetTotalAvailableBitsPerSecond(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!a1)
    return 1;
  if (!*(_BYTE *)(a1 + 8))
    *(_BYTE *)(a1 + 8) = 1;
  result = 0;
  *(_QWORD *)(a1 + 16) = a2;
  return result;
}

uint64_t re::NWProtocolLayer::NWProtocolLayer(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  NWProtocolDelegate *v5;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24E071810;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 32) = *(_BYTE *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 8));
  v4 = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = v4;
  *(_DWORD *)(a1 + 96) = 10;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v5 = objc_alloc_init(NWProtocolDelegate);
  *(_QWORD *)(a1 + 120) = v5;
  *(_QWORD *)(a1 + 128) = 0;
  re::NWProtocolFramer::definition((re::NWProtocolFramer *)v5);
  *(_QWORD *)(a1 + 136) = objc_claimAutoreleasedReturnValue();
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 188) = 0u;
  *(_QWORD *)(a1 + 204) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 216) = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) = a1;
  return a1;
}

void re::NWProtocolLayer::~NWProtocolLayer(re::NWProtocolLayer *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24E071810;
  if (*((_QWORD *)this + 3))
    re::NWProtocolLayer::deinit((os_unfair_lock_s *)this);
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 21);
  v2 = (void *)*((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = 0;

  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::NWProtocolLayer::~NWProtocolLayer(this);
  JUMPOUT(0x220780CD0);
}

void re::NWProtocolLayer::assertNetworkQueue(re::NWProtocolLayer *this)
{
  re::NWProtocolLayer *v1;

  v1 = this;
  dispatch_assert_queue_V2((dispatch_queue_t)v1);

}

uint64_t re::NWProtocolLayer::init(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  id v5;
  uint64_t v6;
  nw_parameters_t v7;
  void *v8;
  NSObject *v9;
  NSObject *options;
  NSObject *v11;
  NSObject *v12;
  nw_parameters_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  void *v18;
  NWListener *v19;
  void *v20;
  NSObject *v21;
  NSObject *v22;
  dispatch_queue_t v23;
  uint64_t v24;
  void *v25;
  re *v26;
  NSObject *v27;
  unint64_t v28;
  unint64_t v29;
  NSObject *host_with_numeric_port;
  int v31;
  NSObject *v32;
  _BOOL4 v33;
  unint64_t v34;
  unint64_t v35;
  const char *v36;
  unint64_t v37;
  unint64_t v38;
  const char *v39;
  int v40;
  void *v41;
  nw_listener_t v42;
  nw_listener_t v43;
  int v44;
  re *v45;
  NSObject *v46;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  int v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
    v5 = (id)(v4 + 8);
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v4;
  if (v6)

  objc_storeStrong((id *)(a1 + 160), *(id *)a2);
  v7 = nw_parameters_create();
  v8 = *(void **)(a1 + 152);
  *(_QWORD *)(a1 + 152) = v7;

  nw_parameters_set_reuse_local_address(*(nw_parameters_t *)(a1 + 152), 1);
  nw_parameters_set_no_delay();
  v9 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(a1 + 152));
  options = nw_tcp_create_options();
  v11 = options;
  if (*(_DWORD *)(a1 + 96))
  {
    nw_tcp_options_set_enable_keepalive(options, 1);
    nw_tcp_options_set_keepalive_idle_time(v11, *(_DWORD *)(a1 + 96));
    nw_tcp_options_set_keepalive_count(v11, 4u);
    nw_tcp_options_set_keepalive_interval(v11, 5u);
  }
  else
  {
    nw_tcp_options_set_enable_keepalive(options, 0);
  }
  nw_protocol_stack_set_transport_protocol(v9, v11);
  v12 = nw_framer_create_options(*(nw_protocol_definition_t *)(a1 + 136));
  nw_protocol_stack_prepend_application_protocol(v9, v12);

  v13 = nw_parameters_create();
  v14 = *(void **)(a1 + 144);
  *(_QWORD *)(a1 + 144) = v13;

  v15 = 1;
  nw_parameters_set_reuse_local_address(*(nw_parameters_t *)(a1 + 144), 1);
  nw_parameters_set_no_delay();
  v16 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(a1 + 144));
  v17 = nw_framer_create_options(*(nw_protocol_definition_t *)(a1 + 136));
  nw_protocol_stack_prepend_application_protocol(v16, v17);

  v18 = (void *)nw_context_create();
  nw_context_set_isolate_protocol_stack();
  nw_context_set_scheduling_mode();
  nw_parameters_set_context();

  if (*(_BYTE *)(a1 + 32))
  {
    v19 = -[NWListener initWithLayer:]([NWListener alloc], "initWithLayer:", a1);
    v20 = *(void **)(a1 + 128);
    *(_QWORD *)(a1 + 128) = v19;

    dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v21 = objc_claimAutoreleasedReturnValue();
    dispatch_get_global_queue(21, 0);
    v22 = objc_claimAutoreleasedReturnValue();
    v23 = dispatch_queue_create_with_target_V2("re-nw-protocol-listener", v21, v22);
    v24 = *(_QWORD *)(a1 + 128);
    v25 = *(void **)(v24 + 8);
    *(_QWORD *)(v24 + 8) = v23;

    objc_storeStrong((id *)(*(_QWORD *)(a1 + 128) + 16), *(id *)(a1 + 160));
    v26 = (re *)nw_parameters_copy(*(nw_parameters_t *)(a1 + 152));
    v27 = v26;
    v28 = *(_QWORD *)(a1 + 48);
    v29 = v28 >> 1;
    if ((v28 & 1) == 0)
      v29 = v28 >> 1;
    if (v29)
    {
      host_with_numeric_port = nw_endpoint_create_host_with_numeric_port();
      nw_parameters_set_local_endpoint(v27, host_with_numeric_port);

    }
    v31 = *(unsigned __int16 *)(a1 + 72);
    v32 = *re::networkLogObjects(v26);
    v33 = os_log_type_enabled(v32, OS_LOG_TYPE_INFO);
    if (v31)
    {
      if (v33)
      {
        v34 = *(_QWORD *)(a1 + 48);
        v35 = v34 >> 1;
        if ((v34 & 1) == 0)
          v35 = v34 >> 1;
        if (v35)
        {
          if ((v34 & 1) != 0)
            v36 = *(const char **)(a1 + 56);
          else
            v36 = (const char *)(a1 + 49);
        }
        else
        {
          v36 = "any";
        }
        v40 = *(unsigned __int16 *)(a1 + 72);
        *(_DWORD *)buf = 136315394;
        v49 = v36;
        v50 = 1024;
        v51 = v40;
        _os_log_impl(&dword_21C69B000, v32, OS_LOG_TYPE_INFO, "NWListener.init address=%s port=%d", buf, 0x12u);
      }
      snprintf((char *)buf, 0x10uLL, "%d", *(unsigned __int16 *)(a1 + 72));
      v41 = *(void **)(a1 + 128);
      v42 = nw_listener_create_with_port((const char *)buf, v27);
    }
    else
    {
      if (v33)
      {
        v37 = *(_QWORD *)(a1 + 48);
        v38 = v37 >> 1;
        if ((v37 & 1) == 0)
          v38 = v37 >> 1;
        if (v38)
        {
          if ((v37 & 1) != 0)
            v39 = *(const char **)(a1 + 56);
          else
            v39 = (const char *)(a1 + 49);
        }
        else
        {
          v39 = "any";
        }
        *(_DWORD *)buf = 136315138;
        v49 = v39;
        _os_log_impl(&dword_21C69B000, v32, OS_LOG_TYPE_INFO, "NWListener.init address=%s port=any", buf, 0xCu);
      }
      v41 = *(void **)(a1 + 128);
      v42 = nw_listener_create(v27);
    }
    v43 = v42;
    objc_msgSend(v41, "setListener:", v42);

    objc_msgSend(*(id *)(a1 + 128), "waitForReady");
    v44 = *(_DWORD *)(*(_QWORD *)(a1 + 128) + 40);

    if (v44 == 2)
    {
      return 1;
    }
    else
    {
      v46 = *re::networkLogObjects(v45);
      v15 = 0;
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_21C69B000, v46, OS_LOG_TYPE_DEFAULT, "Unable to initialize listener", buf, 2u);
        return 0;
      }
    }
  }
  return v15;
}

void re::NWProtocolLayer::deinit(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t os_unfair_lock_opaque;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;

  v2 = this + 54;
  os_unfair_lock_lock(this + 54);
  while (this[49]._os_unfair_lock_opaque)
  {
    os_unfair_lock_opaque = this[50]._os_unfair_lock_opaque;
    v4 = *(_QWORD *)&this[46]._os_unfair_lock_opaque;
    v5 = 0;
    if ((_DWORD)os_unfair_lock_opaque)
    {
      v6 = (int *)(v4 + 8);
      while (1)
      {
        v7 = *v6;
        v6 += 6;
        if (v7 < 0)
          break;
        if (os_unfair_lock_opaque == ++v5)
        {
          LODWORD(v5) = this[50];
          break;
        }
      }
    }
    re::NWProtocolLayer::removeConnection((uint64_t)this, *(_QWORD *)(v4 + 24 * v5 + 16), 1);
  }
  v8 = *(void **)&this[32]._os_unfair_lock_opaque;
  if (v8)
  {
    objc_msgSend(v8, "stopListening");
    v9 = *(_QWORD **)&this[32]._os_unfair_lock_opaque;
    v9[6] = 0;
    *(_QWORD *)&this[32]._os_unfair_lock_opaque = 0;

  }
  *(_QWORD *)(*(_QWORD *)&this[30]._os_unfair_lock_opaque + 8) = 0;
  v10 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (v10)
  {

    *(_QWORD *)&this[6]._os_unfair_lock_opaque = 0;
  }
  os_unfair_lock_unlock(v2);
}

void re::NWProtocolLayer::removeConnection(uint64_t a1, unint64_t a2, int a3)
{
  re *v6;
  NSObject *v7;
  id v8;
  NSObject *v9;
  re *v10;
  NSObject *v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  unint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  v7 = *re::networkLogObjects(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v32 = 134217984;
    v33 = a2;
    _os_log_debug_impl(&dword_21C69B000, v7, OS_LOG_TYPE_DEBUG, "NWProtocolLayer.removeConnection %p", (uint8_t *)&v32, 0xCu);
    if (!a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  if (a2)
LABEL_3:
    v8 = (id)(a2 + 8);
LABEL_4:
  v9 = *(NSObject **)(a2 + 1768);
  if (v9)
  {
    nw_connection_set_state_changed_handler(v9, 0);
    if (*(_DWORD *)(a2 + 1776) != 5)
    {
      v11 = *re::networkLogObjects(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v32 = 134217984;
        v33 = a2;
        _os_log_debug_impl(&dword_21C69B000, v11, OS_LOG_TYPE_DEBUG, "NWProtocolLayer.cancelling %p", (uint8_t *)&v32, 0xCu);
      }
      v12 = *(NSObject **)(a2 + 1768);
      if (a3)
        nw_connection_force_cancel(v12);
      else
        nw_connection_cancel(v12);
    }
  }
  v13 = *(unsigned int *)(a1 + 192);
  if (!(_DWORD)v13
    || (v14 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27)),
        v15 = (v14 ^ (v14 >> 31)) % v13,
        v16 = *(_QWORD *)(a1 + 176),
        v17 = *(unsigned int *)(v16 + 4 * v15),
        (_DWORD)v17 == 0x7FFFFFFF))
  {
    re::NWProtocolHandle::reset((re::NWProtocolHandle *)a2);
LABEL_24:

    return;
  }
  v18 = *(_QWORD *)(a1 + 184);
  if (*(_QWORD *)(v18 + 24 * v17 + 16) == a2)
  {
    *(_DWORD *)(v16 + 4 * v15) = *(_DWORD *)(v18 + 24 * v17 + 8) & 0x7FFFFFFF;
LABEL_19:
    v21 = *(_QWORD *)(a1 + 184);
    v22 = v21 + 24 * v17;
    v25 = *(_DWORD *)(v22 + 8);
    v23 = (int *)(v22 + 8);
    v24 = v25;
    if (v25 < 0)
    {
      *v23 = v24 & 0x7FFFFFFF;
      v26 = v21 + 24 * v17;
      v29 = *(_QWORD *)(v26 + 16);
      v28 = (_QWORD *)(v26 + 16);
      v27 = v29;
      if (v29)
      {

        *v28 = 0;
      }
    }
    v30 = *(_QWORD *)(a1 + 184) + 24 * v17;
    *(_DWORD *)(v30 + 8) = *(_DWORD *)(v30 + 8) & 0x80000000 | *(_DWORD *)(a1 + 204);
    --*(_DWORD *)(a1 + 196);
    v31 = *(_DWORD *)(a1 + 208) + 1;
    *(_DWORD *)(a1 + 204) = v17;
    *(_DWORD *)(a1 + 208) = v31;
  }
  else
  {
    while (1)
    {
      v19 = v17;
      v20 = *(_DWORD *)(v18 + 24 * v17 + 8);
      v17 = v20 & 0x7FFFFFFF;
      if ((v20 & 0x7FFFFFFF) == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v18 + 24 * v17 + 16) == a2)
      {
        *(_DWORD *)(v18 + 24 * v19 + 8) = *(_DWORD *)(v18 + 24 * v19 + 8) & 0x80000000 | *(_DWORD *)(v18 + 24 * v17 + 8) & 0x7FFFFFFF;
        goto LABEL_19;
      }
    }
  }
  re::NWProtocolHandle::reset((re::NWProtocolHandle *)a2);
  if (a2)
    goto LABEL_24;
}

void re::NWProtocolLayer::open(nw_parameters_t *this@<X0>, const re::Address *a2@<X1>, _QWORD *a3@<X8>)
{
  re *IPPortPair;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  NSObject *host_with_numeric_port;
  nw_connection_t v11;
  uint64_t v12;
  const char *v13;
  re *v15;
  int v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  NSObject *v21;
  void *v22;
  void *v23;
  id v24;
  char *v25;
  socklen_t v26;
  sockaddr buf;
  _BYTE v28[8];
  _QWORD v29[5];

  v29[4] = *MEMORY[0x24BDAC8D0];
  IPPortPair = (re *)re::Address::getIPPortPair(a2, (uint64_t)v28);
  if (!v28[0])
  {
    if ((*((_BYTE *)a2 + 8) & 1) != 0)
    {
      v13 = (const char *)*((_QWORD *)a2 + 2);
      if (strncmp(v13, "fd://", 5uLL))
      {
LABEL_18:
        v12 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      v13 = (char *)a2 + 9;
      if (*(_DWORD *)((char *)a2 + 9) != 792355942 || *((_BYTE *)a2 + 13) != 47)
        goto LABEL_18;
    }
    v25 = 0;
    v15 = (re *)strtol(v13 + 5, &v25, 10);
    v16 = (int)v15;
    if ((int)v15 < 1)
      goto LABEL_27;
    v17 = *((_QWORD *)a2 + 1);
    v18 = (char *)*((_QWORD *)a2 + 2);
    if ((v17 & 1) == 0)
      v18 = (char *)a2 + 9;
    v19 = v17 >> 1;
    v20 = v17 >> 1;
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v20 = v19;
    if (v25 != &v18[v20])
      goto LABEL_27;
    v21 = *re::networkLogObjects(v15);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)&buf.sa_len = 67109120;
      *(_DWORD *)&buf.sa_data[2] = v16;
      _os_log_impl(&dword_21C69B000, v21, OS_LOG_TYPE_INFO, "NWProtocolLayer.openConnection file-descriptor=%d", &buf.sa_len, 8u);
    }
    *(_QWORD *)&buf.sa_len = 0;
    *(_QWORD *)&buf.sa_data[6] = 0;
    v26 = 16;
    getsockname(v16, &buf, &v26);
    v22 = (void *)nw_connection_create_with_connected_socket_and_parameters();
    if (v22)
    {
      v23 = v22;
      re::NWProtocolLayer::addConnection((unint64_t *)&buf.sa_len, (uint64_t)this, v22);
      v12 = *(_QWORD *)&buf.sa_len;

      if (v12)
      {

        v24 = (id)(v12 + 8);
      }
    }
    else
    {
LABEL_27:
      v12 = 0;
    }
    goto LABEL_11;
  }
  v7 = *re::networkLogObjects(IPPortPair);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = v7;
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v9 = (char *)*((_QWORD *)a2 + 2);
    else
      v9 = (char *)a2 + 9;
    *(_DWORD *)&buf.sa_len = 136315138;
    *(_QWORD *)&buf.sa_data[2] = v9;
    _os_log_impl(&dword_21C69B000, v8, OS_LOG_TYPE_INFO, "NWProtocolLayer.open address=%s", &buf.sa_len, 0xCu);

  }
  re::IP::generateString((re::IP *)v29, (re::DynamicString *)&buf);
  host_with_numeric_port = nw_endpoint_create_host_with_numeric_port();
  if (*(_QWORD *)&buf.sa_len && (buf.sa_data[6] & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&buf.sa_len + 40))();
  v11 = nw_connection_create(host_with_numeric_port, this[19]);
  re::NWProtocolLayer::addConnection((unint64_t *)&buf.sa_len, (uint64_t)this, v11);
  v12 = *(_QWORD *)&buf.sa_len;

LABEL_11:
  if (v12)
    re::DynamicString::operator=((re::DynamicString *)(v12 + 1784), a2);
LABEL_19:
  *a3 = v12;
}

void re::NWProtocolLayer::addConnection(unint64_t *a1, uint64_t a2, void *a3)
{
  NSObject *v6;
  re *v7;
  uint64_t *v8;
  unint64_t v9;
  _anonymous_namespace_ *v10;
  re *v11;
  NSObject *v12;
  id v13;
  NSObject *v14;
  uint64_t v15;
  id v16;
  NSObject *v17;
  id v18;
  NSObject *v19;
  void *v20;
  void *v21;
  id v22;
  NSObject *v23;
  void *v24;
  void *v25;
  NSObject *v26;
  id v27;
  void *v28;
  void *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  id v40;
  _QWORD v41[4];
  id v42;
  NSObject *v43;
  _QWORD v44[4];
  id v45;
  NSObject *v46;
  _QWORD aBlock[4];
  id v48;
  NSObject *v49;
  _QWORD handler[4];
  id v51;
  NSObject *v52;
  uint8_t buf[4];
  unint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v6 = a3;
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a2 + 160));
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 216));
  v8 = re::globalAllocators(v7);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 1872, 8);
  bzero((void *)v9, 0x750uLL);
  v10 = re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v9);
  *(_QWORD *)v9 = &off_24E071998;
  *(_QWORD *)(v9 + 1768) = 0;
  *(_DWORD *)(v9 + 1776) = 0;
  *(_OWORD *)(v9 + 1784) = 0u;
  *(_OWORD *)(v9 + 1800) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(v9 + 1784), 0);
  *(_WORD *)(v9 + 1864) = 0;
  *(_OWORD *)(v9 + 1832) = 0u;
  *(_OWORD *)(v9 + 1848) = 0u;
  *(_OWORD *)(v9 + 1816) = 0u;
  *a1 = v9;
  objc_storeStrong((id *)(v9 + 1768), a3);
  v12 = *re::networkLogObjects(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    v54 = v9;
    _os_log_debug_impl(&dword_21C69B000, v12, OS_LOG_TYPE_DEBUG, "NWProtocolLayer.addConnection %p", buf, 0xCu);
  }
  v13 = *(id *)(a2 + 120);
  v14 = *(id *)(a2 + 160);
  nw_connection_set_queue(v6, v14);

  v15 = MEMORY[0x24BDAC760];
  handler[0] = MEMORY[0x24BDAC760];
  handler[1] = 3221225472;
  handler[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke;
  handler[3] = &unk_24E0718D8;
  v16 = v13;
  v51 = v16;
  v17 = v6;
  v52 = v17;
  nw_connection_set_state_changed_handler(v17, handler);
  aBlock[0] = v15;
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2;
  aBlock[3] = &unk_24E071900;
  v18 = v16;
  v48 = v18;
  v19 = v17;
  v49 = v19;
  v20 = _Block_copy(aBlock);
  v21 = *(void **)(v9 + 1816);
  *(_QWORD *)(v9 + 1816) = v20;

  v44[0] = v15;
  v44[1] = 3221225472;
  v44[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_3;
  v44[3] = &unk_24E071928;
  v22 = v18;
  v45 = v22;
  v23 = v19;
  v46 = v23;
  v24 = _Block_copy(v44);
  v25 = *(void **)(v9 + 1824);
  *(_QWORD *)(v9 + 1824) = v24;

  v41[0] = v15;
  v41[1] = 3221225472;
  v41[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_4;
  v41[3] = &unk_24E071950;
  v42 = v22;
  v43 = v23;
  v26 = v23;
  v27 = v22;
  v28 = _Block_copy(v41);
  v29 = *(void **)(v9 + 1832);
  *(_QWORD *)(v9 + 1832) = v28;

  nw_connection_start(v26);
  v30 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) >> 27));
  v31 = v30 ^ (v30 >> 31);
  v32 = *(unsigned int *)(a2 + 192);
  if ((_DWORD)v32)
  {
    v33 = v31 % v32;
    v34 = *(unsigned int *)(*(_QWORD *)(a2 + 176) + 4 * (v31 % v32));
    if ((_DWORD)v34 != 0x7FFFFFFF)
    {
      v35 = *(_QWORD *)(a2 + 184);
      if (*(_QWORD *)(v35 + 24 * v34 + 16) == v9)
        goto LABEL_16;
      while (1)
      {
        LODWORD(v34) = *(_DWORD *)(v35 + 24 * v34 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v34 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v35 + 24 * v34 + 16) == v9)
          goto LABEL_16;
      }
    }
  }
  else
  {
    LODWORD(v33) = 0;
  }
  v36 = *(unsigned int *)(a2 + 204);
  if ((_DWORD)v36 == 0x7FFFFFFF)
  {
    v36 = *(unsigned int *)(a2 + 200);
    v37 = v36;
    if ((_DWORD)v36 == (_DWORD)v32)
    {
      re::HashSetBase<re::SharedPtr<re::NWProtocolHandle>,re::SharedPtr<re::NWProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::NWProtocolHandle>>,re::Hash<re::SharedPtr<re::NWProtocolHandle>>,re::EqualTo<re::SharedPtr<re::NWProtocolHandle>>,true,false>::setCapacity(a2 + 168, 2 * *(_DWORD *)(a2 + 196));
      LODWORD(v33) = v31 % *(unsigned int *)(a2 + 192);
      v37 = *(_DWORD *)(a2 + 200);
    }
    *(_DWORD *)(a2 + 200) = v37 + 1;
    v38 = *(_QWORD *)(a2 + 184);
    v39 = *(_DWORD *)(v38 + 24 * v36 + 8);
  }
  else
  {
    v38 = *(_QWORD *)(a2 + 184);
    v39 = *(_DWORD *)(v38 + 24 * v36 + 8);
    *(_DWORD *)(a2 + 204) = v39 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v38 + 24 * v36 + 8) = v39 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a2 + 184) + 24 * v36 + 8) = *(_DWORD *)(*(_QWORD *)(a2 + 184) + 24 * v36 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a2 + 176) + 4 * v33);
  *(_QWORD *)(*(_QWORD *)(a2 + 184) + 24 * v36) = v31;
  *(_QWORD *)(*(_QWORD *)(a2 + 184) + 24 * v36 + 16) = v9;
  v40 = (id)(v9 + 8);
  *(_DWORD *)(*(_QWORD *)(a2 + 176) + 4 * v33) = v36;
  ++*(_DWORD *)(a2 + 196);
  ++*(_DWORD *)(a2 + 208);
LABEL_16:

  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 216));
}

void re::NWProtocolLayer::close(uint64_t a1, unint64_t a2, int a3)
{
  re *v6;
  NSObject *v7;
  int v8;
  unint64_t v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  v7 = *re::networkLogObjects(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = 134218240;
    v9 = a2;
    v10 = 1024;
    v11 = a3;
    _os_log_impl(&dword_21C69B000, v7, OS_LOG_TYPE_INFO, "NWProtocolLayer.close %p force=%d", (uint8_t *)&v8, 0x12u);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  re::NWProtocolLayer::removeConnection(a1, a2, 0);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
}

void re::NWProtocolLayer::disconnect(uint64_t a1, uint64_t a2, int a3)
{
  re *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  v7 = *re::networkLogObjects(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v9 = 134218240;
    v10 = a2;
    v11 = 1024;
    v12 = a3;
    _os_log_impl(&dword_21C69B000, v7, OS_LOG_TYPE_INFO, "NWProtocolLayer.disconnect %p force=%d", (uint8_t *)&v9, 0x12u);
  }
  if (a3)
  {
    nw_connection_force_cancel(*(nw_connection_t *)(a2 + 1768));
    *(_DWORD *)(a2 + 1776) = 5;
    *(_WORD *)(a2 + 1864) = 257;
    v8 = *(_QWORD *)(a1 + 112);
    if (v8)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 8))(v8, a1, a2, a2 + 1784);
  }
  else
  {
    *(_BYTE *)(a2 + 1865) = 1;
    nw_connection_send(*(nw_connection_t *)(a2 + 1768), 0, (nw_content_context_t)*MEMORY[0x24BDE0860], 1, (nw_connection_send_completion_t)*MEMORY[0x24BDE0840]);
  }
}

void re::NWProtocolLayer::update(re::NWProtocolLayer *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  NSObject *v13;
  int v14;
  int v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  void *v32;
  nw_data_transfer_report_t new_data_transfer_report;
  void *v34;
  unsigned int v35;
  unsigned int v36;
  _QWORD v37[6];
  _BYTE v38[16];

  re::NWProtocolLayer::assertNetworkQueue(*((re::NWProtocolLayer **)this + 20));
  os_unfair_lock_lock((os_unfair_lock_t)this + 54);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v38, 6022, (uint64_t)this);
  v2 = *((unsigned int *)this + 50);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)(*((_QWORD *)this + 23) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 6;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 50);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  v6 = *((_DWORD *)this + 50);
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v7 = v3;
    v8 = MEMORY[0x24BDAC760];
    do
    {
      v9 = *(_QWORD *)(*((_QWORD *)this + 23) + 24 * v7 + 16);
      if (*(_QWORD *)(v9 + 1768))
      {
        v10 = 936;
        do
        {
          v11 = atomic_load((unsigned int *)(v9 + v10));
          if (v11)
            break;
          v12 = v10 == 1296;
          v10 += 40;
        }
        while (!v12);
        if (v11)
        {
          v13 = *(NSObject **)(v9 + 1768);
          v37[0] = v8;
          v37[1] = 3221225472;
          v37[2] = ___ZN2re15NWProtocolLayer6updateEv_block_invoke;
          v37[3] = &__block_descriptor_48_e5_v8__0l;
          v37[4] = this;
          v37[5] = v9;
          nw_connection_batch(v13, v37);
        }
      }
      v6 = *((_DWORD *)this + 50);
      if (v6 <= (int)v3 + 1)
        v14 = v3 + 1;
      else
        v14 = *((_DWORD *)this + 50);
      while (1)
      {
        v7 = (v3 + 1);
        if (v14 - 1 == (_DWORD)v3)
          break;
        LODWORD(v3) = v3 + 1;
        v15 = v7;
        if ((*(_DWORD *)(*((_QWORD *)this + 23) + 24 * v7 + 8) & 0x80000000) != 0)
          goto LABEL_23;
      }
      v15 = v14;
LABEL_23:
      LODWORD(v3) = v15;
    }
    while ((_DWORD)v2 != v15);
  }
  v16 = 0;
  if (v6)
  {
    v17 = (int *)(*((_QWORD *)this + 23) + 8);
    while (1)
    {
      v18 = *v17;
      v17 += 6;
      if (v18 < 0)
        break;
      if (v6 == ++v16)
      {
        LODWORD(v16) = v6;
        break;
      }
    }
  }
  if (v6 != (_DWORD)v16)
  {
    v19 = v16;
    do
    {
      re::NWProtocolLayer::scheduleReceives((uint64_t)this, *(_QWORD *)(*((_QWORD *)this + 23) + 24 * v19 + 16));
      if (*((_DWORD *)this + 50) <= (v16 + 1))
        v20 = v16 + 1;
      else
        v20 = *((_DWORD *)this + 50);
      v21 = v16;
      while (1)
      {
        v19 = (v21 + 1);
        if (v20 - 1 == v21)
          break;
        ++v21;
        LODWORD(v16) = v19;
        if ((*(_DWORD *)(*((_QWORD *)this + 23) + 24 * v19 + 8) & 0x80000000) != 0)
          goto LABEL_39;
      }
      LODWORD(v16) = v20;
LABEL_39:
      ;
    }
    while (v6 != (_DWORD)v16);
  }
  if (CFAbsoluteTimeGetCurrent() - *((double *)this + 13) > 1.0)
  {
    *((CFAbsoluteTime *)this + 13) = CFAbsoluteTimeGetCurrent();
    v22 = *((unsigned int *)this + 50);
    if ((_DWORD)v22)
    {
      v23 = 0;
      v24 = (int *)(*((_QWORD *)this + 23) + 8);
      while (1)
      {
        v25 = *v24;
        v24 += 6;
        if (v25 < 0)
          break;
        if (v22 == ++v23)
        {
          LODWORD(v23) = *((_DWORD *)this + 50);
          break;
        }
      }
    }
    else
    {
      LODWORD(v23) = 0;
    }
    if ((_DWORD)v22 != (_DWORD)v23)
    {
      v26 = v23;
      v27 = *((_DWORD *)this + 50);
      do
      {
        v28 = *(_QWORD *)(*((_QWORD *)this + 23) + 24 * v26 + 16);
        v29 = *(NSObject **)(v28 + 1768);
        if (v29 && *(_DWORD *)(v28 + 1776) == 3)
        {
          v30 = *(NSObject **)(v28 + 1848);
          if (v30)
          {
            v31 = *((id *)this + 20);
            nw_data_transfer_report_collect(v30, v31, *(nw_data_transfer_report_collect_block_t *)(v28 + 1832));

            v32 = *(void **)(v28 + 1848);
            *(_QWORD *)(v28 + 1848) = 0;

            v29 = *(NSObject **)(v28 + 1768);
          }
          new_data_transfer_report = nw_connection_create_new_data_transfer_report(v29);
          v34 = *(void **)(v28 + 1848);
          *(_QWORD *)(v28 + 1848) = new_data_transfer_report;

          v27 = *((_DWORD *)this + 50);
        }
        if (v27 <= (int)v23 + 1)
          v35 = v23 + 1;
        else
          v35 = v27;
        while (1)
        {
          v26 = (v23 + 1);
          if (v35 - 1 == (_DWORD)v23)
            break;
          LODWORD(v23) = v23 + 1;
          v36 = v26;
          if ((*(_DWORD *)(*((_QWORD *)this + 23) + 24 * v26 + 8) & 0x80000000) != 0)
            goto LABEL_61;
        }
        v36 = v35;
LABEL_61:
        LODWORD(v23) = v36;
      }
      while ((_DWORD)v22 != v36);
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v38);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 54);
}

void re::NWProtocolLayer::scheduleReceives(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t i;
  unint64_t v8;
  unint64_t v9;
  NSObject *v10;
  _QWORD v11[6];

  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  if (*(_QWORD *)(a2 + 1768) && *(_DWORD *)(a2 + 1776) == 3 && !*(_BYTE *)(a2 + 1864))
  {
    v4 = atomic_load((unsigned int *)(a2 + 1860));
    v5 = *(_DWORD *)(a1 + 80);
    if (!v5)
      v5 = 10;
    if (v4 < v5)
    {
      v6 = 0;
      for (i = 1344; i != 1744; i += 40)
      {
        v8 = atomic_load((unint64_t *)(a2 + i));
        v6 += v8;
      }
      v9 = *(_QWORD *)(a1 + 88);
      if (!v9)
        v9 = 10485760;
      if (v6 < v9)
      {
        v10 = *(NSObject **)(a2 + 1768);
        v11[0] = MEMORY[0x24BDAC760];
        v11[1] = 3221225472;
        v11[2] = ___ZN2re15NWProtocolLayer16scheduleReceivesEPNS_16NWProtocolHandleE_block_invoke;
        v11[3] = &__block_descriptor_48_e5_v8__0l;
        v11[4] = a1;
        v11[5] = a2;
        nw_connection_batch(v10, v11);
      }
    }
  }
}

void ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  id v6;
  uint64_t v7;
  re *v8;
  NSObject *v9;
  NSObject *v10;
  void (***v11)(_QWORD, uint64_t, uint64_t, uint64_t);
  NSObject *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (v3)
  {
    v6 = *(id *)(a1 + 40);
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v3 + 160));
    v7 = re::NWProtocolLayer::handleFor(v3, v6);

    if (v7)
    {
      *(_DWORD *)(v7 + 1776) = a2;
      v9 = *re::networkLogObjects(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        v10 = v9;
        v14 = 134218498;
        v15 = v7;
        v16 = 2080;
        v17 = nw_connection_state_to_string();
        v18 = 2080;
        v19 = nw_connection_state_to_string();
        _os_log_impl(&dword_21C69B000, v10, OS_LOG_TYPE_INFO, "NWProtocolLayer.onConnectionStateChanged %p prevState=%s newState=%s", (uint8_t *)&v14, 0x20u);

      }
      switch(a2)
      {
        case 5:
          re::NWProtocolHandle::reset((re::NWProtocolHandle *)v7);
          break;
        case 4:
          v13 = *(_QWORD *)(v3 + 112);
          if (v13 && !*(_BYTE *)(v7 + 1864))
          {
            if (a3)
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13 + 16))(v13, v3, v7, 2);
            else
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13 + 8))(v13, v3, v7, v7 + 1784);
          }
          break;
        case 3:
          v11 = *(void (****)(_QWORD, uint64_t, uint64_t, uint64_t))(v3 + 112);
          if (v11)
            (**v11)(v11, v3, v7, v7 + 1784);
          re::NWProtocolLayer::scheduleReceives(v3, v7);
          break;
      }
    }
    else
    {
      v12 = *re::networkLogObjects(v8);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        LOWORD(v14) = 0;
        _os_log_impl(&dword_21C69B000, v12, OS_LOG_TYPE_INFO, "NWProtocolLayer.onConnectionStateChanged for unknown connection", (uint8_t *)&v14, 2u);
      }
    }
  }
}

uint64_t ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2(uint64_t result)
{
  uint64_t v1;
  id v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;

  v1 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  if (v1)
  {
    v2 = *(id *)(result + 40);
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v1 + 160));
    v3 = re::NWProtocolLayer::handleFor(v1, v2);

    if (v3)
    {
      v4 = (unsigned int *)(v3 + 1856);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      result = re::internal::enableSignposts(0, 0);
      if ((_DWORD)result)
      {
        result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
        if ((_DWORD)result)
          return kdebug_trace();
      }
    }
    else
    {
      result = re::internal::enableSignposts(0, 0);
      if ((_DWORD)result)
      {
        result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
        if ((_DWORD)result)
          return kdebug_trace();
      }
    }
  }
  return result;
}

void ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_3(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  uint64_t v5;
  void *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  id v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  re::PacketPool *v20;
  uint64_t v21;
  size_t size;
  NSObject *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t error_domain;
  NSObject *v28;
  _BOOL8 is_final;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  _QWORD access_value[5];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  char v37;
  __int128 applier;
  uint64_t (*v39)(uint64_t, int, uint64_t, void *, size_t);
  void *v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (v5)
  {
    v9 = *(void **)(a1 + 40);
    v10 = a2;
    v11 = a3;
    v12 = a5;
    v13 = v9;
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v5 + 160));
    v14 = re::NWProtocolLayer::handleFor(v5, v13);

    if (v14)
    {
      v15 = (unsigned int *)(v14 + 1860);
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (v10 && v11)
      {
        v32 = v12;
        v34 = 0;
        v35 = &v34;
        v36 = 0x2020000000;
        v37 = 0;
        v17 = nw_content_context_copy_protocol_metadata(v11, *(nw_protocol_definition_t *)(v5 + 136));
        v18 = v17;
        v19 = MEMORY[0x24BDAC760];
        if (v17 && nw_protocol_metadata_is_framer_message(v17))
        {
          access_value[0] = v19;
          access_value[1] = 3221225472;
          access_value[2] = ___ZN2re15NWProtocolLayer16onReceiveMessageEPU27objcproto16OS_nw_connection8NSObjectPU27objcproto16OS_dispatch_dataS1_PU32objcproto21OS_nw_content_contextS1_bPU22objcproto11OS_nw_errorS1__block_invoke;
          access_value[3] = &unk_24E070EF0;
          access_value[4] = &v34;
          nw_framer_message_access_value(v18, "channel", access_value);
        }

        v20 = *(re::PacketPool **)(v5 + 24);
        v21 = v19;
        size = dispatch_data_get_size(v10);
        v23 = v10;
        v24 = re::PacketPool::allocate(v20, size);
        *((_DWORD *)v24 + 6) = size;
        v25 = *((_QWORD *)v24 + 2);
        *(_QWORD *)&applier = v21;
        *((_QWORD *)&applier + 1) = 3221225472;
        v39 = ___ZN12_GLOBAL__N_119newPacketForContentEPN2re10PacketPoolEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
        v40 = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
        v41 = v25;
        dispatch_data_apply(v23, &applier);

        if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyNetworkTracing(0, 0))
          kdebug_trace();
        v26 = *(_QWORD *)(v5 + 112);
        v12 = v32;
        if (v26)
          (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v26 + 24))(v26, v5, v14, *((unsigned __int8 *)v35 + 24), *((_QWORD *)v24 + 2), *((unsigned int *)v24 + 6));
        re::PacketPool::free(*(re::PacketPool **)(v5 + 24), (re::Packet *)v24);
        _Block_object_dispose(&v34, 8);
      }
      else if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyNetworkTracing(0, 0))
      {
        kdebug_trace();
      }
      if (v11 && a4 && (is_final = nw_content_context_get_is_final(v11)))
      {
        if (!*(_BYTE *)(v14 + 1864) && *(_DWORD *)(v14 + 1776) == 3)
        {
          v30 = *re::networkLogObjects((re *)is_final);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
          {
            LODWORD(applier) = 134217984;
            *(_QWORD *)((char *)&applier + 4) = v14;
            _os_log_impl(&dword_21C69B000, v30, OS_LOG_TYPE_INFO, "NWProtocolLayer.onReceiveMessage %p readClosed", (uint8_t *)&applier, 0xCu);
          }
          *(_BYTE *)(v14 + 1864) = 1;
          v31 = *(_QWORD *)(v5 + 112);
          if (v31)
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v31 + 8))(v31, v5, v14, v14 + 1784);
        }
      }
      else
      {
        re::NWProtocolLayer::scheduleReceives(v5, v14);
      }
    }
    else
    {
      error_domain = re::internal::enableSignposts(0, 0);
      if ((_DWORD)error_domain)
      {
        error_domain = re::internal::enableHighFrequencyNetworkTracing(0, 0);
        if ((_DWORD)error_domain)
          error_domain = kdebug_trace();
      }
      if (!v12
        || (error_domain = nw_error_get_error_domain(v12), (_DWORD)error_domain != 1)
        || (error_domain = nw_error_get_error_code(v12), (_DWORD)error_domain != 89))
      {
        v28 = *re::networkLogObjects((re *)error_domain);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          LOWORD(applier) = 0;
          _os_log_impl(&dword_21C69B000, v28, OS_LOG_TYPE_INFO, "NWProtocolLayer.onReceiveMessage for unknown connection", (uint8_t *)&applier, 2u);
        }
      }
    }

  }
}

void ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_4(uint64_t a1, void *a2)
{
  uint64_t v2;
  void *v3;
  id v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint32_t v11;
  uint64_t sent_transport_byte_count;
  uint64_t sent_transport_retransmitted_byte_count;
  int v14;
  int v15;
  int v16;
  int v17;
  float v18;
  NSObject *report;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (v2)
  {
    v3 = *(void **)(a1 + 40);
    report = a2;
    v4 = v3;
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v2 + 160));
    v5 = re::NWProtocolLayer::handleFor(v2, v4);

    if (v5)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 1760));
      v6 = *(_DWORD *)(v5 + 1736);
      v7 = *(_DWORD *)(v5 + 1744);
      v8 = *(_DWORD *)(v5 + 1748);
      v9 = *(_DWORD *)(v5 + 1752);
      v10 = *(_DWORD *)(v5 + 1756);
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 1760));
      v11 = *MEMORY[0x24BDE0868];
      sent_transport_byte_count = nw_data_transfer_report_get_sent_transport_byte_count(report, *MEMORY[0x24BDE0868]);
      sent_transport_retransmitted_byte_count = nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(report, v11);
      v14 = v7 + nw_data_transfer_report_get_received_transport_byte_count(report, v11);
      v15 = v8 + sent_transport_byte_count;
      v16 = v9 + nw_data_transfer_report_get_received_ip_packet_count(report, v11);
      v17 = v10 + nw_data_transfer_report_get_sent_ip_packet_count(report, v11);
      if (sent_transport_byte_count)
        v18 = (double)sent_transport_retransmitted_byte_count / (double)sent_transport_byte_count;
      else
        v18 = 0.0;
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 1760));
      *(_DWORD *)(v5 + 1736) = v6;
      *(float *)(v5 + 1740) = v18;
      *(_DWORD *)(v5 + 1744) = v14;
      *(_DWORD *)(v5 + 1748) = v15;
      *(_DWORD *)(v5 + 1752) = v16;
      *(_DWORD *)(v5 + 1756) = v17;
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 1760));
    }

  }
}

void re::NWProtocolHandle::reset(re::NWProtocolHandle *this)
{
  void *v2;
  _anonymous_namespace_ *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = (void *)*((_QWORD *)this + 221);
  *((_QWORD *)this + 221) = 0;

  *((_DWORD *)this + 444) = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  re::DynamicString::setCapacity(&v9, 0);
  re::DynamicString::operator=((re::NWProtocolHandle *)((char *)this + 1784), (re::DynamicString *)&v9);
  if (v9 && (v10 & 1) != 0)
    (*(void (**)(void))(*v9 + 40))();
  v4 = (void *)*((_QWORD *)this + 227);
  *((_QWORD *)this + 227) = 0;

  v5 = (void *)*((_QWORD *)this + 228);
  *((_QWORD *)this + 228) = 0;

  v6 = (void *)*((_QWORD *)this + 229);
  *((_QWORD *)this + 229) = 0;

  *((_WORD *)this + 932) = 0;
  v7 = (void *)*((_QWORD *)this + 230);
  *((_QWORD *)this + 230) = 0;

  v8 = (void *)*((_QWORD *)this + 231);
  *((_QWORD *)this + 231) = 0;

}

uint64_t re::NWProtocolLayer::handleFor(uint64_t a1, void *a2)
{
  id v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;

  v3 = a2;
  v4 = (os_unfair_lock_s *)(a1 + 216);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  v5 = *(unsigned int *)(a1 + 200);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (int *)(*(_QWORD *)(a1 + 184) + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 6;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a1 + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 == (_DWORD)v6)
  {
LABEL_18:
    v11 = 0;
  }
  else
  {
    v9 = v6;
    v10 = *(_QWORD *)(a1 + 184);
    while (1)
    {
      v11 = *(_QWORD *)(v10 + 24 * v9 + 16);
      if (*(id *)(v11 + 1768) == v3)
        break;
      if (v5 <= (int)v6 + 1)
        v12 = v6 + 1;
      else
        v12 = v5;
      while (1)
      {
        v9 = (v6 + 1);
        if (v12 - 1 == (_DWORD)v6)
          break;
        LODWORD(v6) = v6 + 1;
        v13 = v9;
        if ((*(_DWORD *)(v10 + 24 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      v13 = v12;
LABEL_17:
      LODWORD(v6) = v13;
      if ((_DWORD)v5 == v13)
        goto LABEL_18;
    }
  }
  os_unfair_lock_unlock(v4);

  return v11;
}

uint64_t ___ZN2re15NWProtocolLayer16onReceiveMessageEPU27objcproto16OS_nw_connection8NSObjectPU27objcproto16OS_dispatch_dataS1_PU32objcproto21OS_nw_content_contextS1_bPU22objcproto11OS_nw_errorS1__block_invoke(uint64_t a1, char a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

uint64_t ___ZN2re15NWProtocolLayer16scheduleReceivesEPNS_16NWProtocolHandleE_block_invoke(uint64_t a1)
{
  int v2;
  signed int v3;
  unsigned int *v4;
  unsigned int v5;
  signed int v6;
  uint64_t result;

  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 80))
    v2 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 80);
  else
    v2 = 10;
  v3 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 40) + 1860));
  if (v3 < v2)
  {
    do
    {
      v4 = (unsigned int *)(*(_QWORD *)(a1 + 40) + 1860);
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 + 1, v4));
      nw_connection_receive_message(*(nw_connection_t *)(*(_QWORD *)(a1 + 40) + 1768), *(nw_connection_receive_completion_t *)(*(_QWORD *)(a1 + 40) + 1824));
      v6 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 40) + 1860));
    }
    while (v6 < v2);
  }
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
  {
    result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
    if ((_DWORD)result)
      return kdebug_trace();
  }
  return result;
}

void re::NWProtocolLayer::wait(re::NWProtocolLayer *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Implementation required to support update synchronization.", "!\"Unreachable code\"", "wait", 857);
  _os_crash();
  __break(1u);
}

void re::NWProtocolLayer::wakeup(re::NWProtocolLayer *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Implementation required to support update synchronization.", "!\"Unreachable code\"", "wakeup", 862);
  _os_crash();
  __break(1u);
}

uint64_t re::NWProtocolLayer::setListener(uint64_t this, ProtocolLayerListener *a2)
{
  *(_QWORD *)(this + 112) = a2;
  return this;
}

unint64_t re::NWProtocolLayer::localAddresses(re::NWProtocolLayer *this, re::Address *a2, unint64_t a3)
{
  uint64_t v3;
  const char *port;
  re::Address *v8;
  unint64_t v9;
  re *v10;
  sockaddr *ifa_addr;
  ifaddrs *v12;
  unsigned int ifa_flags;
  int v14;
  int v15;
  re::Address *v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  ifaddrs *v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  ifaddrs *v25;
  char v26[17];
  uint8_t buf[8];
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 16);
  if (!v3 || *(_DWORD *)(v3 + 40) != 2)
    return 0;
  port = (const char *)nw_listener_get_port(*(nw_listener_t *)(v3 + 32));
  if ((*((_BYTE *)this + 48) & 1) != 0)
    v8 = (re::Address *)*((_QWORD *)this + 7);
  else
    v8 = (re::NWProtocolLayer *)((char *)this + 49);
  if (*(_BYTE *)v8 && strcmp((const char *)v8, "0.0.0.0"))
  {
    if (a3)
    {
      re::Address::makeFromIPAndPort(v8, port, (re::DynamicString *)buf);
      re::DynamicString::operator=(a2, (re::DynamicString *)buf);
      if (*(_QWORD *)buf)
      {
        if ((v28 & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)buf + 40))();
      }
    }
    return 1;
  }
  v25 = 0;
  v10 = (re *)getifaddrs(&v25);
  if ((v10 & 0x80000000) != 0)
  {
    v21 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = v21;
      v23 = *__error();
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v23;
      _os_log_impl(&dword_21C69B000, v22, OS_LOG_TYPE_DEFAULT, "NWProtocolLayer: Unable to list network adapters(errno=%d).", buf, 8u);

    }
    return 0;
  }
  v12 = v25;
  if (v25)
  {
    v9 = 0;
    do
    {
      ifa_addr = v12->ifa_addr;
      if (ifa_addr)
      {
        ifa_flags = v12->ifa_flags;
        if ((ifa_flags & 1) != 0 && ifa_addr->sa_family == 2)
        {
          v15 = *(_DWORD *)&ifa_addr->sa_data[2];
          ifa_addr = (sockaddr *)((char *)ifa_addr + 4);
          v14 = v15;
          if ((unsigned __int16)v15 != 65193 && ((ifa_flags & 8) == 0 || v14 == 16777343))
          {
            v16 = (re::Address *)inet_ntop(2, ifa_addr, v26, 0x11u);
            if (v16)
            {
              if (v9 < a3)
              {
                re::Address::makeFromIPAndPort(v16, port, (re::DynamicString *)buf);
                re::DynamicString::operator=((re::Address *)((char *)a2 + 32 * v9), (re::DynamicString *)buf);
                if (*(_QWORD *)buf)
                {
                  if ((v28 & 1) != 0)
                    (*(void (**)(void))(**(_QWORD **)buf + 40))();
                }
              }
              ++v9;
            }
            else
            {
              v17 = *re::networkLogObjects(0);
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                v18 = v17;
                v19 = *__error();
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&buf[4] = v19;
                _os_log_impl(&dword_21C69B000, v18, OS_LOG_TYPE_DEFAULT, "NWProtocolLayer: Failed to get string representation of ip(errno=%d).", buf, 8u);

              }
            }
          }
        }
      }
      v12 = v12->ifa_next;
    }
    while (v12);
    v20 = v25;
  }
  else
  {
    v20 = 0;
    v9 = 0;
  }
  MEMORY[0x220780F1C](v20, ifa_addr);
  return v9;
}

uint64_t re::NWProtocolLayer::hostStats(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;
  int v12;
  int v13;
  unsigned int v14;
  int32x4_t v16;

  v4 = *(unsigned int *)(a1 + 200);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a1 + 184) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a1 + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    do
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 184) + 24 * v8 + 16);
      os_unfair_lock_lock((os_unfair_lock_t)(v9 + 1760));
      v10 = *(_DWORD *)(v9 + 1736);
      v11 = *(float *)(v9 + 1740);
      v16 = *(int32x4_t *)(v9 + 1744);
      os_unfair_lock_unlock((os_unfair_lock_t)(v9 + 1760));
      *(int32x4_t *)(a2 + 8) = vaddq_s32(*(int32x4_t *)(a2 + 8), v16);
      *(float *)(a2 + 4) = v11 + *(float *)(a2 + 4);
      *(_DWORD *)a2 += v10;
      if (*(_DWORD *)(a1 + 200) <= (v5 + 1))
        v12 = v5 + 1;
      else
        v12 = *(_DWORD *)(a1 + 200);
      v13 = v5;
      while (1)
      {
        v8 = (v13 + 1);
        if (v12 - 1 == v13)
          break;
        ++v13;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 184) + 24 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v5) = v12;
LABEL_17:
      ;
    }
    while ((_DWORD)v4 != (_DWORD)v5);
  }
  v14 = *(_DWORD *)(a1 + 196);
  if (v14)
  {
    *(float *)(a2 + 4) = *(float *)(a2 + 4) / (float)v14;
    *(_DWORD *)a2 /= v14;
  }
  return 1;
}

uint64_t re::NWProtocolLayer::setDisconnectTimeout(uint64_t this, unsigned int a2)
{
  unsigned int v2;

  if (a2 <= 0x3E8)
    v2 = 1000;
  else
    v2 = a2;
  *(_DWORD *)(this + 96) = v2 / 0x3E8;
  return this;
}

uint64_t re::NWProtocolLayer::preferredPacketSize(re::NWProtocolLayer *this)
{
  return 0x10000;
}

uint64_t re::NWProtocolLayer::preferredThreadMode(re::NWProtocolLayer *this)
{
  return 2;
}

uint64_t re::ProtocolLayer::drainsPacketSink(re::ProtocolLayer *this)
{
  return 0;
}

void re::NWProtocolHandle::~NWProtocolHandle(re::NWProtocolHandle *this)
{
  re::NWProtocolHandle::~NWProtocolHandle(this);
  JUMPOUT(0x220780CD0);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24E071998;
  re::NWProtocolHandle::reset(this);

  v2 = *((_QWORD *)this + 223);
  if (v2)
  {
    if ((*((_BYTE *)this + 1792) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 225));
    *(_OWORD *)((char *)this + 1784) = 0u;
    *(_OWORD *)((char *)this + 1800) = 0u;
  }

  re::ProtocolHandle::~ProtocolHandle(this);
}

uint64_t ___ZN12_GLOBAL__N_119newPacketForContentEPN2re10PacketPoolEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  memcpy((void *)(*(_QWORD *)(a1 + 32) + a3), __src, __n);
  return 1;
}

void re::HashSetBase<re::SharedPtr<re::NWProtocolHandle>,re::SharedPtr<re::NWProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::NWProtocolHandle>>,re::Hash<re::SharedPtr<re::NWProtocolHandle>>,re::EqualTo<re::SharedPtr<re::NWProtocolHandle>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            v14 = *(v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashSetBase<re::SharedPtr<re::NWProtocolHandle>,re::SharedPtr<re::NWProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::NWProtocolHandle>>,re::Hash<re::SharedPtr<re::NWProtocolHandle>>,re::EqualTo<re::SharedPtr<re::NWProtocolHandle>>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 16) = *v13;
            *v13 = 0;
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

uint64_t re::SyncOwnershipRequest::write(re::SyncOwnershipRequest *this, re::BitWriter *a2)
{
  unsigned int v4;
  unsigned int v5;

  v4 = *((_DWORD *)this + 1);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *(_DWORD *)this, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v4, 0x20u);
  v5 = *((_DWORD *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 2), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v5, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int8 *)this + 16), 1u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 18), 0x20u);
  return re::BitWriter::writeData(a2, *((const void **)this + 8), *((unsigned int *)this + 18));
}

uint64_t re::SyncOwnershipRequest::read(re::SyncOwnershipRequest *this, re::BitReader *a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  re::BitReader::readUInt64(a2, (unint64_t *)this);
  re::BitReader::readUInt64(a2, (unint64_t *)this + 1);
  v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 1u, &v9);
  *((_BYTE *)this + 16) = v9 != 0;
  v10 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 0x20u, &v10);
  result = 0;
  v5 = v10;
  v6 = *((_DWORD *)a2 + 2);
  v7 = *((unsigned int *)a2 + 4);
  if (v10 <= v6 - v7)
  {
    if (*((_BYTE *)a2 + 12))
    {
      result = 0;
      *((_QWORD *)this + 8) = 0;
      *((_QWORD *)this + 9) = v5;
    }
    else
    {
      *((_QWORD *)this + 8) = *(_QWORD *)a2 + v7;
      *((_QWORD *)this + 9) = v5;
      *((_QWORD *)a2 + 3) = 0;
      v8 = v7 + v5;
      *((_QWORD *)a2 + 2) = v8;
      result = 1;
      if (v8 > v6)
      {
        *((_BYTE *)a2 + 12) = 1;
        return 0;
      }
    }
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::DynamicArray(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    re::DynamicArray<unsigned char>::setCapacity((_QWORD *)a1, v3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<unsigned char>::copy((_QWORD *)a1, 0, *(char **)a2, *(_QWORD *)(a2 + 8));
  }
  return a1;
}

_QWORD *re::DynamicArray<unsigned char>::copy(_QWORD *this, unint64_t a2, char *__src, size_t __len)
{
  size_t v4;
  unint64_t v5;
  _QWORD *v6;
  size_t v7;
  size_t v8;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  __int128 v13;

  if (!__len)
    return this;
  v5 = a2;
  v6 = this;
  v7 = this[2];
  if (v7 + 1 <= a2)
  {
    v12 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v13) = 136315906;
    *(_QWORD *)((char *)&v13 + 4) = "copy";
    WORD6(v13) = 1024;
    HIWORD(v13) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, v5, v4, v12, v13);
    _os_crash();
    __break(1u);
  }
  v4 = __len;
  v8 = a2 + __len;
  if (__CFADD__(a2, __len))
    goto LABEL_12;
  if (v7 >= v8)
  {
    this = memmove((void *)(this[4] + a2), __src, __len);
  }
  else
  {
    re::DynamicArray<unsigned char>::growCapacity(this, a2 + __len);
    v10 = v6[2];
    v11 = &__src[v10 - v5];
    if (v10 != v5)
    {
      memmove((void *)(v6[4] + v5), __src, v10 - v5);
      v5 = v6[2];
    }
    this = memcpy((void *)(v6[4] + v5), v11, &__src[v4] - v11);
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

_QWORD *re::DynamicArray<unsigned char>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<unsigned char>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<unsigned char>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::entryIsAddable(re::SyncObject **a1, re::SyncObjectViewer *a2)
{
  re::SyncObject *v2;
  uint64_t result;
  re::SyncObject *v6;
  uint64_t v7;
  unint64_t LatestState;

  v2 = *a1;
  if (*a1)
  {
    while (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v2 + 11) + 16) + 74))
    {
      v2 = (re::SyncObject *)*((_QWORD *)v2 + 10);
      if (!v2)
        return 0;
    }
    if (*((_QWORD *)v2 + 12))
    {
      result = (*(uint64_t (**)(re::SyncObjectViewer *))(*(_QWORD *)a2 + 16))(a2);
      if (!(_DWORD)result)
        return result;
      v6 = *a1;
      v7 = *((_QWORD *)a2 + 7);
      LatestState = re::SyncObject::getLatestState(v6);
      if (!LatestState || *(_QWORD *)(LatestState + 88) != v7)
        return !re::SyncObjectViewer::isViewChangePending(a2, v2);
    }
  }
  return 0;
}

BOOL re::SyncCommitBuilder::shouldForward(_BYTE *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *a2;
  v3 = *(_QWORD *)(*a2 + 80);
  if (v3)
  {
    do
    {
      v4 = v2;
      v2 = v3;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 88) + 16) + 73))
        break;
      v3 = *(_QWORD *)(v3 + 80);
      v4 = v2;
    }
    while (v3);
  }
  else
  {
    v4 = *a2;
  }
  return *(_BYTE *)(v4 + 170) || *a1 || a1[1] != 0;
}

void re::SyncCommitBuilder::~SyncCommitBuilder(re::SyncCommitBuilder *this)
{
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 304);
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 232);
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168);
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104);
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40);
}

uint64_t re::SyncCommitBuilder::buildUpdate(uint64_t result, uint64_t a2)
{
  BOOL v2;
  uint64_t v4;
  re::SyncCommitChannel *v5;
  int v6;
  int v7;
  uint64_t v8;
  re::SyncObject **v9;
  re::SyncObject **v10;
  _QWORD *v11;
  re::SyncObject *v12;
  re::SyncObject *v13;
  re::SyncObject *v14;

  if (*(_BYTE *)(a2 + 28))
    v2 = *(_QWORD *)(a2 + 8) == *(_QWORD *)(*(_QWORD *)(result + 8) + 56);
  else
    v2 = 0;
  if (v2)
    return result;
  v4 = result;
  if (*(_BYTE *)(a2 + 28))
  {
    v6 = *(_DWORD *)(result + 144);
    v5 = (re::SyncCommitChannel *)(result + 144);
    if (v6)
    {
      result = *(_QWORD *)(v4 + 160);
      goto LABEL_11;
    }
  }
  else
  {
    v7 = *(_DWORD *)(result + 208);
    v5 = (re::SyncCommitChannel *)(result + 208);
    if (v7)
    {
      result = *(_QWORD *)(v4 + 224);
      goto LABEL_11;
    }
  }
  result = re::SyncCommitChannel::newCommit(v5);
LABEL_11:
  v8 = *(_QWORD *)(a2 + 48);
  if (v8)
  {
    v9 = *(re::SyncObject ***)(a2 + 64);
    v10 = &v9[3 * v8];
    v11 = (_QWORD *)(result + 32);
    do
    {
      v12 = *v9;
      v13 = (re::SyncObject *)*((_QWORD *)*v9 + 10);
      if (v13)
      {
        do
        {
          v14 = v12;
          v12 = v13;
          if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v14 + 11) + 16) + 73))
            break;
          v13 = (re::SyncObject *)*((_QWORD *)v13 + 10);
          v14 = v12;
        }
        while (v13);
      }
      else
      {
        v14 = *v9;
      }
      if (*((_BYTE *)v14 + 170) || *(_BYTE *)v4 || *(_BYTE *)(v4 + 1))
      {
        result = re::entryIsAddable(v9, *(re::SyncObjectViewer **)(v4 + 8));
        if ((_DWORD)result)
          result = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v11, (uint64_t *)v9);
      }
      v9 += 3;
    }
    while (v9 != v10);
  }
  return result;
}

void re::SyncCommitBuilder::buildOwnershipChanges(uint64_t a1, re::SyncObject **a2, uint64_t a3)
{
  re::SyncObject **v3;
  re::SyncObject **v5;
  _QWORD *v6;
  re::SyncObject *v7;
  re::SyncObject *v8;
  uint64_t v9;
  re *v10;
  NSObject *v11;
  uint64_t v12;
  _BOOL8 v13;
  re::SyncObject *v14;
  char *v15;
  re::SyncObject *v16;
  NSObject *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  _BYTE buf[22];
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v3 = a2;
    v5 = &a2[a3];
    v6 = (_QWORD *)(a1 + 304);
    do
    {
      v7 = *v3;
      if (*v3)
      {
        v8 = *v3;
        while (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v8 + 11) + 16) + 74))
        {
          v8 = (re::SyncObject *)*((_QWORD *)v8 + 10);
          if (!v8)
            goto LABEL_26;
        }
        if (*((_QWORD *)v8 + 12))
        {
          while (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v7 + 11) + 16) + 74))
          {
            v7 = (re::SyncObject *)*((_QWORD *)v7 + 10);
            if (!v7)
            {
              v9 = 0;
              goto LABEL_13;
            }
          }
          v9 = *((_QWORD *)v7 + 12);
LABEL_13:
          v10 = (re *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), v9);
          if ((_DWORD)v10)
          {
            v11 = *re::networkLogObjects(v10);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
            {
              v12 = *((_QWORD *)*v3 + 3);
              *(_DWORD *)buf = 134217984;
              *(_QWORD *)&buf[4] = v12;
              _os_log_impl(&dword_21C69B000, v11, OS_LOG_TYPE_INFO, "[Ownership] Adding ownership changes for: %llu", buf, 0xCu);
            }
            v13 = re::SyncObject::takeOverLatestState(*v3);
            if (v13)
            {
              v14 = *v3;
              *(_QWORD *)buf = v14;
              if (v14)
              {
                v15 = (char *)v14 + 8;
                v16 = *v3;
              }
              else
              {
                v16 = 0;
              }
              *(_QWORD *)&buf[8] = re::SyncObject::latestStateHandle(v16);
              buf[16] &= 0xF0u;
              re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v6, (uint64_t)buf);
              if (*(_QWORD *)buf)

            }
            else
            {
              v17 = *re::networkLogObjects((re *)v13);
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              {
                v18 = *((_QWORD *)*v3 + 3);
                v19 = *(_QWORD **)(*((_QWORD *)*v3 + 11) + 16);
                v20 = v19[4];
                v21 = v19[6];
                v22 = (char *)v19[7];
                v23 = (char *)v19 + 49;
                if ((v21 & 1) != 0)
                  v23 = v22;
                *(_DWORD *)buf = 134218498;
                *(_QWORD *)&buf[4] = v18;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v20;
                v25 = 2080;
                v26 = v23;
                _os_log_error_impl(&dword_21C69B000, v17, OS_LOG_TYPE_ERROR, "Encountered sync object without snapshot while packing ownership broadcasts! (id: %llu, type: %llu[%s])", buf, 0x20u);
              }
            }
          }
        }
      }
LABEL_26:
      ++v3;
    }
    while (v3 != v5);
  }
}

void re::SyncCommitBuilder::buildViewAdd(uint64_t a1, re::SyncObject **a2)
{
  re::SyncCommitChannel *v4;
  int v5;
  uint64_t v6;

  v5 = *(_DWORD *)(a1 + 16);
  v4 = (re::SyncCommitChannel *)(a1 + 16);
  if (v5)
    v6 = *(_QWORD *)(a1 + 32);
  else
    v6 = re::SyncCommitChannel::newCommit(v4);
  re::SyncCommitBuilder::addToViewRecursive(a1, a2, v6);
}

void re::SyncCommitBuilder::addToViewRecursive(uint64_t a1, re::SyncObject **a2, uint64_t a3)
{
  re *v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v14;
  unint64_t LatestState;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  _BYTE v21[12];
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v5 = *a2;
  if (*((_QWORD *)*a2 + 8) == *((_QWORD *)*a2 + 9))
  {
    v6 = *re::networkLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *((_QWORD *)*a2 + 3);
      v8 = *(_QWORD **)(*((_QWORD *)*a2 + 11) + 16);
      v9 = v8[4];
      v10 = v8[6];
      v11 = (char *)v8[7];
      v12 = (char *)v8 + 49;
      if ((v10 & 1) != 0)
        v12 = v11;
      *(_DWORD *)v21 = 134218498;
      *(_QWORD *)&v21[4] = v7;
      v22 = 2048;
      v23 = v9;
      v24 = 2080;
      v25 = v12;
      _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "Sync object without snapshot while adding view to commit (id: %llu, type: %llu[%s]).", v21, 0x20u);
    }
  }
  else
  {
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 56);
    LatestState = re::SyncObject::getLatestState(v5);
    if ((!LatestState || *(_QWORD *)(LatestState + 88) != v14) && (*((_BYTE *)*a2 + 128) & 4) == 0)
      re::SyncSnapshot::addToView((_QWORD *)(a3 + 32), a2);
    v16 = *((_QWORD *)*a2 + 25);
    if (v16)
    {
      v17 = (uint64_t *)*((_QWORD *)*a2 + 27);
      v18 = 8 * v16;
      do
      {
        v19 = *v17;
        *(_QWORD *)v21 = v19;
        if (v19)
          v20 = (id)(v19 + 8);
        re::SyncCommitBuilder::addToViewRecursive(a1, v21, a3);
        if (*(_QWORD *)v21)

        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
  }
}

void re::SyncCommitBuilder::buildViewRemoval(uint64_t a1, re::SyncObject **a2)
{
  re::SyncCommitChannel *v4;
  int v5;
  uint64_t v6;

  v5 = *(_DWORD *)(a1 + 80);
  v4 = (re::SyncCommitChannel *)(a1 + 80);
  if (v5)
    v6 = *(_QWORD *)(a1 + 96);
  else
    v6 = re::SyncCommitChannel::newCommit(v4);
  re::SyncCommitBuilder::removeFromViewRecursive(a1, a2, v6);
}

void re::SyncCommitBuilder::removeFromViewRecursive(uint64_t a1, re::SyncObject **a2, uint64_t a3)
{
  re *v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v14;
  unint64_t LatestState;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  _BYTE v21[12];
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v5 = *a2;
  if (*((_QWORD *)*a2 + 8) == *((_QWORD *)*a2 + 9))
  {
    v6 = *re::networkLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *((_QWORD *)*a2 + 3);
      v8 = *(_QWORD **)(*((_QWORD *)*a2 + 11) + 16);
      v9 = v8[4];
      v10 = v8[6];
      v11 = (char *)v8[7];
      v12 = (char *)v8 + 49;
      if ((v10 & 1) != 0)
        v12 = v11;
      *(_DWORD *)v21 = 134218498;
      *(_QWORD *)&v21[4] = v7;
      v22 = 2048;
      v23 = v9;
      v24 = 2080;
      v25 = v12;
      _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "Sync object without snapshot while removing view from commit (id: %llu, type: %llu[%s]).", v21, 0x20u);
    }
  }
  else
  {
    if ((*((_BYTE *)v5 + 128) & 4) == 0
      || (v14 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 56), (LatestState = re::SyncObject::getLatestState(v5)) == 0)
      || *(_QWORD *)(LatestState + 88) != v14)
    {
      re::SyncSnapshot::removeFromView((_QWORD *)(a3 + 32), a2);
    }
    v16 = *((_QWORD *)*a2 + 25);
    if (v16)
    {
      v17 = (uint64_t *)*((_QWORD *)*a2 + 27);
      v18 = 8 * v16;
      do
      {
        v19 = *v17;
        *(_QWORD *)v21 = v19;
        if (v19)
          v20 = (id)(v19 + 8);
        re::SyncCommitBuilder::removeFromViewRecursive(a1, v21, a3);
        if (*(_QWORD *)v21)

        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
  }
}

re::SyncCommitChannel *re::SyncCommitBuilder::begin(re::SyncCommitBuilder *this)
{
  re::SyncCommitChannel *v2;
  int v3;
  re::SyncCommitChannel *result;
  re::SyncCommitChannel *v5;
  int v6;

  v3 = *((_DWORD *)this + 4);
  v2 = (re::SyncCommitBuilder *)((char *)this + 16);
  if ((v3 - 1) <= 1)
    re::SyncCommitChannel::newCommit(v2);
  if ((*((_DWORD *)this + 20) - 1) <= 1)
    re::SyncCommitChannel::newCommit((re::SyncCommitBuilder *)((char *)this + 80));
  result = (re::SyncCommitBuilder *)((char *)this + 144);
  if ((*((_DWORD *)this + 36) - 1) <= 1)
    result = (re::SyncCommitChannel *)re::SyncCommitChannel::newCommit(result);
  v6 = *((_DWORD *)this + 52);
  v5 = (re::SyncCommitBuilder *)((char *)this + 208);
  if ((v6 - 1) <= 1)
    return (re::SyncCommitChannel *)re::SyncCommitChannel::newCommit(v5);
  return result;
}

uint64_t re::SyncCommitBuilder::end(_QWORD *a1, _anonymous_namespace_ *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t v13;
  int v14;
  __int128 v15;
  __int128 v16;
  int v17;
  uint64_t v18;

  v11 = *(_QWORD *)(a1[1] + 56);
  v12[0] = 0;
  v12[1] = 0;
  v13 = 0;
  v14 = 0;
  v18 = 0;
  v15 = 0u;
  v16 = 0u;
  v17 = 0;
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 2), (re::SyncCommitResult *)&v11);
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 10), (re::SyncCommitResult *)&v11);
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 18), (re::SyncCommitResult *)&v11);
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 26), (re::SyncCommitResult *)&v11);
  if (a1[40])
    re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)((char *)&v15 + 8), (uint64_t)(a1 + 34));
  v4 = *((_QWORD *)&v16 + 1);
  v5 = v13 + *((_QWORD *)a2 + 2) + *((_QWORD *)&v16 + 1);
  if (*((_QWORD *)a2 + 1) < v5)
  {
    re::DynamicArray<re::SyncCommit>::setCapacity(a2, v5);
    v4 = *((_QWORD *)&v16 + 1);
  }
  if (v4)
  {
    v6 = v18;
    v7 = 72 * v4;
    do
    {
      re::DynamicArray<re::SyncCommit>::add(a2, v6);
      v6 += 72;
      v7 -= 72;
    }
    while (v7);
  }
  if (v13)
  {
    v8 = v15;
    v9 = 72 * v13;
    do
    {
      re::DynamicArray<re::SyncCommit>::add(a2, v8);
      v8 += 72;
      v9 -= 72;
    }
    while (v9);
  }
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)&v15 + 8);
  return re::DynamicArray<re::SyncCommit>::deinit((uint64_t)v12);
}

uint64_t re::SyncCommitChannel::endFrame(re::SyncCommitChannel *this, re::SyncCommitResult *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _anonymous_namespace_ *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;

  *((_QWORD *)this + 2) = 0;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v5 = *((_QWORD *)this + 7);
    v6 = v5 + 72 * v3;
    v7 = (re::SyncCommitResult *)((char *)a2 + 48);
    do
    {
      if (*(_QWORD *)(v5 + 48))
      {
        if (*(_DWORD *)this == 2)
        {
          v8 = re::SyncCommitResult::sharedCommit(a2, *((unsigned __int8 *)this + 4));
          if (*(_QWORD *)(v5 + 48))
          {
            v9 = 0;
            v10 = 0;
            v11 = v8 + 32;
            do
            {
              re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v11, (uint64_t *)(*(_QWORD *)(v5 + 64) + v9));
              ++v10;
              v9 += 24;
            }
            while (v10 < *(_QWORD *)(v5 + 48));
          }
        }
        else
        {
          re::DynamicArray<re::SyncCommit>::add(v7, v5);
        }
      }
      v5 += 72;
    }
    while (v5 != v6);
  }
  return re::DynamicArray<re::SyncCommit>::clear((uint64_t)this + 24);
}

uint64_t re::SyncCommitChannel::newCommit(re::SyncCommitChannel *this)
{
  uint64_t v2;
  __int128 v4;
  uint64_t v5;
  int v6;
  char v7;
  _QWORD v8[3];
  int v9;
  uint64_t v10;

  *((_QWORD *)&v4 + 1) = *((_QWORD *)this + 1);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v10 = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  LOBYTE(v4) = *((_BYTE *)this + 4);
  re::DynamicArray<re::SyncCommit>::add((re::SyncCommitChannel *)((char *)this + 24), &v4);
  v2 = *((_QWORD *)this + 7) + 72 * *((_QWORD *)this + 5) - 72;
  *((_QWORD *)this + 2) = v2;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v8);
  return v2;
}

unsigned __int8 *re::SyncCommitResult::sharedCommit(re::SyncCommitResult *this, int a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  __int128 v7;
  uint64_t v8;
  int v9;
  char v10;
  _QWORD v11[3];
  int v12;
  uint64_t v13;

  v3 = *((_QWORD *)this + 3);
  if (v3)
  {
    v4 = (unsigned __int8 *)*((_QWORD *)this + 5);
    v5 = 72 * v3;
    while (*v4 != a2)
    {
      v4 += 72;
      v5 -= 72;
      if (!v5)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    *((_QWORD *)&v7 + 1) = *(_QWORD *)this;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v13 = 0;
    memset(v11, 0, sizeof(v11));
    v12 = 0;
    LOBYTE(v7) = a2;
    re::DynamicArray<re::SyncCommit>::add((re::SyncCommitResult *)((char *)this + 8), &v7);
    v4 = (unsigned __int8 *)(*((_QWORD *)this + 5) + 72 * *((_QWORD *)this + 3) - 72);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v11);
  }
  return v4;
}

_anonymous_namespace_ *re::TransportStream::TransportStream(_anonymous_namespace_ *a1, id *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = off_24E071A28;
  *((_QWORD *)a1 + 3) = &unk_24E071A80;
  *(_QWORD *)(v8 + 32) = 0;
  objc_copyWeak((id *)(v8 + 32), a2);
  *((_QWORD *)a1 + 5) = a3;
  *((_QWORD *)a1 + 6) = a4;
  return a1;
}

void re::TransportStream::~TransportStream(re::TransportStream *this)
{
  uint64_t v2;
  id *v3;
  re::Transport *v4;

  *(_QWORD *)this = off_24E071A28;
  v3 = (id *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 3) = &unk_24E071A80;
  if (v2)
    v4 = (re::Transport *)(v2 - 8);
  else
    v4 = 0;
  re::Transport::removeStream(v4, *((_QWORD *)this + 5), *((_QWORD *)this + 6));
  objc_destroyWeak(v3);
  *v3 = 0;
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

uint64_t ___Z20nw_framer_skip_bytesPU23objcproto12OS_nw_framer8NSObjectm_block_invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t re::SharedAppSyncPacker::packCommit(unsigned __int8 *a1, uint64_t a2, re::BitWriter *this, uint64_t a4, unint64_t a5)
{
  uint64_t v10;
  _anonymous_namespace_ *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  int v16;
  int v17;
  re::BitWriter **v18;
  uint64_t (*v19)(uint64_t, uint64_t, uint64_t);
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  re::BitWriter *v26;
  int v27;
  uint64_t *v28;

  re::BitWriter::alignToByte(this);
  v11 = (_anonymous_namespace_ *)re::BitWriter::bytesLeft(this, v10);
  LODWORD(v12) = *((_DWORD *)this + 6);
  if (*((_DWORD *)this + 7))
    v12 = (v12 + 1);
  else
    v12 = v12;
  v26 = this;
  v27 = v12;
  v28 = 0;
  v15 = *((_QWORD *)this + 1) + v12;
  v16 = 0;
  v17 = (int)v11;
  v18 = &v26;
  v19 = re::SharedAppSyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  re::DynamicString::setCapacity(&v20, 0);
  v24 = 6;
  v25 = 0;
  v28 = &v15;
  v13 = re::SharedAppSyncPacker::writeCommit(a1, a2, (re::snapshot::EncoderOPACK *)&v15, a4, a5);
  re::BitWriter::rollbackTo((uint64_t)this, (v16 + v27));
  if (v20 && (v21 & 1) != 0)
    (*(void (**)(void))(*v20 + 40))();
  return v13;
}

uint64_t re::SharedAppSyncPacker::writeCommit(unsigned __int8 *a1, uint64_t a2, re::snapshot::EncoderOPACK *this, uint64_t a4, unint64_t a5)
{
  re::snapshot::EncoderOPACK *v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  void *v22;
  id v23;
  uint64_t v24;
  void *v25;
  id v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t LatestState;
  unint64_t v34;
  unsigned int v35;
  unint64_t v36;
  unsigned int v37;
  size_t v38;
  NSObject *v39;
  unsigned int *v40;
  unint64_t v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  int v52;
  NSObject *v53;
  char *v54;
  uint64_t result;
  char *v56;
  uint64_t v57;
  unsigned int v58;
  int v59;
  unsigned __int8 v60;
  _BYTE buf[12];
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  char *v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a2 + 48) >= 0xFFFFFFFFuLL)
  {
    re::internal::assertLog((re::internal *)4, a2, this, "assertion failure: '%s' (%s:line %i) ", "commit.snapshot.size() < ~uint32_t()", "writeCommit", 72);
    _os_crash();
    __break(1u);
    goto LABEL_75;
  }
  v6 = a5;
  v7 = a4;
  v5 = this;
  v10 = a2;
  v9 = a1;
  v8 = *((_DWORD *)this + 2);
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>(v5, (unsigned __int8 *)v10);
  if ((*(_BYTE *)v10 & 2) != 0)
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned long long>(v5, (uint64_t *)(v10 + 16));
  re::snapshot::EncoderOPACK::endObject((unsigned int *)v5);
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)v5);
  v11 = *((unsigned int *)v5 + 2);
  if (v11 >= *((_DWORD *)v5 + 3))
  {
LABEL_75:
    if ((re::snapshot::Encoder::grow(v5, v11 + 1) & 1) == 0)
    {
      result = 0;
      *((_DWORD *)v5 + 2) = v8;
      return result;
    }
  }
  if (*(_QWORD *)(v10 + 48) <= v6)
  {
    v12 = 0;
    v58 = 0;
    goto LABEL_69;
  }
  v58 = 0;
  v12 = 0;
  v57 = v10;
  while (1)
  {
    v13 = *(_QWORD *)(v10 + 64);
    v14 = (uint64_t *)(v13 + 24 * v6);
    v15 = *v14;
    v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*v14 + 88) + 16) + 128);
    if (v16)
    {
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(v16 + 16))(v16, v7))
      {
        ++v58;
        goto LABEL_52;
      }
      v15 = *v14;
    }
    v59 = *((_DWORD *)v5 + 2);
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, *(_QWORD *)(v15 + 24));
    if ((*(_BYTE *)(v13 + 24 * v6 + 16) & 2) != 0)
      v17 = 5;
    else
      v17 = 1;
    v60 = v17;
    v18 = *(_QWORD **)(v15 + 80);
    v19 = (_QWORD *)v15;
    if (v18)
    {
      v20 = (_QWORD *)v15;
      do
      {
        v19 = v20;
        v20 = v18;
        if (*(_BYTE *)(*(_QWORD *)(v19[11] + 16) + 73))
          break;
        v18 = (_QWORD *)v18[10];
        v19 = v20;
      }
      while (v18);
    }
    if (!v19[20] && v19[17])
      v60 = v17 | 0x10;
    re::snapshot::EncoderOPACK::beginObject((unsigned int *)v5);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>(v5, &v60);
    *(_WORD *)buf = *(_WORD *)(v15 + 176);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>(v5, (unsigned __int16 *)buf);
    v21 = *(_QWORD *)(v15 + 80);
    if (v21)
    {
      v22 = (void *)(v21 + 8);
      v23 = (id)(v21 + 8);

    }
    else
    {
      re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,re::SyncOwnershipInfo>(v5, v15 + 136);
    }
    *(_QWORD *)buf = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v15 + 88) + 16) + 32);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<6,unsigned long long>(v5, (uint64_t *)buf);
    if ((v60 & 1) != 0)
    {
      v24 = *(_QWORD *)(v15 + 80);
      if (v24)
      {
        v25 = (void *)(v24 + 8);
        v26 = (id)(v24 + 8);

        v27 = *(_QWORD *)(v15 + 80);
        if (v27)
          v28 = (id)(v27 + 8);
        *(_QWORD *)buf = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v27 + 88) + 16) + 32);
        re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<8,unsigned long long>(v5, (uint64_t *)buf);

        v29 = *(_QWORD *)(v15 + 80);
        if (v29)
          v30 = (id)(v29 + 8);
        *(_QWORD *)buf = *(_QWORD *)(v29 + 24);
        re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<9,unsigned long long>(v5, (uint64_t *)buf);

      }
    }
    v31 = *((unsigned int *)v5 + 2);
    if (v31 >= *((_DWORD *)v5 + 3))
    {
      re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, 11);
    }
    else
    {
      v32 = *(_QWORD *)v5;
      *((_DWORD *)v5 + 2) = v31 + 1;
      *(_BYTE *)(v32 + v31) = 19;
    }
    LatestState = re::SyncObject::getLatestState((re::SyncObject *)v15);
    if (LatestState)
    {
      v34 = LatestState;
      v35 = *(_DWORD *)(LatestState + 24);
      v36 = *(_DWORD *)(LatestState + 28) ? v35 + 1 : v35;
      re::snapshot::EncoderOPACK::beginData((unsigned int *)v5, v36, v36);
      v37 = *(_DWORD *)(v34 + 24);
      v38 = *(_DWORD *)(v34 + 28) ? v37 + 1 : v37;
      re::snapshot::Encoder::writeRaw<true>((unsigned int *)v5, *(void **)(v34 + 8), v38);
    }
    else
    {
      v39 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        v46 = *(_QWORD *)(v15 + 24);
        v47 = *(_QWORD **)(*(_QWORD *)(v15 + 88) + 16);
        v48 = v47[4];
        v49 = v47[6];
        v50 = (char *)v47[7];
        v51 = (char *)v47 + 49;
        if ((v49 & 1) != 0)
          v51 = v50;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v46;
        v62 = 2048;
        v63 = v48;
        v64 = 2080;
        v65 = v51;
        _os_log_error_impl(&dword_21C69B000, v39, OS_LOG_TYPE_ERROR, "Could not find latest state for object (id: %llu, type: %llu[%s]).", buf, 0x20u);
      }
    }
    v40 = re::snapshot::EncoderOPACK::endObject((unsigned int *)v5);
    v41 = *((_QWORD *)v5 + 5);
    if ((v41 & 1) != 0 ? v41 >> 1 : v41 >> 1)
      break;
    v43 = *((unsigned int *)v5 + 2);
    if (v43 >= *((_DWORD *)v5 + 3) && !re::snapshot::Encoder::grow(v5, v43 + 1))
      goto LABEL_68;
    ++v12;
    v44 = *(_QWORD *)v7;
    if (*(_QWORD *)v7)
    {
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(v7 + 8) + 32))(buf);
      if (*(_QWORD *)buf)

      v45 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v44 + 80))(v44);
      re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(v45, v44);
      v10 = v57;
    }
    else
    {
      v10 = v57;
    }
LABEL_52:
    if (++v6 >= *(_QWORD *)(v10 + 48))
      goto LABEL_69;
  }
  v52 = *v9;
  v53 = *re::networkLogObjects((re *)v40);
  if (v52)
  {
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
    {
      if ((*((_QWORD *)v5 + 5) & 1) != 0)
        v54 = (char *)*((_QWORD *)v5 + 6);
      else
        v54 = (char *)v5 + 41;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v54;
      _os_log_debug_impl(&dword_21C69B000, v53, OS_LOG_TYPE_DEBUG, "Error writing OPACK object data: %s", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
  {
    if ((*((_QWORD *)v5 + 5) & 1) != 0)
      v56 = (char *)*((_QWORD *)v5 + 6);
    else
      v56 = (char *)v5 + 41;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v56;
    _os_log_error_impl(&dword_21C69B000, v53, OS_LOG_TYPE_ERROR, "Error writing OPACK object data: %s", buf, 0xCu);
  }
LABEL_68:
  *((_DWORD *)v5 + 2) = v59;
LABEL_69:
  re::snapshot::EncoderOPACK::endObject((unsigned int *)v5);
  return v12 + v58;
}

unsigned int *re::snapshot::EncoderOPACK::beginObject(unsigned int *this)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = this;
  v2 = this[2];
  if (v2 < this[3])
    goto LABEL_2;
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v2 + 1);
  if ((_DWORD)this)
  {
    LODWORD(v2) = v1[2];
LABEL_2:
    v3 = *(_QWORD *)v1;
    v1[2] = v2 + 1;
    *(_BYTE *)(v3 + v2) = -17;
  }
  return this;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>(re::snapshot::EncoderOPACK *this, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 9;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 2);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 10;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::EncoderOPACK::endObject(unsigned int *this)
{
  unsigned int *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = this;
  v2 = this[2];
  if (v2 < this[3])
    goto LABEL_2;
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v2 + 1);
  if ((_DWORD)this)
  {
    LODWORD(v2) = v1[2];
LABEL_2:
    v3 = *(_QWORD *)v1;
    v1[2] = v2 + 1;
    *(_BYTE *)(v3 + v2) = 3;
  }
  return this;
}

void re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;

  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
    re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions((_anonymous_namespace_ *)a1);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>(re::snapshot::EncoderOPACK *this, unsigned __int16 *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 2);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 10;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,re::SyncOwnershipInfo>(re::snapshot::EncoderOPACK *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 3);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 11;
  }
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
  re::snapshotMapFields(this, a2);
  return re::snapshot::EncoderOPACK::endObject((unsigned int *)this);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<6,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 6);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 14;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<8,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 8);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 16;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<9,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 9);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 17;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Encoder::writeRaw<true>(unsigned int *this, void *__src, size_t __len)
{
  unsigned int *v5;
  uint64_t v6;

  v5 = this;
  v6 = this[2];
  if (v6 + __len <= this[3])
  {
    if (!__len)
    {
LABEL_4:
      v5[2] = v6 + __len;
      return this;
    }
LABEL_3:
    this = (unsigned int *)memmove((void *)(*(_QWORD *)v5 + v6), __src, __len);
    LODWORD(v6) = v5[2];
    goto LABEL_4;
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v6 + __len);
  if ((_DWORD)this)
  {
    LODWORD(v6) = v5[2];
    if (!__len)
      goto LABEL_4;
    goto LABEL_3;
  }
  return this;
}

uint64_t re::SharedAppSyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::BitWriter *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(re::BitWriter **)a1;
  v5 = *(unsigned int *)(a1 + 8);
  re::BitWriter::rollbackTo(*(_QWORD *)a1, (*(_DWORD *)(*(_QWORD *)(a1 + 16) + 8) + v5));
  (*(void (**)(re::BitWriter *, uint64_t))(*(_QWORD *)v4 + 16))(v4, a3);
  re::BitWriter::bytesLeft(v4, v6);
  return *((_QWORD *)v4 + 1) + v5;
}

uint64_t re::snapshot::Encoder::grow(re::snapshot::Encoder *this, unint64_t a2)
{
  const void *v4;
  unsigned int v5;
  BOOL v6;
  uint64_t v7;

  v4 = (const void *)(*((uint64_t (**)(_QWORD, _QWORD, unint64_t))this + 3))(*((_QWORD *)this + 2), *(_QWORD *)this, a2);
  *(_QWORD *)this = v4;
  *((_DWORD *)this + 3) = v5;
  if (v4)
    v6 = a2 > v5;
  else
    v6 = 1;
  v7 = !v6;
  if (v6)
    re::snapshot::Encoder::error(this, "couldn't grow buffer to %zu bytes (buffer = %p, capacity = %d)", a2, v4, v5);
  return v7;
}

void re::SyncView::~SyncView(re::SyncView *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24E071B18;
  while (*((_QWORD *)this + 13))
    re::SyncView::removeFromViewersAtWithoutNotifying((uint64_t)this, 0);
  v2 = *((_QWORD *)this + 11);
  if (v2)
  {
    if (*((_QWORD *)this + 15))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 15) = 0;
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 11) = 0;
    ++*((_DWORD *)this + 28);
  }
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 5);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::SyncView::~SyncView(this);
  JUMPOUT(0x220780CD0);
}

uint64_t re::SyncView::removeFromViewersAtWithoutNotifying(uint64_t this, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;

  v2 = *(_QWORD *)(this + 104);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_16;
  }
  v3 = *(_QWORD *)(*(_QWORD *)(this + 120) + 8 * a2);
  v4 = *(_QWORD **)(v3 + 40);
  v5 = *(_QWORD *)(v3 + 24);
  v6 = v4;
  if (v5)
  {
    v7 = 8 * v5;
    v6 = *(_QWORD **)(v3 + 40);
    while (*v6 != this)
    {
      ++v6;
      v7 -= 8;
      if (!v7)
      {
        v6 = &v4[v5];
        break;
      }
    }
  }
  v8 = v6 - v4;
  if (v8 != v5)
  {
    if (v5 > v8)
    {
      if (v5 - 1 > v8)
        v4[v8] = v4[v5 - 1];
      *(_QWORD *)(v3 + 24) = v5 - 1;
      ++*(_DWORD *)(v3 + 32);
      goto LABEL_12;
    }
LABEL_16:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_12:
  if (v2 - 1 > a2)
    *(_QWORD *)(*(_QWORD *)(this + 120) + 8 * a2) = *(_QWORD *)(*(_QWORD *)(this + 120) + 8 * v2 - 8);
  *(_QWORD *)(this + 104) = v2 - 1;
  ++*(_DWORD *)(this + 112);
  return this;
}

void re::SyncView::addViewer(re::SyncViewer ***this, re::SyncViewer *a2)
{
  re::SyncView *v3;
  re::SyncViewer **v4;
  re::SyncViewer **v5;
  uint64_t v6;
  re::SyncViewer **v7;
  NSObject *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  __int16 v29[8];

  v3 = (re::SyncView *)this;
  v4 = this[15];
  v5 = this[13];
  if (v5)
  {
    v6 = 8 * (_QWORD)v5;
    v7 = this[15];
    while (*v7 != a2)
    {
      ++v7;
      v6 -= 8;
      if (!v6)
      {
        v7 = &v4[(_QWORD)v5];
        break;
      }
    }
  }
  else
  {
    v7 = this[15];
  }
  if (v5 != (re::SyncViewer **)(v7 - v4))
  {
    v8 = *re::networkLogObjects((re *)this);
    this = (re::SyncViewer ***)os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)this)
    {
      v29[0] = 0;
      _os_log_impl(&dword_21C69B000, v8, OS_LOG_TYPE_DEFAULT, "SyncViewer already viewing this View", (uint8_t *)v29, 2u);
    }
  }
  v9 = *((_QWORD *)v3 + 12);
  v10 = *((_QWORD *)v3 + 13);
  if (v10 >= v9)
  {
    v11 = v10 + 1;
    if (v9 < v10 + 1)
    {
      if (*((_QWORD *)v3 + 11))
      {
        v12 = 2 * v9;
        v13 = v9 == 0;
        v14 = 8;
        if (!v13)
          v14 = v12;
        if (v14 <= v11)
          v15 = v11;
        else
          v15 = v14;
        this = (re::SyncViewer ***)re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)v3 + 11, v15);
      }
      else
      {
        this = (re::SyncViewer ***)re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)v3 + 11, v11);
        ++*((_DWORD *)v3 + 28);
      }
    }
    v10 = *((_QWORD *)v3 + 13);
  }
  *(_QWORD *)(*((_QWORD *)v3 + 15) + 8 * v10) = a2;
  *((_QWORD *)v3 + 13) = v10 + 1;
  ++*((_DWORD *)v3 + 28);
  v16 = *((_QWORD *)a2 + 2);
  v17 = *((_QWORD *)a2 + 3);
  if (v17 >= v16)
  {
    v18 = v17 + 1;
    if (v16 < v17 + 1)
    {
      if (*((_QWORD *)a2 + 1))
      {
        v19 = 2 * v16;
        v13 = v16 == 0;
        v20 = 8;
        if (!v13)
          v20 = v19;
        if (v20 <= v18)
          v21 = v18;
        else
          v21 = v20;
        re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)a2 + 1, v21);
      }
      else
      {
        re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)a2 + 1, v18);
        ++*((_DWORD *)a2 + 8);
      }
    }
    v17 = *((_QWORD *)a2 + 3);
  }
  *(_QWORD *)(*((_QWORD *)a2 + 5) + 8 * v17) = v3;
  *((_QWORD *)a2 + 3) = v17 + 1;
  ++*((_DWORD *)a2 + 8);
  v22 = *((unsigned int *)v3 + 18);
  if ((_DWORD)v22)
  {
    v23 = 0;
    v24 = (int *)(*((_QWORD *)v3 + 7) + 8);
    while (1)
    {
      v25 = *v24;
      v24 += 6;
      if (v25 < 0)
        break;
      if (v22 == ++v23)
      {
        LODWORD(v23) = *((_DWORD *)v3 + 18);
        break;
      }
    }
  }
  else
  {
    LODWORD(v23) = 0;
  }
  if ((_DWORD)v22 != (_DWORD)v23)
  {
    v26 = v23;
    do
    {
      (*(void (**)(re::SyncViewer *, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(*((_QWORD *)v3 + 7) + 24 * v26 + 16));
      if (*((_DWORD *)v3 + 18) <= (v23 + 1))
        v27 = v23 + 1;
      else
        v27 = *((_DWORD *)v3 + 18);
      v28 = v23;
      while (1)
      {
        v26 = (v28 + 1);
        if (v27 - 1 == v28)
          break;
        ++v28;
        LODWORD(v23) = v26;
        if ((*(_DWORD *)(*((_QWORD *)v3 + 7) + 24 * v26 + 8) & 0x80000000) != 0)
          goto LABEL_48;
      }
      LODWORD(v23) = v27;
LABEL_48:
      ;
    }
    while ((_DWORD)v22 != (_DWORD)v23);
  }
}

uint64_t re::SyncView::removeViewer(uint64_t this, re::SyncViewer *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  re::SyncViewer **v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;

  v3 = this;
  v4 = *(_QWORD *)(this + 120);
  v5 = *(_QWORD *)(this + 104);
  if (v5)
  {
    v6 = 8 * v5;
    v7 = *(re::SyncViewer ***)(this + 120);
    while (*v7 != a2)
    {
      ++v7;
      v6 -= 8;
      if (!v6)
      {
        v7 = (re::SyncViewer **)(v4 + 8 * v5);
        break;
      }
    }
  }
  else
  {
    v7 = *(re::SyncViewer ***)(this + 120);
  }
  v8 = ((uint64_t)v7 - v4) >> 3;
  if (v8 != v5)
  {
    v9 = *(unsigned int *)(this + 72);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = (int *)(*(_QWORD *)(this + 56) + 8);
      while (1)
      {
        v12 = *v11;
        v11 += 6;
        if (v12 < 0)
          break;
        if (v9 == ++v10)
        {
          LODWORD(v10) = *(_DWORD *)(this + 72);
          break;
        }
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if ((_DWORD)v9 != (_DWORD)v10)
    {
      v13 = v10;
      do
      {
        (*(void (**)(re::SyncViewer *, _QWORD))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(v3 + 56) + 24 * v13 + 16));
        if (*(_DWORD *)(v3 + 72) <= (v10 + 1))
          v14 = v10 + 1;
        else
          v14 = *(_DWORD *)(v3 + 72);
        v15 = v10;
        while (1)
        {
          v13 = (v15 + 1);
          if (v14 - 1 == v15)
            break;
          ++v15;
          LODWORD(v10) = v13;
          if ((*(_DWORD *)(*(_QWORD *)(v3 + 56) + 24 * v13 + 8) & 0x80000000) != 0)
            goto LABEL_24;
        }
        LODWORD(v10) = v14;
LABEL_24:
        ;
      }
      while ((_DWORD)v9 != (_DWORD)v10);
    }
    return re::SyncView::removeFromViewersAtWithoutNotifying(v3, v8);
  }
  return this;
}

BOOL re::SyncView::removeFromViewersWithoutNotifying(re::SyncView *this, re::SyncViewer *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  re::SyncViewer **v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *((_QWORD *)this + 15);
  v3 = *((_QWORD *)this + 13);
  if (v3)
  {
    v4 = 8 * v3;
    v5 = (re::SyncViewer **)*((_QWORD *)this + 15);
    while (*v5 != a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        v5 = (re::SyncViewer **)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    v5 = (re::SyncViewer **)*((_QWORD *)this + 15);
  }
  v6 = (uint64_t)v5 - v2;
  v7 = v6 >> 3;
  if (v6 >> 3 != v3)
    re::SyncView::removeFromViewersAtWithoutNotifying((uint64_t)this, v6 >> 3);
  return v7 != v3;
}

void re::HashSetBase<re::SyncViewable *,re::SyncViewable *,re::internal::ValueAsKey<re::SyncViewable *>,re::Hash<re::SyncViewable *>,re::EqualTo<re::SyncViewable *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v7)
  {
    v8 = v6 % v7;
    v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
    if ((_DWORD)v9 != 0x7FFFFFFF)
    {
      v10 = *(_QWORD *)(a1 + 16);
      if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
        return;
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v9 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
          return;
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  v11 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
    v11 = *(unsigned int *)(a1 + 32);
    v12 = v11;
    if ((_DWORD)v11 == (_DWORD)v7)
    {
      re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v8) = v6 % *(unsigned int *)(a1 + 24);
      v12 = *(_DWORD *)(a1 + 32);
      v4 = *a2;
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
  }
  else
  {
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 24 * v11 + 8) = v14 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11) = v6;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 16) = v4;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

void re::SyncView::removeObject(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;

  v8 = (_QWORD *)a2;
  if (re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove(a1 + 40, (uint64_t *)&v8))
  {
    v3 = *(_QWORD *)(a1 + 104);
    if (v3)
    {
      v4 = *(uint64_t **)(a1 + 120);
      v5 = 8 * v3;
      do
      {
        v6 = *v4++;
        (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 32))(v6, v8);
        v5 -= 8;
      }
      while (v5);
    }
    v7 = v8;
    if (*v8)
    {

      *v7 = 0;
    }
  }
}

void re::SyncView::transferObject(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  id v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  id v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30[2];
  unint64_t v31;
  int v32;
  void *__dst;
  uint64_t *v34;

  v34 = a2;
  v3 = *a2;
  if (*a2)
  {
    if (v3 == a1)
      return;
    re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove(v3 + 40, (uint64_t *)&v34);
    re::HashSetBase<re::SyncViewable *,re::SyncViewable *,re::internal::ValueAsKey<re::SyncViewable *>,re::Hash<re::SyncViewable *>,re::EqualTo<re::SyncViewable *>,true,false>::add(a1 + 40, (uint64_t *)&v34);
    if (a1)
      v4 = (id)(a1 + 8);
    v5 = *v34;
    *v34 = a1;
    if (v5)

    __dst = 0;
    v30[1] = 0;
    v31 = 0;
    v30[0] = 0;
    v32 = 0;
    if (*(_QWORD *)(v3 + 88))
    {
      v6 = *(_QWORD *)(v3 + 104);
      v30[0] = *(_QWORD *)(v3 + 88);
      re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity(v30, v6);
      ++v32;
      v7 = *(_QWORD *)(v3 + 104);
      if (v7 >= v31)
      {
        re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity(v30, *(_QWORD *)(v3 + 104));
        v18 = v31;
        v8 = (unint64_t *)__dst;
        if (v31)
          memmove(__dst, *(const void **)(v3 + 120), 8 * v31);
        memcpy(&v8[v18], (const void *)(*(_QWORD *)(v3 + 120) + 8 * v18), 8 * v7 - 8 * v18);
        v31 = v7;
        v9 = &v8[v7];
        if (v7)
        {
          v10 = 126 - 2 * __clz(v7);
          goto LABEL_26;
        }
      }
      else
      {
        v8 = (unint64_t *)__dst;
        if (v7)
        {
          memmove(__dst, *(const void **)(v3 + 120), 8 * v7);
          v31 = v7;
          v9 = &v8[v7];
          v10 = 126 - 2 * __clz(v7);
          v7 = 1;
LABEL_26:
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(v8, v9, v10, 1);
          v19 = *(_QWORD *)(a1 + 104);
          v20 = 126 - 2 * __clz(v19);
          if (v19)
            v21 = v20;
          else
            v21 = 0;
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(*(unint64_t **)(a1 + 120), (unint64_t *)(*(_QWORD *)(a1 + 120) + 8 * v19), v21, 1);
          v22 = *(_QWORD *)(a1 + 104);
          if (v7 | v22)
          {
            v23 = *(unint64_t **)(a1 + 120);
            v24 = &v23[v22];
            v25 = v8;
            do
            {
              if (v25 == v9)
              {
                v28 = *v23++;
                (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v28 + 24))(v28, v34);
                v25 = v9;
              }
              else if (v23 == v24)
              {
                v29 = *v25++;
                (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v29 + 32))(v29, v34);
                v23 = v24;
              }
              else
              {
                v26 = *v23;
                v27 = *v25;
                if (*v23 >= *v25)
                {
                  if (v27 >= v26)
                    ++v23;
                  else
                    (*(void (**)(unint64_t, uint64_t *))(*(_QWORD *)v27 + 32))(v27, v34);
                  ++v25;
                }
                else
                {
                  (*(void (**)(_QWORD, uint64_t *))(*(_QWORD *)v26 + 24))(*v23++, v34);
                }
              }
            }
            while (v25 != v9 || v23 != v24);
          }
          if (v8)
          {
            if (v30[0])
              (*(void (**)(uint64_t, unint64_t *))(*(_QWORD *)v30[0] + 40))(v30[0], v8);
          }
          return;
        }
        v31 = 0;
        v9 = (unint64_t *)__dst;
      }
    }
    else
    {
      v9 = 0;
      v8 = 0;
      v7 = 0;
    }
    v10 = 0;
    goto LABEL_26;
  }
  v30[0] = (uint64_t)a2;
  re::HashSetBase<re::SyncViewable *,re::SyncViewable *,re::internal::ValueAsKey<re::SyncViewable *>,re::Hash<re::SyncViewable *>,re::EqualTo<re::SyncViewable *>,true,false>::add(a1 + 40, v30);
  if (a1)
    v12 = (id)(a1 + 8);
  v13 = *a2;
  *a2 = a1;
  if (v13)

  v14 = *(_QWORD *)(a1 + 104);
  if (v14)
  {
    v15 = *(uint64_t **)(a1 + 120);
    v16 = 8 * v14;
    do
    {
      v17 = *v15++;
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v17 + 24))(v17, a2);
      v16 -= 8;
    }
    while (v16);
  }
}

void re::SyncViewer::~SyncViewer(re::SyncView ***this)
{
  re::SyncView **v2;

  *this = (re::SyncView **)off_24E071B48;
  while (this[3])
    re::SyncView::removeFromViewersWithoutNotifying(*this[5], (re::SyncViewer *)this);
  v2 = this[1];
  if (v2)
  {
    if (this[5])
      (*((void (**)(re::SyncView **))*v2 + 5))(v2);
    this[5] = 0;
    this[2] = 0;
    this[3] = 0;
    this[1] = 0;
    ++*((_DWORD *)this + 8);
  }
}

BOOL re::SyncViewer::includes(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  v2 = *(_QWORD *)(a2 + 120);
  v3 = *(_QWORD *)(a2 + 104);
  if (v3)
  {
    v4 = 8 * v3;
    v5 = *(_QWORD **)(a2 + 120);
    while (*v5 != a1)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        v5 = (_QWORD *)(v2 + 8 * v3);
        return v3 != ((uint64_t)v5 - v2) >> 3;
      }
    }
  }
  else
  {
    v5 = *(_QWORD **)(a2 + 120);
  }
  return v3 != ((uint64_t)v5 - v2) >> 3;
}

unint64_t *std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(unint64_t *result, unint64_t *a2, uint64_t a3, char a4)
{
  unint64_t *v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  BOOL v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t *v39;
  BOOL v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t *v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  BOOL v55;
  unint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t *v62;
  unint64_t *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t *v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v72;
  unint64_t v73;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = a2 - v8;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v37 = *(a2 - 1);
        v38 = *v8;
        if (v37 < *v8)
        {
          *v8 = v37;
          *(a2 - 1) = v38;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v8, v8 + 1, a2 - 1);
      case 4uLL:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v8, v8 + 1, v8 + 2, a2 - 1);
      case 5uLL:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v8, v8 + 1, v8 + 2, v8 + 3, a2 - 1);
      default:
        if (v9 <= 191)
        {
          v39 = v8 + 1;
          v41 = v8 == a2 || v39 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v41)
            {
              v42 = 8;
              v43 = v8;
              do
              {
                v45 = *v43;
                v44 = v43[1];
                v43 = v39;
                if (v44 < v45)
                {
                  v46 = v42;
                  while (1)
                  {
                    *(unint64_t *)((char *)v8 + v46) = v45;
                    v47 = v46 - 8;
                    if (v46 == 8)
                      break;
                    v45 = *(unint64_t *)((char *)v8 + v46 - 16);
                    v46 -= 8;
                    if (v44 >= v45)
                    {
                      v48 = (unint64_t *)((char *)v8 + v47);
                      goto LABEL_75;
                    }
                  }
                  v48 = v8;
LABEL_75:
                  *v48 = v44;
                }
                v39 = v43 + 1;
                v42 += 8;
              }
              while (v43 + 1 != a2);
            }
          }
          else if (!v41)
          {
            do
            {
              v73 = *v7;
              v72 = v7[1];
              v7 = v39;
              if (v72 < v73)
              {
                do
                {
                  *v39 = v73;
                  v73 = *(v39 - 2);
                  --v39;
                }
                while (v72 < v73);
                *v39 = v72;
              }
              v39 = v7 + 1;
            }
            while (v7 + 1 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v49 = (v10 - 2) >> 1;
            v50 = v49;
            do
            {
              v51 = v50;
              if (v49 >= v50)
              {
                v52 = (2 * v50) | 1;
                v53 = &v8[v52];
                if (2 * v51 + 2 >= (uint64_t)v10)
                {
                  v54 = *v53;
                }
                else
                {
                  v54 = v53[1];
                  v55 = *v53 >= v54;
                  if (*v53 < v54)
                    ++v53;
                  else
                    v54 = *v53;
                  if (!v55)
                    v52 = 2 * v51 + 2;
                }
                v56 = &v8[v51];
                v57 = *v56;
                if (v54 >= *v56)
                {
                  do
                  {
                    *v56 = v54;
                    v56 = v53;
                    if (v49 < v52)
                      break;
                    v58 = (2 * v52) | 1;
                    v53 = &v8[v58];
                    v52 = 2 * v52 + 2;
                    if (v52 >= (uint64_t)v10)
                    {
                      v54 = *v53;
                      v52 = v58;
                    }
                    else
                    {
                      v54 = *v53;
                      result = v53 + 1;
                      if (*v53 >= v53[1])
                      {
                        v52 = v58;
                      }
                      else
                      {
                        v54 = v53[1];
                        ++v53;
                      }
                    }
                  }
                  while (v54 >= v57);
                  *v56 = v57;
                }
              }
              v50 = v51 - 1;
            }
            while (v51);
            v59 = (unint64_t)v9 >> 3;
            do
            {
              v60 = 0;
              v61 = *v8;
              v62 = v8;
              do
              {
                v63 = &v62[v60 + 1];
                v64 = (2 * v60) | 1;
                v60 = 2 * v60 + 2;
                if (v60 >= v59)
                {
                  v65 = *v63;
                  v60 = v64;
                }
                else
                {
                  v65 = *v63;
                  if (*v63 >= v63[1])
                  {
                    v60 = v64;
                  }
                  else
                  {
                    v65 = v63[1];
                    ++v63;
                  }
                }
                *v62 = v65;
                v62 = v63;
              }
              while (v60 <= (uint64_t)((unint64_t)(v59 - 2) >> 1));
              if (v63 == --a2)
              {
                *v63 = v61;
              }
              else
              {
                *v63 = *a2;
                *a2 = v61;
                v66 = (char *)v63 - (char *)v8 + 8;
                if (v66 >= 9)
                {
                  v67 = (((unint64_t)v66 >> 3) - 2) >> 1;
                  v68 = &v8[v67];
                  v69 = *v68;
                  v70 = *v63;
                  if (*v68 < *v63)
                  {
                    do
                    {
                      *v63 = v69;
                      v63 = v68;
                      if (!v67)
                        break;
                      v67 = (v67 - 1) >> 1;
                      v68 = &v8[v67];
                      v69 = *v68;
                    }
                    while (*v68 < v70);
                    *v63 = v70;
                  }
                }
              }
            }
            while (v59-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = &v8[v10 >> 1];
        if ((unint64_t)v9 < 0x401)
        {
          result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(&v7[v10 >> 1], v7, a2 - 1);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v7, &v7[v10 >> 1], a2 - 1);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v7 + 1, v12 - 1, a2 - 2);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v7 + 2, &v7[v11 + 1], a2 - 3);
          result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v12 - 1, v12, &v7[v11 + 1]);
          v13 = *v7;
          *v7 = *v12;
          *v12 = v13;
        }
        --a3;
        v14 = *v7;
        if ((a4 & 1) == 0 && *(v7 - 1) >= v14)
        {
          if (v14 >= *(a2 - 1))
          {
            v29 = v7 + 1;
            do
            {
              v8 = v29;
              if (v29 >= a2)
                break;
              ++v29;
            }
            while (v14 >= *v8);
          }
          else
          {
            v8 = v7;
            do
            {
              v28 = v8[1];
              ++v8;
            }
            while (v14 >= v28);
          }
          v30 = a2;
          if (v8 < a2)
          {
            v30 = a2;
            do
              v31 = *--v30;
            while (v14 < v31);
          }
          if (v8 < v30)
          {
            v32 = *v8;
            v33 = *v30;
            do
            {
              *v8 = v33;
              *v30 = v32;
              do
              {
                v34 = v8[1];
                ++v8;
                v32 = v34;
              }
              while (v14 >= v34);
              do
              {
                v35 = *--v30;
                v33 = v35;
              }
              while (v14 < v35);
            }
            while (v8 < v30);
          }
          v36 = v8 - 1;
          if (v8 - 1 != v7)
            *v7 = *v36;
          a4 = 0;
          *v36 = v14;
          continue;
        }
        v15 = 0;
        do
          v16 = v7[++v15];
        while (v16 < v14);
        v17 = &v7[v15];
        v18 = a2;
        if (v15 == 1)
        {
          v18 = a2;
          do
          {
            if (v17 >= v18)
              break;
            v20 = *--v18;
          }
          while (v20 >= v14);
        }
        else
        {
          do
            v19 = *--v18;
          while (v19 >= v14);
        }
        if (v17 >= v18)
        {
          v26 = v17 - 1;
        }
        else
        {
          v21 = *v18;
          v22 = &v7[v15];
          v23 = v18;
          do
          {
            *v22 = v21;
            *v23 = v16;
            do
            {
              v24 = v22[1];
              ++v22;
              v16 = v24;
            }
            while (v24 < v14);
            do
            {
              v25 = *--v23;
              v21 = v25;
            }
            while (v25 >= v14);
          }
          while (v22 < v23);
          v26 = v22 - 1;
        }
        if (v26 != v7)
          *v7 = *v26;
        *v26 = v14;
        if (v17 < v18)
        {
LABEL_32:
          result = (unint64_t *)std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(v7, v26, a3, a4 & 1);
          a4 = 0;
          v8 = v26 + 1;
          continue;
        }
        v27 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v7, v26);
        v8 = v26 + 1;
        result = (unint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v26 + 1, a2);
        if (!(_DWORD)result)
        {
          if (v27)
            continue;
          goto LABEL_32;
        }
        a2 = v26;
        if (!v27)
          goto LABEL_2;
        return result;
    }
  }
}

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = *a2;
  v4 = *result;
  v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      *a2 = v5;
      *a3 = v3;
      v6 = *result;
      if (*a2 < *result)
      {
        *result = *a2;
        *a2 = v6;
      }
    }
  }
  else
  {
    if (v5 >= v3)
    {
      *result = v3;
      *a2 = v4;
      if (*a3 >= v4)
        return result;
      *a2 = *a3;
    }
    else
    {
      *result = v5;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 24;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    if (*v9 < *v8)
    {
      v14 = v11;
      while (1)
      {
        *(unint64_t *)((char *)a1 + v14) = v13;
        v15 = v14 - 8;
        if (v14 == 8)
          break;
        v13 = *(unint64_t *)((char *)a1 + v14 - 16);
        v14 -= 8;
        if (v12 >= v13)
        {
          v16 = (unint64_t *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v11 += 8;
    if (++v9 == a2)
      return 1;
  }
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t *result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a2, a3);
  v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t *result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a2, a3, a4);
  v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

uint64_t re::SyncSendBuffer::SyncSendBuffer(uint64_t a1, id *a2, id *a3, uint64_t a4)
{
  id v8;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24E071BA8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 60) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_QWORD *)(a1 + 148) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_DWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 196) = 0x7FFFFFFFLL;
  *(_BYTE *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 229) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  objc_copyWeak((id *)(a1 + 280), a2);
  *(_QWORD *)(a1 + 288) = 0;
  objc_copyWeak((id *)(a1 + 288), a3);
  *(_QWORD *)(a1 + 296) = a4;
  if (a4)
    v8 = (id)(a4 + 8);
  *(_DWORD *)(a1 + 304) = 500;
  return a1;
}

void re::SyncSendBuffer::resend(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v8;
  _DWORD *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int16 *v39;
  re::SyncObject *v40;
  unint64_t v41;
  unsigned __int16 *v42;
  unsigned int v43;
  unsigned __int16 v44;
  int v45;
  int v46;
  unsigned __int16 v47;
  uint64_t v48;
  unsigned __int16 *v49;
  int v50;
  char v51;
  char v52;
  int v53;
  unsigned __int16 v54;
  unsigned __int16 *v55;
  unsigned __int16 *v56;
  int v57;
  uint64_t v58;
  unsigned __int16 *v59;
  int v60;
  id WeakRetained;
  void *v62;
  unsigned __int16 *v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  NSObject *v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char v75;
  id v76;
  void *v77;
  unint64_t v78;
  id v79;
  unint64_t v80;
  unint64_t v81;
  char v82;
  char v83;
  unint64_t v84;
  uint64_t v85;
  BOOL v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  id v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  char *v109;
  void *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  _anonymous_namespace_ *v115;
  unsigned int v116;
  uint64_t v117;
  unint64_t v118;
  int v119;
  unsigned __int16 *v121;
  char v122;
  unsigned __int16 *v124;
  char v125;
  id *location;
  id *locationa;
  uint64_t *v128;
  _BYTE buf[22];
  __int16 v130;
  char *v131;
  uint64_t v132;

  v6 = a2;
  v132 = *MEMORY[0x24BDAC8D0];
  location = (id *)*(unsigned int *)(a1 + 144);
  v8 = 0;
  if ((_DWORD)location)
  {
    v9 = (_DWORD *)(*(_QWORD *)(a1 + 128) + 8);
    while ((*v9 & 0x80000000) == 0)
    {
      v9 += 244;
      if (location == (id *)++v8)
      {
        LODWORD(v8) = *(_DWORD *)(a1 + 144);
        break;
      }
    }
  }
  v10 = *(_DWORD *)(a1 + 144);
  if ((_DWORD)location != (_DWORD)v8)
  {
    v11 = v8;
    do
    {
      v12 = *(_QWORD *)(a1 + 128) + 976 * v11;
      v13 = v12 + 24;
      v14 = *(_WORD *)(v12 + 632) - 32;
      v15 = v12 + 536;
      v16 = v12 + 600;
      do
      {
        v17 = v14 & 0x1F;
        if (*(unsigned __int16 *)(v15 + 2 * v17) == v14 && *(_BYTE *)(v16 + v17))
        {
          if ((v18 = *a4, v19 = v18 - v14, v18 >= v14) && v19 < 0x8000 || v18 < v14 && v14 - v18 >= 0x8000)
          {
            v20 = v19 >= 0x8000 ? v19 + 0x10000 : (int)v19;
            if (v20 <= 0xFF
              && ((*(_QWORD *)&a4[4 * re::Bitset<256>::toWordIndex((uint64_t)(a4 + 4), v20) + 4] >> v20) & 1) != 0)
            {
              *(_BYTE *)(v13 + 16 * v17 + 10) = 1;
            }
          }
        }
        ++v14;
      }
      while (*(unsigned __int16 *)(v13 + 608) != v14);
      v10 = *(_DWORD *)(a1 + 144);
      if (v10 <= (int)v8 + 1)
        v21 = v8 + 1;
      else
        v21 = *(_DWORD *)(a1 + 144);
      v6 = a2;
      while (1)
      {
        v11 = (v8 + 1);
        if (v21 - 1 == (_DWORD)v8)
          break;
        LODWORD(v8) = v8 + 1;
        v22 = v11;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 128) + 976 * v11 + 8) & 0x80000000) != 0)
          goto LABEL_30;
      }
      v22 = v21;
LABEL_30:
      LODWORD(v8) = v22;
    }
    while ((_DWORD)location != v22);
  }
  if (!a3)
    goto LABEL_46;
  v23 = v6 + 72 * a3;
  do
  {
    v24 = *(_QWORD *)(v6 + 48);
    if (v24)
    {
      v25 = *(unint64_t **)(v6 + 64);
      v26 = &v25[3 * v24];
      do
      {
        v27 = *v25;
        *(_QWORD *)buf = v27;
        v28 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) >> 27));
        v29 = v28 ^ (v28 >> 31);
        v30 = *(unsigned int *)(a1 + 184);
        if ((_DWORD)v30)
        {
          v31 = v29 % v30;
          v32 = *(unsigned int *)(*(_QWORD *)(a1 + 168) + 4 * (v29 % v30));
          if ((_DWORD)v32 != 0x7FFFFFFF)
          {
            v33 = *(_QWORD *)(a1 + 176);
            while (*(_QWORD *)(v33 + 24 * v32 + 16) != v27)
            {
              LODWORD(v32) = *(_DWORD *)(v33 + 24 * v32 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v32 == 0x7FFFFFFF)
                goto LABEL_42;
            }
            goto LABEL_43;
          }
        }
        else
        {
          LODWORD(v31) = 0;
        }
LABEL_42:
        re::HashSetBase<re::SyncObject *,re::SyncObject *,re::internal::ValueAsKey<re::SyncObject *>,re::Hash<re::SyncObject *>,re::EqualTo<re::SyncObject *>,true,false>::addAsMove(a1 + 160, v31, v29, buf);
        ++*(_DWORD *)(a1 + 200);
LABEL_43:
        v25 += 3;
      }
      while (v25 != v26);
    }
    v6 += 72;
  }
  while (v6 != v23);
  v10 = *(_DWORD *)(a1 + 144);
LABEL_46:
  v34 = 0;
  if (v10)
  {
    v35 = (_DWORD *)(*(_QWORD *)(a1 + 128) + 8);
    while ((*v35 & 0x80000000) == 0)
    {
      v35 += 244;
      if (v10 == ++v34)
      {
        LODWORD(v34) = v10;
        break;
      }
    }
  }
  if (v10 != (_DWORD)v34)
  {
    v36 = v34;
    locationa = (id *)(a1 + 288);
    v115 = (_anonymous_namespace_ *)(a1 + 72);
    v116 = v10;
    while (1)
    {
      v37 = *(_QWORD *)(a1 + 128);
      v38 = v37 + 976 * v36;
      v40 = *(re::SyncObject **)(v38 + 16);
      v39 = (unsigned __int16 *)(v38 + 16);
      v41 = re::SyncObject::latestStateHandle(v40);
      if (v41 != -1)
        break;
      v68 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        v69 = *(_QWORD *)(*(_QWORD *)v39 + 24);
        v70 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)v39 + 88) + 16);
        v71 = v70[4];
        v72 = v70[6];
        v73 = (char *)v70[7];
        v74 = (char *)v70 + 49;
        if ((v72 & 1) != 0)
          v74 = v73;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v69;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v71;
        v130 = 2080;
        v131 = v74;
        _os_log_error_impl(&dword_21C69B000, v68, OS_LOG_TYPE_ERROR, "Sync object without snapshot among snapshot resend entries (id: %llu, type: %llu[%s]).", buf, 0x20u);
      }
LABEL_120:
      v96 = *(_DWORD *)(a1 + 144);
      if (v96 <= (int)v34 + 1)
        v96 = v34 + 1;
      while (1)
      {
        v36 = (v34 + 1);
        if (v96 - 1 == (_DWORD)v34)
          break;
        LODWORD(v34) = v34 + 1;
        v97 = v36;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 128) + 976 * v36 + 8) & 0x80000000) != 0)
          goto LABEL_126;
      }
      v97 = v96;
LABEL_126:
      LODWORD(v34) = v97;
      if (v10 == v97)
        goto LABEL_127;
    }
    v117 = v37;
    v128 = (uint64_t *)v39;
    v42 = v39 + 4;
    v43 = v39[308];
    v44 = v43 - 32;
    v45 = (unsigned __int16)(v43 - 32);
    if (v43 > 0x1F || v45 - v43 >= 0x8000)
    {
      v46 = v39[308];
      v47 = v39[308];
      while (v47 <= v44 || !((v46 - v45) >> 15))
      {
        v48 = --v47 & 0x1F;
        if (v39[v48 + 260] == v47 && *((_BYTE *)v39 + v48 + 584))
        {
          v49 = &v42[8 * v48];
          goto LABEL_64;
        }
        v46 = v47;
        if (v47 <= v44 && !((v45 - v47) >> 15))
          break;
      }
    }
    v49 = 0;
LABEL_64:
    v50 = 0;
    v51 = 0;
    v52 = 0;
    v53 = (*(unsigned __int8 *)(*(_QWORD *)v39 + 128) >> 2) & 1;
    v54 = *(_WORD *)(*(_QWORD *)v39 + 176);
    v55 = v39 + 260;
    v56 = v39 + 292;
    v57 = v119;
    v121 = v39 + 292;
    v124 = v39 + 260;
    do
    {
      v58 = v44 & 0x1F;
      if (v55[v58] == v44 && *((_BYTE *)v56 + v58))
      {
        v59 = &v42[8 * v58];
        if (*((_BYTE *)v59 + 10))
        {
          v60 = v50;
          WeakRetained = objc_loadWeakRetained(locationa);
          if (WeakRetained)
          {
            v62 = WeakRetained;
            re::SyncAckedStateBuffer::addAcked((uint64_t)WeakRetained - 8, v128, *(_QWORD *)v59, v42[8 * v58 + 6]);

          }
          v41 = *(_QWORD *)v59;
          v43 = *(_QWORD *)v59 == *(_QWORD *)v49
             && (v63 = &v42[8 * v58], *((unsigned __int8 *)v63 + 9) == *((unsigned __int8 *)v49 + 9))
             && v63[6] == v49[6];
          v56 = v121;
          v55 = v124;
          v50 = v60 | v43;
          v52 = *((_BYTE *)v59 + 10);
          LOWORD(v43) = v42[304];
        }
        else
        {
          v52 = 0;
          v41 = *(_QWORD *)v59;
        }
        v51 = *((_BYTE *)v59 + 8);
        v53 = *((unsigned __int8 *)v59 + 9);
        v57 = *((unsigned __int8 *)v59 + 11);
        v54 = v59[6];
      }
      ++v44;
    }
    while (v44 != (unsigned __int16)v43);
    v64 = *v128;
    v65 = *(_QWORD *)(*v128 + 80);
    if (v65)
    {
      v119 = v57;
      v122 = v51;
      v125 = v52;
      v66 = v53;
      v118 = v41;
      v10 = v116;
      do
      {
        v67 = v64;
        v64 = v65;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v67 + 88) + 16) + 73))
          break;
        v65 = *(_QWORD *)(v65 + 80);
        v67 = v64;
      }
      while (v65);
    }
    else
    {
      v119 = v57;
      v122 = v51;
      v125 = v52;
      v66 = v53;
      v118 = v41;
      v67 = *v128;
      v10 = v116;
    }
    v75 = v50 | (*(_BYTE *)(v67 + 170) == 0);
    v76 = objc_loadWeakRetained(locationa);
    v77 = v76;
    if (v76 && v75 & 1 | (v66 != 0))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)v76 + 16, v128);
    }
    else if (!v76)
    {
      goto LABEL_93;
    }

LABEL_93:
    v78 = *v128;
    if ((v75 & 1) != 0)
    {
      if (v78)
        v79 = (id)(v78 + 8);
      v80 = *(_QWORD *)(a1 + 80);
      v81 = *(_QWORD *)(a1 + 88);
      v82 = v122;
      v83 = v125;
      if (v81 >= v80)
      {
        v84 = v81 + 1;
        if (v80 < v81 + 1)
        {
          if (*(_QWORD *)v115)
          {
            v85 = 2 * v80;
            v86 = v80 == 0;
            v87 = 8;
            if (!v86)
              v87 = v85;
            if (v87 <= v84)
              v88 = v84;
            else
              v88 = v87;
            re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(v115, v88);
          }
          else
          {
            re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(v115, v84);
            ++*(_DWORD *)(a1 + 96);
          }
          v83 = v125;
          v82 = v122;
        }
        v81 = *(_QWORD *)(a1 + 88);
      }
      v95 = *(_QWORD *)(a1 + 104) + 24 * v81;
      *(_QWORD *)v95 = v78;
      *(_QWORD *)(v95 + 8) = v118;
      *(_BYTE *)(v95 + 16) = v82;
      *(_BYTE *)(v95 + 17) = v66;
      *(_BYTE *)(v95 + 18) = v83;
      *(_BYTE *)(v95 + 19) = v119;
      *(_WORD *)(v95 + 20) = v54;
      ++*(_QWORD *)(a1 + 88);
      ++*(_DWORD *)(a1 + 96);
    }
    else
    {
      v89 = *(unsigned int *)(a1 + 184);
      if (!(_DWORD)v89
        || (v90 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v78 ^ (v78 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v78 ^ (v78 >> 30))) >> 27)),
            v91 = *(unsigned int *)(*(_QWORD *)(a1 + 168) + 4 * ((v90 ^ (v90 >> 31)) % v89)),
            (_DWORD)v91 == 0x7FFFFFFF))
      {
LABEL_110:
        if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 296) + 32))(*(_QWORD *)(a1 + 296))
           - *(_QWORD *)(v117 + 976 * v36 + 968) > (unint64_t)*(unsigned int *)(a1 + 304))
        {
          v93 = *v128;
          *(_QWORD *)buf = v93;
          if (v93)
            v94 = (id)(v93 + 8);
          *(_QWORD *)&buf[8] = v118;
          buf[16] = buf[16] & 0xF0 | (2 * v66);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::add((_QWORD *)(a1 + 240), (uint64_t)buf);
          if (*(_QWORD *)buf)

        }
      }
      else
      {
        v92 = *(_QWORD *)(a1 + 176);
        while (*(_QWORD *)(v92 + 24 * v91 + 16) != v78)
        {
          LODWORD(v91) = *(_DWORD *)(v92 + 24 * v91 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v91 == 0x7FFFFFFF)
            goto LABEL_110;
        }
      }
    }
    goto LABEL_120;
  }
LABEL_127:
  if (*(_DWORD *)(a1 + 188))
  {
    v98 = *(unsigned int *)(a1 + 184);
    if ((_DWORD)v98)
      memset_pattern16(*(void **)(a1 + 168), &unk_21C701D20, 4 * v98);
    v99 = *(unsigned int *)(a1 + 192);
    if ((_DWORD)v99)
    {
      v100 = 0;
      v101 = 24 * v99;
      do
      {
        v102 = *(_QWORD *)(a1 + 176) + v100;
        v103 = *(_DWORD *)(v102 + 8);
        if (v103 < 0)
          *(_DWORD *)(v102 + 8) = v103 & 0x7FFFFFFF;
        v100 += 24;
      }
      while (v101 != v100);
    }
    *(_DWORD *)(a1 + 188) = 0;
    *(_DWORD *)(a1 + 192) = 0;
    v104 = *(_DWORD *)(a1 + 200) + 1;
    *(_DWORD *)(a1 + 196) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 200) = v104;
  }
  if (*(_QWORD *)(a1 + 256))
  {
    *(_BYTE *)(a1 + 208) = 0x80;
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a5 + 32) + 16))(*(_QWORD *)(a5 + 32), a1 + 208);
  }
  re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(a1 + 240);
  v105 = *(_QWORD *)(a1 + 88);
  if (v105)
  {
    v106 = *(_QWORD *)(a1 + 104);
    v107 = 24 * v105;
    do
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(a1 + 112, (uint64_t *)v106);
      if (*(_BYTE *)(v106 + 17))
      {
        v108 = (char *)objc_loadWeakRetained((id *)(a1 + 280));
        if (v108)
          v109 = v108 - 8;
        else
          v109 = 0;
        v110 = v109 + 8;
        (*(void (**)(char *, _QWORD, _QWORD))(*(_QWORD *)v109 + 40))(v109, *(_QWORD *)(*(_QWORD *)v106 + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v106 + 88) + 16) + 32));

      }
      v106 += 24;
      v107 -= 24;
    }
    while (v107);
    v111 = *(_QWORD *)(a1 + 88);
    v112 = *(_QWORD *)(a1 + 104);
    *(_QWORD *)(a1 + 88) = 0;
    if (v111)
    {
      v113 = 24 * v111;
      do
      {
        if (*(_QWORD *)v112)
        {

          *(_QWORD *)v112 = 0;
        }
        v112 += 24;
        v113 -= 24;
      }
      while (v113);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 88) = 0;
  }
  ++*(_DWORD *)(a1 + 96);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = *a2;
  v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v9 + 976 * v7 + 16) != v3)
  {
    while (1)
    {
      v10 = v7;
      v11 = *(_DWORD *)(v9 + 976 * v7 + 8);
      v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      if (*(_QWORD *)(v9 + 976 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 976 * v10 + 8) = *(_DWORD *)(v9 + 976 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 976 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 976 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  v12 = *(_QWORD *)(a1 + 16);
  v13 = v12 + 976 * v7;
  v16 = *(_DWORD *)(v13 + 8);
  v14 = (int *)(v13 + 8);
  v15 = v16;
  if (v16 < 0)
  {
    *v14 = v15 & 0x7FFFFFFF;
    v17 = v12 + 976 * v7;
    v20 = *(_QWORD *)(v17 + 16);
    v19 = (_QWORD *)(v17 + 16);
    v18 = v20;
    if (v20)
    {

      *v19 = 0;
    }
  }
  v21 = *(_QWORD *)(a1 + 16) + 976 * v7;
  v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v22 + 1;
  return 1;
}

void re::SyncSendBuffer::objectsSent(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v5;
  unsigned __int16 v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t i;
  uint8_t *v12;
  uint64_t v13;
  uint64_t v14;
  int16x8_t v15;
  uint8_t *v16;
  uint64_t v17;
  uint64_t v18;
  int16x8_t v19;
  int16x8_t v20;
  uint8_t *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned __int16 v38;
  uint64_t v39;
  int v40;
  re::SyncObject *v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned __int16 v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint8_t buf[4];
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  char *v56;
  _WORD v57[216];
  uint64_t v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = a2;
    v49 = a2 + 24 * a3;
    v50 = (_QWORD *)(a1 + 112);
    v7 = a4 + 1;
    v8 = a4 & 0x1F;
    while (1)
    {
      v9 = re::SyncObject::latestStateHandle(*(re::SyncObject **)v5);
      if (v9 == -1)
      {
        v27 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          v28 = *(_QWORD *)(*(_QWORD *)v5 + 24);
          v29 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)v5 + 88) + 16);
          v30 = v29[4];
          v31 = v29[6];
          v32 = (char *)v29[7];
          v33 = (char *)v29 + 49;
          if ((v31 & 1) != 0)
            v33 = v32;
          *(_DWORD *)buf = 134218498;
          v52 = v28;
          v53 = 2048;
          v54 = v30;
          v55 = 2080;
          v56 = v33;
          _os_log_error_impl(&dword_21C69B000, v27, OS_LOG_TYPE_ERROR, "Sync object without snapshot among sent snapshot entries (id: %llu, type: %llu[%s]).", buf, 0x20u);
        }
        goto LABEL_33;
      }
      v10 = v9;
      for (i = 0; i != 512; i += 16)
      {
        v12 = &buf[i];
        *((_WORD *)v12 + 4) = 0;
        v12[10] = 0;
        *((_WORD *)v12 + 6) = 0;
      }
      v13 = 0;
      v14 = 0;
      v57[48] = 32;
      v15.i64[0] = 0x10001000100010;
      v15.i64[1] = 0x10001000100010;
      do
      {
        *((_BYTE *)&v57[32] + v14) = 0;
        v57[v14] = v14;
        v16 = &buf[v13];
        *((_WORD *)v16 + 6) = 0;
        *(_QWORD *)v16 = 0;
        *(_DWORD *)(v16 + 7) = 0;
        ++v14;
        v13 += 16;
      }
      while (v14 != 32);
      v57[212] = 64;
      v17 = 744;
      v18 = 872;
      v19 = (int16x8_t)xmmword_21C7026C0;
      v20 = (int16x8_t)xmmword_21C7026B0;
      do
      {
        *(_OWORD *)&buf[v18] = 0uLL;
        v21 = &buf[v17];
        *(int16x8_t *)v21 = v19;
        *((int16x8_t *)v21 + 1) = v20;
        v19 = vaddq_s16(v19, v15);
        v20 = vaddq_s16(v20, v15);
        v18 += 16;
        v17 += 32;
      }
      while (v17 != 872);
      v58 = 0;
      v22 = 0xBF58476D1CE4E5B9 * (*(_QWORD *)v5 ^ (*(_QWORD *)v5 >> 30));
      v23 = (0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) ^ ((0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) >> 31);
      if (!*v50)
        break;
      v24 = v23 % *(unsigned int *)(a1 + 136);
      v25 = *(unsigned int *)(*(_QWORD *)(a1 + 120) + 4 * v24);
      if ((_DWORD)v25 == 0x7FFFFFFF)
        goto LABEL_21;
      v26 = *(_QWORD *)(a1 + 128);
      while (*(_QWORD *)(v26 + 976 * v25 + 16) != *(_QWORD *)v5)
      {
        LODWORD(v25) = *(_DWORD *)(v26 + 976 * v25 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v25 == 0x7FFFFFFF)
          goto LABEL_21;
      }
      v35 = v26 + 976 * v25;
LABEL_23:
      v36 = v35 + 24;
      *(_QWORD *)(v35 + 968) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 296) + 32))(*(_QWORD *)(a1 + 296));
      v37 = *(unsigned __int16 *)(v36 + 608);
      if ((v37 > a4 || a4 - v37 >= 0x8000) && (v37 <= a4 || v37 - a4 < 0x8000))
      {
        v43 = v37 - 32;
        v44 = (unsigned __int16)(v37 - 32);
        if (v44 <= a4 && a4 - (unsigned __int16)v43 < 0x8000)
          goto LABEL_30;
        v45 = (v44 - a4) >> 15;
        if (a4 < (unsigned __int16)v43 && v45 != 0)
          goto LABEL_30;
        v47 = v37 - (v37 < 0x20);
        do
        {
          *(_BYTE *)(v36 + 576 + (v43 & 0x1F)) = 0;
          v48 = v36 + 16 * (v43 & 0x1F);
          *(_WORD *)(v48 + 12) = 0;
          *(_QWORD *)v48 = 0;
          *(_DWORD *)(v48 + 7) = 0;
          ++v43;
        }
        while ((unsigned __int16)v43 != v47);
      }
      else
      {
        v38 = v7 - (v37 > v7);
        if (v37 != v38)
        {
          do
          {
            *(_BYTE *)(v36 + 576 + (v37 & 0x1F)) = 0;
            v39 = v36 + 16 * (v37 & 0x1F);
            *(_WORD *)(v39 + 12) = 0;
            *(_QWORD *)v39 = 0;
            *(_DWORD *)(v39 + 7) = 0;
            ++v37;
          }
          while ((unsigned __int16)v37 != v38);
        }
      }
      *(_WORD *)(v36 + 608) = v7;
LABEL_30:
      LOBYTE(v40) = 1;
      *(_BYTE *)(v36 + v8 + 576) = 1;
      *(_WORD *)(v36 + 2 * v8 + 512) = a4;
      v41 = *(re::SyncObject **)v5;
      if ((*(_BYTE *)(*(_QWORD *)v5 + 128) & 4) == 0)
        v40 = (*(unsigned __int8 *)(v5 + 16) >> 1) & 1;
      v42 = v36 + 16 * v8;
      *(_BYTE *)(v42 + 9) = v40;
      *(_QWORD *)v42 = v10;
      *(_WORD *)(v42 + 12) = *((_WORD *)v41 + 88);
LABEL_33:
      v5 += 24;
      if (v5 == v49)
        return;
    }
    LODWORD(v24) = 0;
LABEL_21:
    v34 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove((uint64_t)v50, v24, v23, (uint64_t *)v5, (uint64_t)buf);
    ++*(_DWORD *)(a1 + 152);
    v35 = *(_QWORD *)(a1 + 128) + 976 * v34;
    goto LABEL_23;
  }
}

uint64_t re::SyncSendBuffer::resetAcks(uint64_t a1, uint64_t *a2)
{
  id WeakRetained;
  void *v5;
  uint64_t i;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int16x8_t v11;
  int16x8_t v12;
  uint64_t v13;
  uint64_t v14;
  int16x8_t v15;
  char *v16;
  char v18[608];
  __int16 v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 288));
  if (WeakRetained)
  {
    v5 = WeakRetained;
    re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)WeakRetained + 16, a2);

  }
  for (i = 0; i != 512; i += 16)
  {
    v7 = &v18[i];
    *((_WORD *)v7 + 4) = 0;
    v7[10] = 0;
    *((_WORD *)v7 + 6) = 0;
  }
  v8 = 0;
  v9 = 0;
  v19 = 32;
  do
  {
    v18[v9 + 576] = 0;
    *(_WORD *)&v18[2 * v9 + 512] = v9;
    v10 = &v18[v8];
    *((_WORD *)v10 + 6) = 0;
    *(_QWORD *)v10 = 0;
    *(_DWORD *)(v10 + 7) = 0;
    ++v9;
    v8 += 16;
  }
  while (v9 != 32);
  v20 = 64;
  v11 = (int16x8_t)xmmword_21C7026B0;
  v12 = (int16x8_t)xmmword_21C7026C0;
  v13 = 872;
  v14 = 744;
  v15.i64[0] = 0x10001000100010;
  v15.i64[1] = 0x10001000100010;
  do
  {
    *(_OWORD *)&v18[v13] = 0uLL;
    v16 = &v18[v14];
    *(int16x8_t *)v16 = v12;
    *((int16x8_t *)v16 + 1) = v11;
    v12 = vaddq_s16(v12, v15);
    v11 = vaddq_s16(v11, v15);
    v13 += 16;
    v14 += 32;
  }
  while (v14 != 872);
  v21 = 0;
  return re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(a1 + 112, a2, v18);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, char *__src)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_10;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_10:
    v25 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, (uint64_t)__src);
    ++*(_DWORD *)(a1 + 40);
    v24 = *(_QWORD *)(a1 + 16) + 976 * v25;
    return v24 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 976 * v10 + 16) != v6)
  {
    v12 = *(_DWORD *)(v11 + 976 * v10 + 8);
    v10 = v12 & 0x7FFFFFFF;
    if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF)
      goto LABEL_10;
  }
  v13 = v11 + 976 * v10;
  v14 = v13 + 24;
  if ((char *)(v13 + 24) != __src)
  {
    memmove((void *)(v13 + 24), __src, 0x1FEuLL);
    v15 = *((_OWORD *)__src + 35);
    v17 = *((_OWORD *)__src + 32);
    v16 = *((_OWORD *)__src + 33);
    *(_OWORD *)(v14 + 544) = *((_OWORD *)__src + 34);
    *(_OWORD *)(v14 + 560) = v15;
    *(_OWORD *)(v14 + 512) = v17;
    *(_OWORD *)(v14 + 528) = v16;
    v18 = *((_OWORD *)__src + 37);
    *(_OWORD *)(v14 + 576) = *((_OWORD *)__src + 36);
    *(_OWORD *)(v14 + 592) = v18;
    *(_WORD *)(v14 + 608) = *((_WORD *)__src + 304);
    v19 = (_OWORD *)(v11 + 976 * v10);
    memmove(v19 + 40, __src + 616, 0x80uLL);
    memmove(v19 + 48, __src + 744, 0x80uLL);
    v20 = *(_OWORD *)(__src + 920);
    v22 = *(_OWORD *)(__src + 872);
    v21 = *(_OWORD *)(__src + 888);
    v19[58] = *(_OWORD *)(__src + 904);
    v19[59] = v20;
    v19[56] = v22;
    v19[57] = v21;
  }
  v23 = v11 + 976 * v10;
  *(_WORD *)(v23 + 960) = *((_WORD *)__src + 468);
  *(_QWORD *)(v23 + 968) = *((_QWORD *)__src + 118);
  ++*(_DWORD *)(a1 + 40);
  v24 = *(_QWORD *)(a1 + 16) + 976 * v10;
  return v24 + 24;
}

uint64_t re::SyncSendBuffer::addAck(uint64_t a1, re::SyncObject **a2)
{
  id WeakRetained;
  void *v5;
  uint64_t v6;
  unint64_t v7;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 288));
  if (WeakRetained)
  {
    v5 = WeakRetained;
    v6 = (uint64_t)WeakRetained - 8;
    v7 = re::SyncObject::latestStateHandle(*a2);
    re::SyncAckedStateBuffer::addAcked(v6, (uint64_t *)a2, v7, *((unsigned __int16 *)*a2 + 88));

  }
  return re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(a1 + 112, (uint64_t *)a2);
}

void re::SyncSendBuffer::~SyncSendBuffer(re::SyncSendBuffer *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24E071BA8;
  v2 = *((_QWORD *)this + 37);
  if (v2)
  {

    *((_QWORD *)this + 37) = 0;
  }
  objc_destroyWeak((id *)this + 36);
  *((_QWORD *)this + 36) = 0;
  objc_destroyWeak((id *)this + 35);
  *((_QWORD *)this + 35) = 0;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 240);
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 20);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 14);
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 72);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24E071BA8;
  v2 = *((_QWORD *)this + 37);
  if (v2)
  {

    *((_QWORD *)this + 37) = 0;
  }
  objc_destroyWeak((id *)this + 36);
  *((_QWORD *)this + 36) = 0;
  objc_destroyWeak((id *)this + 35);
  *((_QWORD *)this + 35) = 0;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 240);
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 20);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 14);
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 72);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

void re::HashSetBase<re::SyncObject *,re::SyncObject *,re::internal::ValueAsKey<re::SyncObject *>,re::Hash<re::SyncObject *>,re::EqualTo<re::SyncObject *>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  int v8;
  int v9;
  signed int v10;
  uint64_t v11;
  BOOL v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  signed int v22;
  _BYTE v23[44];

  v7 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
    v7 = *(unsigned int *)(a1 + 32);
    v8 = v7;
    if ((_DWORD)v7 == *(_DWORD *)(a1 + 24))
    {
      v9 = *(_DWORD *)(a1 + 28);
      v10 = 2 * v9;
      v11 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v10)
          v12 = (_DWORD)v7 == v10;
        else
          v12 = 1;
        if (!v12 && (v9 & 0x80000000) == 0)
        {
          memset(v23, 0, 36);
          *(_QWORD *)&v23[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v23, v11, v10);
          v13 = *(_OWORD *)v23;
          *(_OWORD *)v23 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v13;
          v14 = *(_QWORD *)&v23[16];
          v15 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v23[16] = v15;
          *(_QWORD *)(a1 + 16) = v14;
          v17 = *(_OWORD *)&v23[24];
          *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
          v16 = *(_DWORD *)&v23[32];
          *(_OWORD *)(a1 + 24) = v17;
          v18 = v16;
          if (v16)
          {
            v19 = v15 + 16;
            do
            {
              if ((*(_DWORD *)(v19 - 8) & 0x80000000) != 0)
                re::HashSetBase<re::SyncObject *,re::SyncObject *,re::internal::ValueAsKey<re::SyncObject *>,re::Hash<re::SyncObject *>,re::EqualTo<re::SyncObject *>,true,false>::addAsMove(a1, *(_QWORD *)(v19 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v19 - 16), v19);
              v19 += 24;
              --v18;
            }
            while (v18);
          }
          re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)v23);
        }
      }
      else
      {
        if (v10)
          v22 = v10;
        else
          v22 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    v20 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v20 + 24 * v7 + 8);
  }
  else
  {
    v20 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v20 + 24 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v20 + 24 * v7 + 8) = v21 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 16) = *a4;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
}

_QWORD *re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          v2 = 24 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 24 * v9;
        v11 = v7;
        do
        {
          *v11 = *(_QWORD *)v8;
          *(_QWORD *)v8 = 0;
          *(_OWORD *)(v11 + 1) = *(_OWORD *)(v8 + 8);
          if (*(_QWORD *)v8)
          {

            *(_QWORD *)v8 = 0;
          }
          v8 += 24;
          v11 += 3;
          v10 -= 24;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _BYTE v43[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v43, 0, 36);
          *(_QWORD *)&v43[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v43, v13, v12);
          v15 = *(_OWORD *)v43;
          *(_OWORD *)v43 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v43[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v43[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v43[24];
          *(_OWORD *)&v43[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v43[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21, v21 + 8);
              v21 += 976;
              --v20;
            }
            while (v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v43);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 976 * v9 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 976 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  v25 = 976 * v9;
  *(_DWORD *)(v22 + v25 + 8) = v23 | 0x80000000;
  v26 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v25 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v25 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v25) = a3;
  v27 = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v25 + 16) = *a4;
  if (v27)
    v28 = (id)(v27 + 8);
  v29 = 0;
  v30 = *(_QWORD *)(a1 + 16);
  v31 = v30 + 976 * v9;
  v32 = v31 + 24;
  do
  {
    v33 = v31 + v29;
    *(_WORD *)(v33 + 32) = 0;
    *(_BYTE *)(v33 + 34) = 0;
    *(_WORD *)(v33 + 36) = 0;
    v29 += 16;
  }
  while (v29 != 512);
  memmove((void *)(v31 + 24), (const void *)a5, 0x1FEuLL);
  v34 = *(_OWORD *)(a5 + 560);
  v36 = *(_OWORD *)(a5 + 512);
  v35 = *(_OWORD *)(a5 + 528);
  *(_OWORD *)(v32 + 544) = *(_OWORD *)(a5 + 544);
  *(_OWORD *)(v32 + 560) = v34;
  *(_OWORD *)(v32 + 512) = v36;
  *(_OWORD *)(v32 + 528) = v35;
  v37 = *(_OWORD *)(a5 + 592);
  *(_OWORD *)(v32 + 576) = *(_OWORD *)(a5 + 576);
  *(_OWORD *)(v32 + 592) = v37;
  *(_WORD *)(v32 + 608) = *(_WORD *)(a5 + 608);
  v38 = v30 + 976 * v9;
  memmove((void *)(v38 + 640), (const void *)(a5 + 616), 0x80uLL);
  memmove((void *)(v38 + 768), (const void *)(a5 + 744), 0x80uLL);
  v39 = *(_OWORD *)(a5 + 872);
  v40 = *(_OWORD *)(a5 + 888);
  v41 = *(_OWORD *)(a5 + 920);
  *(_OWORD *)(v38 + 928) = *(_OWORD *)(a5 + 904);
  *(_OWORD *)(v38 + 944) = v41;
  *(_OWORD *)(v38 + 896) = v39;
  *(_OWORD *)(v38 + 912) = v40;
  *(_WORD *)(v38 + 960) = *(_WORD *)(a5 + 936);
  *(_QWORD *)(v38 + 968) = *(_QWORD *)(a5 + 944);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v26) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 976 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 976;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::SyncUnpacker::unpackCommit(uint64_t **this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  _QWORD v14[2];
  uint64_t v15;
  uint64_t v16;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;

  if ((*(_BYTE *)(a4 + 24) & 0x20) == 0)
    return re::SyncUnpacker::parseCommit(this, (re::BitReader *)a2, a3, a4);
  v9 = *(unsigned int *)(a2 + 16);
  if (*(_BYTE *)(a2 + 12))
    v10 = 0;
  else
    v10 = *(_QWORD *)a2 + v9;
  v11 = (*(_DWORD *)(a2 + 8) - v9);
  v14[0] = v10;
  v14[1] = v11;
  v17 = -1;
  v18 = 0;
  v19 = 0;
  v21 = 0;
  v15 = v10;
  v16 = v10 + v11;
  result = re::SyncUnpacker::parseCommit(this, (re::snapshot::DecoderOPACK *)v14, a3, (os_log_t)a4);
  if (!*(_BYTE *)(a2 + 12))
  {
    v12 = v15 - LODWORD(v14[0]);
    *(_QWORD *)(a2 + 24) = 0;
    v13 = *(_DWORD *)(a2 + 16) + v12;
    *(_QWORD *)(a2 + 16) = v13;
    if (v13 > *(_DWORD *)(a2 + 8))
      *(_BYTE *)(a2 + 12) = 1;
  }
  return result;
}

uint64_t re::SyncUnpacker::parseCommit(uint64_t **a1, re::snapshot::DecoderOPACK *this, uint64_t a3, os_log_t a4)
{
  re *v8;
  re *v9;
  re *Integer;
  re *v11;
  re *v12;
  unint64_t v13;
  BOOL v14;
  unsigned __int8 v15;
  int v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  unsigned __int8 *v24;
  int v25;
  unsigned __int16 v26;
  unsigned __int8 *v27;
  int v28;
  int v29;
  re *v30;
  uint64_t *v31;
  uint64_t v32;
  void (*v33)(void);
  re::SyncOpaqueTypeInfo *v34;
  uint64_t *v35;
  re *v36;
  uint64_t v37;
  NSObject *v38;
  re::SyncObjectStore *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t shouldAcceptUpdate;
  re::SyncObjectTypedStore **Object;
  re::SyncObject *v44;
  uint64_t Baseline;
  uint64_t v46;
  int v47;
  NSObject *v48;
  uint64_t *v49;
  _BOOL8 v50;
  NSObject *v51;
  uint64_t v52;
  int v53;
  re::SyncObject *v54;
  uint64_t *v55;
  unsigned int v56;
  __int128 v57;
  BOOL v58;
  uint64_t v59;
  re *OldestState;
  unsigned __int16 v61;
  void (***v62)(re::DynamicBitWriter *__hidden);
  uint64_t v63;
  void (***v64)(re::DynamicBitWriter *__hidden);
  int v65;
  uint64_t v66;
  char v67;
  unint64_t v68;
  unint64_t v69;
  char v70;
  NSObject *v71;
  uint64_t v72;
  NSObject *v73;
  uint64_t v74;
  NSObject *v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t *v82;
  _BOOL8 v83;
  NSObject *v84;
  uint64_t v85;
  NSObject *v86;
  const char *v87;
  NSObject *v88;
  uint64_t v89;
  uint64_t v90;
  uint32_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  NSObject *v96;
  NSObject *v97;
  uint64_t v98;
  NSObject *v99;
  int v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  re *v104;
  NSObject *v105;
  uint64_t v106;
  char *v107;
  char *v108;
  unint64_t v109;
  uint64_t v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  __int128 v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t *v117;
  uint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  NSObject *v122;
  uint64_t result;
  const char *v124;
  NSObject *v125;
  const char *v126;
  int log;
  NSObject *loga;
  os_log_t v129;
  NSObject *v130;
  unsigned __int16 v131;
  char v132;
  _anonymous_namespace_ *v133;
  unint64_t v134;
  re::SyncObject *v135;
  re::SyncObject *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  re::SyncOpaqueTypeInfo *v141;
  __int128 v142;
  unint64_t v143[2];
  unsigned __int16 v144[2];
  unsigned __int16 v145;
  unsigned __int8 v146;
  uint64_t v147;
  int v148;
  char v149;
  uint64_t v150;
  uint64_t v151;
  void (**v152)(re::DynamicBitWriter *__hidden);
  __int128 v153;
  __int128 v154;
  _QWORD v155[3];
  int v156;
  uint64_t v157;
  _BYTE buf[24];
  _BYTE v159[24];
  uint64_t v160;
  uint64_t v161;
  int v162;
  uint64_t v163;
  uint64_t v164;

  v164 = *MEMORY[0x24BDAC8D0];
  v8 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
  if ((v8 & 1) == 0)
  {
    v122 = *re::networkLogObjects(v8);
    result = os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      *(_WORD *)buf = 0;
      v124 = "Commit doesn't begin with an object header";
      goto LABEL_219;
    }
    return result;
  }
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, (_BYTE *)a3);
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned long long>((uint64_t)this, (_QWORD *)(a3 + 16));
  re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
  *(_QWORD *)(a3 + 8) = a1[2];
  v134 = 0;
  v9 = (re *)re::snapshot::DecoderOPACK::beginDictionary(this, &v134);
  if ((_DWORD)v9)
  {
    v133 = (_anonymous_namespace_ *)(a3 + 32);
    while (1)
    {
      if (re::snapshot::DecoderOPACK::endDictionary(this, &v134))
        return 2;
      Integer = (re *)re::snapshot::DecoderOPACK::readInteger(this, 0);
      v11 = Integer;
      if ((_DWORD)Integer == -1)
      {
        v125 = *re::networkLogObjects(Integer);
        shouldAcceptUpdate = os_log_type_enabled(v125, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)shouldAcceptUpdate)
          goto LABEL_217;
        *(_WORD *)buf = 0;
        v126 = "Expected object short id";
        goto LABEL_222;
      }
      v12 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
      if ((v12 & 1) == 0)
      {
        v125 = *re::networkLogObjects(v12);
        shouldAcceptUpdate = os_log_type_enabled(v125, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)shouldAcceptUpdate)
          goto LABEL_217;
        *(_WORD *)buf = 0;
        v126 = "Expected object header";
        goto LABEL_222;
      }
      v146 = 0;
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, &v146);
      v145 = 0;
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>((uint64_t)this, &v145);
      *(_QWORD *)&v142 = 0;
      WORD4(v142) = 0;
      LOBYTE(v143[0]) = 0;
      v143[1] = 0;
      *(_DWORD *)v144 = 0x10000;
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,re::SyncOwnershipInfo>((uint64_t)this, (uint64_t)&v142);
      v13 = v143[1];
      if (!v143[1])
      {
        v13 = (unint64_t)a1[2];
        v143[1] = v13;
      }
      v14 = (uint64_t *)v13 == a1[3] || *((_BYTE *)a1 + 120) && (Class)v13 == a4[1].isa;
      LOBYTE(v144[1]) = v14;
      v15 = v146;
      v141 = (re::SyncOpaqueTypeInfo *)-1;
      v16 = v146 & 5;
      if (v16)
      {
        if (re::snapshot::DecoderOPACK::advanceTo<5>((uint64_t)this))
        {
          v17 = re::snapshot::DecoderOPACK::readInteger(this, 0);
          v18 = (unsigned __int8 *)*((_QWORD *)this + 2);
          if ((unint64_t)v18 >= *((_QWORD *)this + 3) || (v19 = *v18, v19 == 3))
          {
            v20 = 0x7FFFFFFF;
          }
          else if ((v19 - 7) > 0x28)
          {
            v20 = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
          }
          else
          {
            *((_QWORD *)this + 2) = v18 + 1;
            v20 = v19 - 8;
          }
          *((_DWORD *)this + 8) = v20;
        }
        else
        {
          v17 = 0;
        }
        re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<6,unsigned long long>((uint64_t)this, &v141);
      }
      else
      {
        v17 = 0;
      }
      v21 = *((_DWORD *)this + 8);
      if (v21 <= 6)
        break;
LABEL_34:
      if (v21 == 7)
      {
        v26 = re::snapshot::DecoderOPACK::readInteger(this, 0);
        v27 = (unsigned __int8 *)*((_QWORD *)this + 2);
        if ((unint64_t)v27 < *((_QWORD *)this + 3))
        {
          v28 = *v27;
          if (v28 != 3)
          {
            if ((v28 - 7) > 0x28)
            {
              v29 = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
            }
            else
            {
              *((_QWORD *)this + 2) = v27 + 1;
              v29 = v28 - 8;
            }
            goto LABEL_41;
          }
        }
LABEL_40:
        v29 = 0x7FFFFFFF;
LABEL_41:
        *((_DWORD *)this + 8) = v29;
        goto LABEL_43;
      }
      v26 = 0;
LABEL_43:
      v139 = -1;
      v140 = 0;
      if ((v15 & 1) != 0)
      {
        re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<8,unsigned long long>((uint64_t)this, &v139);
        re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<9,unsigned long long>((uint64_t)this, &v140);
      }
      v137 = 0;
      v138 = 0;
      v30 = (re *)re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<11,re::Slice<unsigned char>>((uint64_t)this, &v137);
      if (*((_QWORD *)this + 3) == *((_QWORD *)this + 2))
      {
        v125 = *re::networkLogObjects(v30);
        shouldAcceptUpdate = os_log_type_enabled(v125, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)shouldAcceptUpdate)
          goto LABEL_217;
        *(_WORD *)buf = 0;
        v126 = "Failed to unpack sync object.";
LABEL_222:
        _os_log_error_impl(&dword_21C69B000, v125, OS_LOG_TYPE_ERROR, v126, buf, 2u);
LABEL_217:
        v122 = *re::networkLogObjects((re *)shouldAcceptUpdate);
        result = os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          *(_WORD *)buf = 0;
          v124 = "Failure reading object in commit";
LABEL_219:
          _os_log_error_impl(&dword_21C69B000, v122, OS_LOG_TYPE_ERROR, v124, buf, 2u);
          return 0;
        }
        return result;
      }
      re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
      v31 = *a1;
      if (v16)
      {
        v32 = *v31;
        if ((v15 & 4) != 0)
          v33 = *(void (**)(void))(v32 + 64);
        else
          v33 = *(void (**)(void))(v32 + 48);
        v33();
      }
      else
      {
        v17 = (*(uint64_t (**)(uint64_t *, re *))(*v31 + 56))(v31, v11);
        v141 = v34;
      }
      v35 = a1[1];
      *(_QWORD *)buf = v141;
      v36 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v35 + 63), (uint64_t *)buf);
      if (!v36 || (v37 = *(_QWORD *)(*(_QWORD *)v36 + 16)) == 0)
      {
        v38 = *re::networkLogObjects(v36);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v141;
          _os_log_impl(&dword_21C69B000, v38, OS_LOG_TYPE_DEFAULT, "Unknown object typeID=%llu. Assuming opaque type.", buf, 0xCu);
        }
        v39 = (re::SyncObjectStore *)a1[1];
        re::SyncOpaqueTypeInfo::make(v141, (uint64_t)buf);
        re::SyncObjectStore::addType(v39, (const re::SyncObjectTypeInfo *)buf);
        re::SyncObjectTypeInfo::~SyncObjectTypeInfo((re::SyncObjectTypeInfo *)buf);
        v40 = a1[1];
        *(_QWORD *)buf = v141;
        v41 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v40 + 63), (uint64_t *)buf);
        if (v41)
          v37 = *(_QWORD *)(*(_QWORD *)v41 + 16);
        else
          v37 = 0;
      }
      shouldAcceptUpdate = *(_QWORD *)(v37 + 136);
      if (!shouldAcceptUpdate
        || (shouldAcceptUpdate = (*(uint64_t (**)(uint64_t, os_log_t))(shouldAcceptUpdate + 16))(shouldAcceptUpdate, a4), (_DWORD)shouldAcceptUpdate))
      {
        if (!v17)
        {
          v48 = *re::networkLogObjects((re *)shouldAcceptUpdate);
          v47 = 2;
          shouldAcceptUpdate = os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)shouldAcceptUpdate)
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = (_DWORD)v11;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v146;
            _os_log_debug_impl(&dword_21C69B000, v48, OS_LOG_TYPE_DEBUG, "Cannot find guid for object with id=%d, flags=0x%02X. Skipping update.", buf, 0xEu);
          }
          goto LABEL_201;
        }
        Object = re::SyncObjectStore::findObject((re::SyncObjectStore *)a1[1], (uint64_t)v141, v17, (re::SyncObjectTypedStore ***)&v136);
        v44 = v136;
        if (v136)
        {
          if ((v15 & 1) != 0)
          {
            v46 = 0;
LABEL_75:
            v53 = 1;
          }
          else
          {
            Baseline = re::SyncObject::findBaseline(v136, v26, (uint64_t)a1[2]);
            if (Baseline)
            {
              v46 = Baseline;
              goto LABEL_75;
            }
            v73 = *re::networkLogObjects(0);
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
            {
              if ((*(_BYTE *)(v37 + 48) & 1) != 0)
                v74 = *(_QWORD *)(v37 + 56);
              else
                v74 = v37 + 49;
              *(_DWORD *)buf = 134218498;
              *(_QWORD *)&buf[4] = v17;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v74;
              *(_WORD *)&buf[22] = 2048;
              *(_QWORD *)v159 = v141;
              _os_log_impl(&dword_21C69B000, v73, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing baseline for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
            }
            if ((v15 & 4) == 0)
            {
              *(_QWORD *)buf = v141;
              *(_QWORD *)&buf[8] = v17;
              re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)(a1 + 10), (__n128 *)buf);
            }
            v53 = 0;
            v46 = 0;
          }
          v54 = v44;
LABEL_77:
          shouldAcceptUpdate = re::SyncObject::shouldAcceptUpdate(v54, v143[1], v144[0]);
          if (*((_BYTE *)a1 + 121) || (_DWORD)shouldAcceptUpdate)
          {
            if ((_DWORD)shouldAcceptUpdate
              && (v55 = a1[3],
                  v56 = *((unsigned __int16 *)v54 + 84),
                  v57 = *(_OWORD *)v143,
                  *(_OWORD *)((char *)v54 + 136) = v142,
                  *(_OWORD *)((char *)v54 + 152) = v57,
                  *((_DWORD *)v54 + 42) = *(_DWORD *)v144,
                  *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v54 + 11) + 16) + 73))
              && (v56 < v144[0] || ((uint64_t *)v142 == v55 ? (v58 = (_QWORD)v142 == 0) : (v58 = 1), !v58)))
            {
              v132 = 4;
              if (!v53)
              {
LABEL_99:
                v67 = 0;
LABEL_100:
                if (v140 && !*((_QWORD *)v54 + 10))
                {
                  *(_QWORD *)buf = v139;
                  *(_QWORD *)&buf[8] = v140;
                  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace((uint64_t)(a1 + 4), (uint64_t *)&v136, buf);
                  v54 = v136;
                }
                v68 = re::SyncObject::latestStateHandle(v54);
                if (v68 != -1)
                {
                  v69 = v68;
                  memset(buf, 0, 17);
                  re::SharedPtr<re::SyncObject>::reset((uint64_t *)buf, (uint64_t)v136);
                  *(_QWORD *)&buf[8] = v69;
                  v70 = v132 | v67 | buf[16] & 0xF2 | (v44 == 0);
                  buf[16] = v70;
                  if ((v15 & 4) != 0)
                  {
                    *((_BYTE *)v136 + 128) |= 4u;
                    buf[16] = v70 | 2;
                  }
                  shouldAcceptUpdate = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v133, (uint64_t)buf);
                  if (*(_QWORD *)buf)

LABEL_145:
                  v47 = 2;
LABEL_199:
                  if (v136)

                  goto LABEL_201;
                }
                v75 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
                shouldAcceptUpdate = os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
                if ((_DWORD)shouldAcceptUpdate)
                {
                  v76 = *((_QWORD *)v136 + 3);
                  v77 = *(_QWORD **)(*((_QWORD *)v136 + 11) + 16);
                  v78 = v77[4];
                  v79 = v77[6];
                  v80 = (char *)v77[7];
                  v81 = (char *)v77 + 49;
                  if ((v79 & 1) != 0)
                    v81 = v80;
                  *(_DWORD *)buf = 134218498;
                  *(_QWORD *)&buf[4] = v76;
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v78;
                  *(_WORD *)&buf[22] = 2080;
                  *(_QWORD *)v159 = v81;
                  _os_log_error_impl(&dword_21C69B000, v75, OS_LOG_TYPE_ERROR, "Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).", buf, 0x20u);
                }
LABEL_198:
                v47 = 0;
                goto LABEL_199;
              }
            }
            else
            {
              v132 = 0;
              if (!v53)
                goto LABEL_99;
            }
            if (!re::SyncObject::isStateDataChanged(v54, v145, (uint64_t)a1[2]))
              goto LABEL_99;
            v129 = a4;
            v131 = v145;
            v59 = v137;
            log = v138;
            DWORD2(v153) = 0;
            BYTE12(v153) = 0;
            v154 = 0uLL;
            v152 = &off_24E072690;
            *(_QWORD *)&v153 = 0;
            v157 = 0;
            v156 = 0;
            memset(v155, 0, sizeof(v155));
            if (*((_QWORD *)v54 + 9) - *((_QWORD *)v54 + 8) == *((_QWORD *)v54 + 6)
              && (OldestState = (re *)re::SyncObject::getOldestState(v54), OldestState == (re *)v46))
            {
              v96 = *re::networkLogObjects(OldestState);
              if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_21C69B000, v96, OS_LOG_TYPE_INFO, "Baseline would be invalidated by new state! Will read into temp location.", buf, 2u);
              }
              v62 = &v152;
              v61 = v131;
            }
            else
            {
              v61 = v131;
              v62 = (void (***)(re::DynamicBitWriter *__hidden))re::SyncObject::addState(v54, v131, (uint64_t)a1[2]);
            }
            *((_WORD *)v54 + 88) = v61;
            v147 = v59;
            v148 = log;
            v149 = 0;
            v150 = 0;
            v151 = 0;
            if (v46)
            {
              v63 = *(_QWORD *)(v37 + 104);
              v64 = v62;
              a4 = v129;
              if (v63)
              {
                v65 = *(_DWORD *)(v46 + 24);
                if (*(_DWORD *)(v46 + 28))
                  ++v65;
                *(_QWORD *)buf = *(_QWORD *)(v46 + 8);
                *(_DWORD *)&buf[8] = v65;
                buf[12] = 0;
                *(_QWORD *)&buf[16] = 0;
                *(_QWORD *)v159 = 0;
                v66 = (*(uint64_t (**)(uint64_t, uint64_t *, _BYTE *, void (***)(re::DynamicBitWriter *__hidden), os_log_t))(v63 + 16))(v63, &v147, buf, v64, v129);
                if ((v66 & 1) != 0)
                  goto LABEL_169;
LABEL_162:
                if (v64 != &v152)
                {
                  v98 = *((_QWORD *)v54 + 9);
                  if (*((_QWORD *)v54 + 8) != v98)
                    *((_QWORD *)v54 + 9) = v98 - 1;
                }
                v99 = *re::networkLogObjects((re *)v66);
                if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
                {
                  v116 = *((_QWORD *)v54 + 3);
                  v117 = a1[2];
                  *(_DWORD *)buf = 134218240;
                  *(_QWORD *)&buf[4] = v116;
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v117;
                  _os_log_error_impl(&dword_21C69B000, v99, OS_LOG_TYPE_ERROR, "Failed to parse object data.(guid=%llu, peerID=%llu)", buf, 0x16u);
                }
                v100 = 0;
              }
              else
              {
                loga = *re::networkLogObjects(0);
                v66 = os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT);
                if ((_DWORD)v66)
                {
                  v92 = *((_QWORD *)v54 + 3);
                  v93 = *(_QWORD *)(v37 + 32);
                  if ((*(_QWORD *)(v37 + 48) & 1) != 0)
                    v94 = *(_QWORD *)(v37 + 56);
                  else
                    v94 = v37 + 49;
                  *(_DWORD *)buf = 134218498;
                  *(_QWORD *)&buf[4] = v92;
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v93;
                  *(_WORD *)&buf[22] = 2080;
                  *(_QWORD *)v159 = v94;
                  _os_log_impl(&dword_21C69B000, loga, OS_LOG_TYPE_DEFAULT, "Cannot parse state for syncobject %llu of type %llu(%s), readDeltaCb not available.", buf, 0x20u);
                }
                if (v64 == &v152 || (v95 = *((_QWORD *)v54 + 9), *((_QWORD *)v54 + 8) == v95))
                {
                  v64 = 0;
                }
                else
                {
                  v64 = 0;
                  *((_QWORD *)v54 + 9) = v95 - 1;
                }
LABEL_169:
                if (v148 != (_DWORD)v150)
                {
                  v130 = *re::networkLogObjects((re *)v66);
                  if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
                  {
                    v101 = "readDeltaCb";
                    if (!v46)
                      v101 = "readCb";
                    if ((*(_QWORD *)(v37 + 48) & 1) != 0)
                      v102 = *(_QWORD *)(v37 + 56);
                    else
                      v102 = v37 + 49;
                    v103 = *(_QWORD *)(v37 + 32);
                    *(_DWORD *)buf = 136315650;
                    *(_QWORD *)&buf[4] = v101;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = v102;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)v159 = v103;
                    _os_log_impl(&dword_21C69B000, v130, OS_LOG_TYPE_DEFAULT, "Read buffer is not fully consumed by %s of type %s: %llu", buf, 0x20u);
                  }
                }
                if (v64 == &v152)
                {
                  v109 = re::SyncObject::addState(v54, v131, (uint64_t)a1[2]);
                  v110 = *(_QWORD *)(v109 + 40);
                  v109 += 40;
                  v111 = *(_OWORD *)(v109 - 32);
                  v112 = *(_OWORD *)(v109 - 16);
                  *(_QWORD *)buf = &off_24E072690;
                  *(_QWORD *)&v159[16] = v110;
                  *(_QWORD *)v109 = 0;
                  v113 = *(_QWORD *)(v109 + 16);
                  v160 = *(_QWORD *)(v109 + 8);
                  *(_OWORD *)&buf[8] = v111;
                  *(_OWORD *)v159 = v112;
                  *(_QWORD *)(v109 + 8) = 0;
                  v161 = v113;
                  *(_QWORD *)(v109 + 16) = 0;
                  v163 = *(_QWORD *)(v109 + 32);
                  *(_QWORD *)(v109 + 32) = 0;
                  ++*(_DWORD *)(v109 + 24);
                  v162 = 1;
                  v114 = v154;
                  *(_OWORD *)(v109 - 32) = v153;
                  *(_OWORD *)(v109 - 16) = v114;
                  re::DynamicArray<unsigned char>::operator=(v109, (uint64_t)v155);
                  v153 = *(_OWORD *)&buf[8];
                  v154 = *(_OWORD *)v159;
                  re::DynamicArray<unsigned char>::operator=((uint64_t)v155, (uint64_t)&v159[16]);
                  if (*(_QWORD *)&v159[16])
                  {
                    if (v163)
                      (*(void (**)(void))(**(_QWORD **)&v159[16] + 40))();
                  }
                }
                v100 = 1;
              }
              v104 = (re *)v155[0];
              if (v155[0] && v157)
                v104 = (re *)(*(uint64_t (**)(void))(*(_QWORD *)v155[0] + 40))();
              if (v100)
              {
                v67 = 8;
                v54 = v136;
                goto LABEL_100;
              }
              v105 = *re::networkLogObjects(v104);
              shouldAcceptUpdate = os_log_type_enabled(v105, OS_LOG_TYPE_ERROR);
              if ((_DWORD)shouldAcceptUpdate)
              {
                if ((*(_BYTE *)(v37 + 48) & 1) != 0)
                  v115 = *(_QWORD *)(v37 + 56);
                else
                  v115 = v37 + 49;
                v118 = a1[2];
                *(_DWORD *)buf = 134218754;
                *(_QWORD *)&buf[4] = v17;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v141;
                *(_WORD *)&buf[22] = 2080;
                *(_QWORD *)v159 = v115;
                *(_WORD *)&v159[8] = 2048;
                *(_QWORD *)&v159[10] = v118;
                _os_log_error_impl(&dword_21C69B000, v105, OS_LOG_TYPE_ERROR, "Failed to parse object state.(guid=%llu, type=%llu(%s), peerID=%llu)", buf, 0x2Au);
                if (v44)
                  goto LABEL_198;
              }
              else if (v44)
              {
                goto LABEL_198;
              }
              v106 = (uint64_t)a1[1];
              v135 = v136;
              if (v136)
              {
                v107 = (char *)v136 + 8;
                v108 = (char *)v136 + 8;
                re::SyncObjectStore::removeObject(v106, (uint64_t *)&v135);

              }
              else
              {
                re::SyncObjectStore::removeObject(v106, (uint64_t *)&v135);
              }
              goto LABEL_198;
            }
            v90 = *(_QWORD *)(v37 + 96);
            v64 = v62;
            a4 = v129;
            if (v90)
            {
              v66 = (*(uint64_t (**)(uint64_t, uint64_t *, void (***)(re::DynamicBitWriter *__hidden), os_log_t))(v90 + 16))(v90, &v147, v62, v129);
              if ((_DWORD)v66)
                goto LABEL_169;
            }
            else
            {
              v97 = *re::networkLogObjects(0);
              v66 = os_log_type_enabled(v97, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v66)
              {
                v119 = *((_QWORD *)v54 + 3);
                v120 = *(_QWORD *)(v37 + 32);
                if ((*(_QWORD *)(v37 + 48) & 1) != 0)
                  v121 = *(_QWORD *)(v37 + 56);
                else
                  v121 = v37 + 49;
                *(_DWORD *)buf = 134218498;
                *(_QWORD *)&buf[4] = v119;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v120;
                *(_WORD *)&buf[22] = 2080;
                *(_QWORD *)v159 = v121;
                _os_log_error_impl(&dword_21C69B000, v97, OS_LOG_TYPE_ERROR, "Cannot parse state for syncobject %llu of type %llu(%s), readCb not available.", buf, 0x20u);
              }
            }
            goto LABEL_162;
          }
LABEL_126:
          v47 = 2;
          goto LABEL_199;
        }
        if ((v15 & 4) == 0)
        {
          v49 = a1[1];
          *(_QWORD *)buf = v17;
          *(_QWORD *)&buf[8] = v141;
          *(_QWORD *)&buf[16] = 0;
          v50 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v49 + 75), (uint64_t *)buf);
          if (v50)
          {
            v51 = *re::networkLogObjects((re *)v50);
            shouldAcceptUpdate = os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
            if (!(_DWORD)shouldAcceptUpdate)
              goto LABEL_126;
            if ((*(_BYTE *)(v37 + 48) & 1) != 0)
              v52 = *(_QWORD *)(v37 + 56);
            else
              v52 = v37 + 49;
            *(_DWORD *)buf = 134218498;
            *(_QWORD *)&buf[4] = v17;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v52;
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)v159 = v141;
            v86 = v51;
            v87 = "Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)";
LABEL_143:
            v91 = 32;
          }
          else
          {
            v82 = a1[1];
            *(_QWORD *)buf = v140;
            *(_QWORD *)&buf[8] = v139;
            *(_QWORD *)&buf[16] = 0;
            v83 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v82 + 75), (uint64_t *)buf);
            if (!v83)
            {
              if ((v15 & 1) != 0)
              {
                re::SyncObjectStore::createIncomingObject((re::SyncObjectStore *)a1[1], (const re::SyncOwnershipInfo *)&v142, (unint64_t)v141, v17, (uint64_t *)buf);
                v46 = 0;
                v54 = *(re::SyncObject **)buf;
                v136 = *(re::SyncObject **)buf;
                v53 = 1;
                goto LABEL_77;
              }
              v88 = *re::networkLogObjects((re *)v83);
              shouldAcceptUpdate = os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)shouldAcceptUpdate)
              {
                if ((*(_BYTE *)(v37 + 48) & 1) != 0)
                  v89 = *(_QWORD *)(v37 + 56);
                else
                  v89 = v37 + 49;
                *(_DWORD *)buf = 134218498;
                *(_QWORD *)&buf[4] = v17;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v89;
                *(_WORD *)&buf[22] = 2048;
                *(_QWORD *)v159 = v141;
                _os_log_impl(&dword_21C69B000, v88, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
                v47 = 1;
              }
              else
              {
                v47 = 1;
              }
              goto LABEL_199;
            }
            v84 = *re::networkLogObjects((re *)v83);
            shouldAcceptUpdate = os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT);
            if (!(_DWORD)shouldAcceptUpdate)
              goto LABEL_126;
            if ((*(_BYTE *)(v37 + 48) & 1) != 0)
              v85 = *(_QWORD *)(v37 + 56);
            else
              v85 = v37 + 49;
            *(_DWORD *)buf = 134218754;
            *(_QWORD *)&buf[4] = v17;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v85;
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)v159 = v141;
            *(_WORD *)&v159[8] = 2048;
            *(_QWORD *)&v159[10] = v140;
            v86 = v84;
            v87 = "Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu";
            v91 = 42;
          }
          _os_log_impl(&dword_21C69B000, v86, OS_LOG_TYPE_DEFAULT, v87, buf, v91);
          goto LABEL_145;
        }
        v71 = *re::networkLogObjects((re *)Object);
        shouldAcceptUpdate = os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT);
        if (!(_DWORD)shouldAcceptUpdate)
          goto LABEL_126;
        if ((*(_BYTE *)(v37 + 48) & 1) != 0)
          v72 = *(_QWORD *)(v37 + 56);
        else
          v72 = v37 + 49;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v17;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v72;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)v159 = v141;
        v86 = v71;
        v87 = "Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)";
        goto LABEL_143;
      }
      v47 = 2;
LABEL_201:
      if (!v47)
        goto LABEL_217;
    }
    while (1)
    {
      v22 = (unsigned __int8 *)*((_QWORD *)this + 2);
      if ((unint64_t)v22 >= *((_QWORD *)this + 3))
      {
        v23 = 0;
      }
      else
      {
        *((_QWORD *)this + 2) = v22 + 1;
        v23 = *v22;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)this, v23);
      v24 = (unsigned __int8 *)*((_QWORD *)this + 2);
      if ((unint64_t)v24 >= *((_QWORD *)this + 3))
        break;
      v25 = *v24;
      if (v25 == 3)
        break;
      if ((v25 - 7) > 0x28)
      {
        v21 = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
      }
      else
      {
        *((_QWORD *)this + 2) = v24 + 1;
        v21 = v25 - 8;
      }
      *((_DWORD *)this + 8) = v21;
      if (v21 >= 7)
        goto LABEL_34;
    }
    v26 = 0;
    goto LABEL_40;
  }
  v122 = *re::networkLogObjects(v9);
  result = os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    *(_WORD *)buf = 0;
    v124 = "Expected dictionary of entries";
    goto LABEL_219;
  }
  return result;
}

uint64_t re::SyncUnpacker::parseCommit(uint64_t **a1, re::BitReader *this, uint64_t a3, uint64_t a4)
{
  char v7;
  uint64_t *UInt32Bits;
  NSObject *v9;
  uint64_t v10;
  int v12;
  unsigned int v13;
  unsigned __int16 v14;
  uint64_t *v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  int v19;
  re::SyncOpaqueTypeInfo *v20;
  uint64_t v21;
  void (*v22)(void);
  unint64_t v23;
  uint64_t *v24;
  re *v25;
  uint64_t v26;
  NSObject *v27;
  re::SyncObjectStore *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  unsigned __int16 v32;
  NSObject *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  const re::SyncObjectTypeInfo *v37;
  unint64_t v38;
  unsigned __int8 v39;
  re::BitReader *v40;
  re::SyncObjectTypedStore **Object;
  int v42;
  re::SyncObject *v43;
  uint64_t Baseline;
  int v45;
  NSObject *v46;
  const re::SyncObjectTypeInfo *v47;
  unint64_t v48;
  unsigned __int8 v49;
  re::BitReader *v50;
  uint64_t *v51;
  _BOOL8 v52;
  NSObject *v53;
  const re::SyncObjectTypeInfo *v54;
  unint64_t v55;
  unsigned __int8 v56;
  re::BitReader *v57;
  uint64_t v58;
  NSObject *v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t *v63;
  unint64_t v64;
  _BOOL8 v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  const char *v69;
  NSObject *v70;
  const re::SyncObjectTypeInfo *v71;
  unint64_t v72;
  unsigned __int8 v73;
  re::BitReader *v74;
  uint64_t v75;
  _BOOL4 shouldAcceptUpdate;
  uint64_t *v77;
  unsigned int v78;
  __int128 v79;
  BOOL v80;
  re *OldestState;
  unsigned __int16 v82;
  int v83;
  uint64_t v84;
  _BOOL4 v85;
  NSObject *v86;
  int v87;
  re *v88;
  NSObject *v89;
  char v90;
  unint64_t v91;
  unint64_t v92;
  char v93;
  NSObject *v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  char *v100;
  int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  unsigned __int8 *v107;
  unsigned int v108;
  uint64_t v109;
  uint32_t v110;
  NSObject *v111;
  uint64_t v112;
  int v113;
  _QWORD *p_isa;
  uint64_t v115;
  uint64_t v116;
  void (***v117)(re::DynamicBitWriter *__hidden);
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  NSObject *v123;
  int v124;
  void (***v125)(re::DynamicBitWriter *__hidden);
  _BOOL4 v126;
  const char *v127;
  uint64_t v128;
  uint64_t v129;
  re *v130;
  NSObject *v131;
  uint64_t v132;
  char *v133;
  char *v134;
  unint64_t v135;
  uint64_t v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;
  __int128 v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t *v143;
  uint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  NSObject *v148;
  uint64_t v149;
  const char *v150;
  NSObject *v151;
  uint32_t v152;
  uint64_t v153;
  _BOOL4 v154;
  int v155;
  uint64_t v156;
  int v157;
  os_log_t log;
  NSObject *loga;
  os_log_t v160;
  NSObject *v161;
  uint64_t v162;
  char v163;
  _anonymous_namespace_ *v164;
  uint64_t v165;
  re::SyncObject *v166;
  unsigned __int16 v168;
  NSObject *v169;
  int v170;
  re::SyncObject *v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  uint64_t v176;
  __int128 v177;
  __int128 v178;
  unsigned __int16 v179[2];
  uint64_t v180;
  int v181;
  char v182;
  uint64_t v183;
  uint64_t v184;
  void (**v185)(re::DynamicBitWriter *__hidden);
  __int128 v186;
  __int128 v187;
  _QWORD v188[3];
  int v189;
  uint64_t v190;
  unsigned __int8 *v191;
  unsigned int v192;
  char v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  unsigned int v197;
  _BYTE buf[24];
  _BYTE v199[24];
  uint64_t v200;
  uint64_t v201;
  int v202;
  uint64_t v203;
  uint64_t v204;

  v204 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)buf = 0;
  re::BitReader::readUInt32Bits((uint64_t *)this, 8u, (unsigned int *)buf);
  v7 = buf[0];
  *(_BYTE *)a3 = buf[0];
  if ((v7 & 2) != 0)
    re::BitReader::readUInt64(this, (unint64_t *)(a3 + 16));
  *(_QWORD *)(a3 + 8) = a1[2];
  *(_DWORD *)buf = 0;
  UInt32Bits = re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, (unsigned int *)buf);
  if (*((_BYTE *)this + 12))
  {
    v9 = *re::networkLogObjects((re *)UInt32Bits);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v150 = "Failed to parse commit header.";
      v151 = v9;
      v152 = 2;
LABEL_208:
      _os_log_error_impl(&dword_21C69B000, v151, OS_LOG_TYPE_ERROR, v150, buf, v152);
    }
    return 0;
  }
  v170 = *(_DWORD *)buf;
  if (!*(_DWORD *)buf)
    return 2;
  v12 = 0;
  v164 = (_anonymous_namespace_ *)(a3 + 32);
  v162 = a3;
  LODWORD(v10) = 2;
  while (1)
  {
    *((_DWORD *)this + 5) = 0;
    *((_QWORD *)this + 3) = 0;
    *(_DWORD *)buf = 0;
    re::BitReader::readUInt32Bits((uint64_t *)this, 8u, (unsigned int *)buf);
    v13 = *(_DWORD *)buf;
    *(_DWORD *)buf = 0;
    re::BitReader::readUInt32Bits((uint64_t *)this, 0x10u, (unsigned int *)buf);
    v14 = *(_WORD *)buf;
    *(_QWORD *)&v177 = 0;
    WORD4(v177) = 0;
    LOBYTE(v178) = 0;
    *((_QWORD *)&v178 + 1) = 0;
    *(_DWORD *)v179 = 0x10000;
    re::SyncOwnershipInfo::read((re::SyncOwnershipInfo *)&v177, this, (v13 >> 4) & 1, 1);
    v15 = (uint64_t *)*((_QWORD *)&v178 + 1);
    if (!*((_QWORD *)&v178 + 1))
    {
      v15 = a1[2];
      *((_QWORD *)&v178 + 1) = v15;
    }
    if (v15 == a1[3])
    {
      v16 = 1;
    }
    else if (*((_BYTE *)a1 + 120))
    {
      v16 = v15 == *(uint64_t **)(a4 + 8);
    }
    else
    {
      v16 = 0;
    }
    v168 = v14;
    v17 = v13;
    LOBYTE(v179[1]) = v16;
    v176 = 0;
    *(_QWORD *)buf = 0;
    re::BiasedVLQ::read((re::BiasedVLQ *)buf, this, &v176);
    v174 = -1;
    v175 = 0;
    if ((v13 & 5) != 0)
    {
      re::BitReader::readUInt64(this, &v175);
      re::BitReader::readUInt64(this, &v174);
      v18 = v175;
      v19 = v176;
      v20 = (re::SyncOpaqueTypeInfo *)v174;
      v21 = **a1;
      if ((v13 & 4) != 0)
        v22 = *(void (**)(void))(v21 + 64);
      else
        v22 = *(void (**)(void))(v21 + 48);
      v22();
    }
    else
    {
      v19 = v176;
      v18 = (*(uint64_t (**)(uint64_t *, uint64_t))(**a1 + 56))(*a1, v176);
      v20 = (re::SyncOpaqueTypeInfo *)v23;
      v174 = v23;
      v175 = v18;
    }
    v24 = a1[1];
    *(_QWORD *)buf = v20;
    v25 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v24 + 63), (uint64_t *)buf);
    if (!v25 || (v26 = *(_QWORD *)(*(_QWORD *)v25 + 16)) == 0)
    {
      v27 = *re::networkLogObjects(v25);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v20;
        _os_log_impl(&dword_21C69B000, v27, OS_LOG_TYPE_DEFAULT, "Unknown object typeID=%llu. Assuming opaque type.", buf, 0xCu);
      }
      v28 = (re::SyncObjectStore *)a1[1];
      re::SyncOpaqueTypeInfo::make(v20, (uint64_t)buf);
      re::SyncObjectStore::addType(v28, (const re::SyncObjectTypeInfo *)buf);
      re::SyncObjectTypeInfo::~SyncObjectTypeInfo((re::SyncObjectTypeInfo *)buf);
      v29 = a1[1];
      *(_QWORD *)buf = v20;
      v30 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v29 + 63), (uint64_t *)buf);
      if (v30)
        v26 = *(_QWORD *)(*(_QWORD *)v30 + 16);
      else
        v26 = 0;
    }
    v172 = 0;
    v173 = 0;
    if ((v17 & 1) != 0)
    {
      re::BitReader::readUInt64(this, &v173);
      v31 = re::BitReader::readUInt64(this, &v172);
      v32 = 0;
    }
    else
    {
      *(_DWORD *)buf = 0;
      v31 = re::BitReader::readUInt32Bits((uint64_t *)this, 0x10u, (unsigned int *)buf);
      v32 = *(_WORD *)buf;
    }
    if (*((_BYTE *)this + 12))
    {
      v33 = *re::networkLogObjects((re *)v31);
      v34 = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
      if ((_DWORD)v34)
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_21C69B000, v33, OS_LOG_TYPE_ERROR, "Failed to parse object header.", buf, 2u);
      }
      v35 = 0;
      goto LABEL_36;
    }
    v36 = *(_QWORD *)(v26 + 136);
    if (v36)
    {
      v36 = (*(uint64_t (**)(uint64_t, uint64_t))(v36 + 16))(v36, a4);
      if ((v36 & 1) == 0)
      {
        v34 = re::SyncUnpacker::skipObjectState(this, v37, v38, v39, v40);
        v35 = 2;
        goto LABEL_36;
      }
    }
    if (v18)
    {
      Object = re::SyncObjectStore::findObject((re::SyncObjectStore *)a1[1], (uint64_t)v20, v18, (re::SyncObjectTypedStore ***)&v171);
      if (v171)
      {
        v166 = v171;
        if ((v17 & 1) != 0)
        {
          v165 = 0;
          v45 = 1;
          v43 = v171;
          goto LABEL_81;
        }
        v42 = v32;
        v43 = v171;
        Baseline = re::SyncObject::findBaseline(v171, v42, (uint64_t)a1[2]);
        if (!Baseline)
        {
          v61 = *re::networkLogObjects(0);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            if ((*(_BYTE *)(v26 + 48) & 1) != 0)
              v62 = *(_QWORD *)(v26 + 56);
            else
              v62 = v26 + 49;
            *(_DWORD *)buf = 134218498;
            *(_QWORD *)&buf[4] = v18;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v62;
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)v199 = v20;
            _os_log_impl(&dword_21C69B000, v61, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing baseline for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
          }
          if ((v17 & 4) == 0)
          {
            *(_QWORD *)buf = v20;
            *(_QWORD *)&buf[8] = v18;
            re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)(a1 + 10), (__n128 *)buf);
          }
          v45 = 0;
          v165 = 0;
          v43 = v166;
LABEL_81:
          shouldAcceptUpdate = re::SyncObject::shouldAcceptUpdate(v43, *((uint64_t *)&v178 + 1), v179[0]);
          if (*((_BYTE *)a1 + 121) || shouldAcceptUpdate)
          {
            if (shouldAcceptUpdate
              && (v77 = a1[3],
                  v78 = *((unsigned __int16 *)v43 + 84),
                  v79 = v178,
                  *(_OWORD *)((char *)v43 + 136) = v177,
                  *(_OWORD *)((char *)v43 + 152) = v79,
                  *((_DWORD *)v43 + 42) = *(_DWORD *)v179,
                  *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v43 + 11) + 16) + 73))
              && (v78 < v179[0] || ((uint64_t *)v177 == v77 ? (v80 = (_QWORD)v177 == 0) : (v80 = 1), !v80)))
            {
              v163 = 4;
              if (!v45)
                goto LABEL_104;
            }
            else
            {
              v163 = 0;
              if (!v45)
                goto LABEL_104;
            }
            if (re::SyncObject::isStateDataChanged(v43, v168, (uint64_t)a1[2]))
            {
              DWORD2(v186) = 0;
              BYTE12(v186) = 0;
              v187 = 0uLL;
              v185 = &off_24E072690;
              *(_QWORD *)&v186 = 0;
              v190 = 0;
              v189 = 0;
              memset(v188, 0, sizeof(v188));
              if (*((_QWORD *)v43 + 9) - *((_QWORD *)v43 + 8) == *((_QWORD *)v43 + 6)
                && (OldestState = (re *)re::SyncObject::getOldestState(v43), OldestState == (re *)v165))
              {
                v111 = *re::networkLogObjects(OldestState);
                if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_21C69B000, v111, OS_LOG_TYPE_INFO, "Baseline would be invalidated by new state! Will read into temp location.", buf, 2u);
                }
                v160 = (os_log_t)&v185;
                v82 = v168;
              }
              else
              {
                v82 = v168;
                v160 = (os_log_t)re::SyncObject::addState(v43, v168, (uint64_t)a1[2]);
              }
              *((_WORD *)v43 + 88) = v82;
              v154 = *((_DWORD *)this + 5) != 0;
              v155 = *((_DWORD *)this + 4);
              v196 = 0;
              *(_QWORD *)buf = 0;
              re::BiasedVLQ::read((re::BiasedVLQ *)buf, this, &v196);
              v83 = *((_DWORD *)this + 5);
              v84 = (8 - v83);
              v80 = v83 == 0;
              v85 = v83 != 0;
              v86 = (v84 << 32);
              if (v80)
                v86 = 0;
              v157 = v196;
              log = v86;
              v153 = (*((_DWORD *)this + 4) - v85);
              v87 = v153 + v196;
              v88 = (re *)re::BitReader::seekTo((uint64_t)this, (v153 + v196));
              if (*((_BYTE *)this + 12))
              {
                v89 = *re::networkLogObjects(v88);
                if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)&buf[4] = v157;
                  _os_log_error_impl(&dword_21C69B000, v89, OS_LOG_TYPE_ERROR, "Buffer overflowe trying to extract sync object state buffer (len=%u) from packet reader!", buf, 8u);
                }
                v180 = 0;
                v181 = 0;
                v182 = 0;
                v183 = 0;
                v184 = 0;
              }
              else
              {
                v101 = v87;
                v102 = v153;
                v103 = v153 + v154 - v155;
                v104 = v103 - 1;
                if (v103 <= 1)
                {
                  v109 = v153;
                }
                else
                {
                  v105 = *(_QWORD *)this;
                  v106 = v153 - v104;
                  v107 = (unsigned __int8 *)(*(_QWORD *)this + v106);
                  v191 = &v107[v157];
                  v192 = v104;
                  v193 = 0;
                  v194 = 0;
                  v195 = 0;
                  if (log)
                    v102 = v153 + 1;
                  *(_QWORD *)buf = &off_24E072668;
                  *(_QWORD *)&buf[8] = v105;
                  *(_DWORD *)&buf[16] = v102;
                  *(_DWORD *)v199 = v153 - v104;
                  *(_DWORD *)&v199[4] = HIDWORD(log);
                  *(_QWORD *)&v199[8] = 0;
                  v156 = v153 - v104;
                  if (HIDWORD(log))
                    v108 = v106 + 1;
                  else
                    v108 = v153 - v104;
                  buf[20] = v108 > v102;
                  if (HIDWORD(log) && v108 <= v102)
                    *(_QWORD *)&v199[8] = (0xFFuLL >> (8 - BYTE4(log))) & *v107;
                  do
                  {
                    v197 = 0;
                    re::BitReader::readUInt32Bits((uint64_t *)&v191, 8u, &v197);
                    re::BitWriter::writeUInt32Bits((uint64_t)buf, v197, 8u);
                    --v104;
                  }
                  while (v104);
                  v109 = v156;
                  v101 = v156 + v157;
                }
                v180 = *(_QWORD *)this;
                v181 = v101;
                v182 = 0;
                v183 = 0;
                v184 = 0;
                re::BitReader::seekTo((uint64_t)&v180, v109 | (unint64_t)log);
              }
              if (v165)
              {
                v112 = *(_QWORD *)(v26 + 104);
                if (!v112)
                {
                  loga = *re::networkLogObjects(0);
                  v115 = os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT);
                  if ((_DWORD)v115)
                  {
                    v118 = *((_QWORD *)v43 + 3);
                    v119 = *(_QWORD *)(v26 + 32);
                    if ((*(_QWORD *)(v26 + 48) & 1) != 0)
                      v120 = *(_QWORD *)(v26 + 56);
                    else
                      v120 = v26 + 49;
                    *(_DWORD *)buf = 134218498;
                    *(_QWORD *)&buf[4] = v118;
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v119;
                    *(_WORD *)&buf[22] = 2080;
                    *(_QWORD *)v199 = v120;
                    _os_log_impl(&dword_21C69B000, loga, OS_LOG_TYPE_DEFAULT, "Cannot parse state for syncobject %llu of type %llu(%s), readDeltaCb not available.", buf, 0x20u);
                  }
                  if (v160 == (os_log_t)&v185 || (v121 = *((_QWORD *)v43 + 9), *((_QWORD *)v43 + 8) == v121))
                  {
                    v117 = 0;
                  }
                  else
                  {
                    v117 = 0;
                    *((_QWORD *)v43 + 9) = v121 - 1;
                  }
                  goto LABEL_169;
                }
                v113 = *(_DWORD *)(v165 + 24);
                if (*(_DWORD *)(v165 + 28))
                  ++v113;
                *(_QWORD *)buf = *(_QWORD *)(v165 + 8);
                *(_DWORD *)&buf[8] = v113;
                buf[12] = 0;
                *(_QWORD *)&buf[16] = 0;
                *(_QWORD *)v199 = 0;
                p_isa = &v160->isa;
                v115 = (*(uint64_t (**)(uint64_t, uint64_t *, _BYTE *, os_log_t, uint64_t))(v112 + 16))(v112, &v180, buf, v160, a4);
                if ((v115 & 1) == 0)
                  goto LABEL_162;
              }
              else
              {
                v116 = *(_QWORD *)(v26 + 96);
                if (!v116)
                {
                  v169 = *re::networkLogObjects(0);
                  v115 = os_log_type_enabled(v169, OS_LOG_TYPE_ERROR);
                  p_isa = &v160->isa;
                  if ((_DWORD)v115)
                  {
                    v145 = *((_QWORD *)v43 + 3);
                    v146 = *(_QWORD *)(v26 + 32);
                    if ((*(_QWORD *)(v26 + 48) & 1) != 0)
                      v147 = *(_QWORD *)(v26 + 56);
                    else
                      v147 = v26 + 49;
                    *(_DWORD *)buf = 134218498;
                    *(_QWORD *)&buf[4] = v145;
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v146;
                    *(_WORD *)&buf[22] = 2080;
                    *(_QWORD *)v199 = v147;
                    _os_log_error_impl(&dword_21C69B000, v169, OS_LOG_TYPE_ERROR, "Cannot parse state for syncobject %llu of type %llu(%s), readCb not available.", buf, 0x20u);
                  }
                  goto LABEL_162;
                }
                p_isa = &v160->isa;
                v115 = (*(uint64_t (**)(uint64_t, uint64_t *, os_log_t, uint64_t))(v116 + 16))(v116, &v180, v160, a4);
                if (!(_DWORD)v115)
                {
LABEL_162:
                  if (p_isa != &v185)
                  {
                    v122 = *((_QWORD *)v43 + 9);
                    if (*((_QWORD *)v43 + 8) != v122)
                      *((_QWORD *)v43 + 9) = v122 - 1;
                  }
                  v123 = *re::networkLogObjects((re *)v115);
                  if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
                  {
                    v142 = *((_QWORD *)v43 + 3);
                    v143 = a1[2];
                    *(_DWORD *)buf = 134218240;
                    *(_QWORD *)&buf[4] = v142;
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v143;
                    _os_log_error_impl(&dword_21C69B000, v123, OS_LOG_TYPE_ERROR, "Failed to parse object data.(guid=%llu, peerID=%llu)", buf, 0x16u);
                  }
                  v124 = 0;
LABEL_179:
                  v130 = (re *)v188[0];
                  if (v188[0] && v190)
                    v130 = (re *)(*(uint64_t (**)(void))(*(_QWORD *)v188[0] + 40))();
                  if (!v124)
                  {
                    v131 = *re::networkLogObjects(v130);
                    v34 = os_log_type_enabled(v131, OS_LOG_TYPE_ERROR);
                    if ((_DWORD)v34)
                    {
                      if ((*(_BYTE *)(v26 + 48) & 1) != 0)
                        v141 = *(_QWORD *)(v26 + 56);
                      else
                        v141 = v26 + 49;
                      v144 = a1[2];
                      *(_DWORD *)buf = 134218754;
                      *(_QWORD *)&buf[4] = v18;
                      *(_WORD *)&buf[12] = 2048;
                      *(_QWORD *)&buf[14] = v20;
                      *(_WORD *)&buf[22] = 2080;
                      *(_QWORD *)v199 = v141;
                      *(_WORD *)&v199[8] = 2048;
                      *(_QWORD *)&v199[10] = v144;
                      _os_log_error_impl(&dword_21C69B000, v131, OS_LOG_TYPE_ERROR, "Failed to parse object state.(guid=%llu, type=%llu(%s), peerID=%llu)", buf, 0x2Au);
                    }
                    if (!v166)
                    {
                      v132 = (uint64_t)a1[1];
                      *(_QWORD *)buf = v171;
                      if (v171)
                      {
                        v133 = (char *)v171 + 8;
                        v134 = (char *)v171 + 8;
                        re::SyncObjectStore::removeObject(v132, (uint64_t *)buf);

                      }
                      else
                      {
                        re::SyncObjectStore::removeObject(v132, (uint64_t *)buf);
                      }
                    }
                    goto LABEL_195;
                  }
                  v90 = 8;
                  v43 = v171;
LABEL_105:
                  if (v172 && !*((_QWORD *)v43 + 10))
                  {
                    *(_QWORD *)buf = v173;
                    *(_QWORD *)&buf[8] = v172;
                    re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace((uint64_t)(a1 + 4), (uint64_t *)&v171, buf);
                    v43 = v171;
                  }
                  v91 = re::SyncObject::latestStateHandle(v43);
                  if (v91 != -1)
                  {
                    v92 = v91;
                    memset(buf, 0, 17);
                    re::SharedPtr<re::SyncObject>::reset((uint64_t *)buf, (uint64_t)v171);
                    *(_QWORD *)&buf[8] = v92;
                    v93 = v163 | v90 | (v166 == 0) | buf[16] & 0xF2;
                    buf[16] = v93;
                    if ((v17 & 4) != 0)
                    {
                      *((_BYTE *)v171 + 128) |= 4u;
                      buf[16] = v93 | 2;
                    }
                    v34 = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v164, (uint64_t)buf);
                    if (*(_QWORD *)buf)

                    goto LABEL_133;
                  }
                  v94 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
                  v34 = os_log_type_enabled(v94, OS_LOG_TYPE_ERROR);
                  if ((_DWORD)v34)
                  {
                    v95 = *((_QWORD *)v171 + 3);
                    v96 = *(_QWORD **)(*((_QWORD *)v171 + 11) + 16);
                    v97 = v96[4];
                    v98 = v96[6];
                    v99 = (char *)v96[7];
                    v100 = (char *)v96 + 49;
                    if ((v98 & 1) != 0)
                      v100 = v99;
                    *(_DWORD *)buf = 134218498;
                    *(_QWORD *)&buf[4] = v95;
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v97;
                    *(_WORD *)&buf[22] = 2080;
                    *(_QWORD *)v199 = v100;
                    _os_log_error_impl(&dword_21C69B000, v94, OS_LOG_TYPE_ERROR, "Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).", buf, 0x20u);
                  }
LABEL_195:
                  v35 = 0;
LABEL_134:
                  if (v171)

                  goto LABEL_36;
                }
              }
              v117 = (void (***)(re::DynamicBitWriter *__hidden))p_isa;
LABEL_169:
              if (v181 != (_DWORD)v183)
              {
                v125 = v117;
                v161 = *re::networkLogObjects((re *)v115);
                v126 = os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT);
                v117 = v125;
                if (v126)
                {
                  v127 = "readDeltaCb";
                  if (!v165)
                    v127 = "readCb";
                  if ((*(_QWORD *)(v26 + 48) & 1) != 0)
                    v128 = *(_QWORD *)(v26 + 56);
                  else
                    v128 = v26 + 49;
                  v129 = *(_QWORD *)(v26 + 32);
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = v127;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = v128;
                  *(_WORD *)&buf[22] = 2048;
                  *(_QWORD *)v199 = v129;
                  _os_log_impl(&dword_21C69B000, v161, OS_LOG_TYPE_DEFAULT, "Read buffer is not fully consumed by %s of type %s: %llu", buf, 0x20u);
                  v117 = v125;
                }
              }
              if (v117 == &v185)
              {
                v135 = re::SyncObject::addState(v43, v168, (uint64_t)a1[2]);
                v136 = *(_QWORD *)(v135 + 40);
                v135 += 40;
                v137 = *(_OWORD *)(v135 - 32);
                v138 = *(_OWORD *)(v135 - 16);
                *(_QWORD *)buf = &off_24E072690;
                *(_QWORD *)&v199[16] = v136;
                *(_QWORD *)v135 = 0;
                v139 = *(_QWORD *)(v135 + 16);
                v200 = *(_QWORD *)(v135 + 8);
                *(_OWORD *)&buf[8] = v137;
                *(_OWORD *)v199 = v138;
                *(_QWORD *)(v135 + 8) = 0;
                v201 = v139;
                *(_QWORD *)(v135 + 16) = 0;
                v203 = *(_QWORD *)(v135 + 32);
                *(_QWORD *)(v135 + 32) = 0;
                ++*(_DWORD *)(v135 + 24);
                v202 = 1;
                v140 = v187;
                *(_OWORD *)(v135 - 32) = v186;
                *(_OWORD *)(v135 - 16) = v140;
                re::DynamicArray<unsigned char>::operator=(v135, (uint64_t)v188);
                v186 = *(_OWORD *)&buf[8];
                v187 = *(_OWORD *)v199;
                re::DynamicArray<unsigned char>::operator=((uint64_t)v188, (uint64_t)&v199[16]);
                if (*(_QWORD *)&v199[16])
                {
                  if (v203)
                    (*(void (**)(void))(**(_QWORD **)&v199[16] + 40))();
                }
              }
              v124 = 1;
              goto LABEL_179;
            }
LABEL_104:
            re::SyncUnpacker::skipObjectState(this, v54, v55, v56, v57);
            v90 = 0;
            goto LABEL_105;
          }
LABEL_132:
          v34 = re::SyncUnpacker::skipObjectState(this, v54, v55, v56, v57);
LABEL_133:
          v35 = 2;
          goto LABEL_134;
        }
        v165 = Baseline;
LABEL_49:
        v45 = 1;
        goto LABEL_81;
      }
      if ((v17 & 4) != 0)
      {
        v59 = *re::networkLogObjects((re *)Object);
        if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          goto LABEL_132;
        if ((*(_BYTE *)(v26 + 48) & 1) != 0)
          v60 = *(_QWORD *)(v26 + 56);
        else
          v60 = v26 + 49;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v18;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v60;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)v199 = v20;
        v68 = v59;
        v69 = "Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)";
      }
      else
      {
        v166 = v171;
        v51 = a1[1];
        *(_QWORD *)buf = v18;
        *(_QWORD *)&buf[8] = v20;
        *(_QWORD *)&buf[16] = 0;
        v52 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v51 + 75), (uint64_t *)buf);
        if (!v52)
        {
          v63 = a1[1];
          v64 = v172;
          *(_QWORD *)buf = v172;
          *(_QWORD *)&buf[8] = v173;
          *(_QWORD *)&buf[16] = 0;
          v65 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v63 + 75), (uint64_t *)buf);
          if (!v65)
          {
            if ((v17 & 1) == 0)
            {
              v70 = *re::networkLogObjects((re *)v65);
              if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
              {
                if ((*(_BYTE *)(v26 + 48) & 1) != 0)
                  v75 = *(_QWORD *)(v26 + 56);
                else
                  v75 = v26 + 49;
                *(_DWORD *)buf = 134218498;
                *(_QWORD *)&buf[4] = v18;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v75;
                *(_WORD *)&buf[22] = 2048;
                *(_QWORD *)v199 = v20;
                _os_log_impl(&dword_21C69B000, v70, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
              }
              v34 = re::SyncUnpacker::skipObjectState(this, v71, v72, v73, v74);
              v35 = 1;
              goto LABEL_134;
            }
            re::SyncObjectStore::createIncomingObject((re::SyncObjectStore *)a1[1], (const re::SyncOwnershipInfo *)&v177, (unint64_t)v20, v18, (uint64_t *)buf);
            v165 = 0;
            v43 = *(re::SyncObject **)buf;
            v171 = *(re::SyncObject **)buf;
            goto LABEL_49;
          }
          v66 = *re::networkLogObjects((re *)v65);
          if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
            goto LABEL_132;
          if ((*(_BYTE *)(v26 + 48) & 1) != 0)
            v67 = *(_QWORD *)(v26 + 56);
          else
            v67 = v26 + 49;
          *(_DWORD *)buf = 134218754;
          *(_QWORD *)&buf[4] = v18;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v67;
          *(_WORD *)&buf[22] = 2048;
          *(_QWORD *)v199 = v20;
          *(_WORD *)&v199[8] = 2048;
          *(_QWORD *)&v199[10] = v64;
          v68 = v66;
          v69 = "Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu";
          v110 = 42;
LABEL_131:
          _os_log_impl(&dword_21C69B000, v68, OS_LOG_TYPE_DEFAULT, v69, buf, v110);
          goto LABEL_132;
        }
        v53 = *re::networkLogObjects((re *)v52);
        if (!os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          goto LABEL_132;
        if ((*(_BYTE *)(v26 + 48) & 1) != 0)
          v58 = *(_QWORD *)(v26 + 56);
        else
          v58 = v26 + 49;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v18;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v58;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)v199 = v20;
        v68 = v53;
        v69 = "Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)";
      }
      v110 = 32;
      goto LABEL_131;
    }
    v46 = *re::networkLogObjects((re *)v36);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v19;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v17;
      _os_log_debug_impl(&dword_21C69B000, v46, OS_LOG_TYPE_DEBUG, "Cannot find guid for object with id=%d, flags=0x%02X. Skipping update.", buf, 0xEu);
    }
    v34 = re::SyncUnpacker::skipObjectState(this, v47, v48, v49, v50);
    v35 = 1;
LABEL_36:
    v10 = v35 >= (int)v10 ? v10 : v35;
    if (!(_DWORD)v10)
      break;
    if (++v12 == v170)
      return v10;
  }
  v148 = *re::networkLogObjects((re *)v34);
  if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
  {
    v149 = *(_QWORD *)(v162 + 16);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v12;
    *(_WORD *)&buf[8] = 2048;
    *(_QWORD *)&buf[10] = v149;
    v150 = "Failed to parse object %u from commit %llu.";
    v151 = v148;
    v152 = 18;
    goto LABEL_208;
  }
  return 0;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<2>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>(uint64_t a1, _WORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<2>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,re::SyncOwnershipInfo>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<3>(a1);
  if ((_DWORD)result)
  {
    if (re::snapshot::DecoderOPACK::beginObject((re::snapshot::DecoderOPACK *)a1, 0))
    {
      re::snapshotMapFields(a1, a2);
      re::snapshot::DecoderOPACK::endObject((uint64_t *)a1, 0);
    }
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<6,unsigned long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<6>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<8,unsigned long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<8>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<9,unsigned long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<9>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<11,re::Slice<unsigned char>>(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  unint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  __int128 v9;
  unint64_t v10;

  result = re::snapshot::DecoderOPACK::advanceTo<11>(a1);
  if ((_DWORD)result)
  {
    v10 = 0;
    if ((re::snapshot::DecoderOPACK::beginData((re::snapshot::DecoderOPACK *)a1, &v10, 0) & 1) != 0)
    {
      v9 = *(_OWORD *)a1;
      v5 = v10;
      *a2 = re::Slice<unsigned char>::range(&v9, *(_QWORD *)(a1 + 16) - v9, *(_QWORD *)(a1 + 16) - v9 + v10);
      a2[1] = v6;
      v7 = (unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v5);
      *(_QWORD *)(a1 + 16) = v7;
    }
    else
    {
      v7 = *(unsigned __int8 **)(a1 + 16);
    }
    if ((unint64_t)v7 >= *(_QWORD *)(a1 + 24) || (v8 = *v7, v8 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v8 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v7 + 1;
      result = (v8 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 40 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 40 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  *(_OWORD *)(v11 + 40 * v10 + 24) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v12 = *(_QWORD *)(a1 + 16) + 40 * v10;
  return v12 + 24;
}

uint64_t re::SyncUnpacker::skipObjectState(re::SyncUnpacker *this, const re::SyncObjectTypeInfo *a2, unint64_t a3, unsigned __int8 a4, re::BitReader *a5)
{
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  re::BiasedVLQ::read((re::BiasedVLQ *)&v7, this, &v8);
  return re::BitReader::seekTo((uint64_t)this, *((_DWORD *)this + 4) + (_DWORD)v8 - (*((_DWORD *)this + 5) != 0));
}

BOOL re::snapshot::DecoderOPACK::advanceTo<1>(uint64_t a1)
{
  int Integer;
  int v3;
  int v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 0)
  {
    while (1)
    {
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        v4 = *v5;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v6 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v6 >= *(_QWORD *)(a1 + 24))
        break;
      v3 = *v6;
      if (v3 == 3)
        break;
      if ((v3 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v6 + 1;
        Integer = v3 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 1)
        return Integer == 1;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 1;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<2>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 1)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 2)
        return Integer == 2;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 2;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<3>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 2)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 3)
        return Integer == 3;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 3;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<5>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 4)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 5)
        return Integer == 5;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 5;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<6>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 5)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 6)
        return Integer == 6;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 6;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<8>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 7)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 8)
        return Integer == 8;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 8;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<9>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 8)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 9)
        return Integer == 9;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 9;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<11>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 10)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 11)
        return Integer == 11;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 11;
}

uint64_t re::Slice<unsigned char>::range(_QWORD *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t result;

  v3 = a1[1];
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. fromInclusive = %zu, size = %zu", "fromInclusive <= size()", "range", 241, a2, v3);
    _os_crash();
    __break(1u);
  }
  else if (v3 >= a3)
  {
    return *a1 + a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. toExclusive = %zu, size = %zu", "toExclusive <= size()", "range", 242, a2, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, _OWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  id v15;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 40 * v9 + 8) = v12 | 0x80000000;
  v13 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9) = a3;
  v14 = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 16) = *a4;
  if (v14)
    v15 = (id)(v14 + 8);
  *(_OWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 24);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::DynamicArray<unsigned char>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result != a2)
  {
    v2 = *(_QWORD *)result;
    v3 = *(_QWORD *)a2;
    if (*(_QWORD *)result)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (v4 || v2 == v3)
    {
      v6 = *(_QWORD *)(result + 8);
      v7 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = v7;
      *(_QWORD *)a2 = v2;
      *(_QWORD *)(a2 + 8) = v6;
      v8 = *(_QWORD *)(result + 16);
      *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = v8;
      v9 = *(_QWORD *)(result + 32);
      *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::IP::makeFromString@<X0>(re::IP *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)&v6 + 1) = 0;
  v7 = 0;
  result = inet_pton(2, (const char *)this, (char *)&v6 + 8);
  if ((_DWORD)result)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    result = inet_pton(30, (const char *)this, (char *)&v6 + 8);
    if (!(_DWORD)result)
    {
      *(_BYTE *)a2 = 0;
      return result;
    }
    LOBYTE(v6) = 1;
  }
  *(_BYTE *)a2 = 1;
  *(_QWORD *)(a2 + 24) = v7;
  *(_OWORD *)(a2 + 8) = v6;
  return result;
}

re::DynamicString *re::IP::generateString@<X0>(re::IP *this@<X0>, re::DynamicString *a2@<X8>)
{
  char *v3;
  int v4;
  _anonymous_namespace_ *v5;
  char __s[49];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  __s[0] = 0;
  v3 = (char *)this + 8;
  if (*(_BYTE *)this)
    v4 = 30;
  else
    v4 = 2;
  v5 = (_anonymous_namespace_ *)inet_ntop(v4, v3, __s, 0x31u);
}

uint64_t re::Address::getIPPortPair@<X0>(re::Address *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  size_t v6;
  re::Address *v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  __int16 v12;
  re::IP *v13;
  char v14;
  uint64_t v15;
  char v16;
  _BYTE v17[23];
  char *__endptr;
  _BYTE v19[8];
  size_t v20;
  char v21[8];
  __int128 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  result = re::DynamicString::rfind((uint64_t)this, 58, v19);
  if (!v19[0])
    goto LABEL_12;
  v6 = v20;
  if (!v20)
    goto LABEL_12;
  __endptr = 0;
  v7 = (*((_QWORD *)this + 1) & 1) != 0 ? (re::Address *)*((_QWORD *)this + 2) : (re::Address *)((char *)this + 9);
  result = strtol((const char *)v7 + v20 + 1, &__endptr, 10);
  if (result >= 0x10000)
    goto LABEL_12;
  v8 = *((_QWORD *)this + 1);
  v9 = (char *)*((_QWORD *)this + 2);
  if ((v8 & 1) == 0)
    v9 = (char *)this + 9;
  v10 = v8 >> 1;
  v11 = v8 >> 1;
  if ((*((_QWORD *)this + 1) & 1) != 0)
    v11 = v10;
  if (__endptr == &v9[v11])
  {
    v12 = result;
    re::DynamicString::substr(this, 0, v6, (re::DynamicString *)&v15);
    if ((v16 & 1) != 0)
      v13 = *(re::IP **)&v17[7];
    else
      v13 = (re::IP *)v17;
    re::IP::makeFromString(v13, (uint64_t)v21);
    v14 = v21[0];
    if (v21[0])
    {
      *(_OWORD *)(a2 + 8) = v22;
      *(_QWORD *)(a2 + 24) = v23;
      *(_WORD *)(a2 + 32) = v12;
      v14 = 1;
    }
    *(_BYTE *)a2 = v14;
    result = v15;
    if (v15)
    {
      if ((v16 & 1) != 0)
        return (*(uint64_t (**)(void))(*(_QWORD *)v15 + 40))();
    }
  }
  else
  {
LABEL_12:
    *(_BYTE *)a2 = 0;
  }
  return result;
}

size_t re::Address::hash(re::Address *this)
{
  const char *v1;
  size_t result;
  unint64_t v3[3];

  v3[2] = *MEMORY[0x24BDAC8D0];
  if ((*((_BYTE *)this + 8) & 1) != 0)
    v1 = (const char *)*((_QWORD *)this + 2);
  else
    v1 = (char *)this + 9;
  result = strlen(v1);
  if (result)
  {
    MurmurHash3_x64_128((uint64_t)v1, result, 0, v3);
    return (v3[1] + (v3[0] << 6) + (v3[0] >> 2) - 0x61C8864680B583E9) ^ v3[0];
  }
  return result;
}

uint64_t re::Address::makeFromIPAndPort@<X0>(unsigned __int16 *a1@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t result;
  uint64_t v5;
  char v6;

  re::IP::generateString((re::IP *)a1, (re::DynamicString *)&v5);
  re::DynamicString::appendf((re::DynamicString *)&v5, ":%hu", a1[12]);
  re::DynamicString::DynamicString(a2, (const re::DynamicString *)&v5);
  result = v5;
  if (v5)
  {
    if ((v6 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
  }
  return result;
}

uint64_t re::Address::makeFromIPAndPort@<X0>(re::Address *this@<X0>, const char *a2@<X1>, re::DynamicString *a3@<X8>)
{
  int v3;
  uint64_t result;
  uint64_t v7;
  char v8;

  v3 = (int)a2;
  re::DynamicString::appendf((re::DynamicString *)&v7, ":%hu", v3);
  re::DynamicString::DynamicString(a3, (const re::DynamicString *)&v7);
  result = v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return result;
}

double RESyncCreateSyncObjectContext(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 48, 8);
  result = 0.0;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)v2 = 0u;
  *(_DWORD *)(v2 + 36) = 0x7FFFFFFF;
  return result;
}

re *RESyncDestroySyncObjectContext(re *result)
{
  uint64_t *v1;
  uint64_t v2;
  double v3;

  if (result)
  {
    v1 = (uint64_t *)result;
    v2 = re::globalAllocators(result)[2];
    v3 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v1);
    return (re *)(*(uint64_t (**)(uint64_t, uint64_t *, double))(*(_QWORD *)v2 + 40))(v2, v1, v3);
  }
  return result;
}

uint64_t RESyncGetSyncObjectContextRequiredSize()
{
  return 48;
}

double RESyncCreateSyncObjectContextNoAlloc(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
  return result;
}

BOOL RESyncAddSyncObjectContextEntry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v5;
  uint64_t v6;

  v5 = a3;
  v6 = a2;
  v3 = (_QWORD *)re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>(a1, &v5, &v6);
  return *v3 == v6;
}

uint64_t re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<void *&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 32 * v10;
  return v12 + 24;
}

uint64_t RESyncGetSyncObjectContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t v5;
  uint8_t buf[4];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1, &v5);
  if (v2)
    return *(_QWORD *)v2;
  v4 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134217984;
    v7 = v5;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_INFO, "RESyncGetSyncObjectContextEntry: Couldn't find entry with id=%llu", buf, 0xCu);
  }
  return 0;
}

uint64_t RESyncRemoveSyncObjectContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v6 = a2;
  v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1, &v6);
  v3 = v2;
  if ((v2 & 1) == 0)
  {
    v4 = *re::networkLogObjects((re *)v2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v8 = v6;
      _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "RESyncRemoveSyncObjectContextEntry: Couldn't find entry with id=%llu", buf, 0xCu);
    }
  }
  return v3;
}

uint64_t re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<void *&>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<void *&>(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 24);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 9;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshotMapFields(re::snapshot::EncoderOPACK *a1, uint64_t a2)
{
  unsigned int *result;

  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,BOOL>(a1, (unsigned __int8 *)(a2 + 16));
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,BOOL>(a1, (unsigned __int8 *)(a2 + 35));
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,unsigned short>(a1, (unsigned __int16 *)(a2 + 32));
  result = re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<4,unsigned long long>(a1, (uint64_t *)(a2 + 24));
  if (!*(_QWORD *)(a2 + 24))
  {
    if (*(_QWORD *)a2)
      return re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<5,re::HandOffData>(a1, a2);
  }
  return result;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,BOOL>(re::snapshot::EncoderOPACK *this, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 9;
  }
  return re::snapshot::EncoderOPACK::operator<<((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,BOOL>(re::snapshot::EncoderOPACK *this, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 2);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 10;
  }
  return re::snapshot::EncoderOPACK::operator<<((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,unsigned short>(re::snapshot::EncoderOPACK *this, unsigned __int16 *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 3);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 11;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<4,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 4);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 12;
  }
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, *a2);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<5,re::HandOffData>(re::snapshot::EncoderOPACK *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 5);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 13;
  }
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned long long>(this, (uint64_t *)a2);
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>(this, (unsigned __int16 *)(a2 + 8));
  return re::snapshot::EncoderOPACK::endObject((unsigned int *)this);
}

uint64_t re::snapshotMapFields(uint64_t a1, uint64_t a2)
{
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,BOOL>(a1, (_BYTE *)(a2 + 16));
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,BOOL>(a1, (_BYTE *)(a2 + 35));
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,unsigned short>(a1, (_WORD *)(a2 + 32));
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<4,unsigned long long>(a1, (_QWORD *)(a2 + 24));
  return re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<5,re::HandOffData>(a1, a2);
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,BOOL>(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if ((_DWORD)result)
  {
    re::snapshot::DecoderOPACK::operator>>((uint64_t *)a1, a2);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,BOOL>(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<2>(a1);
  if ((_DWORD)result)
  {
    re::snapshot::DecoderOPACK::operator>>((uint64_t *)a1, a2);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,unsigned short>(uint64_t a1, _WORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<3>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<4,unsigned long long>(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<4>(a1);
  if ((_DWORD)result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<5,re::HandOffData>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<5>(a1);
  if ((_DWORD)result)
  {
    if (re::snapshot::DecoderOPACK::beginObject((re::snapshot::DecoderOPACK *)a1, 0))
    {
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned long long>(a1, (_QWORD *)a2);
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>(a1, (_WORD *)(a2 + 8));
      re::snapshot::DecoderOPACK::endObject((uint64_t *)a1, 0);
    }
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

BOOL re::SyncOwnershipInfo::read(re::SyncOwnershipInfo *this, re::BitReader *a2, int a3, int a4)
{
  unsigned int v9;

  v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 1u, &v9);
  *((_BYTE *)this + 16) = v9 != 0;
  v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 1u, &v9);
  *((_BYTE *)this + 35) = v9 != 0;
  v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 0x10u, &v9);
  *((_WORD *)this + 16) = v9;
  if (a4)
    re::BitReader::readUInt64(a2, (unint64_t *)this + 3);
  if (a3)
  {
    re::BitReader::readUInt64(a2, (unint64_t *)this);
    v9 = 0;
    re::BitReader::readUInt32Bits((uint64_t *)a2, 0x10u, &v9);
    *((_WORD *)this + 4) = v9;
  }
  return *((_BYTE *)a2 + 12) == 0;
}

BOOL re::SyncOwnershipInfo::write(re::SyncOwnershipInfo *this, re::BitWriter *a2, int a3)
{
  unsigned int v6;
  uint64_t v7;

  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int8 *)this + 16), 1u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int8 *)this + 35), 1u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int16 *)this + 16), 0x10u);
  if (a3)
  {
    v6 = *((_DWORD *)this + 7);
    re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 6), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)a2, v6, 0x20u);
  }
  if (!*((_QWORD *)this + 3))
  {
    v7 = *(_QWORD *)this;
    if (*(_QWORD *)this)
    {
      re::BitWriter::writeUInt32Bits((uint64_t)a2, *(_QWORD *)this, 0x20u);
      re::BitWriter::writeUInt32Bits((uint64_t)a2, HIDWORD(v7), 0x20u);
      re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int16 *)this + 4), 0x10u);
    }
  }
  return *((_BYTE *)a2 + 20) == 0;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<4>(uint64_t a1)
{
  int Integer;
  unsigned __int8 *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;

  Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 3)
  {
    while (1)
    {
      v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(_QWORD *)(a1 + 24))
      {
        v4 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v3 + 1;
        v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24))
        break;
      v6 = *v5;
      if (v6 == 3)
        break;
      if ((v6 - 7) > 0x28)
      {
        Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v5 + 1;
        Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 4)
        return Integer == 4;
    }
    Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 4;
}

uint64_t *re::networkLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::networkLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Network");
  }
  return &re::networkLogObjects(void)::logObjects;
}

double RESyncCreateSyncObjectWriteContext(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 88, 8);
  result = 0.0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_QWORD *)(v2 + 80) = 0;
  *(_DWORD *)(v2 + 76) = 0x7FFFFFFF;
  return result;
}

re *RESyncDestroySyncObjectWriteContext(re *result)
{
  re *v1;
  uint64_t v2;
  double v3;

  if (result)
  {
    v1 = result;
    v2 = re::globalAllocators(result)[2];
    v3 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v1 + 5);
    return (re *)(*(uint64_t (**)(uint64_t, re *, double))(*(_QWORD *)v2 + 40))(v2, v1, v3);
  }
  return result;
}

uint64_t RESyncGetSyncObjectWriteContextRequiredSize()
{
  return 88;
}

uint64_t RESyncCreateSyncObjectWriteContextNoAlloc(uint64_t result, unint64_t a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (!result)
  {
    v2 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      return 0;
    v3 = 136315394;
    v4 = "RESyncCreateSyncObjectWriteContextNoAlloc";
    v5 = 2080;
    v6 = "bytes != __null";
LABEL_10:
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  if (a2 <= 0x57)
  {
    v2 = *re::networkLogObjects((re *)result);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      return 0;
    v3 = 136315394;
    v4 = "RESyncCreateSyncObjectWriteContextNoAlloc";
    v5 = 2080;
    v6 = "size >= sizeof(re::SyncObjectWriteContext)";
    goto LABEL_10;
  }
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_QWORD *)(result + 80) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)result = 0u;
  *(_DWORD *)(result + 76) = 0x7FFFFFFF;
  return result;
}

void RESyncDestroySyncObjectWriteContextNoDealloc(uint64_t a1)
{
  NSObject *v1;
  int v2;
  const char *v3;
  __int16 v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)(a1 + 40));
  }
  else
  {
    v1 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      v2 = 136315394;
      v3 = "RESyncDestroySyncObjectWriteContextNoDealloc";
      v4 = 2080;
      v5 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v1, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v2, 0x16u);
    }
  }
}

BOOL RESyncAddSyncObjectWriteContextEntry(re *a1, uint64_t a2, uint64_t a3)
{
  re *v3;
  NSObject *v4;
  _BOOL8 result;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v10 = (const char *)a3;
  v11 = a2;
  if (!a1)
  {
    v9 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v13 = "RESyncAddSyncObjectWriteContextEntry";
    v14 = 2080;
    v15 = "context != __null";
    v6 = "%s: Invalid parameter not satisfying %s.";
    goto LABEL_13;
  }
  if (!a2)
  {
    v9 = *re::networkLogObjects(a1);
    result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v13 = "RESyncAddSyncObjectWriteContextEntry";
    v14 = 2080;
    v15 = "entry != __null";
    v6 = "%s: Invalid parameter not satisfying %s.";
LABEL_13:
    v7 = v9;
    v8 = 22;
    goto LABEL_6;
  }
  v3 = (re *)re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>((uint64_t)a1 + 40, (uint64_t *)&v10, &v11);
  if (*(_QWORD *)v3 == v11)
    return 1;
  v4 = *re::networkLogObjects(v3);
  result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 134217984;
    v13 = v10;
    v6 = "RESyncAddSyncObjectWriteContextEntry: Failed to add entry using id=%llu, possible duplicate!";
    v7 = v4;
    v8 = 12;
LABEL_6:
    _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    return 0;
  }
  return result;
}

uint64_t RESyncGetSyncObjectWriteContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = (const char *)a2;
  if (a1)
  {
    v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 40, (uint64_t *)&v6);
    if (v2)
      return *(_QWORD *)v2;
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      v8 = v6;
      _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_INFO, "RESyncGetSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
    }
  }
  else
  {
    v5 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v8 = "RESyncGetSyncObjectWriteContextEntry";
      v9 = 2080;
      v10 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
  }
  return 0;
}

BOOL RESyncRemoveSyncObjectWriteContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 result;
  NSObject *v4;
  _BOOL4 v5;
  NSObject *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v7 = (const char *)a2;
  if (a1)
  {
    v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1 + 40, (uint64_t *)&v7);
    if ((v2 & 1) != 0)
      return 1;
    v4 = *re::networkLogObjects((re *)v2);
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v5)
    {
      *(_DWORD *)buf = 134217984;
      v9 = v7;
      _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "RESyncRemoveSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    v6 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_DWORD *)buf = 136315394;
      v9 = "RESyncRemoveSyncObjectWriteContextEntry";
      v10 = 2080;
      v11 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t RESyncObjectWriteContextGetSession(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 8);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncObjectWriteContextGetSession";
    v5 = 2080;
    v6 = "context != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncObjectWriteContextGetDestinationPeerID(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 16);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncObjectWriteContextGetDestinationPeerID";
    v5 = 2080;
    v6 = "context != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

BOOL RESyncObjectWriteContextSupportsProtocolLevelAlmond(uint64_t a1)
{
  return RESyncObjectWriteContextSupportsProtocolLevel(a1, 8);
}

BOOL RESyncObjectWriteContextSupportsProtocolLevel(uint64_t a1, int a2)
{
  _BOOL8 result;
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return (a2 & ~*(_DWORD *)(a1 + 32)) == 0;
  v3 = *re::networkLogObjects(0);
  result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v4 = 136315394;
    v5 = "RESyncObjectWriteContextSupportsProtocolLevel";
    v6 = 2080;
    v7 = "context != __null";
    _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v4, 0x16u);
    return 0;
  }
  return result;
}

BOOL RESyncObjectWriteContextSupportsProtocolLevelPistachio(uint64_t a1)
{
  return RESyncObjectWriteContextSupportsProtocolLevel(a1, 16);
}

BOOL RESyncObjectWriteContextSupportsProtocolLevelWalnut(uint64_t a1)
{
  return RESyncObjectWriteContextSupportsProtocolLevel(a1, 32);
}

BOOL RESyncObjectWriteContextIsLocalSession(uint64_t a1)
{
  _BOOL8 v1;
  NSObject *v3;
  _BYTE v4[12];
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(a1 + 8) + 32))(v4);
    v1 = *(_BYTE *)(*(_QWORD *)v4 + 2219) != 0;

  }
  else
  {
    v3 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v4 = 136315394;
      *(_QWORD *)&v4[4] = "RESyncObjectWriteContextIsLocalSession";
      v5 = 2080;
      v6 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", v4, 0x16u);
    }
    return 0;
  }
  return v1;
}

void re::DynamicArray<unsigned int>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<unsigned int>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2)
    {
      v5 = (void *)(*(_QWORD *)(a1 + 32) + 4 * v4);
      v6 = 4 * a2 - 4 * v4;
      if (v6 >= 1)
        bzero(v5, 4 * (((unint64_t)v6 >> 2) - ((unint64_t)v6 > 3)) + 4);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

re::SyncObjectShortIDManagerImpl *re::SyncObjectShortIDManagerImpl::SyncObjectShortIDManagerImpl(re::SyncObjectShortIDManagerImpl *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  int v7;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E071BF0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  *(_QWORD *)((char *)this + 60) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_QWORD *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 16) = 0;
  *(_QWORD *)(v2 + 120) = 0;
  *((_DWORD *)this + 34) = 1;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 1;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_DWORD *)this + 56) = 0;
  *((_QWORD *)this + 27) = 0;
  v3 = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::addUninitialized(v2 + 120);
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_DWORD *)(v3 + 44) = 127;
  re::DynamicArray<unsigned int>::resize(v3, 0x80uLL);
  v4 = *(_QWORD *)(v3 + 16);
  if (v4)
  {
    v5 = *(_DWORD **)(v3 + 32);
    v6 = 4 * v4;
    v7 = 127;
    do
    {
      *v5++ = v7--;
      v6 -= 4;
    }
    while (v6);
  }
  *(_QWORD *)re::BucketArray<unsigned long,4ul>::addUninitialized((uint64_t)this + 176) = 0;
  return this;
}

uint64_t re::SyncObjectShortIDManagerImpl::mapOutgoing(re::SyncObjectShortIDManagerImpl *this, unint64_t a2, unint64_t a3)
{
  char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v29;
  uint64_t result;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  _DWORD *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  uint64_t v40;
  uint64_t v41;

  v8 = *((_QWORD *)this + 3);
  v6 = (char *)this + 24;
  LODWORD(v7) = v8;
  v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v10 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
  v11 = ((v10 ^ (v10 >> 31)) + ((v9 ^ (v9 >> 31)) << 6) + ((v9 ^ (v9 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v9 ^ (v9 >> 31);
  if (v8)
  {
    v7 = v11 % *((unsigned int *)this + 12);
    v12 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v7);
    if ((_DWORD)v12 != 0x7FFFFFFF)
    {
      v20 = *((_QWORD *)this + 5);
      v21 = v20 + 40 * v12;
      v23 = *(_QWORD *)(v21 + 16);
      v22 = *(_QWORD *)(v21 + 24);
      if (v23 == a2 && v22 == a3)
      {
LABEL_19:
        v19 = v20 + 40 * v12;
        goto LABEL_20;
      }
      while (1)
      {
        LODWORD(v12) = *(_DWORD *)(v20 + 40 * v12 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v12 == 0x7FFFFFFF)
          break;
        v25 = v20 + 40 * v12;
        v27 = *(_QWORD *)(v25 + 16);
        v26 = *(_QWORD *)(v25 + 24);
        if (v27 == a2 && v26 == a3)
          goto LABEL_19;
      }
    }
  }
  v13 = *((unsigned int *)this + 15);
  if ((_DWORD)v13 == 0x7FFFFFFF)
  {
    v13 = *((unsigned int *)this + 14);
    v14 = v13;
    if ((_DWORD)v13 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::setCapacity((uint64_t)v6, 2 * *((_DWORD *)this + 13));
      LODWORD(v7) = v11 % *((unsigned int *)this + 12);
      v14 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v14 + 1;
    v15 = *((_QWORD *)this + 5);
    v16 = *(_DWORD *)(v15 + 40 * v13 + 8);
  }
  else
  {
    v15 = *((_QWORD *)this + 5);
    v16 = *(_DWORD *)(v15 + 40 * v13 + 8);
    *((_DWORD *)this + 15) = v16 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v15 + 40 * v13 + 8) = v16 | 0x80000000;
  v17 = *((_QWORD *)this + 4);
  *(_DWORD *)(*((_QWORD *)this + 5) + 40 * v13 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 40 * v13 + 8) & 0x80000000 | *(_DWORD *)(v17 + 4 * v7);
  *(_QWORD *)(*((_QWORD *)this + 5) + 40 * v13) = v11;
  v18 = *((_QWORD *)this + 5) + 40 * v13;
  *(_QWORD *)(v18 + 16) = a2;
  *(_QWORD *)(v18 + 24) = a3;
  *(_DWORD *)(*((_QWORD *)this + 5) + 40 * v13 + 32) = -1;
  *(_DWORD *)(v17 + 4 * v7) = v13;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
  v19 = *((_QWORD *)this + 5) + 40 * v13;
LABEL_20:
  v29 = (unsigned int *)(v19 + 32);
  result = *(unsigned int *)(v19 + 32);
  if ((_DWORD)result == -1)
  {
    v31 = *((_QWORD *)this + 27);
    if (v31)
      goto LABEL_26;
    v32 = *((_QWORD *)this + 20);
    v33 = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::addUninitialized((uint64_t)this + 120);
    *(_OWORD *)v33 = 0u;
    *(_OWORD *)(v33 + 16) = 0u;
    *(_QWORD *)(v33 + 32) = 0;
    v34 = ((_DWORD)v32 << 7) | 0x7F;
    *(_DWORD *)(v33 + 40) = (_DWORD)v32 << 7;
    *(_DWORD *)(v33 + 44) = v34;
    re::DynamicArray<unsigned int>::resize(v33, 0x80uLL);
    v35 = *(_QWORD *)(v33 + 16);
    if (v35)
    {
      v36 = *(_DWORD **)(v33 + 32);
      v37 = 4 * v35;
      do
      {
        *v36++ = v34--;
        v37 -= 4;
      }
      while (v37);
    }
    *(_QWORD *)re::BucketArray<unsigned long,4ul>::addUninitialized((uint64_t)this + 176) = v32;
    v31 = *((_QWORD *)this + 27);
    if (v31)
    {
LABEL_26:
      v39 = (unint64_t *)re::BucketArray<unsigned long,4ul>::operator[]((uint64_t)this + 176, v31 - 1);
      v40 = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[]((uint64_t)this + 120, *v39);
      v41 = *(_QWORD *)(v40 + 16) - 1;
      result = *(unsigned int *)(*(_QWORD *)(v40 + 32) + 4 * v41);
      *(_QWORD *)(v40 + 16) = v41;
      ++*(_DWORD *)(v40 + 24);
      *v29 = result;
      if (!v41)
      {
        re::BucketArray<unsigned long,4ul>::operator[]((uint64_t)this + 176, *((_QWORD *)this + 27) - 1);
        --*((_QWORD *)this + 27);
        ++*((_DWORD *)this + 56);
        return *v29;
      }
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v38, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 2)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 2)) + 48 * (a2 & 3);
}

uint64_t re::SyncObjectShortIDManagerImpl::unmapOutgoing(uint64_t this, unint64_t a2, unint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  char v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;

  if (*(_QWORD *)(this + 24))
  {
    v3 = this;
    v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
    v5 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v6 = (((v4 ^ (v4 >> 31)) + ((v5 ^ (v5 >> 31)) << 6) + ((v5 ^ (v5 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v5 ^ (v5 >> 31))
       % *(unsigned int *)(this + 48);
    v7 = *(_QWORD *)(this + 32);
    v8 = *(unsigned int *)(v7 + 4 * v6);
    if ((_DWORD)v8 != 0x7FFFFFFF)
    {
      v9 = *(_QWORD *)(this + 40);
      v10 = v9 + 40 * v8;
      v12 = *(_QWORD *)(v10 + 16);
      v11 = *(_QWORD *)(v10 + 24);
      v13 = v12 == a2 && v11 == a3;
      v14 = v13;
      if (v13)
      {
        v15 = (unsigned int *)(v9 + 40 * v8 + 32);
LABEL_12:
        *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v9 + 40 * v8 + 8) & 0x7FFFFFFF;
LABEL_13:
        v16 = *(_QWORD *)(this + 40);
        v17 = v16 + 40 * v8;
        v20 = *(_DWORD *)(v17 + 8);
        v19 = (int *)(v17 + 8);
        v18 = v20;
        if (v20 < 0)
        {
          *v19 = v18 & 0x7FFFFFFF;
          v16 = *(_QWORD *)(this + 40);
          v18 = *(_DWORD *)(v16 + 40 * v8 + 8);
        }
        v21 = *(_DWORD *)(this + 64);
        *(_DWORD *)(v16 + 40 * v8 + 8) = *(_DWORD *)(this + 60) | v18 & 0x80000000;
        --*(_DWORD *)(this + 52);
        *(_DWORD *)(this + 60) = v8;
        *(_DWORD *)(this + 64) = v21 + 1;
LABEL_16:
        v22 = (unint64_t)*v15 >> 7;
        this = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[](this + 120, v22);
        v23 = this;
        v24 = *v15;
        v25 = *(_QWORD *)(this + 8);
        v26 = *(_QWORD *)(this + 16);
        v27 = v26;
        if (v26 >= v25)
        {
          if (v25 < v26 + 1)
          {
            if (*(_QWORD *)this)
            {
              v28 = 2 * v25;
              v13 = v25 == 0;
              v29 = 8;
              if (!v13)
                v29 = v28;
              if (v29 <= v26 + 1)
                v30 = v26 + 1;
              else
                v30 = v29;
              this = (uint64_t)re::DynamicArray<unsigned int>::setCapacity((_QWORD *)this, v30);
            }
            else
            {
              this = (uint64_t)re::DynamicArray<unsigned int>::setCapacity((_QWORD *)v23, v26 + 1);
              ++*(_DWORD *)(v23 + 24);
            }
          }
          v27 = *(_QWORD *)(v23 + 16);
        }
        *(_DWORD *)(*(_QWORD *)(v23 + 32) + 4 * v27) = v24;
        *(_QWORD *)(v23 + 16) = v27 + 1;
        ++*(_DWORD *)(v23 + 24);
        if (!v26)
        {
          v41 = v3 + 176;
          v42 = *(_QWORD *)(v3 + 216);
          this = re::BucketArray<unsigned long,4ul>::addUninitialized(v41);
          *(_QWORD *)this = v22;
          if (v42)
          {
            do
            {
              v43 = v42 - 1;
              this = re::BucketArray<unsigned long,4ul>::operator[](v41, v42 - 1);
              if (*(_QWORD *)this >= v22)
                break;
              v44 = *(_QWORD *)re::BucketArray<unsigned long,4ul>::operator[](v41, v42 - 1);
              *(_QWORD *)re::BucketArray<unsigned long,4ul>::operator[](v41, v42) = v44;
              this = re::BucketArray<unsigned long,4ul>::operator[](v41, v42 - 1);
              *(_QWORD *)this = v22;
              --v42;
            }
            while (v43);
          }
        }
      }
      else
      {
        while (1)
        {
          v31 = *(_DWORD *)(v9 + 40 * *(unsigned int *)(v7 + 4 * v6) + 8) & 0x7FFFFFFF;
          if (v31 == 0x7FFFFFFF)
            break;
          v32 = v9 + 40 * v31;
          v34 = *(_QWORD *)(v32 + 16);
          v33 = *(_QWORD *)(v32 + 24);
          if (v34 == a2 && v33 == a3)
          {
            v15 = (unsigned int *)(v9 + 40 * v31 + 32);
            if ((v14 & 1) != 0)
              goto LABEL_12;
            while (1)
            {
              v36 = v8;
              LODWORD(v8) = *(_DWORD *)(v9 + 40 * v8 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v8 == 0x7FFFFFFF)
                goto LABEL_16;
              v37 = v9 + 40 * v8;
              v39 = *(_QWORD *)(v37 + 16);
              v38 = *(_QWORD *)(v37 + 24);
              if (v39 == a2 && v38 == a3)
              {
                *(_DWORD *)(v9 + 40 * v36 + 8) = *(_DWORD *)(v9 + 40 * v36 + 8) & 0x80000000 | *(_DWORD *)(v9 + 40 * v8 + 8) & 0x7FFFFFFF;
                goto LABEL_13;
              }
            }
          }
        }
      }
    }
  }
  return this;
}

uint64_t re::BucketArray<unsigned long,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 2)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 2)) + 8 * (a2 & 3);
}

void re::SyncObjectShortIDManagerImpl::mapIncoming(re::SyncObjectShortIDManagerImpl *this, unsigned int a2, uint64_t a3, uint64_t a4)
{
  char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;

  v10 = *((_QWORD *)this + 9);
  v8 = (char *)this + 72;
  LODWORD(v9) = v10;
  v11 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  v12 = (0x94D049BB133111EBLL * (v11 ^ (v11 >> 27))) ^ ((0x94D049BB133111EBLL * (v11 ^ (v11 >> 27))) >> 31);
  if (v10)
  {
    v9 = v12 % *((unsigned int *)this + 24);
    v13 = *(unsigned int *)(*((_QWORD *)this + 10) + 4 * v9);
    if ((_DWORD)v13 != 0x7FFFFFFF)
    {
      v21 = *((_QWORD *)this + 11);
      if (*(_DWORD *)(v21 + 32 * v13 + 12) == a2)
      {
LABEL_12:
        v20 = v21 + 32 * v13;
        goto LABEL_13;
      }
      while (1)
      {
        v13 = *(_DWORD *)(v21 + 32 * v13 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v13 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v21 + 32 * v13 + 12) == a2)
          goto LABEL_12;
      }
    }
  }
  v14 = *((unsigned int *)this + 27);
  if ((_DWORD)v14 == 0x7FFFFFFF)
  {
    v14 = *((unsigned int *)this + 26);
    v15 = v14;
    if ((_DWORD)v14 == *((_DWORD *)this + 24))
    {
      re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity((uint64_t)v8, 2 * *((_DWORD *)this + 25));
      LODWORD(v9) = v12 % *((unsigned int *)this + 24);
      v15 = *((_DWORD *)this + 26);
    }
    *((_DWORD *)this + 26) = v15 + 1;
    v16 = *((_QWORD *)this + 11);
    v17 = *(_DWORD *)(v16 + 32 * v14 + 8);
  }
  else
  {
    v16 = *((_QWORD *)this + 11);
    v17 = *(_DWORD *)(v16 + 32 * v14 + 8);
    *((_DWORD *)this + 27) = v17 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v16 + 32 * v14 + 8) = v17 | 0x80000000;
  v18 = *((_QWORD *)this + 10);
  *(_DWORD *)(*((_QWORD *)this + 11) + 32 * v14 + 8) = *(_DWORD *)(*((_QWORD *)this + 11) + 32 * v14 + 8) & 0x80000000 | *(_DWORD *)(v18 + 4 * v9);
  *(_QWORD *)(*((_QWORD *)this + 11) + 32 * v14) = v12;
  *(_DWORD *)(*((_QWORD *)this + 11) + 32 * v14 + 12) = a2;
  v19 = *((_QWORD *)this + 11) + 32 * v14;
  *(_QWORD *)(v19 + 16) = a3;
  *(_QWORD *)(v19 + 24) = a4;
  *(_DWORD *)(v18 + 4 * v9) = v14;
  ++*((_DWORD *)this + 25);
  ++*((_DWORD *)this + 28);
  v20 = *((_QWORD *)this + 11) + 32 * v14;
LABEL_13:
  v23 = *(_QWORD *)(v20 + 16);
  v22 = (_QWORD *)(v20 + 16);
  if (v23 != a3 || v22[1] != a4)
  {
    *v22 = a3;
    v22[1] = a4;
  }
}

uint64_t re::SyncObjectShortIDManagerImpl::mapIncoming(re::SyncObjectShortIDManagerImpl *this, unsigned int a2)
{
  uint64_t result;

  result = re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)this + 72, a2);
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v5 + 32 * v3 + 12) != a2)
  {
    while (1)
    {
      v3 = *(_DWORD *)(v5 + 32 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_DWORD *)(v5 + 32 * v3 + 12) == a2)
        return v5 + 32 * v3 + 16;
    }
    return 0;
  }
  return v5 + 32 * v3 + 16;
}

_QWORD *re::SyncObjectShortIDManagerImpl::unmapIncoming(re::SyncObjectShortIDManagerImpl *this, unsigned int a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int *v21;
  int v22;
  int v23;

  v8 = (_QWORD *)((char *)this + 72);
  result = (_QWORD *)re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)this + 72, a2);
  if (result)
  {
    if (*result == a3 && result[1] == a4)
    {
      if (*v8)
      {
        v10 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
        v11 = ((0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) ^ ((0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) >> 31))
            % *((unsigned int *)this + 24);
        v12 = *((_QWORD *)this + 10);
        v13 = *(unsigned int *)(v12 + 4 * v11);
        if ((_DWORD)v13 != 0x7FFFFFFF)
        {
          v14 = *((_QWORD *)this + 11);
          v15 = v14 + 32 * v13;
          if (*(_DWORD *)(v15 + 12) == a2)
          {
            *(_DWORD *)(v12 + 4 * v11) = *(_DWORD *)(v15 + 8) & 0x7FFFFFFF;
LABEL_11:
            v18 = *((_QWORD *)this + 11);
            v19 = v18 + 32 * v13;
            v22 = *(_DWORD *)(v19 + 8);
            v21 = (int *)(v19 + 8);
            v20 = v22;
            if (v22 < 0)
            {
              *v21 = v20 & 0x7FFFFFFF;
              v18 = *((_QWORD *)this + 11);
              v20 = *(_DWORD *)(v18 + 32 * v13 + 8);
            }
            v23 = *((_DWORD *)this + 28);
            *(_DWORD *)(v18 + 32 * v13 + 8) = *((_DWORD *)this + 27) | v20 & 0x80000000;
            --*((_DWORD *)this + 25);
            *((_DWORD *)this + 27) = v13;
            *((_DWORD *)this + 28) = v23 + 1;
          }
          else
          {
            while (1)
            {
              v16 = v13;
              v13 = *(_DWORD *)(v14 + 32 * v13 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v13 == 0x7FFFFFFF)
                break;
              v17 = v14 + 32 * v13;
              if (*(_DWORD *)(v17 + 12) == a2)
              {
                *(_DWORD *)(v14 + 32 * v16 + 8) = *(_DWORD *)(v14 + 32 * v16 + 8) & 0x80000000 | *(_DWORD *)(v17 + 8) & 0x7FFFFFFF;
                goto LABEL_11;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void re::SyncObjectShortIDManagerImpl::~SyncObjectShortIDManagerImpl(re::SyncObjectShortIDManagerImpl *this)
{
  char *v2;

  v2 = (char *)this + 176;
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 176);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)v2);
  re::BucketArray<re::SyncObjectShortIDBlock,4ul>::deinit((uint64_t)this + 120);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)this + 120);
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;

  v2 = (char *)this + 176;
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 176);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)v2);
  re::BucketArray<re::SyncObjectShortIDBlock,4ul>::deinit((uint64_t)this + 120);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)this + 120);
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t re::BucketArray<unsigned long,4ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
      re::BucketArray<unsigned long,4ul>::operator[](a1, i);
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<unsigned long,4ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<unsigned long *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::freeElementBucket(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t result;
  int v5;

  v2 = *a1;
  if ((a1[2] & 1) != 0)
    v3 = a1 + 3;
  else
    v3 = (uint64_t *)a1[4];
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3[a1[1] - 1]);
  v5 = *((_DWORD *)a1 + 4);
  --a1[1];
  *((_DWORD *)a1 + 4) = v5 + 2;
  return result;
}

uint64_t re::DynamicOverflowArray<unsigned long *,2ul>::deinit(uint64_t a1)
{
  uint64_t result;
  int v3;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_DWORD *)(a1 + 16);
    if ((v3 & 1) == 0)
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(a1 + 32));
      v3 = *(_DWORD *)(a1 + 16);
    }
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = (v3 | 1) + 2;
  }
  return result;
}

uint64_t re::BucketArray<re::SyncObjectShortIDBlock,4ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  _QWORD *v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (_QWORD *)re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[](a1, i);
      if (*v4)
      {
        if (v4[4])
          (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 40))(*v4);
        v4[4] = 0;
        v4[1] = 0;
        v4[2] = 0;
        *v4 = 0;
        ++*((_DWORD *)v4 + 6);
      }
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<unsigned long,4ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<unsigned long *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 40 * v3;
      do
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 40;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

_QWORD *re::DynamicArray<unsigned int>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 62)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 4, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 4 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 4 * a2, 4);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 4 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<unsigned int>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::BucketArray<re::SyncObjectShortIDBlock,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::SyncObjectShortIDBlock,4ul>::setBucketsCapacity((_QWORD *)a1, (v2 + 4) >> 2);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 2));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 48 * (v2 & 3);
}

_QWORD *re::BucketArray<re::SyncObjectShortIDBlock,4ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<unsigned long,4ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 192, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    result = (_QWORD *)re::BucketArray<re::SyncObjectShortIDBlock,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

_QWORD *re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  void *v14;
  uint64_t v15;
  const void *v16;
  int v17;

  v4 = result;
  v5 = *result;
  if (a2 && !v5)
  {
    result = (_QWORD *)re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v4, a2);
    v6 = *((_DWORD *)v4 + 4) + 2;
LABEL_4:
    *((_DWORD *)v4 + 4) = v6;
    return result;
  }
  v7 = *((_DWORD *)result + 4);
  if ((v7 & 1) != 0)
    v8 = 2;
  else
    v8 = result[3];
  if (v8 != a2)
  {
    v9 = result[1];
    if (v9 <= a2 && (a2 > 2 || (v7 & 1) == 0))
    {
      if (a2 < 3)
      {
        v14 = result + 3;
        v15 = v4[4];
        if ((v7 & 1) != 0)
          v16 = v4 + 3;
        else
          v16 = (const void *)v4[4];
        memcpy(v14, v16, 8 * v9);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v15);
        v6 = *((_DWORD *)v4 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        v2 = 8 * a2;
        v10 = (void *)(*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)v5 + 32))(*result, 8 * a2, 8);
        if (v10)
        {
          v12 = v10;
          if ((v4[2] & 1) != 0)
            v13 = v4 + 3;
          else
            v13 = (const void *)v4[4];
          result = memcpy(v10, v13, 8 * v4[1]);
          v17 = *((_DWORD *)v4 + 4);
          if ((v17 & 1) == 0)
          {
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[4]);
            v17 = *((_DWORD *)v4 + 4);
          }
          *((_DWORD *)v4 + 4) = v17 & 0xFFFFFFFE;
          v4[3] = a2;
          v4[4] = v12;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(_QWORD *)(*v4 + 8));
      result = (_QWORD *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<unsigned long,4ul>::setBucketsCapacity((_QWORD *)a1, (v2 + 4) >> 2);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 2));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 3);
}

_QWORD *re::BucketArray<unsigned long,4ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<unsigned long,4ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 32, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    result = (_QWORD *)re::BucketArray<unsigned long,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

unint64_t re::Hash<re::Pair<unsigned long long,unsigned long long,true>>::operator()(uint64_t a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  v3 = (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
  v4 = 0xBF58476D1CE4E5B9 * (a2[1] ^ (a2[1] >> 30));
  return (((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
        + (v3 << 6)
        + (v3 >> 2)
        - 0x61C8864680B583E9) ^ v3;
}

void re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = v6 + 16;
        do
        {
          if ((*(_DWORD *)(v13 - 8) & 0x80000000) != 0)
          {
            v14 = *(_QWORD *)(v13 - 16);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 40 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17) = v14;
            *(_OWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17 + 16) = *(_OWORD *)v13;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17 + 32) = *(_DWORD *)(v13 + 16);
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 40;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

void re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _OWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_OWORD *)(v6 + 16);
        do
        {
          if ((*((_DWORD *)v13 - 2) & 0x80000000) != 0)
          {
            v14 = *((_QWORD *)v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17) = v14;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 12) = *((_DWORD *)v13 - 1);
            *(_OWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 16) = *v13;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 2;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

char *PacketUtils::move(PacketUtils *this, re::PacketPool **a2, re::PacketPool **a3, re::Transport *a4)
{
  PacketUtils *v4;
  char *v6;
  uint64_t v7;

  v4 = this;
  if (a2 != a3)
  {
    v6 = re::PacketPool::allocate(a3[48], (*((_DWORD *)this + 6) + 3));
    re::Packet::offsetBy((uint64_t)v6, 3);
    v7 = *((_QWORD *)v6 + 1);
    *(_BYTE *)(v7 + 2) = 0;
    *(_WORD *)v7 = 0;
    *((_DWORD *)v6 + 6) = *((_DWORD *)v4 + 6);
    memcpy(*((void **)v6 + 2), *((const void **)v4 + 2), *((unsigned int *)v4 + 6));
    re::PacketPool::free(a2[48], v4);
    return v6;
  }
  return (char *)v4;
}

void re::Session::~Session(re::Session *this)
{
  uint64_t v2;
  __n128 v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;

  *(_QWORD *)this = &off_24E071E80;
  *((_QWORD *)this + 3) = &unk_24E071F18;
  if (*((_BYTE *)this + 2272))
    re::Session::deinit(this);
  v2 = 0;
  *((_QWORD *)this + 941) = &off_24E072450;
  do
  {
    v3.n128_f64[0] = re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)((char *)this + v2 + 7592));
    v2 -= 48;
  }
  while (v2 != -96);
  v4 = *((_QWORD *)this + 940);
  if (v4)
  {

    *((_QWORD *)this + 940) = 0;
  }
  v5 = (uint64_t *)((char *)this + 7432);
  v6 = *((_QWORD *)this + 929);
  if (v6)
  {
    if (*((_QWORD *)this + 933))
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v6 + 40))(v6, v3);
    *((_QWORD *)this + 933) = 0;
    *((_QWORD *)this + 930) = 0;
    *((_QWORD *)this + 931) = 0;
    *v5 = 0;
    ++*((_DWORD *)this + 1864);
  }
  v7 = *((_QWORD *)this + 934);
  if (v7)
  {
    if (*((_QWORD *)this + 938))
    {
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v7 + 40))(v7, v3);
      v8 = *v5;
    }
    else
    {
      v8 = 0;
    }
    *((_QWORD *)this + 938) = 0;
    *((_QWORD *)this + 935) = 0;
    *((_QWORD *)this + 936) = 0;
    *((_QWORD *)this + 934) = 0;
    ++*((_DWORD *)this + 1874);
    if (v8)
    {
      if (*((_QWORD *)this + 933))
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
      *((_QWORD *)this + 933) = 0;
      *((_QWORD *)this + 930) = 0;
      *((_QWORD *)this + 931) = 0;
      *v5 = 0;
      ++*((_DWORD *)this + 1864);
    }
  }
  v9 = *((_QWORD *)this + 928);
  if (v9)
  {

    *((_QWORD *)this + 928) = 0;
  }
  v10 = *((_QWORD *)this + 403);
  if (v10)
  {
    if (*((_QWORD *)this + 407))
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v10 + 40))(v10, v3);
    *((_QWORD *)this + 407) = 0;
    *((_QWORD *)this + 404) = 0;
    *((_QWORD *)this + 405) = 0;
    *((_QWORD *)this + 403) = 0;
    ++*((_DWORD *)this + 812);
  }
  v11 = *((_QWORD *)this + 398);
  if (v11)
  {
    if (*((_QWORD *)this + 402))
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v11 + 40))(v11, v3);
    *((_QWORD *)this + 402) = 0;
    *((_QWORD *)this + 399) = 0;
    *((_QWORD *)this + 400) = 0;
    *((_QWORD *)this + 398) = 0;
    ++*((_DWORD *)this + 802);
  }
  re::DynamicArray<re::Session::BacklogItem>::deinit((uint64_t)this + 3144);
  v12 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 386);
  v13 = *((_QWORD *)this + 381);
  if (v13)
  {
    if (*((_QWORD *)this + 385))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v13 + 40))(v13, v12);
    *((_QWORD *)this + 385) = 0;
    *((_QWORD *)this + 382) = 0;
    *((_QWORD *)this + 383) = 0;
    *((_QWORD *)this + 381) = 0;
    ++*((_DWORD *)this + 768);
  }
  v14 = *((_QWORD *)this + 380);
  if (v14)
  {

    *((_QWORD *)this + 380) = 0;
  }
  re::Transport::~Transport((re::Session *)((char *)this + 2320), v12);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 2280);
  v15 = *((_QWORD *)this + 282);
  if (v15)
  {

    *((_QWORD *)this + 282) = 0;
  }
  v16 = *((_QWORD *)this + 281);
  if (v16)
  {

    *((_QWORD *)this + 281) = 0;
  }
  v17 = *((_QWORD *)this + 276);
  if (v17)
  {

    *((_QWORD *)this + 276) = 0;
  }
  v18 = *((_QWORD *)this + 272);
  if (v18)
  {

    *((_QWORD *)this + 272) = 0;
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 257);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 246);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 235);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 224);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 213);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 202);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 191);
  v19 = (uint64_t *)((char *)this + 1440);
  v20 = *((_QWORD *)this + 180);
  if (v20)
  {
    if (*((_QWORD *)this + 184))
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
    *((_QWORD *)this + 184) = 0;
    *((_QWORD *)this + 181) = 0;
    *((_QWORD *)this + 182) = 0;
    *v19 = 0;
    ++*((_DWORD *)this + 366);
  }
  v21 = *((_QWORD *)this + 185);
  if (v21)
  {
    if (*((_QWORD *)this + 189))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 40))(v21);
      v22 = *v19;
    }
    else
    {
      v22 = 0;
    }
    *((_QWORD *)this + 189) = 0;
    *((_QWORD *)this + 186) = 0;
    *((_QWORD *)this + 187) = 0;
    *((_QWORD *)this + 185) = 0;
    ++*((_DWORD *)this + 376);
    if (v22)
    {
      if (*((_QWORD *)this + 184))
        (*(void (**)(uint64_t))(*(_QWORD *)v22 + 40))(v22);
      *((_QWORD *)this + 184) = 0;
      *((_QWORD *)this + 181) = 0;
      *((_QWORD *)this + 182) = 0;
      *v19 = 0;
      ++*((_DWORD *)this + 366);
    }
  }
  v23 = 880;
  do
  {
    v24 = (_QWORD *)((char *)this + v23);
    v25 = (_QWORD *)((char *)this + v23 + 472);
    if (*v25)
    {
      if (v24[63])
        (*(void (**)(_QWORD))(*(_QWORD *)*v25 + 40))(*v25);
      v24[63] = 0;
      *(_QWORD *)((char *)this + v23 + 480) = 0;
      *(_QWORD *)((char *)this + v23 + 488) = 0;
      *v25 = 0;
      ++*(_DWORD *)((char *)this + v23 + 496);
    }
    v26 = v24[64];
    if (v26)
    {
      v27 = (char *)this + v23;
      if (*(_QWORD *)((char *)this + v23 + 544))
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v26 + 40))(v26);
        v28 = *v25;
      }
      else
      {
        v28 = 0;
      }
      *((_QWORD *)v27 + 68) = 0;
      v24[65] = 0;
      v24[66] = 0;
      v24[64] = 0;
      ++*((_DWORD *)v27 + 134);
      if (v28)
      {
        v29 = (char *)this + v23;
        if (*(_QWORD *)((char *)this + v23 + 504))
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 40))(v28);
        *((_QWORD *)v29 + 63) = 0;
        *(_QWORD *)((char *)this + v23 + 480) = 0;
        *(_QWORD *)((char *)this + v23 + 488) = 0;
        *v25 = 0;
        ++*((_DWORD *)v29 + 124);
      }
    }
    v23 -= 88;
  }
  while (v23);
  v30 = (uint64_t *)((char *)this + 472);
  v31 = *((_QWORD *)this + 59);
  if (v31)
  {
    if (*((_QWORD *)this + 63))
      (*(void (**)(uint64_t))(*(_QWORD *)v31 + 40))(v31);
    *((_QWORD *)this + 63) = 0;
    *((_QWORD *)this + 60) = 0;
    *((_QWORD *)this + 61) = 0;
    *v30 = 0;
    ++*((_DWORD *)this + 124);
  }
  v32 = *((_QWORD *)this + 64);
  if (v32)
  {
    if (*((_QWORD *)this + 68))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v32 + 40))(v32);
      v33 = *v30;
    }
    else
    {
      v33 = 0;
    }
    *((_QWORD *)this + 68) = 0;
    *((_QWORD *)this + 65) = 0;
    *((_QWORD *)this + 66) = 0;
    *((_QWORD *)this + 64) = 0;
    ++*((_DWORD *)this + 134);
    if (v33)
    {
      if (*((_QWORD *)this + 63))
        (*(void (**)(uint64_t))(*(_QWORD *)v33 + 40))(v33);
      *((_QWORD *)this + 63) = 0;
      *((_QWORD *)this + 60) = 0;
      *((_QWORD *)this + 61) = 0;
      *v30 = 0;
      ++*((_DWORD *)this + 124);
    }
  }
  v34 = (uint64_t *)((char *)this + 384);
  v35 = *((_QWORD *)this + 48);
  if (v35)
  {
    if (*((_QWORD *)this + 52))
      (*(void (**)(uint64_t))(*(_QWORD *)v35 + 40))(v35);
    *((_QWORD *)this + 52) = 0;
    *((_QWORD *)this + 49) = 0;
    *((_QWORD *)this + 50) = 0;
    *v34 = 0;
    ++*((_DWORD *)this + 102);
  }
  v36 = *((_QWORD *)this + 53);
  if (v36)
  {
    if (*((_QWORD *)this + 57))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v36 + 40))(v36);
      v37 = *v34;
    }
    else
    {
      v37 = 0;
    }
    *((_QWORD *)this + 57) = 0;
    *((_QWORD *)this + 54) = 0;
    *((_QWORD *)this + 55) = 0;
    *((_QWORD *)this + 53) = 0;
    ++*((_DWORD *)this + 112);
    if (v37)
    {
      if (*((_QWORD *)this + 52))
        (*(void (**)(uint64_t))(*(_QWORD *)v37 + 40))(v37);
      *((_QWORD *)this + 52) = 0;
      *((_QWORD *)this + 49) = 0;
      *((_QWORD *)this + 50) = 0;
      *v34 = 0;
      ++*((_DWORD *)this + 102);
    }
  }
  v38 = (uint64_t *)((char *)this + 296);
  v39 = *((_QWORD *)this + 37);
  if (v39)
  {
    if (*((_QWORD *)this + 41))
      (*(void (**)(uint64_t))(*(_QWORD *)v39 + 40))(v39);
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 39) = 0;
    *v38 = 0;
    ++*((_DWORD *)this + 80);
  }
  v40 = *((_QWORD *)this + 42);
  if (v40)
  {
    if (*((_QWORD *)this + 46))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v40 + 40))(v40);
      v41 = *v38;
    }
    else
    {
      v41 = 0;
    }
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 44) = 0;
    *((_QWORD *)this + 42) = 0;
    ++*((_DWORD *)this + 90);
    if (v41)
    {
      if (*((_QWORD *)this + 41))
        (*(void (**)(uint64_t))(*(_QWORD *)v41 + 40))(v41);
      *((_QWORD *)this + 41) = 0;
      *((_QWORD *)this + 38) = 0;
      *((_QWORD *)this + 39) = 0;
      *v38 = 0;
      ++*((_DWORD *)this + 80);
    }
  }
  v43 = (uint64_t *)((char *)this + 208);
  v42 = *((_QWORD *)this + 26);
  if (v42)
  {
    if (*((_QWORD *)this + 30))
      (*(void (**)(uint64_t))(*(_QWORD *)v42 + 40))(v42);
    *((_QWORD *)this + 30) = 0;
    *((_QWORD *)this + 27) = 0;
    *((_QWORD *)this + 28) = 0;
    *v43 = 0;
    ++*((_DWORD *)this + 58);
  }
  v44 = *((_QWORD *)this + 31);
  if (v44)
  {
    if (*((_QWORD *)this + 35))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v44 + 40))(v44);
      v45 = *v43;
    }
    else
    {
      v45 = 0;
    }
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    *((_QWORD *)this + 31) = 0;
    ++*((_DWORD *)this + 68);
    if (v45)
    {
      if (*((_QWORD *)this + 30))
        (*(void (**)(uint64_t))(*(_QWORD *)v45 + 40))(v45);
      *((_QWORD *)this + 30) = 0;
      *((_QWORD *)this + 27) = 0;
      *((_QWORD *)this + 28) = 0;
      *v43 = 0;
      ++*((_DWORD *)this + 58);
    }
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 15);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 4);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::Session::~Session(this);
  JUMPOUT(0x220780CD0);
}

BOOL re::Session::init(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  id v7;
  __int128 v8;
  __int128 v9;
  _anonymous_namespace_ **v10;
  re *v11;
  uint64_t *v12;
  _anonymous_namespace_ *v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  _anonymous_namespace_ *v19;
  _anonymous_namespace_ *v20;
  _anonymous_namespace_ *v21;
  _anonymous_namespace_ *v22;
  _anonymous_namespace_ *v23;
  _anonymous_namespace_ *v24;
  _anonymous_namespace_ *v25;
  _anonymous_namespace_ *v26;
  _anonymous_namespace_ *v27;
  _anonymous_namespace_ *v28;
  _anonymous_namespace_ *v29;
  uint64_t v30;
  uint64_t v31;
  _anonymous_namespace_ *v32;
  _anonymous_namespace_ *v33;
  _anonymous_namespace_ *v34;
  _anonymous_namespace_ *v35;
  _anonymous_namespace_ *v36;
  re *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  re *v44;
  const char *v45;
  NSObject *v46;
  re *v47;
  NSObject *v48;
  uint64_t v49;
  const char *v50;
  _anonymous_namespace_ *v51;
  double v52;
  _anonymous_namespace_ *v53;
  _BOOL8 v54;
  _BOOL8 v55;
  uint64_t *v56;
  re::RoutingTable *v57;
  _anonymous_namespace_ *v58;
  uint64_t v59;
  int v60;
  int v61;
  re *v62;
  uint64_t *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  re *v67;
  NSObject *v68;
  unsigned int v69;
  unsigned int v70;
  re *v71;
  NSObject *v72;
  _BOOL8 v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  NSObject *v79;
  NSObject *v80;
  uint64_t v82;
  char v83[4];
  int v84;
  char v85[4];
  int v86;
  __int128 v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  _BYTE buf[18];
  __int16 v92;
  int v93;
  _OWORD v94[3];
  __int128 v95;
  __int16 v96;
  uint64_t v97;
  uint8_t v98[8];
  uint64_t (*v99)(re *, uint64_t, uint64_t *);
  uint64_t v100;
  uint64_t (*v101)(uint64_t, _QWORD *, uint64_t *);
  uint64_t v102;

  v102 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  *(_OWORD *)(a1 + 2160) = a2[1];
  *(_OWORD *)(a1 + 2144) = v4;
  v5 = *((_QWORD *)a2 + 4);
  v6 = *(_QWORD *)(a1 + 2176);
  if (v6 != v5)
  {
    if (v5)
    {
      v7 = (id)(v5 + 8);
      v6 = *(_QWORD *)(a1 + 2176);
    }
    if (v6)

    *(_QWORD *)(a1 + 2176) = v5;
  }
  v8 = *(__int128 *)((char *)a2 + 40);
  *(_QWORD *)(a1 + 2200) = *((_QWORD *)a2 + 7);
  *(_OWORD *)(a1 + 2184) = v8;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 2208), *((_QWORD *)a2 + 8));
  v9 = *(__int128 *)((char *)a2 + 72);
  *(_OWORD *)(a1 + 2228) = *(__int128 *)((char *)a2 + 84);
  *(_OWORD *)(a1 + 2216) = v9;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 2248), *((_QWORD *)a2 + 13));
  v10 = (_anonymous_namespace_ **)(a1 + 2256);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 2256), *((_QWORD *)a2 + 14));
  *(_DWORD *)(a1 + 2264) = *((_DWORD *)a2 + 30);
  if (!*(_QWORD *)(a1 + 2256))
  {
    v12 = re::globalAllocators(v11);
    v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12[2] + 32))(v12[2], 24, 8);
    *((_QWORD *)v13 + 1) = 0;
    *((_QWORD *)v13 + 2) = 0;
    *(_QWORD *)v13 = 0;
    ArcSharedObject::ArcSharedObject(v13, 0);
    *(_QWORD *)v13 = &off_24E0716F0;
    v14 = *v10;
    *v10 = v13;
    if (v14)

  }
  v15 = *(_QWORD *)(a1 + 2176);
  if (v15)
  {
    v16 = (id)(v15 + 8);
    v17 = v15;
  }
  else
  {
    re::make::shared::object<re::LeaderElectionLowestPeerID>(v11, &v90);
    v17 = v90;
    v90 = 0;
  }
  v18 = *(_QWORD *)(a1 + 7424);
  *(_QWORD *)(a1 + 7424) = v17;
  if (v18)

  if (!v15 && v90)
  v19 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 7424) + 104))(*(_QWORD *)(a1 + 7424), a1);
  *(_DWORD *)(a1 + 3032) = 1;
  v20 = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity((_QWORD *)(a1 + 2280), 0x80uLL);
  ++*(_DWORD *)(a1 + 2304);
  v21 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 32), 0);
  ++*(_DWORD *)(a1 + 56);
  v22 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 120), 0);
  ++*(_DWORD *)(a1 + 144);
  v23 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 208), 0);
  ++*(_DWORD *)(a1 + 232);
  v24 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 296), 0);
  ++*(_DWORD *)(a1 + 320);
  v25 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 384), 0);
  ++*(_DWORD *)(a1 + 408);
  v26 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 1528), 0);
  ++*(_DWORD *)(a1 + 1552);
  v27 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 472), 0);
  ++*(_DWORD *)(a1 + 496);
  v28 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 1440), 0);
  ++*(_DWORD *)(a1 + 1464);
  v29 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 1704), 0);
  ++*(_DWORD *)(a1 + 1728);
  v30 = 560;
  do
  {
    v31 = a1 + v30;
    v29 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + v30), 0);
    ++*(_DWORD *)(v31 + 24);
    v30 += 88;
  }
  while (v31 + 88 != a1 + 1440);
  v32 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 1616), 0);
  ++*(_DWORD *)(a1 + 1640);
  v33 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 1792), 0);
  ++*(_DWORD *)(a1 + 1816);
  v34 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 1880), 0);
  ++*(_DWORD *)(a1 + 1904);
  v35 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 1968), 0);
  ++*(_DWORD *)(a1 + 1992);
  v36 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 2056), 0);
  ++*(_DWORD *)(a1 + 2080);
  v37 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 7432), 0);
  ++*(_DWORD *)(a1 + 7456);
  v38 = *(_QWORD *)(a1 + 2256);
  if (v38)
    v37 = (re *)(id)(v38 + 8);
  v39 = 100000000;
  v40 = re::globalAllocators(v37);
  v41 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v40[2] + 32))(v40[2], 312, 8);
  *(_OWORD *)v41 = 0u;
  *(_OWORD *)(v41 + 16) = 0u;
  *(_OWORD *)(v41 + 32) = 0u;
  *(_OWORD *)(v41 + 48) = 0u;
  *(_OWORD *)(v41 + 64) = 0u;
  *(_OWORD *)(v41 + 80) = 0u;
  *(_OWORD *)(v41 + 96) = 0u;
  *(_OWORD *)(v41 + 112) = 0u;
  *(_OWORD *)(v41 + 128) = 0u;
  *(_OWORD *)(v41 + 144) = 0u;
  *(_OWORD *)(v41 + 160) = 0u;
  *(_OWORD *)(v41 + 176) = 0u;
  *(_OWORD *)(v41 + 192) = 0u;
  *(_OWORD *)(v41 + 208) = 0u;
  *(_OWORD *)(v41 + 224) = 0u;
  *(_OWORD *)(v41 + 240) = 0u;
  *(_OWORD *)(v41 + 256) = 0u;
  *(_OWORD *)(v41 + 272) = 0u;
  *(_OWORD *)(v41 + 288) = 0u;
  *(_QWORD *)(v41 + 304) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v41, 0);
  *(_QWORD *)v41 = &off_24E0736F0;
  *(_BYTE *)(v41 + 24) = 0;
  *(_QWORD *)(v41 + 32) = 0;
  *(_QWORD *)(v41 + 40) = 0;
  *(_QWORD *)(v41 + 48) = 100000000;
  *(_DWORD *)(v41 + 56) = 1000;
  *(_QWORD *)(v41 + 64) = 0;
  *(_QWORD *)(v41 + 72) = 0;
  *(_QWORD *)(v41 + 80) = 100000000;
  *(_DWORD *)(v41 + 200) = 0;
  *(_QWORD *)(v41 + 208) = 0;
  *(_DWORD *)(v41 + 216) = 0;
  *(_OWORD *)(v41 + 88) = 0u;
  *(_OWORD *)(v41 + 104) = 0u;
  *(_QWORD *)(v41 + 232) = 0;
  *(_QWORD *)(v41 + 240) = 0;
  *(_QWORD *)(v41 + 224) = 0;
  *(_DWORD *)(v41 + 248) = 0;
  *(_QWORD *)(v41 + 296) = 0;
  *(_DWORD *)(v41 + 304) = 0;
  *(_OWORD *)(v41 + 256) = 0u;
  *(_OWORD *)(v41 + 272) = 0u;
  *(_DWORD *)(v41 + 288) = 0;
  v43 = *(_QWORD *)(a1 + 7520);
  *(_QWORD *)(a1 + 7520) = v41;
  if (v43)

  *(_QWORD *)&v87 = a1 + 7432;
  *((_QWORD *)&v87 + 1) = 100000000;
  v88 = 1000;
  v89 = v38;
  re::Defaults::intValue((re::Defaults *)"network.session.maxTotalBandwidthBpsLocal", v42, (uint64_t)v85);
  if (v85[0])
  {
    if (*(_BYTE *)(a1 + 2219))
    {
      v39 = v86;
      *((_QWORD *)&v87 + 1) = v86;
      v46 = *re::networkLogObjects(v44);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v39;
        _os_log_impl(&dword_21C69B000, v46, OS_LOG_TYPE_DEFAULT, "Session: config override netMaxTotalBandwidthBpsLocal=%llu", buf, 0xCu);
      }
    }
  }
  re::Defaults::intValue((re::Defaults *)"network.session.maxTotalBandwidthBpsRemote", v45, (uint64_t)v83);
  if (v83[0])
  {
    if (!*(_BYTE *)(a1 + 2219))
    {
      v39 = v84;
      *((_QWORD *)&v87 + 1) = v84;
      v48 = *re::networkLogObjects(v47);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v39;
        _os_log_impl(&dword_21C69B000, v48, OS_LOG_TYPE_DEFAULT, "Session: config override netMaxTotalBandwidthBpsRemote=%llu", buf, 0xCu);
      }
    }
  }
  re::PacketStatsFilter::init(*(_QWORD *)(a1 + 7520), &v87);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  buf[16] = 1;
  memset(v94, 0, sizeof(v94));
  v95 = 0u;
  v96 = 257;
  v97 = a1;
  (*(void (**)(uint8_t *__return_ptr))(**((_QWORD **)a2 + 8) + 88))(v98);
  v49 = *(_QWORD *)buf;
  *(_QWORD *)buf = *(_QWORD *)v98;
  *(_QWORD *)v98 = v49;
  if (v49)

  *(_QWORD *)&buf[8] = *(_QWORD *)a2;
  buf[16] = *((_BYTE *)a2 + 92);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)v94, *((_QWORD *)a2 + 13));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)v94 + 1, v38);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)&v95 + 1, *(_QWORD *)(a1 + 7520));
  LOBYTE(v96) = re::NetworkFeatureFlags::overrideTransportThrottling(*((unsigned __int8 *)a2 + 76));
  HIBYTE(v96) = re::NetworkFeatureFlags::overrideMessageFragmentation(*((unsigned __int8 *)a2 + 77));
  if (*((_BYTE *)a2 + 79))
  {
    v50 = "NetworkReliable";
  }
  else
  {
    DWORD1(v94[1]) = *((_DWORD *)a2 + 22);
    v50 = "NetworkUnreliable";
  }
  *(_QWORD *)(a1 + 3272) = os_log_create("com.apple.re", v50);
  v51 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 8) + 32))(*((_QWORD *)a2 + 8));
  *(_QWORD *)v98 = a1;
  v99 = re::Session::discoveryViewDidJoin;
  v100 = 0;
  v101 = re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::createSubscription<re::Session>(re::Session *,REEventHandlerResult (re::Session::*)(re::DiscoveryView*,re::SharedPtr<re::DiscoveryIdentity>))::{lambda(re::DiscoveryView*,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription const&,re::SharedPtr<re::DiscoveryIdentity>&&)#1}::__invoke;
  v52 = re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(v51, (uint64_t)v98);
  v53 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, double))(**((_QWORD **)a2 + 8) + 40))(*((_QWORD *)a2 + 8), v52);
  *(_QWORD *)v98 = a1;
  v99 = re::Session::discoveryViewDidLeave;
  v100 = 0;
  v101 = re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::createSubscription<re::Session>(re::Session *,REEventHandlerResult (re::Session::*)(re::DiscoveryView*,re::SharedPtr<re::DiscoveryIdentity>))::{lambda(re::DiscoveryView*,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription const&,re::SharedPtr<re::DiscoveryIdentity>&&)#1}::__invoke;
  re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(v53, (uint64_t)v98);
  v54 = re::Transport::init(a1 + 2320, (uint64_t *)buf);
  v55 = v54;
  if (v54)
  {
    if (*((_QWORD *)&v95 + 1))
    {

      *((_QWORD *)&v95 + 1) = 0;
    }
    if (*((_QWORD *)&v94[0] + 1))
    {

      *((_QWORD *)&v94[0] + 1) = 0;
    }
    if (*(_QWORD *)&v94[0])
    {

      *(_QWORD *)&v94[0] = 0;
    }
    if (*(_QWORD *)buf)

    v56 = re::globalAllocators((re *)v54);
    v57 = (re::RoutingTable *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v56[2] + 32))(v56[2], 128, 8);
    v58 = re::RoutingTable::RoutingTable(v57);
    v59 = *(_QWORD *)(a1 + 3040);
    *(_QWORD *)(a1 + 3040) = v58;
    if (v59)

    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 7424) + 48))(*(_QWORD *)(a1 + 7424));
    if (*((_BYTE *)a2 + 72))
      v60 = *(_DWORD *)(a1 + 3280) | 2;
    else
      v60 = *(_DWORD *)(a1 + 3280);
    v61 = *((_DWORD *)a2 + 30);
    if (!v61)
      v61 = 56;
    *(_DWORD *)(a1 + 3280) = v61 | v60;
    v62 = (re *)re::Session::peerID((re::Session *)a1);
    v63 = re::globalAllocators(v62);
    v64 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v63[2] + 32))(v63[2], 160, 8);
    *(_QWORD *)buf = re::SessionParticipant::SessionParticipant(v64, (uint64_t)v62, *(_DWORD *)(a1 + 3280), *((char **)a2 + 6), *((_QWORD *)a2 + 7));
    re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::add((_anonymous_namespace_ *)(a1 + 2280), buf);
    if (*(_QWORD *)buf)

    if ((*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 8) + 48))(*((_QWORD *)a2 + 8)))
    {
      v65 = 0;
      do
      {
        (*(void (**)(uint64_t *__return_ptr, _QWORD, unint64_t))(**((_QWORD **)a2 + 8) + 56))(&v82, *((_QWORD *)a2 + 8), v65);
        re::Session::addIdentity(a1, &v82);
        if (v82)
        {

          v82 = 0;
        }
        ++v65;
      }
      while (v65 < (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 8) + 48))(*((_QWORD *)a2 + 8)));
    }
    re::Session::localParticipant(buf, a1);
    v66 = *(_QWORD *)(*(_QWORD *)buf + 152);

    if (!v66)
    {
      v68 = *re::networkLogObjects(v67);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_21C69B000, v68, OS_LOG_TYPE_DEFAULT, "No local identity set for session.", buf, 2u);
      }
    }
    v69 = *(_DWORD *)(a1 + 2172);
    if (v69)
    {
      v70 = *(_DWORD *)(a1 + 2240);
      if (v70 <= 1)
        v70 = 1;
      *(_QWORD *)(a1 + 3296) = v69 / v70;
    }
    re::Session::stateSet((int *)a1, 1);
    *(_BYTE *)(a1 + 2272) = 1;
    v72 = *re::networkLogObjects(v71);
    v73 = os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT);
    if (v73)
    {
      v74 = *((unsigned __int8 *)a2 + 75);
      v75 = *((unsigned __int8 *)a2 + 79);
      v76 = *((_DWORD *)a2 + 20);
      v77 = *((_DWORD *)a2 + 21);
      v78 = *((_DWORD *)a2 + 22);
      *(_DWORD *)buf = 134219264;
      *(_QWORD *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v74;
      v92 = 1024;
      v93 = v75;
      LOWORD(v94[0]) = 1024;
      *(_DWORD *)((char *)v94 + 2) = v76;
      WORD3(v94[0]) = 1024;
      DWORD2(v94[0]) = v77;
      WORD6(v94[0]) = 1024;
      *(_DWORD *)((char *)v94 + 14) = v78;
      _os_log_impl(&dword_21C69B000, v72, OS_LOG_TYPE_DEFAULT, "Session: initialized (%p) {isLocal=%d, useReliableSync=%d, resendPeriodMs=%u, syncPacketSizeLimit=%u, syncInboundQueueLimit=%u}", buf, 0x2Au);
    }
    v79 = *re::networkLogObjects((re *)v73);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v39;
      _os_log_impl(&dword_21C69B000, v79, OS_LOG_TYPE_INFO, "Session: max bandwidth: %llu bps", buf, 0xCu);
    }
  }
  else
  {
    v80 = *re::networkLogObjects((re *)v54);
    if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v98 = 0;
      _os_log_error_impl(&dword_21C69B000, v80, OS_LOG_TYPE_ERROR, "Cannot initialize transport.", v98, 2u);
    }
    if (*((_QWORD *)&v95 + 1))
    {

      *((_QWORD *)&v95 + 1) = 0;
    }
    if (*((_QWORD *)&v94[0] + 1))
    {

      *((_QWORD *)&v94[0] + 1) = 0;
    }
    if (*(_QWORD *)&v94[0])
    {

      *(_QWORD *)&v94[0] = 0;
    }
    if (*(_QWORD *)buf)

  }
  if (v38)

  return v55;
}

uint64_t re::Session::discoveryViewDidJoin(re *a1, uint64_t a2, uint64_t *a3)
{
  re *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (**v6)();
  _QWORD *v7;
  _QWORD v9[3];
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v3 = a1;
  v12 = *MEMORY[0x24BDAC8D0];
  v4 = *a3;
  if (*a3)
    a1 = (re *)(id)(v4 + 8);
  v5 = re::globalAllocators(a1)[2];
  v6 = &off_24E071D78;
  v9[0] = &off_24E071D78;
  v9[1] = v3;
  v9[2] = v4;
  v10 = v5;
  v11 = v9;
  if (*((_BYTE *)v3 + 7648))
  {
    v7 = v9;
  }
  else
  {
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)v3 + 1884, (uint64_t)v9);
    v7 = v11;
    if (!v11)
      return 0;
    v6 = (uint64_t (**)())*v11;
  }
  ((void (*)(_QWORD *))*v6)(v7);
  if (v11 != v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  return 0;
}

uint64_t re::Session::discoveryViewDidLeave(re *a1, uint64_t a2, uint64_t *a3)
{
  re *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (**v6)();
  _QWORD *v7;
  _QWORD v9[3];
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v3 = a1;
  v12 = *MEMORY[0x24BDAC8D0];
  v4 = *a3;
  if (*a3)
    a1 = (re *)(id)(v4 + 8);
  v5 = re::globalAllocators(a1)[2];
  v6 = &off_24E071DD0;
  v9[0] = &off_24E071DD0;
  v9[1] = v3;
  v9[2] = v4;
  v10 = v5;
  v11 = v9;
  if (*((_BYTE *)v3 + 7648))
  {
    v7 = v9;
  }
  else
  {
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)v3 + 1884, (uint64_t)v9);
    v7 = v11;
    if (!v11)
      return 0;
    v6 = (uint64_t (**)())*v11;
  }
  ((void (*)(_QWORD *))*v6)(v7);
  if (v11 != v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  return 0;
}

void re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::add(_anonymous_namespace_ *result, _QWORD *a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v3 = result;
  v5 = *((_QWORD *)result + 1);
  v4 = *((_QWORD *)result + 2);
  if (v4 >= v5)
  {
    v6 = v4 + 1;
    if (v5 < v4 + 1)
    {
      if (*(_QWORD *)result)
      {
        v7 = 2 * v5;
        if (!v5)
          v7 = 8;
        if (v7 <= v6)
          v8 = v6;
        else
          v8 = v7;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(result, v8);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    v4 = *((_QWORD *)v3 + 2);
  }
  *(_QWORD *)(*((_QWORD *)v3 + 4) + 8 * v4) = *a2;
  *a2 = 0;
  *((_QWORD *)v3 + 2) = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::Session::peerID(re::Session *this)
{
  uint64_t v1;
  NSObject *v3;
  uint8_t v4[16];

  v1 = *((_QWORD *)this + 380);
  if (v1)
    return *(_QWORD *)(v1 + 24);
  v3 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_21C69B000, v3, OS_LOG_TYPE_INFO, "Routing table is nil, returning kInvalidPeerID", v4, 2u);
  }
  return 0;
}

void re::Session::addIdentity(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;
  re *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  int v15;
  BOOL v16;
  NSObject *v17;
  _BOOL8 v18;
  uint64_t v19;
  _BYTE *v20;
  NSObject *v21;
  uint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  uint64_t v25;
  char v26;
  _BYTE v27[7];
  _BYTE *v28;
  uint64_t v29;
  int v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  unint64_t v35;
  __int16 v36;
  unint64_t v37;
  uint8_t buf[32];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)*a2 + 48))(*a2))
  {
    re::Session::localParticipant(buf, a1);
    v4 = *(_QWORD *)buf;
    v5 = *a2;
    if (v5)
    {
      v6 = (id)(v5 + 8);
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v4 + 152), v5);

      if (!v4)
        return;
    }
    else
    {
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(*(_QWORD *)buf + 152), 0);
      if (!v4)
        return;
    }

    return;
  }
  v7 = (re *)(*(_QWORD *(**)(uint64_t *__return_ptr))(*(_QWORD *)*a2 + 40))(&v25);
  v8 = *(_QWORD *)(a1 + 3160);
  if (!v8)
  {
LABEL_22:
    v17 = *re::networkLogObjects(v7);
    v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    if (v18)
    {
      v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)*a2 + 32))(*a2);
      if ((v26 & 1) != 0)
        v20 = v28;
      else
        v20 = v27;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v19;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v20;
      _os_log_impl(&dword_21C69B000, v17, OS_LOG_TYPE_DEFAULT, "No pending connection for identity '%s (%s)'. Will initiate a new one.", buf, 0x16u);
    }
    *((_QWORD *)&v41 + 1) = 0;
    memset(buf, 0, 28);
    v39 = 0u;
    v40 = 0u;
    LODWORD(v41) = 0;
    re::DynamicArray<unsigned char>::setCapacity((_QWORD *)&v39 + 1, 0);
    LODWORD(v41) = v41 + 1;
    *(_QWORD *)buf = re::Transport::connect((re::Transport *)(a1 + 2320), (const re::Address *)&v25);
    *(_QWORD *)&v39 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2256) + 32))(*(_QWORD *)(a1 + 2256));
    re::SharedPtr<re::SyncObject>::reset((uint64_t *)&buf[16], *a2);
    re::DynamicArray<re::Session::BacklogItem>::add(a1 + 3144, (uint64_t)buf);
    if (*((_QWORD *)&v39 + 1))
    {
      if (*((_QWORD *)&v41 + 1))
        (*(void (**)(void))(**((_QWORD **)&v39 + 1) + 40))();
      *((_QWORD *)&v41 + 1) = 0;
      v40 = 0uLL;
      *((_QWORD *)&v39 + 1) = 0;
      LODWORD(v41) = v41 + 1;
    }
    if (*(_QWORD *)&buf[16])

    goto LABEL_42;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 3176) + v9);
    if (v11)
      break;
LABEL_21:
    ++v10;
    v9 += 80;
    if (v10 >= v8)
      goto LABEL_22;
  }
  re::Transport::connectionAddress((re::Transport *)(a1 + 2320), v11, (re::DynamicString *)buf);
  if ((v26 & 1) != 0)
    v12 = v28;
  else
    v12 = v27;
  v13 = buf[8] & 1;
  if ((buf[8] & 1) != 0)
    v14 = *(const char **)&buf[16];
  else
    v14 = (const char *)&buf[9];
  v15 = strcmp(v12, v14);
  v7 = *(re **)buf;
  if (*(_QWORD *)buf)
    v16 = v13 == 0;
  else
    v16 = 1;
  if (!v16)
    v7 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
  if (v15)
  {
    v8 = *(_QWORD *)(a1 + 3160);
    goto LABEL_21;
  }
  v21 = *re::networkLogObjects(v7);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    v22 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)*a2 + 32))(*a2);
    if ((v26 & 1) != 0)
      v23 = v28;
    else
      v23 = v27;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v22;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v23;
    _os_log_impl(&dword_21C69B000, v21, OS_LOG_TYPE_DEFAULT, "Found backlog item for identity: %s (%s).", buf, 0x16u);
  }
  v24 = *(_QWORD *)(a1 + 3160);
  if (v24 <= v10)
  {
    v29 = 0;
    v40 = 0u;
    v41 = 0u;
    v39 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v30 = 136315906;
    v31 = "operator[]";
    v32 = 1024;
    v33 = 789;
    v34 = 2048;
    v35 = v10;
    v36 = 2048;
    v37 = v24;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(*(_QWORD *)(a1 + 3176) + v9 + 16), *a2);
  re::Session::stateEvent(a1, 3);
LABEL_42:
  if (v25)
  {
    if ((v26 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v25 + 40))();
  }
}

_QWORD *re::Session::localParticipant(_QWORD *this, uint64_t a2)
{
  uint64_t v2;

  if (!*(_QWORD *)(a2 + 2296))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v2 = **(_QWORD **)(a2 + 2312);
  *this = v2;
  if (v2)
    return (id)(v2 + 8);
  return this;
}

void re::Session::stateSet(int *a1, int a2)
{
  NSObject *v4;
  char *v5;
  char *v6;
  int v7;
  char *v8;
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 136315394;
    v8 = v5;
    v9 = 2080;
    v10 = v6;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Session: changing state %s->%s", (uint8_t *)&v7, 0x16u);
  }
  re::Session::stateEvent((_BOOL8)a1, 1);
  a1[816] = a2;
  re::Session::stateEvent((_BOOL8)a1, 0);
}

void re::Session::deinit(re::Session *this)
{
  re **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  re *v21;
  NSObject *v22;
  int v23;
  re::Session *v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 2272))
  {
    if (*((_DWORD *)this + 816) != 3)
      re::Session::stopSession((uint64_t)this, 1);
    v2 = (re **)((char *)this + 32);
    re::Event<re::Session>::raise((uint64_t)this + 32, (uint64_t)this);
    *((_BYTE *)this + 2272) = 0;
    re::Transport::deinit((re::Session *)((char *)this + 2320));
    re::DynamicArray<re::Session::BacklogItem>::deinit((uint64_t)this + 3144);
    re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 2280);
    v3 = *((_QWORD *)this + 398);
    if (v3)
    {
      if (*((_QWORD *)this + 402))
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
      *((_QWORD *)this + 402) = 0;
      *((_QWORD *)this + 399) = 0;
      *((_QWORD *)this + 400) = 0;
      *((_QWORD *)this + 398) = 0;
      ++*((_DWORD *)this + 802);
    }
    re::PacketStatsFilter::deInit(*((re::PacketStatsFilter **)this + 940));
    v4 = *((_QWORD *)this + 929);
    if (v4)
    {
      if (*((_QWORD *)this + 933))
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      *((_QWORD *)this + 933) = 0;
      *((_QWORD *)this + 930) = 0;
      *((_QWORD *)this + 931) = 0;
      *((_QWORD *)this + 929) = 0;
      ++*((_DWORD *)this + 1864);
    }
    (*(void (**)(_QWORD))(**((_QWORD **)this + 928) + 32))(*((_QWORD *)this + 928));
    v5 = *((_QWORD *)this + 257);
    if (v5)
    {
      if (*((_QWORD *)this + 261))
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      *((_QWORD *)this + 261) = 0;
      *((_QWORD *)this + 258) = 0;
      *((_QWORD *)this + 259) = 0;
      *((_QWORD *)this + 257) = 0;
      ++*((_DWORD *)this + 520);
    }
    v6 = *((_QWORD *)this + 246);
    if (v6)
    {
      if (*((_QWORD *)this + 250))
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
      *((_QWORD *)this + 250) = 0;
      *((_QWORD *)this + 247) = 0;
      *((_QWORD *)this + 248) = 0;
      *((_QWORD *)this + 246) = 0;
      ++*((_DWORD *)this + 498);
    }
    v7 = *((_QWORD *)this + 202);
    if (v7)
    {
      if (*((_QWORD *)this + 206))
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
      *((_QWORD *)this + 206) = 0;
      *((_QWORD *)this + 203) = 0;
      *((_QWORD *)this + 204) = 0;
      *((_QWORD *)this + 202) = 0;
      ++*((_DWORD *)this + 410);
    }
    v8 = *((_QWORD *)this + 224);
    if (v8)
    {
      if (*((_QWORD *)this + 228))
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
      *((_QWORD *)this + 228) = 0;
      *((_QWORD *)this + 225) = 0;
      *((_QWORD *)this + 226) = 0;
      *((_QWORD *)this + 224) = 0;
      ++*((_DWORD *)this + 454);
    }
    v9 = *((_QWORD *)this + 235);
    if (v9)
    {
      if (*((_QWORD *)this + 239))
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
      *((_QWORD *)this + 239) = 0;
      *((_QWORD *)this + 236) = 0;
      *((_QWORD *)this + 237) = 0;
      *((_QWORD *)this + 235) = 0;
      ++*((_DWORD *)this + 476);
    }
    v10 = 0;
    v11 = (_QWORD *)((char *)this + 1440);
    do
    {
      v12 = (_QWORD *)((char *)this + v10);
      v13 = *(_QWORD *)((char *)this + v10 + 560);
      if (v13)
      {
        if (v12[74])
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        v12[74] = 0;
        v12[71] = 0;
        v12[72] = 0;
        v12[70] = 0;
        ++*(_DWORD *)((char *)this + v10 + 584);
      }
      v10 += 88;
    }
    while (v10 != 880);
    v14 = *((_QWORD *)this + 213);
    if (v14)
    {
      if (*((_QWORD *)this + 217))
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
      *((_QWORD *)this + 217) = 0;
      *((_QWORD *)this + 214) = 0;
      *((_QWORD *)this + 215) = 0;
      *((_QWORD *)this + 213) = 0;
      ++*((_DWORD *)this + 432);
    }
    if (*v11)
    {
      if (*((_QWORD *)this + 184))
        (*(void (**)(_QWORD))(*(_QWORD *)*v11 + 40))(*v11);
      *((_QWORD *)this + 184) = 0;
      *((_QWORD *)this + 181) = 0;
      *((_QWORD *)this + 182) = 0;
      *v11 = 0;
      ++*((_DWORD *)this + 366);
    }
    v15 = *((_QWORD *)this + 59);
    if (v15)
    {
      if (*((_QWORD *)this + 63))
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
      *((_QWORD *)this + 63) = 0;
      *((_QWORD *)this + 60) = 0;
      *((_QWORD *)this + 61) = 0;
      *((_QWORD *)this + 59) = 0;
      ++*((_DWORD *)this + 124);
    }
    v16 = *((_QWORD *)this + 191);
    if (v16)
    {
      if (*((_QWORD *)this + 195))
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
      *((_QWORD *)this + 195) = 0;
      *((_QWORD *)this + 192) = 0;
      *((_QWORD *)this + 193) = 0;
      *((_QWORD *)this + 191) = 0;
      ++*((_DWORD *)this + 388);
    }
    v17 = *((_QWORD *)this + 48);
    if (v17)
    {
      if (*((_QWORD *)this + 52))
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
      *((_QWORD *)this + 52) = 0;
      *((_QWORD *)this + 49) = 0;
      *((_QWORD *)this + 50) = 0;
      *((_QWORD *)this + 48) = 0;
      ++*((_DWORD *)this + 102);
    }
    v18 = *((_QWORD *)this + 37);
    if (v18)
    {
      if (*((_QWORD *)this + 41))
        (*(void (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
      *((_QWORD *)this + 41) = 0;
      *((_QWORD *)this + 38) = 0;
      *((_QWORD *)this + 39) = 0;
      *((_QWORD *)this + 37) = 0;
      ++*((_DWORD *)this + 80);
    }
    v19 = *((_QWORD *)this + 26);
    if (v19)
    {
      if (*((_QWORD *)this + 30))
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19);
      *((_QWORD *)this + 30) = 0;
      *((_QWORD *)this + 27) = 0;
      *((_QWORD *)this + 28) = 0;
      *((_QWORD *)this + 26) = 0;
      ++*((_DWORD *)this + 58);
    }
    v20 = *((_QWORD *)this + 15);
    if (v20)
    {
      if (*((_QWORD *)this + 19))
        (*(void (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
      *((_QWORD *)this + 19) = 0;
      *((_QWORD *)this + 16) = 0;
      *((_QWORD *)this + 17) = 0;
      *((_QWORD *)this + 15) = 0;
      ++*((_DWORD *)this + 36);
    }
    v21 = *v2;
    if (*v2)
    {
      if (*((_QWORD *)this + 8))
        v21 = (re *)(*(uint64_t (**)(re *))(*(_QWORD *)v21 + 40))(v21);
      *((_QWORD *)this + 8) = 0;
      *((_QWORD *)this + 5) = 0;
      *((_QWORD *)this + 6) = 0;
      *v2 = 0;
      ++*((_DWORD *)this + 14);
    }
    v22 = *re::networkLogObjects(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v23 = 134217984;
      v24 = this;
      _os_log_impl(&dword_21C69B000, v22, OS_LOG_TYPE_DEFAULT, "Session: deinitialized (%p).", (uint8_t *)&v23, 0xCu);
    }
  }
}

void re::Session::stopSession(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  re::Packet **v10;
  uint64_t v11;
  re::Packet *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  re *v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 3264) != 3)
  {
    *(_DWORD *)(a1 + 3032) = a2;
    re::Session::stateSet((int *)a1, 3);
    v4 = *(_QWORD *)(a1 + 3160);
    *(_QWORD *)(a1 + 3160) = 0;
    if (v4)
    {
      v5 = 80 * v4;
      v6 = (_QWORD *)(*(_QWORD *)(a1 + 3176) + 72);
      do
      {
        v7 = *(v6 - 4);
        if (v7)
        {
          if (*v6)
            (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
          *v6 = 0;
          *(v6 - 3) = 0;
          *(v6 - 2) = 0;
          *(v6 - 4) = 0;
          ++*((_DWORD *)v6 - 2);
        }
        v8 = *(v6 - 7);
        if (v8)
        {

          *(v6 - 7) = 0;
        }
        v6 += 10;
        v5 -= 80;
      }
      while (v5);
    }
    ++*(_DWORD *)(a1 + 3168);
    *(_QWORD *)(a1 + 3200) = 0;
    ++*(_DWORD *)(a1 + 3208);
    v9 = *(_QWORD *)(a1 + 3064);
    if (v9)
    {
      v10 = *(re::Packet ***)(a1 + 3080);
      v11 = 40 * v9;
      do
      {
        v12 = *v10;
        v10 += 5;
        re::PacketPool::free(*(re::PacketPool **)(a1 + 2704), v12);
        v11 -= 40;
      }
      while (v11);
    }
    *(_QWORD *)(a1 + 3064) = 0;
    ++*(_DWORD *)(a1 + 3072);
    *(_BYTE *)(a1 + 7648) = 1;
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 7528) + 24))(a1 + 7528);
    v13 = *(_QWORD *)(a1 + 2208);
    if (v13)
    {
      v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
      re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v14, a1);
      v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2208) + 32))(*(_QWORD *)(a1 + 2208));
      re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v15, a1);
    }
    v16 = re::RoutingTable::removeRoutesForTransport(*(re::RoutingTable **)(a1 + 3040), (re::Transport *)(a1 + 2320));
    v17 = *re::networkLogObjects(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 134218240;
      v19 = a1;
      v20 = 1024;
      v21 = a2;
      _os_log_impl(&dword_21C69B000, v17, OS_LOG_TYPE_DEFAULT, "Session: stopped (%p) with error: %d", (uint8_t *)&v18, 0x12u);
    }
  }
}

void re::Event<re::Session>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  _OWORD v23[5];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *(_QWORD *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v15 = 136315906;
          v16 = "operator[]";
          v17 = 1024;
          v18 = 789;
          v19 = 2048;
          v20 = i;
          v21 = 2048;
          v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *(_QWORD *)(a1 + 72) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, *((unint64_t *)&v23[0] + 1));
        }
        v7 += 40;
      }
    }
  }
}

uint64_t re::DynamicArray<re::Session::BacklogItem>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 80 * v4;
        v6 = (_QWORD *)(v3 + 72);
        do
        {
          v7 = *(v6 - 4);
          if (v7)
          {
            if (*v6)
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *v6 = 0;
            *(v6 - 3) = 0;
            *(v6 - 2) = 0;
            *(v6 - 4) = 0;
            ++*((_DWORD *)v6 - 2);
          }
          v8 = *(v6 - 7);
          if (v8)
          {

            *(v6 - 7) = 0;
          }
          v6 += 10;
          v5 -= 80;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::Session::participants(re::Session *this)
{
  return *((_QWORD *)this + 289);
}

void re::Session::setRoutingTable(re::Session *this, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  __int128 *v9;
  uint64_t v10;
  id v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD v16[2];
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  if (*a2 && (v5 = (_QWORD *)*((_QWORD *)this + 380)) != 0)
  {
    v6 = v5[6];
    if (v6)
    {
      v7 = (uint64_t *)v5[8];
      v8 = &v7[5 * v6];
      do
      {
        v9 = (__int128 *)(v7 + 1);
        v10 = *v7;
        v7 += 5;
        re::RoutingTable::addRoute(v4, v10, v9);
      }
      while (v7 != v8);
      v4 = *a2;
      v5 = (_QWORD *)*((_QWORD *)this + 380);
    }
    if (v5 == (_QWORD *)v4)
    {
      v4 = (uint64_t)v5;
    }
    else
    {
      if (v4)
      {
        v11 = (id)(v4 + 8);
        v5 = (_QWORD *)*((_QWORD *)this + 380);
      }
      if (v5)

      *((_QWORD *)this + 380) = v4;
    }
    re::Session::assignLocalPeerID(this, *(_QWORD *)(v4 + 24));
  }
  else
  {
    v12 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = *((unsigned __int8 *)this + 2272);
      v14 = *a2;
      v15 = *((_QWORD *)this + 380);
      v16[0] = 67109632;
      v16[1] = v13;
      v17 = 2048;
      v18 = v14;
      v19 = 2048;
      v20 = v15;
      _os_log_error_impl(&dword_21C69B000, v12, OS_LOG_TYPE_ERROR, "Cannot set routing table {isInitialized: %d, routingTable parameter: %p, session routing table:%p}", (uint8_t *)v16, 0x1Cu);
    }
  }
}

uint64_t re::Session::assignLocalPeerID(re::Session *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v6;

  re::Session::localParticipant(&v6, (uint64_t)this);
  v4 = v6;
  *(_QWORD *)(v6 + 24) = a2;

  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 928) + 40))(*((_QWORD *)this + 928), a2);
}

void re::Session::processIncomingMessages(re::Session *this, unint64_t a2)
{
  _DWORD *v4;
  re::Packet *v5;
  unsigned int v6;
  uint64_t *v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  NSObject *v11;
  re *v12;
  uint64_t *v13;
  int v14;
  uint64_t *v15;
  int v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t *UInt64;
  NSObject *v20;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  NSObject *v38;
  uint64_t *v39;
  int v40;
  unsigned int v41;
  NSObject *v42;
  _BOOL8 v43;
  _BOOL4 v44;
  NSObject *v45;
  uint64_t *v46;
  unsigned int v47;
  NSObject *v48;
  uint64_t *v49;
  unsigned int v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t *Route;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  NSObject *v62;
  id v63;
  re::Transport *v64;
  char *v65;
  NSObject *v66;
  uint64_t *v67;
  unsigned int v68;
  re *v69;
  NSObject *v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  re *v74;
  int v75;
  void *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  void *v80;
  id v81;
  re *v82;
  NSObject *v83;
  _BOOL8 v84;
  uint8_t *v85;
  uint8_t *v86;
  NSObject *v87;
  uint8_t *v88;
  NSObject *v89;
  const char *v90;
  NSObject *v91;
  NSObject *v92;
  NSObject *v93;
  uint8_t *v94;
  NSObject *v95;
  NSObject *v96;
  int v97;
  NSObject *v98;
  const char *v99;
  uint32_t v100;
  NSObject *v101;
  NSObject *v102;
  uint8_t *v103;
  NSObject *v104;
  NSObject *v105;
  NSObject *v106;
  NSObject *v107;
  uint8_t *v108;
  NSObject *v109;
  uint8_t *v110;
  NSObject *v111;
  NSObject *v112;
  re *v113;
  NSObject *v114;
  uint64_t v115;
  int v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t i;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t v126;
  BOOL v127;
  unint64_t v128;
  unint64_t v129;
  _OWORD *v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  uint64_t v134;
  NSObject *v135;
  id v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  int v141;
  re *v142;
  uint8_t *v143;
  int v144;
  uint64_t v145;
  uint64_t v146;
  uint8_t *v147;
  uint64_t v148;
  NSObject *v149;
  char *v150;
  re::Transport *v151;
  _QWORD *v152;
  uint64_t v153;
  unsigned int v154;
  BOOL v155;
  uint64_t v156;
  uint64_t v157;
  re::Packet *v158;
  unsigned int v159;
  unint64_t v160;
  uint8_t buf[8];
  _BYTE v162[40];
  int v163;
  _BYTE v164[24];
  __int16 v165;
  unint64_t v166;
  uint8_t v167[32];
  __int128 v168;
  __int128 v169;
  __int128 v170;
  uint64_t v171;

  v171 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return;
  v4 = (_DWORD *)re::DataArray<re::Connection>::tryGet((uint64_t)this + 2440, a2);
  if (!v4)
    return;
  if (*v4 != 1)
    return;
  v158 = 0;
  v151 = (re::Session *)((char *)this + 2320);
  if (!re::Transport::receive((uint64_t)this + 2320, a2, 0, (unint64_t **)&v158))
    return;
  v150 = (char *)this + 3088;
  v152 = (_QWORD *)((char *)this + 3048);
LABEL_6:
  v5 = v158;
  v6 = *((_DWORD *)v158 + 6);
  v153 = *((_QWORD *)v158 + 2);
  v154 = v6;
  v155 = 0;
  v156 = 0;
  v157 = 0;
  if (!v6)
    goto LABEL_145;
  while (2)
  {
    re::Session::readRoutingHeader((re::Session *)&v163, (re::BitReader *)&v153);
    if (!(_BYTE)v163
      || (*(_DWORD *)v167 = 0, v7 = re::BitReader::readUInt32Bits(&v153, 8u, (unsigned int *)v167), v155))
    {
      v41 = 6;
LABEL_182:
      re::PacketPool::free(*((re::PacketPool **)this + 338), v158);
      v114 = *re::networkLogObjects(v113);
      v115 = os_log_type_enabled(v114, OS_LOG_TYPE_ERROR);
      if ((v115 & 1) != 0)
      {
        re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
        v143 = &v167[9];
        if ((v167[8] & 1) != 0)
          v143 = *(uint8_t **)&v167[16];
        *(_DWORD *)v162 = 136315394;
        *(_QWORD *)&v162[4] = v143;
        *(_WORD *)&v162[12] = 1024;
        *(_DWORD *)&v162[14] = v41;
        _os_log_error_impl(&dword_21C69B000, v114, OS_LOG_TYPE_ERROR, "Received corrupt message from '%s'. Packet error: %d, Disconnecting.", v162, 0x12u);
        v115 = *(_QWORD *)v167;
        if (*(_QWORD *)v167 && (v167[8] & 1) != 0)
          v115 = (*(uint64_t (**)(void))(**(_QWORD **)v167 + 40))();
      }
      v160 = a2;
      v159 = v41;
      v116 = *((_DWORD *)this + 380);
      *((_DWORD *)this + 380) = v116 + 1;
      if (*((_QWORD *)this + 182))
      {
        v117 = 0;
        do
        {
          v115 = (*(uint64_t (**)(re::Session *))(*((_QWORD *)this + 184) + 32 * v117 + 24))(this);
          if ((_DWORD)v115 == 1)
            v115 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)this + 180, v117);
          else
            ++v117;
        }
        while (v117 < *((_QWORD *)this + 182));
        v116 = *((_DWORD *)this + 380) - 1;
      }
      *((_DWORD *)this + 380) = v116;
      if (!v116)
      {
        v118 = *((_QWORD *)this + 187);
        if (v118)
        {
          v119 = 0;
          for (i = 0; i != v118; ++i)
          {
            v121 = *((_QWORD *)this + 187);
            if (v121 <= i)
            {
              *(_QWORD *)buf = 0;
              v169 = 0u;
              v170 = 0u;
              v168 = 0u;
              memset(v167, 0, sizeof(v167));
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              v163 = 136315906;
              *(_QWORD *)v164 = "operator[]";
              *(_WORD *)&v164[8] = 1024;
              *(_DWORD *)&v164[10] = 789;
              *(_WORD *)&v164[14] = 2048;
              *(_QWORD *)&v164[16] = i;
              v165 = 2048;
              v166 = v121;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v122 = *((_QWORD *)this + 189) + v119;
            *(_OWORD *)v162 = *(_OWORD *)v122;
            *(_OWORD *)&v162[16] = *(_OWORD *)(v122 + 16);
            *(_QWORD *)&v162[32] = *(_QWORD *)(v122 + 32);
            if (v162[0])
            {
              v115 = re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)v167, *((_QWORD *)this + 182), *((char **)this + 184), &v162[8]);
              if (!v167[0])
              {
                v123 = *((_QWORD *)this + 182);
                v124 = *((_QWORD *)this + 181);
                if (v123 >= v124)
                {
                  v125 = v123 + 1;
                  if (v124 < v123 + 1)
                  {
                    if (*((_QWORD *)this + 180))
                    {
                      v126 = 2 * v124;
                      v127 = v124 == 0;
                      v128 = 8;
                      if (!v127)
                        v128 = v126;
                      if (v128 <= v125)
                        v129 = v125;
                      else
                        v129 = v128;
                      v115 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)this + 180, v129);
                    }
                    else
                    {
                      v115 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)this + 180, v125);
                      ++*((_DWORD *)this + 366);
                    }
                  }
                  v123 = *((_QWORD *)this + 182);
                }
                v130 = (_OWORD *)(*((_QWORD *)this + 184) + 32 * v123);
                *v130 = *(_OWORD *)&v162[8];
                v130[1] = *(_OWORD *)&v162[24];
                ++*((_QWORD *)this + 182);
                ++*((_DWORD *)this + 366);
              }
            }
            else
            {
              v115 = re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)v167, *((_QWORD *)this + 182), *((char **)this + 184), &v162[8]);
              if (v167[0])
                v115 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)this + 180, *(unint64_t *)&v167[8]);
            }
            v119 += 40;
          }
        }
      }
      v131 = *((_QWORD *)this + 287);
      if (v131)
      {
        v132 = (uint64_t *)*((_QWORD *)this + 289);
        v133 = 8 * v131;
        while (1)
        {
          v134 = *v132;
          if (*(_QWORD *)(*v132 + 32) == a2)
            break;
          ++v132;
          v133 -= 8;
          if (!v133)
            goto LABEL_215;
        }
        v136 = (id)(v134 + 8);
        v137 = re::PacketPool::allocate(*((re::PacketPool **)this + 338), 67);
        re::Packet::offsetBy((uint64_t)v137, 3);
        v138 = *((_QWORD *)v137 + 1);
        *(_BYTE *)(v138 + 2) = 0;
        *(_WORD *)v138 = 0;
        v139 = *((_QWORD *)v137 + 2);
        v140 = *((_DWORD *)v137 + 7);
        *(_QWORD *)v167 = &off_24E072668;
        *(_QWORD *)&v167[8] = v139;
        *(_DWORD *)&v167[16] = v140;
        v167[20] = 0;
        *(_QWORD *)&v167[24] = 0;
        *(_QWORD *)&v168 = 0;
        re::BitWriter::writeUInt32Bits((uint64_t)v167, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v167, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v167, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v167, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v167, 3u, 8u);
        re::BitWriter::writeUInt32Bits((uint64_t)v167, v41, 0x20u);
        v141 = *(_DWORD *)&v167[24];
        if (*(_DWORD *)&v167[28])
          v141 = *(_DWORD *)&v167[24] + 1;
        *((_DWORD *)v137 + 6) = v141;
        re::Transport::send((uint64_t)v151, a2, (unint64_t)v137, 0, 0, 0, *(_DWORD *)(v134 + 72));

      }
      else
      {
LABEL_215:
        v135 = *re::networkLogObjects((re *)v115);
        if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v167 = 0;
          _os_log_error_impl(&dword_21C69B000, v135, OS_LOG_TYPE_ERROR, "sendSessionError: missing participant for connection!", v167, 2u);
        }
      }
      re::Transport::disconnect(v151, a2, 0);
      if (v41 != 4 || !*((_BYTE *)this + 2222))
        goto LABEL_222;
      v149 = *re::networkLogObjects(v142);
      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v167 = 134217984;
        *(_QWORD *)&v167[4] = this;
        _os_log_impl(&dword_21C69B000, v149, OS_LOG_TYPE_DEFAULT, "Stopping Session (%p) with packet error=kProtocolMismatch", v167, 0xCu);
      }
      re::Session::stopSession((uint64_t)this, 4);
      return;
    }
    v8 = v167[0];
    v10 = *(_QWORD *)&v164[4];
    v9 = *(_QWORD *)&v164[12];
    switch(v167[0])
    {
      case 1u:
        v11 = *re::networkLogObjects((re *)v7);
        v12 = (re *)os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v12)
        {
          re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
          v85 = &v167[9];
          if ((v167[8] & 1) != 0)
            v85 = *(uint8_t **)&v167[16];
          *(_DWORD *)v162 = 136315138;
          *(_QWORD *)&v162[4] = v85;
          _os_log_debug_impl(&dword_21C69B000, v11, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kPeerHello from %s", v162, 0xCu);
          v12 = *(re **)v167;
          if (*(_QWORD *)v167 && (v167[8] & 1) != 0)
            v12 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)v167 + 40))();
        }
        if (!v9)
        {
          v160 = 0;
          *(_QWORD *)buf = 0;
          *(_DWORD *)v167 = 0;
          v13 = re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
          v14 = *(_DWORD *)v167;
          if (*((_DWORD *)this + 538) != *(_DWORD *)v167)
          {
            v95 = *re::networkLogObjects((re *)v13);
            v26 = os_log_type_enabled(v95, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v26)
            {
              v144 = *((_DWORD *)this + 538);
              *(_DWORD *)v167 = 67109376;
              *(_DWORD *)&v167[4] = v14;
              *(_WORD *)&v167[8] = 1024;
              *(_DWORD *)&v167[10] = v144;
              _os_log_error_impl(&dword_21C69B000, v95, OS_LOG_TYPE_ERROR, "Mismatched AppId, received 0x%X expecting 0x%X", v167, 0xEu);
            }
            v41 = 3;
            goto LABEL_178;
          }
          *(_DWORD *)v167 = 0;
          v15 = re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
          v16 = *(_DWORD *)v167;
          if (*((_DWORD *)this + 539) != *(_DWORD *)v167)
          {
            v96 = *re::networkLogObjects((re *)v15);
            v26 = os_log_type_enabled(v96, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v26)
            {
              v97 = *((_DWORD *)this + 539);
              *(_DWORD *)v167 = 67109376;
              *(_DWORD *)&v167[4] = v16;
              *(_WORD *)&v167[8] = 1024;
              *(_DWORD *)&v167[10] = v97;
              v98 = v96;
              v99 = "Mismatched protocol, received 0x%X expecting 0x%X";
              v100 = 14;
              goto LABEL_235;
            }
LABEL_152:
            v41 = 4;
LABEL_178:
            v111 = *re::networkLogObjects((re *)v26);
            v43 = os_log_type_enabled(v111, OS_LOG_TYPE_ERROR);
            if (v43)
            {
              *(_WORD *)v167 = 0;
              _os_log_error_impl(&dword_21C69B000, v111, OS_LOG_TYPE_ERROR, "Error receiving message of type kPeerHello", v167, 2u);
            }
            goto LABEL_180;
          }
          v17 = re::BitReader::readUInt64((re::BitReader *)&v153, &v160);
          v18 = v160;
          if (*((_QWORD *)this + 270) != v160)
          {
            v101 = *re::networkLogObjects((re *)v17);
            v26 = os_log_type_enabled(v101, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v26)
            {
              v145 = *((_QWORD *)this + 270);
              *(_DWORD *)v167 = 134218240;
              *(_QWORD *)&v167[4] = v18;
              *(_WORD *)&v167[12] = 2048;
              *(_QWORD *)&v167[14] = v145;
              v98 = v101;
              v99 = "Mismatched component schema, received 0x%llX expecting 0x%llX";
              v100 = 22;
LABEL_235:
              _os_log_error_impl(&dword_21C69B000, v98, OS_LOG_TYPE_ERROR, v99, v167, v100);
            }
            goto LABEL_152;
          }
          UInt64 = re::BitReader::readUInt64((re::BitReader *)&v153, (unint64_t *)buf);
          v20 = *re::networkLogObjects((re *)UInt64);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v167 = 134217984;
            *(_QWORD *)&v167[4] = *(_QWORD *)buf;
          }
          *(_DWORD *)v167 = 0;
          re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
          v21 = *(_DWORD *)v167;
          *(_DWORD *)v167 = 0;
          v22 = re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
          if (v155
            || (v23 = *(unsigned int *)v167, v24 = v156, v154 - v156 < *(_DWORD *)v167))
          {
            v87 = *re::networkLogObjects((re *)v22);
            v26 = os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
            if (!(_DWORD)v26)
              goto LABEL_177;
            re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
            v88 = &v167[9];
            if ((v167[8] & 1) != 0)
              v88 = *(uint8_t **)&v167[16];
            *(_DWORD *)v162 = 136315138;
            *(_QWORD *)&v162[4] = v88;
            v89 = v87;
            v90 = "Cannot read discovery data. Hello message from %s is corrupt.";
            goto LABEL_174;
          }
          v25 = v153;
          v157 = 0;
          v156 = (v156 + *(_DWORD *)v167);
          v155 = (int)v24 + *(_DWORD *)v167 > v154;
          *(_DWORD *)v167 = 0;
          v26 = (uint64_t)re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
          if (v155)
          {
            v102 = *re::networkLogObjects((re *)v26);
            v26 = os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
            if (!(_DWORD)v26)
              goto LABEL_177;
            re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
            v103 = &v167[9];
            if ((v167[8] & 1) != 0)
              v103 = *(uint8_t **)&v167[16];
            *(_DWORD *)v162 = 136315138;
            *(_QWORD *)&v162[4] = v103;
            v89 = v102;
            v90 = "Hello message received from %s is corrupt.";
            goto LABEL_174;
          }
          v27 = *(unsigned int *)v167;
          if (*(_DWORD *)v167 > 0x400000u)
          {
            v104 = *re::networkLogObjects((re *)v26);
            v26 = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v26)
            {
              *(_DWORD *)v167 = 67109376;
              *(_DWORD *)&v167[4] = v27;
              *(_WORD *)&v167[8] = 2048;
              *(_QWORD *)&v167[10] = 0x400000;
              _os_log_error_impl(&dword_21C69B000, v104, OS_LOG_TYPE_ERROR, "User context is bigger than maximum allowed (%u > %zu)", v167, 0x12u);
            }
            goto LABEL_177;
          }
          v28 = *((_QWORD *)this + 395);
          if (v28)
          {
            v29 = v25 + v24;
            v30 = *((_QWORD *)this + 397) + 40;
            v31 = 80 * v28;
            while (*(_QWORD *)(v30 - 40) != a2)
            {
              v30 += 80;
              v31 -= 80;
              if (!v31)
                goto LABEL_25;
            }
            *(_QWORD *)(v30 - 32) = *(_QWORD *)buf;
            *(_DWORD *)(v30 - 16) = v21;
            if ((_DWORD)v27)
            {
              re::DynamicArray<unsigned char>::resize(v30, v27);
              if (!v155)
              {
                v75 = v156;
                if (v154 - v156 >= v27)
                {
                  v76 = *(void **)(v30 + 32);
                  HIDWORD(v156) = 0;
                  v157 = 0;
                  v26 = (uint64_t)memcpy(v76, (const void *)(v153 + v156), v27);
                  LODWORD(v156) = v75 + v27;
                  goto LABEL_90;
                }
                v155 = 1;
                v156 = v154;
              }
              v107 = *re::networkLogObjects(v74);
              v26 = os_log_type_enabled(v107, OS_LOG_TYPE_ERROR);
              if (!(_DWORD)v26)
                goto LABEL_177;
              re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
              v108 = &v167[9];
              if ((v167[8] & 1) != 0)
                v108 = *(uint8_t **)&v167[16];
              *(_DWORD *)v162 = 136315138;
              *(_QWORD *)&v162[4] = v108;
              v89 = v107;
              v90 = "User context data received from %s is corrupt.";
LABEL_174:
              _os_log_error_impl(&dword_21C69B000, v89, OS_LOG_TYPE_ERROR, v90, v162, 0xCu);
              v26 = *(_QWORD *)v167;
              if (*(_QWORD *)v167 && (v167[8] & 1) != 0)
                v26 = (*(uint64_t (**)(void))(**(_QWORD **)v167 + 40))();
              goto LABEL_177;
            }
LABEL_90:
            if ((v21 & 2) != 0 && (!*((_BYTE *)this + 2219) || !*(_QWORD *)(v30 - 24)))
            {
              v41 = 15;
              goto LABEL_178;
            }
            v77 = *((_QWORD *)this + 276);
            if (v77)
            {
              if (!*(_QWORD *)(v30 - 24))
              {
                re::Transport::connectionAddress(v151, *(_QWORD *)(v30 - 40), (re::DynamicString *)v167);
                (*(void (**)(uint64_t, uint8_t *, uint64_t, uint64_t))(*(_QWORD *)v77 + 72))(v77, v167, v29, v23);
                v26 = *(_QWORD *)v167;
                if (*(_QWORD *)v167)
                {
                  if ((v167[8] & 1) != 0)
                    v26 = (*(uint64_t (**)(void))(**(_QWORD **)v167 + 40))();
                }
              }
            }
            v37 = 1;
            if ((v21 & 1) != 0)
            {
LABEL_96:
              if (!*((_QWORD *)this + 392))
              {
                v26 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 928) + 56))(*((_QWORD *)this + 928), *(_QWORD *)buf);
                goto LABEL_98;
              }
              v106 = *re::networkLogObjects((re *)v26);
              v26 = os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v26)
              {
                v148 = *((_QWORD *)this + 392);
                *(_DWORD *)v167 = 134218240;
                *(_QWORD *)&v167[4] = v148;
                *(_WORD *)&v167[12] = 2048;
                *(_QWORD *)&v167[14] = *(_QWORD *)buf;
                _os_log_error_impl(&dword_21C69B000, v106, OS_LOG_TYPE_ERROR, "Two nodes claim to be session leaders (%llu and %llu)", v167, 0x16u);
              }
              v41 = 5;
              goto LABEL_178;
            }
LABEL_98:
            if ((v37 & 1) != 0)
            {
              v78 = *((_DWORD *)this + 816);
              if (v78 == 2)
              {
                re::Session::stateEvent((_BOOL8)this, 3);
              }
              else if (v78 == 1)
              {
                v79 = re::Session::peerID(this);
                re::Session::assignLocalPeerID(this, v79);
                re::Session::stateSet((int *)this, 2);
              }
              goto LABEL_107;
            }
            v105 = *re::networkLogObjects((re *)v26);
            v26 = os_log_type_enabled(v105, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v26)
            {
              v146 = *(_QWORD *)buf;
              re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
              v147 = &v167[9];
              if ((v167[8] & 1) != 0)
                v147 = *(uint8_t **)&v167[16];
              *(_DWORD *)v162 = 134218242;
              *(_QWORD *)&v162[4] = v146;
              *(_WORD *)&v162[12] = 2080;
              *(_QWORD *)&v162[14] = v147;
              _os_log_error_impl(&dword_21C69B000, v105, OS_LOG_TYPE_ERROR, "Cannot bind peerID %llu with connection for peer %s", v162, 0x16u);
              v26 = *(_QWORD *)v167;
              if (*(_QWORD *)v167 && (v167[8] & 1) != 0)
                v26 = (*(uint64_t (**)(void))(**(_QWORD **)v167 + 40))();
            }
            v41 = 7;
            goto LABEL_178;
          }
LABEL_25:
          v32 = *((_QWORD *)this + 287);
          if (!v32)
          {
LABEL_29:
            v37 = 0;
            if ((v21 & 1) != 0)
              goto LABEL_96;
            goto LABEL_98;
          }
          v33 = *(_QWORD *)buf;
          v34 = (uint64_t *)*((_QWORD *)this + 289);
          v35 = 8 * v32;
          while (1)
          {
            v36 = *v34;
            if (*(_QWORD *)(*v34 + 24) == *(_QWORD *)buf)
              break;
            ++v34;
            v35 -= 8;
            if (!v35)
              goto LABEL_29;
          }
          v80 = (void *)(v36 + 8);
          v81 = (id)(v36 + 8);

          v83 = *re::networkLogObjects(v82);
          v84 = os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG);
          if (v84)
          {
            *(_DWORD *)v167 = 134217984;
            *(_QWORD *)&v167[4] = v33;
          }
          if ((_DWORD)v27)
          {
            v157 = 0;
            v156 = (v156 + v27);
            if (v156 > v154)
            {
              v155 = 1;
              v109 = *re::networkLogObjects((re *)v84);
              v26 = os_log_type_enabled(v109, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v26)
              {
                re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
                v110 = &v167[9];
                if ((v167[8] & 1) != 0)
                  v110 = *(uint8_t **)&v167[16];
                *(_DWORD *)v162 = 136315138;
                *(_QWORD *)&v162[4] = v110;
                v89 = v109;
                v90 = "User context data received from %s for existing participant is corrupt.";
                goto LABEL_174;
              }
LABEL_177:
              v41 = 6;
              goto LABEL_178;
            }
          }
          goto LABEL_107;
        }
        v92 = *re::networkLogObjects(v12);
        v43 = os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
        if (v43)
        {
          *(_WORD *)v167 = 0;
          _os_log_error_impl(&dword_21C69B000, v92, OS_LOG_TYPE_ERROR, "Error receiving message of type kPeerHello: invalid peerid", v167, 2u);
        }
        v41 = 8;
LABEL_180:
        v112 = *re::networkLogObjects((re *)v43);
        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v167 = 67109120;
          *(_DWORD *)&v167[4] = v41;
          _os_log_error_impl(&dword_21C69B000, v112, OS_LOG_TYPE_ERROR, "Aborting transport receive due to packet error: %d", v167, 8u);
        }
        goto LABEL_182;
      case 3u:
        v38 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
          v86 = &v167[9];
          if ((v167[8] & 1) != 0)
            v86 = *(uint8_t **)&v167[16];
          *(_DWORD *)v162 = 136315138;
          *(_QWORD *)&v162[4] = v86;
          _os_log_debug_impl(&dword_21C69B000, v38, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kSessionError from %s", v162, 0xCu);
          if (*(_QWORD *)v167 && (v167[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)v167 + 40))();
        }
        *(_DWORD *)v167 = 0;
        v39 = re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
        v40 = *(_DWORD *)v167;
        if (*(_DWORD *)v167 >= 0x11u)
          v41 = 6;
        else
          v41 = *(_DWORD *)v167;
        v42 = *re::networkLogObjects((re *)v39);
        v43 = os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
        if (v43)
        {
          *(_DWORD *)v167 = 134218240;
          *(_QWORD *)&v167[4] = a2;
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = v40;
          _os_log_error_impl(&dword_21C69B000, v42, OS_LOG_TYPE_ERROR, "Connection error received from ConnectionId(%llu) Error = 0x%X", v167, 0x12u);
        }
        if (v41 != 1)
          goto LABEL_180;
        v44 = v155;
        goto LABEL_108;
      case 4u:
        v45 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)v167 = 0;
          _os_log_debug_impl(&dword_21C69B000, v45, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kRouteRequest", v167, 2u);
        }
        *(_DWORD *)v167 = 0;
        v46 = re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
        if (v155)
        {
          v93 = *re::networkLogObjects((re *)v46);
          if (!os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
            goto LABEL_144;
          re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
          v94 = &v167[9];
          if ((v167[8] & 1) != 0)
            v94 = *(uint8_t **)&v167[16];
          goto LABEL_231;
        }
        v47 = *(_DWORD *)v167;
        *(_QWORD *)v162 = (char *)this + 2320;
        *(_QWORD *)&v162[8] = a2;
        *(_DWORD *)&v162[16] = *(_DWORD *)v167;
        re::RoutingTable::addRoute(*((_QWORD *)this + 380), v10, (__int128 *)v162);
        re::RoutingTable::getRoute(*((re::RoutingTable **)this + 380), v9, (uint64_t)v167);
        if (v167[0])
        {
          re::Session::sendRouteResponse(*((re::Session **)this + 380), v9, v10, *(_DWORD *)&v167[24] + 1);
        }
        else if (v47 <= 1)
        {
          re::Session::broadcastRouteRequest((_BOOL8)this, a2, v10, v9, v47 + 1);
        }
        goto LABEL_107;
      case 5u:
        v48 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)v167 = 0;
          _os_log_debug_impl(&dword_21C69B000, v48, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kRouteResponse", v167, 2u);
        }
        *(_DWORD *)v167 = 0;
        v49 = re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
        if (v155)
        {
          v93 = *re::networkLogObjects((re *)v49);
          if (!os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
            goto LABEL_144;
          re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
          v94 = &v167[9];
          if ((v167[8] & 1) != 0)
            v94 = *(uint8_t **)&v167[16];
          goto LABEL_231;
        }
        v50 = *(_DWORD *)v167;
        *(_QWORD *)v162 = (char *)this + 2320;
        *(_QWORD *)&v162[8] = a2;
        *(_DWORD *)&v162[16] = *(_DWORD *)v167;
        re::RoutingTable::addRoute(*((_QWORD *)this + 380), v10, (__int128 *)v162);
        *(_QWORD *)v167 = v9;
        *(_QWORD *)&v167[8] = v10;
        re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::remove((uint64_t)v150, v167);
        if (re::Session::peerID(this) == v9)
        {
          v51 = *((_QWORD *)this + 383);
          if (v51)
          {
            v52 = 0;
            do
            {
              v53 = *((_QWORD *)this + 385);
              v54 = v53 + 40 * v52;
              if (*(_QWORD *)(v54 + 8) == v10)
              {
                Route = re::RoutingTable::getRoute(*((re::RoutingTable **)this + 380), v10, (uint64_t)v167);
                v56 = *(_QWORD *)(*(_QWORD *)&v167[8] + 600);
                if (v56)
                {
                  v57 = *(_QWORD *)(v56 + 2296);
                  if (v57)
                  {
                    v58 = *(uint64_t **)(v56 + 2312);
                    v59 = 8 * v57;
                    while (1)
                    {
                      v60 = *v58;
                      if (*(_QWORD *)(*v58 + 32) == *(_QWORD *)&v167[16])
                        break;
                      ++v58;
                      v59 -= 8;
                      if (!v59)
                        goto LABEL_56;
                    }
                    v63 = (id)(v60 + 8);
                    v65 = PacketUtils::move(*(PacketUtils **)v54, (re::PacketPool **)v151, *(re::PacketPool ***)&v167[8], v64);
                    re::Transport::send(*(uint64_t *)&v167[8], *(unint64_t *)&v167[16], (unint64_t)v65, *(unsigned __int8 *)(v53 + 40 * v52 + 16), 0, *(unsigned __int8 *)(v53 + 40 * v52 + 32), *(_DWORD *)(v60 + 72));
                    re::DynamicArray<re::Session::PendingMessage>::removeStableAt(v152, v52);

                  }
                  else
                  {
LABEL_56:
                    v61 = *re::networkLogObjects((re *)Route);
                    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl(&dword_21C69B000, v61, OS_LOG_TYPE_ERROR, "receiveRouteResponse: missing participant for connection!", buf, 2u);
                    }
                    re::PacketPool::free(*((re::PacketPool **)this + 338), *(re::Packet **)v54);
                    re::DynamicArray<re::Session::PendingMessage>::removeStableAt(v152, v52);
                  }
                }
                else
                {
                  v62 = *re::networkLogObjects((re *)Route);
                  if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_error_impl(&dword_21C69B000, v62, OS_LOG_TYPE_ERROR, "receiveRouteResponse: missing session for transport!", buf, 2u);
                  }
                }
                v51 = *((_QWORD *)this + 383);
              }
              else
              {
                ++v52;
              }
            }
            while (v52 < v51);
          }
        }
        else if (v50 <= 2)
        {
          re::Session::sendRouteResponse(*((re::Session **)this + 380), v10, v9, v50 + 1);
        }
        v44 = 0;
        goto LABEL_108;
      case 6u:
        v66 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)v167 = 0;
          _os_log_debug_impl(&dword_21C69B000, v66, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kRouteFail", v167, 2u);
        }
        *(_DWORD *)v167 = 0;
        v67 = re::BitReader::readUInt32Bits(&v153, 0x20u, (unsigned int *)v167);
        if (!v155)
        {
          v68 = *(_DWORD *)v167;
          *(_QWORD *)v167 = v10;
          *(_QWORD *)&v167[8] = v9;
          re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::remove((uint64_t)v150, v167);
          v69 = (re *)re::Session::peerID(this);
          if (v69 == (re *)v9)
          {
            v70 = *re::networkLogObjects(v69);
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v167 = 134217984;
              *(_QWORD *)&v167[4] = v9;
              _os_log_impl(&dword_21C69B000, v70, OS_LOG_TYPE_DEFAULT, "Received route failure for PeerID. (%llu)", v167, 0xCu);
            }
            re::RoutingTable::removeRouteForPeerID(*((re::RoutingTable **)this + 380), v10);
            v71 = *((_QWORD *)this + 383);
            if (v71)
            {
              v72 = 0;
              do
              {
                v73 = *((_QWORD *)this + 385);
                if (*(_QWORD *)(v73 + 40 * v72 + 8) == v10)
                {
                  re::PacketPool::free(*((re::PacketPool **)this + 338), *(re::Packet **)(v73 + 40 * v72));
                  re::DynamicArray<re::Session::PendingMessage>::removeStableAt(v152, v72);
                  v71 = *((_QWORD *)this + 383);
                }
                else
                {
                  ++v72;
                }
              }
              while (v72 < v71);
            }
            re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1528, (uint64_t)this);
          }
          else if (v68 <= 2)
          {
            re::Session::sendRouteFail(*((re::Session **)this + 380), v10, v9, v68 + 1);
          }
LABEL_107:
          v44 = 0;
LABEL_108:
          if (v154 == (_DWORD)v156 || v44)
            goto LABEL_144;
          continue;
        }
        v93 = *re::networkLogObjects((re *)v67);
        if (!os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
          goto LABEL_144;
        re::Transport::connectionAddress(v151, a2, (re::DynamicString *)v167);
        v94 = &v167[9];
        if ((v167[8] & 1) != 0)
          v94 = *(uint8_t **)&v167[16];
LABEL_231:
        *(_DWORD *)v162 = 136315138;
        *(_QWORD *)&v162[4] = v94;
        _os_log_error_impl(&dword_21C69B000, v93, OS_LOG_TYPE_ERROR, "No hop specified in route request from %s", v162, 0xCu);
        if (*(_QWORD *)v167 && (v167[8] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)v167 + 40))();
LABEL_144:
        v5 = v158;
LABEL_145:
        re::PacketPool::free(*((re::PacketPool **)this + 338), v5);
LABEL_222:
        if (re::Transport::receive((uint64_t)v151, a2, 0, (unint64_t **)&v158))
          goto LABEL_6;
        return;
      default:
        v91 = *re::networkLogObjects((re *)v7);
        v43 = os_log_type_enabled(v91, OS_LOG_TYPE_ERROR);
        if (v43)
        {
          *(_DWORD *)v167 = 67109120;
          *(_DWORD *)&v167[4] = v8;
          _os_log_error_impl(&dword_21C69B000, v91, OS_LOG_TYPE_ERROR, "Received unrecognized message type: %d", v167, 8u);
        }
        v41 = 9;
        goto LABEL_180;
    }
  }
}

void re::Session::beforeFrameUpdate(re::Session *this)
{
  re::Session *v1;
  re::PacketPool **v2;
  re *v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  char *v22;
  _anonymous_namespace_ *v23;
  int v24;
  uint64_t *RoutingHeader;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  int v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  _anonymous_namespace_ *v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  BOOL v50;
  unint64_t v51;
  unint64_t v52;
  _OWORD *v53;
  NSObject *v54;
  unint64_t *Route;
  re::Transport *v56;
  NSObject *v57;
  uint64_t v58;
  uint64_t v59;
  id v60;
  re *v61;
  uint64_t v62;
  re *v63;
  uint64_t i;
  unint64_t v65;
  uint64_t v66;
  NSObject *v67;
  unint64_t v68;
  uint8_t *v69;
  int v70;
  unint64_t *v71;
  uint64_t v72;
  unint64_t *v73;
  uint64_t v74;
  _QWORD *v75;
  re::Transport *v76;
  int *v77;
  uint64_t v78;
  _QWORD *v79;
  unint64_t *v80;
  _BYTE v81[16];
  char v82[8];
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  char v87;
  uint64_t v88;
  uint64_t v89;
  re::Packet *v90;
  char v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _BYTE v96[40];
  _BYTE v97[12];
  __int16 v98;
  int v99;
  __int16 v100;
  unint64_t v101;
  __int16 v102;
  unint64_t v103;
  uint8_t buf[32];
  __int128 v105;
  __int128 v106;
  __int128 v107;
  uint64_t v108;

  v108 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 816) == 3)
    return;
  v1 = this;
  re::Session::stateEvent((_BOOL8)this, 2);
  (*(void (**)(_QWORD))(**((_QWORD **)v1 + 940) + 48))(*((_QWORD *)v1 + 940));
  (*(void (**)(_QWORD))(**((_QWORD **)v1 + 928) + 64))(*((_QWORD *)v1 + 928));
  v2 = (re::PacketPool **)((char *)v1 + 2320);
  re::Transport::flushNetworkEvents((re::Session *)((char *)v1 + 2320));
  if (*((_QWORD *)v1 + 299))
  {
    re::TransportCommandsQueued::update((re::Session *)((char *)v1 + 7528));
    v3 = (re *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v1 + 330) + 24))(*((_QWORD *)v1 + 330));
    if (*((_DWORD *)v1 + 758) != 1)
    {
      v4 = *re::networkLogObjects(v3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = *((_DWORD *)v1 + 758);
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v1;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v5;
        _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Stopping Session (%p) with error:%d after flushing transport events", buf, 0x12u);
      }
      re::Session::stopSession((uint64_t)v1, *((_DWORD *)v1 + 758));
    }
  }
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v81, 6032, (uint64_t)v1);
  v6 = *((_QWORD *)v1 + 405);
  v76 = (re::Session *)((char *)v1 + 2320);
  if (!v6)
    goto LABEL_110;
  v7 = (unint64_t *)*((_QWORD *)v1 + 407);
  v71 = &v7[v6];
  v75 = (_QWORD *)((char *)v1 + 472);
  while (1)
  {
    v73 = v7;
    v8 = *v7;
    v9 = *((_QWORD *)v1 + 287);
    if (v9)
    {
      v10 = (uint64_t *)*((_QWORD *)v1 + 289);
      v11 = 8 * v9;
      while (1)
      {
        v12 = *v10;
        if (*(_QWORD *)(*v10 + 32) == v8)
          break;
        ++v10;
        v11 -= 8;
        if (!v11)
          goto LABEL_14;
      }
      v16 = (id)(v12 + 8);
      re::Session::processIncomingMessages(v1, v8);
    }
    else
    {
      v13 = *((_QWORD *)v1 + 395);
      if (!v13)
        goto LABEL_24;
LABEL_14:
      v14 = (_QWORD *)*((_QWORD *)v1 + 397);
      v15 = 80 * v13;
      while (*v14 != v8)
      {
        v14 += 10;
        v15 -= 80;
        if (!v15)
          goto LABEL_24;
      }
      re::Session::processIncomingMessages(v1, *v7);
      v17 = *((_QWORD *)v1 + 287);
      if (v17)
      {
        v18 = (uint64_t *)*((_QWORD *)v1 + 289);
        v19 = 8 * v17;
        while (1)
        {
          v12 = *v18;
          if (*(_QWORD *)(*v18 + 32) == v8)
            break;
          ++v18;
          v19 -= 8;
          if (!v19)
            goto LABEL_24;
        }
        v60 = (id)(v12 + 8);
      }
      else
      {
LABEL_24:
        v12 = 0;
      }
    }
    if (*((_DWORD *)v1 + 816) == 3)
      goto LABEL_107;
    if (v12)
      break;
LABEL_103:
    if (++v7 == v71)
      goto LABEL_109;
  }
  v20 = (_DWORD *)re::DataArray<re::Connection>::tryGet((uint64_t)v1 + 2440, *(_QWORD *)(v12 + 32));
  if (!v20 || *v20 != 1)
  {
LABEL_101:
    if (*((_DWORD *)v1 + 816) == 3)
      goto LABEL_108;

    goto LABEL_103;
  }
  v90 = 0;
  v72 = v12 + 49;
  v21 = 3;
  v74 = v12;
  while (!re::Transport::receive((uint64_t)v2, *(_QWORD *)(v12 + 32), v21, (unint64_t **)&v90))
  {
LABEL_99:
    if (++v21 == 10)
    {
      v7 = v73;
      goto LABEL_101;
    }
  }
  v22 = (char *)v1 + 88 * v21;
  v23 = (_anonymous_namespace_ *)(v22 + 560);
  v77 = (int *)(v22 + 640);
  v78 = v21;
  v79 = v22 + 632;
  v80 = (unint64_t *)(v22 + 616);
  while (2)
  {
    v24 = *((_DWORD *)v90 + 6);
    v85 = *((_QWORD *)v90 + 2);
    v86 = v24;
    v87 = 0;
    v88 = 0;
    v89 = 0;
    RoutingHeader = re::Session::readRoutingHeader((re::Session *)v82, (re::BitReader *)&v85);
    if (!v82[0])
    {
      v54 = *re::networkLogObjects((re *)RoutingHeader);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        v58 = v72;
        if ((*(_QWORD *)(v12 + 48) & 1) != 0)
          v58 = *(_QWORD *)(v12 + 56);
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v58;
        _os_log_error_impl(&dword_21C69B000, v54, OS_LOG_TYPE_ERROR, "Received corrupt message from '%s'. No routing header. Disconnecting.", buf, 0xCu);
      }
      re::PacketPool::free(*((re::PacketPool **)v1 + 338), v90);
LABEL_91:
      if (!re::Transport::receive((uint64_t)v2, *(_QWORD *)(v12 + 32), v21, (unint64_t **)&v90))
        goto LABEL_99;
      continue;
    }
    break;
  }
  v27 = v83;
  v26 = v84;
  if (v26 != re::Session::peerID(v1))
  {
    Route = re::RoutingTable::getRoute(*((re::RoutingTable **)v1 + 380), v26, (uint64_t)buf);
    if (buf[0])
    {
      v90 = (re::Packet *)PacketUtils::move(v90, v2, *(re::PacketPool ***)&buf[8], v56);
      v21 = v78;
      re::Transport::send(*(uint64_t *)&buf[8], *(unint64_t *)&buf[16], (unint64_t)v90, v78, 0, 0, *(_DWORD *)(v12 + 72));
    }
    else
    {
      v57 = *re::networkLogObjects((re *)Route);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        v59 = v72;
        if ((*(_QWORD *)(v12 + 48) & 1) != 0)
          v59 = *(_QWORD *)(v12 + 56);
        *(_DWORD *)v96 = 136315650;
        *(_QWORD *)&v96[4] = v59;
        *(_WORD *)&v96[12] = 2048;
        *(_QWORD *)&v96[14] = v27;
        *(_WORD *)&v96[22] = 2048;
        *(_QWORD *)&v96[24] = v26;
        _os_log_error_impl(&dword_21C69B000, v57, OS_LOG_TYPE_ERROR, "Received message with unknown route from '%s'. No route exists %llu->%llu.", v96, 0x20u);
      }
      re::PacketPool::free(*((re::PacketPool **)v1 + 338), v90);
      re::Session::sendRouteFail(*((re::Session **)v1 + 380), v26, v27, 1u);
      v21 = v78;
    }
    goto LABEL_91;
  }
  if (v87)
    v28 = 0;
  else
    v28 = v85 + v88;
  v29 = v86 - v88;
  v91 = v78;
  v93 = v28;
  v94 = v27;
  v92 = v86 - v88;
  v30 = (*v77)++;
  if (*((_QWORD *)v23 + 2))
  {
    v31 = 0;
    do
    {
      if ((*(unsigned int (**)(re::Session *))(*((_QWORD *)v23 + 4) + 32 * v31 + 24))(v1) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v23, v31);
      else
        ++v31;
    }
    while (v31 < *((_QWORD *)v23 + 2));
    v30 = *v77 - 1;
  }
  *v77 = v30;
  if (v30 || (v32 = *v80) == 0)
  {
LABEL_54:
    v21 = v78;
    v2 = (re::PacketPool **)((char *)v1 + 2320);
    if (v78 == 3)
    {
      v93 = v28;
      v94 = v27;
      v92 = v29;
      v38 = *((_DWORD *)v1 + 138);
      *((_DWORD *)v1 + 138) = v38 + 1;
      if (*((_QWORD *)v1 + 61))
      {
        v39 = 0;
        do
        {
          if ((*(unsigned int (**)(re::Session *))(*((_QWORD *)v1 + 63) + 32 * v39 + 24))(v1) == 1)
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v75, v39);
          else
            ++v39;
        }
        while (v39 < *((_QWORD *)v1 + 61));
        v38 = *((_DWORD *)v1 + 138) - 1;
      }
      *((_DWORD *)v1 + 138) = v38;
      if (!v38)
      {
        v40 = *((_QWORD *)v1 + 66);
        if (v40)
        {
          v41 = 0;
          v42 = 0;
          while (1)
          {
            v43 = *((_QWORD *)v1 + 66);
            if (v43 <= v42)
              break;
            v44 = *((_QWORD *)v1 + 68) + v41;
            *(_OWORD *)v96 = *(_OWORD *)v44;
            *(_OWORD *)&v96[16] = *(_OWORD *)(v44 + 16);
            *(_QWORD *)&v96[32] = *(_QWORD *)(v44 + 32);
            if (v96[0])
            {
              v45 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)buf, *((_QWORD *)v1 + 61), *((char **)v1 + 63), &v96[8]);
              if (!buf[0])
              {
                v46 = *((_QWORD *)v1 + 60);
                v47 = *((_QWORD *)v1 + 61);
                if (v47 >= v46)
                {
                  v48 = v47 + 1;
                  if (v46 < v47 + 1)
                  {
                    if (*v75)
                    {
                      v49 = 2 * v46;
                      v50 = v46 == 0;
                      v51 = 8;
                      if (!v50)
                        v51 = v49;
                      if (v51 <= v48)
                        v52 = v48;
                      else
                        v52 = v51;
                      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v75, v52);
                    }
                    else
                    {
                      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v75, v48);
                      ++*((_DWORD *)v1 + 124);
                    }
                  }
                  v47 = *((_QWORD *)v1 + 61);
                }
                v53 = (_OWORD *)(*((_QWORD *)v1 + 63) + 32 * v47);
                *v53 = *(_OWORD *)&v96[8];
                v53[1] = *(_OWORD *)&v96[24];
                ++*((_QWORD *)v1 + 61);
                ++*((_DWORD *)v1 + 124);
              }
            }
            else
            {
              re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)buf, *((_QWORD *)v1 + 61), *((char **)v1 + 63), &v96[8]);
              if (buf[0])
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v75, *(unint64_t *)&buf[8]);
            }
            ++v42;
            v41 += 40;
            if (v40 == v42)
              goto LABEL_83;
          }
          v95 = 0;
          v106 = 0u;
          v107 = 0u;
          v105 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v97 = 136315906;
          *(_QWORD *)&v97[4] = "operator[]";
          v98 = 1024;
          v99 = 789;
          v100 = 2048;
          v101 = v42;
          v102 = 2048;
          v103 = v43;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_126:
          *(_QWORD *)v97 = 0;
          v106 = 0u;
          v107 = 0u;
          v105 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v96 = 136315906;
          *(_QWORD *)&v96[4] = "operator[]";
          *(_WORD *)&v96[12] = 1024;
          *(_DWORD *)&v96[14] = 789;
          *(_WORD *)&v96[18] = 2048;
          *(_QWORD *)&v96[20] = v40;
          *(_WORD *)&v96[28] = 2048;
          *(_QWORD *)&v96[30] = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
LABEL_83:
      v21 = 3;
    }
    re::PacketPool::free(*((re::PacketPool **)v1 + 338), v90);
    v12 = v74;
    goto LABEL_91;
  }
  v12 = 0;
  v33 = 0;
  while (1)
  {
    v34 = *v80;
    if (*v80 <= v33)
      break;
    v35 = *v79 + v12;
    v36 = *(_QWORD *)(v35 + 32);
    v37 = *(_OWORD *)(v35 + 16);
    *(_OWORD *)v96 = *(_OWORD *)v35;
    *(_OWORD *)&v96[16] = v37;
    *(_QWORD *)&v96[32] = v36;
    if (v96[0])
    {
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v23, &v96[8], (uint64_t)buf);
      if (!buf[0])
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v23, (uint64_t)&v96[8]);
    }
    else
    {
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v23, &v96[8], (uint64_t)buf);
      if (buf[0])
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v23, *(unint64_t *)&buf[8]);
    }
    ++v33;
    v12 += 40;
    if (v32 == v33)
      goto LABEL_54;
  }
  v95 = 0;
  v106 = 0u;
  v107 = 0u;
  v105 = 0u;
  memset(buf, 0, sizeof(buf));
  v1 = (re::Session *)MEMORY[0x24BDACB70];
  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
  *(_DWORD *)v97 = 136315906;
  *(_QWORD *)&v97[4] = "operator[]";
  v98 = 1024;
  v99 = 789;
  v100 = 2048;
  v101 = v33;
  v102 = 2048;
  v103 = v34;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_107:
  if (v12)
LABEL_108:

LABEL_109:
  *((_QWORD *)v1 + 405) = 0;
  ++*((_DWORD *)v1 + 812);
LABEL_110:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v81);
  v61 = (re *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v1 + 282) + 32))(*((_QWORD *)v1 + 282));
  v62 = *((_QWORD *)v1 + 395);
  if (v62)
  {
    v63 = v61;
    v40 = v62 - 1;
    for (i = 80 * v62; ; i -= 80)
    {
      v42 = *((_QWORD *)v1 + 395);
      if (v42 <= v40)
        break;
      v65 = *((unsigned int *)v1 + 543);
      if ((_DWORD)v65)
      {
        v66 = *((_QWORD *)v1 + 397) + i;
        if ((unint64_t)v63 - *(_QWORD *)(v66 - 48) >= v65)
        {
          v67 = *re::networkLogObjects(v61);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            re::Transport::connectionAddress(v76, *(_QWORD *)(v66 - 80), (re::DynamicString *)buf);
            if ((buf[8] & 1) != 0)
              v69 = *(uint8_t **)&buf[16];
            else
              v69 = &buf[9];
            v70 = *((_DWORD *)v1 + 543);
            *(_DWORD *)v96 = 136315394;
            *(_QWORD *)&v96[4] = v69;
            *(_WORD *)&v96[12] = 1024;
            *(_DWORD *)&v96[14] = v70;
            _os_log_error_impl(&dword_21C69B000, v67, OS_LOG_TYPE_ERROR, "Connection '%s' did not do handshake for %d ms. Disconnecting.", v96, 0x12u);
            if (*(_QWORD *)buf)
            {
              if ((buf[8] & 1) != 0)
                (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, *(_QWORD *)&buf[16]);
            }
          }
          v68 = *(_QWORD *)(v66 - 80);
          re::DynamicArray<re::Session::BacklogItem>::removeAt((uint64_t)v1 + 3144, v40);
          re::Transport::disconnect(v76, v68, 0);
        }
      }
      if (--v40 == -1)
        return;
    }
    goto LABEL_126;
  }
}

void re::Session::stateEvent(_BOOL8 a1, uint64_t a2)
{
  re *v2;
  unint64_t v3;
  uint64_t v5;
  NSObject *v6;
  char *v7;
  char *v8;
  int v9;
  uint64_t v10;
  re *v11;
  re *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  id v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  re *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  uint64_t i;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  NSObject *v39;
  re::Transport *v40;
  uint64_t v41;
  const void *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  const void *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint8_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t *v60;
  uint64_t *v61;
  NSObject *v63;
  _BOOL8 v64;
  int v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  re *v70;
  uint64_t v71;
  char *v72;
  size_t v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  id v78;
  NSObject *v79;
  void *v80;
  id v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  id v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  __int128 v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  re::Transport *v95;
  re::Transport *v96;
  re::Transport *v97;
  uint64_t v98;
  __int128 v99;
  int v100;
  uint64_t v101;
  _BYTE v102[40];
  _BYTE v103[12];
  __int16 v104;
  int v105;
  __int16 v106;
  re *v107;
  __int16 v108;
  _BYTE *v109;
  uint8_t buf[32];
  __int128 v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;

  v5 = a1;
  v114 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a2 != 2)
  {
    v6 = *re::networkLogObjects((re *)a1);
    a1 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v7;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v8;
      _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "Session: handling event '%s' in state '%s'", buf, 0x16u);
    }
  }
  v9 = *(_DWORD *)(v5 + 3264);
  switch(v9)
  {
    case 0:
      return;
    case 1:
      switch((int)a2)
      {
        case 0:
          *(_QWORD *)(v5 + 3288) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 2256) + 32))(*(_QWORD *)(v5 + 2256));
          return;
        case 1:
        case 3:
          return;
        case 2:
          v26 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 2256) + 32))(*(_QWORD *)(v5 + 2256));
          v27 = *(unsigned int *)(v5 + 2168);
          if (!(_DWORD)v27 || (unint64_t)v26 - *(_QWORD *)(v5 + 3288) < v27)
          {
            if (*(_DWORD *)(v5 + 3032) == 1)
            {
              v28 = re::Session::peerID((re::Session *)v5);
              re::Session::assignLocalPeerID((re::Session *)v5, v28);
              v29 = v5;
              v30 = 2;
            }
            else
            {
              v29 = v5;
              v30 = 3;
            }
            re::Session::stateSet(v29, v30);
            return;
          }
          v14 = *re::networkLogObjects(v26);
          if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_ERROR))
            goto LABEL_134;
          break;
        default:
          goto LABEL_142;
      }
      goto LABEL_131;
    case 2:
      switch((int)a2)
      {
        case 0:
          re::Session::stateEvent(v5, 3);
          re::Event<re::Session>::raise(v5 + 120, v5);
          return;
        case 1:
        case 5:
          return;
        case 2:
          v31 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 2256) + 32))(*(_QWORD *)(v5 + 2256));
          v32 = *(_QWORD *)(v5 + 3200);
          if (!v32)
            return;
          v11 = v31;
          v95 = (re::Transport *)(v5 + 2320);
          v14 = v32 - 1;
          for (i = 32 * v32; ; i -= 32)
          {
            v13 = *(_QWORD *)(v5 + 3200);
            if (v13 <= v14)
              break;
            v34 = *(_QWORD *)(v5 + 3216);
            v35 = *(unsigned int *)(v5 + 2172);
            if ((_DWORD)v35 && (unint64_t)v11 - *(_QWORD *)(v34 + i - 32) >= v35
              || ((v36 = v34 + i,
                   v37 = *(_QWORD *)(v34 + i - 8),
                   LODWORD(v38) = *(_DWORD *)(v5 + 2240),
                   v38 <= 1)
                ? (v38 = 1)
                : (v38 = v38),
                  v37 >= v38))
            {
              v31 = (re *)re::DynamicArray<re::Session::SendHandshakeInProgressEntry>::removeAt(v5 + 3184, v14);
            }
            else if (*(_DWORD *)(v5 + 3264) == 2
                   && (unint64_t)v11 - *(_QWORD *)(v34 + i - 24) >= *(_QWORD *)(v5 + 3296))
            {
              *(_QWORD *)(v36 - 8) = v37 + 1;
              *(_QWORD *)(v34 + i - 24) = v11;
              v39 = *re::networkLogObjects(v31);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
              {
                re::Transport::connectionAddress(v95, *(_QWORD *)(v34 + i - 16), (re::DynamicString *)buf);
                v55 = &buf[9];
                if ((buf[8] & 1) != 0)
                  v55 = *(uint8_t **)&buf[16];
                v56 = *(_QWORD *)(v36 - 8);
                *(_DWORD *)v102 = 136315394;
                *(_QWORD *)&v102[4] = v55;
                *(_WORD *)&v102[12] = 2048;
                *(_QWORD *)&v102[14] = v56;
                if (*(_QWORD *)buf && (buf[8] & 1) != 0)
                  (*(void (**)(void))(**(_QWORD **)buf + 40))();
              }
              v40 = *(re::Transport **)(v34 + i - 16);
              re::Session::localParticipant(buf, v5);
              v41 = *(_QWORD *)(*(_QWORD *)buf + 128);
              v96 = v40;
              if (v41)
                v42 = *(const void **)(*(_QWORD *)buf + 144);
              else
                v42 = 0;

              v43 = re::PacketPool::allocate(*(re::PacketPool **)(v5 + 2704), (v41 + 67));
              re::Packet::offsetBy((uint64_t)v43, 3);
              v44 = *((_QWORD *)v43 + 1);
              *(_BYTE *)(v44 + 2) = 0;
              *(_WORD *)v44 = 0;
              v45 = *((_QWORD *)v43 + 2);
              v46 = *((_DWORD *)v43 + 7);
              *(_QWORD *)buf = &off_24E072668;
              *(_QWORD *)&buf[8] = v45;
              *(_DWORD *)&buf[16] = v46;
              buf[20] = 0;
              *(_QWORD *)&buf[24] = 0;
              *(_QWORD *)&v111 = 0;
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 1u, 8u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 2152), 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 2156), 0x20u);
              v47 = *(_DWORD *)(v5 + 2164);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 2160), 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v47, 0x20u);
              v48 = re::Session::peerID((re::Session *)v5);
              v49 = HIDWORD(v48);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v48, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v49, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 3280), 0x20u);
              v50 = *(_QWORD *)(v5 + 2208);
              if (v50)
              {
                v51 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v50 + 64))(v50);
                v53 = v52;
              }
              else
              {
                v51 = 0;
                v53 = 0;
              }
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v53, 0x20u);
              re::BitWriter::writeData((re::BitWriter *)buf, v51, v53);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v41, 0x20u);
              re::BitWriter::writeData((re::BitWriter *)buf, v42, v41);
              v54 = *(_DWORD *)&buf[24];
              if (*(_DWORD *)&buf[28])
                v54 = *(_DWORD *)&buf[24] + 1;
              *((_DWORD *)v43 + 6) = v54;
              v31 = (re *)re::Transport::send((uint64_t)v95, (unint64_t)v96, (unint64_t)v43, 0, 0, 0, 0);
            }
            if (--v14 == -1)
              return;
          }
          goto LABEL_138;
        case 3:
          v14 = *(_QWORD *)(v5 + 3160);
          if (!v14)
            return;
          v57 = v5 + 3144;
          v97 = (re::Transport *)(v5 + 2320);
          v2 = (re *)&v102[8];
          break;
        case 4:
          v91 = *(_QWORD *)(v5 + 7424);
          v92 = re::Session::peerID((re::Session *)v5);
          v93 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v91 + 80))(v91, v92, v5 + 2280);
          *(_QWORD *)(v5 + 3136) = v93;
          re::Session::onLeaderChange((re::Session *)v5, v93);
          return;
        default:
          goto LABEL_143;
      }
      break;
    case 3:
      if ((_DWORD)a2 == 2)
        return;
      if ((_DWORD)a2)
      {
LABEL_141:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid event %d in state '%s'", "!\"Unreachable code\"", "stateFinished", 1417, a2, "Finished");
        _os_crash();
        __break(1u);
LABEL_142:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid event %d in state '%s'", "!\"Unreachable code\"", "stateInit", 1391, a2, "Init");
        _os_crash();
        __break(1u);
LABEL_143:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid event %d in state '%s'", "!\"Unreachable code\"", "stateActive", 1459, a2, "Active");
        _os_crash();
        __break(1u);
        JUMPOUT(0x21C6D0408);
      }
      v10 = *(_QWORD *)(v5 + 2296);
      if (!v10)
        goto LABEL_22;
      v11 = (re *)(v5 + 2280);
      v12 = (re *)(v5 + 2320);
      v13 = v5 + 384;
      v14 = v10 - 1;
      do
      {
        v15 = *(_QWORD *)(v5 + 2296);
        if (v15 <= v14)
        {
          *(_QWORD *)v103 = 0;
          v112 = 0u;
          v113 = 0u;
          v111 = 0u;
          memset(buf, 0, sizeof(buf));
          v5 = MEMORY[0x24BDACB70];
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v102 = 136315906;
          *(_QWORD *)&v102[4] = "operator[]";
          *(_WORD *)&v102[12] = 1024;
          *(_DWORD *)&v102[14] = 789;
          *(_WORD *)&v102[18] = 2048;
          *(_QWORD *)&v102[20] = v14;
          *(_WORD *)&v102[28] = 2048;
          *(_QWORD *)&v102[30] = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_134:
          v94 = *(_DWORD *)(v5 + 2168);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v94;
          _os_log_error_impl(&dword_21C69B000, (os_log_t)v14, OS_LOG_TYPE_ERROR, "Failed to initialize session in %d ms. Session will be terminated.", buf, 8u);
LABEL_131:
          re::Session::stopSession(v5, 2);
          return;
        }
        v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 2312) + 8 * v14) + 32);
        if (v16)
        {
          re::Transport::disconnect((re::Transport *)(v5 + 2320), v16, 1);
          v17 = *(_QWORD *)(v5 + 2296);
          if (v17 <= v14)
          {
            *(_QWORD *)v103 = 0;
            v112 = 0u;
            v113 = 0u;
            v111 = 0u;
            memset(buf, 0, sizeof(buf));
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v102 = 136315906;
            *(_QWORD *)&v102[4] = "operator[]";
            *(_WORD *)&v102[12] = 1024;
            *(_DWORD *)&v102[14] = 789;
            *(_WORD *)&v102[18] = 2048;
            *(_QWORD *)&v102[20] = v14;
            *(_WORD *)&v102[28] = 2048;
            *(_QWORD *)&v102[30] = v17;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_136;
          }
          v18 = *(_QWORD *)(*(_QWORD *)(v5 + 2312) + 8 * v14);
          v101 = v18;
          if (v18)
            v19 = (id)(v18 + 8);
          re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::raise(v5 + 384, v5);
          if (v101)
          {

            v101 = 0;
          }
          re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(v5 + 2280, v14);
        }
        --v14;
      }
      while (v14 != -1);
LABEL_22:
      v14 = v5 + 208;
      v20 = *(_DWORD *)(v5 + 288);
      *(_DWORD *)(v5 + 288) = v20 + 1;
      if (*(_QWORD *)(v5 + 224))
      {
        v21 = 0;
        do
        {
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(v5 + 240) + 32 * v21 + 24))(v5) == 1)
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v5 + 208), v21);
          else
            ++v21;
        }
        while (v21 < *(_QWORD *)(v5 + 224));
        v20 = *(_DWORD *)(v5 + 288) - 1;
      }
      *(_DWORD *)(v5 + 288) = v20;
      if (!v20)
      {
        v13 = *(_QWORD *)(v5 + 264);
        if (v13)
        {
          v22 = 0;
          v12 = 0;
          v11 = (re *)&v102[8];
          do
          {
            v2 = *(re **)(v5 + 264);
            if (v2 <= v12)
              goto LABEL_137;
            v23 = *(_QWORD *)(v5 + 280) + v22;
            v24 = *(_QWORD *)(v23 + 32);
            v25 = *(_OWORD *)(v23 + 16);
            *(_OWORD *)v102 = *(_OWORD *)v23;
            *(_OWORD *)&v102[16] = v25;
            *(_QWORD *)&v102[32] = v24;
            if (v102[0])
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 208, &v102[8], (uint64_t)buf);
              if (!buf[0])
                re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)(v5 + 208), (uint64_t)&v102[8]);
            }
            else
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 208, &v102[8], (uint64_t)buf);
              if (buf[0])
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v5 + 208), *(unint64_t *)&buf[8]);
            }
            v12 = (re *)((char *)v12 + 1);
            v22 += 40;
          }
          while ((re *)v13 != v12);
        }
      }
      return;
    default:
      _os_crash();
      __break(1u);
      goto LABEL_141;
  }
  while (1)
  {
    --v14;
    v11 = *(re **)(v5 + 3160);
    if ((unint64_t)v11 <= v14)
      goto LABEL_139;
    v58 = *(_QWORD *)(v5 + 3176);
    v59 = (uint64_t *)(v58 + 80 * v14);
    v60 = v59 + 1;
    v61 = v59 + 2;
    if (v59[1] && v59[2] != 0)
      break;
LABEL_125:
    if (!v14)
      return;
  }
  v63 = *re::networkLogObjects((re *)a1);
  v64 = os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT);
  if (v64)
  {
    v65 = *(_DWORD *)(v58 + 80 * v14 + 24);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v65;
    _os_log_impl(&dword_21C69B000, v63, OS_LOG_TYPE_DEFAULT, "Remote peer ready with capabilities 0x%x", buf, 8u);
  }
  if (*v60)
  {
    v66 = *(_QWORD *)(v5 + 2296);
    if (v66)
    {
      v67 = *(uint64_t **)(v5 + 2312);
      v68 = 8 * v66;
      while (1)
      {
        v69 = *v67;
        if (*(_QWORD *)(*v67 + 24) == *v60)
          break;
        ++v67;
        v68 -= 8;
        if (!v68)
          goto LABEL_87;
      }
      v80 = (void *)(v69 + 8);
      v81 = (id)(v69 + 8);
      v82 = v80;
    }
    else
    {
LABEL_87:
      if (re::internal::enableSignposts(0, 0))
        kdebug_trace();
      v70 = re::Transport::connectionAddress(v97, *v59, (re::DynamicString *)buf);
      v71 = v58 + 80 * v14;
      v72 = *(char **)(v71 + 72);
      v73 = *(_QWORD *)(v71 + 56);
      v74 = re::globalAllocators(v70);
      v75 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v74[2] + 32))(v74[2], 160, 8);
      *(_QWORD *)v102 = re::SessionParticipant::SessionParticipant(v75, *v60, *v59, (const re::DynamicString *)buf, *(_DWORD *)(v71 + 24), v72, v73);
      re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::add((_anonymous_namespace_ *)(v5 + 2280), v102);
      if (*(_QWORD *)v102)

      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, *(_QWORD *)&buf[16]);
      v76 = *(_QWORD *)(*(_QWORD *)(v5 + 2312) + 8 * *(_QWORD *)(v5 + 2296) - 8);
      v77 = *v61;
      if (*v61)
      {
        v78 = (id)(v77 + 8);
        re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v76 + 152), v77);

      }
      else
      {
        v83 = *(_QWORD *)(v76 + 152);
        if (v83)
        {

          *(_QWORD *)(v76 + 152) = 0;
        }
      }
      *(_QWORD *)&v99 = v5 + 2320;
      *((_QWORD *)&v99 + 1) = *v59;
      v100 = 1;
      re::RoutingTable::addRoute(*(_QWORD *)(v5 + 3040), *v60, &v99);
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 7424) + 88))(*(_QWORD *)(v5 + 7424), *v60);
      re::Session::stateEvent(v5, 5);
      v84 = *(_QWORD *)(*(_QWORD *)(v5 + 2312) + 8 * *(_QWORD *)(v5 + 2296) - 8);
      v98 = v84;
      if (v84)
        v85 = (id)(v84 + 8);
      v86 = *(_DWORD *)(v5 + 376);
      *(_DWORD *)(v5 + 376) = v86 + 1;
      v57 = v5 + 3144;
      if (*(_QWORD *)(v5 + 312))
      {
        v87 = 0;
        do
        {
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(v5 + 328) + 32 * v87 + 24))(v5) == 1)
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v5 + 296), v87);
          else
            ++v87;
        }
        while (v87 < *(_QWORD *)(v5 + 312));
        v86 = *(_DWORD *)(v5 + 376) - 1;
      }
      *(_DWORD *)(v5 + 376) = v86;
      if (!v86)
      {
        v12 = *(re **)(v5 + 352);
        if (v12)
        {
          v13 = 0;
          v11 = 0;
          while (1)
          {
            v3 = *(_QWORD *)(v5 + 352);
            if (v3 <= (unint64_t)v11)
              break;
            v88 = *(_QWORD *)(v5 + 368) + v13;
            v89 = *(_QWORD *)(v88 + 32);
            v90 = *(_OWORD *)(v88 + 16);
            *(_OWORD *)v102 = *(_OWORD *)v88;
            *(_OWORD *)&v102[16] = v90;
            *(_QWORD *)&v102[32] = v89;
            if (v102[0])
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 296, &v102[8], (uint64_t)buf);
              if (!buf[0])
                re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)(v5 + 296), (uint64_t)&v102[8]);
            }
            else
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 296, &v102[8], (uint64_t)buf);
              if (buf[0])
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(v5 + 296), *(unint64_t *)&buf[8]);
            }
            v11 = (re *)((char *)v11 + 1);
            v13 += 40;
            if (v12 == v11)
              goto LABEL_121;
          }
LABEL_136:
          v101 = 0;
          v112 = 0u;
          v113 = 0u;
          v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v103 = 136315906;
          *(_QWORD *)&v103[4] = "operator[]";
          v104 = 1024;
          v105 = 789;
          v106 = 2048;
          v107 = v11;
          v108 = 2048;
          v109 = (_BYTE *)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_137:
          *(_QWORD *)&v99 = 0;
          v112 = 0u;
          v113 = 0u;
          v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v103 = 136315906;
          *(_QWORD *)&v103[4] = "operator[]";
          v104 = 1024;
          v105 = 789;
          v106 = 2048;
          v107 = v12;
          v108 = 2048;
          v109 = v2;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_138:
          *(_QWORD *)v103 = 0;
          v112 = 0u;
          v113 = 0u;
          v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v102 = 136315906;
          *(_QWORD *)&v102[4] = "operator[]";
          *(_WORD *)&v102[12] = 1024;
          *(_DWORD *)&v102[14] = 789;
          *(_WORD *)&v102[18] = 2048;
          *(_QWORD *)&v102[20] = v14;
          *(_WORD *)&v102[28] = 2048;
          *(_QWORD *)&v102[30] = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_139:
          *(_QWORD *)v103 = 0;
          v112 = 0u;
          v113 = 0u;
          v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v102 = 136315906;
          *(_QWORD *)&v102[4] = "operator[]";
          *(_WORD *)&v102[12] = 1024;
          *(_DWORD *)&v102[14] = 789;
          *(_WORD *)&v102[18] = 2048;
          *(_QWORD *)&v102[20] = v14;
          *(_WORD *)&v102[28] = 2048;
          *(_QWORD *)&v102[30] = v11;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
LABEL_121:
      if (!v98)
        goto LABEL_124;
      v82 = (void *)(v98 + 8);
    }

  }
  else
  {
    v79 = *re::networkLogObjects((re *)v64);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v79, OS_LOG_TYPE_ERROR, "Invalid peerID", buf, 2u);
    }
    re::Transport::disconnect(v97, *v59, 0);
  }
LABEL_124:
  re::DynamicArray<re::Session::BacklogItem>::removeAt(v57, v14);
  goto LABEL_125;
}

void re::Session::afterFrameUpdate(re::Session *this)
{
  re::Transport *v2;
  int8x16_t v3;
  int8x16_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  std::chrono::steady_clock::time_point v12;
  uint64_t v13;
  int8x16_t *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t isStatisticCollectionEnabled;
  int64x2_t *v22;
  unint64_t v23;
  unint64_t v24;
  int64x2_t v25;
  uint64_t v26;
  int64x2_t *v27;
  unint64_t v28;
  unint64_t v29;
  int64x2_t v30;
  uint64_t v31;
  int64x2_t *v32;
  unint64_t v33;
  unint64_t v34;
  int64x2_t v35;
  re *v36;
  uint64_t v37;
  int64x2_t *v38;
  unint64_t v39;
  unint64_t v40;
  int64x2_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  re *v51;
  NSObject *v52;
  int8x16_t v53;
  int v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  unint64_t v59;
  __int16 v60;
  unint64_t v61;
  _DWORD buf[8];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 816) == 3)
    return;
  v2 = (re::Session *)((char *)this + 2320);
  re::Transport::hostStats((re::Session *)((char *)this + 2320), (uint64_t)buf);
  v5 = *((_QWORD *)this + 287);
  if (v5)
  {
    v6 = 0;
    v7 = 0;
    v8 = *((_QWORD *)this + 289);
    v9 = 8 * v5;
    v10 = 0.0;
    do
    {
      re::Transport::connectionStats(v2, *(_QWORD *)(*(_QWORD *)v8 + 32), (uint64_t)&v54);
      if ((_BYTE)v54)
      {
        v7 += v55;
        v10 = v10 + *((float *)&v55 + 1);
        ++v6;
      }
      v8 += 8;
      v9 -= 8;
    }
    while (v9);
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v10 = 0.0;
  }
  v3.i32[0] = 0;
  v4.i8[0] = buf[0];
  v11 = v10 / (float)v6;
  v53 = vbicq_s8(*(int8x16_t *)&buf[3], vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v4, v3), 0));
  *((_QWORD *)this + 927) = v53.i64[0];
  v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v13 = *((_QWORD *)this + 926);
  if (v13 - *((_QWORD *)this + 925) == 128)
    *((_QWORD *)this + 925) = v13 - 127;
  v14 = (int8x16_t *)((char *)this + 32 * (v13 & 0x7F));
  *((_QWORD *)this + 926) = v13 + 1;
  v14[206].i32[2] = v7 / v6;
  *(float *)&v14[206].i32[3] = v11;
  v14[207] = v53;
  *(std::chrono::steady_clock::time_point *)v14[208].i8 = v12;
  v15 = (_QWORD *)*((_QWORD *)this + 940);
  v17 = v15[11];
  v16 = v15[12];
  v19 = v15[13];
  v18 = v15[14];
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v20 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v20)
    v20 = kdebug_trace();
  isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v20);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    isStatisticCollectionEnabled = re::profilerThreadContext((re *)isStatisticCollectionEnabled);
    v22 = *(int64x2_t **)(isStatisticCollectionEnabled + 152);
    if (v22)
    {
      v23 = v22[164].u64[0];
      if (v23 >= v17)
        v23 = v17;
      v22[164].i64[0] = v23;
      v24 = v22[164].u64[1];
      if (v24 <= v17)
        v24 = v17;
      v22[164].i64[1] = v24;
      v25 = vdupq_n_s64(1uLL);
      v25.i64[0] = v17;
      v22[165] = vaddq_s64(v22[165], v25);
      *(_BYTE *)(isStatisticCollectionEnabled + 184) = 0;
    }
  }
  v26 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
  if ((_DWORD)v26)
  {
    v26 = re::profilerThreadContext((re *)v26);
    v27 = *(int64x2_t **)(v26 + 152);
    if (v27)
    {
      v28 = v27[168].u64[0];
      if (v28 >= v19)
        v28 = v19;
      v27[168].i64[0] = v28;
      v29 = v27[168].u64[1];
      if (v29 <= v19)
        v29 = v19;
      v27[168].i64[1] = v29;
      v30 = vdupq_n_s64(1uLL);
      v30.i64[0] = v19;
      v27[169] = vaddq_s64(v27[169], v30);
      *(_BYTE *)(v26 + 184) = 0;
    }
  }
  v31 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v26);
  if ((_DWORD)v31)
  {
    v31 = re::profilerThreadContext((re *)v31);
    v32 = *(int64x2_t **)(v31 + 152);
    if (v32)
    {
      v33 = v32[172].u64[0];
      if (v33 >= v16)
        v33 = v16;
      v32[172].i64[0] = v33;
      v34 = v32[172].u64[1];
      if (v34 <= v16)
        v34 = v16;
      v32[172].i64[1] = v34;
      v35 = vdupq_n_s64(1uLL);
      v35.i64[0] = v16;
      v32[173] = vaddq_s64(v32[173], v35);
      *(_BYTE *)(v31 + 184) = 0;
    }
  }
  v36 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v31);
  if ((_DWORD)v36)
  {
    v37 = re::profilerThreadContext(v36);
    v38 = *(int64x2_t **)(v37 + 152);
    if (v38)
    {
      v39 = v38[176].u64[0];
      if (v39 >= v18)
        v39 = v18;
      v38[176].i64[0] = v39;
      v40 = v38[176].u64[1];
      if (v40 <= v18)
        v40 = v18;
      v38[176].i64[1] = v40;
      v41 = vdupq_n_s64(1uLL);
      v41.i64[0] = v18;
      v38[177] = vaddq_s64(v38[177], v41);
      *(_BYTE *)(v37 + 184) = 0;
    }
  }
  re::Transport::flushOutgoingData(v2);
  v42 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 282) + 32))(*((_QWORD *)this + 282));
  v43 = *((_QWORD *)this + 383);
  v44 = v43 + 1;
  v45 = 40 * v43;
  do
  {
    if (!--v44)
      return;
    v46 = v42 - *(_QWORD *)(*((_QWORD *)this + 385) + v45 - 16);
    v45 -= 40;
  }
  while (v46 >> 4 < 0x753);
  v47 = 0;
  v48 = 0;
  v49 = v44 - 1;
  do
  {
    v50 = *((_QWORD *)this + 383);
    if (v50 <= v48)
    {
      v64 = 0u;
      v65 = 0u;
      v63 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v54 = 136315906;
      v55 = "operator[]";
      v56 = 1024;
      v57 = 789;
      v58 = 2048;
      v59 = v48;
      v60 = 2048;
      v61 = v50;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      v64 = 0u;
      v65 = 0u;
      v63 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v54 = 136315906;
      v55 = "removeManyStableAt";
      v56 = 1024;
      v57 = 986;
      v58 = 2048;
      v59 = v44 - 1;
      v60 = 2048;
      v61 = v48;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::PacketPool::free(*((re::PacketPool **)this + 338), *(re::Packet **)(*((_QWORD *)this + 385) + v47));
    ++v48;
    v47 += 40;
  }
  while (v44 != v48);
  v48 = *((_QWORD *)this + 383);
  if (v49 >= v48)
    goto LABEL_57;
  if (v48 != v44 && v49 < v48 - 1)
  {
    v51 = (re *)memmove(*((void **)this + 385), (const void *)(*((_QWORD *)this + 385) + v45 + 40), 40 * v48 - v45 - 47);
    v48 = *((_QWORD *)this + 383);
  }
  *((_QWORD *)this + 383) = v48 - v44;
  ++*((_DWORD *)this + 768);
  v52 = *re::networkLogObjects(v51);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 134217984;
    *(_QWORD *)&buf[1] = v44;
    _os_log_impl(&dword_21C69B000, v52, OS_LOG_TYPE_DEFAULT, "Removing %zu Pending Messages due to timeout.", (uint8_t *)buf, 0xCu);
  }
}

uint64_t *re::Session::readRoutingHeader(re::Session *this, re::BitReader *a2)
{
  uint64_t *result;
  char v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v7 = 0;
  v8 = 0;
  re::BitReader::readUInt64(a2, &v8);
  result = re::BitReader::readUInt64(a2, &v7);
  if (*((_BYTE *)a2 + 12))
  {
    v5 = 0;
  }
  else
  {
    v6 = v7;
    *((_QWORD *)this + 1) = v8;
    *((_QWORD *)this + 2) = v6;
    v5 = 1;
  }
  *(_BYTE *)this = v5;
  return result;
}

uint64_t re::Session::sendData(uint64_t a1, unint64_t a2, const void *a3, uint64_t a4, unsigned int a5, int a6, int a7)
{
  char *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  unint64_t *Route;
  uint64_t v22;
  uint64_t v23;
  re::PacketPool **v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _anonymous_namespace_ *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  BOOL v39;
  unint64_t v40;
  unint64_t v41;
  id v42;
  re::Transport *v43;
  char *v44;
  uint64_t v45;
  _BYTE v46[8];
  re::Transport *v47;
  unint64_t v48;
  uint8_t v49[4];
  uint64_t v50;
  __int16 v51;
  unint64_t v52;
  _BYTE buf[20];
  char v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 2392))
  {
    v29 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = a4;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a5;
      _os_log_impl(&dword_21C69B000, v29, OS_LOG_TYPE_DEFAULT, "Session: attempting to send %zu bytes on channel %d when not initialized. Data discarded.", buf, 0x12u);
    }
    return 14;
  }
  v14 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 2704), (a4 + 67));
  re::Packet::offsetBy((uint64_t)v14, 3);
  v15 = *((_QWORD *)v14 + 1);
  *(_BYTE *)(v15 + 2) = 0;
  *(_WORD *)v15 = 0;
  v16 = *((_QWORD *)v14 + 2);
  v17 = *((_DWORD *)v14 + 7);
  *(_QWORD *)buf = &off_24E072668;
  *(_QWORD *)&buf[8] = v16;
  *(_DWORD *)&buf[16] = v17;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v18 = re::Session::peerID((re::Session *)a1);
  v19 = HIDWORD(v18);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, v18, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, v19, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a2, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a2), 0x20u);
  re::BitWriter::writeData((re::BitWriter *)buf, a3, a4);
  v20 = v55;
  if (HIDWORD(v55))
    v20 = v55 + 1;
  *((_DWORD *)v14 + 6) = v20;
  Route = re::RoutingTable::getRoute(*(re::RoutingTable **)(a1 + 3040), a2, (uint64_t)v46);
  if (v46[0])
  {
    v22 = *((_QWORD *)v47 + 75);
    if (v22)
    {
      v23 = *(_QWORD *)(v22 + 2296);
      if (!v23)
        return 8;
      v24 = (re::PacketPool **)(a1 + 2320);
      v25 = *(uint64_t **)(v22 + 2312);
      v26 = 8 * v23;
      while (1)
      {
        v27 = *v25;
        if (*(_QWORD *)(*v25 + 32) == v48)
          break;
        ++v25;
        v26 -= 8;
        if (!v26)
          return 8;
      }
      v42 = (id)(v27 + 8);
      v44 = PacketUtils::move((PacketUtils *)v14, v24, (re::PacketPool **)v47, v43);
      re::Transport::send((uint64_t)v47, v48, (unint64_t)v44, a5, a7, a6, *(_DWORD *)(v27 + 72));

      return 1;
    }
    return 14;
  }
  v30 = *re::networkLogObjects((re *)Route);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    v31 = re::Session::peerID((re::Session *)a1);
    *(_DWORD *)v49 = 134218240;
    v50 = v31;
    v51 = 2048;
    v52 = a2;
    _os_log_impl(&dword_21C69B000, v30, OS_LOG_TYPE_DEFAULT, "No route exists for userData from %llu to %llu. Will try to discover route.", v49, 0x16u);
  }
  v32 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2256) + 32))(*(_QWORD *)(a1 + 2256));
  v33 = re::Session::peerID((re::Session *)a1);
  re::Session::broadcastRouteRequest(a1, 0, v33, a2, 1u);
  v35 = *(_QWORD *)(a1 + 3064);
  v36 = *(_QWORD *)(a1 + 3056);
  if (v35 >= v36)
  {
    v37 = v35 + 1;
    if (v36 < v35 + 1)
    {
      if (*(_QWORD *)(a1 + 3048))
      {
        v38 = 2 * v36;
        v39 = v36 == 0;
        v40 = 8;
        if (!v39)
          v40 = v38;
        if (v40 <= v37)
          v41 = v37;
        else
          v41 = v40;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity((_QWORD *)(a1 + 3048), v41);
      }
      else
      {
        re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity((_QWORD *)(a1 + 3048), v37);
        ++*(_DWORD *)(a1 + 3072);
      }
    }
    v35 = *(_QWORD *)(a1 + 3064);
  }
  v45 = *(_QWORD *)(a1 + 3080) + 40 * v35;
  *(_QWORD *)v45 = v14;
  *(_QWORD *)(v45 + 8) = a2;
  *(_BYTE *)(v45 + 16) = a5;
  *(_QWORD *)(v45 + 24) = v32;
  *(_BYTE *)(v45 + 32) = a6;
  ++*(_QWORD *)(a1 + 3064);
  ++*(_DWORD *)(a1 + 3072);
  return 1;
}

void re::Session::broadcastRouteRequest(_BOOL8 this, uint64_t a2, unint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  const char *v29;
  NSObject *v30;
  id v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v57;
  uint64_t v58;
  unsigned int v59[2];
  uint8_t buf[16];
  int v62;
  char v63;
  uint64_t v64;
  uint64_t v65;

  v8 = this;
  v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
  v10 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (a4 ^ (a4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a4 ^ (a4 >> 30))) >> 27));
  v11 = ((v10 ^ (v10 >> 31)) + ((v9 ^ (v9 >> 31)) << 6) + ((v9 ^ (v9 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v9 ^ (v9 >> 31);
  v12 = *(unsigned int *)(this + 3112);
  if ((_DWORD)v12)
  {
    v13 = *(unsigned int *)(*(_QWORD *)(this + 3096) + 4 * (v11 % v12));
    if ((_DWORD)v13 != 0x7FFFFFFF)
    {
      v48 = *(_QWORD *)(this + 3104);
      v49 = v48 + 32 * v13;
      v51 = *(_QWORD *)(v49 + 16);
      v50 = *(_QWORD *)(v49 + 24);
      if (v51 == a3 && v50 == a4)
        return;
      while (1)
      {
        v13 = *(_DWORD *)(v48 + 32 * v13 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v13 == 0x7FFFFFFF)
          break;
        v53 = v48 + 32 * v13;
        v55 = *(_QWORD *)(v53 + 16);
        v54 = *(_QWORD *)(v53 + 24);
        if (v55 == a3 && v54 == a4)
          return;
      }
    }
  }
  v14 = *(_QWORD *)(this + 3040);
  v15 = *(_QWORD *)(v14 + 48);
  if (!v15)
    goto LABEL_25;
  v57 = v11;
  v58 = this;
  v16 = *(_QWORD *)(v14 + 64);
  v17 = v16 + 40 * v15;
  v18 = (char *)(this + 2320);
  *(_QWORD *)v59 = HIDWORD(a4);
  do
  {
    if (*(_DWORD *)(v16 + 24) > 1u)
      goto LABEL_23;
    v20 = *(_QWORD *)(v16 + 8);
    v19 = *(_QWORD *)(v16 + 16);
    if ((char *)v20 == v18 && v19 == a2)
      goto LABEL_23;
    v22 = *(_QWORD *)(v20 + 600);
    if (!v22)
    {
      v30 = *re::networkLogObjects((re *)this);
      this = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      if (!this)
        goto LABEL_23;
      *(_WORD *)buf = 0;
      v28 = v30;
      v29 = "sendRouteRequest: missing session for transport!";
      goto LABEL_19;
    }
    v23 = *(_QWORD *)(v22 + 2296);
    if (!v23)
    {
LABEL_15:
      v27 = *re::networkLogObjects((re *)this);
      this = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if (!this)
        goto LABEL_23;
      *(_WORD *)buf = 0;
      v28 = v27;
      v29 = "sendRouteRequest: missing participant for connection!";
LABEL_19:
      _os_log_error_impl(&dword_21C69B000, v28, OS_LOG_TYPE_ERROR, v29, buf, 2u);
      goto LABEL_23;
    }
    v24 = *(uint64_t **)(v22 + 2312);
    v25 = 8 * v23;
    while (1)
    {
      v26 = *v24;
      if (*(_QWORD *)(*v24 + 32) == v19)
        break;
      ++v24;
      v25 -= 8;
      if (!v25)
        goto LABEL_15;
    }
    v31 = (id)(v26 + 8);
    v32 = re::PacketPool::allocate(*(re::PacketPool **)(v20 + 384), 67);
    re::Packet::offsetBy((uint64_t)v32, 3);
    v33 = *((_QWORD *)v32 + 1);
    *(_BYTE *)(v33 + 2) = 0;
    *(_WORD *)v33 = 0;
    v34 = *((_QWORD *)v32 + 2);
    v35 = *((_DWORD *)v32 + 7);
    *(_QWORD *)buf = &off_24E072668;
    *(_QWORD *)&buf[8] = v34;
    v62 = v35;
    v63 = 0;
    v64 = 0;
    v65 = 0;
    re::BitWriter::writeUInt32Bits((uint64_t)buf, a3, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a3), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, a4, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, v59[0], 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, 4u, 8u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, a5, 0x20u);
    v36 = v64;
    if (HIDWORD(v64))
      v36 = v64 + 1;
    *((_DWORD *)v32 + 6) = v36;
    re::Transport::send(v20, v19, (unint64_t)v32, 0, 0, 0, *(_DWORD *)(v26 + 72));

LABEL_23:
    v16 += 40;
  }
  while (v16 != v17);
  v11 = v57;
  v8 = v58;
  LODWORD(v12) = *(_DWORD *)(v58 + 3112);
LABEL_25:
  *(_QWORD *)buf = a3;
  *(_QWORD *)&buf[8] = a4;
  if (!(_DWORD)v12)
  {
    LODWORD(v37) = 0;
    goto LABEL_50;
  }
  v37 = v11 % v12;
  v38 = *(unsigned int *)(*(_QWORD *)(v8 + 3096) + 4 * v37);
  if ((_DWORD)v38 == 0x7FFFFFFF)
    goto LABEL_50;
  v39 = *(_QWORD *)(v8 + 3104);
  v40 = v39 + 32 * v38;
  v42 = *(_QWORD *)(v40 + 16);
  v41 = *(_QWORD *)(v40 + 24);
  if (v42 == a3 && v41 == a4)
  {
LABEL_37:
    *(_OWORD *)(v39 + 32 * v38 + 16) = *(_OWORD *)buf;
  }
  else
  {
    while (1)
    {
      v38 = *(_DWORD *)(v39 + 32 * v38 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v38 == 0x7FFFFFFF)
        break;
      v44 = v39 + 32 * v38;
      v46 = *(_QWORD *)(v44 + 16);
      v45 = *(_QWORD *)(v44 + 24);
      if (v46 == a3 && v45 == a4)
        goto LABEL_37;
    }
LABEL_50:
    re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::addAsMove(v8 + 3088, v37, v11, (__n128 *)buf);
  }
  ++*(_DWORD *)(v8 + 3128);
}

void re::Session::sendRouteResponse(re::Session *this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  unint64_t *Route;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  NSObject *v16;
  uint32_t v17;
  id v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  _BYTE v24[8];
  uint64_t v25;
  unint64_t v26;
  _BYTE buf[22];
  __int16 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  Route = re::RoutingTable::getRoute(this, a3, (uint64_t)v24);
  if (!v24[0])
  {
    v15 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 134218496;
    *(_QWORD *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = a3;
    v28 = 1024;
    LODWORD(v29) = a4;
    v14 = "Failed to send routing response. src=%llu, dst-%llu, hop=%d";
    v16 = v15;
    v17 = 28;
    goto LABEL_14;
  }
  v8 = *(_QWORD *)(v25 + 600);
  if (!v8)
  {
    v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "sendRouteResponse: missing session for transport!";
    goto LABEL_13;
  }
  v9 = *(_QWORD *)(v8 + 2296);
  if (!v9)
  {
LABEL_7:
    v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "sendRouteResponse: missing participant for connection!";
LABEL_13:
    v16 = v13;
    v17 = 2;
LABEL_14:
    _os_log_error_impl(&dword_21C69B000, v16, OS_LOG_TYPE_ERROR, v14, buf, v17);
    return;
  }
  v10 = *(uint64_t **)(v8 + 2312);
  v11 = 8 * v9;
  while (1)
  {
    v12 = *v10;
    if (*(_QWORD *)(*v10 + 32) == v26)
      break;
    ++v10;
    v11 -= 8;
    if (!v11)
      goto LABEL_7;
  }
  v18 = (id)(v12 + 8);
  v19 = re::PacketPool::allocate(*(re::PacketPool **)(v25 + 384), 67);
  re::Packet::offsetBy((uint64_t)v19, 3);
  v20 = *((_QWORD *)v19 + 1);
  *(_BYTE *)(v20 + 2) = 0;
  *(_WORD *)v20 = 0;
  v21 = *((_QWORD *)v19 + 2);
  v22 = *((_DWORD *)v19 + 7);
  *(_QWORD *)buf = &off_24E072668;
  *(_QWORD *)&buf[8] = v21;
  *(_DWORD *)&buf[16] = v22;
  buf[20] = 0;
  v29 = 0;
  v30 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a2, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a2), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a3, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a3), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, 5u, 8u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a4, 0x20u);
  v23 = v29;
  if (HIDWORD(v29))
    v23 = v29 + 1;
  *((_DWORD *)v19 + 6) = v23;
  re::Transport::send(v25, v26, (unint64_t)v19, 0, 0, 0, *(_DWORD *)(v12 + 72));

}

unint64_t re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::remove(uint64_t a1, _QWORD *a2)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v20;
  int v21;
  char v22;

  result = re::Hash<re::Pair<unsigned long long,unsigned long long,true>>::operator()((uint64_t)&v22, a2);
  v5 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v5)
  {
    v6 = result % v5;
    v7 = *(_QWORD *)(a1 + 8);
    v8 = *(unsigned int *)(v7 + 4 * (result % v5));
    if ((_DWORD)v8 != 0x7FFFFFFF)
    {
      v9 = *(_QWORD *)(a1 + 16);
      v10 = a2[1];
      v11 = v9 + 32 * v8;
      if (*(_QWORD *)(v11 + 16) == *a2 && *(_QWORD *)(v11 + 24) == v10)
      {
        *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
LABEL_15:
        v16 = *(_QWORD *)(a1 + 16);
        v17 = v16 + 32 * v8;
        v20 = *(_DWORD *)(v17 + 8);
        v19 = (int *)(v17 + 8);
        v18 = v20;
        if (v20 < 0)
        {
          *v19 = v18 & 0x7FFFFFFF;
          v16 = *(_QWORD *)(a1 + 16);
          v18 = *(_DWORD *)(v16 + 32 * v8 + 8);
        }
        v21 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v16 + 32 * v8 + 8) = *(_DWORD *)(a1 + 36) | v18 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v8;
        *(_DWORD *)(a1 + 40) = v21 + 1;
      }
      else
      {
        while (1)
        {
          v13 = v8;
          v8 = *(_DWORD *)(v9 + 32 * v8 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v8 == 0x7FFFFFFF)
            break;
          v14 = v9 + 32 * v8;
          if (*(_QWORD *)(v14 + 16) == *a2 && *(_QWORD *)(v14 + 24) == v10)
          {
            *(_DWORD *)(v9 + 32 * v13 + 8) = *(_DWORD *)(v9 + 32 * v13 + 8) & 0x80000000 | *(_DWORD *)(v14 + 8) & 0x7FFFFFFF;
            goto LABEL_15;
          }
        }
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::Session::PendingMessage>::removeStableAt(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = result;
  v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    result = (_QWORD *)(result[4] + 40 * a2);
    v5 = 40 * v2 - (40 * a2 + 40);
    if (v5)
    {
      result = memmove(result, result + 5, v5 - 7);
      v4 = v3[2] - 1;
    }
  }
  v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void re::Session::sendRouteFail(re::Session *this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  unint64_t *Route;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  NSObject *v16;
  uint32_t v17;
  id v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  _BYTE v24[8];
  uint64_t v25;
  unint64_t v26;
  _BYTE buf[22];
  __int16 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  Route = re::RoutingTable::getRoute(this, a3, (uint64_t)v24);
  if (!v24[0])
  {
    v15 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 134218496;
    *(_QWORD *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = a3;
    v28 = 1024;
    LODWORD(v29) = a4;
    v14 = "Failed to notify peer about failed route. src=%llu, dst-%llu, hop=%d";
    v16 = v15;
    v17 = 28;
    goto LABEL_14;
  }
  v8 = *(_QWORD *)(v25 + 600);
  if (!v8)
  {
    v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "sendRouteFail: missing session for transport!";
    goto LABEL_13;
  }
  v9 = *(_QWORD *)(v8 + 2296);
  if (!v9)
  {
LABEL_7:
    v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    *(_WORD *)buf = 0;
    v14 = "sendRouteFail: missing participant for connection!";
LABEL_13:
    v16 = v13;
    v17 = 2;
LABEL_14:
    _os_log_error_impl(&dword_21C69B000, v16, OS_LOG_TYPE_ERROR, v14, buf, v17);
    return;
  }
  v10 = *(uint64_t **)(v8 + 2312);
  v11 = 8 * v9;
  while (1)
  {
    v12 = *v10;
    if (*(_QWORD *)(*v10 + 32) == v26)
      break;
    ++v10;
    v11 -= 8;
    if (!v11)
      goto LABEL_7;
  }
  v18 = (id)(v12 + 8);
  v19 = re::PacketPool::allocate(*(re::PacketPool **)(v25 + 384), 67);
  re::Packet::offsetBy((uint64_t)v19, 3);
  v20 = *((_QWORD *)v19 + 1);
  *(_BYTE *)(v20 + 2) = 0;
  *(_WORD *)v20 = 0;
  v21 = *((_QWORD *)v19 + 2);
  v22 = *((_DWORD *)v19 + 7);
  *(_QWORD *)buf = &off_24E072668;
  *(_QWORD *)&buf[8] = v21;
  *(_DWORD *)&buf[16] = v22;
  buf[20] = 0;
  v29 = 0;
  v30 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a2, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a2), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a3, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a3), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, 6u, 8u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a4, 0x20u);
  v23 = v29;
  if (HIDWORD(v29))
    v23 = v29 + 1;
  *((_DWORD *)v19 + 6) = v23;
  re::Transport::send(v25, v26, (unint64_t)v19, 0, 0, 0, *(_DWORD *)(v12 + 72));

}

void re::Event<re::Session,unsigned long long>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  _OWORD v23[5];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *(_QWORD *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v15 = 136315906;
          v16 = "operator[]";
          v17 = 1024;
          v18 = 789;
          v19 = 2048;
          v20 = i;
          v21 = 2048;
          v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *(_QWORD *)(a1 + 72) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, *((unint64_t *)&v23[0] + 1));
        }
        v7 += 40;
      }
    }
  }
}

BOOL re::Session::isLocalPeer(re::Session *this, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 result;
  NSObject *v4;
  uint8_t v5[16];

  v2 = *((_QWORD *)this + 380);
  if (v2)
    return *(_QWORD *)(v2 + 24) == a2;
  v4 = *re::networkLogObjects(this);
  result = os_log_type_enabled(v4, OS_LOG_TYPE_INFO);
  if ((_DWORD)result)
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_INFO, "Routing table is nil", v5, 2u);
    return 0;
  }
  return result;
}

uint64_t re::Session::hasPeerID(re::Session *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  void *v7;
  id v8;

  v2 = *((_QWORD *)this + 287);
  if (!v2)
    return 0;
  v3 = (uint64_t *)*((_QWORD *)this + 289);
  v4 = 8 * v2;
  while (1)
  {
    v5 = *v3;
    if (*(_QWORD *)(*v3 + 24) == a2)
      break;
    ++v3;
    v4 -= 8;
    if (!v4)
      return 0;
  }
  v7 = (void *)(v5 + 8);
  v8 = (id)(v5 + 8);

  return 1;
}

uint64_t re::DynamicArray<re::Session::SendHandshakeInProgressEntry>::removeAt(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _OWORD *v6;
  __int128 v7;

  v2 = *(_QWORD *)(result + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = v2 - 1;
  if (v2 - 1 > a2)
  {
    v4 = *(_QWORD *)(result + 32);
    v5 = v4 + 32 * v2;
    v6 = (_OWORD *)(v4 + 32 * a2);
    v7 = *(_OWORD *)(v5 - 16);
    *v6 = *(_OWORD *)(v5 - 32);
    v6[1] = v7;
    v3 = *(_QWORD *)(result + 16) - 1;
  }
  *(_QWORD *)(result + 16) = v3;
  ++*(_DWORD *)(result + 24);
  return result;
}

uint64_t re::Session::removePendingPeerHelloForConnection(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;

  v2 = *(_QWORD *)(this + 3200);
  if (v2)
  {
    v3 = 0;
    v4 = (uint64_t *)(*(_QWORD *)(this + 3216) + 16);
    while (1)
    {
      v5 = *v4;
      v4 += 4;
      if (v5 == a2)
        break;
      if (v2 == ++v3)
        return this;
    }
    return re::DynamicArray<re::Session::SendHandshakeInProgressEntry>::removeAt(this + 3184, v3);
  }
  return this;
}

_anonymous_namespace_ *re::Session::onConnected(re::Session *this, uint64_t a2)
{
  _anonymous_namespace_ *result;
  _anonymous_namespace_ *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  _anonymous_namespace_ **v13;
  _QWORD v14[2];
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1792, (uint64_t)this);
  if (!re::Session::findBacklogItemWithConnectionHandle(this, a2, 0))
  {
    v21 = 0;
    v14[1] = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v19 = 0u;
    v20 = 0;
    re::DynamicArray<unsigned char>::setCapacity(&v18, 0);
    ++v20;
    v14[0] = a2;
    v17 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 282) + 32))(*((_QWORD *)this + 282));
    re::DynamicArray<re::Session::BacklogItem>::add((uint64_t)this + 3144, (uint64_t)v14);
    if (v18)
    {
      if (v21)
        (*(void (**)(void))(*v18 + 40))();
      v21 = 0;
      v19 = 0uLL;
      v18 = 0;
      ++v20;
    }
    if (v15)

  }
  result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 282) + 32))(*((_QWORD *)this + 282));
  v5 = result;
  v6 = *((_QWORD *)this + 400);
  v7 = *((_QWORD *)this + 399);
  if (v6 >= v7)
  {
    v8 = v6 + 1;
    if (v7 < v6 + 1)
    {
      if (*((_QWORD *)this + 398))
      {
        v9 = 2 * v7;
        v10 = v7 == 0;
        v11 = 8;
        if (!v10)
          v11 = v9;
        if (v11 <= v8)
          v12 = v8;
        else
          v12 = v11;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)this + 398, v12);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)this + 398, v8);
        ++*((_DWORD *)this + 802);
      }
    }
    v6 = *((_QWORD *)this + 400);
  }
  v13 = (_anonymous_namespace_ **)(*((_QWORD *)this + 402) + 32 * v6);
  *v13 = v5;
  v13[1] = 0;
  v13[2] = (_anonymous_namespace_ *)a2;
  v13[3] = 0;
  ++*((_QWORD *)this + 400);
  ++*((_DWORD *)this + 802);
  return result;
}

uint64_t re::Session::findBacklogItemWithConnectionHandle(re::Session *this, uint64_t a2, unint64_t *a3)
{
  uint64_t v6;
  uint64_t BacklogItem;
  _QWORD v9[3];
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v6 = re::globalAllocators(this)[2];
  v9[0] = &off_24E071D10;
  v9[1] = a2;
  v10 = v6;
  v11 = v9;
  BacklogItem = re::Session::findBacklogItem((uint64_t)this, (uint64_t)v9, a3);
  if (v11)
  {
    (*(void (**)(_QWORD *))*v11)(v11);
    if (v11 != v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  }
  return BacklogItem;
}

uint64_t re::DynamicArray<re::Session::BacklogItem>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v6)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::Session::BacklogItem>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Session::BacklogItem>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = *(_QWORD *)(a1 + 32);
  v12 = v11 + 80 * v5;
  *(_OWORD *)v12 = *(_OWORD *)a2;
  v13 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(v12 + 16) = v13;
  if (v13)
    v14 = (id)(v13 + 8);
  v15 = v11 + 80 * v5;
  *(_OWORD *)(v15 + 24) = *(_OWORD *)(a2 + 24);
  result = re::DynamicArray<unsigned char>::DynamicArray(v15 + 40, (uint64_t *)(a2 + 40));
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

_anonymous_namespace_ *`non-virtual thunk to're::Session::onConnected(re::Session *this, uint64_t a2)
{
  return re::Session::onConnected((re::Session *)((char *)this - 24), a2);
}

void re::Session::onDisconnected(uint64_t **this, uint64_t a2)
{
  uint64_t BacklogItemWithConnectionHandle;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  id v10;
  uint64_t *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;

  re::Event<re::Session,unsigned long long>::raise((uint64_t)(this + 235), (uint64_t)this);
  v15 = 0;
  v16 = 0;
  BacklogItemWithConnectionHandle = re::Session::findBacklogItemWithConnectionHandle((re::Session *)this, a2, &v15);
  if (BacklogItemWithConnectionHandle)
  {
    re::SharedPtr<re::SyncObject>::reset(&v16, *(_QWORD *)(BacklogItemWithConnectionHandle + 16));
    re::DynamicArray<re::Session::BacklogItem>::removeAt((uint64_t)(this + 393), v15);
  }
  v5 = this[287];
  if (v5)
  {
    v6 = this[289];
    v7 = 8 * (_QWORD)v5;
    while (1)
    {
      v8 = *v6;
      if (*(_QWORD *)(*v6 + 32) == a2)
        break;
      ++v6;
      v7 -= 8;
      if (!v7)
        goto LABEL_9;
    }
    v9 = (id)(v8 + 8);
    re::SharedPtr<re::SyncObject>::reset(&v16, *(_QWORD *)(v8 + 152));
    v14 = v8;
    v10 = (id)(v8 + 8);
    re::Session::removeParticipant((uint64_t)this, &v14);

  }
LABEL_9:
  v11 = this[276];
  if (v11)
  {
    if (v16)
    {
      v13 = v16;
      v12 = (id)(v16 + 8);
      (*(void (**)(uint64_t *, uint64_t *))(*v11 + 80))(v11, &v13);
      if (v13)
      {

        v13 = 0;
      }
    }
  }
  re::Session::removePendingPeerHelloForConnection((uint64_t)this, a2);
  if (v16)

}

void re::DynamicArray<re::Session::BacklogItem>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = v4 + 80 * v2;
    v6 = v4 + 80 * a2;
    *(_OWORD *)v6 = *(_OWORD *)(v5 - 80);
    v7 = *(_QWORD *)(v6 + 16);
    *(_QWORD *)(v6 + 16) = *(_QWORD *)(v5 - 64);
    *(_QWORD *)(v5 - 64) = v7;
    *(_OWORD *)(v6 + 24) = *(_OWORD *)(v5 - 56);
    re::DynamicArray<unsigned char>::operator=(v6 + 40, v5 - 40);
    v2 = *(_QWORD *)(a1 + 16);
  }
  v8 = *(_QWORD *)(a1 + 32) + 80 * v2;
  v9 = *(_QWORD *)(v8 - 40);
  if (v9)
  {
    if (*(_QWORD *)(v8 - 8))
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
    *(_QWORD *)(v8 - 8) = 0;
    *(_QWORD *)(v8 - 32) = 0;
    *(_QWORD *)(v8 - 24) = 0;
    *(_QWORD *)(v8 - 40) = 0;
    ++*(_DWORD *)(v8 - 16);
  }
  v10 = *(_QWORD *)(v8 - 64);
  if (v10)
  {

    *(_QWORD *)(v8 - 64) = 0;
  }
  --*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::Session::removeParticipant(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  v4 = *(_QWORD *)(*a2 + 24);
  v5 = a1 + 384;
  v17 = *a2;
  v6 = (id)(*a2 + 8);
  re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::raise(v5, a1);
  if (v17)

  re::RoutingTable::removeRoutesForConnection(*(re::RoutingTable **)(a1 + 3040), (re::Transport *)(a1 + 2320), *(_QWORD *)(*a2 + 32));
  v7 = *(_QWORD *)(a1 + 2312);
  v8 = *(_QWORD *)(a1 + 2296);
  if (v8)
  {
    v9 = 8 * v8;
    v10 = *(_QWORD **)(a1 + 2312);
    while (*v10 != *a2)
    {
      ++v10;
      v9 -= 8;
      if (!v9)
      {
        v10 = (_QWORD *)(v7 + 8 * v8);
        break;
      }
    }
  }
  else
  {
    v10 = *(_QWORD **)(a1 + 2312);
  }
  v11 = ((uint64_t)v10 - v7) >> 3;
  if (v11 != v8)
    re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(a1 + 2280, v11);
  v12 = *(_QWORD *)(a1 + 3064);
  if (v12)
  {
    v13 = v12 - 1;
    v14 = 40 * v12;
    do
    {
      if (*(_QWORD *)(a1 + 3064) <= v13)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v15 = *(_QWORD *)(a1 + 3080) + v14;
      if (*(_QWORD *)(v15 - 32) == v4)
      {
        re::PacketPool::free(*(re::PacketPool **)(a1 + 2704), *(re::Packet **)(v15 - 40));
        re::DynamicArray<re::Session::PendingMessage>::removeStableAt((_QWORD *)(a1 + 3048), v13);
      }
      --v13;
      v14 -= 40;
    }
    while (v13 != -1);
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  re::Session::stateEvent(a1, 5);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 7424) + 96))(*(_QWORD *)(a1 + 7424), v4);
}

void `non-virtual thunk to're::Session::onDisconnected(uint64_t **this, uint64_t a2)
{
  re::Session::onDisconnected(this - 3, a2);
}

uint64_t re::Session::onError(uint64_t this, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t v8;

  if ((a3 & 0xFFFFFFFB) == 0)
  {
    v4 = this;
    v5 = *(_QWORD *)(this + 3160);
    if (v5)
    {
      v6 = 0;
      v7 = *(uint64_t **)(this + 3176);
      while (1)
      {
        v8 = *v7;
        v7 += 10;
        if (v8 == a2)
          break;
        if (v5 == ++v6)
          return re::Session::removePendingPeerHelloForConnection(v4, a2);
      }
      re::DynamicArray<re::Session::BacklogItem>::removeAt(this + 3144, v6);
    }
    return re::Session::removePendingPeerHelloForConnection(v4, a2);
  }
  return this;
}

uint64_t `non-virtual thunk to're::Session::onError(uint64_t a1, uint64_t a2, int a3)
{
  return re::Session::onError(a1 - 24, a2, a3);
}

_anonymous_namespace_ *re::Session::onReceive(_anonymous_namespace_ *result, uint64_t a2, int a3)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if (a3 != 1)
  {
    v4 = result;
    v5 = *((_QWORD *)result + 407);
    v6 = *((_QWORD *)result + 405);
    if (v6)
    {
      v7 = 8 * v6;
      v8 = (_QWORD *)*((_QWORD *)result + 407);
      while (*v8 != a2)
      {
        ++v8;
        v7 -= 8;
        if (!v7)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      v9 = *((_QWORD *)result + 404);
      if (v6 >= v9)
      {
        v10 = v6 + 1;
        if (v9 < v6 + 1)
        {
          if (*((_QWORD *)result + 403))
          {
            v11 = 2 * v9;
            if (!v9)
              v11 = 8;
            if (v11 <= v10)
              v12 = v10;
            else
              v12 = v11;
            result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)result + 403, v12);
          }
          else
          {
            result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)v4 + 403, v10);
            ++*((_DWORD *)v4 + 812);
          }
        }
        v6 = *((_QWORD *)v4 + 405);
        v5 = *((_QWORD *)v4 + 407);
      }
      *(_QWORD *)(v5 + 8 * v6) = a2;
      *((_QWORD *)v4 + 405) = v6 + 1;
      ++*((_DWORD *)v4 + 812);
    }
  }
  return result;
}

_anonymous_namespace_ *`non-virtual thunk to're::Session::onReceive(uint64_t a1, uint64_t a2, int a3)
{
  return re::Session::onReceive((_anonymous_namespace_ *)(a1 - 24), a2, a3);
}

void re::Session::onDataArrived(re::Session *this)
{
  re::Event<re::Session>::raise((uint64_t)this + 1616, (uint64_t)this);
}

void `non-virtual thunk to're::Session::onDataArrived(re::Session *this)
{
  re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24);
}

void re::Session::onConnectionPaused(re::Session *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  id v7;

  v2 = *((_QWORD *)this + 287);
  if (v2)
  {
    v4 = (uint64_t *)*((_QWORD *)this + 289);
    v5 = 8 * v2;
    while (1)
    {
      v6 = *v4;
      if (*(_QWORD *)(*v4 + 32) == a2)
        break;
      ++v4;
      v5 -= 8;
      if (!v5)
        return;
    }
    v7 = (id)(v6 + 8);
    re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1968, (uint64_t)this);

  }
}

void `non-virtual thunk to're::Session::onConnectionPaused(re::Session *this, uint64_t a2)
{
  re::Session::onConnectionPaused((re::Session *)((char *)this - 24), a2);
}

void re::Session::onConnectionResumed(re::Session *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  id v7;

  v2 = *((_QWORD *)this + 287);
  if (v2)
  {
    v4 = (uint64_t *)*((_QWORD *)this + 289);
    v5 = 8 * v2;
    while (1)
    {
      v6 = *v4;
      if (*(_QWORD *)(*v4 + 32) == a2)
        break;
      ++v4;
      v5 -= 8;
      if (!v5)
        return;
    }
    v7 = (id)(v6 + 8);
    re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 2056, (uint64_t)this);

  }
}

void `non-virtual thunk to're::Session::onConnectionResumed(re::Session *this, uint64_t a2)
{
  re::Session::onConnectionResumed((re::Session *)((char *)this - 24), a2);
}

uint64_t re::Session::findBacklogItem(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *(_QWORD *)(a1 + 3160);
  if (!v3)
    return 0;
  v7 = *(_QWORD *)(a1 + 3176);
  v8 = -v7;
  v9 = 80 * v3;
  while (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), v7))
  {
    v7 += 80;
    v8 -= 80;
    v9 -= 80;
    if (!v9)
      return 0;
  }
  if (a3)
    *a3 = 0xCCCCCCCCCCCCCCCDLL * ((-v8 - *(_QWORD *)(a1 + 3176)) >> 4);
  return v7;
}

void re::Session::findParticipantWithIdentity(_QWORD *a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  id v6;
  uint64_t v7;

  v5 = *a2;
  v7 = v5;
  if (v5)
    v6 = (id)(v5 + 8);
  re::Session::findParticipant<re::Session::findParticipantWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&)::{lambda(re::SessionParticipant const*)#1}>(a1, &v7, a3);
  if (v7)

}

void re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  _OWORD v23[5];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *(_QWORD *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v15 = 136315906;
          v16 = "operator[]";
          v17 = 1024;
          v18 = 789;
          v19 = 2048;
          v20 = i;
          v21 = 2048;
          v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *(_QWORD *)(a1 + 72) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, *((unint64_t *)&v23[0] + 1));
        }
        v7 += 40;
      }
    }
  }
}

void re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = v5 + 8 * v2;
    v7 = *(_QWORD *)(v5 + 8 * a2);
    *(_QWORD *)(v5 + 8 * a2) = *(_QWORD *)(v6 - 8);
    *(_QWORD *)(v6 - 8) = v7;
  }
  v8 = *(_QWORD *)(a1 + 32) + 8 * v2;
  v9 = *(_QWORD *)(v8 - 8);
  if (v9)
  {

    *(_QWORD *)(v8 - 8) = 0;
    v4 = *(_QWORD *)(a1 + 16) - 1;
  }
  *(_QWORD *)(a1 + 16) = v4;
  ++*(_DWORD *)(a1 + 24);
}

void re::Session::onLeaderChange(re::Session *this, uint64_t a2)
{
  NSObject *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 134218240;
    v6 = a2;
    v7 = 2048;
    v8 = re::Session::peerID(this);
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Picked session leader %llu (localPeerID=%llu)", (uint8_t *)&v5, 0x16u);
  }
  re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1704, (uint64_t)this);
}

void re::DynamicArray<unsigned char>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<unsigned char>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2 && (uint64_t)(a2 - v4) >= 1)
      bzero((void *)(*(_QWORD *)(a1 + 32) + v4), a2 - v4);
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  __int128 *v6;
  __int128 v7;
  _BYTE v8[8];
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 16))
  {
    v4 = 0;
    v5 = a1 + 40;
    do
    {
      v6 = (__int128 *)(*(_QWORD *)(a1 + 32) + 32 * v4);
      if (*(_QWORD *)v6 == a2)
      {
        if (!*(_DWORD *)(a1 + 80))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v4);
          continue;
        }
        v8[0] = 0;
        v7 = v6[1];
        v9 = *v6;
        v10 = v7;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v5, (uint64_t)v8);
      }
      ++v4;
    }
    while (v4 < *(_QWORD *)(a1 + 16));
  }
}

float re::Session::averagedStatsAggregated@<S0>(re::Session *this@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  char *v6;
  char *v7;
  int32x4_t v8;
  uint64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float v12;
  float v13;
  float *v14;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v3 = *((_QWORD *)this + 926);
  v4 = *((_QWORD *)this + 925);
  v5 = v3 - v4;
  if ((unint64_t)(v3 - v4) >= 2)
  {
    v6 = (char *)this + 32 * ((v3 - 1) & 0x7F) + 3304;
    v7 = (char *)this + 32 * (*((_QWORD *)this + 925) & 0x7FLL) + 3304;
    a3 = (float)((float)((*((_QWORD *)v6 + 3) - *((_QWORD *)v7 + 3)) / 1000000) / 1000.0);
    if (a3 > 0.0001)
    {
      v8 = vsubq_s32(*(int32x4_t *)(v6 + 8), *(int32x4_t *)(v7 + 8));
      v9.i64[0] = v8.u32[0];
      v9.i64[1] = v8.u32[1];
      v10 = vcvtq_f64_u64(v9);
      v9.i64[0] = v8.u32[2];
      v9.i64[1] = v8.u32[3];
      v11 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a3, 0);
      *(float32x4_t *)(a2 + 8) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v10, v11)), vdivq_f64(vcvtq_f64_u64(v9), v11));
      v12 = 0.0;
      if (v3 != v4)
      {
        v13 = 0.0;
        do
        {
          v14 = (float *)((char *)this + 32 * (v4 & 0x7F) + 3304);
          v13 = v13 + v14[1];
          v12 = v12 + (float)*(unsigned int *)v14;
          ++v4;
        }
        while (v3 != v4);
        *(float *)(a2 + 4) = v13;
      }
      *(float *)&a3 = v12 / (float)v5;
      *(_DWORD *)a2 = LODWORD(a3);
    }
  }
  return *(float *)&a3;
}

void re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

BOOL re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  return *a2 == *(_QWORD *)(a1 + 8);
}

_QWORD *re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071D10;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071D10;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::size()
{
  return 16;
}

_QWORD *re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071D78;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071D78;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id v7;
  _BYTE v8[24];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
    *(_DWORD *)v8 = 136315138;
    *(_QWORD *)&v8[4] = v4;
    _os_log_impl(&dword_21C69B000, v3, OS_LOG_TYPE_DEFAULT, "Discovered new peer: %s", v8, 0xCu);
  }
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)v8 = v5;
  if (v5)
  {
    v6 = (void *)(v5 + 8);
    v7 = (id)(v5 + 8);
    re::Session::addIdentity(v2, (uint64_t *)v8);

  }
  else
  {
    re::Session::addIdentity(v2, (uint64_t *)v8);
  }
}

_QWORD *re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E071D78;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E071D78;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071DD0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071DD0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::operator()(re *a1)
{
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  id v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  re *v14;
  NSObject *v15;
  _BYTE *v16;
  uint64_t v17;
  _BYTE *v18;
  re *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  void *v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  _BYTE v30[23];
  uint64_t v31;
  char v32;
  _BYTE v33[7];
  _BYTE *v34;
  _BYTE buf[22];
  __int16 v36;
  uint64_t v37;
  _BYTE *v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)*((_QWORD *)a1 + 1);
  v3 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a1 + 2) + 32))(*((_QWORD *)a1 + 2));
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v4;
    _os_log_impl(&dword_21C69B000, v3, OS_LOG_TYPE_DEFAULT, "Lost peer: %s", buf, 0xCu);
  }
  v5 = *((_QWORD *)a1 + 2);
  v27 = v5;
  if (v5)
  {
    v6 = (id)(v5 + 8);
    v37 = re::globalAllocators((re *)(id)(v5 + 8))[2];
    *(_QWORD *)buf = &off_24E071E28;
    *(_QWORD *)&buf[8] = v5;
    v7 = (id)(v5 + 8);
    v38 = buf;
    v8 = v2[395];
    if (v8)
    {
      v9 = (unint64_t *)v2[397];
      v10 = -(uint64_t)v9;
      v11 = 80 * v8;
      while (!(*(unsigned int (**)(_BYTE *, unint64_t *))(*(_QWORD *)v38 + 16))(v38, v9))
      {
        v9 += 10;
        v10 -= 80;
        v11 -= 80;
        if (!v11)
          goto LABEL_8;
      }
      v12 = 0xCCCCCCCCCCCCCCCDLL * ((-v10 - v2[397]) >> 4);
    }
    else
    {
LABEL_8:
      v12 = 0;
      v9 = 0;
    }
    if (v38)
    {
      (**(void (***)(_BYTE *))v38)(v38);
      if (v38 != buf)
        (*(void (**)(uint64_t))(*(_QWORD *)v37 + 40))(v37);
      v38 = 0;
    }

    if (v9)
    {
      v13 = *v9;
      re::DynamicArray<re::Session::BacklogItem>::removeAt((uint64_t)(v2 + 393), v12);
      if (v13)
      {
        v15 = *re::networkLogObjects(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          re::Transport::connectionAddress((re::Transport *)(v2 + 290), v13, (re::DynamicString *)&v31);
          if ((v32 & 1) != 0)
            v16 = v34;
          else
            v16 = v33;
          v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
          (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v5 + 40))(&v28, v5);
          if ((v29 & 1) != 0)
            v18 = *(_BYTE **)&v30[7];
          else
            v18 = v30;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v16;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v17;
          v36 = 2080;
          v37 = (uint64_t)v18;
          _os_log_impl(&dword_21C69B000, v15, OS_LOG_TYPE_DEFAULT, "Dropping pending connection %s. because its identity '%s (%s)' left.", buf, 0x20u);
          if (v28 && (v29 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v28 + 40))();
          if (v31 && (v32 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v31 + 40))();
        }
        re::Transport::disconnect((re::Transport *)(v2 + 290), v13, 1);
        re::Session::removePendingPeerHelloForConnection((uint64_t)v2, v13);
      }
    }
    re::Session::findParticipantWithIdentity(v2, &v27, &v28);
    if (v28)
    {
      v20 = *re::networkLogObjects(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v21 = (*(_BYTE *)(v28 + 48) & 1) != 0 ? *(_QWORD *)(v28 + 56) : v28 + 49;
        v22 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v27 + 32))(v27);
        (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v27 + 40))(&v31);
        v23 = (v32 & 1) != 0 ? v34 : v33;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = v21;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v22;
        v36 = 2080;
        v37 = (uint64_t)v23;
        _os_log_impl(&dword_21C69B000, v20, OS_LOG_TYPE_DEFAULT, "Deleting participant '%s' for identity '%s (%s)'.", buf, 0x20u);
        if (v31)
        {
          if ((v32 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v31 + 40))();
        }
      }
      v24 = *(_QWORD *)(v28 + 32);
      *(_QWORD *)buf = v28;
      v25 = (void *)(v28 + 8);
      v26 = (id)(v28 + 8);
      re::Session::removeParticipant((uint64_t)v2, (uint64_t *)buf);

      re::Transport::disconnect((re::Transport *)(v2 + 290), v24, 1);
      re::Session::removePendingPeerHelloForConnection((uint64_t)v2, v24);
      if (v28)

    }
    if (v27)

  }
}

_QWORD *re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E071DD0;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E071DD0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071E28;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E071E28;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x220780CD0);
}

BOOL re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16) == *(_QWORD *)(a1 + 8);
}

_QWORD *re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  id v4;

  v3 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071E28;
  a2[1] = v3;
  if (v3)
    v4 = (id)(v3 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  id v4;

  v3 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E071E28;
  a2[1] = v3;
  if (v3)
    v4 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::size()
{
  return 16;
}

_QWORD *re::Session::findParticipant<re::Session::findParticipantWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&)::{lambda(re::SessionParticipant const*)#1}>@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = result[287];
  if (v3)
  {
    v4 = (uint64_t *)result[289];
    v5 = 8 * v3;
    while (1)
    {
      v6 = *v4;
      if (*(_QWORD *)(*v4 + 152) == *a2)
        break;
      ++v4;
      v5 -= 8;
      if (!v5)
        goto LABEL_5;
    }
    *a3 = v6;
    return (id)(v6 + 8);
  }
  else
  {
LABEL_5:
    *a3 = 0;
  }
  return result;
}

_QWORD *re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_15;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        v12 = (_QWORD *)v5[4];
        do
        {
          *v11++ = *v12;
          *v12++ = 0;
          v10 -= 8;
        }
        while (v10);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

double re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(_anonymous_namespace_ *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (*((_DWORD *)a1 + 20))
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)a1 + 40, (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __n128 result;
  __int128 v13;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = *(_QWORD *)(a1 + 32) + 40 * v5;
  result = *(__n128 *)a2;
  v13 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(v11 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)v11 = result;
  *(_OWORD *)(v11 + 16) = v13;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::createSubscription<re::Session>(re::Session *,REEventHandlerResult (re::Session::*)(re::DiscoveryView*,re::SharedPtr<re::DiscoveryIdentity>))::{lambda(re::DiscoveryView*,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription const&,re::SharedPtr<re::DiscoveryIdentity>&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t *);
  _QWORD *v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  uint64_t v11;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *))a2[1];
  v4 = a2[2];
  v6 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *))(*v6 + v5);
  v7 = *a3;
  v11 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v9 = v5(v6, a1, &v11);
  if (v11)

  return v9;
}

uint64_t re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf(uint64_t result, uint64_t a2, char *a3, _QWORD *a4)
{
  char *v4;
  uint64_t v5;
  uint64_t v7;
  char v8;

  v4 = a3;
  if (a2)
  {
    v5 = 32 * a2;
    v4 = a3;
    while (*(_QWORD *)v4 != *a4 || *((_QWORD *)v4 + 1) != a4[1] || *((_QWORD *)v4 + 2) != a4[2])
    {
      v4 += 32;
      v5 -= 32;
      if (!v5)
      {
        v4 = &a3[32 * a2];
        break;
      }
    }
  }
  v7 = (v4 - a3) >> 5;
  if (v7 == a2)
  {
    v8 = 0;
  }
  else
  {
    *(_QWORD *)(result + 8) = v7;
    v8 = 1;
  }
  *(_BYTE *)result = v8;
  return result;
}

__n128 re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, __n128 *a4)
{
  uint64_t v7;
  int v8;
  int v9;
  signed int v10;
  uint64_t v11;
  BOOL v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  signed int v22;
  __n128 result;
  _BYTE v24[44];

  v7 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
    v7 = *(unsigned int *)(a1 + 32);
    v8 = v7;
    if ((_DWORD)v7 == *(_DWORD *)(a1 + 24))
    {
      v9 = *(_DWORD *)(a1 + 28);
      v10 = 2 * v9;
      v11 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v10)
          v12 = (_DWORD)v7 == v10;
        else
          v12 = 1;
        if (!v12 && (v9 & 0x80000000) == 0)
        {
          memset(v24, 0, 36);
          *(_QWORD *)&v24[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::init((uint64_t)v24, v11, v10);
          v13 = *(_OWORD *)v24;
          *(_OWORD *)v24 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v13;
          v14 = *(_QWORD *)&v24[16];
          v15 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v24[16] = v15;
          *(_QWORD *)(a1 + 16) = v14;
          v17 = *(_OWORD *)&v24[24];
          *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
          v16 = *(_DWORD *)&v24[32];
          *(_OWORD *)(a1 + 24) = v17;
          v18 = v16;
          if (v16)
          {
            v19 = v15 + 16;
            do
            {
              if ((*(_DWORD *)(v19 - 8) & 0x80000000) != 0)
                re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::addAsMove(a1, *(_QWORD *)(v19 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v19 - 16), v19);
              v19 += 32;
              --v18;
            }
            while (v18);
          }
          re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v24);
        }
      }
      else
      {
        if (v10)
          v22 = v10;
        else
          v22 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    v20 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
  }
  else
  {
    v20 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v20 + 32 * v7 + 8) = v21 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7) = a3;
  result = *a4;
  *(__n128 *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 16) = *a4;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

_QWORD *re::DynamicArray<re::Session::BacklogItem>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::Session::BacklogItem>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          v2 = 80 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_22;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_22:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 80 * v9;
        v11 = (_QWORD *)(v8 + 40);
        v12 = v7;
        do
        {
          *(_OWORD *)v12 = *(_OWORD *)(v11 - 5);
          v12[2] = *(v11 - 3);
          *(v11 - 3) = 0;
          *(_OWORD *)(v12 + 3) = *((_OWORD *)v11 - 1);
          v12[9] = 0;
          v12[6] = 0;
          v12[7] = 0;
          v12[5] = 0;
          *((_DWORD *)v12 + 16) = 0;
          v13 = v11[1];
          v12[5] = *v11;
          v12[6] = v13;
          *v11 = 0;
          v11[1] = 0;
          v14 = v12[7];
          v12[7] = v11[2];
          v11[2] = v14;
          v15 = v12[9];
          v12[9] = v11[4];
          v11[4] = v15;
          ++*((_DWORD *)v11 + 6);
          ++*((_DWORD *)v12 + 16);
          if (*v11)
          {
            if (v15)
              (*(void (**)(_QWORD))(*(_QWORD *)*v11 + 40))(*v11);
            v11[4] = 0;
            v11[1] = 0;
            v11[2] = 0;
            *v11 = 0;
            ++*((_DWORD *)v11 + 6);
          }
          v16 = *(v11 - 3);
          if (v16)
          {

            *(v11 - 3) = 0;
          }
          v11 += 10;
          v12 += 10;
          v10 -= 80;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_22;
    }
  }
  return result;
}

void re::StaticPacketBitWriter::~StaticPacketBitWriter(re::StaticPacketBitWriter *this)
{
  if (*((_QWORD *)this + 6))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 5) + 40))(*((_QWORD *)this + 5));
    *((_QWORD *)this + 6) = 0;
  }
}

{
  if (*((_QWORD *)this + 6))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 5) + 40))(*((_QWORD *)this + 5));
    *((_QWORD *)this + 6) = 0;
  }
  JUMPOUT(0x220780CD0);
}

uint64_t re::StaticPacketBitWriter::grow(uint64_t this)
{
  uint64_t v1;

  if (!*(_QWORD *)(this + 48))
  {
    v1 = this;
    this = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(this + 40) + 32))(*(_QWORD *)(this + 40), *(unsigned int *)(this + 56));
    *(_QWORD *)(v1 + 48) = this;
    *(_QWORD *)(v1 + 8) = *(_QWORD *)(this + 16);
    *(_DWORD *)(v1 + 16) = *(_DWORD *)(v1 + 56);
  }
  return this;
}

void re::SyncSnapshotDump::log(NSObject *a1, char *a2, uint64_t *a3, uint64_t a4, const char *a5)
{
  uint64_t v5;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  int v19;
  const char *v20;
  char v21;
  const char *v22;
  const char *v23;
  char v24;
  int v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  const char *v30;
  const char *v31;
  const char *v32;
  const char *v33;
  NSObject *v34;
  uint32_t v35;
  uint64_t v36;
  int v37;
  char v38;
  const char *v39;
  const char *v40;
  char v41;
  const char *v42;
  int v43;
  const char *v44;
  const char *v45;
  const char *v46;
  const char *v47;
  const char *v48;
  const char *v49;
  int v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  int v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  uint64_t v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v5 = *a3;
  if (*a3)
  {
    v10 = (id)(v5 + 8);
    v11 = *(_QWORD *)(v5 + 80);
    v12 = *(_QWORD *)(*(_QWORD *)(v5 + 88) + 16);
    v13 = *(_QWORD *)(v12 + 48);
    v14 = *(_QWORD *)(v12 + 56);
    v15 = v12 + 49;
    if ((v13 & 1) != 0)
      v16 = v14;
    else
      v16 = v15;
    v17 = os_log_type_enabled(a1, OS_LOG_TYPE_DEBUG);
    if (v11)
    {
      if (v17)
      {
        v18 = *(_QWORD *)(v5 + 24);
        v19 = *(unsigned __int16 *)(v5 + 176);
        v20 = *(const char **)(v11 + 24);
        v21 = *((_BYTE *)a3 + 16);
        v22 = "(new)";
        if ((v21 & 1) == 0)
          v22 = (const char *)&unk_21C704343;
        v23 = "(data)";
        v24 = *a2;
        if ((a3[2] & 8) == 0)
          v23 = (const char *)&unk_21C704343;
        v25 = a2[28];
        v26 = "(destroyed)";
        v27 = *((_QWORD *)a2 + 1);
        if ((a3[2] & 2) == 0)
          v26 = (const char *)&unk_21C704343;
        v50 = 136318210;
        if ((v21 & 4) != 0)
          v28 = "(ownerChange)";
        else
          v28 = (const char *)&unk_21C704343;
        v51 = v16;
        v52 = 2048;
        v53 = v18;
        if (a5)
          v29 = a5;
        else
          v29 = "Commit";
        v54 = 1024;
        v55 = v19;
        if ((v24 & 1) != 0)
          v30 = "(Atomic)";
        else
          v30 = (const char *)&unk_21C704343;
        v56 = 2048;
        v57 = v20;
        v58 = 2080;
        if ((v24 & 2) != 0)
          v31 = "(Held)";
        else
          v31 = (const char *)&unk_21C704343;
        v59 = v22;
        v32 = "(Fwd)";
        v60 = 2080;
        if (!v25)
          v32 = (const char *)&unk_21C704343;
        v61 = v23;
        v62 = 2080;
        v63 = v26;
        v64 = 2080;
        v65 = v28;
        v66 = 2080;
        v67 = v29;
        v68 = 2080;
        v69 = v30;
        v70 = 2080;
        v71 = v31;
        v72 = 2080;
        v73 = v32;
        v74 = 2048;
        v75 = v27;
        v33 = "\t%s Id=%llu(v#%u) Parent=%llu %s%s%s%s \t%s %s%s%s Peer=%llu";
        v34 = a1;
        v35 = 128;
LABEL_50:
        _os_log_debug_impl(&dword_21C69B000, v34, OS_LOG_TYPE_DEBUG, v33, (uint8_t *)&v50, v35);
      }
    }
    else if (v17)
    {
      v36 = *(_QWORD *)(v5 + 24);
      v37 = *(unsigned __int16 *)(v5 + 176);
      v38 = *((_BYTE *)a3 + 16);
      v39 = "(new)";
      v40 = (const char *)&unk_21C704343;
      if ((v38 & 1) == 0)
        v39 = (const char *)&unk_21C704343;
      v41 = *a2;
      v42 = "(data)";
      v43 = a2[28];
      if ((a3[2] & 8) == 0)
        v42 = (const char *)&unk_21C704343;
      v44 = (const char *)*((_QWORD *)a2 + 1);
      v45 = "(destroyed)";
      if ((a3[2] & 2) == 0)
        v45 = (const char *)&unk_21C704343;
      v50 = 136317954;
      v46 = "(ownerChange)";
      v51 = v16;
      v52 = 2048;
      if ((v38 & 4) == 0)
        v46 = (const char *)&unk_21C704343;
      v53 = v36;
      v47 = "Commit";
      v54 = 1024;
      if (a5)
        v47 = a5;
      v55 = v37;
      v56 = 2080;
      v57 = v39;
      if ((v41 & 1) != 0)
        v48 = "(Atomic)";
      else
        v48 = (const char *)&unk_21C704343;
      v58 = 2080;
      v59 = v42;
      if ((v41 & 2) != 0)
        v49 = "(Held)";
      else
        v49 = (const char *)&unk_21C704343;
      v60 = 2080;
      v61 = v45;
      if (v43)
        v40 = "(Fwd)";
      v62 = 2080;
      v63 = v46;
      v64 = 2080;
      v65 = v47;
      v66 = 2080;
      v67 = v48;
      v68 = 2080;
      v69 = v49;
      v70 = 2080;
      v71 = v40;
      v72 = 2048;
      v73 = v44;
      v33 = "\t%s Id=%llu(v#%u) %s%s%s%s \t%s %s%s%s Peer=%llu";
      v34 = a1;
      v35 = 118;
      goto LABEL_50;
    }

  }
}

uint64_t re::SyncSnapshotDump::log(NSObject *a1, uint64_t a2, const char *a3)
{
  unint64_t i;
  uint64_t *v7;
  uint64_t v8;
  _BYTE v10[16];
  unint64_t v11;

  re::DynamicArray<re::internal::SyncSnapshotEntry>::DynamicArray((uint64_t)v10, (uint64_t *)(a2 + 32));
  if (v11)
  {
    for (i = 0; i < v11; ++i)
    {
      v7 = (uint64_t *)re::SyncSnapshot::readAt((re::SyncSnapshot *)v10, i);
      re::SyncSnapshotDump::log(a1, (char *)a2, v7, v8, a3);
    }
  }
  return re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v10);
}

uint64_t re::SyncSelectiveAckedUnicast::SyncSelectiveAckedUnicast(uint64_t a1, id *a2, id *a3, uint64_t a4, uint64_t a5, uint64_t a6, id *a7, char a8, char a9, char a10, int a11)
{
  uint64_t v19;
  re *v20;
  uint64_t *v21;
  re::SyncObjectShortIDManagerImpl *v22;
  re::SyncObjectShortIDManagerImpl *v23;
  re *v24;
  uint64_t *v25;
  uint64_t v26;
  re::Transport *v27;
  char *WeakRetained;
  char *v29;
  _BOOL4 v30;
  uint64_t v31;
  char *v32;
  re::Transport *v33;
  uint64_t v34;
  char *v35;
  char *v36;
  _BOOL4 v37;
  re *v38;
  char *v39;
  char *v40;
  char *v41;
  re::Transport *v42;
  uint64_t v43;
  char *v44;
  char *v45;
  _BOOL4 v46;
  re *v47;
  uint64_t *v48;
  _anonymous_namespace_ *v49;
  void *v50;
  id v51;
  char *v52;
  re::Transport *v53;
  uint64_t v54;
  char *v55;
  char *v56;
  _BOOL4 v57;
  _anonymous_namespace_ *v58;
  uint64_t *v59;
  _anonymous_namespace_ *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  void *v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  re::Transport *v73;
  uint64_t v74;
  uint64_t v75;
  id *v77;
  unsigned int v78;
  char v79;
  uint64_t v80;
  id location;
  id to;

  v80 = a4;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24E071FB0;
  *(_QWORD *)(v19 + 24) = 0;
  objc_copyWeak((id *)(v19 + 24), a2);
  *(_OWORD *)(a1 + 32) = 0u;
  v77 = (id *)(a1 + 32);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = 0;
  v21 = re::globalAllocators(v20);
  v22 = (re::SyncObjectShortIDManagerImpl *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v21[2]
                                                                                                 + 32))(v21[2], 232, 8);
  v23 = re::SyncObjectShortIDManagerImpl::SyncObjectShortIDManagerImpl(v22);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 72) = v23;
  *(_QWORD *)(a1 + 80) = a5;
  *(_QWORD *)(a1 + 88) = a6;
  objc_copyWeak((id *)(a1 + 96), a7);
  *(_BYTE *)(a1 + 104) = a8;
  *(_BYTE *)(a1 + 105) = a9;
  *(_QWORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = a5;
  *(_QWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 148) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_QWORD *)(a1 + 228) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  v25 = re::globalAllocators(v24);
  v26 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v25[2] + 32))(v25[2], 208, 8);
  to = 0;
  objc_copyWeak(&to, a3);
  re::UnreliableAckedUnicastStream::UnreliableAckedUnicastStream(v26, &to, a4, 1, 4, 0);
  objc_destroyWeak(&to);
  if (*a3)
    v27 = (re::Transport *)((char *)*a3 - 8);
  else
    v27 = 0;
  WeakRetained = (char *)objc_loadWeakRetained(a2);
  if (WeakRetained)
    v29 = WeakRetained - 8;
  else
    v29 = 0;
  (*(void (**)(id *__return_ptr, char *))(*(_QWORD *)v29 + 32))(&to, v29);
  v30 = re::Transport::registerStream(v27, (re::TransportStream *)v26, 4uLL, a4);
  if (to)
  {

    to = 0;
  }

  if (v30)
  {
    v31 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = v26;
    v26 = v31;
  }
  LODWORD(location) = 0;
  v79 = 1;
  v78 = 5;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>((re *)&to, a3, &v80, (int *)&location, &v79, &v78);
  v32 = (char *)to;
  if (*a3)
    v33 = (re::Transport *)((char *)*a3 - 8);
  else
    v33 = 0;
  v34 = v80;
  v35 = (char *)objc_loadWeakRetained(a2);
  if (v35)
    v36 = v35 - 8;
  else
    v36 = 0;
  (*(void (**)(id *__return_ptr, char *))(*(_QWORD *)v36 + 32))(&to, v36);
  v37 = re::Transport::registerStream(v33, (re::TransportStream *)v32, 5uLL, v34);
  if (to)
  {

    to = 0;
  }

  if (v37)
  {
    v39 = *(char **)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v32;
    v32 = v39;
  }
  if (a10)
  {
    re::make::shared::object<re::SyncAckedStateBuffer>(v38, (uint64_t *)&to);
    v40 = (char *)*v77;
    *v77 = to;
    to = v40;
    if (v40)

    LODWORD(location) = 0;
    v79 = 1;
    v78 = 3;
    re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>((re *)&to, a3, &v80, (int *)&location, &v79, &v78);
    v41 = (char *)to;
    if (*a3)
      v42 = (re::Transport *)((char *)*a3 - 8);
    else
      v42 = 0;
    v43 = v80;
    v44 = (char *)objc_loadWeakRetained(a2);
    if (v44)
      v45 = v44 - 8;
    else
      v45 = 0;
    (*(void (**)(id *__return_ptr, char *))(*(_QWORD *)v45 + 32))(&to, v45);
    v46 = re::Transport::registerStream(v42, (re::TransportStream *)v41, 3uLL, v43);
    if (to)
    {

      to = 0;
    }

    if (v46)
    {
      v48 = re::globalAllocators(v47);
      v49 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v48[2] + 32))(v48[2], 32, 8);
      ArcSharedObject::ArcSharedObject(v49, 0);
      *(_QWORD *)v49 = &off_24E0720F0;
      *((_QWORD *)v49 + 3) = v41;
      if (v41)
      {
        v50 = v41 + 8;
        v51 = v50;

      }
      v41 = *(char **)(a1 + 40);
      *(_QWORD *)(a1 + 40) = v49;
    }
    if (v41)

  }
  LODWORD(location) = 0;
  v79 = 1;
  v78 = 2;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>((re *)&to, a3, &v80, (int *)&location, &v79, &v78);
  v52 = (char *)to;
  if (*a3)
    v53 = (re::Transport *)((char *)*a3 - 8);
  else
    v53 = 0;
  v54 = v80;
  v55 = (char *)objc_loadWeakRetained(a2);
  if (v55)
    v56 = v55 - 8;
  else
    v56 = 0;
  (*(void (**)(id *__return_ptr, char *))(*(_QWORD *)v56 + 32))(&to, v56);
  v57 = re::Transport::registerStream(v53, (re::TransportStream *)v52, 2uLL, v54);
  if (to)
  {

    to = 0;
  }

  if (v57)
  {
    v59 = re::globalAllocators(v58);
    v60 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v59[2] + 32))(v59[2], 32, 8);
    to = v52;
    v58 = re::MessageStreamer<re::SyncOwnershipRequest>::MessageStreamer(v60, (uint64_t *)&to);
    if (to)

    v61 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 64) = v60;
    if (v61)

    v52 = 0;
  }
  v62 = *(_QWORD *)(a1 + 72);
  v63 = *(_QWORD *)(a1 + 32);
  if (*a3)
    v64 = (uint64_t)*a3 - 8;
  else
    v64 = 0;
  v65 = *(_QWORD *)(v64 + 568);
  v66 = re::globalAllocators(v58);
  v67 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v66[2] + 32))(v66[2], 312, 8);
  if (v62)
    v68 = (void *)(v62 + 8);
  else
    v68 = 0;
  objc_initWeak(&to, v68);
  if (v63)
    v69 = (void *)(v63 + 8);
  else
    v69 = 0;
  objc_initWeak(&location, v69);
  re::SyncSendBuffer::SyncSendBuffer(v67, &to, &location, v65);
  objc_destroyWeak(&location);
  location = 0;
  objc_destroyWeak(&to);
  v70 = *(_QWORD *)(a1 + 280);
  *(_QWORD *)(a1 + 280) = v67;
  if (v70)
  {

    v67 = *(_QWORD *)(a1 + 280);
  }
  *(_QWORD *)(v67 + 216) = *(_QWORD *)(a1 + 80);
  *(_DWORD *)(v67 + 304) = a11;
  to = 0;
  v71 = v80;
  if (*a3)
    v72 = (uint64_t)*a3 - 8;
  else
    v72 = 0;
  if (re::Transport::receive(v72, v80, 1u, (unint64_t **)&to))
  {
    do
    {
      if (*a3)
        v73 = (re::Transport *)((char *)*a3 - 8);
      else
        v73 = 0;
      if (re::Transport::dispatchPacketToStream(v73, (re::Packet *)to, v71))
      {
        if (*a3)
          v74 = (uint64_t)*a3 - 8;
        else
          v74 = 0;
        re::PacketPool::free(*(re::PacketPool **)(v74 + 384), (re::Packet *)to);
      }
      if (*a3)
        v75 = (uint64_t)*a3 - 8;
      else
        v75 = 0;
    }
    while (re::Transport::receive(v75, v71, 1u, (unint64_t **)&to));
  }
  if (v52)

  if (v32)
  if (v26)

  return a1;
}

void re::SyncSelectiveAckedUnicast::send(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  char *WeakRetained;
  char *v20;
  void *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  re::SyncObject **v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  re *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int16 *v37;
  _QWORD *v38;
  int v39;
  uint64_t v40;
  _QWORD v41[2];
  uint64_t v42;
  int v43;
  char *v44;
  void (**v45)(re::StaticPacketBitWriter *__hidden);
  uint64_t v46;
  int v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint8_t buf[8];
  uint64_t v55;
  int v56;
  char v57;
  uint64_t v58;
  __int128 v59;
  __int128 v60;
  int v61;
  uint64_t v62;
  int v63;
  char v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  int v68;
  uint64_t v69;
  int v70;
  char v71;
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  int v75;
  uint64_t v76;
  int v77;
  char v78;
  uint64_t v79;
  __int128 v80;
  __int128 v81;
  int v82;
  uint64_t v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  _BYTE v94[24];
  uint64_t v95;
  _BYTE *v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 48) && (v6 = *(_QWORD *)(a1 + 56)) != 0 && *(_QWORD *)(a1 + 72))
  {
    *(_QWORD *)(a1 + 112) = 0;
    v11 = *(_QWORD *)(v6 + 32);
    if (v11)
      v12 = v11 - 8;
    else
      v12 = 0;
    v13 = *(_DWORD *)(v12 + 512);
    if (v13 >= 0x10000)
      v13 = 0x10000;
    v47 = 0;
    v48 = 0;
    v49 = 0;
    v50 = 0;
    v45 = &off_24E071F70;
    v46 = 0;
    v51 = v6;
    v52 = 0;
    v53 = v13;
    v44 = 0;
    v41[1] = 0;
    v42 = 0;
    v41[0] = 0;
    v43 = 0;
    v14 = *(_WORD *)(a1 + 104);
    v55 = a4;
    v58 = *(_QWORD *)(a4 + 56);
    v62 = 0;
    v59 = 0u;
    v60 = 0u;
    v61 = 0;
    v65 = v58;
    v69 = 0;
    v66 = 0u;
    v67 = 0u;
    v68 = 0;
    v72 = v58;
    v76 = 0;
    v73 = 0u;
    v74 = 0u;
    v75 = 0;
    v79 = v58;
    v83 = 0;
    v82 = 0;
    v80 = 0u;
    v81 = 0u;
    v84 = 0;
    v85 = v58;
    v86 = 0;
    v87 = 0;
    v88 = 0;
    v93 = 0;
    v89 = 0;
    v90 = 0;
    v92 = 0;
    v91 = 0;
    *(_WORD *)buf = v14;
    v57 = 1;
    v56 = 1;
    v64 = 0;
    v63 = 2;
    v78 = 0;
    v77 = 2;
    v71 = 0;
    v70 = 0;
    re::SyncCommitBuilder::begin((re::SyncCommitBuilder *)buf);
    v15 = *(unsigned int *)(a4 + 96);
    if ((_DWORD)v15)
    {
      v16 = 0;
      v17 = (int *)(*(_QWORD *)(a4 + 80) + 8);
      while (1)
      {
        v18 = *v17;
        v17 += 8;
        if (v18 < 0)
          break;
        if (v15 == ++v16)
        {
          LODWORD(v16) = *(_DWORD *)(a4 + 96);
          break;
        }
      }
    }
    else
    {
      LODWORD(v16) = 0;
    }
    if ((_DWORD)v15 != (_DWORD)v16)
    {
      v23 = v16;
      do
      {
        v24 = *(_QWORD *)(a4 + 80) + 32 * v23;
        v25 = (re::SyncObject **)(v24 + 16);
        v26 = *(_DWORD *)(v24 + 24);
        if (re::SyncCommitBuilder::shouldForward(buf, (uint64_t *)(v24 + 16)))
        {
          if (v26)
            re::SyncCommitBuilder::buildViewRemoval((uint64_t)buf, v25);
          else
            re::SyncCommitBuilder::buildViewAdd((uint64_t)buf, v25);
        }
        if (*(_DWORD *)(a4 + 96) <= (v16 + 1))
          v27 = v16 + 1;
        else
          v27 = *(_DWORD *)(a4 + 96);
        while (1)
        {
          v23 = (v16 + 1);
          if (v27 - 1 == (_DWORD)v16)
            break;
          LODWORD(v16) = v16 + 1;
          v28 = v23;
          if ((*(_DWORD *)(*(_QWORD *)(a4 + 80) + 32 * v23 + 8) & 0x80000000) != 0)
            goto LABEL_34;
        }
        v28 = v27;
LABEL_34:
        LODWORD(v16) = v28;
      }
      while ((_DWORD)v15 != v28);
    }
    v29 = a2[1];
    if (v29)
    {
      v30 = *a2;
      v31 = 72 * v29;
      do
      {
        re::SyncCommitBuilder::buildUpdate((uint64_t)buf, v30);
        v30 += 72;
        v31 -= 72;
      }
      while (v31);
    }
    re::SyncCommitBuilder::buildOwnershipChanges((uint64_t)buf, *(re::SyncObject ***)a3, *(_QWORD *)(a3 + 8));
    re::SyncCommitBuilder::end(buf, (_anonymous_namespace_ *)v41);
    re::SyncCommitBuilder::~SyncCommitBuilder((re::SyncCommitBuilder *)buf);
    v33 = v44;
    if (v42)
    {
      v34 = 72 * v42;
      do
      {
        re::SyncSelectiveAckedUnicast::sendCommit((_QWORD *)a1, v33, (uint64_t)&v45, a5);
        v33 += 72;
        v34 -= 72;
      }
      while (v34);
      v33 = v44;
      v35 = v42;
    }
    else
    {
      v35 = 0;
    }
    v36 = *(_QWORD *)(a1 + 280);
    v37 = (unsigned __int16 *)(*(_QWORD *)(a1 + 56) + 152);
    v95 = re::globalAllocators(v32)[2];
    v38 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v95 + 32))(v95, 32, 0);
    *v38 = &off_24E072040;
    v38[1] = a1;
    v38[2] = &v45;
    v38[3] = a5;
    v96 = v38;
    re::SyncSendBuffer::resend(v36, (uint64_t)v33, v35, v37, (uint64_t)v94);
    if (v96)
    {
      (**(void (***)(_BYTE *))v96)(v96);
      if (v96 != v94)
        (*(void (**)(uint64_t))(*(_QWORD *)v95 + 40))(v95);
      v96 = 0;
    }
    v39 = v49;
    if (HIDWORD(v49))
      v39 = v49 + 1;
    if (v39)
    {
      v40 = *(_QWORD *)(a1 + 56);
      *(_DWORD *)(v52 + 24) = v39;
      v49 = 0;
      v50 = 0;
      v46 = 0;
      v47 = 0;
      v52 = 0;
      (*(void (**)(uint64_t))(*(_QWORD *)v40 + 48))(v40);
    }
    re::UnreliableAckedUnicastStream::update(*(re::UnreliableAckedUnicastStream **)(a1 + 56));
    re::DynamicArray<re::SyncCommit>::deinit((uint64_t)v41);
    if (v52)
      (*(void (**)(uint64_t))(*(_QWORD *)v51 + 40))(v51);
  }
  else
  {
    WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 24));
    if (WeakRetained)
      v20 = WeakRetained - 8;
    else
      v20 = 0;
    v21 = v20 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v20 + 32))(buf);
    v22 = *(NSObject **)(*(_QWORD *)buf + 3272);

    *(_QWORD *)buf = 0;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v22, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to send.", buf, 2u);
    }
  }
}

void re::SyncSelectiveAckedUnicast::sendCommit(_QWORD *a1, char *a2, uint64_t a3, uint64_t a4)
{
  const char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD v19[2];
  char v20;
  _BYTE v21[8];
  __int128 v22;
  int v23;
  char v24;
  _BYTE v25[24];
  int v26;
  uint64_t v27;
  uint64_t v28[3];
  int v29;
  uint64_t v30;

  if (*a2 < 0)
    v8 = "ReSendCommit";
  else
    v8 = "SendCommit";
  re::SyncCommitDump::log((re *)a2, 1, v8);
  if ((*a2 & 1) != 0)
  {
    re::SyncSelectiveAckedUnicast::sendCommitReliable(a1, (uint64_t)a2, a4);
    return;
  }
  v9 = a1[4];
  v19[0] = a1[9];
  v19[1] = v9;
  v20 = 1;
  if (*((_QWORD *)a2 + 6))
  {
    v10 = 0;
    do
    {
      v11 = re::SyncPacker::packCommit(v19, (unsigned __int8 *)a2, (re::BitWriter *)a3, a4, v10);
      v13 = a1[14] + v11;
      a1[14] = v13;
      if (v13)
      {
        v14 = v11;
        re::SyncSendBuffer::objectsSent(a1[35], *((_QWORD *)a2 + 8) + 24 * v10, v11, *(unsigned __int16 *)(a1[7] + 192));
        v10 += v14;
        if (v10 < *((_QWORD *)a2 + 6))
        {
          v15 = a1[7];
          v16 = *(_DWORD *)(a3 + 24);
          if (*(_DWORD *)(a3 + 28))
            ++v16;
          *(_DWORD *)(*(_QWORD *)(a3 + 48) + 24) = v16;
          *(_QWORD *)(a3 + 24) = 0;
          *(_QWORD *)(a3 + 32) = 0;
          *(_QWORD *)(a3 + 8) = 0;
          *(_DWORD *)(a3 + 16) = 0;
          *(_QWORD *)(a3 + 48) = 0;
          (*(void (**)(uint64_t))(*(_QWORD *)v15 + 48))(v15);
          a1[14] = 0;
        }
      }
      else
      {
        v17 = *((_QWORD *)a2 + 6);
        if (v17 <= v10)
        {
          re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, v17);
          _os_crash();
          __break(1u);
          return;
        }
        v18 = *((_QWORD *)a2 + 8);
        v30 = 0;
        memset(v28, 0, sizeof(v28));
        v29 = 0;
        re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v28, (uint64_t *)(v18 + 24 * v10));
        v27 = 0;
        memset(v25, 0, sizeof(v25));
        v26 = 0;
        v22 = *(_OWORD *)(a2 + 8);
        v23 = *((_DWORD *)a2 + 6);
        v21[0] = *a2;
        v24 = a2[28];
        re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v25, v28);
        re::SyncSelectiveAckedUnicast::sendCommitReliable(a1, (uint64_t)v21, a4);
        re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v25);
        re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v28);
        ++v10;
      }
    }
    while (v10 < *((_QWORD *)a2 + 6));
  }
}

uint64_t re::SyncSelectiveAckedUnicast::sendCommitReliable(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  re::SyncObject **v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _QWORD v12[2];
  char v13;
  void (**v14)(re::DynamicPacketBitWriter *__hidden);
  uint64_t v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v5 = a1[6];
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v14 = &off_24E071758;
  v15 = 0;
  v20 = v5 + 24;
  v21 = 0;
  v12[0] = a1[9];
  v12[1] = 0;
  v13 = 0;
  result = re::SyncPacker::packCommit(v12, (unsigned __int8 *)a2, (re::BitWriter *)&v14, a3, 0);
  v7 = *(_QWORD *)(a2 + 48);
  if (v7)
  {
    v8 = *(re::SyncObject ***)(a2 + 64);
    v9 = 24 * v7;
    do
    {
      result = re::SyncSendBuffer::addAck(a1[35], v8);
      v8 += 3;
      v9 -= 24;
    }
    while (v9);
  }
  v10 = v18;
  if (HIDWORD(v18))
    v10 = v18 + 1;
  if (v10)
  {
    v11 = a1[6];
    *(_DWORD *)(v21 + 24) = v10;
    v18 = 0;
    v19 = 0;
    v15 = 0;
    v16 = 0;
    v21 = 0;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 48))(v11);
  }
  if (v21)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
  return result;
}

uint64_t re::SyncSelectiveAckedUnicast::receive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  char *WeakRetained;
  char *v13;
  void *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  char *v32;
  void *v33;
  re::SyncObjectStore *v34;
  re::SyncObjectTypedStore **v35;
  char *v36;
  char *v37;
  void *v38;
  NSObject *v39;
  NSObject *v40;
  const char *v41;
  uint32_t v42;
  re::SyncObjectTypedStore *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  void *v49;
  NSObject *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  re::SyncObject **v57;
  uint64_t v58;
  char *v59;
  void *v60;
  re::SyncObjectStore *v61;
  re::SyncObject *v62;
  char *v63;
  char *v64;
  void *v65;
  NSObject *v66;
  _BOOL4 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  BOOL v75;
  uint8_t buf[8];
  uint64_t v77;
  _QWORD v78[2];
  _QWORD v79[2];
  uint64_t v80;
  int v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  re::SyncObject *v85;
  int v86;
  char v87;
  uint64_t v88;
  uint64_t v89;
  re::SyncObjectTypedStore **v90;
  _BYTE v91[12];
  __int16 v92;
  uint64_t v93;
  __int16 v94;
  uint64_t v95;
  uint64_t v96;

  v96 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD **)(a1 + 48);
  if (!v5 || !*(_QWORD *)(a1 + 56) || !*(_QWORD *)(a1 + 72))
  {
    WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 24));
    if (WeakRetained)
      v13 = WeakRetained - 8;
    else
      v13 = 0;
    v14 = v13 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v13 + 32))(buf);
    v15 = *(NSObject **)(*(_QWORD *)buf + 3272);

    *(_QWORD *)buf = 0;
    result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v15, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", buf, 2u);
      return 0;
    }
    return result;
  }
  result = re::SyncSelectiveAckedUnicast::receiveFromStream(a1, v5, a2);
  if (!(_DWORD)result)
    return result;
  result = re::SyncSelectiveAckedUnicast::receiveFromStream(a1, *(_QWORD **)(a1 + 56), a2);
  if (!(_DWORD)result)
    return result;
  buf[0] = 0;
  v82 = 0;
  v79[1] = 0;
  v80 = 0;
  v79[0] = 0;
  v81 = 0;
  v77 = *(_QWORD *)(a1 + 80);
  v78[0] = 0;
  *(_QWORD *)((char *)v78 + 5) = 0;
  v8 = *(unsigned int *)(a1 + 224);
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = (int *)(*(_QWORD *)(a1 + 208) + 8);
    while (1)
    {
      v11 = *v10;
      v10 += 18;
      if (v11 < 0)
        break;
      if (v8 == ++v9)
      {
        LODWORD(v9) = *(_DWORD *)(a1 + 224);
        break;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  v73 = a2;
  v74 = a3;
  if ((_DWORD)v8 != (_DWORD)v9)
  {
    v75 = 0;
    v52 = v9;
    while (1)
    {
      v53 = *(_QWORD *)(a1 + 208);
      v54 = v53 + 72 * v52;
      v56 = *(_QWORD *)(v54 + 32);
      v55 = (uint64_t *)(v54 + 32);
      v57 = (re::SyncObject **)(v55 - 2);
      if (v56)
      {
        v58 = v53 + 72 * v52;
        if ((*(_BYTE *)(v58 + 56) & 2) != 0)
          goto LABEL_88;
        v59 = (char *)objc_loadWeakRetained((id *)(a1 + 96));
        v60 = v59;
        if (v59)
          v61 = (re::SyncObjectStore *)(v59 - 8);
        else
          v61 = 0;
        re::SyncObjectStore::findObject(v61, *(v55 - 1), *v55, (re::SyncObjectTypedStore ***)&v85);
        if (v60)

        v62 = v85;
        if (v85)
        {
          if (*((_QWORD *)*v57 + 10))
          {
            v63 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
            if (v63)
              v64 = v63 - 8;
            else
              v64 = 0;
            v65 = v64 + 8;
            (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v64 + 32))(v91);
            v66 = *(NSObject **)(*(_QWORD *)v91 + 3272);

            *(_QWORD *)v91 = 0;
            v67 = os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT);
            v62 = v85;
            if (v67)
            {
              v68 = *((_QWORD *)*v57 + 3);
              v69 = *(_QWORD *)(*((_QWORD *)*v57 + 10) + 24);
              v70 = *((_QWORD *)v85 + 3);
              *(_DWORD *)v91 = 134218496;
              *(_QWORD *)&v91[4] = v68;
              v92 = 2048;
              v93 = v69;
              v94 = 2048;
              v95 = v70;
              _os_log_impl(&dword_21C69B000, v66, OS_LOG_TYPE_DEFAULT, "Parent already bound for object: %llu, current parent: %llu, attempted new parent: %llu", v91, 0x20u);
            }
          }
          else
          {
            re::SyncObject::bindWithParent(*v57, v85);
          }
          re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v79, v58 + 40);
          re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((_QWORD *)(a1 + 240), (uint64_t *)v57);
          if (v62)

        }
      }
      else if (*(_BYTE *)(v53 + 72 * v52 + 64) || (*(_BYTE *)(v53 + 72 * v52 + 56) & 1) == 0)
      {
        v75 = (*(unsigned __int8 *)(v53 + 72 * v52 + 64) | v75) != 0;
        re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v79, v53 + 72 * v52 + 40);
LABEL_88:
        re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((_QWORD *)(a1 + 240), v55 - 2);
      }
      if (*(_DWORD *)(a1 + 224) <= (v9 + 1))
        v71 = v9 + 1;
      else
        v71 = *(_DWORD *)(a1 + 224);
      while (1)
      {
        v52 = (v9 + 1);
        if (v71 - 1 == (_DWORD)v9)
          break;
        LODWORD(v9) = v9 + 1;
        v72 = v52;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 208) + 72 * v52 + 8) & 0x80000000) != 0)
          goto LABEL_96;
      }
      v72 = v71;
LABEL_96:
      LODWORD(v9) = v72;
      if ((_DWORD)v8 == v72)
        goto LABEL_20;
    }
  }
  v75 = 0;
LABEL_20:
  v16 = *(_QWORD *)(a1 + 256);
  if (v16)
  {
    v17 = *(uint64_t **)(a1 + 272);
    v18 = &v17[v16];
    do
    {
      if (*(_QWORD *)(a1 + 192))
      {
        v19 = *v17;
        v20 = 0xBF58476D1CE4E5B9 * (*v17 ^ ((unint64_t)*v17 >> 30));
        v21 = ((0x94D049BB133111EBLL * (v20 ^ (v20 >> 27))) ^ ((0x94D049BB133111EBLL * (v20 ^ (v20 >> 27))) >> 31))
            % *(unsigned int *)(a1 + 216);
        v22 = *(_QWORD *)(a1 + 200);
        v23 = *(unsigned int *)(v22 + 4 * v21);
        if ((_DWORD)v23 != 0x7FFFFFFF)
        {
          v24 = *(_QWORD *)(a1 + 208);
          if (*(_QWORD *)(v24 + 72 * v23 + 16) == v19)
          {
            *(_DWORD *)(v22 + 4 * v21) = *(_DWORD *)(v24 + 72 * v23 + 8) & 0x7FFFFFFF;
LABEL_29:
            re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 208) + 72 * v23);
            *(_DWORD *)(*(_QWORD *)(a1 + 208) + 72 * v23 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 208) + 72 * v23 + 8) & 0x80000000 | *(_DWORD *)(a1 + 228);
            --*(_DWORD *)(a1 + 220);
            v26 = *(_DWORD *)(a1 + 232) + 1;
            *(_DWORD *)(a1 + 228) = v23;
            *(_DWORD *)(a1 + 232) = v26;
          }
          else
          {
            while (1)
            {
              v25 = v23;
              v23 = *(_DWORD *)(v24 + 72 * v23 + 8) & 0x7FFFFFFF;
              if (v23 == 0x7FFFFFFF)
                break;
              if (*(_QWORD *)(v24 + 72 * v23 + 16) == v19)
              {
                *(_DWORD *)(v24 + 72 * v25 + 8) = *(_DWORD *)(v24 + 72 * v25 + 8) & 0x80000000 | *(_DWORD *)(v24 + 72 * v23 + 8) & 0x7FFFFFFF;
                goto LABEL_29;
              }
            }
          }
        }
      }
      ++v17;
    }
    while (v17 != v18);
  }
  if (v80 != 0 && v75)
    buf[0] |= 1u;
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::clear(a1 + 240);
  v27 = *(_QWORD *)(a1 + 40);
  if (v27)
  {
    v28 = *(_QWORD *)(a1 + 40);
    v29 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v27 + 24) + 56))(*(_QWORD *)(v27 + 24));
    if (v29)
    {
      v30 = v29;
      while (1)
      {
        v31 = *(_DWORD *)(v30 + 24);
        v85 = *(re::SyncObject **)(v30 + 16);
        v86 = v31;
        v87 = 0;
        v88 = 0;
        v89 = 0;
        if (v31)
          break;
LABEL_68:
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v28 + 24) + 40))(*(_QWORD *)(v28 + 24), v30);
        v30 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v28 + 24) + 56))(*(_QWORD *)(v28 + 24));
        if (!v30)
          goto LABEL_69;
      }
      while (1)
      {
        v83 = 0;
        v84 = 0;
        re::BitReader::readUInt64((re::BitReader *)&v85, &v83);
        re::BitReader::readUInt64((re::BitReader *)&v85, (unint64_t *)&v84);
        if (v87)
          break;
        v32 = (char *)objc_loadWeakRetained((id *)(a1 + 96));
        v33 = v32;
        if (v32)
          v34 = (re::SyncObjectStore *)(v32 - 8);
        else
          v34 = 0;
        re::SyncObjectStore::findObject(v34, v83, v84, &v90);
        if (v33)

        v35 = v90;
        if (v90)
        {
          while (!*(_BYTE *)(*((_QWORD *)v35[11] + 2) + 74))
          {
            v35 = (re::SyncObjectTypedStore **)v35[10];
            if (!v35)
              goto LABEL_57;
          }
          v43 = v35[12];
          if (v43)
          {
            v44 = *((_QWORD *)v43 + 13);
            if (v44)
            {
              v45 = *((_QWORD *)v43 + 15);
              v46 = 8 * v44;
              while (*(_QWORD *)(*(_QWORD *)v45 + 56) != *(_QWORD *)(a1 + 80))
              {
                v45 += 8;
                v46 -= 8;
                if (!v46)
                  goto LABEL_57;
              }
              re::SyncSendBuffer::resetAcks(*(_QWORD *)(a1 + 280), (uint64_t *)&v90);
              goto LABEL_63;
            }
          }
LABEL_57:
          v47 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
          if (v47)
            v48 = v47 - 8;
          else
            v48 = 0;
          v49 = v48 + 8;
          (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v48 + 32))(v91);
          v50 = *(NSObject **)(*(_QWORD *)v91 + 3272);

          *(_QWORD *)v91 = 0;
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            v51 = *(_QWORD *)(a1 + 80);
            *(_DWORD *)v91 = 134218496;
            *(_QWORD *)&v91[4] = v83;
            v92 = 2048;
            v93 = v84;
            v94 = 2048;
            v95 = v51;
            v40 = v50;
            v41 = "Received history reset request for object {%llu, %llu}.But the object is not viewed by peer %llu.";
            v42 = 32;
            goto LABEL_62;
          }
        }
        else
        {
          v36 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
          if (v36)
            v37 = v36 - 8;
          else
            v37 = 0;
          v38 = v37 + 8;
          (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v37 + 32))(v91);
          v39 = *(NSObject **)(*(_QWORD *)v91 + 3272);

          *(_QWORD *)v91 = 0;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v91 = 134218240;
            *(_QWORD *)&v91[4] = v83;
            v92 = 2048;
            v93 = v84;
            v40 = v39;
            v41 = "Received history reset request for object {%llu, %llu}.But the object does not exist.";
            v42 = 22;
LABEL_62:
            _os_log_impl(&dword_21C69B000, v40, OS_LOG_TYPE_DEFAULT, v41, v91, v42);
          }
        }
LABEL_63:
        if (v90)

        HIDWORD(v88) = 0;
        v89 = 0;
        if (v86 == (_DWORD)v88)
          goto LABEL_68;
      }
    }
  }
LABEL_69:
  (*(void (**)(uint64_t, uint8_t *, uint64_t))(v74 + 16))(v74, buf, v73);
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v79);
  return 1;
}

uint64_t re::SyncSelectiveAckedUnicast::receiveFromStream(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  char *v6;
  __int16 v7;
  char *v8;
  uint64_t v9;
  unsigned __int16 v10;
  re *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  unint64_t v18;
  __int128 v19;
  unint64_t v20;
  uint64_t v21;
  id v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  uint64_t v34;
  re::SyncHistoryResetRequest *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *WeakRetained;
  char *v43;
  void *v44;
  NSObject *v45;
  uint64_t v46;
  re::Transport *v47;
  char *v48;
  char *v49;
  void *v50;
  NSObject *v51;
  uint64_t v53;
  char *v54;
  unsigned __int16 v55;
  uint64_t v56;
  uint64_t v57;
  int v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  int v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  uint8_t buf[8];
  char *v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  re::SyncHistoryResetRequest *v78;
  __int16 v79;
  __int128 v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _BYTE v86[12];
  __int16 v87;
  char *v88;
  uint64_t v89;

  v89 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 48) || !*(_QWORD *)(a1 + 56) || (v4 = *(_QWORD *)(a1 + 72)) == 0)
  {
    WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 24));
    if (WeakRetained)
      v43 = WeakRetained - 8;
    else
      v43 = 0;
    v44 = v43 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v43 + 32))(buf);
    v45 = *(NSObject **)(*(_QWORD *)buf + 3272);

    *(_QWORD *)buf = 0;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v45, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", buf, 2u);
    }
    return 0;
  }
  v6 = (char *)objc_loadWeakRetained((id *)(a1 + 96));
  v7 = *(_WORD *)(a1 + 104);
  v8 = v6 - 8;
  if (!v6)
    v8 = 0;
  *(_QWORD *)buf = v4;
  v68 = v8;
  v69 = *(_OWORD *)(a1 + 80);
  v70 = 0u;
  v71 = 0u;
  v72 = 0;
  v73 = 0x7FFFFFFFLL;
  v78 = 0;
  v75 = 0;
  v76 = 0;
  v74 = 0;
  v77 = 0;
  v79 = v7;
  if (v6)

  v9 = (*(uint64_t (**)(_QWORD *))(*a2 + 56))(a2);
  if (!v9)
    goto LABEL_45;
  v11 = (re *)(a1 + 120);
  v57 = a1 + 152;
  v61 = (_QWORD *)(a1 + 192);
LABEL_10:
  v56 = v9;
  v12 = *(_DWORD *)(v9 + 24);
  v62 = *(_QWORD *)(v9 + 16);
  v63 = v12;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  if (!v12)
    goto LABEL_43;
  v55 = v10;
  v13 = 2;
  while (1)
  {
    v14 = re::SyncUnpacker::unpackCommit((uint64_t **)buf, (uint64_t)&v62, (uint64_t)v11, a3);
    if (v14 < v13)
      v13 = v14;
    if (!v13)
      break;
    v59 = v13;
    re::SyncCommitDump::log(v11, 1, "RecvCommit");
    v15 = *(_QWORD *)(a1 + 168);
    if (v15)
    {
      v16 = *(_BYTE *)(a1 + 120) & 1;
      v17 = *(_QWORD *)(a1 + 184);
      v60 = v17 + 24 * v15;
      do
      {
        v18 = *(_QWORD *)v17;
        v19 = 0uLL;
        if ((_QWORD)v70)
        {
          v20 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v18 ^ (v18 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v18 ^ (v18 >> 30))) >> 27));
          v21 = *(unsigned int *)(*((_QWORD *)&v70 + 1) + 4 * ((v20 ^ (v20 >> 31)) % DWORD2(v71)));
          if ((_DWORD)v21 != 0x7FFFFFFF)
          {
            while (*(_QWORD *)(v71 + 40 * v21 + 16) != v18)
            {
              LODWORD(v21) = *(_DWORD *)(v71 + 40 * v21 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v21 == 0x7FFFFFFF)
                goto LABEL_23;
            }
            v19 = *(_OWORD *)(v71 + 40 * v21 + 24);
          }
        }
LABEL_23:
        v80 = v19;
        v81 = (char *)v18;
        if (v18)
        {
          v22 = (id)(v18 + 8);
          v23 = *(_QWORD *)v17;
        }
        else
        {
          v23 = 0;
        }
        v82 = *(_QWORD *)(v17 + 8);
        LOBYTE(v83) = *(_BYTE *)(v17 + 16);
        LOBYTE(v84) = v16;
        v24 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) >> 27));
        v25 = v24 ^ (v24 >> 31);
        if (*v61)
        {
          v26 = v25 % *(unsigned int *)(a1 + 216);
          v27 = *(unsigned int *)(*(_QWORD *)(a1 + 200) + 4 * v26);
          if ((_DWORD)v27 != 0x7FFFFFFF)
          {
            v28 = *(_QWORD *)(a1 + 208);
            while (*(_QWORD *)(v28 + 72 * v27 + 16) != v23)
            {
              LODWORD(v27) = *(_DWORD *)(v28 + 72 * v27 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v27 == 0x7FFFFFFF)
                goto LABEL_33;
            }
            v30 = v28 + 72 * v27 + 24;
            if (!v18)
              goto LABEL_35;
LABEL_34:

            goto LABEL_35;
          }
        }
        else
        {
          LODWORD(v26) = 0;
        }
LABEL_33:
        v29 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove((uint64_t)v61, v26, v25, (uint64_t *)v17, (uint64_t)&v80);
        ++*(_DWORD *)(a1 + 232);
        v30 = *(_QWORD *)(a1 + 208) + 72 * v29 + 24;
        v18 = (unint64_t)v81;
        if (v81)
          goto LABEL_34;
LABEL_35:
        *(_BYTE *)(v30 + 40) |= v16;
        v31 = *(unsigned __int8 *)(v30 + 32);
        v32 = *(_BYTE *)(v17 + 16) & 1 | v31;
        *(_BYTE *)(v30 + 32) = v32;
        v33 = v32 & 0xFFFFFFFD | (2 * (((*(unsigned __int8 *)(v17 + 16) | v31) >> 1) & 1));
        *(_BYTE *)(v30 + 32) = v33;
        LOBYTE(v33) = v33 & 0xFB | (4 * (((*(unsigned __int8 *)(v17 + 16) | v31) & 4) != 0));
        *(_BYTE *)(v30 + 32) = v33;
        *(_BYTE *)(v30 + 32) = v33 & 0xF7 | (*(_BYTE *)(v17 + 16) | v31) & 8;
        if ((*(_BYTE *)(v17 + 16) & 8) != 0)
          *(_QWORD *)(v30 + 24) = *(_QWORD *)(v17 + 8);
        v17 += 24;
      }
      while (v17 != v60);
    }
    re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(v57);
    v11 = (re *)(a1 + 120);
    v13 = v59;
    if (v63 == (_DWORD)v65)
    {
      v10 = v55;
      if (v59 == 2)
LABEL_43:
        (*(void (**)(_QWORD *, _QWORD))(*a2 + 64))(a2, v10);
      (*(void (**)(_QWORD *, uint64_t))(*a2 + 40))(a2, v56);
      v9 = (*(uint64_t (**)(_QWORD *))(*a2 + 56))(a2);
      if (!v9)
      {
LABEL_45:
        v34 = *(_QWORD *)(a1 + 40);
        if (v34)
        {
          v35 = v78;
          v36 = *(_QWORD *)(v34 + 24) + 24;
          LODWORD(v81) = 0;
          BYTE4(v81) = 0;
          v82 = 0;
          v83 = 0;
          *(_QWORD *)&v80 = &off_24E071758;
          *((_QWORD *)&v80 + 1) = 0;
          v84 = v36;
          v85 = 0;
          if (v76)
          {
            v37 = 16 * v76;
            do
            {
              re::SyncHistoryResetRequest::write(v35, (re::BitWriter *)&v80);
              re::BitWriter::alignToByte(&v80);
              v35 = (re::SyncHistoryResetRequest *)((char *)v35 + 16);
              v37 -= 16;
            }
            while (v37);
            v38 = v82;
            v39 = v85;
            if (HIDWORD(v82))
              v38 = v82 + 1;
            if (v38)
            {
              v40 = *(_QWORD *)(v34 + 24);
              *(_DWORD *)(v85 + 24) = v38;
              v82 = 0;
              v83 = 0;
              *((_QWORD *)&v80 + 1) = 0;
              LODWORD(v81) = 0;
              v85 = 0;
              (*(void (**)(uint64_t))(*(_QWORD *)v40 + 48))(v40);
              v39 = v85;
            }
            if (v39)
              (*(void (**)(uint64_t))(*(_QWORD *)v84 + 24))(v84);
          }
        }
        v41 = 1;
        goto LABEL_73;
      }
      goto LABEL_10;
    }
  }
  v46 = a2[4];
  if (v46)
    v47 = (re::Transport *)(v46 - 8);
  else
    v47 = 0;
  re::Transport::connectionAddress(v47, a2[5], (re::DynamicString *)&v80);
  v48 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
  if (v48)
    v49 = v48 - 8;
  else
    v49 = 0;
  v50 = v49 + 8;
  (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v49 + 32))(v86);
  v51 = *(NSObject **)(*(_QWORD *)v86 + 3272);

  *(_QWORD *)v86 = 0;
  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
  {
    v53 = *(_QWORD *)(a1 + 80);
    if ((BYTE8(v80) & 1) != 0)
      v54 = v81;
    else
      v54 = (char *)&v80 + 9;
    *(_DWORD *)v86 = 134218242;
    *(_QWORD *)&v86[4] = v53;
    v87 = 2082;
    v88 = v54;
    _os_log_error_impl(&dword_21C69B000, v51, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)", v86, 0x16u);
  }
  re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(v57);
  (*(void (**)(_QWORD *, uint64_t))(*a2 + 40))(a2, v56);
  if ((_QWORD)v80 && (BYTE8(v80) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v80 + 40))();
  v41 = 0;
LABEL_73:
  if (v74)
  {
    if (v78)
      (*(void (**)(void))(*(_QWORD *)v74 + 40))();
    v78 = 0;
    v75 = 0;
    v76 = 0;
    v74 = 0;
    ++v77;
  }
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)&v70);
  return v41;
}

_DWORD *re::SyncSelectiveAckedUnicast::sendOwnershipRequests(uint64_t a1, uint64_t a2)
{
  return re::MessageStreamer<re::SyncOwnershipRequest>::send(*(_DWORD **)(a1 + 64), *(re::SyncOwnershipRequest **)a2, *(_QWORD *)(a2 + 8));
}

_DWORD *re::MessageStreamer<re::SyncOwnershipRequest>::send(_DWORD *result, re::SyncOwnershipRequest *this, uint64_t a3)
{
  uint64_t v3;
  _DWORD *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void (**v10)(re::DynamicPacketBitWriter *__hidden);
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *((_QWORD *)result + 3);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v10 = &off_24E071758;
  v11 = 0;
  v16 = v3 + 24;
  v17 = 0;
  if (a3)
  {
    v5 = result;
    v6 = 80 * a3;
    do
    {
      re::SyncOwnershipRequest::write(this, (re::BitWriter *)&v10);
      result = re::BitWriter::alignToByte(&v10);
      this = (re::SyncOwnershipRequest *)((char *)this + 80);
      v6 -= 80;
    }
    while (v6);
    v7 = v14;
    v8 = v17;
    if (HIDWORD(v14))
      v7 = v14 + 1;
    if (v7)
    {
      v9 = *((_QWORD *)v5 + 3);
      *(_DWORD *)(v17 + 24) = v7;
      v14 = 0;
      v15 = 0;
      v11 = 0;
      v12 = 0;
      v17 = 0;
      result = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
      v8 = v17;
    }
    if (v8)
      return (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
  }
  return result;
}

uint64_t re::SyncSelectiveAckedUnicast::receiveOwnershipRequests(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  unint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  _BYTE v8[24];
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 64);
  v9 = *((_QWORD *)a2 + 3);
  v10 = 0;
  if (v8 != a2)
  {
    if (*((_BYTE **)a2 + 4) == a2)
    {
      v4 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)a2 + 40))(a2);
      if (v4 >= 0x19)
      {
        if (v9)
          v5 = (_BYTE *)(*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, v4, 0);
        else
          v5 = 0;
      }
      else
      {
        v5 = v8;
      }
      v10 = v5;
      (*(void (**)(_QWORD))(**((_QWORD **)a2 + 4) + 32))(*((_QWORD *)a2 + 4));
      re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)a2);
    }
    else
    {
      v10 = (_BYTE *)*((_QWORD *)a2 + 4);
      *((_QWORD *)a2 + 4) = 0;
    }
  }
  v6 = re::MessageStreamer<re::SyncOwnershipRequest>::receive<re::Function<void ()(re::SyncOwnershipRequest const&)>>(v2, (uint64_t)v8);
  if (v10)
  {
    (**(void (***)(_BYTE *))v10)(v10);
    if (v10 != v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
  }
  return v6;
}

uint64_t re::MessageStreamer<re::SyncOwnershipRequest>::receive<re::Function<void ()(re::SyncOwnershipRequest const&)>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  _QWORD v8[2];
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint64_t v20;
  uint64_t v21;

  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 56))(*(_QWORD *)(a1 + 24));
  if (!v4)
    return 1;
  v5 = v4;
  while (1)
  {
    v6 = *(_DWORD *)(v5 + 24);
    v17 = *(_QWORD *)(v5 + 16);
    v18 = v6;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    if (v6)
      break;
LABEL_10:
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24), v5);
    v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 56))(*(_QWORD *)(a1 + 24));
    if (!v5)
      return 1;
  }
  while (1)
  {
    v10 = 0;
    v11 = 0;
    v13 = 0;
    v12 = 0;
    v8[0] = 0;
    v8[1] = 0;
    v9 = 0;
    v15 = 0;
    v16 = 0;
    v14 = 0;
    if (!re::SyncOwnershipRequest::read((re::SyncOwnershipRequest *)v8, (re::BitReader *)&v17) || v19)
      break;
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), v8);
    HIDWORD(v20) = 0;
    v21 = 0;
    if (v10)
    {
      if (v14)
        (*(void (**)(void))(*(_QWORD *)v10 + 40))();
    }
    if (v18 == (_DWORD)v20)
      goto LABEL_10;
  }
  if (v10 && v14)
    (*(void (**)(void))(*(_QWORD *)v10 + 40))();
  return 0;
}

void re::SyncSelectiveAckedUnicast::~SyncSelectiveAckedUnicast(re::SyncSelectiveAckedUnicast *this)
{
  re::SyncSelectiveAckedUnicast::~SyncSelectiveAckedUnicast(this);
  JUMPOUT(0x220780CD0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *((_QWORD *)this + 35);
  if (v2)
  {

    *((_QWORD *)this + 35) = 0;
  }
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 240);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 24);
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 152);
  objc_destroyWeak((id *)this + 12);
  *((_QWORD *)this + 12) = 0;
  v3 = *((_QWORD *)this + 9);
  if (v3)
  {

    *((_QWORD *)this + 9) = 0;
  }
  v4 = *((_QWORD *)this + 8);
  if (v4)
  {

    *((_QWORD *)this + 8) = 0;
  }
  v5 = *((_QWORD *)this + 7);
  if (v5)
  {

    *((_QWORD *)this + 7) = 0;
  }
  v6 = *((_QWORD *)this + 6);
  if (v6)
  {

    *((_QWORD *)this + 6) = 0;
  }
  v7 = *((_QWORD *)this + 5);
  if (v7)
  {

    *((_QWORD *)this + 5) = 0;
  }
  v8 = *((_QWORD *)this + 4);
  if (v8)
  {

    *((_QWORD *)this + 4) = 0;
  }
  objc_destroyWeak((id *)this + 3);
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

void re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::operator()(uint64_t a1, char *a2)
{
  re::SyncSelectiveAckedUnicast::sendCommit(*(_QWORD **)(a1 + 8), a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24E072040;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24E072040;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::size()
{
  return 32;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(uint64_t a1))(_QWORD)
{
  uint64_t (***result)(_QWORD);

  result = *(uint64_t (****)(_QWORD))(a1 + 32);
  if (result)
  {
    result = (uint64_t (***)(_QWORD))(**result)(result);
    if (*(_QWORD *)(a1 + 32) != a1)
      result = (uint64_t (***)(_QWORD))(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24));
    *(_QWORD *)(a1 + 32) = 0;
  }
  return result;
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 72;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  uint64_t v4;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {

      *(_QWORD *)(a1 + 16) = 0;
    }
    v4 = *(_QWORD *)(a1 + 40);
    if (v4)
    {

      *(_QWORD *)(a1 + 40) = 0;
    }
  }
}

void re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>(re *a1, id *a2, uint64_t *a3, int *a4, char *a5, unsigned int *a6)
{
  uint64_t *v12;
  uint64_t v13;
  id to;

  v12 = re::globalAllocators(a1);
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12[2] + 32))(v12[2], 112, 8);
  to = 0;
  objc_copyWeak(&to, a2);
  re::UnicastStream::UnicastStream(v13, &to, *a3, *a4, *a5, *a6, 0);
  *(_QWORD *)a1 = v13;
  objc_destroyWeak(&to);
}

double re::make::shared::object<re::SyncAckedStateBuffer>@<D0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  double result;

  v3 = re::globalAllocators(a1);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 72, 8);
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_QWORD *)(v4 + 64) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(_QWORD *)v4 = &off_24E0720A8;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_DWORD *)(v4 + 56) = 0;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(v4 + 60) = 0x7FFFFFFFLL;
  *a2 = v4;
  return result;
}

void re::SyncAckedStateBuffer::~SyncAckedStateBuffer(re::SyncAckedStateBuffer *this)
{
  *(_QWORD *)this = &off_24E0720A8;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0720A8;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

_QWORD *re::MessageStreamer<re::SyncHistoryResetRequest>::~MessageStreamer(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E0720F0;
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &off_24E0707C0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::MessageStreamer<re::SyncHistoryResetRequest>::~MessageStreamer(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E0720F0;
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &off_24E0707C0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x220780CD0);
}

_anonymous_namespace_ *re::MessageStreamer<re::SyncOwnershipRequest>::MessageStreamer(_anonymous_namespace_ *a1, uint64_t *a2)
{
  uint64_t v4;
  id v5;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = &off_24E072138;
  v4 = *a2;
  *((_QWORD *)a1 + 3) = v4;
  if (v4)
    v5 = (id)(v4 + 8);
  return a1;
}

_QWORD *re::MessageStreamer<re::SyncOwnershipRequest>::~MessageStreamer(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072138;
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &off_24E0707C0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::MessageStreamer<re::SyncOwnershipRequest>::~MessageStreamer(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072138;
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &off_24E0707C0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x220780CD0);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE v31[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(_QWORD *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v31, v13, v12);
          v15 = *(_OWORD *)v31;
          *(_OWORD *)v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v31[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v31[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v31[24];
          *(_OWORD *)&v31[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21, v21 + 8);
              v21 += 72;
              --v20;
            }
            while (v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 72 * v9 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 72 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 72 * v9 + 8) = v23 | 0x80000000;
  v25 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v9) = a3;
  v26 = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v9 + 16) = *a4;
  if (v26)
    v27 = (id)(v26 + 8);
  v28 = *(_QWORD *)(a1 + 16) + 72 * v9;
  *(_OWORD *)(v28 + 24) = *(_OWORD *)a5;
  *(_QWORD *)(v28 + 40) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)(a5 + 16) = 0;
  v29 = *(_QWORD *)(a5 + 24);
  *(_BYTE *)(v28 + 56) = *(_BYTE *)(a5 + 32);
  *(_QWORD *)(v28 + 48) = v29;
  *(_BYTE *)(v28 + 64) = *(_BYTE *)(a5 + 40);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v25) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 72 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::SyncReliableOrderedUnicast::SyncReliableOrderedUnicast(uint64_t a1, id *a2, re *a3, unint64_t a4, uint64_t a5, uint64_t a6, id *a7, char a8, char a9, char a10)
{
  unint64_t **v17;
  uint64_t v18;
  unint64_t **v19;
  re *v20;
  uint64_t *v21;
  re::SyncObjectShortIDManagerImpl *v22;
  uint64_t v23;
  unint64_t *v24;
  re::Transport *v25;
  unint64_t v26;
  char *WeakRetained;
  char *v28;
  _BOOL4 v29;
  re *v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t *v33;
  re::Transport *v34;
  unint64_t v35;
  char *v36;
  char *v37;
  _BOOL4 v38;
  re *v39;
  uint64_t *v40;
  _anonymous_namespace_ *v41;
  unint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  re::Transport *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v49[5];
  _QWORD v50[5];
  _QWORD *v51;
  unsigned int v52;
  char v53;
  int v54;
  unint64_t v55;
  unint64_t *v56;

  v55 = a4;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24E072180;
  *(_QWORD *)(a1 + 24) = 0;
  v17 = (unint64_t **)(a1 + 24);
  *(_QWORD *)(v18 + 32) = 0;
  objc_copyWeak((id *)(v18 + 32), a2);
  *(_QWORD *)(a1 + 40) = 0;
  v19 = (unint64_t **)(a1 + 40);
  *(_QWORD *)(a1 + 48) = 0;
  v21 = re::globalAllocators(v20);
  v22 = (re::SyncObjectShortIDManagerImpl *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v21[2]
                                                                                                 + 32))(v21[2], 232, 8);
  *(_QWORD *)(a1 + 56) = re::SyncObjectShortIDManagerImpl::SyncObjectShortIDManagerImpl(v22);
  *(_QWORD *)(a1 + 64) = a5;
  *(_QWORD *)(a1 + 72) = a6;
  *(_QWORD *)(a1 + 80) = 0;
  objc_copyWeak((id *)(a1 + 80), a7);
  *(_BYTE *)(a1 + 88) = a8;
  *(_BYTE *)(a1 + 89) = a9;
  *(_WORD *)(a1 + 90) = 0;
  *(_BYTE *)(a1 + 92) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 132) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 144) = 0x8000000000000000;
  v54 = 0;
  v53 = 1;
  v52 = 1;
  v23 = MEMORY[0x24BDAC760];
  v50[0] = MEMORY[0x24BDAC760];
  v50[1] = 0x40000000;
  v50[2] = ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke;
  v50[3] = &__block_descriptor_tmp_4;
  v50[4] = a1;
  v51 = v50;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(a3, (uint64_t *)&v55, &v54, &v53, &v52, (const void **)&v51, (uint64_t *)&v56);
  v24 = v56;
  if (*(_QWORD *)a3)
    v25 = (re::Transport *)(*(_QWORD *)a3 - 8);
  else
    v25 = 0;
  v26 = v55;
  WeakRetained = (char *)objc_loadWeakRetained(a2);
  if (WeakRetained)
    v28 = WeakRetained - 8;
  else
    v28 = 0;
  (*(void (**)(unint64_t **__return_ptr, char *))(*(_QWORD *)v28 + 32))(&v56, v28);
  v29 = re::Transport::registerStream(v25, (re::TransportStream *)v24, 1uLL, v26);
  if (v56)
  {

    v56 = 0;
  }

  if (v29)
  {
    v31 = *v19;
    *v19 = v24;
    v24 = v31;
  }
  if (a10)
  {
    re::make::shared::object<re::SyncAckedStateBuffer>(v30, (uint64_t *)&v56);
    v32 = *v17;
    *v17 = v56;
    v56 = v32;
    if (v32)

  }
  v54 = 0;
  v53 = 1;
  v52 = 2;
  v49[0] = v23;
  v49[1] = 0x40000000;
  v49[2] = ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke_2;
  v49[3] = &__block_descriptor_tmp_1;
  v49[4] = a1;
  v51 = v49;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(a3, (uint64_t *)&v55, &v54, &v53, &v52, (const void **)&v51, (uint64_t *)&v56);
  v33 = v56;
  if (*(_QWORD *)a3)
    v34 = (re::Transport *)(*(_QWORD *)a3 - 8);
  else
    v34 = 0;
  v35 = v55;
  v36 = (char *)objc_loadWeakRetained(a2);
  if (v36)
    v37 = v36 - 8;
  else
    v37 = 0;
  (*(void (**)(unint64_t **__return_ptr, char *))(*(_QWORD *)v37 + 32))(&v56, v37);
  v38 = re::Transport::registerStream(v34, (re::TransportStream *)v33, 2uLL, v35);
  if (v56)
  {

    v56 = 0;
  }

  if (v38)
  {
    v40 = re::globalAllocators(v39);
    v41 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v40[2] + 32))(v40[2], 32, 8);
    v56 = v33;
    if (v33)
      v42 = v33 + 1;
    re::MessageStreamer<re::SyncOwnershipRequest>::MessageStreamer(v41, (uint64_t *)&v56);
    if (v56)

    v43 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v41;
    if (v43)

  }
  v56 = 0;
  if (*(_QWORD *)a3)
    v44 = *(_QWORD *)a3 - 8;
  else
    v44 = 0;
  if (re::Transport::receive(v44, v55, 1u, &v56))
  {
    do
    {
      if (*(_QWORD *)a3)
        v45 = (re::Transport *)(*(_QWORD *)a3 - 8);
      else
        v45 = 0;
      if (re::Transport::dispatchPacketToStream(v45, (re::Packet *)v56, v55))
      {
        if (*(_QWORD *)a3)
          v46 = *(_QWORD *)a3 - 8;
        else
          v46 = 0;
        re::PacketPool::free(*(re::PacketPool **)(v46 + 384), (re::Packet *)v56);
      }
      if (*(_QWORD *)a3)
        v47 = *(_QWORD *)a3 - 8;
      else
        v47 = 0;
    }
    while (re::Transport::receive(v47, v55, 1u, &v56));
  }
  if (v33)

  if (v24)
  return a1;
}

uint64_t ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 91) = 1;
  return result;
}

uint64_t ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke_2(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 92) = 1;
  return result;
}

void re::SyncReliableOrderedUnicast::send(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  re::SyncObject **v8;
  uint64_t v9;
  re::SyncObject **v10;
  re::SyncObject *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  char *WeakRetained;
  char *v18;
  void *v19;
  NSObject *v20;
  uint64_t v21;
  _BOOL8 v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  id v32;
  re::SyncObject *v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  int v37;
  char *v38;
  char *v39;
  void *v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  id v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  re *v82;
  uint64_t v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  _BYTE *v87;
  uint64_t *v88;
  _BYTE *v89;
  uint64_t v90;
  uint64_t v91;
  int *v92;
  int v93;
  std::chrono::steady_clock::time_point v94;
  re *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  int *v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  const char *v109;
  const char *v110;
  BOOL v111;
  const char *v112;
  size_t v113;
  size_t v114;
  size_t v115;
  int v116;
  int v117;
  char *v118;
  char *v119;
  void *v120;
  NSObject *v121;
  double v122;
  char *v123;
  char *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  re::Transport *v128;
  _BYTE *v129;
  char *v130;
  uint64_t v131;
  int v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  int *v136;
  int v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  id v143;
  int v144;
  int v145;
  unint64_t v146;
  re *v147;
  _OWORD *v148;
  re *v149;
  uint64_t v150;
  char *v151;
  __int128 v152;
  __int128 v153;
  uint64_t v154;
  uint64_t v155;
  re *v156;
  uint64_t v157;
  int v158;
  uint64_t v159;
  re *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  _OWORD v168[2];
  __int128 v169;
  __int128 v170;
  uint64_t v171;
  uint64_t v172;
  char v173;
  _BYTE v174[23];
  re::Session *v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  int v179;
  int v180[2];
  uint8_t v181[48];
  uint8_t buf[32];
  __int128 v183;
  __int128 v184;
  __int128 v185;
  uint64_t v186;

  v186 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 40) && *(_QWORD *)(a1 + 56))
  {
    *(_QWORD *)v180 = 0;
    v177 = 0;
    v178 = 0;
    v176 = 0;
    v179 = 0;
    v8 = *(re::SyncObject ***)a3;
    v7 = *(_QWORD *)(a3 + 8);
    *(_QWORD *)&v169 = 0;
    memset(v168, 0, 28);
    v9 = *(_QWORD *)(a4 + 56);
    if (v7)
    {
      v10 = &v8[v7];
      do
      {
        v11 = *v8;
        if (*v8)
        {
          while (!*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v11 + 11) + 16) + 74))
          {
            v11 = (re::SyncObject *)*((_QWORD *)v11 + 10);
            if (!v11)
              goto LABEL_35;
          }
          v12 = *((_QWORD *)v11 + 12);
          if (v12)
          {
            v13 = *(_QWORD **)(v12 + 120);
            v14 = *(_QWORD *)(v12 + 104);
            if (v14)
            {
              v15 = 8 * v14;
              v16 = v13;
              while (*v16 != a4)
              {
                ++v16;
                v15 -= 8;
                if (!v15)
                {
                  v16 = &v13[v14];
                  break;
                }
              }
            }
            else
            {
              v16 = v13;
            }
            if (v14 != v16 - v13)
            {
              WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
              if (WeakRetained)
                v18 = WeakRetained - 8;
              else
                v18 = 0;
              v19 = v18 + 8;
              (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v18 + 32))(buf);
              v20 = *(NSObject **)(*(_QWORD *)buf + 3272);

              *(_QWORD *)buf = 0;
              if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
              {
                v21 = *((_QWORD *)*v8 + 3);
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v21;
                _os_log_impl(&dword_21C69B000, v20, OS_LOG_TYPE_INFO, "[Ownership] Adding ownership changes for: %llu", buf, 0xCu);
              }
              v22 = re::SyncObject::takeOverLatestState(*v8);
              if (v22)
              {
                if (v178)
                {
                  v23 = *(_QWORD *)v180 + 72 * v178 - 72;
                }
                else
                {
                  buf[0] = 0;
                  *(_QWORD *)&buf[8] = v9;
                  *(_QWORD *)&buf[16] = 0;
                  *(_DWORD *)&buf[24] = 0;
                  buf[28] = 0;
                  *(_QWORD *)&v185 = 0;
                  *(_QWORD *)&v184 = 0;
                  v183 = 0uLL;
                  DWORD2(v184) = 0;
                  re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v176, (uint64_t)buf);
                  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v183);
                  v31 = *(_QWORD *)v180 + 72 * v178;
                  *(_BYTE *)(v31 - 72) = 1;
                  v23 = v31 - 72;
                }
                *(_QWORD *)buf = *v8;
                if (*(_QWORD *)buf)
                {
                  v32 = (id)(*(_QWORD *)buf + 8);
                  v33 = *v8;
                }
                else
                {
                  v33 = 0;
                }
                *(_QWORD *)&buf[8] = re::SyncObject::latestStateHandle(v33);
                buf[16] &= 0xF0u;
                re::DynamicArray<re::internal::SyncSnapshotEntry>::add((_QWORD *)(v23 + 32), (uint64_t)buf);
                if (*(_QWORD *)buf)

              }
              else
              {
                v24 = *re::networkLogObjects((re *)v22);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                {
                  v25 = *((_QWORD *)*v8 + 3);
                  v26 = *(_QWORD **)(*((_QWORD *)*v8 + 11) + 16);
                  v27 = v26[4];
                  v28 = v26[6];
                  v29 = (char *)v26[7];
                  v30 = (char *)v26 + 49;
                  if ((v28 & 1) != 0)
                    v30 = v29;
                  *(_DWORD *)buf = 134218498;
                  *(_QWORD *)&buf[4] = v25;
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v27;
                  *(_WORD *)&buf[22] = 2080;
                  *(_QWORD *)&buf[24] = v30;
                  _os_log_error_impl(&dword_21C69B000, v24, OS_LOG_TYPE_ERROR, "Sync object without snapshot while packing ownership broadcasts (id: %llu, type: %llu[%s]).", buf, 0x20u);
                }
              }
            }
          }
        }
LABEL_35:
        ++v8;
      }
      while (v8 != v10);
    }
    v34 = *(unsigned int *)(a4 + 96);
    if ((_DWORD)v34)
    {
      v35 = 0;
      v36 = (int *)(*(_QWORD *)(a4 + 80) + 8);
      while (1)
      {
        v37 = *v36;
        v36 += 8;
        if (v37 < 0)
          break;
        if (v34 == ++v35)
        {
          LODWORD(v35) = *(_DWORD *)(a4 + 96);
          break;
        }
      }
    }
    else
    {
      LODWORD(v35) = 0;
    }
    if ((_DWORD)v34 != (_DWORD)v35)
    {
      v42 = v35;
      do
      {
        v43 = *(_QWORD *)(a4 + 80) + 32 * v42;
        v46 = *(_QWORD *)(v43 + 16);
        v45 = v43 + 16;
        v44 = v46;
        v47 = *(_QWORD *)(v46 + 80);
        v48 = v46;
        if (v47)
        {
          v49 = v44;
          do
          {
            v48 = v49;
            v49 = v47;
            if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v48 + 88) + 16) + 73))
              break;
            v47 = *(_QWORD *)(v47 + 80);
            v48 = v49;
          }
          while (v47);
        }
        if (*(_BYTE *)(v48 + 170) || *(_BYTE *)(a1 + 88) || *(_BYTE *)(a1 + 89))
        {
          if (*(_DWORD *)(v45 + 8))
          {
            *(_QWORD *)buf = v44;
            re::DynamicArray<re::SyncCommit const*>::add(v168, buf);
          }
          else
          {
            if (v178)
            {
              v50 = *(_QWORD *)v180 + 72 * v178 - 72;
            }
            else
            {
              buf[0] = 0;
              *(_QWORD *)&buf[8] = v9;
              *(_QWORD *)&buf[16] = 0;
              *(_DWORD *)&buf[24] = 0;
              buf[28] = 0;
              *(_QWORD *)&v185 = 0;
              *(_QWORD *)&v184 = 0;
              v183 = 0uLL;
              DWORD2(v184) = 0;
              re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v176, (uint64_t)buf);
              re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v183);
              v51 = *(_QWORD *)v180 + 72 * v178;
              *(_BYTE *)(v51 - 72) = 1;
              v50 = v51 - 72;
            }
            addToViewRecursive((re::SyncObject **)v45, v50, *(_QWORD *)(a4 + 56));
          }
        }
        if (*(_DWORD *)(a4 + 96) <= (v35 + 1))
          v52 = v35 + 1;
        else
          v52 = *(_DWORD *)(a4 + 96);
        while (1)
        {
          v42 = (v35 + 1);
          if (v52 - 1 == (_DWORD)v35)
            break;
          LODWORD(v35) = v35 + 1;
          v53 = v42;
          if ((*(_DWORD *)(*(_QWORD *)(a4 + 80) + 32 * v42 + 8) & 0x80000000) != 0)
            goto LABEL_69;
        }
        v53 = v52;
LABEL_69:
        LODWORD(v35) = v53;
      }
      while ((_DWORD)v34 != v53);
    }
    if (*(_QWORD *)&v168[1])
    {
      v54 = (uint64_t *)v169;
      v55 = 8 * *(_QWORD *)&v168[1];
      do
      {
        v56 = *v54;
        *(_QWORD *)v181 = v56;
        if (v56)
          v57 = (id)(v56 + 8);
        if (v178)
        {
          v58 = *(_QWORD *)v180 + 72 * v178 - 72;
        }
        else
        {
          buf[0] = 0;
          *(_QWORD *)&buf[8] = v9;
          *(_QWORD *)&buf[16] = 0;
          *(_DWORD *)&buf[24] = 0;
          buf[28] = 0;
          *(_QWORD *)&v185 = 0;
          *(_QWORD *)&v184 = 0;
          v183 = 0uLL;
          DWORD2(v184) = 0;
          re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v176, (uint64_t)buf);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v183);
          v59 = *(_QWORD *)v180 + 72 * v178;
          *(_BYTE *)(v59 - 72) = 1;
          v58 = v59 - 72;
        }
        removeFromViewRecursive((re::SyncObject **)v181, v58, *(_QWORD *)(a4 + 56));
        if (*(_QWORD *)v181)

        ++v54;
        v55 -= 8;
      }
      while (v55);
    }
    *(_QWORD *)&v181[32] = 0;
    memset(v181, 0, 28);
    v60 = a2[1];
    if (v60)
    {
      v61 = *a2;
      v62 = *a2 + 72 * v60;
      do
      {
        if (*(_BYTE *)(v61 + 28))
          v63 = *(_QWORD *)(v61 + 8) == *(_QWORD *)(a4 + 56);
        else
          v63 = 0;
        if (!v63)
        {
          if (*(_BYTE *)(v61 + 28))
          {
            v64 = *(_QWORD *)(v61 + 48);
            if (v64)
            {
              v65 = *(uint64_t **)(v61 + 64);
              v66 = &v65[3 * v64];
              do
              {
                v67 = *v65;
                v68 = *(_QWORD *)(*v65 + 80);
                if (v68)
                {
                  do
                  {
                    v69 = v67;
                    v67 = v68;
                    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v69 + 88) + 16) + 73))
                      break;
                    v68 = *(_QWORD *)(v68 + 80);
                    v69 = v67;
                  }
                  while (v68);
                }
                else
                {
                  v69 = *v65;
                }
                if ((*(_BYTE *)(v69 + 170) || *(_BYTE *)(a1 + 88) || *(_BYTE *)(a1 + 89))
                  && entryIsAddable((re::SyncObject **)v65, (re::SyncObjectViewer *)a4))
                {
                  if (v178)
                  {
                    v70 = *(_QWORD *)v180 + 72 * v178 - 72;
                  }
                  else
                  {
                    buf[0] = 0;
                    *(_QWORD *)&buf[8] = v9;
                    *(_QWORD *)&buf[16] = 0;
                    *(_DWORD *)&buf[24] = 0;
                    buf[28] = 0;
                    *(_QWORD *)&v185 = 0;
                    *(_QWORD *)&v184 = 0;
                    v183 = 0uLL;
                    DWORD2(v184) = 0;
                    re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v176, (uint64_t)buf);
                    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v183);
                    v71 = *(_QWORD *)v180 + 72 * v178;
                    *(_BYTE *)(v71 - 72) = 1;
                    v70 = v71 - 72;
                  }
                  re::DynamicArray<re::internal::SyncSnapshotEntry>::add((_QWORD *)(v70 + 32), v65);
                }
                v65 += 3;
              }
              while (v65 != v66);
            }
          }
          else
          {
            *(_QWORD *)buf = v61;
            re::DynamicArray<re::SyncCommit const*>::add(v181, buf);
          }
        }
        v61 += 72;
      }
      while (v61 != v62);
      if (*(_QWORD *)&v181[16])
      {
        v72 = *(_QWORD *)&v181[32];
        v73 = *(_QWORD *)&v181[32] + 8 * *(_QWORD *)&v181[16];
        do
        {
          v74 = *(_QWORD *)(*(_QWORD *)v72 + 48);
          if (v74)
          {
            v75 = *(uint64_t **)(*(_QWORD *)v72 + 64);
            v76 = &v75[3 * v74];
            do
            {
              v77 = *v75;
              v78 = *(_QWORD *)(*v75 + 80);
              if (v78)
              {
                do
                {
                  v79 = v77;
                  v77 = v78;
                  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v79 + 88) + 16) + 73))
                    break;
                  v78 = *(_QWORD *)(v78 + 80);
                  v79 = v77;
                }
                while (v78);
              }
              else
              {
                v79 = *v75;
              }
              if ((*(_BYTE *)(v79 + 170) || *(_BYTE *)(a1 + 88) || *(_BYTE *)(a1 + 89))
                && entryIsAddable((re::SyncObject **)v75, (re::SyncObjectViewer *)a4))
              {
                if (v178)
                {
                  v80 = *(_QWORD *)v180 + 72 * v178 - 72;
                }
                else
                {
                  buf[0] = 0;
                  *(_QWORD *)&buf[8] = v9;
                  *(_QWORD *)&buf[16] = 0;
                  *(_DWORD *)&buf[24] = 0;
                  buf[28] = 0;
                  *(_QWORD *)&v185 = 0;
                  *(_QWORD *)&v184 = 0;
                  v183 = 0uLL;
                  DWORD2(v184) = 0;
                  re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v176, (uint64_t)buf);
                  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v183);
                  v81 = *(_QWORD *)v180 + 72 * v178;
                  *(_BYTE *)(v81 - 72) = 1;
                  v80 = v81 - 72;
                }
                re::DynamicArray<re::internal::SyncSnapshotEntry>::add((_QWORD *)(v80 + 32), v75);
              }
              v75 += 3;
            }
            while (v75 != v76);
          }
          v72 += 8;
        }
        while (v72 != v73);
      }
    }
    if (*(_QWORD *)v181 && *(_QWORD *)&v181[32])
      (*(void (**)(void))(**(_QWORD **)v181 + 40))();
    if (*(_QWORD *)&v168[0] && (_QWORD)v169)
      (*(void (**)(void))(**(_QWORD **)&v168[0] + 40))();
    re::SyncCommitDump::log(*(re **)v180, v178, "SendCommit");
    if (*(_BYTE *)(a1 + 90))
    {
      if (v178)
      {
        v82 = *(re **)v180;
        v83 = *(_QWORD *)v180 + 72 * v178;
        v84 = 1;
        do
        {
          v85 = *((_QWORD *)v82 + 6);
          if (v85)
          {
            v86 = 24 * v85;
            v87 = (_BYTE *)(*((_QWORD *)v82 + 8) + 16);
            do
            {
              v88 = (uint64_t *)(v87 - 16);
              if ((*v87 & 2) != 0)
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(a1 + 96, v88, v87);
              }
              else
              {
                v89 = (_BYTE *)re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(a1 + 96, v88, v87);
                if ((*v89 & 2) != 0)
                  *v89 = *v87;
              }
              v87 += 24;
              v86 -= 24;
            }
            while (v86);
            v84 = 0;
          }
          v82 = (re *)((char *)v82 + 72);
        }
        while (v82 != (re *)v83);
      }
      else
      {
        v84 = 1;
      }
      if (std::chrono::steady_clock::now().__d_.__rep_ >= *(_QWORD *)(a1 + 144) && (v84 & 1) == 0)
      {
        v94.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        *(_QWORD *)(a1 + 144) = v94.__d_.__rep_ + 5000000000;
        LODWORD(v183) = 0;
        memset(buf, 0, sizeof(buf));
        *(_QWORD *)((char *)&v183 + 4) = 0x7FFFFFFFLL;
        if (v178)
        {
          v95 = *(re **)v180;
          v96 = *(_QWORD *)v180 + 72 * v178;
          do
          {
            v97 = *((_QWORD *)v95 + 6);
            if (v97)
            {
              v98 = (uint64_t *)*((_QWORD *)v95 + 8);
              v99 = 24 * v97;
              do
              {
                v100 = *v98;
                v98 += 3;
                v94.__d_.__rep_ = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)buf, (re::DynamicString *)(*(_QWORD *)(*(_QWORD *)(v100 + 88) + 16) + 40));
                v99 -= 24;
              }
              while (v99);
            }
            v95 = (re *)((char *)v95 + 72);
          }
          while (v95 != (re *)v96);
        }
        memset((char *)v168 + 8, 0, 24);
        re::DynamicString::setCapacity(v168, 0);
        v101 = v183;
        if ((_DWORD)v183)
        {
          v102 = 0;
          v103 = (int *)(*(_QWORD *)&buf[16] + 8);
          while (1)
          {
            v104 = *v103;
            v103 += 12;
            if (v104 < 0)
              break;
            if (v183 == ++v102)
            {
              LODWORD(v102) = v183;
              break;
            }
          }
        }
        else
        {
          LODWORD(v102) = 0;
        }
        if ((_DWORD)v183 != (_DWORD)v102)
        {
          v105 = v102;
          v106 = *(_QWORD *)&buf[16];
          do
          {
            v107 = v106 + 48 * v105;
            v108 = *(_QWORD *)(v107 + 24);
            v109 = *(const char **)(v107 + 32);
            v110 = (const char *)(v107 + 25);
            v111 = (v108 & 1) == 0;
            if ((v108 & 1) != 0)
              v112 = v109;
            else
              v112 = v110;
            v113 = v108 >> 1;
            v114 = v108 >> 1;
            if (v111)
              v115 = v114;
            else
              v115 = v113;
            re::DynamicString::append((re::DynamicString *)v168, v112, v115);
            re::DynamicString::append((re::DynamicString *)v168, " ", 1uLL);
            v106 = *(_QWORD *)&buf[16];
            if (v183 <= (int)v102 + 1)
              v116 = v102 + 1;
            else
              v116 = v183;
            v117 = v102;
            while (1)
            {
              v105 = (v117 + 1);
              if (v116 - 1 == v117)
                break;
              ++v117;
              LODWORD(v102) = v105;
              if ((*(_DWORD *)(*(_QWORD *)&buf[16] + 48 * v105 + 8) & 0x80000000) != 0)
                goto LABEL_181;
            }
            LODWORD(v102) = v116;
LABEL_181:
            ;
          }
          while (v101 != (_DWORD)v102);
        }
        v118 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
        if (v118)
          v119 = v118 - 8;
        else
          v119 = 0;
        v120 = v119 + 8;
        (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v119 + 32))(v181);
        v121 = *(NSObject **)(*(_QWORD *)v181 + 3272);

        *(_QWORD *)v181 = 0;
        if (os_log_type_enabled(v121, OS_LOG_TYPE_INFO))
        {
          v123 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
          if (v123)
            v124 = v123 - 8;
          else
            v124 = 0;
          (*(void (**)(re::Session **__return_ptr, char *))(*(_QWORD *)v124 + 32))(&v175, v124);
          v125 = re::Session::peerID(v175);
          v126 = *(_QWORD *)(a1 + 40);
          v127 = *(_QWORD *)(v126 + 32);
          if (v127)
            v128 = (re::Transport *)(v127 - 8);
          else
            v128 = 0;
          re::Transport::connectionAddress(v128, *(_QWORD *)(v126 + 40), (re::DynamicString *)&v172);
          if ((v173 & 1) != 0)
            v129 = *(_BYTE **)&v174[7];
          else
            v129 = v174;
          if ((BYTE8(v168[0]) & 1) != 0)
            v130 = *(char **)&v168[1];
          else
            v130 = (char *)v168 + 9;
          *(_DWORD *)v181 = 134218498;
          *(_QWORD *)&v181[4] = v125;
          *(_WORD *)&v181[12] = 2080;
          *(_QWORD *)&v181[14] = v129;
          *(_WORD *)&v181[22] = 2080;
          *(_QWORD *)&v181[24] = v130;
          _os_log_impl(&dword_21C69B000, v121, OS_LOG_TYPE_INFO, "Sending sync data on paused connection to %llx ('%s'): %s", v181, 0x20u);
          if (v172 && (v173 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v172 + 40))();
          if (v175)
          {

            v175 = 0;
          }

        }
        if (*(_QWORD *)&v168[0])
        {
          if ((BYTE8(v168[0]) & 1) != 0)
            v122 = (*(double (**)(void))(**(_QWORD **)&v168[0] + 40))();
        }
        re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)buf, v122);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 124))
      {
        v90 = *(unsigned int *)(a4 + 96);
        if ((_DWORD)v90)
        {
          v91 = 0;
          v92 = (int *)(*(_QWORD *)(a4 + 80) + 8);
          while (1)
          {
            v93 = *v92;
            v92 += 8;
            if (v93 < 0)
              break;
            if (v90 == ++v91)
            {
              LODWORD(v91) = *(_DWORD *)(a4 + 96);
              break;
            }
          }
        }
        else
        {
          LODWORD(v91) = 0;
        }
        if ((_DWORD)v90 != (_DWORD)v91)
        {
          v131 = v91;
          do
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(a1 + 96, (uint64_t *)(*(_QWORD *)(a4 + 80) + 32 * v131 + 16));
            if (*(_DWORD *)(a4 + 96) <= (v91 + 1))
              v132 = v91 + 1;
            else
              v132 = *(_DWORD *)(a4 + 96);
            v133 = v91;
            while (1)
            {
              v131 = (v133 + 1);
              if (v132 - 1 == v133)
                break;
              ++v133;
              LODWORD(v91) = v131;
              if ((*(_DWORD *)(*(_QWORD *)(a4 + 80) + 32 * v131 + 8) & 0x80000000) != 0)
                goto LABEL_219;
            }
            LODWORD(v91) = v132;
LABEL_219:
            ;
          }
          while ((_DWORD)v90 != (_DWORD)v91);
        }
        v171 = 0;
        v169 = 0u;
        v170 = 0u;
        memset(v168, 0, sizeof(v168));
        LOBYTE(v168[0]) = 1;
        v134 = *(unsigned int *)(a1 + 128);
        if ((_DWORD)v134)
        {
          v135 = 0;
          v136 = (int *)(*(_QWORD *)(a1 + 112) + 8);
          while (1)
          {
            v137 = *v136;
            v136 += 8;
            if (v137 < 0)
              break;
            if (v134 == ++v135)
            {
              LODWORD(v135) = *(_DWORD *)(a1 + 128);
              break;
            }
          }
        }
        else
        {
          LODWORD(v135) = 0;
        }
        if ((_DWORD)v134 != (_DWORD)v135)
        {
          v138 = v135;
          do
          {
            v139 = *(_QWORD *)(a1 + 112) + 32 * v138;
            v142 = *(_QWORD *)(v139 + 16);
            v141 = v139 + 16;
            v140 = v142;
            *(_QWORD *)buf = v142;
            if (v142)
              v143 = (id)(v140 + 8);
            *(_QWORD *)&buf[8] = re::SyncObject::latestStateHandle(*(re::SyncObject **)v141);
            buf[16] = *(_BYTE *)(v141 + 8);
            re::DynamicArray<re::internal::SyncSnapshotEntry>::add(&v169, (uint64_t)buf);
            if (*(_QWORD *)buf)

            if (*(_DWORD *)(a1 + 128) <= (v135 + 1))
              v144 = v135 + 1;
            else
              v144 = *(_DWORD *)(a1 + 128);
            while (1)
            {
              v138 = (v135 + 1);
              if (v144 - 1 == (_DWORD)v135)
                break;
              LODWORD(v135) = v135 + 1;
              v145 = v138;
              if ((*(_DWORD *)(*(_QWORD *)(a1 + 112) + 32 * v138 + 8) & 0x80000000) != 0)
                goto LABEL_239;
            }
            v145 = v144;
LABEL_239:
            LODWORD(v135) = v145;
          }
          while ((_DWORD)v134 != v145);
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(a1 + 96);
        v146 = v178;
        if (v178 == -1)
        {
          v172 = 0;
          v184 = 0u;
          v185 = 0u;
          v183 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v181 = 136315906;
          *(_QWORD *)&v181[4] = "insert";
          *(_WORD *)&v181[12] = 1024;
          *(_DWORD *)&v181[14] = 887;
          *(_WORD *)&v181[18] = 2048;
          *(_QWORD *)&v181[20] = 0;
          *(_WORD *)&v181[28] = 2048;
          *(_QWORD *)&v181[30] = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        if (v178 >= v177)
        {
          re::DynamicArray<re::SyncCommit>::growCapacity(&v176, v178 + 1);
          v146 = v178;
        }
        v147 = *(re **)v180;
        v148 = (_OWORD *)(*(_QWORD *)v180 + 72 * v146);
        if (v146)
        {
          re::SyncCommit::SyncCommit((uint64_t)v148, *(_QWORD *)v180 + 72 * v146 - 72);
          v149 = *(re **)v180;
          if (*(_QWORD *)v180 + 72 * v178 - 72 != *(_QWORD *)v180)
          {
            v150 = 72 * v178;
            do
            {
              v151 = (char *)v149 + v150;
              *(_OWORD *)(v151 - 72) = *(_OWORD *)((char *)v149 + v150 - 144);
              *(_OWORD *)(v151 - 59) = *(_OWORD *)((char *)v149 + v150 - 131);
              re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v149 + v150 - 40, (uint64_t *)((char *)v149 + v150 - 112));
              v150 -= 72;
            }
            while (v150 != 72);
            v149 = *(re **)v180;
          }
          v152 = v168[0];
          *(_OWORD *)((char *)v149 + 13) = *(_OWORD *)((char *)v168 + 13);
          *(_OWORD *)v149 = v152;
          re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v149 + 32, (uint64_t *)&v169);
        }
        else
        {
          v153 = v168[0];
          *(_OWORD *)((char *)v148 + 13) = *(_OWORD *)((char *)v168 + 13);
          *v148 = v153;
          *((_QWORD *)v147 + 8) = 0;
          *((_QWORD *)v147 + 5) = 0;
          *((_QWORD *)v147 + 6) = 0;
          *((_QWORD *)v147 + 4) = 0;
          *((_DWORD *)v147 + 14) = 0;
          *((_OWORD *)v147 + 2) = v169;
          *((_QWORD *)v147 + 6) = v170;
          v169 = 0uLL;
          *(_QWORD *)&v170 = 0;
          *((_QWORD *)v147 + 8) = v171;
          v171 = 0;
          ++DWORD2(v170);
          ++*((_DWORD *)v147 + 14);
        }
        ++v178;
        ++v179;
        re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v169);
      }
      v154 = *(_QWORD *)(a1 + 40) + 24;
      *(_DWORD *)&buf[16] = 0;
      buf[20] = 0;
      *(_QWORD *)&buf[24] = 0;
      *(_QWORD *)&v183 = 0;
      *(_QWORD *)buf = &off_24E071758;
      *(_QWORD *)&buf[8] = 0;
      *((_QWORD *)&v183 + 1) = v154;
      *(_QWORD *)&v184 = 0;
      v155 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)&v168[0] = *(_QWORD *)(a1 + 56);
      *((_QWORD *)&v168[0] + 1) = v155;
      LOBYTE(v168[1]) = 0;
      if (v178)
      {
        v156 = *(re **)v180;
        v157 = 72 * v178;
        do
        {
          re::SyncPacker::packCommit(v168, (unsigned __int8 *)v156, (re::BitWriter *)buf, a5, 0);
          v156 = (re *)((char *)v156 + 72);
          v157 -= 72;
        }
        while (v157);
        v158 = *(_DWORD *)&buf[24];
        if (*(_DWORD *)&buf[28])
          v158 = *(_DWORD *)&buf[24] + 1;
        if (v158)
        {
          v159 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)(v184 + 24) = v158;
          *(_QWORD *)&buf[24] = 0;
          *(_QWORD *)&v183 = 0;
          *(_QWORD *)&buf[8] = 0;
          *(_DWORD *)&buf[16] = 0;
          *(_QWORD *)&v184 = 0;
          (*(void (**)(uint64_t))(*(_QWORD *)v159 + 48))(v159);
        }
      }
      if (*(_QWORD *)(a1 + 24) && v178)
      {
        v160 = *(re **)v180;
        v161 = *(_QWORD *)v180 + 72 * v178;
        do
        {
          v162 = *((_QWORD *)v160 + 6);
          if (v162)
          {
            v163 = *((_QWORD *)v160 + 8);
            v164 = 24 * v162;
            do
            {
              v165 = *(_QWORD *)(a1 + 24);
              if ((*(_BYTE *)(v163 + 16) & 2) != 0)
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v165 + 24, (uint64_t *)v163);
              else
                re::SyncAckedStateBuffer::addAcked(v165, (uint64_t *)v163, *(_QWORD *)(v163 + 8), *(unsigned __int16 *)(*(_QWORD *)v163 + 176));
              v163 += 24;
              v164 -= 24;
            }
            while (v164);
          }
          v160 = (re *)((char *)v160 + 72);
        }
        while (v160 != (re *)v161);
      }
      if ((_QWORD)v184)
        (*(void (**)(_QWORD))(**((_QWORD **)&v183 + 1) + 24))(*((_QWORD *)&v183 + 1));
    }
    re::DynamicArray<re::SyncCommit>::deinit((uint64_t)&v176);
  }
  else
  {
    v38 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
    if (v38)
      v39 = v38 - 8;
    else
      v39 = 0;
    v40 = v39 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v39 + 32))(buf);
    v41 = *(NSObject **)(*(_QWORD *)buf + 3272);

    *(_QWORD *)buf = 0;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v41, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to send.", buf, 2u);
    }
  }
}

BOOL re::SyncReliableOrderedUnicast::receive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char *WeakRetained;
  __int16 v12;
  char *v13;
  unsigned int v14;
  uint64_t v15;
  int *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  re::Transport *v20;
  char *v21;
  char *v22;
  void *v23;
  NSObject *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  void *v36;
  re::SyncObjectStore *v37;
  re::SyncObject **v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  id v42;
  void *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  BOOL v47;
  re *v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  _BYTE *v52;
  _BOOL8 result;
  char *v54;
  char *v55;
  void *v56;
  NSObject *v57;
  uint64_t v58;
  uint64_t v59;
  int v61;
  char v62[8];
  uint64_t v63;
  _QWORD v64[2];
  _QWORD v65[2];
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint8_t v69[8];
  char *v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  __int16 v81;
  uint64_t v82;
  int v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  _BYTE v87[12];
  __int16 v88;
  _BYTE *v89;
  _BYTE buf[24];
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 40);
  if (v4 && *(_QWORD *)(a1 + 56))
  {
    if (*(_BYTE *)(a1 + 91))
    {
      *(_BYTE *)(a1 + 91) = 0;
      v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 56))(v4);
      if (v6)
      {
        v7 = v6;
        v59 = a2;
        while (1)
        {
          v8 = *(_QWORD *)(v7 + 16);
          v58 = v7;
          v9 = *(_DWORD *)(v7 + 24);
          v82 = v8;
          v83 = v9;
          v84 = 0;
          v85 = 0;
          v86 = 0;
          while (v83 != (_DWORD)v85)
          {
            v10 = *(_QWORD *)(a1 + 56);
            WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 80));
            v12 = *(_WORD *)(a1 + 88);
            v13 = WeakRetained - 8;
            if (!WeakRetained)
              v13 = 0;
            *(_QWORD *)v69 = v10;
            v70 = v13;
            v71 = *(_OWORD *)(a1 + 64);
            v72 = 0u;
            v73 = 0u;
            v74 = 0;
            v75 = 0x7FFFFFFFLL;
            v80 = 0;
            v77 = 0;
            v78 = 0;
            v76 = 0;
            v79 = 0;
            v81 = v12;
            if (WeakRetained)

            v62[0] = 0;
            v68 = 0;
            v65[1] = 0;
            v66 = 0;
            v65[0] = 0;
            v67 = 0;
            v63 = 0;
            v64[0] = 0;
            *(_QWORD *)((char *)v64 + 5) = 0;
            v61 = re::SyncUnpacker::unpackCommit((uint64_t **)v69, (uint64_t)&v82, (uint64_t)v62, a2);
            if (!v61)
            {
              v18 = *(_QWORD *)(a1 + 40);
              v19 = *(_QWORD *)(v18 + 32);
              if (v19)
                v20 = (re::Transport *)(v19 - 8);
              else
                v20 = 0;
              re::Transport::connectionAddress(v20, *(_QWORD *)(v18 + 40), (re::DynamicString *)buf);
              v21 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
              if (v21)
                v22 = v21 - 8;
              else
                v22 = 0;
              v23 = v22 + 8;
              (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)v22 + 32))(v87);
              v24 = *(NSObject **)(*(_QWORD *)v87 + 3272);

              *(_QWORD *)v87 = 0;
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              {
                v51 = *(_QWORD *)(a1 + 64);
                v52 = &buf[9];
                if ((buf[8] & 1) != 0)
                  v52 = *(_BYTE **)&buf[16];
                *(_DWORD *)v87 = 134218242;
                *(_QWORD *)&v87[4] = v51;
                v88 = 2082;
                v89 = v52;
                _os_log_error_impl(&dword_21C69B000, v24, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)", v87, 0x16u);
              }
              (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 40) + 40))(*(_QWORD *)(a1 + 40), v58);
              if (*(_QWORD *)buf && (buf[8] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)buf + 40))();
              goto LABEL_41;
            }
            v14 = v74;
            if (v74)
            {
              v15 = 0;
              v16 = (int *)(v73 + 8);
              while (1)
              {
                v17 = *v16;
                v16 += 10;
                if (v17 < 0)
                  break;
                if (v74 == ++v15)
                {
                  LODWORD(v15) = v74;
                  break;
                }
              }
            }
            else
            {
              LODWORD(v15) = 0;
            }
            if (v74 != (_DWORD)v15)
            {
              v30 = v15;
              v31 = v73;
              while (1)
              {
                v32 = v31 + 40 * v30;
                v33 = *(_QWORD *)(v32 + 24);
                v34 = *(_QWORD *)(v32 + 32);
                v35 = (char *)objc_loadWeakRetained((id *)(a1 + 80));
                v36 = v35;
                if (v35)
                  v37 = (re::SyncObjectStore *)(v35 - 8);
                else
                  v37 = 0;
                re::SyncObjectStore::findObject(v37, v33, v34, (re::SyncObjectTypedStore ***)v87);
                if (v36)

                v38 = (re::SyncObject **)(v32 + 16);
                v39 = *(_QWORD *)v87;
                if (*(_QWORD *)v87)
                  break;
                v42 = objc_loadWeakRetained((id *)(a1 + 80));
                if (v42)
                {
                  v43 = v42;
                  v44 = (char *)objc_loadWeakRetained((id *)(a1 + 80));
                  v45 = v44 - 8;
                  if (!v44)
                    v45 = 0;
                  v46 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*v38 + 11) + 16) + 32);
                  *(_QWORD *)buf = *((_QWORD *)*v38 + 3);
                  *(_QWORD *)&buf[8] = v46;
                  *(_QWORD *)&buf[16] = 0;
                  v47 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v45 + 600), (uint64_t *)buf);
                  if (v44)

                  if (!v47)
                  {
                    v49 = *re::networkLogObjects(v48);
                    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
                    {
                      v50 = *((_QWORD *)*v38 + 3);
                      *(_DWORD *)buf = 134218240;
                      *(_QWORD *)&buf[4] = v50;
                      *(_WORD *)&buf[12] = 2048;
                      *(_QWORD *)&buf[14] = v34;
                      _os_log_error_impl(&dword_21C69B000, v49, OS_LOG_TYPE_ERROR, "BindFailure: Object %llu with parent %llu", buf, 0x16u);
                    }
                  }
                  v39 = *(_QWORD *)v87;
                  if (*(_QWORD *)v87)
                    goto LABEL_55;
                }
LABEL_56:
                v31 = v73;
                if (v74 <= (int)v15 + 1)
                  v40 = v15 + 1;
                else
                  v40 = v74;
                while (1)
                {
                  v30 = (v15 + 1);
                  if (v40 - 1 == (_DWORD)v15)
                    break;
                  LODWORD(v15) = v15 + 1;
                  v41 = v30;
                  if ((*(_DWORD *)(v73 + 40 * v30 + 8) & 0x80000000) != 0)
                    goto LABEL_63;
                }
                v41 = v40;
LABEL_63:
                LODWORD(v15) = v41;
                if (v14 == v41)
                  goto LABEL_30;
              }
              re::SyncObject::bindWithParent(*v38, *(re::SyncObject **)v87);
LABEL_55:

              goto LABEL_56;
            }
LABEL_30:
            if (v66)
            {
              v25 = (_BYTE *)(v68 + 16);
              v26 = 24 * v66;
              do
              {
                v27 = *((_QWORD *)v25 - 2);
                if ((*v25 & 2) != 0 || (*(_BYTE *)(v27 + 128) & 4) != 0)
                  (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), *(_QWORD *)(v27 + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v27 + 88) + 16) + 32));
                v25 += 24;
                v26 -= 24;
              }
              while (v26);
            }
            if (*(_QWORD *)(a1 + 24) && v66)
            {
              v28 = (uint64_t *)v68;
              v29 = 24 * v66;
              do
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(*(_QWORD *)(a1 + 24) + 24, v28);
                v28 += 3;
                v29 -= 24;
              }
              while (v29);
            }
            re::SyncCommitDump::log((re *)v62, 1, "RecvCommit");
            a2 = v59;
            (*(void (**)(uint64_t, char *, uint64_t))(a3 + 16))(a3, v62, v59);
LABEL_41:
            re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v65);
            if (v76)
            {
              if (v80)
                (*(void (**)(void))(*(_QWORD *)v76 + 40))();
              v80 = 0;
              v77 = 0;
              v78 = 0;
              v76 = 0;
              ++v79;
            }
            re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)&v72);
            if (!v61)
              return 0;
          }
          (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 40) + 40))(*(_QWORD *)(a1 + 40), v58);
          v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 56))(*(_QWORD *)(a1 + 40));
          result = 1;
          if (!v7)
            return result;
        }
      }
    }
    return 1;
  }
  else
  {
    v54 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
    if (v54)
      v55 = v54 - 8;
    else
      v55 = 0;
    v56 = v55 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v55 + 32))(v69);
    v57 = *(NSObject **)(*(_QWORD *)v69 + 3272);

    *(_QWORD *)v69 = 0;
    result = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)v69 = 0;
      _os_log_error_impl(&dword_21C69B000, v57, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", v69, 2u);
      return 0;
    }
  }
  return result;
}

_DWORD *re::SyncReliableOrderedUnicast::sendOwnershipRequests(uint64_t a1, uint64_t a2)
{
  return re::MessageStreamer<re::SyncOwnershipRequest>::send(*(_DWORD **)(a1 + 48), *(re::SyncOwnershipRequest **)a2, *(_QWORD *)(a2 + 8));
}

uint64_t re::SyncReliableOrderedUnicast::receiveOwnershipRequests(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  _BYTE v9[24];
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 92))
    return 1;
  *(_BYTE *)(a1 + 92) = 0;
  v3 = *(_QWORD *)(a1 + 48);
  v10 = *(_QWORD *)(a2 + 24);
  v11 = 0;
  if (v9 != (_BYTE *)a2)
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      if (v5 >= 0x19)
      {
        if (v10)
          v6 = (_BYTE *)(*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v10 + 32))(v10, v5, 0);
        else
          v6 = 0;
      }
      else
      {
        v6 = v9;
      }
      v11 = v6;
      (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 24))(*(_QWORD *)(a2 + 32));
    }
  }
  v7 = re::MessageStreamer<re::SyncOwnershipRequest>::receive<re::Function<void ()(re::SyncOwnershipRequest const&)>>(v3, (uint64_t)v9);
  if (v11)
  {
    (**(void (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  }
  return v7;
}

uint64_t re::SyncReliableOrderedUnicast::pause(uint64_t this)
{
  *(_BYTE *)(this + 90) = 1;
  return this;
}

uint64_t re::SyncReliableOrderedUnicast::resume(uint64_t this)
{
  *(_BYTE *)(this + 90) = 0;
  return this;
}

void re::SyncReliableOrderedUnicast::~SyncReliableOrderedUnicast(re::SyncReliableOrderedUnicast *this)
{
  re::SyncReliableOrderedUnicast::~SyncReliableOrderedUnicast(this);
  JUMPOUT(0x220780CD0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 12);
  objc_destroyWeak((id *)this + 10);
  *((_QWORD *)this + 10) = 0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
  {

    *((_QWORD *)this + 7) = 0;
  }
  v3 = *((_QWORD *)this + 6);
  if (v3)
  {

    *((_QWORD *)this + 6) = 0;
  }
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {

    *((_QWORD *)this + 5) = 0;
  }
  objc_destroyWeak((id *)this + 4);
  *((_QWORD *)this + 4) = 0;
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

uint64_t RESyncParticipantListCount(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t RESyncParticipantListAtIndex(uint64_t result, unint64_t a2)
{
  unint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(result + 16);
    if (v2 >= a2)
    {
      if (v2 <= a2)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      return *(_QWORD *)(*(_QWORD *)(result + 32) + 8 * a2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t RESyncNetSessionCreate(_QWORD *a1)
{
  __int128 *v1;
  uint64_t *v2;
  uint64_t v3;
  re::Session *v4;
  NSObject *v6;
  const char *v7;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    v8 = 136315394;
    v9 = "RESyncNetSessionCreate";
    v10 = 2080;
    v11 = "configuration != __null";
    v7 = "%s: Invalid parameter not satisfying %s.";
LABEL_14:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v8, 0x16u);
    return 0;
  }
  v1 = (__int128 *)(a1 + 3);
  if (!a1[3])
  {
    v6 = *re::networkLogObjects((re *)a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    v8 = 136315394;
    v9 = "RESyncNetSessionCreate";
    v10 = 2080;
    v11 = "Use RESyncNetSessionConfigurationSetTransportQueue() to configure transport queue.";
    v7 = "%s: %s";
    goto LABEL_14;
  }
  if (!a1[11])
  {
    v6 = *re::networkLogObjects((re *)a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    v8 = 136315394;
    v9 = "RESyncNetSessionCreate";
    v10 = 2080;
    v11 = "Use RESyncNetSessionConfigurationSetDiscoveryView() to configure discovery view.";
    v7 = "%s: %s";
    goto LABEL_14;
  }
  v2 = re::globalAllocators((re *)a1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 7656, 8);
  bzero((void *)v3, 0x1DE8uLL);
  v4 = re::Session::Session((re::Session *)v3);
  if (!re::Session::init((uint64_t)v4, v1))
  {

    return 0;
  }
  return v3;
}

uint64_t RESyncNetSessionConfigurationSetTransportQueue(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 24) = a2;
  return result;
}

uint64_t RESyncNetSessionShutdown(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
}

BOOL RESyncNetSessionIsInitialized(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 2272) != 0;
  return result;
}

BOOL RESyncNetSessionIsActive(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 3264) == 2;
  return result;
}

re::Session *RESyncNetSessionPeerID(re::Session *result)
{
  if (result)
    return (re::Session *)re::Session::peerID(result);
  return result;
}

uint64_t RESyncNetSessionLeader(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  id v7;

  if (!a1)
    return 0;
  v1 = a1[392];
  if (!v1)
    return 0;
  v2 = a1[287];
  if (!v2)
    return 0;
  v3 = (uint64_t *)a1[289];
  v4 = 8 * v2;
  while (1)
  {
    v5 = *v3;
    if (*(_QWORD *)(*v3 + 24) == v1)
      break;
    ++v3;
    v4 -= 8;
    if (!v4)
      return 0;
  }
  v7 = (id)(v5 + 8);

  return v5;
}

uint64_t RESyncNetSessionGetDiscoveryView(uint64_t a1)
{
  uint64_t v1;
  id v2;

  if (!a1)
    return 0;
  v1 = *(_QWORD *)(a1 + 2208);
  if (v1)
  {
    v2 = (id)(v1 + 8);

  }
  return v1;
}

double RESyncNetSessionObserverCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 144, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E072238;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 100) = 0u;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(v2 + 116) = 0x7FFFFFFFLL;
  *(_QWORD *)(v2 + 128) = 0;
  *(_QWORD *)(v2 + 136) = 0;
  return result;
}

double RESyncNetSessionAddObserver(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  double result;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (a1 && a2)
  {
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 30, (uint64_t)&v16);
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 52, (uint64_t)&v16);
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 74, (uint64_t)&v16);
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 96, (uint64_t)&v16);
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 426, (uint64_t)&v16);
    v4 = *(unsigned int *)(a2 + 112);
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = (int *)(*(_QWORD *)(a2 + 96) + 8);
      while (1)
      {
        v7 = *v6;
        v6 += 6;
        if (v7 < 0)
          break;
        if (v4 == ++v5)
        {
          LODWORD(v5) = *(_DWORD *)(a2 + 112);
          break;
        }
      }
    }
    else
    {
      LODWORD(v5) = 0;
    }
    if ((_DWORD)v4 != (_DWORD)v5)
    {
      v8 = v5;
      do
      {
        v9 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 96) + 24 * v8 + 12);
        *(_QWORD *)&v14 = a2;
        *(_QWORD *)&v15 = 0;
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)&a1[22 * v9 + 140], &v14, (uint64_t)&v16);
        if (!(_BYTE)v16)
        {
          if (a1[22 * v9 + 160])
          {
            LOBYTE(v16) = 1;
            v17 = v14;
            v18 = v15;
            re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)&a1[22 * v9 + 150], (uint64_t)&v16);
          }
          else
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)&a1[22 * v9 + 140], (uint64_t)&v14);
          }
        }
        v10 = *(_DWORD *)(a2 + 112);
        if (v10 <= (int)v5 + 1)
          v11 = v5 + 1;
        else
          v11 = *(_DWORD *)(a2 + 112);
        while (1)
        {
          v8 = (v5 + 1);
          if (v11 - 1 == (_DWORD)v5)
            break;
          LODWORD(v5) = v5 + 1;
          v12 = v8;
          if ((*(_DWORD *)(*(_QWORD *)(a2 + 96) + 24 * v8 + 8) & 0x80000000) != 0)
            goto LABEL_22;
        }
        v12 = v11;
LABEL_22:
        LODWORD(v5) = v12;
      }
      while (v10 != v12);
    }
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 448, (uint64_t)&v16);
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 470, (uint64_t)&v16);
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 492, (uint64_t)&v16);
    v16 = a2;
    *((_QWORD *)&v17 + 1) = 0;
    return re::Event<re::Session>::addSubscription(a1 + 514, (uint64_t)&v16);
  }
  return result;
}

void RESyncNetSessionRemoveObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  unint64_t v19;
  __int128 *v20;
  __int128 v21;
  unint64_t v22;
  __int128 *v23;
  __int128 v24;
  unint64_t v25;
  __int128 *v26;
  __int128 v27;
  unint64_t v28;
  __int128 *v29;
  __int128 v30;
  _BYTE v31[8];
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (!a1 || !a2)
    return;
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 2056, a2);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1968, a2);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1880, a2);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1792, a2);
  v4 = *(unsigned int *)(a2 + 112);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a2 + 96) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 112);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 == (_DWORD)v5)
    goto LABEL_28;
  v8 = v5;
  do
  {
    v9 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 96) + 24 * v8 + 12);
    v10 = a1 + 88 * v9;
    if (!*(_QWORD *)(v10 + 576))
      goto LABEL_20;
    v11 = 0;
    v12 = (_QWORD *)(v10 + 560);
    v13 = a1 + 88 * v9;
    v14 = (_DWORD *)(v13 + 640);
    v15 = v13 + 600;
    do
    {
      v16 = v12[4] + 32 * v11;
      if (*(_QWORD *)v16 != a2)
        goto LABEL_16;
      if (*v14)
      {
        v31[0] = 0;
        v32 = *(_OWORD *)v16;
        v33 = *(_OWORD *)(v16 + 16);
        re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v15, (uint64_t)v31);
LABEL_16:
        ++v11;
        continue;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v12, v11);
    }
    while (v11 < v12[2]);
    LODWORD(v4) = *(_DWORD *)(a2 + 112);
LABEL_20:
    if (v4 <= (int)v5 + 1)
      v17 = v5 + 1;
    else
      v17 = v4;
    while (1)
    {
      v8 = (v5 + 1);
      if (v17 - 1 == (_DWORD)v5)
        break;
      LODWORD(v5) = v5 + 1;
      v18 = v8;
      if ((*(_DWORD *)(*(_QWORD *)(a2 + 96) + 24 * v8 + 8) & 0x80000000) != 0)
        goto LABEL_27;
    }
    v18 = v17;
LABEL_27:
    LODWORD(v5) = v18;
  }
  while ((_DWORD)v4 != v18);
LABEL_28:
  if (*(_QWORD *)(a1 + 400))
  {
    v19 = 0;
    do
    {
      v20 = (__int128 *)(*(_QWORD *)(a1 + 416) + 32 * v19);
      if (*(_QWORD *)v20 == a2)
      {
        if (!*(_DWORD *)(a1 + 464))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(a1 + 384), v19);
          continue;
        }
        v31[0] = 0;
        v21 = v20[1];
        v32 = *v20;
        v33 = v21;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 424), (uint64_t)v31);
      }
      ++v19;
    }
    while (v19 < *(_QWORD *)(a1 + 400));
  }
  if (*(_QWORD *)(a1 + 312))
  {
    v22 = 0;
    do
    {
      v23 = (__int128 *)(*(_QWORD *)(a1 + 328) + 32 * v22);
      if (*(_QWORD *)v23 == a2)
      {
        if (!*(_DWORD *)(a1 + 376))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(a1 + 296), v22);
          continue;
        }
        v31[0] = 0;
        v24 = v23[1];
        v32 = *v23;
        v33 = v24;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 336), (uint64_t)v31);
      }
      ++v22;
    }
    while (v22 < *(_QWORD *)(a1 + 312));
  }
  if (*(_QWORD *)(a1 + 224))
  {
    v25 = 0;
    do
    {
      v26 = (__int128 *)(*(_QWORD *)(a1 + 240) + 32 * v25);
      if (*(_QWORD *)v26 == a2)
      {
        if (!*(_DWORD *)(a1 + 288))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(a1 + 208), v25);
          continue;
        }
        v31[0] = 0;
        v27 = v26[1];
        v32 = *v26;
        v33 = v27;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 248), (uint64_t)v31);
      }
      ++v25;
    }
    while (v25 < *(_QWORD *)(a1 + 224));
  }
  if (*(_QWORD *)(a1 + 136))
  {
    v28 = 0;
    do
    {
      v29 = (__int128 *)(*(_QWORD *)(a1 + 152) + 32 * v28);
      if (*(_QWORD *)v29 == a2)
      {
        if (!*(_DWORD *)(a1 + 200))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(a1 + 120), v28);
          continue;
        }
        v31[0] = 0;
        v30 = v29[1];
        v32 = *v29;
        v33 = v30;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 160), (uint64_t)v31);
      }
      ++v28;
    }
    while (v28 < *(_QWORD *)(a1 + 136));
  }
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1704, a2);
}

void *RESyncNetSessionObserverOnStart(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 24));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

void *RESyncNetSessionObserverOnStop(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 32));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void *RESyncNetSessionObserverOnParticipantJoin(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 40));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void *RESyncNetSessionObserverOnParticipantLeave(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 48));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 48) = result;
  return result;
}

void RESyncNetSessionObserverOnReceiveUserData(uint64_t a1, const void *a2)
{
}

void `anonymous namespace'::SessionObserverProxy::setOnReceiveData(uint64_t a1, const void *a2, unsigned int a3)
{
  _QWORD *v6;
  const void **v7;
  void *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  char v15;

  v15 = a3;
  v6 = (_QWORD *)(a1 + 80);
  v7 = (const void **)re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::tryGet(a1 + 80, a3);
  if (v7)
    _Block_release(*v7);
  v8 = _Block_copy(a2);
  v14 = v8;
  v9 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a3) ^ ((0xBF58476D1CE4E5B9 * a3) >> 27));
  v10 = v9 ^ (v9 >> 31);
  if (!*v6)
  {
    LODWORD(v11) = 0;
    goto LABEL_10;
  }
  v11 = v10 % *(unsigned int *)(a1 + 104);
  v12 = *(unsigned int *)(*(_QWORD *)(a1 + 88) + 4 * v11);
  if ((_DWORD)v12 == 0x7FFFFFFF)
  {
LABEL_10:
    re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::addAsMove((uint64_t)v6, v11, v10, &v15, &v14);
    goto LABEL_11;
  }
  v13 = *(_QWORD *)(a1 + 96);
  while (*(unsigned __int8 *)(v13 + 24 * v12 + 12) != a3)
  {
    LODWORD(v12) = *(_DWORD *)(v13 + 24 * v12 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v12 == 0x7FFFFFFF)
      goto LABEL_10;
  }
  *(_QWORD *)(v13 + 24 * v12 + 16) = v8;
LABEL_11:
  ++*(_DWORD *)(a1 + 120);
}

void RESyncNetSessionObserverOnReceiveData(uint64_t a1, unsigned int a2, const void *a3)
{
}

void *RESyncNetSessionObserverOnLeaderChanged(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 56));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

void *RESyncNetSessionObserverOnConnectionConnected(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 64));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

void *RESyncNetSessionObserverOnConnectionDisconnected(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 72));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

void *RESyncNetSessionObserverOnPeerDidPause(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 128));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 128) = result;
  return result;
}

void *RESyncNetSessionObserverOnPeerDidResume(uint64_t a1, const void *a2)
{
  void *result;

  _Block_release(*(const void **)(a1 + 136));
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 136) = result;
  return result;
}

uint64_t RESyncNetSessionParticipantsCount(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    return v1;
  }
  return result;
}

uint64_t RESyncNetSessionGetParticipantAtIndex(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;

  if (result)
  {
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    if (v4 <= a2)
    {
      re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a2, v4);
      result = _os_crash();
      __break(1u);
    }
    else
    {
      return *(_QWORD *)(v3 + 8 * a2);
    }
  }
  return result;
}

uint64_t RESyncNetSessionGetParticipantWithIdentity(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  id v4;
  uint64_t v6;
  uint64_t v7;

  v2 = 0;
  if (a1 && a2)
  {
    v6 = a2;
    v4 = (id)(a2 + 8);
    re::Session::findParticipantWithIdentity(a1, &v6, &v7);
    v2 = v7;
    if (v7)
    {

      v7 = 0;
    }
    if (v6)

  }
  return v2;
}

uint64_t RESyncNetSessionGetParticipantWithPeerID(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  id v7;

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 2296);
  if (!v2)
    return 0;
  v3 = *(uint64_t **)(a1 + 2312);
  v4 = 8 * v2;
  while (1)
  {
    v5 = *v3;
    if (*(_QWORD *)(*v3 + 24) == a2)
      break;
    ++v3;
    v4 -= 8;
    if (!v4)
      return 0;
  }
  v7 = (id)(v5 + 8);

  return v5;
}

void RESyncNetSessionDropParticipant(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
      re::Transport::disconnect((re::Transport *)(a1 + 2320), *(_QWORD *)(a2 + 32), 1);
  }
}

_QWORD *RESyncNetSessionSetDisconnectTimeout(_QWORD *result, int a2)
{
  if (result)
    return re::Transport::setDisconnectTimeout((re::Transport *)(result + 290), a2);
  return result;
}

uint64_t RESyncNetSessionGetIsLocalPeer(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 72))(result);
  return result;
}

BOOL RESyncNetSessionGetIsLocal(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 2219) != 0;
  return result;
}

uint64_t RESyncNetSessionSetIsLocal(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 2219) = a2;
  return result;
}

uint64_t RESyncNetSessionSendData(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)result + 64))(result, a2, a3, a4, a5, 1, 0);
  return result;
}

uint64_t RESyncNetSessionSendDataUnreliableUnordered(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 64))(result, a2, a3, a4, a5, 1, 2);
  return result;
}

uint64_t RESyncNetSessionIncomingUpdate(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

uint64_t RESyncNetSessionOutgoingUpdate(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 56))(result);
  return result;
}

uint64_t RESyncNetSessionLastStatsAggregated@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  int v3;

  if (result)
  {
    v2 = result + 32 * ((*(_DWORD *)(result + 7408) - 1) & 0x7F);
    v3 = *(_DWORD *)(v2 + 3308);
    *(_DWORD *)a2 = *(_DWORD *)(v2 + 3304);
    *(_DWORD *)(a2 + 4) = v3;
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(v2 + 3312);
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  return result;
}

void RESyncNetSessionAveragedStatsAggregated(re::Session *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  __int128 v4;
  uint64_t v5;

  if (a1)
  {
    v4 = 0uLL;
    v5 = 0;
    re::Session::averagedStatsAggregated(a1, (uint64_t)&v4, a3);
    *(_OWORD *)a2 = v4;
    *(_QWORD *)(a2 + 16) = v5;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
}

re *RESyncNetSessionCopyLocalAddresses(re *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  re *v4;
  re *v5;
  uint64_t v6;
  char **v7;
  char *v8;
  re *v9;
  re *v10;
  uint64_t *v11;

  if (!a1)
    return 0;
  v1 = *((_QWORD *)a1 + 304);
  v2 = *((_QWORD *)a1 + 302);
  v3 = re::globalAllocators(a1);
  v4 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v3[2] + 32))(v3[2], 8 * v2, 0);
  v5 = v4;
  if (v2)
  {
    v6 = 0;
    v7 = (char **)(v1 + 16);
    do
    {
      if ((*(_BYTE *)(v7 - 1) & 1) != 0)
        v8 = *v7;
      else
        v8 = (char *)v7 - 7;
      *((_QWORD *)v4 + v6++) = v8;
      v7 += 4;
    }
    while (v2 != v6);
    v9 = RESyncAddressListCreate(v4, v2);
    v10 = v9;
    goto LABEL_11;
  }
  v9 = RESyncAddressListCreate(v4, 0);
  v10 = v9;
  if (v5)
  {
LABEL_11:
    v11 = re::globalAllocators(v9);
    (*(void (**)(uint64_t, re *))(*(_QWORD *)v11[2] + 40))(v11[2], v5);
  }
  return v10;
}

uint64_t RESyncParticipantGetIdentity(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 152);
  return result;
}

uint64_t RESyncParticipantGetPeerID(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t RESyncParticipantGetUserContext@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    *(_DWORD *)a2 = 0;
    v2 = *(_QWORD *)(result + 128);
    if (v2)
      v3 = *(_QWORD *)(result + 144);
    else
      v3 = 0;
    *(_QWORD *)(a2 + 8) = v3;
    *(_QWORD *)(a2 + 16) = v2;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  return result;
}

uint64_t RESyncParticipantGetAddress(uint64_t result)
{
  if (result)
  {
    if ((*(_BYTE *)(result + 48) & 1) != 0)
      return *(_QWORD *)(result + 56);
    else
      result += 49;
  }
  return result;
}

uint64_t RESyncParticipantHasForceAuthorityCapability(uint64_t result)
{
  if (result)
    return (*(unsigned __int8 *)(result + 72) >> 1) & 1;
  return result;
}

BOOL RESyncParticipantHasCapability(_BOOL8 result, int a2)
{
  if (result)
    return (a2 & ~*(_DWORD *)(result + 72)) == 0;
  return result;
}

uint64_t RESyncLeaderElectionCreateLowestPeerID(re *a1)
{
  uint64_t v2;

  re::make::shared::object<re::LeaderElectionLowestPeerID>(a1, &v2);
  return v2;
}

double RESyncNetSessionConfigurationCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 152, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_QWORD *)(v2 + 144) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E072280;
  v3 = MEMORY[0x24BDAC9B8];
  *(_QWORD *)(v2 + 24) = v3;
  *(_QWORD *)(v2 + 32) = 0x7B61A86B3;
  *(_QWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 48) = 0x61A800000000;
  *(_QWORD *)(v2 + 56) = 0;
  *(_BYTE *)(v2 + 64) = 0;
  *(_QWORD *)(v2 + 80) = 0;
  *(_QWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v2 + 72) = 0;
  *(_DWORD *)(v2 + 96) = 0;
  *(_DWORD *)(v2 + 100) = 16777473;
  *(_QWORD *)&result = 500;
  *(_QWORD *)(v2 + 104) = 500;
  *(_DWORD *)(v2 + 112) = 10485760;
  *(_WORD *)(v2 + 116) = 257;
  *(_DWORD *)(v2 + 120) = 10;
  *(_QWORD *)(v2 + 128) = 0;
  *(_QWORD *)(v2 + 136) = 0;
  *(_DWORD *)(v2 + 144) = 0;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetIsLeader(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 64) = a2;
  return result;
}

void RESyncNetSessionSetLeader(re::Session *this, uint64_t a2)
{
  if (this)
  {
    *((_QWORD *)this + 392) = a2;
    re::Session::onLeaderChange(this, a2);
  }
}

void RESyncNetSessionConfigurationSetAllowLeaderMigration(re *a1, char a2)
{
  uint64_t v3;
  uint64_t v4;

  if (a1)
  {
    if ((a2 & 1) != 0)
    {
      re::make::shared::object<re::LeaderElectionLowestPeerID>(a1, &v4);
      v3 = v4;
      RESyncNetSessionConfigurationSetLeaderElection(a1, v4);
      if (v3)

    }
    else
    {
      RESyncNetSessionConfigurationSetLeaderElection(a1, 0);
    }
  }
}

void RESyncNetSessionConfigurationSetLeaderElection(re *a1, uint64_t a2)
{
  uint64_t v2;
  id v4;
  uint64_t *v5;
  uint64_t v6;

  if (a1)
  {
    v2 = a2;
    if (a2)
    {
      v4 = (id)(a2 + 8);
    }
    else
    {
      v5 = re::globalAllocators(a1);
      v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 40, 8);
      *(_OWORD *)v2 = 0u;
      *(_OWORD *)(v2 + 16) = 0u;
      *(_QWORD *)(v2 + 32) = 0;
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
      *(_QWORD *)v2 = &off_24E0709E8;
    }
    v6 = *((_QWORD *)a1 + 7);
    *((_QWORD *)a1 + 7) = v2;
    if (v6)

  }
}

void RESyncNetSessionConfigurationSetLeaderElectionPolicy(re *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  if (a1)
  {
    if (a2 == 1)
    {
      re::make::shared::object<re::LeaderElectionLowestPeerID>(a1, &v4);
      v3 = v4;
      RESyncNetSessionConfigurationSetLeaderElection(a1, v4);
      if (v3)

    }
    else
    {
      RESyncNetSessionConfigurationSetLeaderElection(a1, 0);
    }
  }
}

uint64_t RESyncNetSessionConfigurationSetUserContext(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(result + 80) = v2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetAllowTimeSync(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 97) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetAuthorityPolicy(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 96) = a2;
  return result;
}

void RESyncNetSessionConfigurationSetDiscoveryView(uint64_t a1, uint64_t a2)
{
  id v4;
  uint64_t v5;

  if (a1)
  {
    if (a2)
      v4 = (id)(a2 + 8);
    v5 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = a2;
    if (v5)

  }
}

uint64_t RESyncNetSessionConfigurationSetIsPrivileged(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 98) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetUnreliableSyncEnabled(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 103) = a2 ^ 1;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetUnreliableResendTimeout(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 104) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetCompressionMethod(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 116) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetSyncDeltaCompression(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 117) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetInitTimeOutMs(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 48) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetHandshakeTimeOutMs(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 52) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetMaxHelloPacketsSendCount(uint64_t result, unsigned int a2)
{
  int v2;

  if (result)
  {
    if (a2 <= 1)
      v2 = 1;
    else
      v2 = a2;
    *(_DWORD *)(result + 120) = v2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetShutdownOnVersionMismatch(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 102) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetMaxUnreliablePacketSize(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 108) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetIsLocal(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 99) = a2;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetTransportIsThrottled(uint64_t result, char a2)
{
  if (result)
    *(_BYTE *)(result + 100) = a2;
  return result;
}

void RESyncNetSessionConfigurationSetTransportIsFragmented(uint64_t a1, char a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_BYTE *)(a1 + 101) = a2;
  }
  else
  {
    v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136315394;
      v4 = "RESyncNetSessionConfigurationSetTransportIsFragmented";
      v5 = 2080;
      v6 = "configuration != __null";
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncNetSessionPublishBandwidthEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _anonymous_namespace_ *v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  NSObject *v15;
  _OWORD v16[2];
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unint64_t v23;
  __int16 v24;
  unint64_t v25;
  uint8_t buf[32];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
LABEL_23:
    v15 = *re::networkLogObjects((re *)a1);
    v13 = 16;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "RESyncNetSessionPublishBandwidthEvent";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = "session != __null";
LABEL_27:
      _os_log_error_impl(&dword_21C69B000, v15, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
      return v13;
    }
    return v13;
  }
  if (a2)
  {
    v2 = a1;
    v3 = (_anonymous_namespace_ *)(a1 + 7432);
    v4 = *(_DWORD *)(a1 + 7512);
    *(_DWORD *)(a1 + 7512) = v4 + 1;
    if (*(_QWORD *)(a1 + 7448))
    {
      v5 = 0;
      do
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(v2 + 7464) + 32 * v5 + 24))(v2) == 1)
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, v5);
        else
          ++v5;
      }
      while (v5 < *(_QWORD *)(v2 + 7448));
      v4 = *(_DWORD *)(v2 + 7512) - 1;
    }
    *(_DWORD *)(v2 + 7512) = v4;
    if (v4)
      return 1;
    v6 = *(_QWORD *)(v2 + 7488);
    if (!v6)
      return 1;
    v7 = 0;
    v8 = 0;
    while (1)
    {
      v9 = *(_QWORD *)(v2 + 7488);
      if (v9 <= v8)
        break;
      v10 = *(_QWORD *)(v2 + 7504) + v7;
      v11 = *(_QWORD *)(v10 + 32);
      v12 = *(_OWORD *)(v10 + 16);
      v16[0] = *(_OWORD *)v10;
      v16[1] = v12;
      v17 = v11;
      if (LOBYTE(v16[0]))
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (_QWORD *)v16 + 1, (uint64_t)buf);
        if (!buf[0])
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v3, (uint64_t)v16 + 8);
      }
      else
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (_QWORD *)v16 + 1, (uint64_t)buf);
        if (buf[0])
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, *(unint64_t *)&buf[8]);
      }
      ++v8;
      v7 += 40;
      if (v6 == v8)
        return 1;
    }
    v28 = 0u;
    v29 = 0u;
    v27 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v18 = 136315906;
    v19 = "operator[]";
    v20 = 1024;
    v21 = 789;
    v22 = 2048;
    v23 = v8;
    v24 = 2048;
    v25 = v9;
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
    goto LABEL_23;
  }
  v15 = *re::networkLogObjects((re *)a1);
  v13 = 16;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "RESyncNetSessionPublishBandwidthEvent";
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = "bwEvent != __null";
    goto LABEL_27;
  }
  return v13;
}

uint64_t RESyncNetSessionSetCapabilitiesIsLeader(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 3280) = *(_DWORD *)(result + 3280) & 0xFFFFFFFE | a2;
  return result;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didStart(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didStop(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    (*(void (**)(void))(v1 + 16))();
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didJoin(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, a2, *a3);
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didLeave(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 48);
  if (v3)
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, a2, *a3);
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didChangeLeader(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didReceiveCustomData(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3;

  v3 = re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::tryGet(a1 + 80, a3);
  if (v3)
    (*(void (**)(void))(*(_QWORD *)v3 + 16))();
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didConnectConnection(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t v7;
  char v8;
  _BYTE v9[23];

  if (*((_QWORD *)this + 8))
  {
    re::Transport::connectionAddress((re::Session *)((char *)a2 + 2320), a3, (re::DynamicString *)&v7);
    if ((v8 & 1) != 0)
      v5 = *(_BYTE **)&v9[7];
    else
      v5 = v9;
    (*(void (**)(_QWORD, re::Session *, _BYTE *))(*((_QWORD *)this + 8) + 16))(*((_QWORD *)this + 8), a2, v5);
    if (v7 && (v8 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::didDisconnectConnection(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t v7;
  char v8;
  _BYTE v9[23];

  if (*((_QWORD *)this + 9))
  {
    re::Transport::connectionAddress((re::Session *)((char *)a2 + 2320), a3, (re::DynamicString *)&v7);
    if ((v8 & 1) != 0)
      v5 = *(_BYTE **)&v9[7];
    else
      v5 = v9;
    (*(void (**)(_QWORD, re::Session *, _BYTE *))(*((_QWORD *)this + 9) + 16))(*((_QWORD *)this + 9), a2, v5);
    if (v7 && (v8 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::peerDidPause(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 16);
  if (v2)
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  return 0;
}

uint64_t `anonymous namespace'::SessionObserverProxy::peerDidResume(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 17);
  if (v2)
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  return 0;
}

uint64_t re::Event<re::Session>::createSubscription<`anonymous namespace'::SessionObserverProxy>(`anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (`anonymous namespace'::SessionObserverProxy::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<`anonymous namespace'::SessionObserverProxy>(`anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (`anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<`anonymous namespace'::SessionObserverProxy>(`anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (`anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t *);
  _QWORD *v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  uint64_t v11;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *))a2[1];
  v4 = a2[2];
  v6 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *))(*v6 + v5);
  v7 = *a3;
  v11 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v9 = v5(v6, a1, &v11);
  if (v11)

  return v9;
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<`anonymous namespace'::SessionObserverProxy>(`anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (`anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v6;
  uint64_t (*v7)(_QWORD *, uint64_t, uint64_t *, _QWORD);
  _QWORD *v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  uint64_t v13;

  v7 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *, _QWORD))a2[1];
  v6 = a2[2];
  v8 = (_QWORD *)(*a2 + (v6 >> 1));
  if ((v6 & 1) != 0)
    v7 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *, _QWORD))(*v8 + v7);
  v9 = *a3;
  v13 = v9;
  if (v9)
    v10 = (id)(v9 + 8);
  v11 = v7(v8, a1, &v13, *a4);
  if (v13)

  return v11;
}

uint64_t re::Event<re::Session,unsigned long long>::createSubscription<`anonymous namespace'::SessionObserverProxy>(`anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (`anonymous namespace'::SessionObserverProxy::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::ChannelId,unsigned long long,void const*,unsigned int>::createSubscription<`anonymous namespace'::SessionObserverProxy>(`anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (`anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::ChannelId,unsigned long long,void const*,unsigned int))::{lambda(re::Session*,re::Event<re::Session,re::ChannelId,unsigned long long,void const*,unsigned int>::Subscription const&,re::ChannelId&&,unsigned long long &&,void const*&&,unsigned int &&)#1}::__invoke(uint64_t a1, _QWORD *a2, unsigned __int8 *a3, _QWORD *a4, _QWORD *a5, unsigned int *a6)
{
  uint64_t (*v7)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v8;
  _QWORD *v9;

  v7 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))a2[1];
  v8 = a2[2];
  v9 = (_QWORD *)(*a2 + (v8 >> 1));
  if ((v8 & 1) != 0)
    v7 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*v9 + v7);
  return v7(v9, a1, *a3, *a4, *a5, *a6);
}

uint64_t re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::tryGet(uint64_t a1, unsigned __int8 a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a2) ^ ((0xBF58476D1CE4E5B9 * a2) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(unsigned __int8 *)(v5 + 24 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 24 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(unsigned __int8 *)(v5 + 24 * v3 + 12) == a2)
        return v5 + 24 * v3 + 16;
    }
    return 0;
  }
  return v5 + 24 * v3 + 16;
}

void re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _BYTE *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  _BYTE v25[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v25, 0, 36);
          *(_QWORD *)&v25[36] = 0x7FFFFFFFLL;
          re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::init((uint64_t)v25, v13, v12);
          v15 = *(_OWORD *)v25;
          *(_OWORD *)v25 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v25[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v25[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v25[24];
          *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v25[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21 - 4, v21);
              v21 += 24;
              --v20;
            }
            while (v20);
          }
          re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)v25);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 24 * v9 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 24 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 24 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9) = a3;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 12) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

void re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

re::Session *re::Session::Session(re::Session *this)
{
  char *v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  _OWORD *v7;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E071E80;
  *((_QWORD *)this + 3) = &unk_24E071F18;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 46) = 0;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 58) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 35) = 0;
  *((_DWORD *)this + 72) = 0;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_DWORD *)this + 68) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_DWORD *)this + 80) = 0;
  *((_QWORD *)this + 39) = 0;
  *((_QWORD *)this + 46) = 0;
  *((_DWORD *)this + 94) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_DWORD *)this + 90) = 0;
  *((_QWORD *)this + 48) = 0;
  *((_QWORD *)this + 49) = 0;
  *((_DWORD *)this + 102) = 0;
  *((_QWORD *)this + 50) = 0;
  *((_QWORD *)this + 57) = 0;
  *((_DWORD *)this + 116) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 60) = 0;
  *((_DWORD *)this + 124) = 0;
  *((_QWORD *)this + 61) = 0;
  *((_QWORD *)this + 68) = 0;
  *((_DWORD *)this + 138) = 0;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  v2 = (char *)this + 1440;
  v3 = 560;
  *((_DWORD *)this + 134) = 0;
  do
  {
    v4 = (char *)this + v3;
    *(_QWORD *)v4 = 0;
    *((_QWORD *)v4 + 1) = 0;
    *((_DWORD *)v4 + 6) = 0;
    *((_QWORD *)v4 + 2) = 0;
    *((_QWORD *)v4 + 9) = 0;
    *((_DWORD *)v4 + 20) = 0;
    *((_OWORD *)v4 + 2) = 0uLL;
    *((_OWORD *)v4 + 3) = 0uLL;
    v3 += 88;
    *((_DWORD *)v4 + 16) = 0;
  }
  while (v4 + 88 != v2);
  *((_DWORD *)this + 366) = 0;
  *((_QWORD *)this + 182) = 0;
  *(_OWORD *)v2 = 0u;
  *((_QWORD *)this + 189) = 0;
  *((_DWORD *)this + 380) = 0;
  *((_OWORD *)this + 92) = 0u;
  *((_OWORD *)this + 93) = 0u;
  *((_DWORD *)this + 376) = 0;
  *((_QWORD *)this + 191) = 0;
  *((_OWORD *)this + 96) = 0u;
  *((_DWORD *)this + 388) = 0;
  *((_QWORD *)this + 200) = 0;
  *((_DWORD *)this + 402) = 0;
  *((_DWORD *)this + 398) = 0;
  *(_OWORD *)((char *)this + 1560) = 0u;
  *(_OWORD *)((char *)this + 1576) = 0u;
  *((_OWORD *)this + 101) = 0u;
  *((_DWORD *)this + 410) = 0;
  *((_QWORD *)this + 204) = 0;
  *((_QWORD *)this + 211) = 0;
  *((_DWORD *)this + 424) = 0;
  *((_OWORD *)this + 103) = 0u;
  *((_OWORD *)this + 104) = 0u;
  *((_DWORD *)this + 420) = 0;
  *((_QWORD *)this + 215) = 0;
  *((_DWORD *)this + 432) = 0;
  *(_OWORD *)((char *)this + 1704) = 0u;
  *((_QWORD *)this + 222) = 0;
  *((_DWORD *)this + 446) = 0;
  *(_OWORD *)((char *)this + 1736) = 0u;
  *(_OWORD *)((char *)this + 1752) = 0u;
  *((_DWORD *)this + 442) = 0;
  *((_QWORD *)this + 226) = 0;
  *((_DWORD *)this + 454) = 0;
  *((_OWORD *)this + 112) = 0u;
  *((_QWORD *)this + 233) = 0;
  *((_DWORD *)this + 468) = 0;
  *((_DWORD *)this + 464) = 0;
  *((_OWORD *)this + 115) = 0u;
  *((_OWORD *)this + 114) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
  *((_DWORD *)this + 476) = 0;
  *((_QWORD *)this + 237) = 0;
  *((_QWORD *)this + 244) = 0;
  *((_DWORD *)this + 490) = 0;
  *(_OWORD *)((char *)this + 1912) = 0u;
  *(_OWORD *)((char *)this + 1928) = 0u;
  *((_DWORD *)this + 486) = 0;
  *((_OWORD *)this + 123) = 0u;
  *((_DWORD *)this + 498) = 0;
  *((_QWORD *)this + 248) = 0;
  *((_QWORD *)this + 255) = 0;
  *((_DWORD *)this + 512) = 0;
  *((_OWORD *)this + 125) = 0u;
  *((_OWORD *)this + 126) = 0u;
  *((_DWORD *)this + 508) = 0;
  *((_DWORD *)this + 520) = 0;
  *((_QWORD *)this + 259) = 0;
  *(_OWORD *)((char *)this + 2056) = 0u;
  *((_QWORD *)this + 266) = 0;
  *((_DWORD *)this + 534) = 0;
  *(_OWORD *)((char *)this + 2088) = 0u;
  *(_OWORD *)((char *)this + 2104) = 0u;
  *((_DWORD *)this + 530) = 0;
  *((_QWORD *)this + 268) = MEMORY[0x24BDAC9B8];
  *((_QWORD *)this + 269) = 0x7B61A86B3;
  *((_QWORD *)this + 270) = 0;
  *((_QWORD *)this + 271) = 0x61A800000000;
  *((_QWORD *)this + 272) = 0;
  *((_BYTE *)this + 2184) = 0;
  *((_QWORD *)this + 276) = 0;
  *((_DWORD *)this + 554) = 0;
  *((_OWORD *)this + 137) = 0u;
  *((_DWORD *)this + 555) = 16777473;
  *((_QWORD *)this + 278) = 500;
  *((_DWORD *)this + 558) = 10485760;
  *((_WORD *)this + 1118) = 257;
  *((_DWORD *)this + 560) = 10;
  *((_DWORD *)this + 566) = 0;
  *(_OWORD *)((char *)this + 2248) = 0u;
  *((_BYTE *)this + 2272) = 0;
  *((_QWORD *)this + 289) = 0;
  *((_DWORD *)this + 576) = 0;
  *((_QWORD *)this + 287) = 0;
  *(_OWORD *)((char *)this + 2280) = 0u;
  re::Transport::Transport((re::Session *)((char *)this + 2320));
  *((_DWORD *)this + 758) = 1;
  *((_OWORD *)this + 190) = 0u;
  *((_OWORD *)this + 191) = 0u;
  *((_DWORD *)this + 768) = 0;
  *(_OWORD *)((char *)this + 3080) = 0u;
  *(_OWORD *)((char *)this + 3096) = 0u;
  *(_OWORD *)((char *)this + 3108) = 0u;
  *(_QWORD *)((char *)this + 3124) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 407) = 0;
  *((_DWORD *)this + 816) = 0;
  *((_QWORD *)this + 409) = 0;
  *((_DWORD *)this + 820) = 0;
  *((_QWORD *)this + 411) = 0;
  *((_OWORD *)this + 196) = 0u;
  *((_OWORD *)this + 197) = 0u;
  *((_DWORD *)this + 792) = 0;
  *((_DWORD *)this + 802) = 0;
  *(_OWORD *)((char *)this + 3176) = 0u;
  *(_OWORD *)((char *)this + 3192) = 0u;
  *((_DWORD *)this + 812) = 0;
  *((_OWORD *)this + 202) = 0u;
  *((_OWORD *)this + 201) = 0u;
  *((_QWORD *)this + 412) = 500;
  *((_QWORD *)this + 938) = 0;
  *((_DWORD *)this + 1878) = 0;
  *(_OWORD *)((char *)this + 7464) = 0u;
  *(_OWORD *)((char *)this + 7480) = 0u;
  *((_DWORD *)this + 1874) = 0;
  *((_QWORD *)this + 940) = 0;
  bzero((char *)this + 3304, 0x103CuLL);
  *((_QWORD *)this + 941) = &off_24E072450;
  *((_QWORD *)this + 942) = 0x100000000;
  v5 = -96;
  do
  {
    v6 = (char *)this + v5;
    *((_QWORD *)v6 + 960) = 0;
    v7 = (_OWORD *)((char *)this + v5 + 7640);
    *((_DWORD *)v6 + 1918) = 0;
    *v7 = 0uLL;
    v7[1] = 0uLL;
    v5 += 48;
  }
  while (v5);
  *((_DWORD *)this + 1910) = 0;
  *((_BYTE *)this + 7648) = 0;
  return this;
}

void `anonymous namespace'::SessionObserverProxy::~SessionObserverProxy(_anonymous_namespace_::SessionObserverProxy *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;

  *(_QWORD *)this = &off_24E072238;
  _Block_release(*((const void **)this + 3));
  _Block_release(*((const void **)this + 4));
  _Block_release(*((const void **)this + 5));
  _Block_release(*((const void **)this + 6));
  _Block_release(*((const void **)this + 7));
  _Block_release(*((const void **)this + 16));
  _Block_release(*((const void **)this + 17));
  v2 = *((unsigned int *)this + 28);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)(*((_QWORD *)this + 12) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 6;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v6 = v3;
    do
    {
      _Block_release(*(const void **)(*((_QWORD *)this + 12) + 24 * v6 + 16));
      v7 = *((_DWORD *)this + 28);
      if (v7 <= (int)v3 + 1)
        v8 = v3 + 1;
      else
        v8 = *((_DWORD *)this + 28);
      v9 = v3;
      while (1)
      {
        v6 = (v9 + 1);
        if (v8 - 1 == v9)
          break;
        ++v9;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((_QWORD *)this + 12) + 24 * v6 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while (v7 != (_DWORD)v3);
  }
  _Block_release(*((const void **)this + 8));
  _Block_release(*((const void **)this + 9));
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 10);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  JUMPOUT(0x220780CD0);
}

void RESyncNetSessionConfig::~RESyncNetSessionConfig(RESyncNetSessionConfig *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24E072280;
  v2 = *((_QWORD *)this + 17);
  if (v2)
  {

    *((_QWORD *)this + 17) = 0;
  }
  v3 = *((_QWORD *)this + 16);
  if (v3)
  {

    *((_QWORD *)this + 16) = 0;
  }
  v4 = *((_QWORD *)this + 11);
  if (v4)
  {

    *((_QWORD *)this + 11) = 0;
  }
  v5 = *((_QWORD *)this + 7);
  if (v5)
  {

    *((_QWORD *)this + 7) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24E072280;
  v2 = *((_QWORD *)this + 17);
  if (v2)
  {

    *((_QWORD *)this + 17) = 0;
  }
  v3 = *((_QWORD *)this + 16);
  if (v3)
  {

    *((_QWORD *)this + 16) = 0;
  }
  v4 = *((_QWORD *)this + 11);
  if (v4)
  {

    *((_QWORD *)this + 11) = 0;
  }
  v5 = *((_QWORD *)this + 7);
  if (v5)
  {

    *((_QWORD *)this + 7) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t re::SyncObjectTypedStore::SyncObjectTypedStore(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)a1 = &off_24E0722C8;
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = *a2;
  *a2 = 0;
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = a4;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + 104) && *(_QWORD *)(v5 + 120))
    v6 = re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize((re::NetworkFeatureFlags *)a1);
  else
    v6 = 1;
  *(_QWORD *)(a1 + 40) = v6;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_QWORD *)(a1 + 124) = 0x7FFFFFFFLL;
  return a1;
}

void re::SyncObjectTypedStore::~SyncObjectTypedStore(re::SyncObjectTypedStore *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24E0722C8;
  if (*((_BYTE *)this + 8))
    *((_BYTE *)this + 8) = 0;
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 11);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 48);
  v2 = *((_QWORD *)this + 2);
  if (v2)
  {

    *((_QWORD *)this + 2) = 0;
  }
}

{
  re::SyncObjectTypedStore::~SyncObjectTypedStore(this);
  JUMPOUT(0x220780CD0);
}

_QWORD *re::SyncObjectTypedStore::createWithGuid@<X0>(re::SyncObjectTypedStore *this@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  re::Allocator *v6;
  re::Allocator *v7;
  unint64_t v8;
  re::SyncObject *v9;
  re::SyncObject *v10;
  uint64_t v11;
  _QWORD *result;
  uint64_t v13;
  uint64_t v14;

  v6 = (re::Allocator *)*((_QWORD *)this + 3);
  v7 = (re::Allocator *)*((_QWORD *)this + 4);
  v8 = *((_QWORD *)this + 5);
  v9 = (re::SyncObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)v6 + 32))(v6, 224, 8);
  v10 = re::SyncObject::SyncObject(v9, v6, a2, v7, v8);
  *a3 = (uint64_t)v10;
  v11 = *((_QWORD *)v10 + 3);
  v13 = *((_QWORD *)this + 8);
  v14 = v11;
  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add((uint64_t)this + 88, &v14, &v13);
  result = re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((_QWORD *)this + 6, a3);
  *(_QWORD *)(*a3 + 88) = this;
  return result;
}

unint64_t *re::SyncObjectTypedStore::findObjectWithGuid(re::SyncObjectTypedStore *this, uint64_t a2)
{
  unint64_t *result;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6[2];
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  unint64_t v12;
  __int16 v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v6[0] = a2;
  result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 88, v6);
  if (result)
  {
    v4 = *result;
    v5 = *((_QWORD *)this + 8);
    if (v5 <= *result)
    {
      v6[1] = 0;
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v15 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v7 = 136315906;
      v8 = "operator[]";
      v9 = 1024;
      v10 = 797;
      v11 = 2048;
      v12 = v4;
      v13 = 2048;
      v14 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(unint64_t **)(*((_QWORD *)this + 10) + 8 * v4);
  }
  return result;
}

void re::SyncObjectTypedStore::removeObject(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD v18[5];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v4 = a1 + 88;
  *(_QWORD *)&v18[0] = *(_QWORD *)(*(_QWORD *)a2 + 24);
  v5 = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 88, (uint64_t *)v18);
  if (v5)
  {
    v6 = *(_QWORD *)(a1 + 64);
    v7 = *v5;
    if (v6 <= *v5)
    {
      memset(v18, 0, sizeof(v18));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v10 = *(_QWORD *)(a1 + 80);
    v8 = v10 + 8 * v6;
    v9 = *(_QWORD *)(v8 - 8);
    *(_QWORD *)(v8 - 8) = 0;
    *(_QWORD *)(v8 - 8) = *(_QWORD *)(v10 + 8 * v7);
    *(_QWORD *)(v10 + 8 * v7) = v9;
    LODWORD(v10) = 0x7FFFFFFF;
    if (*(_QWORD *)(a1 + 88))
    {
      v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v7) + 24);
      v12 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) >> 27));
      v13 = *(unsigned int *)(*(_QWORD *)(a1 + 96) + 4 * ((v12 ^ (v12 >> 31)) % *(unsigned int *)(a1 + 112)));
      if ((_DWORD)v13 != 0x7FFFFFFF)
      {
        v14 = *(_QWORD *)(a1 + 104);
        LODWORD(v10) = v13;
        if (*(_QWORD *)(v14 + 32 * v13 + 16) != v11)
        {
          v10 = v13;
          while (1)
          {
            v10 = *(_DWORD *)(v14 + 32 * v10 + 8) & 0x7FFFFFFF;
            if ((_DWORD)v10 == 0x7FFFFFFF)
              break;
            if (*(_QWORD *)(v14 + 32 * v10 + 16) == v11)
              goto LABEL_11;
          }
          LODWORD(v10) = 0x7FFFFFFF;
        }
      }
    }
LABEL_11:
    *(_QWORD *)(*(_QWORD *)(a1 + 104) + 32 * v10 + 24) = v7;
    *(_QWORD *)&v18[0] = *(_QWORD *)(*(_QWORD *)a2 + 24);
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v4, (uint64_t *)v18);
    v15 = *(_QWORD *)(a1 + 64);
    v16 = *(_QWORD *)(a1 + 80) + 8 * v15;
    v17 = *(_QWORD *)(v16 - 8);
    if (v17)
    {

      *(_QWORD *)(v16 - 8) = 0;
      v15 = *(_QWORD *)(a1 + 64);
    }
    *(_QWORD *)(a1 + 64) = v15 - 1;
    ++*(_DWORD *)(a1 + 72);
  }
}

re::SyncObjectStore *re::SyncObjectStore::SyncObjectStore(re::SyncObjectStore *this)
{
  _anonymous_namespace_ *v2;
  re::PoolAllocator *v3;
  _anonymous_namespace_ *v4;
  unint64_t v5;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E0722E8;
  v4 = (_anonymous_namespace_ *)re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(v3);
  v5 = 96 * v4;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *((_QWORD *)this + 67) = 0x7FFFFFFF00000000;
  *((_DWORD *)this + 136) = 0;
  *((_QWORD *)this + 69) = 0x20000000ALL;
  *((_QWORD *)this + 70) = 0;
  *((_QWORD *)this + 72) = 0;
  *((_QWORD *)this + 71) = 0;
  *((_DWORD *)this + 146) = 0;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *(_OWORD *)((char *)this + 620) = 0u;
  *(_QWORD *)((char *)this + 636) = 0x7FFFFFFFLL;
  return this;
}

void re::SyncObjectStore::~SyncObjectStore(re::SyncObjectStore *this)
{
  re::SyncObjectStore *v1;
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  void (***v8)(_QWORD);
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  double v17;
  uint64_t v18;

  v1 = this;
  *(_QWORD *)this = &off_24E0722E8;
  v2 = *((unsigned int *)this + 134);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)(*((_QWORD *)this + 65) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 8;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 134);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 == (_DWORD)v3)
  {
    v6 = *((_DWORD *)this + 134);
  }
  else
  {
    v7 = v3;
    v6 = *((_DWORD *)this + 134);
    do
    {
      v8 = *(void (****)(_QWORD))(*((_QWORD *)v1 + 65) + 32 * v7 + 24);
      if (v8)
      {
        v9 = re::globalAllocators(this)[2];
        (**v8)(v8);
        this = (re::SyncObjectStore *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v9 + 40))(v9, v8);
        v6 = *((_DWORD *)v1 + 134);
      }
      if (v6 <= (int)v3 + 1)
        v10 = v3 + 1;
      else
        v10 = v6;
      while (1)
      {
        v7 = (v3 + 1);
        if (v10 - 1 == (_DWORD)v3)
          break;
        LODWORD(v3) = v3 + 1;
        v11 = v7;
        if ((*(_DWORD *)(*((_QWORD *)v1 + 65) + 32 * v7 + 8) & 0x80000000) != 0)
          goto LABEL_19;
      }
      v11 = v10;
LABEL_19:
      LODWORD(v3) = v11;
    }
    while ((_DWORD)v2 != v11);
  }
  if (*((_DWORD *)v1 + 133))
  {
    v12 = *((unsigned int *)v1 + 132);
    if ((_DWORD)v12)
    {
      memset_pattern16(*((void **)v1 + 64), &unk_21C701D20, 4 * v12);
      v6 = *((_DWORD *)v1 + 134);
    }
    if (v6)
    {
      v13 = 0;
      v14 = 32 * v6;
      do
      {
        v15 = *((_QWORD *)v1 + 65) + v13;
        v16 = *(_DWORD *)(v15 + 8);
        if (v16 < 0)
          *(_DWORD *)(v15 + 8) = v16 & 0x7FFFFFFF;
        v13 += 32;
      }
      while (v14 != v13);
    }
    *((_DWORD *)v1 + 135) = 0x7FFFFFFF;
    *(_QWORD *)((char *)v1 + 532) = 0;
    ++*((_DWORD *)v1 + 136);
  }
  re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::clear((uint64_t)v1 + 600);
  *((_QWORD *)v1 + 72) = 0;
  ++*((_DWORD *)v1 + 146);
  re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::clear((uint64_t)v1 + 600);
  *((_QWORD *)v1 + 72) = 0;
  ++*((_DWORD *)v1 + 146);
  v17 = re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)v1 + 75);
  v18 = *((_QWORD *)v1 + 70);
  if (v18)
  {
    if (*((_QWORD *)v1 + 74))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v18 + 40))(v18, v17);
    *((_QWORD *)v1 + 74) = 0;
    *((_QWORD *)v1 + 71) = 0;
    *((_QWORD *)v1 + 72) = 0;
    *((_QWORD *)v1 + 70) = 0;
    ++*((_DWORD *)v1 + 146);
  }
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v1 + 63);
  re::PoolAllocator::~PoolAllocator((re::SyncObjectStore *)((char *)v1 + 264));
  re::PoolAllocator::~PoolAllocator((re::SyncObjectStore *)((char *)v1 + 24));
  *(_QWORD *)v1 = &off_24E0707C0;
  objc_destructInstance((char *)v1 + 8);
}

{
  re::SyncObjectStore::~SyncObjectStore(this);
  JUMPOUT(0x220780CD0);
}

void re::SyncObjectTombstoneInfo::update(re::SyncObjectTombstoneInfo *this)
{
  double Current;
  double v3;
  unint64_t v4;
  double v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;

  Current = CFAbsoluteTimeGetCurrent();
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    v5 = Current;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *((_QWORD *)this + 5);
      LODWORD(v3) = *(_DWORD *)this;
      v3 = (double)*(unint64_t *)&v3;
      if (v5 - *(double *)(v9 + v6) < v3)
        break;
      v10 = v9 + v6;
      v11 = *(unsigned __int16 *)(v10 + 8);
      if (*((_DWORD *)this + 1) <= v11)
      {
        re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::remove((uint64_t)this + 48, (uint64_t *)(v10 + 16));
        ++v8;
        v4 = *((_QWORD *)this + 3);
      }
      else
      {
        *(_WORD *)(v10 + 8) = v11 + 1;
      }
      ++v7;
      v6 += 40;
    }
    while (v7 < v4);
    if (v8)
      re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::removeManyStableAt((_QWORD *)this + 1, 0, v8);
  }
}

void re::SyncObjectStore::addType(re::SyncObjectStore *this, const re::SyncObjectTypeInfo *a2)
{
  char *v4;
  _BOOL8 v5;
  uint64_t *v6;
  uint64_t v7;
  re *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  id v12;
  re *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE buf[12];
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = (char *)this + 504;
  v5 = re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)this + 504, *((_QWORD *)a2 + 4));
  if (!v5)
  {
    v6 = re::globalAllocators((re *)v5);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6[2] + 32))(v6[2], 144, 8);
    v8 = re::SyncObjectTypeInfo::SyncObjectTypeInfo((re::SyncObjectTypeInfo *)v7, a2);
    v9 = (uint64_t *)((char *)v8 + 32);
    v10 = re::globalAllocators(v8);
    v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 136, 8);
    v17 = v7;
    if (v7)
      v12 = (id)(v7 + 8);
    re::SyncObjectTypedStore::SyncObjectTypedStore(v11, &v17, (uint64_t)this + 24, (uint64_t)this + 264);
    *(_QWORD *)buf = v11;
    v13 = (re *)re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v4, v9, buf);
    if (v17)

    v14 = *re::networkLogObjects(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      if ((*(_BYTE *)(v7 + 48) & 1) != 0)
        v15 = *(_QWORD *)(v7 + 56);
      else
        v15 = v7 + 49;
      v16 = *v9;
      *(_DWORD *)buf = 136380931;
      *(_QWORD *)&buf[4] = v15;
      v19 = 2048;
      v20 = v16;
      _os_log_impl(&dword_21C69B000, v14, OS_LOG_TYPE_INFO, "Registered sync object type %{private}s:%llu", buf, 0x16u);
      goto LABEL_13;
    }
    if (v7)
LABEL_13:

  }
}

BOOL re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _BOOL8 result;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + 32 * v3 + 16) == a2)
    return 1;
  do
  {
    v3 = *(_DWORD *)(v5 + 32 * v3 + 8) & 0x7FFFFFFF;
    result = (_DWORD)v3 != 0x7FFFFFFF;
  }
  while ((_DWORD)v3 != 0x7FFFFFFF && *(_QWORD *)(v5 + 32 * v3 + 16) != a2);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = result;
  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(_QWORD *)result)
  {
    v9 = v8 % *(unsigned int *)(result + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v11 + 32 * v10 + 16) == v6)
        return result;
      while (1)
      {
        v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v11 + 32 * v10 + 16) == v6)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  result = re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

void re::SyncObjectStore::addType(re::SyncObjectStore *this, re::SyncObjectTypeInfo *a2)
{
  char *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  char *v8;
  re *v9;
  NSObject *v10;
  char *v11;
  uint64_t v12;
  re::SyncObjectTypeInfo *v13;
  _BYTE buf[12];
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v4 = (char *)this + 504;
    v5 = (uint64_t *)((char *)a2 + 32);
    if (!re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)this + 504, *((_QWORD *)a2 + 4)))
    {
      v6 = re::globalAllocators((re *)(char *)a2 + 8);
      v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6[2] + 32))(v6[2], 136, 8);
      v13 = a2;
      v8 = (char *)a2 + 8;
      re::SyncObjectTypedStore::SyncObjectTypedStore(v7, &v13, (uint64_t)this + 24, (uint64_t)this + 264);
      *(_QWORD *)buf = v7;
      v9 = (re *)re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v4, v5, buf);
      if (v13)

      v10 = *re::networkLogObjects(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        if ((*((_BYTE *)a2 + 48) & 1) != 0)
          v11 = (char *)*((_QWORD *)a2 + 7);
        else
          v11 = (char *)a2 + 49;
        v12 = *v5;
        *(_DWORD *)buf = 136380931;
        *(_QWORD *)&buf[4] = v11;
        v15 = 2048;
        v16 = v12;
        _os_log_impl(&dword_21C69B000, v10, OS_LOG_TYPE_INFO, "Registered sync object type %{private}s:%llu", buf, 0x16u);
      }

    }
  }
}

_QWORD *re::SyncObjectStore::create@<X0>(re::SyncObjectStore *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  re::SyncObjectTypedStore *v7;
  _QWORD v9[2];

  v3 = a3;
  LODWORD(a3) = 0x7FFFFFFF;
  if (*((_QWORD *)this + 63))
  {
    v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v5 = (uint64_t *)*(unsigned int *)(*((_QWORD *)this + 64) + 4 * ((v4 ^ (v4 >> 31)) % *((unsigned int *)this + 132)));
    if ((_DWORD)v5 != 0x7FFFFFFF)
    {
      v6 = *((_QWORD *)this + 65);
      LODWORD(a3) = (_DWORD)v5;
      if (*(_QWORD *)(v6 + 32 * (_QWORD)v5 + 16) != a2)
      {
        a3 = v5;
        while (1)
        {
          a3 = (uint64_t *)(*(_DWORD *)(v6 + 32 * (_QWORD)a3 + 8) & 0x7FFFFFFF);
          if ((_DWORD)a3 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v6 + 32 * (_QWORD)a3 + 16) == a2)
            goto LABEL_9;
        }
        LODWORD(a3) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  v7 = *(re::SyncObjectTypedStore **)(*((_QWORD *)this + 65) + 32 * a3 + 24);
  uuid_generate_random((unsigned __int8 *)v9);
  return re::SyncObjectTypedStore::createWithGuid(v7, (v9[1] + (v9[0] << 6) + (v9[0] >> 2) - 0x61C8864680B583E9) ^ v9[0], v3);
}

unint64_t re::SyncObjectStore::createIncomingObject@<X0>(re::SyncObjectStore *this@<X0>, const re::SyncOwnershipInfo *a2@<X3>, unint64_t a3@<X1>, uint64_t a4@<X2>, uint64_t *a5@<X8>)
{
  uint64_t *v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  __int128 v12;

  v6 = a5;
  LODWORD(a5) = 0x7FFFFFFF;
  if (*((_QWORD *)this + 63))
  {
    v7 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
    v8 = (uint64_t *)*(unsigned int *)(*((_QWORD *)this + 64) + 4 * ((v7 ^ (v7 >> 31)) % *((unsigned int *)this + 132)));
    if ((_DWORD)v8 != 0x7FFFFFFF)
    {
      v9 = *((_QWORD *)this + 65);
      LODWORD(a5) = (_DWORD)v8;
      if (*(_QWORD *)(v9 + 32 * (_QWORD)v8 + 16) != a3)
      {
        a5 = v8;
        while (1)
        {
          a5 = (uint64_t *)(*(_DWORD *)(v9 + 32 * (_QWORD)a5 + 8) & 0x7FFFFFFF);
          if ((_DWORD)a5 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v9 + 32 * (_QWORD)a5 + 16) == a3)
            goto LABEL_9;
        }
        LODWORD(a5) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  re::SyncObjectTypedStore::createWithGuid(*(re::SyncObjectTypedStore **)(*((_QWORD *)this + 65) + 32 * a5 + 24), a4, v6);
  v10 = *v6;
  v11 = *((_DWORD *)a2 + 8);
  v12 = *((_OWORD *)a2 + 1);
  *(_OWORD *)(v10 + 136) = *(_OWORD *)a2;
  *(_DWORD *)(v10 + 168) = v11;
  *(_OWORD *)(v10 + 152) = v12;
  return re::SyncObject::addState((re::SyncObject *)v10, 0, *((_QWORD *)a2 + 3));
}

re::SyncObjectTypedStore **re::SyncObjectStore::findObject@<X0>(re::SyncObjectStore *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, re::SyncObjectTypedStore ***a4@<X8>)
{
  re::SyncObjectTypedStore **result;
  uint64_t v7;

  v7 = a2;
  result = (re::SyncObjectTypedStore **)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 504, &v7);
  if (result)
  {
    result = (re::SyncObjectTypedStore **)re::SyncObjectTypedStore::findObjectWithGuid(*result, a3);
    *a4 = result;
    if (result)
      return result + 1;
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

double re::SyncObjectStore::removeObject(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  id v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;

  v4 = *a2;
  v5 = 0x7FFFFFFF;
  if (!*(_QWORD *)(a1 + 504)
    || (v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 88) + 16) + 32),
        v7 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27)),
        v8 = *(unsigned int *)(*(_QWORD *)(a1 + 512) + 4 * ((v7 ^ (v7 >> 31)) % *(unsigned int *)(a1 + 528))),
        (_DWORD)v8 == 0x7FFFFFFF)
    || (v9 = *(_QWORD *)(a1 + 520), v5 = v8, *(_QWORD *)(v9 + 32 * v8 + 16) == v6))
  {
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 520) + 32 * v5 + 24);
    v19 = *a2;
LABEL_5:
    v11 = (void *)(v4 + 8);
    v12 = (id)(v4 + 8);
    re::SyncObjectTypedStore::removeObject(v10, (uint64_t)&v19);

    goto LABEL_6;
  }
  while (1)
  {
    v8 = *(_DWORD *)(v9 + 32 * v8 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v8 == 0x7FFFFFFF)
      break;
    if (*(_QWORD *)(v9 + 32 * v8 + 16) == v6)
      goto LABEL_13;
  }
  v8 = 0x7FFFFFFFLL;
LABEL_13:
  v10 = *(_QWORD *)(v9 + 32 * v8 + 24);
  v19 = *a2;
  if (v4)
    goto LABEL_5;
  re::SyncObjectTypedStore::removeObject(v10, (uint64_t)&v19);
LABEL_6:
  v13 = *(_QWORD *)(*a2 + 24);
  v14 = *(_QWORD *)(*a2 + 80);
  v17 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a2 + 88) + 16) + 32);
  v18 = v13;
  if (v14)
    v14 = *(_QWORD *)(v14 + 24);
  v16 = v14;
  return re::SyncObjectTombstoneInfo::addEntry((re::SyncObjectTombstoneInfo *)(a1 + 552), &v18, &v17, &v16);
}

double re::SyncObjectTombstoneInfo::addEntry(re::SyncObjectTombstoneInfo *this, const unint64_t *a2, const unint64_t *a3, const unint64_t *a4)
{
  uint64_t v5;
  double result;
  CFAbsoluteTime Current;
  __int16 v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v5 = *a3;
  *(_QWORD *)&v11 = *a2;
  *((_QWORD *)&v11 + 1) = v5;
  v12 = *a4;
  re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::add((uint64_t)this + 48, (uint64_t *)&v11);
  Current = CFAbsoluteTimeGetCurrent();
  v8 = 0;
  v9 = v11;
  v10 = v12;
  *(_QWORD *)&result = re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::add((re::SyncObjectTombstoneInfo *)((char *)this + 8), (uint64_t)&Current).n128_u64[0];
  return result;
}

_QWORD *re::SyncObjectStore::types@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;

  v2 = this;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  v4 = *((unsigned int *)this + 133);
  if ((_DWORD)v4)
    this = re::DynamicArray<re::SyncObjectTypedStore const*>::setCapacity((_QWORD *)a2, v4);
  v5 = *((unsigned int *)v2 + 134);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (int *)(v2[65] + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 8;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *((_DWORD *)v2 + 134);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 != (_DWORD)v6)
  {
    v9 = v6;
    do
    {
      this = re::DynamicArray<re::SyncObjectTypedStore const*>::add((_QWORD *)a2, (_QWORD *)(v2[65] + 32 * v9 + 24));
      if (*((_DWORD *)v2 + 134) <= (v6 + 1))
        v10 = v6 + 1;
      else
        v10 = *((_DWORD *)v2 + 134);
      v11 = v6;
      while (1)
      {
        v9 = (v11 + 1);
        if (v10 - 1 == v11)
          break;
        ++v11;
        LODWORD(v6) = v9;
        if ((*(_DWORD *)(v2[65] + 32 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_19;
      }
      LODWORD(v6) = v10;
LABEL_19:
      ;
    }
    while ((_DWORD)v5 != (_DWORD)v6);
  }
  return this;
}

_QWORD *re::DynamicArray<re::SyncObjectTypedStore const*>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SyncObjectTypedStore const*>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_21C701D20, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 40 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 40;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  __int128 v25;

  v4 = *a2;
  v5 = a2[1];
  v6 = (v5 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2;
  v7 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v7)
  {
    v8 = v6 % v7;
    v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
    if ((_DWORD)v9 != 0x7FFFFFFF)
    {
      v10 = *(_QWORD *)(a1 + 16);
      v11 = v10 + 40 * v9;
      v13 = *(_QWORD *)(v11 + 16);
      v12 = *(_QWORD *)(v11 + 24);
      if (v13 == v4 && v12 == v5)
      {
LABEL_13:
        v19 = v10 + 40 * v9;
        return v19 + 16;
      }
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 40 * v9 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v9 == 0x7FFFFFFF)
          break;
        v15 = v10 + 40 * v9;
        v17 = *(_QWORD *)(v15 + 16);
        v16 = *(_QWORD *)(v15 + 24);
        if (v17 == v4 && v16 == v5)
          goto LABEL_13;
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  v20 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v20 == 0x7FFFFFFF)
  {
    v20 = *(unsigned int *)(a1 + 32);
    v21 = v20;
    if ((_DWORD)v20 == (_DWORD)v7)
    {
      re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v8) = v6 % *(unsigned int *)(a1 + 24);
      v21 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v21 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 40 * v20 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 40 * v20 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 40 * v20 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v20 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v20 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v20) = v6;
  v24 = *(_QWORD *)(a1 + 16) + 40 * v20;
  v25 = *(_OWORD *)a2;
  *(_QWORD *)(v24 + 32) = a2[2];
  *(_OWORD *)(v24 + 16) = v25;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8) = v20;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
  v19 = *(_QWORD *)(a1 + 16) + 40 * v20;
  return v19 + 16;
}

__n128 re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)v5 = result;
  *(_OWORD *)(v5 + 16) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int *v22;
  int v23;
  int v24;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v3 = *a2;
  v4 = a2[1];
  v5 = ((v4 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2) % v2;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  v10 = v9 + 40 * v7;
  v12 = *(_QWORD *)(v10 + 16);
  v11 = *(_QWORD *)(v10 + 24);
  if (v12 != v3 || v11 != v4)
  {
    while (1)
    {
      v14 = v7;
      LODWORD(v7) = *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v7 == 0x7FFFFFFF)
        return 0;
      v15 = v9 + 40 * v7;
      v17 = *(_QWORD *)(v15 + 16);
      v16 = *(_QWORD *)(v15 + 24);
      if (v17 == v3 && v16 == v4)
      {
        *(_DWORD *)(v9 + 40 * v14 + 8) = *(_DWORD *)(v9 + 40 * v14 + 8) & 0x80000000 | *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_16;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
LABEL_16:
  v19 = *(_QWORD *)(a1 + 16);
  v20 = v19 + 40 * v7;
  v23 = *(_DWORD *)(v20 + 8);
  v22 = (int *)(v20 + 8);
  v21 = v23;
  if (v23 < 0)
  {
    *v22 = v21 & 0x7FFFFFFF;
    v19 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v19 + 40 * v7 + 8);
  }
  v24 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v19 + 40 * v7 + 8) = *(_DWORD *)(a1 + 36) | v21 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v24 + 1;
  return 1;
}

_QWORD *re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::removeManyStableAt(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _BYTE *v9;

  if (a3)
  {
    v4 = result;
    v5 = a2 + a3 - 1;
    v6 = result[2];
    if (v5 >= v6)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 < v6 - 1)
    {
      v7 = result[4];
      result = (_QWORD *)(v7 + 40 * a2);
      v8 = &result[5 * a3];
      v9 = (_BYTE *)(v7 + 40 * v6);
      if (v9 != (_BYTE *)v8)
      {
        result = memmove(result, v8, v9 - (_BYTE *)v8);
        v6 = v4[2];
      }
    }
    v4[2] = v6 - a3;
    ++*((_DWORD *)v4 + 6);
  }
  return result;
}

BOOL re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v3 = *a2;
  v4 = a2[1];
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4 * (((v4 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2) % v2));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v7 = *(_QWORD *)(a1 + 16);
  v8 = v7 + 40 * v5;
  v10 = *(_QWORD *)(v8 + 16);
  v9 = *(_QWORD *)(v8 + 24);
  if (v10 == v3 && v9 == v4)
    return 1;
  do
  {
    LODWORD(v5) = *(_DWORD *)(v7 + 40 * v5 + 8) & 0x7FFFFFFF;
    result = (_DWORD)v5 != 0x7FFFFFFF;
    if ((_DWORD)v5 == 0x7FFFFFFF)
      break;
    v12 = v7 + 40 * v5;
    v14 = *(_QWORD *)(v12 + 16);
    v13 = *(_QWORD *)(v12 + 24);
  }
  while (v14 != v3 || v13 != v4);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  _BYTE v26[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v26, 0, 36);
          *(_QWORD *)&v26[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v26, v13, v12);
          v15 = *(_OWORD *)v26;
          *(_OWORD *)v26 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v26[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v26[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v26[24];
          *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v26[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21, v21 + 8);
              v21 += 32;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v26);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 32 * v9 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 32 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

_QWORD *re::DynamicArray<re::SyncObjectTypedStore const*>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::SyncObjectTypedStore const*>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::SyncObjectTypedStore const*>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SyncObjectTypedStore const*>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SyncObjectTypedStore const*>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int128 *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  __int128 v22;
  signed int v23;
  _BYTE v24[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(_QWORD *)&v24[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::init((uint64_t)v24, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v24;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)v24 = v5;
      *(_QWORD *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (__int128 *)(v6 + 16);
        do
        {
          if ((*((_DWORD *)v13 - 2) & 0x80000000) != 0)
          {
            v14 = *((_QWORD *)v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 40 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v17) = v14;
            v21 = *(_QWORD *)(a1 + 16) + 40 * v17;
            v22 = *v13;
            *(_QWORD *)(v21 + 32) = *((_QWORD *)v13 + 2);
            *(_OWORD *)(v21 + 16) = v22;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 = (__int128 *)((char *)v13 + 40);
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2)
      v23 = a2;
    else
      v23 = 3;
  }
}

void re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

_QWORD *re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 40 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t RESyncBiasedVLQWrite(re::BitWriter *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = 0;
  return re::BiasedVLQ::write((re::BiasedVLQ *)&v3, a1, a2);
}

uint64_t RESyncBiasedVLQRead(re::BitReader *a1, uint64_t *a2)
{
  uint64_t v3;

  v3 = 0;
  return re::BiasedVLQ::read((re::BiasedVLQ *)&v3, a1, a2);
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<`anonymous namespace'::MCProtocolHandle>>::add(_anonymous_namespace_ *result, _QWORD *a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;

  v3 = result;
  v4 = *((_QWORD *)result + 1);
  v5 = *((_QWORD *)result + 2);
  v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(_QWORD *)result)
    {
      v9 = 2 * v4;
      v10 = v4 == 0;
      v11 = 8;
      if (!v10)
        v11 = v9;
      if (v11 <= v6)
        v12 = v6;
      else
        v12 = v11;
      result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(result, v12);
    }
    else
    {
      result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(v3, v6);
      ++*((_DWORD *)v3 + 6);
    }
  }
  v8 = *((_QWORD *)v3 + 2);
  *(_QWORD *)(*((_QWORD *)v3 + 4) + 8 * v8) = *a2;
  *a2 = 0;
  *((_QWORD *)v3 + 2) = v8 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void `anonymous namespace'::MCProtocolHandle::make(_anonymous_namespace_::MCProtocolHandle *this, MCPeerID *a2)
{
  uint64_t *v3;
  void **v4;
  MCPeerID *v5;

  v5 = a2;
  v3 = re::globalAllocators((re *)v5);
  v4 = (void **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 1800, 8);
  bzero(v4, 0x708uLL);
  re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v4);
  *v4 = &off_24E072408;
  v4[221] = 0;
  *((_BYTE *)v4 + 1776) = 0;
  v4[223] = (void *)250000000;
  v4[224] = 0;
  *(_QWORD *)this = v4;
  re::ObjCObject::operator=(v4 + 221, v5);

}

void `anonymous namespace'::MCProtocolHandle::onHandshake(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;
  char v8;
  id v9;
  re *v10;
  NSObject *v11;
  NSObject *v12;
  id v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  id v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  id v22;
  unint64_t v23;
  char v24;
  _BYTE v25[25];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  qmemcpy(v25, "com.apple.rekit.hello.ack", sizeof(v25));
  v3 = a2;
  v24 = -2;
  objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytesNoCopy:length:freeWhenDone:", &v23, 34, 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = *(id *)(a1 + 1768);
  v5 = (void *)MEMORY[0x24BDBCE30];
  v6 = v22;
  objc_msgSend(v5, "arrayWithObjects:count:", &v22, 1);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = 0;
  v8 = objc_msgSend(v3, "sendData:toPeers:withMode:error:", v4, v7, 0, &v17);

  v9 = v17;
  if ((v8 & 1) == 0)
  {
    v11 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = v11;
      objc_msgSend(v9, "description");
      v13 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v14 = objc_msgSend(v13, "UTF8String");
      objc_msgSend(v9, "description");
      v15 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v16 = objc_msgSend(v15, "UTF8String");
      *(_DWORD *)buf = 136315394;
      v19 = v14;
      v20 = 2080;
      v21 = v16;
      _os_log_error_impl(&dword_21C69B000, v12, OS_LOG_TYPE_ERROR, "MPC: Error sending handshake ack: %s, reason: %s", buf, 0x16u);

    }
  }

}

uint64_t *re::DynamicArray<re::SharedPtr<`anonymous namespace'::MCProtocolHandle>>::~DynamicArray(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *a1;
  if (v2)
  {
    v3 = a1[4];
    if (v3)
    {
      v4 = a1[2];
      if (v4)
      {
        v5 = 8 * v4;
        do
        {
          if (*(_QWORD *)v3)
          {

            *(_QWORD *)v3 = 0;
          }
          v3 += 8;
          v5 -= 8;
        }
        while (v5);
        v2 = *a1;
        v3 = a1[4];
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3);
    }
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  return a1;
}

uint64_t re::MultipeerProtocolLayer::MultipeerProtocolLayer(uint64_t a1, id *a2)
{
  _anonymous_namespace_ *v4;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24E072340;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = (_anonymous_namespace_ *)*a2;
  *(_QWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a1 + 48), 0);
  return a1;
}

void re::MultipeerProtocolLayer::~MultipeerProtocolLayer(void **this)
{
  void *v2;

  re::ObjCObject::operator=(this + 4, 0);
  re::ObjCObject::operator=(this + 5, 0);
  v2 = this[6];
  if (v2)
  {
    if (((_BYTE)this[7] & 1) != 0)
      (*(void (**)(void *, void *))(*(_QWORD *)v2 + 40))(v2, this[8]);
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
  }

  *this = &off_24E0707C0;
  objc_destructInstance(this + 1);
}

{
  re::MultipeerProtocolLayer::~MultipeerProtocolLayer(this);
  JUMPOUT(0x220780CD0);
}

void **re::MultipeerProtocolLayer::deinit(void **this)
{
  re::ObjCObject::operator=(this + 4, 0);
  return re::ObjCObject::operator=(this + 5, 0);
}

uint64_t re::MultipeerProtocolLayer::init(id *a1)
{
  void *v2;
  uint64_t v4;
  char v5;

  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  objc_msgSend(a1[4], "myPeerID");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  +[REMultipeerHelper makeAddressFromPeerID:](REMultipeerHelper, "makeAddressFromPeerID:", v2);
  re::DynamicString::operator=((re::DynamicString *)(a1 + 6), (re::DynamicString *)&v4);
  if (v4 && (v5 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v4 + 40))();
  re::ObjCObject::operator=(a1 + 5, 0);

  return 1;
}

void re::MultipeerProtocolLayer::open(id *this@<X0>, const re::Address *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  id v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  id v11;
  char v12;
  const char *v13;
  const char *v14;
  unint64_t v15;
  uint64_t v16;
  void *v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  unint64_t v29;
  __int16 v30;
  unint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v6 = this[5];
  objc_msgSend(v6, "handlesLock");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "lock");

  if (!v6)
  {
LABEL_24:
    *(_QWORD *)&v34 = 0;
    v32 = 0u;
    v33 = 0u;
    goto LABEL_18;
  }
  objc_msgSend(v6, "handles");
  v8 = v33;
  if (v8)
  {
    v9 = 0;
    while (1)
    {
      objc_msgSend(v6, "handles");
      v10 = v21;
      if (v21 <= v9)
        break;
      v3 = *(_QWORD *)(v22 + 8 * v9);
      if (v3)
        v11 = (id)(v3 + 8);
      +[REMultipeerHelper makeAddressFromPeerID:](REMultipeerHelper, "makeAddressFromPeerID:", *(_QWORD *)(v3 + 1768));
      v12 = BYTE8(v32);
      if ((BYTE8(v32) & 1) != 0)
        v13 = (const char *)v33;
      else
        v13 = (char *)&v32 + 9;
      if ((*((_QWORD *)a2 + 1) & 1) != 0)
        v14 = (const char *)*((_QWORD *)a2 + 2);
      else
        v14 = (char *)a2 + 9;
      if (!strcmp(v13, v14))
        goto LABEL_19;
      if ((_QWORD)v32 && (v12 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v32 + 40))();

      ++v9;
      objc_msgSend(v6, "handles");
      v15 = v33;
      if (v9 >= v15)
        goto LABEL_18;
    }
    v23 = 0;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v32 = 0u;
    v6 = (id)MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v24 = 136315906;
    v25 = "operator[]";
    v26 = 1024;
    v27 = 789;
    v28 = 2048;
    v29 = v9;
    v30 = 2048;
    v31 = v10;
    LODWORD(v19) = 38;
    v18 = &v24;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_24;
  }
LABEL_18:
  objc_msgSend(v6, "handlesLock", v18, v19);
  v6 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "unlock");

  re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) Unknown new connection requested.", "!\"Unreachable code\"", "open", 414);
  _os_crash();
  __break(1u);
LABEL_19:
  objc_msgSend(v6, "handlesLock");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "unlock");

  *a3 = v3;
  if ((_QWORD)v32 && (BYTE8(v32) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v32 + 40))();

}

void re::MultipeerProtocolLayer::close(id *a1, uint64_t a2, int a3)
{
  NSObject *v6;
  id v7;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  id v14;
  unint64_t v15;
  void *v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24[2];
  unint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unint64_t v34;
  __int16 v35;
  unint64_t v36;
  uint8_t buf[32];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v6 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "MPC: Closing peer handle=%p force=%d", buf, 0x12u);
  }
  v7 = a1[5];
  objc_msgSend(v7, "handlesLock");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "lock");

  if (!v7)
  {
    *(_QWORD *)&v38 = 0;
    memset(buf, 0, sizeof(buf));
    goto LABEL_23;
  }
  objc_msgSend(v7, "handles");
  v9 = *(_QWORD *)&buf[16];
  if (v9)
  {
    v10 = 0;
    v11 = -8;
    while (1)
    {
      objc_msgSend(v7, "handles");
      v12 = v25;
      if (v25 <= v10)
        break;
      v13 = *(_QWORD *)(v27 + 8 * v10);
      if (v13)
      {
        v14 = (id)(v13 + 8);
        if (v13 == a2)
          goto LABEL_14;

      }
      else
      {
        if (!a2)
        {
LABEL_14:
          v16 = *(void **)(a2 + 1768);
          *(_QWORD *)(a2 + 1768) = 0;

          objc_msgSend(v7, "handles");
          v12 = v25;
          if (v25 > v10)
          {
            v17 = v25 - 1;
            if (v25 - 1 > v10 && v11 + 8 * v25)
            {
              v18 = (_QWORD *)(v27 - v11);
              v19 = *(_QWORD *)(v27 + 8 * v10);
              v20 = v11 + 8 * v25;
              do
              {
                *(v18 - 1) = *v18;
                *v18++ = v19;
                v20 -= 8;
              }
              while (v20);
            }
            v21 = v27 + 8 * v12;
            v22 = *(_QWORD *)(v21 - 8);
            if (v22)
            {

              *(_QWORD *)(v21 - 8) = 0;
              v17 = v25 - 1;
            }
            v25 = v17;
            ++v26;
            if (v13)

            goto LABEL_23;
          }
LABEL_25:
          v28 = 0;
          v39 = 0u;
          v40 = 0u;
          v38 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v29 = 136315906;
          v30 = "removeStableAt";
          v31 = 1024;
          v32 = 969;
          v33 = 2048;
          v34 = v10;
          v35 = 2048;
          v36 = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      ++v10;
      objc_msgSend(v7, "handles");
      v15 = *(_QWORD *)&buf[16];
      v11 -= 8;
      if (v10 >= v15)
        goto LABEL_23;
    }
    v28 = 0;
    v39 = 0u;
    v40 = 0u;
    v38 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v29 = 136315906;
    v30 = "operator[]";
    v31 = 1024;
    v32 = 789;
    v33 = 2048;
    v34 = v10;
    v35 = 2048;
    v36 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_25;
  }
LABEL_23:
  objc_msgSend(v7, "handlesLock");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v23, "unlock");

}

void re::MultipeerProtocolLayer::disconnect(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  void *v11;
  _BYTE v12[12];
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v6 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v12 = 134218240;
    *(_QWORD *)&v12[4] = a2;
    v13 = 1024;
    LODWORD(v14) = a3;
    _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "MPC: Disconnecting peer handle=%p force=%d", v12, 0x12u);
  }
  v7 = *(id *)(a1 + 40);
  objc_msgSend(v7, "handlesLock");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "lock");

  v9 = *(void **)(a2 + 1768);
  if (v9)
  {
    if (*(_QWORD *)(a1 + 24))
    {
      v10 = v9;
      +[REMultipeerHelper makeAddressFromPeerID:](REMultipeerHelper, "makeAddressFromPeerID:", v10);
      (*(void (**)(_QWORD, uint64_t, uint64_t, _BYTE *))(**(_QWORD **)(a1 + 24) + 8))(*(_QWORD *)(a1 + 24), a1, a2, v12);

      if (*(_QWORD *)v12 && (v12[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v12 + 40))();
      v9 = *(void **)(a2 + 1768);
    }
    *(_QWORD *)(a2 + 1768) = 0;

  }
  objc_msgSend(v7, "handlesLock");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "unlock");

}

void re::MultipeerProtocolLayer::send(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  id v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  size_t v12;
  unint64_t *v13;
  void *v14;
  _BOOL8 v15;
  void *v16;
  id v17;
  void *v18;
  char v19;
  id v20;
  re *v21;
  NSObject *v22;
  uint64_t v23;
  re::PacketPool **v24;
  NSObject *v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE v29[16];
  id v30;
  uint8_t buf[4];
  uint64_t v32;
  id v33[2];

  v33[1] = *(id *)MEMORY[0x24BDAC8D0];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v29, 6078, a1);
  if (*(_BYTE *)(a2 + 1776) && *(_QWORD *)(a2 + 1768))
  {
    v6 = *(id *)(a1 + 32);
    v7 = *(_QWORD *)a3;
    if (*(_QWORD *)a3 != *((_QWORD *)a3 + 1))
    {
      do
      {
        v8 = atomic_load(*(unint64_t **)(v7 + 8));
        v9 = atomic_load((unint64_t *)(*(_QWORD *)a3 + 16));
        if (v8)
        {
          v10 = v9 + 1;
          do
          {
            if (!--v10)
              break;
            v11 = a3[16];
            v12 = *(unsigned int *)(v8 + 24) + 9;
            v13 = (unint64_t *)malloc_type_malloc(v12, 0xFA76ED1CuLL);
            *((_BYTE *)v13 + 8) = v11;
            memcpy((char *)v13 + 9, *(const void **)(v8 + 16), *(unsigned int *)(v8 + 24));
            objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytesNoCopy:length:", v13, v12);
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            v15 = *(_DWORD *)(v8 + 32) == 2;
            v33[0] = *(id *)(a2 + 1768);
            v16 = (void *)MEMORY[0x24BDBCE30];
            v17 = v33[0];
            objc_msgSend(v16, "arrayWithObjects:count:", v33, 1);
            v18 = (void *)objc_claimAutoreleasedReturnValue();
            v30 = 0;
            v19 = objc_msgSend(v6, "sendData:toPeers:withMode:error:", v14, v18, v15, &v30);
            v20 = v30;

            if ((v19 & 1) == 0)
            {
              v22 = *re::networkLogObjects(v21);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                v25 = v22;
                objc_msgSend(v20, "description");
                v26 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                v27 = objc_msgSend(v26, "UTF8String");
                *(_DWORD *)buf = 136315138;
                v32 = v27;
                _os_log_error_impl(&dword_21C69B000, v25, OS_LOG_TYPE_ERROR, "MPC: Error sending packet: %s.", buf, 0xCu);

              }
              v23 = *(_QWORD *)(a1 + 24);
              if (v23)
              {
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v23 + 16))(v23, a1, a2, 2);

                goto LABEL_15;
              }
            }

            v24 = (re::PacketPool **)re::PacketQueue::dequeue(*(unint64_t ***)a3);
            re::PacketPool::free(v24[7], (re::Packet *)v24);
            v8 = atomic_load(*(unint64_t **)(*(_QWORD *)a3 + 8));
          }
          while (v8);
        }
        v28 = *((_QWORD *)a3 + 1);
        v7 = *(_QWORD *)a3 + 40;
        *(_QWORD *)a3 = v7;
        ++a3[16];
      }
      while (v7 != v28);
    }
LABEL_15:

  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v29);
}

void re::MultipeerProtocolLayer::update(id *this)
{
  id v2;
  id v3;
  void *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  id v9;
  std::chrono::steady_clock::time_point v10;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  id v12;
  uint64_t v13;
  void *v14;
  id v15;
  void *v16;
  id v17;
  re *v18;
  NSObject *v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  id v23;
  uint64_t v24;
  void *v25;
  NSObject *log;
  void *v27;
  void *v28;
  __int128 v29;
  __int128 v30;
  uint64_t *v31;
  _BYTE v32[16];
  id v33;
  uint8_t buf[4];
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  id v38;
  unint64_t v39;
  char v40;
  _BYTE v41[21];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v32, 6022, (uint64_t)this);
  v2 = this[5];
  v3 = this[4];
  objc_msgSend(v2, "handlesLock");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "lock");

  v27 = v2;
  if (v2)
  {
    objc_msgSend(v2, "handles");
    if ((_QWORD)v30)
    {
      v5 = v31;
      v6 = 8 * v30;
      do
      {
        v7 = *v5;
        if (*v5)
          v8 = (id)(v7 + 8);
        if (*(_QWORD *)(v7 + 1768))
        {
          v9 = v3;
          if (!*(_BYTE *)(v7 + 1776))
          {
            v10.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
            if (v10.__d_.__rep_ >= *(_QWORD *)(v7 + 1792))
            {
              rep = v10.__d_.__rep_;
              qmemcpy(v41, "com.apple.rekit.hello", sizeof(v41));
              v12 = v9;
              v40 = -1;
              objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytesNoCopy:length:freeWhenDone:", &v39, 30, 0);
              v13 = objc_claimAutoreleasedReturnValue();
              v38 = *(id *)(v7 + 1768);
              v14 = (void *)MEMORY[0x24BDBCE30];
              v15 = v38;
              objc_msgSend(v14, "arrayWithObjects:count:", &v38, 1);
              v16 = (void *)objc_claimAutoreleasedReturnValue();
              v33 = 0;
              v28 = (void *)v13;
              LOBYTE(v13) = objc_msgSend(v12, "sendData:toPeers:withMode:error:", v13, v16, 0, &v33);

              v17 = v33;
              if ((v13 & 1) == 0)
              {
                v19 = *re::networkLogObjects(v18);
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                {
                  log = v19;
                  objc_msgSend(v17, "description");
                  v21 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                  v22 = objc_msgSend(v21, "UTF8String");
                  objc_msgSend(v17, "description");
                  v23 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                  v24 = objc_msgSend(v23, "UTF8String");
                  *(_DWORD *)buf = 136315394;
                  v35 = v22;
                  v36 = 2080;
                  v37 = v24;
                  _os_log_error_impl(&dword_21C69B000, log, OS_LOG_TYPE_ERROR, "MPC: Error sending handshake: %s, reason: %s", buf, 0x16u);

                }
              }

              v20 = 2 * *(_QWORD *)(v7 + 1784);
              if (v20 >= 8000000000)
                v20 = 8000000000;
              *(_QWORD *)(v7 + 1784) = v20;
              *(_QWORD *)(v7 + 1792) = v20 + rep;
            }
          }

        }
        ++v5;
        v6 -= 8;
      }
      while (v6);
    }
  }
  else
  {
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
  }
  objc_msgSend(v27, "handlesLock");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v25, "unlock");

  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v32);
}

void re::MultipeerProtocolLayer::wait(re::MultipeerProtocolLayer *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not implemented", "!\"Unreachable code\"", "wait", 516);
  _os_crash();
  __break(1u);
}

void re::MultipeerProtocolLayer::wakeup(re::MultipeerProtocolLayer *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not implemented", "!\"Unreachable code\"", "wakeup", 521);
  _os_crash();
  __break(1u);
}

void re::MultipeerProtocolLayer::setListener(re::MultipeerProtocolLayer *this, ProtocolLayerListener *a2)
{
  MCSessionHandler *v3;

  if (a2)
  {
    *((_QWORD *)this + 3) = a2;
    v3 = -[MCSessionHandler initWithSession:protocolLayer:]([MCSessionHandler alloc], "initWithSession:protocolLayer:", *((_QWORD *)this + 4), this);
    re::ObjCObject::operator=((void **)this + 5, v3);

  }
}

uint64_t re::MultipeerProtocolLayer::localAddresses(re::MultipeerProtocolLayer *this, re::Address *a2, uint64_t a3)
{
  if (a3)
    re::DynamicString::operator=(a2, (re::MultipeerProtocolLayer *)((char *)this + 48));
  return 1;
}

uint64_t re::MultipeerProtocolLayer::hostStats()
{
  return 0;
}

uint64_t re::MultipeerProtocolLayer::preferredThreadMode(re::MultipeerProtocolLayer *this)
{
  return 2;
}

uint64_t re::MultipeerProtocolLayer::drainsPacketSink(re::MultipeerProtocolLayer *this)
{
  return 1;
}

uint64_t re::ProtocolLayer::preferredPacketSize(re::ProtocolLayer *this)
{
  return 1200;
}

void `anonymous namespace'::MCProtocolHandle::~MCProtocolHandle(id *this)
{
  *this = &off_24E072408;

  re::ProtocolHandle::~ProtocolHandle((re::ProtocolHandle *)this);
}

{
  *this = &off_24E072408;

  re::ProtocolHandle::~ProtocolHandle((re::ProtocolHandle *)this);
  JUMPOUT(0x220780CD0);
}

BOOL `anonymous namespace'::readSignatureUnsafe(_anonymous_namespace_ *this, char *a2, uint64_t a3)
{
  int v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v9[3];

  v9[2] = *MEMORY[0x24BDAC8D0];
  if ((unint64_t)(a2 - 9) >= 0x40)
    v5 = 64;
  else
    v5 = (_DWORD)a2 - 9;
  MurmurHash3_x64_128((uint64_t)this + 9, v5, 0, v9);
  v6 = (v9[1] + (v9[0] << 6) + (v9[0] >> 2) - 0x61C8864680B583E9) ^ v9[0];
  v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a3 ^ 0x149153915)) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ 0x149153915)) >> 27));
  return *(_QWORD *)this == (((v7 ^ (v7 >> 31)) + (v6 << 6) + (v6 >> 2) - 0x61C8864680B583E9) ^ v6);
}

unint64_t *`anonymous namespace'::writeSignatureUnsafe(unint64_t *this, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9[3];

  v5 = this;
  v9[2] = *MEMORY[0x24BDAC8D0];
  if (a4 >= 0x40)
    v6 = 64;
  else
    v6 = a4;
  if (v6)
  {
    this = (unint64_t *)MurmurHash3_x64_128(a3, v6, 0, v9);
    v7 = (v9[1] - 0x61C8864680B583E9 + (v9[0] << 6) + (v9[0] >> 2)) ^ v9[0];
  }
  else
  {
    v7 = 0;
  }
  v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ 0x149153915)) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ 0x149153915)) >> 27));
  *v5 = ((v8 ^ (v8 >> 31)) - 0x61C8864680B583E9 + (v7 << 6) + (v7 >> 2)) ^ v7;
  return this;
}

void re::DynamicArray<re::SharedPtr<`anonymous namespace'::MCProtocolHandle>>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  id v25;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = a1[2];
  if (v4 >= v5)
  {
    re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    v14 = *(uint64_t **)(a2 + 32);
    v15 = a1[2];
    v16 = (uint64_t *)a1[4];
    if (v15)
    {
      v17 = 8 * v15;
      do
      {
        v18 = *v14;
        v19 = *v16;
        if (*v16 != *v14)
        {
          if (v18)
          {
            v20 = (id)(v18 + 8);
            v19 = *v16;
          }
          if (v19)

          *v16 = v18;
        }
        ++v14;
        ++v16;
        v17 -= 8;
      }
      while (v17);
      v16 = (uint64_t *)a1[4];
      v15 = a1[2];
      v14 = *(uint64_t **)(a2 + 32);
    }
    if (v15 != v4)
    {
      v21 = &v14[v15];
      v22 = &v16[v15];
      v23 = 8 * v4 - 8 * v15;
      do
      {
        v24 = *v21;
        *v22 = *v21;
        if (v24)
          v25 = (id)(v24 + 8);
        ++v21;
        ++v22;
        v23 -= 8;
      }
      while (v23);
    }
  }
  else
  {
    v6 = (uint64_t *)a1[4];
    if (v4)
    {
      v7 = *(uint64_t **)(a2 + 32);
      v8 = 8 * v4;
      do
      {
        v9 = *v7;
        v10 = *v6;
        if (*v6 != *v7)
        {
          if (v9)
          {
            v11 = (id)(v9 + 8);
            v10 = *v6;
          }
          if (v10)

          *v6 = v9;
        }
        ++v7;
        ++v6;
        v8 -= 8;
      }
      while (v8);
      v6 = (uint64_t *)a1[4];
      v5 = a1[2];
    }
    if (v4 != v5)
    {
      v12 = &v6[v4];
      v13 = 8 * v5 - 8 * v4;
      do
      {
        if (*v12)
        {

          *v12 = 0;
        }
        ++v12;
        v13 -= 8;
      }
      while (v13);
    }
  }
  a1[2] = v4;
}

void re::TransportCommandsQueued::~TransportCommandsQueued(re::TransportCommandsQueued *this)
{
  uint64_t i;

  *(_QWORD *)this = &off_24E072450;
  for (i = 64; i != -32; i -= 48)
    re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)((char *)this + i));
}

{
  uint64_t i;

  *(_QWORD *)this = &off_24E072450;
  for (i = 64; i != -32; i -= 48)
    re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)((char *)this + i));
  JUMPOUT(0x220780CD0);
}

void re::TransportCommandsQueued::async(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 120))
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)(a1 + 8), a2);
}

void re::network::EventQueue<re::Function<void ()(void)>>::push(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = a1 + 26;
  os_unfair_lock_lock(a1 + 26);
  re::Queue<re::Function<void ()(void)>>::enqueue((_anonymous_namespace_ *)&a1[12 * a1[1]._os_unfair_lock_opaque + 2], a2);
  os_unfair_lock_unlock(v4);
}

uint64_t (***re::TransportCommandsQueued::update(re::TransportCommandsQueued *this))(_QWORD)
{
  os_unfair_lock_s *v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;

  v2 = (os_unfair_lock_s *)((char *)this + 112);
  os_unfair_lock_lock((os_unfair_lock_t)this + 28);
  *((int32x2_t *)this + 1) = vrev64_s32(*(int32x2_t *)((char *)this + 8));
  os_unfair_lock_unlock(v2);
  v3 = *((_DWORD *)this + 2);
  v4 = *((_QWORD *)this + 6 * v3 + 4);
  if (v4)
  {
    v5 = 0;
    v6 = (char *)this + 48 * v3;
    v7 = v6 + 40;
    v8 = v6 + 24;
    v9 = v6 + 56;
    do
    {
      v10 = *(_QWORD *)(*v9 + 40 * ((unint64_t)(v5 + *v7) % *v8) + 32);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
      ++v5;
    }
    while (v4 != v5);
    v3 = *((_DWORD *)this + 2);
  }
  return re::Queue<re::Function<void ()(void)>>::clear((uint64_t (***)(_QWORD))this + 6 * v3 + 2);
}

uint64_t (***re::Queue<re::Function<void ()(void)>>::clear(uint64_t (***result)(_QWORD)))(_QWORD)
{
  uint64_t (***v1)(_QWORD);
  unint64_t v2;

  v1 = result;
  if (result[2])
  {
    v2 = 0;
    do
      result = re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)&v1[5][5 * (((unint64_t)v1[3] + v2++) % (unint64_t)v1[1])]);
    while (v2 < (unint64_t)v1[2]);
  }
  v1[2] = 0;
  ++*((_DWORD *)v1 + 8);
  return result;
}

uint64_t re::TransportCommandsQueued::finish(re::TransportCommandsQueued *this)
{
  *((_BYTE *)this + 120) = 1;
  return (*(uint64_t (**)(re::TransportCommandsQueued *))(*(_QWORD *)this + 24))(this);
}

re::TransportCommandsThreadedProtocol *re::TransportCommandsThreadedProtocol::TransportCommandsThreadedProtocol(re::TransportCommandsThreadedProtocol *this, re::ProtocolLayer *a2)
{
  char *v3;
  uint64_t v4;
  char *v5;
  std::__thread_struct *v6;
  _QWORD *v7;
  int v8;
  std::thread v10;
  uint64_t *v11;

  *(_QWORD *)this = &off_24E072488;
  *((_QWORD *)this + 1) = a2;
  if (a2)
    v3 = (char *)a2 + 8;
  v4 = 0;
  *((_QWORD *)this + 2) = 0x100000000;
  do
  {
    v5 = (char *)this + v4;
    *((_QWORD *)v5 + 8) = 0;
    *(_OWORD *)(v5 + 24) = 0uLL;
    *(_OWORD *)(v5 + 40) = 0uLL;
    *((_DWORD *)v5 + 14) = 0;
    v4 += 48;
  }
  while (v4 != 96);
  *((_DWORD *)this + 30) = 0;
  *((_QWORD *)this + 17) = 0;
  atomic_store(1u, (unsigned __int8 *)this + 128);
  v6 = (std::__thread_struct *)operator new();
  std::__thread_struct::__thread_struct(v6);
  v7 = (_QWORD *)operator new();
  *v7 = v6;
  v7[1] = re::TransportCommandsThreadedProtocol::threadLoop;
  v7[2] = 0;
  v7[3] = this;
  v8 = pthread_create(&v10.__t_, 0, (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>, v7);
  if (v8)
  {
    std::__throw_system_error(v8, "thread constructor failed");
LABEL_9:
    std::terminate();
  }
  v11 = 0;
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>::reset[abi:nn180100](&v11, 0);
  if (*((_QWORD *)this + 17))
    goto LABEL_9;
  *((std::thread *)this + 17) = v10;
  v10.__t_ = 0;
  std::thread::~thread(&v10);
  return this;
}

void re::TransportCommandsThreadedProtocol::threadLoop(int32x2_t *this)
{
  os_unfair_lock_s *v2;
  unsigned __int32 v3;
  int32x2_t v4;
  uint64_t v5;
  int32x2_t *v6;
  int32x2_t *v7;
  int32x2_t *v8;
  int32x2_t *v9;
  uint64_t v10;
  unsigned __int8 v11;
  int32x2_t v12;
  uint64_t v13;
  int32x2_t *v14;
  int32x2_t *v15;
  int32x2_t *v16;
  int32x2_t *v17;
  uint64_t v18;

  v2 = (os_unfair_lock_s *)&this[15];
  while (1)
  {
    os_unfair_lock_lock(v2);
    this[2] = vrev64_s32(this[2]);
    os_unfair_lock_unlock(v2);
    v3 = this[2].u32[0];
    v4 = this[6 * v3 + 5];
    if (v4)
    {
      v5 = 0;
      v6 = &this[6 * v3];
      v7 = v6 + 6;
      v8 = v6 + 4;
      v9 = v6 + 8;
      do
      {
        v10 = *(_QWORD *)(*(_QWORD *)v9 + 40 * ((unint64_t)(v5 + *(_QWORD *)v7) % *(_QWORD *)v8) + 32);
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
        ++v5;
      }
      while (*(_QWORD *)&v4 != v5);
      v3 = this[2].u32[0];
    }
    re::Queue<re::Function<void ()(void)>>::clear(&this[6 * v3 + 3]);
    v11 = atomic_load((unsigned __int8 *)&this[16]);
    if ((v11 & 1) == 0)
      break;
    (*(void (**)(_QWORD))(**(_QWORD **)&this[1] + 96))(*(_QWORD *)&this[1]);
  }
  os_unfair_lock_lock(v2);
  this[2] = vrev64_s32(this[2]);
  os_unfair_lock_unlock(v2);
  v12 = this[6 * this[2].u32[0] + 5];
  if (v12)
  {
    v13 = 0;
    v14 = &this[6 * this[2].u32[0]];
    v15 = v14 + 6;
    v16 = v14 + 4;
    v17 = v14 + 8;
    do
    {
      v18 = *(_QWORD *)(*(_QWORD *)v17 + 40 * ((unint64_t)(v13 + *(_QWORD *)v15) % *(_QWORD *)v16) + 32);
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18);
      ++v13;
    }
    while (*(_QWORD *)&v12 != v13);
    re::Queue<re::Function<void ()(void)>>::clear(&this[6 * this[2].u32[0] + 3]);
  }
}

void re::TransportCommandsThreadedProtocol::~TransportCommandsThreadedProtocol(std::thread *this)
{
  uint64_t i;
  std::__libcpp_thread_t t;

  this->__t_ = (std::__libcpp_thread_t)&off_24E072488;
  std::thread::~thread(this + 17);
  for (i = 9; i != -3; i -= 6)
    re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)&this[i]);
  t = this[1].__t_;
  if (t)
  {

    this[1].__t_ = 0;
  }
}

{
  re::TransportCommandsThreadedProtocol::~TransportCommandsThreadedProtocol(this);
  JUMPOUT(0x220780CD0);
}

void re::TransportCommandsThreadedProtocol::async(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)(a1 + 128));
  if ((v2 & 1) != 0)
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)(a1 + 16), a2);
}

void re::TransportCommandsThreadedProtocol::finish(re::TransportCommandsThreadedProtocol *this)
{
  uint64_t v2;
  uint64_t v3;

  atomic_store(0, (unsigned __int8 *)this + 128);
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 104))(v2);
  std::thread::join((std::thread *)this + 17);
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {

    *((_QWORD *)this + 1) = 0;
  }
}

uint64_t re::TransportCommandsThreadedProtocol::update(re::TransportCommandsThreadedProtocol *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 104))(result);
  return result;
}

re::TransportCommandsDispatch *re::TransportCommandsDispatch::TransportCommandsDispatch(re::TransportCommandsDispatch *this)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  *(_QWORD *)this = &off_24E0724C0;
  *((_BYTE *)this + 8) = 0;
  *((_QWORD *)this + 2) = 0;
  v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v3 = dispatch_queue_attr_make_with_qos_class(v2, QOS_CLASS_USER_INTERACTIVE, 0);
  v4 = dispatch_queue_create("com.apple.re.networking.network", v3);
  v5 = v4;
  if (v4)
    dispatch_retain(v4);
  v6 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = v5;
  if (v6)
    dispatch_release(v6);
  dispatch_release(v5);
  return this;
}

void re::TransportCommandsDispatch::async(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  _QWORD *v5;

  if (!*(_BYTE *)(a1 + 8))
  {
    v4 = re::globalAllocators((re *)a1);
    v5 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 40, 8);
    v5[3] = *(_QWORD *)(a2 + 24);
    v5[4] = 0;
    re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v5, a2);
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 16), v5, (dispatch_function_t)re::TransportCommandsDispatch::async(re::Function<void ()(void)> &&)::$_0::__invoke);
  }
}

void re::TransportCommandsDispatch::finish(re::TransportCommandsDispatch *this)
{
  NSObject *v2;

  *((_BYTE *)this + 8) = 1;
  dispatch_async_and_wait(*((dispatch_queue_t *)this + 2), &__block_literal_global_1);
  v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v2)
    dispatch_release(v2);
}

void re::TransportCommandsDispatch::~TransportCommandsDispatch(re::TransportCommandsDispatch *this)
{
  NSObject *v1;

  *(_QWORD *)this = &off_24E0724C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    dispatch_release(v1);
}

{
  NSObject *v1;

  *(_QWORD *)this = &off_24E0724C0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    dispatch_release(v1);
  JUMPOUT(0x220780CD0);
}

double re::Queue<re::Function<void ()(void)>>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = a1[5];
    if (v3)
    {
      if (a1[2])
      {
        v4 = 0;
        do
        {
          re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(a1[5] + 40
                                                                                                 * ((v4 + a1[3])
                                                                                                  % (unint64_t)a1[1]));
          ++v4;
        }
        while (v4 != a1[2]);
        v2 = *a1;
        v3 = a1[5];
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3);
    }
    a1[5] = 0;
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_DWORD *)a1 + 8) = 0;
  }
  return result;
}

uint64_t re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(a1);
    v4 = *(_QWORD *)(a2 + 32);
    if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24))
    {
      v5 = a2;
      if (v4 != a2)
      {
        *(_QWORD *)(a1 + 32) = v4;
        *(_QWORD *)(a2 + 32) = 0;
        return a1;
      }
    }
    else
    {
      v5 = *(_QWORD *)(a2 + 32);
      if (!v4)
        return a1;
    }
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    v7 = a1;
    if (v6 >= 0x19)
    {
      v8 = v6;
      v9 = *(_QWORD *)(a1 + 24);
      if (v9)
        v7 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, v8, 0);
      else
        v7 = 0;
    }
    *(_QWORD *)(a1 + 32) = v7;
    (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 32))(*(_QWORD *)(a2 + 32));
    re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(a2);
  }
  return a1;
}

uint64_t re::TransportCommandsDispatch::async(re::Function<void ()(void)> &&)::$_0::__invoke(uint64_t a1)
{
  re *v2;
  uint64_t v3;

  v2 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32));
  v3 = re::globalAllocators(v2)[2];
  re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1);
}

uint64_t re::Queue<re::Function<void ()(void)>>::enqueue(_anonymous_namespace_ *this, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t result;

  v5 = *((_QWORD *)this + 1);
  v4 = *((_QWORD *)this + 2);
  if (v4 + 1 >= v5)
  {
    re::Queue<re::Function<void ()(void)>>::growCapacity(this, v4 + 1);
    v5 = *((_QWORD *)this + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v6 = *((_QWORD *)this + 5) + 40 * ((*((_QWORD *)this + 3) + v4) % v5);
  *(_QWORD *)(v6 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(v6 + 32) = 0;
  result = re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v6, a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 8);
  return result;
}

_QWORD *re::Queue<re::Function<void ()(void)>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::Queue<re::Function<void ()(void)>>::setCapacity(this, a2);
    }
    else
    {
      this = re::Queue<re::Function<void ()(void)>>::setCapacity(v4, v3);
      v4[2] = 0;
      v4[3] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
  }
  return this;
}

_QWORD *re::Queue<re::Function<void ()(void)>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    v6 = result + 2;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::Queue<re::Function<void ()(void)>>::setCapacity(v5, a2);
        *v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v8 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        v9 = 0;
        v10 = v5[3];
        do
        {
          v11 = v5[5] + 40 * ((unint64_t)(v9 + v5[3]) % v5[1]);
          v12 = (uint64_t)&v8[5 * v10];
          *(_QWORD *)(v12 + 24) = *(_QWORD *)(v11 + 24);
          *(_QWORD *)(v12 + 32) = 0;
          re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v12, v11);
          re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(v11);
          if (v10 + 1 < a2)
            ++v10;
          else
            v10 = 0;
          ++v9;
        }
        while (v9 != v5[2]);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>(uint64_t *a1)
{
  std::__thread_specific_ptr<std::__thread_struct> *v2;
  const void *v3;
  uint64_t v4;
  void (*v5)(_QWORD *);
  _QWORD *v6;
  uint64_t *v8;

  v8 = a1;
  v2 = std::__thread_local_data();
  v3 = (const void *)*a1;
  *a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  v4 = a1[2];
  v5 = (void (*)(_QWORD *))a1[1];
  v6 = (_QWORD *)(a1[3] + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(void (**)(_QWORD *))(*v6 + v5);
  v5(v6);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>::reset[abi:nn180100](&v8, 0);
  return 0;
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t *v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](v2, 0);
    JUMPOUT(0x220780CD0);
  }
  return result;
}

uint64_t std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    MEMORY[0x220780BF8]();
    JUMPOUT(0x220780CD0);
  }
  return result;
}

re::SyncObject *re::SyncObject::SyncObject(re::SyncObject *this, re::Allocator *a2, uint64_t a3, re::Allocator *a4, unint64_t a5)
{
  _QWORD *v10;

  ArcSharedObject::ArcSharedObject(this, 0);
  *v10 = &off_24E072590;
  v10[2] = a2;
  v10[3] = a3;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = this;
  *((_QWORD *)this + 17) = 0;
  *((_WORD *)this + 72) = 0;
  *((_BYTE *)this + 152) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0x10000;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_BYTE *)this + 128) = 0;
  *((_WORD *)this + 88) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_DWORD *)this + 52) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  re::FixedArray<re::SyncObjectState>::init<>((uint64_t)(v10 + 5), (uint64_t)a4, a5);
  return this;
}

void re::SyncObject::~SyncObject(re::SyncObject *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;

  *(_QWORD *)this = &off_24E072590;
  re::SyncObject::unbindFromParent(this);
  v2 = *((_QWORD *)this + 25);
  if (v2)
  {
    v3 = (uint64_t *)*((_QWORD *)this + 27);
    v4 = 8 * v2;
    do
    {
      v5 = *v3++;
      *(_QWORD *)(v5 + 80) = 0;
      v4 -= 8;
    }
    while (v4);
  }
  v6 = *((_QWORD *)this + 14);
  *((_QWORD *)this + 25) = 0;
  ++*((_DWORD *)this + 52);
  if (v6)
  {
    v7 = *((_QWORD *)this + 15);
    if (v7)
      (*(void (**)(void))(v7 + 16))();
  }
  _Block_release(*((const void **)this + 15));
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  v8 = *((_QWORD *)this + 23);
  if (v8)
  {
    if (*((_QWORD *)this + 27))
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
    *((_QWORD *)this + 27) = 0;
    *((_QWORD *)this + 24) = 0;
    *((_QWORD *)this + 25) = 0;
    *((_QWORD *)this + 23) = 0;
    ++*((_DWORD *)this + 52);
  }
  v10 = (char *)this + 96;
  v9 = *((_QWORD *)this + 12);
  if (v9)
  {
    re::SyncView::removeObject(v9, (uint64_t)this + 96);
    if (*(_QWORD *)v10)
    {

      *(_QWORD *)v10 = 0;
    }
  }
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  re::FixedArray<re::SyncObjectState>::deinit((_QWORD *)this + 5);
  re::FixedArray<re::SyncObjectState>::deinit((_QWORD *)this + 5);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::SyncObject::~SyncObject(this);
  JUMPOUT(0x220780CD0);
}

_QWORD *re::SyncObject::unbindFromParent(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;

  v1 = (_QWORD *)this[10];
  if (v1)
  {
    this[10] = 0;
    v2 = v1[25];
    if (v2)
    {
      v3 = 0;
      while (*(_QWORD **)(v1[27] + 8 * v3) != this)
      {
        if (v2 == ++v3)
          return this;
      }
      return re::DynamicArray<re::Allocator const*>::removeStableAt(v1 + 23, v3);
    }
  }
  return this;
}

unint64_t re::SyncObject::latestStateHandle(re::SyncObject *this)
{
  uint64_t v1;
  unint64_t v3;

  v1 = *((_QWORD *)this + 9);
  if (*((_QWORD *)this + 8) == v1)
    return -1;
  v3 = *((_QWORD *)this + 6);
  if (v3 <= ((v3 - 1) & (v1 - 1)))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return ((_DWORD)v3 - 1) & (v1 - 1) | ((unint64_t)*(unsigned int *)(*((_QWORD *)this + 7)
                                                                                        + 96 * ((v3 - 1) & (v1 - 1))
                                                                                        + 80) << 32);
}

unint64_t re::SyncObject::addState(re::SyncObject *this, __int16 a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t result;

  v3 = *((_QWORD *)this + 9);
  v4 = v3 - *((_QWORD *)this + 8);
  v5 = *((_QWORD *)this + 6);
  v6 = v3 + 1;
  if (v4 == v5)
    *((_QWORD *)this + 8) = v6 - v4;
  *((_QWORD *)this + 9) = v6;
  v7 = (v5 - 1) & v3;
  if (v5 <= v7)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  result = *((_QWORD *)this + 7) + 96 * v7;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_WORD *)(result + 84) = a2;
  *(_QWORD *)(result + 88) = a3;
  ++*(_DWORD *)(result + 80);
  return result;
}

BOOL re::SyncObject::takeOverLatestState(re::SyncObject *this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v1 = *((_QWORD *)this + 8);
  v2 = *((_QWORD *)this + 9);
  if (v2 != v1)
  {
    v3 = *((_QWORD *)this + 6);
    v4 = v3 - 1;
    v5 = (v3 - 1) & (v2 - 1);
    if (v3 <= v5)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      v6 = v2 + 1;
      if (v2 - v1 == v3)
        *((_QWORD *)this + 8) = v6 - v3;
      v7 = *((_QWORD *)this + 7);
      *((_QWORD *)this + 9) = v6;
      v8 = v4 & v2;
      if (v3 > (v4 & v2))
      {
        v9 = v7 + 96 * v5;
        v10 = *(_OWORD *)(v9 + 8);
        v11 = v7 + 96 * v8;
        *(_OWORD *)(v11 + 24) = *(_OWORD *)(v9 + 24);
        *(_OWORD *)(v11 + 8) = v10;
        re::DynamicArray<unsigned char>::operator=(v11 + 40, (uint64_t *)(v9 + 40));
        *(_OWORD *)(v11 + 80) = *(_OWORD *)(v7 + 96 * v5 + 80);
        *(_WORD *)(v11 + 84) = 0;
        *(_QWORD *)(v11 + 88) = 0;
        ++*(_DWORD *)(v11 + 80);
        return v2 != v1;
      }
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v2 != v1;
}

uint64_t re::SyncObject::findBaseline(re::SyncObject *this, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *((_QWORD *)this + 8);
  v3 = *((_QWORD *)this + 9);
  if (v3 == v4)
    return 0;
  v5 = *((_QWORD *)this + 6);
  v6 = v5 - 1;
  while (1)
  {
    v7 = --v3 & v6;
    if (v5 <= (v3 & v6))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v8 = *((_QWORD *)this + 7);
    if (*(unsigned __int16 *)(v8 + 96 * v7 + 84) == a2 && *(_QWORD *)(v8 + 96 * v7 + 88) == a3)
      break;
    if (v4 == v3)
      return 0;
  }
  return v8 + 96 * v7;
}

__n128 re::SyncObject::bindWithParent(re::SyncObject *this, re::SyncObject *a2)
{
  char *v4;
  char *v5;
  re::SyncObject *v6;
  re::SyncObject *v7;
  re::SyncObject *v8;
  __n128 result;
  __int128 v10;
  re::SyncObject *v11;

  if (*((re::SyncObject **)this + 10) != a2)
  {
    *((_QWORD *)this + 10) = a2;
    v4 = (char *)this + 8;
    v5 = (char *)this + 8;
    v11 = this;
    re::DynamicArray<re::SyncCommit const*>::add((_QWORD *)a2 + 23, &v11);

    v6 = (re::SyncObject *)*((_QWORD *)this + 10);
    v7 = this;
    if (v6)
    {
      v8 = this;
      do
      {
        v7 = v8;
        v8 = v6;
        if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v7 + 11) + 16) + 73))
          break;
        v6 = (re::SyncObject *)*((_QWORD *)v6 + 10);
        v7 = v8;
      }
      while (v6);
    }
    result = *(__n128 *)((char *)v7 + 136);
    v10 = *(_OWORD *)((char *)v7 + 152);
    *((_DWORD *)this + 42) = *((_DWORD *)v7 + 42);
    *(_OWORD *)((char *)this + 152) = v10;
    *(__n128 *)((char *)this + 136) = result;
  }
  return result;
}

unint64_t re::SyncObject::getLatestState(re::SyncObject *this)
{
  uint64_t v1;
  unint64_t v3;
  unint64_t v4;

  v1 = *((_QWORD *)this + 9);
  if (*((_QWORD *)this + 8) == v1)
    return 0;
  v3 = *((_QWORD *)this + 6);
  v4 = (v3 - 1) & (v1 - 1);
  if (v3 <= v4)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *((_QWORD *)this + 7) + 96 * v4;
}

unint64_t re::SyncObject::getOldestState(re::SyncObject *this)
{
  uint64_t v1;
  unint64_t v3;
  unint64_t v4;

  v1 = *((_QWORD *)this + 8);
  if (v1 == *((_QWORD *)this + 9))
    return 0;
  v3 = *((_QWORD *)this + 6);
  v4 = (v3 - 1) & v1;
  if (v3 <= v4)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *((_QWORD *)this + 7) + 96 * v4;
}

uint64_t re::SyncObject::getState(re::SyncObject *this, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *((_QWORD *)this + 6);
  if (v2 <= a2)
    return 0;
  v3 = *((_QWORD *)this + 8);
  v4 = *((_QWORD *)this + 9);
  v5 = v4 - v3;
  if (v4 == v3)
    return 0;
  v7 = *((_QWORD *)this + 7);
  if (v5 >= v2)
    goto LABEL_12;
  v8 = v3 & (v2 - 1);
  if (v2 <= v8)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_16:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v9 = (v4 - 1) & (v2 - 1);
  if (v2 <= v9)
    goto LABEL_16;
  result = 0;
  if (v8 > v9)
    v10 = -(uint64_t)v2;
  else
    v10 = 0;
  if (-1431655765 * ((96 * (unint64_t)a2 - (96 * v8 + 96 * v10)) >> 5) < v5)
  {
LABEL_12:
    if (*(_DWORD *)(v7 + 96 * a2 + 80) == HIDWORD(a2))
      return v7 + 96 * a2;
    else
      return 0;
  }
  return result;
}

uint64_t re::SyncObject::fromPeerID(re::SyncObject *this)
{
  uint64_t v1;
  unint64_t v3;
  unint64_t v4;

  v1 = *((_QWORD *)this + 9);
  if (*((_QWORD *)this + 8) == v1)
    return 0;
  v3 = *((_QWORD *)this + 6);
  v4 = (v3 - 1) & (v1 - 1);
  if (v3 <= v4)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*((_QWORD *)this + 7) + 96 * v4 + 88);
}

uint64_t re::SyncObject::handOff(re::SyncObject *this, uint64_t a2)
{
  re::SyncObject *v2;
  re::SyncObject *v3;
  re::SyncObject *v4;
  __int16 v6;

  v2 = (re::SyncObject *)*((_QWORD *)this + 10);
  v3 = this;
  if (v2)
  {
    v4 = this;
    do
    {
      v3 = v4;
      v4 = v2;
      if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v3 + 11) + 16) + 73))
        break;
      v2 = (re::SyncObject *)*((_QWORD *)v2 + 10);
      v3 = v4;
    }
    while (v2);
  }
  if (*((_QWORD *)v3 + 20) || !*((_QWORD *)this + 20) && *((_QWORD *)this + 17))
    return 0;
  v6 = *((_WORD *)this + 84) + 1;
  *((_QWORD *)this + 17) = a2;
  *((_WORD *)this + 72) = v6;
  return 1;
}

BOOL re::SyncObject::isStateDataChanged(re::SyncObject *this, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v3 = *((_QWORD *)this + 9);
  while (*((_QWORD *)this + 8) != v3)
  {
    --v3;
    v4 = *((_QWORD *)this + 6);
    v5 = (v4 - 1) & v3;
    if (v4 <= v5)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v6 = *((_QWORD *)this + 7);
    if (*(_QWORD *)(v6 + 96 * v5 + 88) == a3)
    {
      v7 = *(unsigned __int16 *)(v6 + 96 * v5 + 84);
      if (v7 >= a2 && v7 - a2 < 0x8000)
        return 0;
      if (v7 < a2)
        return a2 - v7 < 0x8000;
      return 1;
    }
  }
  return 1;
}

BOOL re::SyncObject::shouldAcceptUpdate(re::SyncObject *this, uint64_t a2, unsigned int a3)
{
  re::SyncObject *v3;
  re::SyncObject *v4;
  uint64_t v5;
  unsigned int v6;

  v3 = (re::SyncObject *)*((_QWORD *)this + 10);
  if (v3)
  {
    do
    {
      v4 = this;
      this = v3;
      if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v4 + 11) + 16) + 73))
        break;
      v3 = (re::SyncObject *)*((_QWORD *)v3 + 10);
      v4 = this;
    }
    while (v3);
  }
  else
  {
    v4 = this;
  }
  v5 = *((_QWORD *)v4 + 20);
  v6 = *((unsigned __int16 *)v4 + 84);
  if (v5 == a2)
  {
    if (v6 > a3 || a3 - v6 >= 0x8000)
      return v6 > a3 && ((v6 - a3) & 0xFFFF8000) != 0;
    else
      return 1;
  }
  else if (v6 < a3 || v6 - a3 >= 0x8000)
  {
    return v6 >= a3 || a3 - v6 < 0x8000;
  }
  else
  {
    return 0;
  }
}

void re::SyncObject::setViewDirectly(re::SyncObject *this, re::SyncView *a2)
{
  re::SyncView *v2;
  uint64_t *v3;

  if (!a2 || (*((_BYTE *)this + 128) & 4) == 0)
  {
    v3 = (uint64_t *)((char *)this + 96);
    v2 = (re::SyncView *)*((_QWORD *)this + 12);
    if (v2 != a2)
    {
      if (a2)
        re::SyncView::transferObject((uint64_t)a2, v3);
      else
        re::SyncView::removeObject((uint64_t)v2, (uint64_t)v3);
    }
  }
}

void *re::SyncObject::setUserData(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6;
  void *result;

  if (*(_QWORD *)(a1 + 112))
  {
    v6 = *(_QWORD *)(a1 + 120);
    if (v6)
      (*(void (**)(void))(v6 + 16))();
  }
  _Block_release(*(const void **)(a1 + 120));
  *(_QWORD *)(a1 + 112) = a2;
  result = _Block_copy(a3);
  *(_QWORD *)(a1 + 120) = result;
  return result;
}

_QWORD *re::FixedArray<re::SyncObjectState>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = 96 * v2;
      v5 = (_QWORD *)(result[2] + 72);
      do
      {
        v6 = *(v5 - 4);
        if (v6)
        {
          if (*v5)
            (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
          *v5 = 0;
          *(v5 - 3) = 0;
          *(v5 - 2) = 0;
          *(v5 - 4) = 0;
          ++*((_DWORD *)v5 - 2);
        }
        v5 += 12;
        v4 -= 96;
      }
      while (v4);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

uint64_t re::FixedArray<re::SyncObjectState>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  if (!a3)
    return result;
  if (a3 >= 0x2AAAAAAAAAAAAABLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 96, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v4 = result;
  result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 96 * a3, 8);
  *(_QWORD *)(v4 + 16) = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(_OWORD *)(result + 40) = 0uLL;
      *(_OWORD *)(result + 56) = 0uLL;
      *(_OWORD *)(result + 72) = 0uLL;
      *(_OWORD *)(result + 24) = 0uLL;
      *(_OWORD *)(result + 8) = 0uLL;
      *(_QWORD *)result = &off_24E072690;
      *(_QWORD *)(result + 40) = 0;
      *(_QWORD *)(result + 48) = 0;
      *(_QWORD *)(result + 56) = 0;
      *(_DWORD *)(result + 64) = 0;
      *(_WORD *)(result + 84) = 0;
      *(_QWORD *)(result + 88) = 0;
      result += 96;
      --v6;
    }
    while (v6);
  }
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 8) = 0u;
  *(_QWORD *)result = &off_24E072690;
  *(_QWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 56) = 0;
  *(_DWORD *)(result + 64) = 0;
  *(_WORD *)(result + 84) = 0;
  *(_QWORD *)(result + 88) = 0;
  return result;
}

double RESyncCreateSyncObjectReadContext(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 80, 8);
  result = 0.0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_DWORD *)(v2 + 68) = 0x7FFFFFFF;
  return result;
}

re *RESyncDestroySyncObjectReadContext(re *result)
{
  re *v1;
  uint64_t v2;
  double v3;

  if (result)
  {
    v1 = result;
    v2 = re::globalAllocators(result)[2];
    v3 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v1 + 4);
    return (re *)(*(uint64_t (**)(uint64_t, re *, double))(*(_QWORD *)v2 + 40))(v2, v1, v3);
  }
  return result;
}

uint64_t RESyncGetSyncObjectReadContextRequiredSize()
{
  return 80;
}

uint64_t RESyncCreateSyncObjectReadContextNoAlloc(uint64_t result, unint64_t a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (!result)
  {
    v2 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      return 0;
    v3 = 136315394;
    v4 = "RESyncCreateSyncObjectReadContextNoAlloc";
    v5 = 2080;
    v6 = "bytes != __null";
LABEL_10:
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  if (a2 <= 0x4F)
  {
    v2 = *re::networkLogObjects((re *)result);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      return 0;
    v3 = 136315394;
    v4 = "RESyncCreateSyncObjectReadContextNoAlloc";
    v5 = 2080;
    v6 = "size >= sizeof(SyncObjectReadContext)";
    goto LABEL_10;
  }
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)result = 0u;
  *(_DWORD *)(result + 68) = 0x7FFFFFFF;
  return result;
}

void RESyncDestroySyncObjectReadContextNoDealloc(uint64_t a1)
{
  NSObject *v1;
  int v2;
  const char *v3;
  __int16 v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)(a1 + 32));
  }
  else
  {
    v1 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      v2 = 136315394;
      v3 = "RESyncDestroySyncObjectReadContextNoDealloc";
      v4 = 2080;
      v5 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v1, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v2, 0x16u);
    }
  }
}

BOOL RESyncAddSyncObjectReadContextEntry(re *a1, uint64_t a2, uint64_t a3)
{
  re *v3;
  NSObject *v4;
  _BOOL8 result;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v10 = (const char *)a3;
  v11 = a2;
  if (!a1)
  {
    v9 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v13 = "RESyncAddSyncObjectReadContextEntry";
    v14 = 2080;
    v15 = "context != __null";
    v6 = "%s: Invalid parameter not satisfying %s.";
    goto LABEL_13;
  }
  if (!a2)
  {
    v9 = *re::networkLogObjects(a1);
    result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136315394;
    v13 = "RESyncAddSyncObjectReadContextEntry";
    v14 = 2080;
    v15 = "entry != __null";
    v6 = "%s: Invalid parameter not satisfying %s.";
LABEL_13:
    v7 = v9;
    v8 = 22;
    goto LABEL_6;
  }
  v3 = (re *)re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>((uint64_t)a1 + 32, (uint64_t *)&v10, &v11);
  if (*(_QWORD *)v3 == v11)
    return 1;
  v4 = *re::networkLogObjects(v3);
  result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 134217984;
    v13 = v10;
    v6 = "RESyncAddSyncObjectReadContextEntry: Failed to add entry using id=%llu, possible duplicate!";
    v7 = v4;
    v8 = 12;
LABEL_6:
    _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    return 0;
  }
  return result;
}

uint64_t RESyncGetSyncObjectReadContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = (const char *)a2;
  if (a1)
  {
    v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 32, (uint64_t *)&v6);
    if (v2)
      return *(_QWORD *)v2;
    v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      v8 = v6;
      _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_INFO, "RESyncGetSyncObjectReadContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
    }
  }
  else
  {
    v5 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v8 = "RESyncGetSyncObjectReadContextEntry";
      v9 = 2080;
      v10 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
  }
  return 0;
}

BOOL RESyncRemoveSyncObjectReadContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 result;
  NSObject *v4;
  _BOOL4 v5;
  NSObject *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v7 = (const char *)a2;
  if (a1)
  {
    v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1 + 32, (uint64_t *)&v7);
    if ((v2 & 1) != 0)
      return 1;
    v4 = *re::networkLogObjects((re *)v2);
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v5)
    {
      *(_DWORD *)buf = 134217984;
      v9 = v7;
      _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "RESyncRemoveSyncObjectReadContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    v6 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_DWORD *)buf = 136315394;
      v9 = "RESyncRemoveSyncObjectReadContextEntry";
      v10 = 2080;
      v11 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t RESyncObjectReadContextGetSession(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)a1;
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncObjectReadContextGetSession";
    v5 = 2080;
    v6 = "context != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncObjectReadContextGetSourcePeerID(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 8);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncObjectReadContextGetSourcePeerID";
    v5 = 2080;
    v6 = "context != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncObjectReadContextGetSyncableGuid(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 16);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncObjectReadContextGetSyncableGuid";
    v5 = 2080;
    v6 = "context != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

BOOL RESyncObjectReadContextSupportsProtocolLevelAlmond(uint64_t a1)
{
  return RESyncObjectReadContextSupportsProtocolLevel(a1, 8);
}

BOOL RESyncObjectReadContextSupportsProtocolLevel(uint64_t a1, int a2)
{
  _BOOL8 result;
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return (a2 & ~*(_DWORD *)(a1 + 24)) == 0;
  v3 = *re::networkLogObjects(0);
  result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v4 = 136315394;
    v5 = "RESyncObjectReadContextSupportsProtocolLevel";
    v6 = 2080;
    v7 = "context != __null";
    _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v4, 0x16u);
    return 0;
  }
  return result;
}

BOOL RESyncObjectReadContextSupportsProtocolLevelPistachio(uint64_t a1)
{
  return RESyncObjectReadContextSupportsProtocolLevel(a1, 16);
}

BOOL RESyncObjectReadContextSupportsProtocolLevelWalnut(uint64_t a1)
{
  return RESyncObjectReadContextSupportsProtocolLevel(a1, 32);
}

BOOL RESyncObjectReadContextIsLocalSession(uint64_t a1)
{
  _BOOL8 v1;
  NSObject *v3;
  _BYTE v4[12];
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)a1 + 32))(v4);
    v1 = *(_BYTE *)(*(_QWORD *)v4 + 2219) != 0;

  }
  else
  {
    v3 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v4 = 136315394;
      *(_QWORD *)&v4[4] = "RESyncObjectReadContextIsLocalSession";
      v5 = 2080;
      v6 = "context != __null";
      _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", v4, 0x16u);
    }
    return 0;
  }
  return v1;
}

double re::Packet::swap(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  double result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v2;
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  LODWORD(v3) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v3;
  result = *(double *)(a2 + 28);
  v5 = *(_QWORD *)(a1 + 28);
  *(double *)(a1 + 28) = result;
  *(_QWORD *)(a2 + 28) = v5;
  v6 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v6;
  v7 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v7;
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v8;
  return result;
}

void re::PacketPool::free(re::PacketPool *this, re::Packet *a2)
{
  uint64_t v4;
  int v5;
  os_unfair_lock_s *v6;
  unsigned int v7;
  unsigned int v8;
  int32x2_t v9;
  uint64_t v10;
  re *v11;
  uint64_t *v12;
  uint64_t v13;

  v4 = *((_QWORD *)a2 + 1);
  v5 = *((_DWORD *)a2 + 7) + *((_DWORD *)a2 + 4) - v4;
  *((_QWORD *)a2 + 2) = v4;
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 7) = v5;
  v6 = (os_unfair_lock_s *)((char *)this + 128);
  os_unfair_lock_lock((os_unfair_lock_t)this + 32);
  v7 = *((_DWORD *)a2 + 7);
  if (v7 <= *((_DWORD *)this + 38) && (v8 = *((_DWORD *)this + 35) + v7, v8 <= *((_DWORD *)this + 39)))
  {
    v13 = *((_QWORD *)this + 14);
    *((_QWORD *)this + 14) = a2;
    *((_QWORD *)a2 + 6) = v13;
    LODWORD(v13) = *((_DWORD *)this + 36) + 1;
    *((_DWORD *)this + 35) = v8;
    *((_DWORD *)this + 36) = v13;
  }
  else
  {
    v9 = *(int32x2_t *)((char *)this + 132);
    LODWORD(v10) = vsub_s32(v9, (int32x2_t)(v7 | 0xFFFFFFFF00000000)).u32[0];
    HIDWORD(v10) = vadd_s32(v9, (int32x2_t)-1).i32[1];
    *(_QWORD *)((char *)this + 132) = v10;
    v11 = (re *)(*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), *((_QWORD *)a2 + 1));
    v12 = re::globalAllocators(v11);
    (*(void (**)(uint64_t, re::Packet *))(*(_QWORD *)v12[2] + 40))(v12[2], a2);
  }
  os_unfair_lock_unlock(v6);
}

unint64_t *re::PacketQueue::dequeue(unint64_t **this)
{
  uint64_t v1;
  unint64_t *result;
  unsigned int *v4;
  int v5;
  unsigned int v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;

  v1 = atomic_load(this[1]);
  if (!v1)
    return 0;
  re::Packet::swap((uint64_t)this[1], v1);
  result = this[1];
  this[1] = (unint64_t *)v1;
  v4 = (unsigned int *)(this + 3);
  v5 = *((_DWORD *)result + 6);
  do
    v6 = __ldxr(v4);
  while (__stlxr(v6 - v5, v4));
  v7 = (unint64_t *)(this + 4);
  v8 = *((unsigned int *)result + 7);
  do
    v9 = __ldxr(v7);
  while (__stlxr(v9 - v8, v7));
  v10 = (unint64_t *)(this + 2);
  do
    v11 = __ldxr(v10);
  while (__stlxr(v11 - 1, v10));
  atomic_store(0, result);
  return result;
}

uint64_t re::InlineString<32ul>::assignf(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *a1 = 0;
  return re::InlineString<32ul>::vappendf(a1, "PacketPool%s", &a9);
}

void re::PacketPool::~PacketPool(re::PacketPool *this)
{
  uint64_t i;
  int32x2_t v3;
  int32x2_t v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;

  *(_QWORD *)this = &off_24E0725D8;
  for (i = *((_QWORD *)this + 14); i; i = *((_QWORD *)this + 14))
  {
    *((_QWORD *)this + 14) = *(_QWORD *)(i + 48);
    v3 = *(int32x2_t *)((char *)this + 140);
    v4.i32[1] = -1;
    v4.i32[0] = *(_DWORD *)(i + 28);
    v4.i32[0] = vsub_s32(v3, v4).u32[0];
    v4.i32[1] = vadd_s32(v3, (int32x2_t)-1).i32[1];
    *(_QWORD *)(i + 48) = 0;
    *(int32x2_t *)((char *)this + 140) = v4;
    v5 = (re *)(*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), *(_QWORD *)(i + 8));
    v6 = re::globalAllocators(v5);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6[2] + 40))(v6[2], i);
  }
  v7 = *((_QWORD *)this + 3);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 20) = 0;
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::PacketPool::~PacketPool(this);
  JUMPOUT(0x220780CC4);
}

void re::PacketPool::make(re::PacketPool *this@<X0>, re::MallocZoneAllocator *a2@<X1>, uint64_t *a3@<X8>)
{
  re::MallocZoneAllocator *v5;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  const char *v19;
  _DWORD *v20;
  const char *v21;
  _DWORD *v22;
  _DWORD *v23;
  _BYTE v24[4];
  _BYTE v25[4];

  v5 = this;
  v7 = re::globalAllocators(this);
  v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7[2] + 32))(v7[2], 256, 64);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v8, 0);
  *(_QWORD *)v8 = &off_24E0725D8;
  *(_QWORD *)(v8 + 24) = 0;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_DWORD *)(v8 + 96) = 0;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 132) = 0u;
  *(_QWORD *)(v8 + 148) = 0x10000000002000;
  *(_DWORD *)(v8 + 156) = 0x1000000;
  *(_OWORD *)(v8 + 176) = 0u;
  v17 = &unk_21C704343;
  *(_QWORD *)(v8 + 192) = 0;
  if (a2)
    LOBYTE(v17) = (_BYTE)a2;
  *(_OWORD *)(v9 + 160) = 0uLL;
  re::InlineString<32ul>::assignf((unint64_t *)(v9 + 160), v10, v11, v12, v13, v14, v15, v16, (char)v17);
  if (!v5)
  {
    v5 = (re::MallocZoneAllocator *)operator new();
    re::MallocZoneAllocator::MallocZoneAllocator(v5, (const char *)(v8 + 168), 1);
  }
  *(_QWORD *)(v8 + 24) = v5;
  re::Defaults::intValue((re::Defaults *)"network.packetpool.minPacketSize", v18, (uint64_t)v24);
  if (v24[0])
    v20 = v25;
  else
    v20 = (_DWORD *)(v8 + 148);
  *(_DWORD *)(v8 + 148) = *v20;
  re::Defaults::intValue((re::Defaults *)"network.packetpool.maxFreePacketSize", v19, (uint64_t)v24);
  if (v24[0])
    v22 = v25;
  else
    v22 = (_DWORD *)(v8 + 152);
  *(_DWORD *)(v8 + 152) = *v22;
  re::Defaults::intValue((re::Defaults *)"network.packetpool.maxFreePacketPoolMemory", v21, (uint64_t)v24);
  v23 = (_DWORD *)(v8 + 156);
  if (v24[0])
    v23 = v25;
  *(_DWORD *)(v8 + 156) = *v23;
  *a3 = v8;
}

void re::PacketPool::emitAriadneSignpost(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v1;

  v1 = this + 32;
  os_unfair_lock_lock(this + 32);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  os_unfair_lock_unlock(v1);
}

char *re::PacketPool::allocate(re::PacketPool *this, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  int32x2_t v9;
  uint64_t v10;
  unsigned int v11;
  re *v12;
  uint64_t v13;
  re *v14;
  uint64_t *v15;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  char *result;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v4 = (os_unfair_lock_s *)((char *)this + 128);
  os_unfair_lock_lock((os_unfair_lock_t)this + 32);
  v6 = (char *)this + 64;
  while (1)
  {
    v7 = v6;
    v6 = (char *)*((_QWORD *)v6 + 6);
    if (!v6)
      break;
    LODWORD(v8) = *((_DWORD *)v6 + 7);
    if (v8 >= a2)
    {
      *((_QWORD *)v7 + 6) = *((_QWORD *)v6 + 6);
      *((_QWORD *)v6 + 6) = 0;
      v9 = *(int32x2_t *)((char *)this + 140);
      LODWORD(v10) = vsub_s32(v9, (int32x2_t)(v8 | 0xFFFFFFFF00000000)).u32[0];
      HIDWORD(v10) = vadd_s32(v9, (int32x2_t)-1).i32[1];
      *(_QWORD *)((char *)this + 140) = v10;
      goto LABEL_10;
    }
  }
  v11 = *((_DWORD *)this + 37);
  if (v11 <= a2)
    v8 = a2;
  else
    v8 = v11;
  v12 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3), v8, 0);
  if (!v12)
  {
    re::internal::assertLog((re::internal *)0xA, v13, "assertion failure: '%s' (%s:line %i) [Network] Failed to allocate packet buffer of size %u(%u), totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u", "false", "allocate", 188, v8, a2, *((unsigned int *)this + 34), *((unsigned int *)this + 33), *((unsigned int *)this + 36), *((unsigned int *)this + 35));
    result = (char *)_os_crash();
    __break(1u);
    return result;
  }
  v14 = v12;
  v15 = re::globalAllocators(v12);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15[2] + 32))(v15[2], 64, 64);
  v6 = (char *)v5;
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = v14;
  *(_QWORD *)(v5 + 16) = v14;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 28) = v8;
  *(_DWORD *)(v5 + 32) = 0;
  *(_QWORD *)(v5 + 40) = 0;
  *(_QWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 56) = this;
  *(int32x2_t *)((char *)this + 132) = vadd_s32(*(int32x2_t *)((char *)this + 132), (int32x2_t)(v8 | 0x100000000));
LABEL_10:
  if (v8 > *((_DWORD *)this + 38))
  {
    v16 = *re::networkLogObjects((re *)v5);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *((_DWORD *)v6 + 7);
      v19 = *((_DWORD *)this + 33);
      v18 = *((_DWORD *)this + 34);
      v21 = *((_DWORD *)this + 35);
      v20 = *((_DWORD *)this + 36);
      *(_DWORD *)buf = 67110144;
      v24 = v17;
      v25 = 1024;
      v26 = v18;
      v27 = 1024;
      v28 = v19;
      v29 = 1024;
      v30 = v20;
      v31 = 1024;
      v32 = v21;
      _os_log_impl(&dword_21C69B000, v16, OS_LOG_TYPE_DEFAULT, "Large packet buffer allocated: %u, totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u", buf, 0x20u);
    }
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

uint64_t re::SessionParticipant::SessionParticipant(uint64_t a1, uint64_t a2, int a3, char *a4, size_t a5)
{
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24E072620;
  *(_QWORD *)(a1 + 24) = a2;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = 0;
  v11 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(a1 + 40), 0);
  *(_DWORD *)(a1 + 72) = a3;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(a1 + 80), 0);
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  if (a4 && a5 && a5 <= 0x400000)
    re::DynamicArray<unsigned char>::copy((_QWORD *)(a1 + 112), 0, a4, a5);
  return a1;
}

uint64_t re::SessionParticipant::SessionParticipant(uint64_t a1, uint64_t a2, uint64_t a3, const re::DynamicString *a4, int a5, char *a6, size_t a7)
{
  _anonymous_namespace_ *v14;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24E072620;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  v14 = re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), a4);
  *(_DWORD *)(a1 + 72) = a5;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(a1 + 80), 0);
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  if (a6 && a7 && a7 <= 0x400000)
    re::DynamicArray<unsigned char>::copy((_QWORD *)(a1 + 112), 0, a6, a7);
  return a1;
}

void re::SessionParticipant::~SessionParticipant(re::SessionParticipant *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_24E072620;
  v2 = *((_QWORD *)this + 19);
  if (v2)
  {

    *((_QWORD *)this + 19) = 0;
  }
  v3 = *((_QWORD *)this + 14);
  if (v3)
  {
    if (*((_QWORD *)this + 18))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 18) = 0;
    *((_QWORD *)this + 15) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 14) = 0;
    ++*((_DWORD *)this + 34);
  }
  v4 = *((_QWORD *)this + 10);
  if (v4)
  {
    if ((*((_BYTE *)this + 88) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 12));
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 6) = 0u;
  }
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_24E072620;
  v2 = *((_QWORD *)this + 19);
  if (v2)
  {

    *((_QWORD *)this + 19) = 0;
  }
  v3 = *((_QWORD *)this + 14);
  if (v3)
  {
    if (*((_QWORD *)this + 18))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 18) = 0;
    *((_QWORD *)this + 15) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 14) = 0;
    ++*((_DWORD *)this + 34);
  }
  v4 = *((_QWORD *)this + 10);
  if (v4)
  {
    if ((*((_BYTE *)this + 88) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 12));
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 6) = 0u;
  }
  v5 = *((_QWORD *)this + 5);
  if (v5)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

BOOL re::BitWriter::rollbackTo(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;

  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = 0;
  if (HIDWORD(a2))
    v2 = a2 + 1;
  else
    v2 = a2;
  v3 = *(_DWORD *)(a1 + 16);
  *(_BYTE *)(a1 + 20) = v2 > v3;
  if (HIDWORD(a2) && v2 <= v3)
    *(_QWORD *)(a1 + 32) = (0xFFuLL >> (8 - BYTE4(a2))) & *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + a2);
  return v2 <= v3;
}

uint64_t re::BitWriter::writeUInt32Bits(uint64_t this, unsigned int a2, unsigned int a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;

  if (!*(_BYTE *)(this + 20))
  {
    v5 = this;
    v6 = *(_DWORD *)(this + 16);
    v7 = *(_DWORD *)(this + 24);
    v8 = *(_DWORD *)(this + 28);
    v9 = 8 * (v6 - v7) - v8;
    v10 = a3 >= v9;
    v11 = a3 - v9;
    if (v11 != 0
      && v10
      && (this = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)this + 16))(this, (v11 >> 3) + 1),
          v6 = *(_DWORD *)(v5 + 16),
          v7 = *(_DWORD *)(v5 + 24),
          v8 = *(_DWORD *)(v5 + 28),
          8 * (v6 - v7) - v8 < a3))
    {
      *(_DWORD *)(v5 + 24) = v6;
      *(_DWORD *)(v5 + 28) = 0;
      *(_BYTE *)(v5 + 20) = 1;
    }
    else
    {
      v12 = ((unint64_t)a2 << v8) | *(_QWORD *)(v5 + 32);
      *(_QWORD *)(v5 + 32) = v12;
      v13 = v8 + a3;
      *(_DWORD *)(v5 + 28) = v13;
      if (v13 >= 8)
      {
        do
        {
          v14 = *(_QWORD *)(v5 + 8);
          v15 = *(unsigned int *)(v5 + 24);
          *(_DWORD *)(v5 + 24) = v15 + 1;
          *(_BYTE *)(v14 + v15) = v12;
          v12 = *(_QWORD *)(v5 + 32) >> 8;
          *(_QWORD *)(v5 + 32) = v12;
          v13 = *(_DWORD *)(v5 + 28) - 8;
          *(_DWORD *)(v5 + 28) = v13;
        }
        while (v13 > 7);
        v7 = *(_DWORD *)(v5 + 24);
        v6 = *(_DWORD *)(v5 + 16);
      }
      if (v7 < v6)
        *(_BYTE *)(*(_QWORD *)(v5 + 8) + v7) = (-1 << v13) & *(_BYTE *)(*(_QWORD *)(v5 + 8) + v7) | v12 & ~(-1 << v13);
    }
  }
  return this;
}

uint64_t re::BitWriter::writeUInt64Bits(re::BitWriter *this, unint64_t a2, unsigned int a3)
{
  unsigned int v3;
  unint64_t v4;
  re::BitWriter *v5;

  v3 = a3;
  v4 = a2;
  v5 = this;
  if (a3 >= 0x21)
  {
    re::BitWriter::writeUInt32Bits((uint64_t)this, a2, 0x20u);
    a2 = HIDWORD(v4);
    a3 = v3 - 32;
    this = v5;
  }
  return re::BitWriter::writeUInt32Bits((uint64_t)this, a2, a3);
}

uint64_t re::BitWriter::writeUInt32At(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t result;

  if ((a2 + 4) > *(_DWORD *)(a1 + 16))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Marker is out of bounds", "marker.byteOffset + 4 <= m_dataSize", "writeUInt32At", 84);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 24);
    re::BitWriter::rollbackTo(a1, a2);
    re::BitWriter::writeUInt32Bits(a1, a3, 0x20u);
    return re::BitWriter::rollbackTo(a1, v5);
  }
  return result;
}

uint64_t re::BitWriter::writeData(re::BitWriter *this, const void *a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  v3 = a3;
  if (!a2 && (_DWORD)a3)
  {
    re::internal::assertLog((re::internal *)5, 0, "assertion failure: '%s' (%s:line %i) data==null, dataSize==%u", "!(data == nullptr && dataSize > 0)", "writeData", 117, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    if (re::BitWriter::bytesLeft(this, (uint64_t)a2) < a3)
    {
      v7 = re::BitWriter::bytesLeft(this, v6);
      (*(void (**)(re::BitWriter *, _QWORD))(*(_QWORD *)this + 16))(this, v3 - v7);
      if (re::BitWriter::bytesLeft(this, v8) < v3)
      {
        *((_DWORD *)this + 6) = *((_DWORD *)this + 4);
        *((_DWORD *)this + 7) = 0;
        *((_BYTE *)this + 20) = 1;
        return *((_BYTE *)this + 20) == 0;
      }
    }
    re::BitWriter::alignToByte(this);
    v10 = *((_QWORD *)this + 1);
    if (v10)
    {
      if (a2)
      {
        if (v3)
        {
          memcpy((void *)(v10 + *((unsigned int *)this + 6)), a2, v3);
          *((_DWORD *)this + 6) += v3;
          *((_QWORD *)this + 4) = 0;
        }
      }
      return *((_BYTE *)this + 20) == 0;
    }
  }
  re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) memcpy destination data is null", "m_data != nullptr", "operator()", 120);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::BitWriter::bytesLeft(re::BitWriter *this, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  unsigned int v5;
  int v6;
  uint64_t result;

  v2 = *((_DWORD *)this + 4);
  v3 = *((_DWORD *)this + 6);
  v4 = v2 >= v3;
  v5 = v2 - v3;
  if (v4)
  {
    v6 = *((_DWORD *)this + 7);
    if (v5 != 0 && v4)
    {
      if (v6)
        v6 = -1;
      else
        v6 = 0;
    }
    else if (v6)
    {
      goto LABEL_10;
    }
    return v5 + v6;
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Writer is in inconsistent state", "m_dataSize >= m_byteOffset", "bytesLeft", 171);
  _os_crash();
  __break(1u);
LABEL_10:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Writer is in inconsistent state", "m_byteOffset < m_dataSize || m_bitOffset == 0", "bytesLeft", 172);
  result = _os_crash();
  __break(1u);
  return result;
}

_DWORD *re::BitWriter::alignToByte(_DWORD *this)
{
  _DWORD *v1;
  int v2;
  int v3;
  unsigned int v4;
  int v5;

  v1 = this;
  v2 = this[6];
  v3 = this[7];
  v4 = 8 - v3;
  if (8 * (this[4] - v2) != 8
    && 8 - v3 >= (8 * (this[4] - v2) - v3)
    && (this = (_DWORD *)(*(uint64_t (**)(_DWORD *, _QWORD))(*(_QWORD *)this + 16))(this, ((8 - 8 * (this[4] - v2)) >> 3) + 1), v5 = v1[4], v2 = v1[6], v3 = v1[7], 8 * (v5 - v2) - v3 < v4))
  {
    v1[6] = v5;
    v1[7] = 0;
    *((_BYTE *)v1 + 20) = 1;
  }
  else
  {
    if (v3)
      ++v2;
    v1[6] = v2;
    v1[7] = 0;
    *((_QWORD *)v1 + 4) = 0;
  }
  return this;
}

void *re::BitWriter::copyDataTo(re::BitWriter *this, void *__dst, size_t a3)
{
  size_t v3;
  void *result;

  LODWORD(v3) = *((_DWORD *)this + 6);
  if (*((_DWORD *)this + 7))
    v3 = (v3 + 1);
  else
    v3 = v3;
  if (v3 >= a3)
    return memcpy(__dst, *((const void **)this + 1), a3);
  re::internal::assertLog((re::internal *)4, (uint64_t)__dst, "assertion failure: '%s' (%s:line %i) ", "bytesToCopy <= size()", "copyDataTo", 204);
  result = (void *)_os_crash();
  __break(1u);
  return result;
}

void re::DynamicBitWriter::grow(re::DynamicBitWriter *this, unsigned int a2)
{
  char *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  v3 = (char *)this + 40;
  v4 = *((_QWORD *)this + 7);
  v5 = v4 + a2;
  v6 = 2 * v4;
  if (v6 <= v5)
    v7 = v5;
  else
    v7 = v6;
  re::DynamicArray<unsigned char>::resize((uint64_t)v3, v7);
  *((_QWORD *)this + 1) = *((_QWORD *)this + 9);
  *((_DWORD *)this + 4) = *((_QWORD *)this + 7);
}

uint64_t re::BackedBitWriter::grow(uint64_t this, int a2)
{
  uint64_t (*v2)(_QWORD, _QWORD);
  uint64_t v3;
  int v4;

  v2 = *(uint64_t (**)(_QWORD, _QWORD))(this + 40);
  if (v2)
  {
    v3 = this;
    v4 = *(_DWORD *)(this + 16) + a2;
    this = v2(*(_QWORD *)(this + 48), *(_QWORD *)(this + 8));
    *(_QWORD *)(v3 + 8) = this;
    *(_DWORD *)(v3 + 16) = v4;
  }
  return this;
}

void re::BitWriter::~BitWriter(re::BitWriter *this)
{
  JUMPOUT(0x220780CD0);
}

void re::DynamicBitWriter::~DynamicBitWriter(re::DynamicBitWriter *this)
{
  uint64_t v2;
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if (*((_QWORD *)this + 9))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 9) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 16);
  }
}

{
  uint64_t v2;
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if (*((_QWORD *)this + 9))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 9) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 16);
  }
  JUMPOUT(0x220780CD0);
}

void re::BackedBitWriter::~BackedBitWriter(re::BackedBitWriter *this)
{
  JUMPOUT(0x220780CD0);
}

double re::NetworkSyncManager::NetworkSyncManager(re::NetworkSyncManager *this)
{
  double result;

  ArcSharedObject::ArcSharedObject(this, 0);
  *((_QWORD *)this + 31) = 0;
  *(_QWORD *)this = &off_24E072720;
  result = 0.0;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *((_QWORD *)this + 29) = 0;
  *((_DWORD *)this + 60) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_DWORD *)this + 56) = 0;
  *((_OWORD *)this + 16) = 0u;
  *((_DWORD *)this + 68) = 0;
  *((_QWORD *)this + 40) = 0;
  *((_DWORD *)this + 82) = 0;
  *((_DWORD *)this + 78) = 0;
  *((_QWORD *)this + 42) = 0;
  *((_DWORD *)this + 90) = 0;
  *((_QWORD *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *((_DWORD *)this + 100) = 0;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_QWORD *)this + 55) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_QWORD *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *((_DWORD *)this + 122) = 0;
  *((_QWORD *)this + 66) = 0;
  *((_DWORD *)this + 134) = 0;
  *((_OWORD *)this + 32) = 0u;
  *((_QWORD *)this + 73) = 0;
  *((_DWORD *)this + 148) = 0;
  *((_DWORD *)this + 144) = 0;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_DWORD *)this + 156) = 0;
  *((_QWORD *)this + 77) = 0;
  *((_QWORD *)this + 84) = 0;
  *((_DWORD *)this + 170) = 0;
  *((_DWORD *)this + 166) = 0;
  *((_OWORD *)this + 43) = 0u;
  *((_DWORD *)this + 178) = 0;
  *((_QWORD *)this + 88) = 0;
  *((_QWORD *)this + 95) = 0;
  *((_DWORD *)this + 192) = 0;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((_DWORD *)this + 188) = 0;
  *((_DWORD *)this + 200) = 0;
  *((_QWORD *)this + 99) = 0;
  *((_QWORD *)this + 106) = 0;
  *((_DWORD *)this + 214) = 0;
  *((_DWORD *)this + 210) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 48) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 22) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 32) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 46) = 0;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  return result;
}

void re::NetworkSyncManager::~NetworkSyncManager(re::NetworkSyncManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  re *v10;
  NSObject *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint8_t v29[16];

  *(_QWORD *)this = &off_24E072720;
  if (*((_BYTE *)this + 48))
  {
    re::NetworkSyncManager::stopSync(this);
    re::NetworkSyncManager::removeDeferredSessions(this);
    v2 = *((_QWORD *)this + 19);
    if (v2)
    {

      *((_QWORD *)this + 19) = 0;
    }
    v3 = *((_QWORD *)this + 53);
    if (v3)
    {
      if (*((_QWORD *)this + 57))
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
      *((_QWORD *)this + 57) = 0;
      *((_QWORD *)this + 54) = 0;
      *((_QWORD *)this + 55) = 0;
      *((_QWORD *)this + 53) = 0;
      ++*((_DWORD *)this + 112);
    }
    v4 = *((_QWORD *)this + 42);
    if (v4)
    {
      if (*((_QWORD *)this + 46))
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      *((_QWORD *)this + 46) = 0;
      *((_QWORD *)this + 43) = 0;
      *((_QWORD *)this + 44) = 0;
      *((_QWORD *)this + 42) = 0;
      ++*((_DWORD *)this + 90);
    }
    v5 = *((_QWORD *)this + 97);
    if (v5)
    {
      if (*((_QWORD *)this + 101))
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      *((_QWORD *)this + 101) = 0;
      *((_QWORD *)this + 98) = 0;
      *((_QWORD *)this + 99) = 0;
      *((_QWORD *)this + 97) = 0;
      ++*((_DWORD *)this + 200);
    }
    v6 = *((_QWORD *)this + 86);
    if (v6)
    {
      if (*((_QWORD *)this + 90))
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
      *((_QWORD *)this + 90) = 0;
      *((_QWORD *)this + 87) = 0;
      *((_QWORD *)this + 88) = 0;
      *((_QWORD *)this + 86) = 0;
      ++*((_DWORD *)this + 178);
    }
    v7 = *((_QWORD *)this + 75);
    if (v7)
    {
      if (*((_QWORD *)this + 79))
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
      *((_QWORD *)this + 79) = 0;
      *((_QWORD *)this + 76) = 0;
      *((_QWORD *)this + 77) = 0;
      *((_QWORD *)this + 75) = 0;
      ++*((_DWORD *)this + 156);
    }
    v8 = *((_QWORD *)this + 64);
    if (v8)
    {
      if (*((_QWORD *)this + 68))
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
      *((_QWORD *)this + 68) = 0;
      *((_QWORD *)this + 65) = 0;
      *((_QWORD *)this + 66) = 0;
      *((_QWORD *)this + 64) = 0;
      ++*((_DWORD *)this + 134);
    }
    v9 = *((_QWORD *)this + 31);
    if (v9)
    {
      if (*((_QWORD *)this + 35))
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
      *((_QWORD *)this + 35) = 0;
      *((_QWORD *)this + 32) = 0;
      *((_QWORD *)this + 33) = 0;
      *((_QWORD *)this + 31) = 0;
      ++*((_DWORD *)this + 68);
    }
    v10 = (re *)*((_QWORD *)this + 20);
    if (v10)
    {
      if (*((_QWORD *)this + 24))
        v10 = (re *)(*(uint64_t (**)(re *))(*(_QWORD *)v10 + 40))(v10);
      *((_QWORD *)this + 24) = 0;
      *((_QWORD *)this + 21) = 0;
      *((_QWORD *)this + 22) = 0;
      *((_QWORD *)this + 20) = 0;
      ++*((_DWORD *)this + 46);
    }
    *((_BYTE *)this + 48) = 0;
    v11 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v29 = 0;
      _os_log_impl(&dword_21C69B000, v11, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: uninitialized", v29, 2u);
    }
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 97);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 86);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 75);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 64);
  v12 = (uint64_t *)((char *)this + 424);
  v13 = *((_QWORD *)this + 53);
  if (v13)
  {
    if (*((_QWORD *)this + 57))
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    *((_QWORD *)this + 57) = 0;
    *((_QWORD *)this + 54) = 0;
    *((_QWORD *)this + 55) = 0;
    *v12 = 0;
    ++*((_DWORD *)this + 112);
  }
  v14 = *((_QWORD *)this + 58);
  if (v14)
  {
    if (*((_QWORD *)this + 62))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
      v15 = *v12;
    }
    else
    {
      v15 = 0;
    }
    *((_QWORD *)this + 62) = 0;
    *((_QWORD *)this + 59) = 0;
    *((_QWORD *)this + 60) = 0;
    *((_QWORD *)this + 58) = 0;
    ++*((_DWORD *)this + 122);
    if (v15)
    {
      if (*((_QWORD *)this + 57))
        (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
      *((_QWORD *)this + 57) = 0;
      *((_QWORD *)this + 54) = 0;
      *((_QWORD *)this + 55) = 0;
      *v12 = 0;
      ++*((_DWORD *)this + 112);
    }
  }
  v16 = (uint64_t *)((char *)this + 336);
  v17 = *((_QWORD *)this + 42);
  if (v17)
  {
    if (*((_QWORD *)this + 46))
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 44) = 0;
    *v16 = 0;
    ++*((_DWORD *)this + 90);
  }
  v18 = *((_QWORD *)this + 47);
  if (v18)
  {
    if (*((_QWORD *)this + 51))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
      v19 = *v16;
    }
    else
    {
      v19 = 0;
    }
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 49) = 0;
    *((_QWORD *)this + 47) = 0;
    ++*((_DWORD *)this + 100);
    if (v19)
    {
      if (*((_QWORD *)this + 46))
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19);
      *((_QWORD *)this + 46) = 0;
      *((_QWORD *)this + 43) = 0;
      *((_QWORD *)this + 44) = 0;
      *v16 = 0;
      ++*((_DWORD *)this + 90);
    }
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 31);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 20);
  v20 = *((_QWORD *)this + 19);
  if (v20)
  {

    *((_QWORD *)this + 19) = 0;
  }
  v21 = *((_QWORD *)this + 18);
  if (v21)
  {

    *((_QWORD *)this + 18) = 0;
  }
  v22 = *((_QWORD *)this + 13);
  if (v22)
  {
    if (*((_QWORD *)this + 17))
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 40))(v22);
    *((_QWORD *)this + 17) = 0;
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 15) = 0;
    *((_QWORD *)this + 13) = 0;
    ++*((_DWORD *)this + 32);
  }
  v23 = *((_QWORD *)this + 8);
  if (v23)
  {
    v24 = *((_QWORD *)this + 12);
    if (v24)
    {
      v25 = *((_QWORD *)this + 10);
      if (v25)
      {
        v26 = 8 * v25;
        do
        {
          if (*(_QWORD *)v24)
          {

            *(_QWORD *)v24 = 0;
          }
          v24 += 8;
          v26 -= 8;
        }
        while (v26);
        v23 = *((_QWORD *)this + 8);
        v24 = *((_QWORD *)this + 12);
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v23 + 40))(v23, v24);
    }
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 8) = 0;
    ++*((_DWORD *)this + 22);
  }
  v27 = *((_QWORD *)this + 7);
  if (v27)
  {

    *((_QWORD *)this + 7) = 0;
  }
  v28 = *((_QWORD *)this + 4);
  if (v28)
  {

    *((_QWORD *)this + 4) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::NetworkSyncManager::~NetworkSyncManager(this);
  JUMPOUT(0x220780CD0);
}

void re::NetworkSyncManager::init(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _anonymous_namespace_ *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  _anonymous_namespace_ *v14;
  re *v15;
  uint64_t *v16;
  re::RoutingTable *v17;
  re *v18;
  uint64_t v19;
  uint64_t *v20;
  re::SyncViewManager *v21;
  re::SyncViewManager *v22;
  uint64_t v23;
  re *v24;
  uint64_t v25;
  NSObject *v26;
  uint8_t v27[16];

  v5 = *a2;
  v4 = a2[1];
  *(_QWORD *)(a1 + 24) = v5;
  v6 = (_QWORD *)(a1 + 32);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 32), v4);
  *(_QWORD *)(a1 + 40) = a2[2];
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 160), 0);
  ++*(_DWORD *)(a1 + 184);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 248), 0);
  ++*(_DWORD *)(a1 + 272);
  v10 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 512), 0);
  ++*(_DWORD *)(a1 + 536);
  v11 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 600), 0);
  ++*(_DWORD *)(a1 + 624);
  v12 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 688), 0);
  ++*(_DWORD *)(a1 + 712);
  v13 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)(a1 + 776), 0);
  ++*(_DWORD *)(a1 + 800);
  v14 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 336), 0);
  ++*(_DWORD *)(a1 + 360);
  v15 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 424), 0);
  ++*(_DWORD *)(a1 + 448);
  v16 = re::globalAllocators(v15);
  v17 = (re::RoutingTable *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16[2] + 32))(v16[2], 128, 8);
  v18 = re::RoutingTable::RoutingTable(v17);
  v19 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 144) = v18;
  if (v19)

  v20 = re::globalAllocators(v18);
  v21 = (re::SyncViewManager *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v20[2] + 32))(v20[2], 208, 8);
  v22 = re::SyncViewManager::SyncViewManager(v21);
  v23 = *(_QWORD *)(a1 + 152);
  *(_QWORD *)(a1 + 152) = v22;
  if (v23)

  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 56), a2[1]);
  v25 = *(_QWORD *)(a1 + 32);
  if (v25)
  {

    *v6 = 0;
  }
  *(_BYTE *)(a1 + 48) = 1;
  v26 = *re::networkLogObjects(v24);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v27 = 0;
    _os_log_impl(&dword_21C69B000, v26, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: initialized", v27, 2u);
  }
}

void re::NetworkSyncManager::removeDeferredSessions(re::NetworkSyncManager *this)
{
  uint64_t i;

  for (i = *((_QWORD *)this + 15); i; i = *((_QWORD *)this + 15))
    re::NetworkSyncManager::removeSession(this, *(re::Session **)(*((_QWORD *)this + 17) + 8 * i - 8));
}

uint64_t re::NetworkSyncManager::startSyncWithSession(re *a1, re::Session **a2)
{
  re *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  re::Session *v7;
  re::Session *v8;
  NSObject *v9;
  re::Session *v10;
  re::Session *v11;
  uint64_t v12;
  id v13;
  re::Session *v14;
  _DWORD *v15;
  re::NetworkFeatureFlags *v16;
  re *v17;
  re::Session *v18;
  uint64_t *v19;
  _QWORD *v20;
  _anonymous_namespace_ *v21;
  re::Session *v22;
  void *v23;
  char *v24;
  uint64_t v25;
  id v26;
  uint64_t v27;
  id v28;
  re::Session *v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  void *v33;
  NSObject *v34;
  re::Session *v35;
  const char *v36;
  NSObject *v37;
  uint32_t v38;
  NSObject *v39;
  _BYTE *v41;
  re *v42;
  uint64_t v43;
  uint64_t v44;
  re::Session *v45;
  int v46;
  uint64_t *v47;
  uint64_t v48;
  id v49;
  re::Session *v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint8_t buf[16];
  unint64_t v55;
  void *v56;
  re::Session *v57;
  uint64_t v58;
  uint64_t v59;
  re *v60;
  int v61;
  int v62;
  char v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)a1 + 48))
  {
    v39 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v36 = "NetworkSyncManager: Not initialized.";
      v37 = v39;
      v38 = 2;
      goto LABEL_58;
    }
    return 0;
  }
  if (!*a2 || !*((_BYTE *)*a2 + 2272))
  {
    v34 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v35 = *a2;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v35;
      v36 = "NetworkSyncManager: Invalid session object (%p).";
LABEL_33:
      v37 = v34;
      v38 = 12;
LABEL_58:
      _os_log_error_impl(&dword_21C69B000, v37, OS_LOG_TYPE_ERROR, v36, buf, v38);
    }
    return 0;
  }
  v3 = a1;
  v4 = *((_QWORD *)a1 + 10);
  if (v4)
  {
    v5 = *((_QWORD *)a1 + 12);
    v6 = 8 * v4;
    while (1)
    {
      a1 = (re *)(*(_QWORD *(**)(uint8_t *__return_ptr))(**(_QWORD **)v5 + 32))(buf);
      v7 = *a2;
      v8 = *(re::Session **)buf;
      if (*(_QWORD *)buf)

      if (v8 == v7)
        break;
      v5 += 8;
      v6 -= 8;
      if (!v6)
        goto LABEL_10;
    }
    v34 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      return 0;
    v50 = *a2;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v50;
    v36 = "NetworkSyncManager: Session already used to sync (%p).";
    goto LABEL_33;
  }
LABEL_10:
  v9 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = *a2;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v10;
    _os_log_impl(&dword_21C69B000, v9, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: Starting sync with session (%p).", buf, 0xCu);
  }
  v11 = *a2;
  v12 = *((_QWORD *)v3 + 18);
  v53 = v12;
  if (v12)
    v13 = (id)(v12 + 8);
  re::Session::setRoutingTable(v11, &v53);
  if (v53)
  {

    v53 = 0;
  }
  v14 = *a2;
  v15 = (_DWORD *)((char *)*a2 + 1616);
  *(_QWORD *)buf = v3;
  *(_QWORD *)&buf[8] = re::NetworkSyncManager::sessionDataDidArrive;
  v55 = 0;
  v56 = re::Event<re::Session>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v15, (uint64_t)buf);
  *(_QWORD *)buf = v3;
  *(_QWORD *)&buf[8] = re::NetworkSyncManager::sessionDidStop;
  v55 = 0;
  v56 = re::Event<re::Session,re::SessionError>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription((_DWORD *)v14 + 52, (uint64_t)buf);
  v17 = (re *)re::NetworkFeatureFlags::enableSharedAppSpecialization(v16);
  v18 = *a2;
  if ((_DWORD)v17 && *((_BYTE *)v18 + 2219))
  {
    v19 = re::globalAllocators(v17);
    v20 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19[2] + 32))(v19[2], 552, 8);
    bzero(v20, 0x228uLL);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v20, 0);
    v20[3] = 0;
    v20[4] = 0;
    v20[5] = 0;
    *((_DWORD *)v20 + 12) = 0;
    v20[12] = 0;
    *((_DWORD *)v20 + 26) = 0;
    *(_OWORD *)(v20 + 7) = 0u;
    *(_OWORD *)(v20 + 9) = 0u;
    *((_DWORD *)v20 + 22) = 0;
    v20[15] = 0;
    v20[16] = 0;
    v20[14] = 0;
    *((_DWORD *)v20 + 34) = 0;
    v20[23] = 0;
    *((_DWORD *)v20 + 48) = 0;
    *((_OWORD *)v20 + 9) = 0u;
    *((_OWORD *)v20 + 10) = 0u;
    *((_DWORD *)v20 + 44) = 0;
    v20[25] = 0;
    v20[26] = 0;
    *((_DWORD *)v20 + 56) = 0;
    v20[27] = 0;
    v20[34] = 0;
    *((_DWORD *)v20 + 70) = 0;
    *(_OWORD *)(v20 + 29) = 0u;
    *(_OWORD *)(v20 + 31) = 0u;
    *((_DWORD *)v20 + 66) = 0;
    v20[37] = 0;
    v20[38] = 0;
    *((_DWORD *)v20 + 78) = 0;
    v20[36] = 0;
    v20[45] = 0;
    *((_DWORD *)v20 + 92) = 0;
    *((_OWORD *)v20 + 20) = 0u;
    *((_OWORD *)v20 + 21) = 0u;
    *((_DWORD *)v20 + 88) = 0;
    *v20 = &off_24E0712A0;
    v20[47] = 0;
    v20[48] = 30;
    v20[49] = 0xFFFFFFFF00010000;
    *((_BYTE *)v20 + 400) = 0;
    *(_OWORD *)(v20 + 51) = 0u;
    *(_OWORD *)(v20 + 53) = 0u;
    *((_DWORD *)v20 + 110) = 500;
    *((_BYTE *)v20 + 448) = 0;
    v20[58] = 0;
    v20[59] = 0;
    *((_DWORD *)v20 + 120) = 0;
    v20[57] = 0;
    v20[68] = 0;
    *((_DWORD *)v20 + 134) = 0;
    *(_OWORD *)(v20 + 63) = 0u;
    *(_OWORD *)(v20 + 65) = 0u;
    *(_OWORD *)(v20 + 61) = 0u;
    *(_OWORD *)buf = xmmword_21C702DE0;
    v55 = 0xFFFFFFFF00010000;
    v22 = *a2;
    LOBYTE(v56) = *((_BYTE *)*a2 + 2216);
    v23 = (char *)v22 + 8;
    v57 = v22;
    v24 = (char *)v22 + 8;
    v25 = *((_QWORD *)v3 + 7);
    v58 = v25;
    if (v25)
      v26 = (id)(v25 + 8);
    v27 = *((_QWORD *)v3 + 19);
    v59 = v27;
    if (v27)
      v28 = (id)(v27 + 8);
    v60 = v3;
    v29 = *a2;
    v61 = *((_DWORD *)*a2 + 556);
    v30 = *((_DWORD *)v29 + 557);
    if (v30)
    {
      LODWORD(v55) = v30;
      HIDWORD(v55) = v30;
    }
    re::SharedAppSyncManager::init((uint64_t)v20, (__int128 *)buf);
    v52 = v20;
    v31 = v20 + 1;
    v32 = (*(uint64_t (**)(re *, _QWORD **))(*(_QWORD *)v3 + 96))(v3, &v52);
    if (v52)
    {

      v52 = 0;
    }
    if (v27)

    if (v25)
    v33 = v20 + 1;
  }
  else
  {
    *(_OWORD *)buf = xmmword_21C702DE0;
    v55 = 0xFFFFFFFF00010000;
    LOBYTE(v56) = *((_BYTE *)v18 + 2216);
    v57 = v18;
    v41 = (char *)v18 + 8;
    v42 = (char *)v18 + 8;
    v43 = *((_QWORD *)v3 + 7);
    v58 = v43;
    if (v43)
      v42 = (re *)(id)(v43 + 8);
    v44 = *((_QWORD *)v3 + 19);
    v59 = v44;
    if (v44)
      v42 = (re *)(id)(v44 + 8);
    v60 = v3;
    v45 = *a2;
    LOBYTE(v61) = *((_BYTE *)*a2 + 2223);
    v62 = *((_DWORD *)v45 + 556);
    v63 = *((_BYTE *)v45 + 2237);
    v46 = *((_DWORD *)v45 + 557);
    if (v46)
    {
      LODWORD(v55) = v46;
      HIDWORD(v55) = v46;
    }
    v47 = re::globalAllocators(v42);
    v48 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v47[2] + 32))(v47[2], 664, 8);
    v51 = re::SyncObjectManager::SyncObjectManager(v48, (__int128 *)buf);
    if (v51)
      v49 = (id)(v48 + 8);
    v32 = (*(uint64_t (**)(re *, uint64_t *))(*(_QWORD *)v3 + 96))(v3, &v51);
    if (v51)
    {

      v51 = 0;
    }
    if (v48)

    if (v44)
    if (v43)

    v33 = v41;
  }

  return v32;
}

void re::NetworkSyncManager::createSessionAndStartSync(re *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  re *v4;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  re::Session *v14;
  _BOOL8 v15;
  id v16;
  NSObject *v17;
  uint64_t v18;
  uint8_t buf[16];
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  _OWORD v26[2];
  uint64_t v27;
  uint64_t v28;
  int v29;

  v4 = a1;
  v6 = *(_OWORD *)(a2 + 16);
  v20 = *(_OWORD *)a2;
  v21 = v6;
  v7 = *(_QWORD *)(a2 + 32);
  v22 = v7;
  if (v7)
    a1 = (re *)(id)(v7 + 8);
  v23 = *(_OWORD *)(a2 + 40);
  v8 = *(_QWORD *)(a2 + 64);
  v24 = *(_QWORD *)(a2 + 56);
  v25 = v8;
  if (v8)
    a1 = (re *)(id)(v8 + 8);
  v26[0] = *(_OWORD *)(a2 + 72);
  *(_OWORD *)((char *)v26 + 12) = *(_OWORD *)(a2 + 84);
  v9 = *(_QWORD *)(a2 + 104);
  v27 = v9;
  if (v9)
    a1 = (re *)(id)(v9 + 8);
  v10 = *(_QWORD *)(a2 + 112);
  v28 = v10;
  if (v10)
    a1 = (re *)(id)(v10 + 8);
  v29 = *(_DWORD *)(a2 + 120);
  v11 = *((_QWORD *)v4 + 3);
  *(_QWORD *)&v20 = *((_QWORD *)v4 + 5);
  *(_QWORD *)&v21 = v11;
  v12 = re::globalAllocators(a1);
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12[2] + 32))(v12[2], 7656, 8);
  bzero((void *)v13, 0x1DE8uLL);
  v14 = re::Session::Session((re::Session *)v13);
  v15 = re::Session::init((uint64_t)v14, &v20);
  if (v15)
  {
    v18 = v13;
    v16 = (id)(v13 + 8);
    (*(void (**)(re *, uint64_t *))(*(_QWORD *)v4 + 88))(v4, &v18);
    if (v18)
    {

      v18 = 0;
    }
    *a3 = v13;
  }
  else
  {
    v17 = *re::networkLogObjects((re *)v15);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v17, OS_LOG_TYPE_ERROR, "Failed to init session with provided config.", buf, 2u);
    }
    *a3 = 0;

  }
  if (v28)
  {

    v28 = 0;
  }
  if (v27)
  {

    v27 = 0;
  }
  if (v25)
  {

    v25 = 0;
  }
  if (v22)

}

uint64_t re::NetworkSyncManager::startSync(uint64_t a1, _QWORD *a2)
{
  _anonymous_namespace_ *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  id v11;
  re *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  re::Session *v17;
  uint64_t v18;
  uint64_t v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v4 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 64))(*a2);
  v6 = *(_QWORD *)(a1 + 72);
  v5 = *(_QWORD *)(a1 + 80);
  if (v5 >= v6)
  {
    v7 = v5 + 1;
    if (v6 < v5 + 1)
    {
      if (*(_QWORD *)(a1 + 64))
      {
        v8 = 2 * v6;
        if (!v6)
          v8 = 8;
        if (v8 <= v7)
          v9 = v7;
        else
          v9 = v8;
        re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity((_QWORD *)(a1 + 64), v9);
      }
      else
      {
        re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity((_QWORD *)(a1 + 64), v7);
        ++*(_DWORD *)(a1 + 88);
      }
    }
    v5 = *(_QWORD *)(a1 + 80);
  }
  v10 = *a2;
  *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v5) = *a2;
  if (v10)
  {
    v11 = (id)(v10 + 8);
    v5 = *(_QWORD *)(a1 + 80);
  }
  *(_QWORD *)(a1 + 80) = v5 + 1;
  ++*(_DWORD *)(a1 + 88);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)*a2 + 32))(&v19);
  re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::raise(a1 + 160, a1);
  if (v19)
  {

    v19 = 0;
  }
  v13 = *re::networkLogObjects(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)*a2 + 32))(&v18);
    v14 = v18;
    (*(void (**)(re::Session **__return_ptr))(*(_QWORD *)*a2 + 32))(&v17);
    v15 = re::Session::peerID(v17);
    *(_DWORD *)buf = 134218240;
    v21 = v14;
    v22 = 2048;
    v23 = v15;
    _os_log_impl(&dword_21C69B000, v13, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: Added new session: %p (peerID=%llu)", buf, 0x16u);
    if (v17)

    if (v18)
  }
  return 1;
}

void re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  _OWORD v23[5];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *(_QWORD *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v15 = 136315906;
          v16 = "operator[]";
          v17 = 1024;
          v18 = 789;
          v19 = 2048;
          v20 = i;
          v21 = 2048;
          v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *(_QWORD *)(a1 + 72) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, *((unint64_t *)&v23[0] + 1));
        }
        v7 += 40;
      }
    }
  }
}

void re::NetworkSyncManager::beforeFrameUpdate(re::RoutingTable **this)
{
  re::RoutingTable *v2;
  re::RoutingTable *v3;
  re::RoutingTable *v4;
  uint64_t v5;
  uint64_t v6;

  re::RoutingTable::update(this[18]);
  v2 = this[7];
  if (v2)
    re::SyncObjectTombstoneInfo::update((re::RoutingTable *)((char *)v2 + 552));
  v3 = this[10];
  if (v3)
  {
    v4 = this[12];
    v5 = 8 * (_QWORD)v3;
    do
    {
      (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)v4 + 32))(&v6);
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6);
      if (v6)

      v4 = (re::RoutingTable *)((char *)v4 + 8);
      v5 -= 8;
    }
    while (v5);
  }
}

void re::NetworkSyncManager::afterFrameUpdate(re::NetworkSyncManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    v3 = *((_QWORD *)this + 12);
    v4 = 8 * v2;
    do
    {
      (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)v3 + 32))(&v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 56))(v5);
      if (v5)

      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  re::NetworkSyncManager::removeDeferredSessions(this);
}

uint64_t re::NetworkSyncManager::sessionDataDidArrive(re::NetworkSyncManager *this, re::Session *a2)
{
  _anonymous_namespace_ *v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v14[2];
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  unint64_t v21;
  __int16 v22;
  unint64_t v23;
  _OWORD v24[5];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v3 = (re::NetworkSyncManager *)((char *)this + 336);
  v4 = *((_DWORD *)this + 104);
  *((_DWORD *)this + 104) = v4 + 1;
  if (*((_QWORD *)this + 44))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(re::NetworkSyncManager *))(*((_QWORD *)this + 46) + 32 * v5 + 24))(this) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, v5);
      else
        ++v5;
    }
    while (v5 < *((_QWORD *)this + 44));
    v4 = *((_DWORD *)this + 104) - 1;
  }
  *((_DWORD *)this + 104) = v4;
  if (!v4)
  {
    v6 = *((_QWORD *)this + 49);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *((_QWORD *)this + 49);
        if (v9 <= i)
        {
          memset(v24, 0, sizeof(v24));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v16 = 136315906;
          v17 = "operator[]";
          v18 = 1024;
          v19 = 789;
          v20 = 2048;
          v21 = i;
          v22 = 2048;
          v23 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *((_QWORD *)this + 51) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v14[0] = *(_OWORD *)v10;
        v14[1] = v12;
        v15 = v11;
        if (LOBYTE(v14[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (_QWORD *)v14 + 1, (uint64_t)v24);
          if (!LOBYTE(v24[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v3, (uint64_t)v14 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (_QWORD *)v14 + 1, (uint64_t)v24);
          if (LOBYTE(v24[0]))
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, *((unint64_t *)&v24[0] + 1));
        }
        v7 += 40;
      }
    }
  }
  return 0;
}

uint64_t re::NetworkSyncManager::sessionDidStop(re *a1, re::Session *a2, int a3)
{
  NSObject *v6;
  int v8;
  re::Session *v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v6 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 134218240;
    v9 = a2;
    v10 = 1024;
    v11 = a3;
    _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: session stopped (%p) with error: %d.", (uint8_t *)&v8, 0x12u);
  }
  re::NetworkSyncManager::removeSessionDeferred(a1, a2);
  return 1;
}

void re::NetworkSyncManager::removeSessionDeferred(re::NetworkSyncManager *this, re::Session *a2)
{
  re::NetworkSyncManager *v3;
  re::Session **v4;
  unint64_t v5;
  re::Session **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  NSObject *v12;
  int v13;
  re::Session *v14;
  uint64_t v15;

  v3 = this;
  v15 = *MEMORY[0x24BDAC8D0];
  v4 = (re::Session **)*((_QWORD *)this + 17);
  v5 = *((_QWORD *)this + 15);
  v6 = v4;
  if (v5)
  {
    v7 = 8 * v5;
    v6 = (re::Session **)*((_QWORD *)this + 17);
    while (*v6 != a2)
    {
      ++v6;
      v7 -= 8;
      if (!v7)
      {
        v6 = &v4[v5];
        break;
      }
    }
  }
  if (v5 == v6 - v4)
  {
    v8 = *((_QWORD *)this + 14);
    if (v5 >= v8)
    {
      v9 = v5 + 1;
      if (v8 < v5 + 1)
      {
        if (*((_QWORD *)this + 13))
        {
          v10 = 2 * v8;
          if (!v8)
            v10 = 8;
          if (v10 <= v9)
            v11 = v9;
          else
            v11 = v10;
          this = (re::NetworkSyncManager *)re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)this + 13, v11);
        }
        else
        {
          this = (re::NetworkSyncManager *)re::DynamicArray<re::PoolAllocator::PoolBlock *>::setCapacity((_QWORD *)v3 + 13, v9);
          ++*((_DWORD *)v3 + 32);
        }
      }
      v5 = *((_QWORD *)v3 + 15);
      v4 = (re::Session **)*((_QWORD *)v3 + 17);
    }
    v4[v5] = a2;
    *((_QWORD *)v3 + 15) = v5 + 1;
    ++*((_DWORD *)v3 + 32);
    v12 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 134217984;
      v14 = a2;
      _os_log_impl(&dword_21C69B000, v12, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: session scheduled (%p) for removal.", (uint8_t *)&v13, 0xCu);
    }
  }
}

void re::NetworkSyncManager::requestOwnership(re *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v6;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int hasPeerID;
  uint64_t v25;
  uint64_t v26;
  id v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE buf[24];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v6 = *a2;
  if (!*a2)
  {
    v14 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      return;
    *(_WORD *)buf = 0;
    v15 = "Requesting ownership for invalid object. Request is ignored.";
    v16 = v14;
    v17 = 2;
LABEL_28:
    _os_log_impl(&dword_21C69B000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
    return;
  }
  v12 = *(_QWORD *)(v6 + 80);
  if (v12)
  {
    do
    {
      v13 = v6;
      v6 = v12;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v13 + 88) + 16) + 73))
        break;
      v12 = *(_QWORD *)(v12 + 80);
      v13 = v6;
    }
    while (v12);
  }
  else
  {
    v13 = *a2;
  }
  if (!*(_QWORD *)(v13 + 160))
  {
    v28 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      return;
    v29 = *(_QWORD *)(*a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v29;
    v15 = "Requesting ownership for already owned object '%llu'. Request is ignored.";
    v16 = v28;
    v17 = 12;
    goto LABEL_28;
  }
  v18 = *((_QWORD *)a1 + 10);
  if (v18)
  {
    v19 = (uint64_t *)*((_QWORD *)a1 + 12);
    v20 = &v19[v18];
    do
    {
      (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)*v19 + 32))(buf);
      v21 = *a2;
      v22 = *(_QWORD *)(*a2 + 80);
      if (v22)
      {
        do
        {
          v23 = v21;
          v21 = v22;
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v23 + 88) + 16) + 73))
            break;
          v22 = *(_QWORD *)(v22 + 80);
          v23 = v21;
        }
        while (v22);
      }
      else
      {
        v23 = *a2;
      }
      hasPeerID = re::Session::hasPeerID(*(re::Session **)buf, *(_QWORD *)(v23 + 160));
      if (*(_QWORD *)buf)

      if (hasPeerID)
      {
        v25 = *v19;
        v26 = *a2;
        v30 = v26;
        if (v26)
          v27 = (id)(v26 + 8);
        (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)v25 + 104))(v25, &v30, a3, a4, a5, a6);
        if (v30)
        {

          v30 = 0;
        }
      }
      ++v19;
    }
    while (v19 != v20);
  }
}

double re::NetworkSyncManager::adjustTimeForSender(re::NetworkSyncManager *this, double a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;
  int hasPeerID;
  re::Session *v10;

  v4 = *((_QWORD *)this + 10);
  if (v4)
  {
    v6 = (_QWORD *)*((_QWORD *)this + 12);
    v7 = 8 * v4;
    while (1)
    {
      (*(void (**)(re::Session **__return_ptr))(*(_QWORD *)*v6 + 32))(&v10);
      hasPeerID = re::Session::hasPeerID(v10, a3);
      if (v10)

      if (hasPeerID)
        break;
      ++v6;
      v7 -= 8;
      if (!v7)
        return a2;
    }
    return (*(double (**)(_QWORD, uint64_t, double))(*(_QWORD *)*v6 + 112))(*v6, a3, a2);
  }
  return a2;
}

void re::NetworkSyncManager::removeSession(re::NetworkSyncManager *this, re::Session *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  re::Session *v8;
  uint64_t v9;
  re *v10;
  unint64_t v11;
  _OWORD *v12;
  __int128 v13;
  unint64_t v14;
  _OWORD *v15;
  __int128 v16;
  uint64_t v17;
  unint64_t v18;
  re::Session *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  re::Session **v26;
  re::Session **v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  re::Session *v36;
  __int16 v37;
  re::Session *v38;
  uint8_t buf[48];
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 12);
  v5 = *((_QWORD *)this + 10);
  if (v5)
  {
    v6 = 8 * v5;
    v7 = v4 + 8 * v5;
    while (1)
    {
      (*(void (**)(uint8_t *__return_ptr))(**(_QWORD **)v4 + 32))(buf);
      v8 = *(re::Session **)buf;
      if (*(_QWORD *)buf)

      if (v8 == a2)
        break;
      v4 += 8;
      v6 -= 8;
      if (!v6)
      {
        v4 = v7;
        break;
      }
    }
    v9 = v4;
    v4 = *((_QWORD *)this + 12);
    v5 = *((_QWORD *)this + 10);
  }
  else
  {
    v9 = *((_QWORD *)this + 12);
  }
  if (v9 != v4 + 8 * v5)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)v9 + 32))(&v29);
    re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::raise((uint64_t)this + 248, (uint64_t)this);
    if (v29)
    {

      v29 = 0;
    }
    if (*((_BYTE *)a2 + 2272))
    {
      if (*((_QWORD *)a2 + 204))
      {
        v11 = 0;
        do
        {
          v12 = (_OWORD *)(*((_QWORD *)a2 + 206) + 32 * v11);
          if (*(re::NetworkSyncManager **)v12 == this)
          {
            if (!*((_DWORD *)a2 + 424))
            {
              v10 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a2 + 202, v11);
              continue;
            }
            buf[0] = 0;
            v13 = v12[1];
            *(_OWORD *)&buf[8] = *v12;
            *(_OWORD *)&buf[24] = v13;
            re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((re::Session *)((char *)a2 + 1656), (uint64_t)buf);
          }
          ++v11;
        }
        while (v11 < *((_QWORD *)a2 + 204));
      }
      if (*((_QWORD *)a2 + 28))
      {
        v14 = 0;
        do
        {
          v15 = (_OWORD *)(*((_QWORD *)a2 + 30) + 32 * v14);
          if (*(re::NetworkSyncManager **)v15 == this)
          {
            if (!*((_DWORD *)a2 + 72))
            {
              v10 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a2 + 26, v14);
              continue;
            }
            buf[0] = 0;
            v16 = v15[1];
            *(_OWORD *)&buf[8] = *v15;
            *(_OWORD *)&buf[24] = v16;
            re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((re::Session *)((char *)a2 + 248), (uint64_t)buf);
          }
          ++v14;
        }
        while (v14 < *((_QWORD *)a2 + 28));
      }
    }
    v17 = *((_QWORD *)this + 12);
    v18 = (v9 - v17) >> 3;
    v19 = (re::Session *)*((_QWORD *)this + 10);
    if ((unint64_t)v19 <= v18)
    {
      v30 = 0;
      v40 = 0u;
      v41 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v31 = 136315906;
      v32 = "removeAt";
      v33 = 1024;
      v34 = 931;
      v35 = 2048;
      v36 = (re::Session *)v18;
      v37 = 2048;
      v38 = v19;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_51;
    }
    v20 = (uint64_t)v19 - 1;
    if ((unint64_t)v19 - 1 > v18)
    {
      v21 = *(_QWORD *)(v17 + 8 * v18);
      v22 = v17 + 8 * (_QWORD)v19;
      *(_QWORD *)(v17 + 8 * v18) = *(_QWORD *)(v22 - 8);
      *(_QWORD *)(v22 - 8) = v21;
      v17 = *((_QWORD *)this + 12);
    }
    v23 = v17 + 8 * (_QWORD)v19;
    v24 = *(_QWORD *)(v23 - 8);
    if (v24)
    {

      *(_QWORD *)(v23 - 8) = 0;
      v20 = *((_QWORD *)this + 10) - 1;
    }
    *((_QWORD *)this + 10) = v20;
    ++*((_DWORD *)this + 22);
    v25 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a2;
      _os_log_impl(&dword_21C69B000, v25, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: session removed (%p).", buf, 0xCu);
    }
  }
  v26 = (re::Session **)*((_QWORD *)this + 17);
  v19 = (re::Session *)*((_QWORD *)this + 15);
  v27 = v26;
  if (v19)
  {
    v28 = 8 * (_QWORD)v19;
    v27 = (re::Session **)*((_QWORD *)this + 17);
    while (*v27 != a2)
    {
      ++v27;
      v28 -= 8;
      if (!v28)
      {
        v27 = &v26[(_QWORD)v19];
        break;
      }
    }
  }
  a2 = (re::Session *)(v27 - v26);
  if (a2 != v19)
  {
    if (v19 > a2)
    {
      if ((re::Session *)((char *)v19 - 1) > a2)
        v26[(_QWORD)a2] = v26[(_QWORD)v19 - 1];
      *((_QWORD *)this + 15) = (char *)v19 - 1;
      ++*((_DWORD *)this + 32);
      return;
    }
LABEL_51:
    v30 = 0;
    v40 = 0u;
    v41 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v31 = 136315906;
    v32 = "removeAt";
    v33 = 1024;
    v34 = 931;
    v35 = 2048;
    v36 = a2;
    v37 = 2048;
    v38 = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::NetworkSyncManager::stopSyncWithSession(re::NetworkSyncManager *a1, re::Session **a2)
{
  re::Session *v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = *a2;
  if (v2)
  {
    re::NetworkSyncManager::removeSessionDeferred(a1, v2);
  }
  else
  {
    v3 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v4 = 0;
      _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "Invalid session object passed to stopSyncWithSession", v4, 2u);
    }
  }
}

void re::NetworkSyncManager::stopSync(re::NetworkSyncManager *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  re::Session *v5;

  v1 = *((_QWORD *)this + 10);
  if (v1)
  {
    v3 = *((_QWORD *)this + 12);
    v4 = 8 * v1;
    do
    {
      (*(void (**)(re::Session **__return_ptr))(**(_QWORD **)v3 + 32))(&v5);
      re::NetworkSyncManager::removeSessionDeferred(this, v5);
      if (v5)

      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
}

uint64_t re::NetworkSyncManager::sessions(re::NetworkSyncManager *this)
{
  return *((_QWORD *)this + 12);
}

uint64_t re::NetworkSyncManager::didAddSession(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 160;
}

uint64_t re::NetworkSyncManager::willRemoveSession(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 248;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipRequest(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 512;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipResponse(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 600;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipHandoff(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 688;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipChange(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 776;
}

uint64_t re::NetworkSyncManager::transferReportSendEvent(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 424;
}

uint64_t re::NetworkSyncManager::localPeerID(re::NetworkSyncManager *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 18);
  if (v1)
    return *(_QWORD *)(v1 + 24);
  else
    return 0;
}

unint64_t *re::NetworkSyncManager::getRoute@<X0>(re::NetworkSyncManager *this@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  unint64_t *result;

  result = (unint64_t *)*((_QWORD *)this + 18);
  if (result)
    return re::RoutingTable::getRoute((re::RoutingTable *)result, a2, (uint64_t)a3);
  *a3 = 0;
  return result;
}

uint64_t re::NetworkSyncManager::store(re::NetworkSyncManager *this)
{
  return *((_QWORD *)this + 7);
}

uint64_t re::NetworkSyncManager::viewManager(re::NetworkSyncManager *this)
{
  return *((_QWORD *)this + 19);
}

uint64_t re::Event<re::Session>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, _QWORD *a2, unsigned int *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

uint64_t re::SyncAckedStateBuffer::addAcked(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7;
  uint64_t result;
  unsigned int v9;
  __int128 v10;

  v7 = a1 + 24;
  result = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::tryGet(a1 + 24, a2);
  if (result)
  {
    v9 = *(unsigned __int16 *)(result + 8);
    if (v9 <= a4 && a4 - v9 < 0x8000 || v9 > a4 && v9 - a4 >= 0x8000)
    {
      *(_QWORD *)result = a3;
      *(_WORD *)(result + 8) = a4;
    }
  }
  else
  {
    *(_QWORD *)&v10 = a3;
    WORD4(v10) = a4;
    return re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v7, a2, &v10);
  }
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 40 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 40 * v4 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v6 + 40 * v4 + 16) == v2)
        return v6 + 40 * v4 + 24;
    }
    return 0;
  }
  return v6 + 40 * v4 + 24;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 40 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 40 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 40 * v10;
  return v12 + 24;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = *a2;
  v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v9 + 40 * v7 + 16) != v3)
  {
    while (1)
    {
      v10 = v7;
      v11 = *(_DWORD *)(v9 + 40 * v7 + 8);
      v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      if (*(_QWORD *)(v9 + 40 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 40 * v10 + 8) = *(_DWORD *)(v9 + 40 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  v12 = *(_QWORD *)(a1 + 16);
  v13 = v12 + 40 * v7;
  v16 = *(_DWORD *)(v13 + 8);
  v14 = (int *)(v13 + 8);
  v15 = v16;
  if (v16 < 0)
  {
    *v14 = v15 & 0x7FFFFFFF;
    v17 = v12 + 40 * v7;
    v20 = *(_QWORD *)(v17 + 16);
    v19 = (_QWORD *)(v17 + 16);
    v18 = v20;
    if (v20)
    {

      *v19 = 0;
    }
  }
  v21 = *(_QWORD *)(a1 + 16) + 40 * v7;
  v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v22 + 1;
  return 1;
}

uint64_t *re::SyncAckedStateBuffer::getLatestAckedState(uint64_t a1, uint64_t *a2)
{
  uint64_t *result;

  result = (uint64_t *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::tryGet(a1 + 24, a2);
  if (result)
    return (uint64_t *)re::SyncObject::getState((re::SyncObject *)*a2, *result);
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, _OWORD *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  signed int v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  _BYTE v30[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v30, 0, 36);
          *(_QWORD *)&v30[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v30, v13, v12);
          v15 = *(_OWORD *)v30;
          *(_OWORD *)v30 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v30[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v30[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v30[24];
          *(_OWORD *)&v30[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v30[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = 0;
            v22 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v22 - 8) & 0x80000000) != 0)
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(_QWORD *)(v22 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v22 - 16), v22, v22 + 8);
              ++v21;
              v22 += 40;
            }
            while (v21 < v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v30);
        }
      }
      else
      {
        if (v12)
          v25 = 2 * v11;
        else
          v25 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 40 * v9 + 8);
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 40 * v9 + 8) = v24 | 0x80000000;
  v26 = a2;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9) = a3;
  v27 = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 16) = *a4;
  if (v27)
    v28 = (id)(v27 + 8);
  *(_OWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v26) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::SyncObjectViewer::objectEnteredView(re *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  NSObject *v7;
  uint64_t v8;
  _BOOL4 v9;
  void *v10;
  _QWORD *v11;
  _DWORD *v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _BYTE buf[12];
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD **)(a2 + 8);
  v4 = (_QWORD *)v3[10];
  v5 = v3;
  if (v4)
  {
    v6 = *(_QWORD **)(a2 + 8);
    do
    {
      v5 = v6;
      v6 = v4;
      if (*(_BYTE *)(*(_QWORD *)(v5[11] + 16) + 73))
        break;
      v4 = (_QWORD *)v4[10];
      v5 = v6;
    }
    while (v4);
  }
  if (*((_BYTE *)v5 + 170) && (v7 = *re::networkLogObjects(a1), os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)))
  {
    v14 = *((_QWORD *)a1 + 7);
    v15 = *(_QWORD *)(v3[11] + 16);
    v16 = *(_QWORD *)(v15 + 48);
    v17 = *(_QWORD *)(v15 + 56);
    v18 = v15 + 49;
    if ((v16 & 1) != 0)
      v18 = v17;
    v19 = v3[3];
    *(_DWORD *)buf = 134218498;
    *(_QWORD *)&buf[4] = v14;
    v22 = 2080;
    v23 = v18;
    v24 = 2048;
    v25 = v19;
    _os_log_debug_impl(&dword_21C69B000, v7, OS_LOG_TYPE_DEBUG, "Peer %llu became aware of %s Guid=%llu", buf, 0x20u);
    v8 = (uint64_t)a1 + 64;
    *(_QWORD *)buf = v3;
    v9 = v3 == 0;
  }
  else
  {
    v8 = (uint64_t)a1 + 64;
    *(_QWORD *)buf = v3;
    if (!v3)
    {
      v20 = 0;
      v12 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v8, (uint64_t *)buf, &v20);
      goto LABEL_13;
    }
    v9 = 0;
  }
  v10 = v3 + 1;
  v11 = v3 + 1;
  v20 = 0;
  v12 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v8, (uint64_t *)buf, &v20);
  if (!v9)
  {

    if (*v12)
    {
      v13 = v10;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v8, (unint64_t)v3);

    }
    return;
  }
LABEL_13:
  if (*v12)
    re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v8, (unint64_t)v3);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 32 * v10;
  return v12 + 24;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;

  if (*(_QWORD *)a1)
  {
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24);
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(v5 + 4 * v4);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v8 = v7 + 32 * v6;
      if (*(_QWORD *)(v8 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v8 + 8) & 0x7FFFFFFF;
LABEL_8:
        v12 = *(_QWORD *)(a1 + 16) + 32 * v6;
        v13 = *(_DWORD *)(v12 + 8);
        if (v13 < 0)
        {
          *(_DWORD *)(v12 + 8) = v13 & 0x7FFFFFFF;
          v16 = *(_QWORD *)(v12 + 16);
          v15 = (_QWORD *)(v12 + 16);
          v14 = v16;
          if (v16)
          {

            *v15 = 0;
          }
        }
        v17 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v6 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v6 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v6;
        *(_DWORD *)(a1 + 40) = v17 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v6;
          v10 = *(_DWORD *)(v7 + 32 * v6 + 8);
          v6 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          v11 = v7 + 32 * v6;
          if (*(_QWORD *)(v11 + 16) == a2)
          {
            *(_DWORD *)(v7 + 32 * v9 + 8) = *(_DWORD *)(v7 + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

void re::SyncObjectViewer::objectExitedView(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  void *v4;
  re *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  NSObject *v10;
  uint64_t v11;
  _BOOL4 v12;
  id v13;
  _DWORD *v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BYTE buf[12];
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD **)(a2 + 8);
  v4 = v3 + 1;
  v5 = (re *)objc_msgSend(v3 + 1, "retainCount");
  if ((int)v5 <= 0)
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "object->retainCount() > 0", "objectExitedView", 38);
    _os_crash();
    __break(1u);
  }
  v7 = (_QWORD *)v3[10];
  v8 = v3;
  if (v7)
  {
    v9 = v3;
    do
    {
      v8 = v9;
      v9 = v7;
      if (*(_BYTE *)(*(_QWORD *)(v8[11] + 16) + 73))
        break;
      v7 = (_QWORD *)v7[10];
      v8 = v9;
    }
    while (v7);
  }
  if (*((_BYTE *)v8 + 170)
    && (v10 = *re::networkLogObjects(v5), os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)))
  {
    v16 = *(_QWORD *)(a1 + 56);
    v17 = *(_QWORD *)(v3[11] + 16);
    v18 = *(_QWORD *)(v17 + 48);
    v19 = *(_QWORD *)(v17 + 56);
    v20 = v17 + 49;
    if ((v18 & 1) != 0)
      v20 = v19;
    v21 = v3[3];
    *(_DWORD *)buf = 134218498;
    *(_QWORD *)&buf[4] = v16;
    v24 = 2080;
    v25 = v20;
    v26 = 2048;
    v27 = v21;
    _os_log_debug_impl(&dword_21C69B000, v10, OS_LOG_TYPE_DEBUG, "Peer %llu lost awareness of %s Guid=%llu", buf, 0x20u);
    v11 = a1 + 64;
    *(_QWORD *)buf = v3;
    v12 = v3 == 0;
  }
  else
  {
    v11 = a1 + 64;
    *(_QWORD *)buf = v3;
    if (!v3)
    {
      v22 = 1;
      v14 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v11, (uint64_t *)buf, &v22);
      goto LABEL_14;
    }
    v12 = 0;
  }
  v13 = v4;
  v22 = 1;
  v14 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v11, (uint64_t *)buf, &v22);
  if (!v12)
  {

    if (*v14 != 1)
    {
      v15 = v4;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v11, (unint64_t)v3);

    }
    return;
  }
LABEL_14:
  if (*v14 != 1)
    re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v11, (unint64_t)v3);
}

void re::SyncObjectViewer::~SyncObjectViewer(re::SyncObjectViewer *this)
{
  *(_QWORD *)this = &off_24E072818;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
}

{
  *(_QWORD *)this = &off_24E072818;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
  JUMPOUT(0x220780CD0);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, _DWORD *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  signed int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  id v29;
  _BYTE v31[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(_QWORD *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v31, v13, v12);
          v15 = *(_OWORD *)v31;
          *(_OWORD *)v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v31[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v31[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v31[24];
          *(_OWORD *)&v31[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = 0;
            v22 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v22 - 8) & 0x80000000) != 0)
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(_QWORD *)(v22 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v22 - 16), v22, v22 + 8);
              ++v21;
              v22 += 32;
            }
            while (v21 < v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v12)
          v25 = 2 * v11;
        else
          v25 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 32 * v9 + 8);
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 32 * v9 + 8) = v24 | 0x80000000;
  v26 = a2;
  v27 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v27 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  v28 = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  if (v28)
  {
    v29 = (id)(v28 + 8);
    v27 = *(_QWORD *)(a1 + 8);
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v27 + 4 * v26) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t RESyncWriteContextDataWriter(_QWORD *a1)
{
  *(_BYTE *)(*a1 + 16) |= 8u;
  return a1[1];
}

_QWORD *RESyncWriteContextMarkDestroyed(_QWORD *result)
{
  uint64_t v1;

  *(_BYTE *)(*result + 16) |= 2u;
  *(_BYTE *)(*(_QWORD *)*result + 128) |= 4u;
  v1 = result[1];
  *(_WORD *)(v1 + 84) = 0;
  *(_QWORD *)(v1 + 88) = 0;
  ++*(_DWORD *)(v1 + 80);
  return result;
}

uint64_t re::SyncPacker::packCommit(_QWORD *a1, unsigned __int8 *a2, re::BitWriter *this, uint64_t a4, unint64_t a5)
{
  uint64_t v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  re::BitWriter **v18;
  uint64_t (*v19)(uint64_t, uint64_t, uint64_t);
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  re::BitWriter *v26;
  int v27;
  uint64_t *v28;

  if ((*(_BYTE *)(a4 + 32) & 0x20) == 0)
    return re::SyncPacker::writeCommit(a1, a2, this, a4, a5);
  re::BitWriter::alignToByte(this);
  v12 = (_anonymous_namespace_ *)re::BitWriter::bytesLeft(this, v11);
  LODWORD(v13) = *((_DWORD *)this + 6);
  if (*((_DWORD *)this + 7))
    v13 = (v13 + 1);
  else
    v13 = v13;
  v26 = this;
  v27 = v13;
  v28 = 0;
  v15 = *((_QWORD *)this + 1) + v13;
  v16 = 0;
  v17 = (int)v12;
  v18 = &v26;
  v19 = re::SyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  re::DynamicString::setCapacity(&v20, 0);
  v24 = 6;
  v25 = 0;
  v28 = &v15;
  v14 = re::SyncPacker::writeCommit(a1, (uint64_t)a2, (re::snapshot::EncoderOPACK *)&v15, a4, a5);
  re::BitWriter::rollbackTo((uint64_t)this, (v16 + v27));
  if (v20)
  {
    if ((v21 & 1) != 0)
      (*(void (**)(void))(*v20 + 40))();
  }
  return v14;
}

uint64_t re::SyncPacker::writeCommit(_QWORD *a1, uint64_t a2, re::snapshot::EncoderOPACK *this, uint64_t a4, unint64_t a5)
{
  re::snapshot::EncoderOPACK *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t *LatestAckedState;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned __int8 v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  id v39;
  uint64_t v40;
  id v41;
  uint64_t v42;
  id v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t LatestState;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  int v60;
  uint64_t v61;
  unsigned int *v62;
  unint64_t v63;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  NSObject *v69;
  char *v70;
  uint64_t result;
  char *v72;
  unsigned int v74;
  int v75;
  uint64_t v76;
  unsigned __int8 v77;
  uint64_t v78;
  int v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  char v85;
  uint64_t v86;
  uint64_t v87;
  _BYTE buf[22];
  __int16 v89;
  char *v90;
  uint64_t v91;
  uint64_t v92;
  re::snapshot::EncoderOPACK *v93;
  uint64_t v94;

  v94 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a2 + 48) >= 0xFFFFFFFFuLL)
  {
    re::internal::assertLog((re::internal *)4, a2, this, "assertion failure: '%s' (%s:line %i) ", "commit.snapshot.size() < ~uint32_t()", "writeCommit", 123);
    _os_crash();
    __break(1u);
    goto LABEL_95;
  }
  v6 = a5;
  v7 = a4;
  v5 = this;
  v8 = a2;
  v9 = *((_DWORD *)this + 2);
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>(v5, (unsigned __int8 *)v8);
  if ((*(_BYTE *)v8 & 2) != 0)
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned long long>(v5, (uint64_t *)(v8 + 16));
  re::snapshot::EncoderOPACK::endObject((unsigned int *)v5);
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)v5);
  v10 = *((unsigned int *)v5 + 2);
  if (v10 >= *((_DWORD *)v5 + 3))
  {
LABEL_95:
    if ((re::snapshot::Encoder::grow(v5, v10 + 1) & 1) == 0)
    {
      result = 0;
      *((_DWORD *)v5 + 2) = v9;
      return result;
    }
  }
  if (*(_QWORD *)(v8 + 48) <= v6)
  {
    v76 = 0;
    v74 = 0;
    goto LABEL_89;
  }
  v74 = 0;
  v76 = 0;
  while (1)
  {
    v11 = *(_QWORD *)(v8 + 64);
    v12 = (uint64_t *)(v11 + 24 * v6);
    v13 = *v12;
    v14 = *(_QWORD *)(*(_QWORD *)(*v12 + 88) + 16);
    v15 = *(_QWORD *)(v14 + 128);
    if (v15)
    {
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(v15 + 16))(v15, v7))
      {
        ++v74;
        goto LABEL_73;
      }
      v13 = *v12;
      v14 = *(_QWORD *)(*(_QWORD *)(*v12 + 88) + 16);
    }
    v75 = *((_DWORD *)v5 + 2);
    v16 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, *(_QWORD *)(v13 + 24), *(_QWORD *)(v14 + 32));
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, v16);
    v17 = a1[1];
    if (!v17
      || ((v18 = *(_QWORD *)(*(_QWORD *)(v13 + 88) + 16),
           v19 = *(_QWORD *)(v18 + 104),
           v20 = *(_QWORD *)(v18 + 120),
           v19)
        ? (v21 = v20 == 0)
        : (v21 = 1),
          v21 || (*(_BYTE *)(v11 + 24 * v6 + 16) & 1) != 0))
    {
      v24 = 0;
      LatestAckedState = 0;
    }
    else
    {
      LatestAckedState = re::SyncAckedStateBuffer::getLatestAckedState(v17, (uint64_t *)(v11 + 24 * v6));
      v24 = v23;
    }
    v25 = LatestAckedState == 0;
    v77 = LatestAckedState == 0;
    if ((*(_BYTE *)(v11 + 24 * v6 + 16) & 2) != 0)
    {
      v25 |= 4u;
      v77 = v25;
    }
    v26 = *(_QWORD **)(v13 + 80);
    v27 = (_QWORD *)v13;
    if (v26)
    {
      v28 = (_QWORD *)v13;
      do
      {
        v27 = v28;
        v28 = v26;
        if (*(_BYTE *)(*(_QWORD *)(v27[11] + 16) + 73))
          break;
        v26 = (_QWORD *)v26[10];
        v27 = v28;
      }
      while (v26);
    }
    if (!v27[20] && v27[17])
      v77 = v25 | 0x10;
    re::snapshot::EncoderOPACK::beginObject((unsigned int *)v5);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>(v5, &v77);
    *(_WORD *)buf = *(_WORD *)(v13 + 176);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>(v5, (unsigned __int16 *)buf);
    v29 = *(_QWORD *)(v13 + 80);
    v30 = v13;
    if (v29)
    {
      v31 = v13;
      do
      {
        v30 = v31;
        v31 = v29;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v30 + 88) + 16) + 73))
          break;
        v29 = *(_QWORD *)(v29 + 80);
        v30 = v31;
      }
      while (v29);
    }
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,re::SyncOwnershipInfo>(v5, v30 + 136);
    if ((v77 & 5) != 0)
    {
      v32 = *(_QWORD *)(v13 + 24);
      v33 = *((unsigned int *)v5 + 2);
      if (v33 >= *((_DWORD *)v5 + 3))
      {
        re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, 5);
      }
      else
      {
        v34 = *(_QWORD *)v5;
        *((_DWORD *)v5 + 2) = v33 + 1;
        *(_BYTE *)(v34 + v33) = 13;
      }
      re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, v32);
      *(_QWORD *)buf = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 88) + 16) + 32);
      re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<6,unsigned long long>(v5, (uint64_t *)buf);
    }
    if (LatestAckedState)
    {
      v35 = *((unsigned int *)v5 + 2);
      if (v35 >= *((_DWORD *)v5 + 3))
      {
        re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, 7);
      }
      else
      {
        v36 = *(_QWORD *)v5;
        *((_DWORD *)v5 + 2) = v35 + 1;
        *(_BYTE *)(v36 + v35) = 15;
      }
      re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, v24);
    }
    if ((v77 & 1) != 0)
    {
      v37 = *(_QWORD *)(v13 + 80);
      if (v37)
      {
        v38 = (void *)(v37 + 8);
        v39 = (id)(v37 + 8);

        v40 = *(_QWORD *)(v13 + 80);
        if (v40)
          v41 = (id)(v40 + 8);
        *(_QWORD *)buf = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v40 + 88) + 16) + 32);
        re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<8,unsigned long long>(v5, (uint64_t *)buf);

        v42 = *(_QWORD *)(v13 + 80);
        if (v42)
          v43 = (id)(v42 + 8);
        *(_QWORD *)buf = *(_QWORD *)(v42 + 24);
        re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<9,unsigned long long>(v5, (uint64_t *)buf);

      }
    }
    v44 = *((unsigned int *)v5 + 2);
    if (v44 >= *((_DWORD *)v5 + 3))
    {
      re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v5, 11);
    }
    else
    {
      v45 = *(_QWORD *)v5;
      *((_DWORD *)v5 + 2) = v44 + 1;
      *(_BYTE *)(v45 + v44) = 19;
    }
    LatestState = re::SyncObject::getLatestState((re::SyncObject *)v13);
    if (LatestState)
    {
      v47 = *(_QWORD *)(*(_QWORD *)(v13 + 88) + 16);
      v48 = *(_DWORD *)(LatestState + 24);
      if (*(_DWORD *)(LatestState + 28))
        ++v48;
      v78 = *(_QWORD *)(LatestState + 8);
      v79 = v48;
      v80 = 0;
      v81 = 0;
      v82 = 0;
      v49 = *((_DWORD *)v5 + 2);
      re::snapshot::EncoderOPACK::beginData((unsigned int *)v5, 0, 0xFFFFFFFFuLL);
      v50 = *((unsigned int *)v5 + 2);
      v51 = *(_QWORD *)v5 + v50;
      *(_DWORD *)&buf[16] = *((_DWORD *)v5 + 3) - v50;
      buf[20] = 0;
      v90 = 0;
      v91 = 0;
      *(_QWORD *)&buf[8] = v51;
      *(_QWORD *)buf = &off_24E072868;
      v92 = v50;
      v93 = v5;
      if (LatestAckedState)
      {
        v52 = *((_DWORD *)LatestAckedState + 6);
        if (*((_DWORD *)LatestAckedState + 7))
          ++v52;
        v83 = LatestAckedState[1];
        v84 = v52;
        v85 = 0;
        v86 = 0;
        v87 = 0;
        (*(void (**)(void))(*(_QWORD *)(v47 + 120) + 16))();
      }
      else
      {
        (*(void (**)(void))(*(_QWORD *)(v47 + 112) + 16))();
      }
      re::BitWriter::alignToByte(buf);
      v60 = (_DWORD)v90 + v92;
      if (HIDWORD(v90))
        ++v60;
      *((_DWORD *)v93 + 2) = v60;
      v61 = *((unsigned int *)v5 + 2);
      *((_DWORD *)v5 + 2) = v49;
      re::snapshot::EncoderOPACK::beginData((unsigned int *)v5, v61 - v50, 0xFFFFFFFFuLL);
      *((_DWORD *)v5 + 2) = v61;
    }
    else
    {
      v53 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        v54 = *(_QWORD *)(v13 + 24);
        v55 = *(_QWORD **)(*(_QWORD *)(v13 + 88) + 16);
        v56 = v55[4];
        v57 = v55[6];
        v58 = (char *)v55[7];
        v59 = (char *)v55 + 49;
        if ((v57 & 1) != 0)
          v59 = v58;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v54;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v56;
        v89 = 2080;
        v90 = v59;
        _os_log_error_impl(&dword_21C69B000, v53, OS_LOG_TYPE_ERROR, "Could not find latest state for object (id: %llu, type: %llu[%s]).", buf, 0x20u);
      }
    }
    v62 = re::snapshot::EncoderOPACK::endObject((unsigned int *)v5);
    v63 = *((_QWORD *)v5 + 5);
    if ((v63 & 1) != 0 ? v63 >> 1 : v63 >> 1)
      break;
    v65 = *((unsigned int *)v5 + 2);
    if (v65 >= *((_DWORD *)v5 + 3) && !re::snapshot::Encoder::grow(v5, v65 + 1))
      goto LABEL_88;
    ++v76;
    v66 = *(_QWORD *)v7;
    if (*(_QWORD *)v7)
    {
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(v7 + 8) + 32))(buf);
      if (*(_QWORD *)buf)

      v67 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v66 + 80))(v66);
      re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(v67, v66);
    }
LABEL_73:
    if (++v6 >= *(_QWORD *)(v8 + 48))
      goto LABEL_89;
  }
  v68 = *((unsigned __int8 *)a1 + 16);
  v69 = *re::networkLogObjects((re *)v62);
  if (v68)
  {
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
    {
      if ((*((_QWORD *)v5 + 5) & 1) != 0)
        v70 = (char *)*((_QWORD *)v5 + 6);
      else
        v70 = (char *)v5 + 41;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v70;
      _os_log_debug_impl(&dword_21C69B000, v69, OS_LOG_TYPE_DEBUG, "Error writing OPACK object data: %s", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
  {
    if ((*((_QWORD *)v5 + 5) & 1) != 0)
      v72 = (char *)*((_QWORD *)v5 + 6);
    else
      v72 = (char *)v5 + 41;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v72;
    _os_log_error_impl(&dword_21C69B000, v69, OS_LOG_TYPE_ERROR, "Error writing OPACK object data: %s", buf, 0xCu);
  }
LABEL_88:
  *((_DWORD *)v5 + 2) = v75;
LABEL_89:
  re::snapshot::EncoderOPACK::endObject((unsigned int *)v5);
  return v76 + v74;
}

uint64_t re::SyncPacker::writeCommit(_QWORD *a1, unsigned __int8 *a2, re::BitWriter *this, uint64_t a4, unint64_t a5)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t *LatestAckedState;
  unsigned __int16 v25;
  unsigned __int16 v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  void *v40;
  id v41;
  uint64_t v42;
  id v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  uint64_t v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  void (*v53)(void);
  NSObject *v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  void (*v61)(void);
  unint64_t v62;
  uint64_t v63;
  int v64;
  unint64_t v65;
  int v66;
  unint64_t v67;
  int v68;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int v79;
  _BYTE buf[12];
  __int16 v81;
  _BYTE v82[10];
  char *v83;
  uint64_t v84;

  v84 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)a2 + 6) >= 0xFFFFFFFFuLL)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, this, "assertion failure: '%s' (%s:line %i) ", "commit.snapshot.size() < ~uint32_t()", "writeCommit", 189);
    _os_crash();
    __break(1u);
  }
  v10 = *((_QWORD *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)this, *a2, 8u);
  if ((*a2 & 2) != 0)
  {
    v11 = *((_DWORD *)a2 + 5);
    re::BitWriter::writeUInt32Bits((uint64_t)this, *((_DWORD *)a2 + 4), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v11, 0x20u);
  }
  v12 = *((_QWORD *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)this, 0, 0x20u);
  if (*((_BYTE *)this + 20))
  {
    re::BitWriter::rollbackTo((uint64_t)this, v10);
    return 0;
  }
  v73 = v12;
  if (*((_QWORD *)a2 + 6) <= a5)
  {
    v75 = 0;
    v14 = 0;
    goto LABEL_76;
  }
  v14 = 0;
  v75 = 0;
  v77 = a4;
  v74 = a1;
  while (1)
  {
    v15 = *((_QWORD *)a2 + 8);
    v16 = (uint64_t *)(v15 + 24 * a5);
    v17 = *v16;
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*v16 + 88) + 16) + 128);
    if (!v18)
      break;
    if ((*(unsigned int (**)(uint64_t, uint64_t))(v18 + 16))(v18, a4))
    {
      v17 = *v16;
      break;
    }
    ++v75;
LABEL_72:
    if (++a5 >= *((_QWORD *)a2 + 6))
      goto LABEL_76;
  }
  v19 = a1[1];
  v78 = v14;
  v76 = *((_QWORD *)this + 3);
  if (!v19
    || ((v20 = *(_QWORD *)(*(_QWORD *)(v17 + 88) + 16), v21 = *(_QWORD *)(v20 + 104),
                                                          v22 = *(_QWORD *)(v20 + 120),
                                                          v21)
      ? (v23 = v22 == 0)
      : (v23 = 1),
        v23 || (*(_BYTE *)(v15 + 24 * a5 + 16) & 1) != 0))
  {
    v26 = 0;
    LatestAckedState = 0;
  }
  else
  {
    LatestAckedState = re::SyncAckedStateBuffer::getLatestAckedState(v19, (uint64_t *)(v15 + 24 * a5));
    v26 = v25;
  }
  v27 = *(_QWORD **)(v17 + 80);
  v28 = (_QWORD *)v17;
  if (v27)
  {
    v29 = (_QWORD *)v17;
    do
    {
      v28 = v29;
      v29 = v27;
      if (*(_BYTE *)(*(_QWORD *)(v28[11] + 16) + 73))
        break;
      v27 = (_QWORD *)v27[10];
      v28 = v29;
    }
    while (v27);
  }
  v30 = (LatestAckedState == 0) | (2 * *(_BYTE *)(v15 + 24 * a5 + 16)) & 5;
  if (!v28[20] && v28[17])
    v30 |= 0x10u;
  re::BitWriter::alignToByte(this);
  re::BitWriter::writeUInt32Bits((uint64_t)this, v30, 8u);
  re::BitWriter::writeUInt32Bits((uint64_t)this, *(unsigned __int16 *)(v17 + 176), 0x10u);
  v31 = *(_QWORD *)(v17 + 80);
  v32 = v17;
  if (v31)
  {
    v33 = v17;
    do
    {
      v32 = v33;
      v33 = v31;
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v32 + 88) + 16) + 73))
        break;
      v31 = *(_QWORD *)(v31 + 80);
      v32 = v33;
    }
    while (v31);
  }
  re::SyncOwnershipInfo::write((re::SyncOwnershipInfo *)(v32 + 136), this, 1);
  v34 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, *(_QWORD *)(v17 + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v17 + 88) + 16) + 32));
  *(_QWORD *)buf = 0;
  re::BiasedVLQ::write((re::BiasedVLQ *)buf, this, v34);
  if ((v30 & 5) != 0)
  {
    v35 = *(_DWORD *)(v17 + 28);
    re::BitWriter::writeUInt32Bits((uint64_t)this, *(_DWORD *)(v17 + 24), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v35, 0x20u);
    v36 = *(_QWORD *)(*(_QWORD *)(v17 + 88) + 16);
    v37 = *(_DWORD *)(v36 + 36);
    re::BitWriter::writeUInt32Bits((uint64_t)this, *(_DWORD *)(v36 + 32), 0x20u);
    v38 = v37;
    a1 = v74;
    re::BitWriter::writeUInt32Bits((uint64_t)this, v38, 0x20u);
  }
  if (LatestAckedState)
    re::BitWriter::writeUInt32Bits((uint64_t)this, v26, 0x10u);
  if ((v30 & 1) != 0)
  {
    v39 = *(_QWORD *)(v17 + 80);
    if (v39)
    {
      v40 = (void *)(v39 + 8);
      v41 = (id)(v39 + 8);

      v42 = *(_QWORD *)(v17 + 80);
      if (v42)
        v43 = (id)(v42 + 8);
      v44 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v42 + 88) + 16) + 32);

      v45 = *(_QWORD *)(v17 + 80);
      if (v45)
        v46 = (id)(v45 + 8);
      v47 = *(_QWORD *)(v45 + 24);

      a4 = v77;
    }
    else
    {
      v44 = 0;
      v47 = 0;
    }
    re::BitWriter::writeUInt32Bits((uint64_t)this, v44, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, HIDWORD(v44), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v47, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, HIDWORD(v47), 0x20u);
  }
  if (!*((_BYTE *)this + 20))
  {
    if (re::SyncObject::getLatestState((re::SyncObject *)v17))
    {
      v49 = *(_QWORD *)(*(_QWORD *)(v17 + 88) + 16);
      v50 = *((_QWORD *)this + 3);
      re::BitWriter::writeUInt32Bits((uint64_t)this, 0, 8u);
      v51 = *((_QWORD *)this + 3);
      if (LatestAckedState)
      {
        v52 = *((_DWORD *)LatestAckedState + 6);
        if (*((_DWORD *)LatestAckedState + 7))
          ++v52;
        *(_QWORD *)buf = LatestAckedState[1];
        *(_DWORD *)&buf[8] = v52;
        LOBYTE(v81) = 0;
        *(_QWORD *)&v82[2] = 0;
        v83 = 0;
        v53 = *(void (**)(void))(*(_QWORD *)(v49 + 120) + 16);
        a4 = v77;
        v53();
      }
      else
      {
        v61 = *(void (**)(void))(*(_QWORD *)(v49 + 112) + 16);
        a4 = v77;
        v61();
      }
      re::BitWriter::alignToByte(this);
      v62 = *((_QWORD *)this + 3);
      v63 = (v62 - v51);
      if (v63 >= 0x80)
      {
        v64 = 0;
        v65 = (v62 - v51);
        do
        {
          v66 = v64;
          v67 = v65 >> 14;
          v65 >>= 7;
          ++v64;
        }
        while (v67);
        if (HIDWORD(v62))
          LODWORD(v62) = v62 + 1;
        *(_QWORD *)buf = *((_QWORD *)this + 1);
        *(_DWORD *)&buf[8] = v62;
        LOBYTE(v81) = 0;
        *(_QWORD *)&v82[2] = 0;
        v83 = 0;
        re::BitReader::seekTo((uint64_t)buf, v51);
        v68 = ~v66;
        do
        {
          v79 = 0;
          re::BitReader::readUInt32Bits((uint64_t *)buf, 8u, &v79);
          re::BitWriter::writeUInt32Bits((uint64_t)this, v79, 8u);
        }
        while (!__CFADD__(v68++, 1));
        a4 = v77;
      }
      if (!*((_BYTE *)this + 20))
      {
        v70 = *((_QWORD *)this + 3);
        re::BitWriter::rollbackTo((uint64_t)this, v50);
        *(_QWORD *)buf = 0;
        re::BiasedVLQ::write((re::BiasedVLQ *)buf, this, v63);
        re::BitWriter::rollbackTo((uint64_t)this, v70);
      }
    }
    else
    {
      v54 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        v55 = *(_QWORD *)(v17 + 24);
        v56 = *(_QWORD **)(*(_QWORD *)(v17 + 88) + 16);
        v57 = v56[4];
        v58 = v56[6];
        v59 = (char *)v56[7];
        v60 = (char *)v56 + 49;
        if ((v58 & 1) != 0)
          v60 = v59;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v55;
        v81 = 2048;
        *(_QWORD *)v82 = v57;
        *(_WORD *)&v82[8] = 2080;
        v83 = v60;
        _os_log_error_impl(&dword_21C69B000, v54, OS_LOG_TYPE_ERROR, "Could not find latest state for object (id: %llu, type: %llu[%s]).", buf, 0x20u);
      }
    }
    if (!*((_BYTE *)this + 20))
    {
      v71 = *(_QWORD *)a4;
      if (*(_QWORD *)a4)
      {
        (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(a4 + 8) + 32))(buf);
        if (*(_QWORD *)buf)

        v72 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v71 + 80))(v71);
        a4 = v77;
        re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(v72, v71);
        a1 = v74;
      }
      v14 = v78 + 1;
      goto LABEL_72;
    }
  }
  re::BitWriter::rollbackTo((uint64_t)this, v76);
  v14 = v78;
LABEL_76:
  re::BitWriter::writeUInt32At((uint64_t)this, v73, v14);
  return v14 + v75;
}

uint64_t re::SyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::BitWriter *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(re::BitWriter **)a1;
  v5 = *(unsigned int *)(a1 + 8);
  re::BitWriter::rollbackTo(*(_QWORD *)a1, (*(_DWORD *)(*(_QWORD *)(a1 + 16) + 8) + v5));
  (*(void (**)(re::BitWriter *, uint64_t))(*(_QWORD *)v4 + 16))(v4, a3);
  re::BitWriter::bytesLeft(v4, v6);
  return *((_QWORD *)v4 + 1) + v5;
}

void `anonymous namespace'::SnapshotBitWriter::~SnapshotBitWriter(_anonymous_namespace_::SnapshotBitWriter *this)
{
  JUMPOUT(0x220780CD0);
}

unsigned int *`anonymous namespace'::SnapshotBitWriter::grow(_anonymous_namespace_::SnapshotBitWriter *this, unsigned int a2)
{
  unsigned int *result;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  result = (unsigned int *)*((_QWORD *)this + 6);
  v4 = result[2];
  v5 = result[3];
  v6 = v4 + a2;
  if (v6 <= v5)
    goto LABEL_2;
  result = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)result, v6);
  if ((_DWORD)result)
  {
    result = (unsigned int *)*((_QWORD *)this + 6);
    LODWORD(v4) = result[2];
    LODWORD(v5) = result[3];
LABEL_2:
    *((_QWORD *)this + 1) = *(_QWORD *)result + *((_QWORD *)this + 5);
    *((_DWORD *)this + 4) = v5 - v4;
  }
  return result;
}

double RESyncViewCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 136, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E071B18;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_DWORD *)(v2 + 72) = 0;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(v2 + 76) = 0x7FFFFFFFLL;
  *(_QWORD *)(v2 + 96) = 0;
  *(_QWORD *)(v2 + 104) = 0;
  *(_QWORD *)(v2 + 88) = 0;
  *(_DWORD *)(v2 + 112) = 0;
  *(_QWORD *)(v2 + 120) = 0;
  *(_QWORD *)(v2 + 128) = 0;
  return result;
}

void RESyncViewSetUserData(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_QWORD *)(a1 + 128) = a2;
  }
  else
  {
    v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136315394;
      v4 = "RESyncViewSetUserData";
      v5 = 2080;
      v6 = "view != __null";
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncViewGetUserData(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 128);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncViewGetUserData";
    v5 = 2080;
    v6 = "view != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncViewGetObjectCount(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(unsigned int *)(a1 + 68);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncViewGetObjectCount";
    v5 = 2080;
    v6 = "view != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncViewSetOwnerPeerID(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_QWORD *)(a1 + 32) = a2;
  }
  else
  {
    v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136315394;
      v4 = "RESyncViewSetOwnerPeerID";
      v5 = 2080;
      v6 = "view != __null";
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncViewGetOwnerPeerID(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 32);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncViewGetOwnerPeerID";
    v5 = 2080;
    v6 = "view != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncViewSetFromPeerID(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    *(_QWORD *)(a1 + 24) = a2;
  }
  else
  {
    v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136315394;
      v4 = "RESyncViewSetFromPeerID";
      v5 = 2080;
      v6 = "view != __null";
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncViewGetFromPeerID(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a1)
    return *(_QWORD *)(a1 + 24);
  v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    v3 = 136315394;
    v4 = "RESyncViewGetFromPeerID";
    v5 = 2080;
    v6 = "view != __null";
    _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncViewEnumerateObjects(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v11 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return;
    v12 = 136315394;
    v13 = "RESyncViewEnumerateObjects";
    v14 = 2080;
    v15 = "view != __null";
    goto LABEL_25;
  }
  if (!a2)
  {
    v11 = *re::networkLogObjects((re *)a1);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return;
    v12 = 136315394;
    v13 = "RESyncViewEnumerateObjects";
    v14 = 2080;
    v15 = "cb != __null";
LABEL_25:
    _os_log_error_impl(&dword_21C69B000, v11, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v12, 0x16u);
    return;
  }
  v4 = *(unsigned int *)(a1 + 72);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a1 + 56) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a1 + 72);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    do
    {
      if (!(*(unsigned int (**)(uint64_t, _QWORD))(a2 + 16))(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 24 * v8 + 16) + 8)))break;
      v9 = *(_DWORD *)(a1 + 72) <= (v5 + 1) ? v5 + 1 : *(_DWORD *)(a1 + 72);
      while (1)
      {
        v8 = (v5 + 1);
        if (v9 - 1 == (_DWORD)v5)
          break;
        LODWORD(v5) = v5 + 1;
        v10 = v8;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 56) + 24 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_19;
      }
      v10 = v9;
LABEL_19:
      LODWORD(v5) = v10;
    }
    while ((_DWORD)v4 != v10);
  }
}

uint64_t re::LeaderElectionLowestPeerID::setSession(uint64_t this, re::Session *a2)
{
  *(_QWORD *)(this + 32) = a2;
  return this;
}

uint64_t re::LeaderElectionLowestPeerID::setup(re::LeaderElectionLowestPeerID *this, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(re::LeaderElectionLowestPeerID *))(*(_QWORD *)this + 72))(this);
  if ((_DWORD)result)
    *(_QWORD *)(*((_QWORD *)this + 4) + 3136) = a2;
  return result;
}

uint64_t re::LeaderElectionLowestPeerID::processCapabilities(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 32);
  if (*(_BYTE *)(v1 + 2184))
    *(_DWORD *)(v1 + 3280) |= 1u;
  return this;
}

unint64_t re::LeaderElectionLowestPeerID::handleMigration(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = *(_QWORD *)(a3 + 16);
  if (!v3)
    goto LABEL_7;
  v4 = *(uint64_t **)(a3 + 32);
  v5 = 8 * v3;
  v6 = a2;
  do
  {
    v7 = *v4++;
    v8 = *(_QWORD *)(v7 + 24);
    if (v6 >= v8)
      v6 = v8;
    v5 -= 8;
  }
  while (v5);
  if (v6 == a2)
  {
LABEL_7:
    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 3280) |= 1u;
    return a2;
  }
  return v6;
}

void re::LeaderElectionLowestPeerID::removePeer(re::LeaderElectionLowestPeerID *this, uint64_t a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 4);
  if (*(_QWORD *)(v2 + 3136) == a2)
    re::Session::stateEvent(v2, 4);
}

uint64_t re::LeaderElectionLowestPeerID::isLeader(re::LeaderElectionLowestPeerID *this)
{
  return *(_DWORD *)(*((_QWORD *)this + 4) + 3280) & 1;
}

uint64_t re::LeaderElectionLowestPeerID::processPeerHelloSetLeader(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(this + 32) + 3136) = a2;
  return this;
}

void re::LeaderElectionLowestPeerID::~LeaderElectionLowestPeerID(re::LeaderElectionLowestPeerID *this)
{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

re::Transport *re::Transport::Transport(re::Transport *this)
{
  _anonymous_namespace_ *v2;
  uint64_t v3;
  uint64_t v5;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E072948;
  *((_QWORD *)this + 3) = &unk_24E0729B0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *(_QWORD *)((char *)this + 172) = 0x1FFFFFFFFLL;
  *((_DWORD *)this + 46) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_DWORD *)this + 54) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  *(_QWORD *)((char *)this + 308) = 0x7FFFFFFFLL;
  *((_BYTE *)this + 340) = 0;
  *((_DWORD *)this + 92) = 0;
  *((_QWORD *)this + 40) = 0;
  *((_QWORD *)this + 41) = 0;
  *((_BYTE *)this + 336) = 0;
  *((_QWORD *)this + 47) = 0;
  *((_QWORD *)this + 48) = 0;
  *((_BYTE *)this + 392) = 1;
  *((_QWORD *)this + 51) = 0;
  *((_QWORD *)this + 52) = 0;
  *((_DWORD *)this + 106) = 0;
  *((_QWORD *)this + 50) = 0;
  *((_DWORD *)this + 116) = 0;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_QWORD *)this + 63) = 0;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 60, 0);
  *((_QWORD *)this + 64) = 0;
  *((_QWORD *)this + 70) = 0;
  *((_QWORD *)this + 72) = 0;
  *((_QWORD *)this + 71) = 0;
  *((_WORD *)this + 292) = 257;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  re::PacketPool::make(0, 0, &v5);
  v3 = *((_QWORD *)this + 48);
  *((_QWORD *)this + 48) = v5;
  if (v3)

  return this;
}

void re::Transport::~Transport(re::Transport *this, double a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id *v14;
  uint64_t v15;
  uint64_t v16;

  *(_QWORD *)this = &off_24E072948;
  *((_QWORD *)this + 3) = &unk_24E0729B0;
  if (*((_QWORD *)this + 9))
    a2 = re::Transport::deinit(this);
  v3 = *((_QWORD *)this + 72);
  if (v3)
  {

    *((_QWORD *)this + 72) = 0;
  }
  v4 = *((_QWORD *)this + 71);
  if (v4)
  {

    *((_QWORD *)this + 71) = 0;
  }
  v5 = *((_QWORD *)this + 70);
  if (v5)
  {

    *((_QWORD *)this + 70) = 0;
  }
  v6 = *((_QWORD *)this + 60);
  if (v6)
  {
    if ((*((_BYTE *)this + 488) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 62));
    a2 = 0.0;
    *((_OWORD *)this + 30) = 0u;
    *((_OWORD *)this + 31) = 0u;
  }
  v7 = *((_QWORD *)this + 55);
  if (v7)
  {
    if (*((_QWORD *)this + 59))
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    *((_QWORD *)this + 59) = 0;
    *((_QWORD *)this + 56) = 0;
    *((_QWORD *)this + 57) = 0;
    *((_QWORD *)this + 55) = 0;
    ++*((_DWORD *)this + 116);
  }
  v8 = *((_QWORD *)this + 50);
  if (v8)
  {
    if (*((_QWORD *)this + 54))
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
    *((_QWORD *)this + 54) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 52) = 0;
    *((_QWORD *)this + 50) = 0;
    ++*((_DWORD *)this + 106);
  }
  v9 = *((_QWORD *)this + 48);
  if (v9)
  {

    *((_QWORD *)this + 48) = 0;
  }
  v10 = *((_QWORD *)this + 47);
  if (v10)
    dispatch_release(v10);
  re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit((uint64_t *)this + 34, a2);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 232);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 192);
  re::DataArray<re::Connection>::deinit((_DWORD *)this + 30);
  v11 = *((_QWORD *)this + 15);
  if (v11)
  {
    if (*((_QWORD *)this + 19))
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    *((_QWORD *)this + 15) = 0;
    ++*((_DWORD *)this + 36);
  }
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 80);
  v12 = *((_QWORD *)this + 9);
  if (v12)
  {

    *((_QWORD *)this + 9) = 0;
  }
  v13 = *((_QWORD *)this + 4);
  if (v13)
  {
    v14 = (id *)*((_QWORD *)this + 8);
    if (v14)
    {
      v15 = *((_QWORD *)this + 6);
      if (v15)
      {
        v16 = 8 * v15;
        do
        {
          objc_destroyWeak(v14);
          *v14++ = 0;
          v16 -= 8;
        }
        while (v16);
        v13 = *((_QWORD *)this + 4);
        v14 = (id *)*((_QWORD *)this + 8);
      }
      (*(void (**)(uint64_t, id *))(*(_QWORD *)v13 + 40))(v13, v14);
    }
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    ++*((_DWORD *)this + 14);
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::Transport::~Transport(this, a2);
  JUMPOUT(0x220780CD0);
}

double re::Transport::deinit(re::Transport *this)
{
  uint64_t v2;
  re *v3;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  re *v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  re *v19;
  void (***v20)(_QWORD);
  uint64_t v21;
  void (***v22)(_QWORD);
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  double result;
  re::Transport *v28;
  re::Transport *v29;
  uint64_t (**v30)();
  re::Transport *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t (***v34)();
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  atomic_store(0, (unsigned __int8 *)this + 336);
  v2 = *((_QWORD *)this + 72);
  if (v2)
  {

    *((_QWORD *)this + 72) = 0;
  }
  dispatch_queue_set_specific(*((dispatch_queue_t *)this + 47), this, 0, 0);
  v3 = (re *)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)&v30, (uint64_t)this + 120, 0);
  v28 = (re::Transport *)v30;
  v29 = v31;
  if ((uint64_t (**)())((char *)this + 120) != v30
    || (unsigned __int16)v31 != 0xFFFFLL
    || (v31 & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v6 = *((_QWORD *)this + 70);
      if (v6)
      {
        v7 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v28);
        (*(void (**)(uint64_t, re::Transport *, unint64_t))(*(_QWORD *)v6 + 40))(v6, this, v7);
      }
      if (*(_DWORD *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v28) == 1)
      {
        v8 = *((_QWORD *)this + 76);
        v9 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v28);
        (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v8 + 8))(v8, v9);
        v10 = (re *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v28);
        v11 = *((_QWORD *)v10 + 5);
        if (v11)
        {
          v12 = (id)(v11 + 8);
          v10 = (re *)(id)(v11 + 8);
        }
        v13 = re::globalAllocators(v10)[2];
        v30 = &off_24E072A78;
        v31 = this;
        v32 = v11;
        v33 = v13;
        v34 = &v30;
        (*(void (**)(_QWORD, uint64_t (***)()))(**((_QWORD **)this + 41) + 16))(*((_QWORD *)this + 41), &v30);
        if (v34)
        {
          ((void (*)(uint64_t (***)()))**v34)(v34);
          if (v34 != &v30)
            (*(void (**)(uint64_t))(*(_QWORD *)v33 + 40))(v33);
        }
        if (v11)

      }
      if (*(_QWORD *)(re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v28)
                     + 40))
      {
        v14 = *(_QWORD *)(re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v28)
                        + 40);
        if (v14)
          v15 = (id)(v14 + 8);
        os_unfair_lock_lock((os_unfair_lock_t)(v14 + 1764));
        *(_QWORD *)(v14 + 24) = 0;
        os_unfair_lock_unlock((os_unfair_lock_t)(v14 + 1764));
        v16 = re::globalAllocators((re *)(id)(v14 + 8))[2];
        v30 = &off_24E072AD0;
        v31 = this;
        v32 = v14;
        v33 = v16;
        v34 = &v30;
        (*(void (**)(_QWORD, uint64_t (***)()))(**((_QWORD **)this + 41) + 16))(*((_QWORD *)this + 41), &v30);
        if (v34)
        {
          ((void (*)(uint64_t (***)()))**v34)(v34);
          if (v34 != &v30)
            (*(void (**)(uint64_t))(*(_QWORD *)v33 + 40))(v33);
        }

      }
      v3 = (re *)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v28);
    }
    while (v28 != (re::Transport *)((char *)this + 120) || (unsigned __int16)v29 != 0xFFFF || WORD1(v29) != 0xFFFF);
  }
  v17 = re::globalAllocators(v3)[2];
  v30 = &off_24E072B28;
  v31 = this;
  v33 = v17;
  v34 = &v30;
  (*(void (**)(_QWORD, uint64_t (***)()))(**((_QWORD **)this + 41) + 16))(*((_QWORD *)this + 41), &v30);
  if (v34)
  {
    ((void (*)(uint64_t (***)()))**v34)(v34);
    if (v34 != &v30)
      (*(void (**)(uint64_t))(*(_QWORD *)v33 + 40))(v33);
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 41) + 32))(*((_QWORD *)this + 41));
  (*(void (**)(_QWORD))(**((_QWORD **)this + 40) + 32))(*((_QWORD *)this + 40));
  re::DataArray<re::Connection>::deinit((_DWORD *)this + 30);
  re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit((uint64_t *)this + 34, v18);
  v20 = (void (***)(_QWORD))*((_QWORD *)this + 41);
  if (v20)
  {
    v21 = re::globalAllocators(v19)[2];
    (**v20)(v20);
    v19 = (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v21 + 40))(v21, v20);
  }
  *((_QWORD *)this + 41) = 0;
  v22 = (void (***)(_QWORD))*((_QWORD *)this + 40);
  if (v22)
  {
    v23 = re::globalAllocators(v19)[2];
    (**v22)(v22);
    (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v23 + 40))(v23, v22);
  }
  *((_QWORD *)this + 40) = 0;
  v24 = *((_QWORD *)this + 9);
  if (v24)
  {

    *((_QWORD *)this + 9) = 0;
  }
  v25 = *((_QWORD *)this + 47);
  *((_QWORD *)this + 47) = 0;
  if (v25)
    dispatch_release(v25);
  v26 = *((_QWORD *)this + 48);
  if (v26)
  {

    *((_QWORD *)this + 48) = 0;
  }
  result = 0.0;
  *(_OWORD *)((char *)this + 600) = 0u;
  return result;
}

BOOL re::Transport::init(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject **v10;
  NSObject *v11;
  re *v12;
  NSObject *v13;
  _anonymous_namespace_ *v14;
  _anonymous_namespace_ *v15;
  const char *v16;
  int *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL8 v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  __n128 *v30;
  uint64_t v31;
  re *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  re *v37;
  uint64_t *v38;
  re::TransportCommandsDispatch *v39;
  re::TransportCommandsDispatch *v40;
  uint64_t *v41;
  uint64_t v42;
  char *v43;
  NSObject *v44;
  uint64_t *v45;
  re::TransportCommandsThreadedProtocol *v46;
  _anonymous_namespace_ *v47;
  const char *v48;
  size_t v49;
  __int128 v50;
  __int128 v51;
  re *v52;
  NSObject *v53;
  _BOOL8 v54;
  int v55;
  unsigned int v56;
  re *v57;
  NSObject *v58;
  _BOOL8 v59;
  int v60;
  NSObject *v61;
  int v62;
  NSObject *v63;
  int v66;
  char v67[4];
  int v68;
  uint8_t buf[16];
  const char *v70;
  uint64_t v71;
  uint8_t v72[8];
  size_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 600) = a2[12];
  v4 = *a2;
  v5 = *(_QWORD *)(a1 + 72);
  if (v5 != *a2)
  {
    if (v4)
    {
      v6 = (id)(v4 + 8);
      v5 = *(_QWORD *)(a1 + 72);
    }
    if (v5)

    *(_QWORD *)(a1 + 72) = v4;
  }
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 568), a2[4]);
  v7 = a2[12];
  if (v7)
    v8 = v7 + 24;
  else
    v8 = 0;
  *(_QWORD *)(a1 + 608) = v8;
  v9 = a2[1];
  if (v9)
    dispatch_retain((dispatch_object_t)a2[1]);
  v10 = (NSObject **)(a1 + 376);
  v11 = *(NSObject **)(a1 + 376);
  *(_QWORD *)(a1 + 376) = v9;
  if (v11)
  {
    dispatch_release(v11);
    v9 = *v10;
  }
  dispatch_queue_set_specific(v9, (const void *)a1, (void *)a1, 0);
  if (!*(_QWORD *)(a1 + 376))
  {
    v13 = *re::networkLogObjects(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v13, OS_LOG_TYPE_ERROR, "Invalid transport queue. Should be the same dispatch_queue that transport api will be called on.", buf, 2u);
    }
  }
  *(_OWORD *)buf = *(_OWORD *)v10;
  v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint8_t *))(**(_QWORD **)(a1 + 72) + 32))(*(_QWORD *)(a1 + 72), buf);
  if ((v14 & 1) != 0)
  {
    re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((_QWORD *)(a1 + 120), 0);
    ++*(_DWORD *)(a1 + 144);
    *(_DWORD *)(a1 + 164) = 64;
    v15 = re::DataArray<re::Connection>::allocBlock((_QWORD *)(a1 + 120));
    re::Defaults::intValue((re::Defaults *)"network.transport.compressionMethod", v16, (uint64_t)v67);
    if (v67[0])
      v17 = &v68;
    else
      v17 = (int *)(a2 + 2);
    *(_BYTE *)(a1 + 392) = *(_BYTE *)v17;
    v18 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 72) + 120))(*(_QWORD *)(a1 + 72), 0, 0);
    v19 = v18;
    v20 = *(_QWORD *)(a1 + 96);
    if (v20 >= v18)
    {
      if (v20 <= v18)
      {
LABEL_39:
        v32 = (re *)(*(uint64_t (**)(_QWORD, _QWORD, unint64_t))(**(_QWORD **)(a1 + 72) + 120))(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 112), v19);
        atomic_store(1u, (unsigned __int8 *)(a1 + 336));
        v33 = re::globalAllocators(v32);
        v34 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v33[2] + 32))(v33[2], 128, 8);
        v35 = 0;
        *(_QWORD *)v34 = &off_24E072450;
        *(_QWORD *)(v34 + 8) = 0x100000000;
        do
        {
          v36 = v34 + v35;
          *(_QWORD *)(v36 + 56) = 0;
          *(_OWORD *)(v36 + 16) = 0uLL;
          *(_OWORD *)(v36 + 32) = 0uLL;
          *(_DWORD *)(v36 + 48) = 0;
          v35 += 48;
        }
        while (v35 != 96);
        *(_DWORD *)(v34 + 112) = 0;
        *(_BYTE *)(v34 + 120) = 0;
        *(_QWORD *)(a1 + 320) = v34;
        v37 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 72) + 152))(*(_QWORD *)(a1 + 72));
        if ((_DWORD)v37)
        {
          if ((_DWORD)v37 == 2)
          {
            v41 = re::globalAllocators(v37);
            v40 = (re::TransportCommandsDispatch *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v41[2] + 32))(v41[2], 128, 8);
            v42 = 0;
            *(_QWORD *)v40 = &off_24E072450;
            *((_QWORD *)v40 + 1) = 0x100000000;
            do
            {
              v43 = (char *)v40 + v42;
              *((_QWORD *)v43 + 7) = 0;
              *((_OWORD *)v43 + 1) = 0uLL;
              *((_OWORD *)v43 + 2) = 0uLL;
              *((_DWORD *)v43 + 12) = 0;
              v42 += 48;
            }
            while (v42 != 96);
            *((_DWORD *)v40 + 28) = 0;
            *((_BYTE *)v40 + 120) = 0;
LABEL_51:
            *(_QWORD *)(a1 + 328) = v40;
            v47 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 72) + 112))(*(_QWORD *)(a1 + 72), a1 + 24);
            *(_QWORD *)&buf[8] = 0;
            v70 = 0;
            v71 = 0;
            re::DynamicString::setCapacity(buf, 0);
            if ((*(uint64_t (**)(_QWORD, uint8_t *, uint64_t))(**(_QWORD **)(a1 + 72) + 120))(*(_QWORD *)(a1 + 72), buf, 1))
            {
              if ((buf[8] & 1) != 0)
                v48 = v70;
              else
                v48 = (const char *)&buf[9];
            }
            else
            {
              v48 = "n/a";
            }
            v49 = strlen(v48);
            *(_QWORD *)v72 = v48;
            v73 = v49;
            re::DynamicString::operator=((re::DynamicString *)(a1 + 480), (uint64_t)v72);
            re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 560), a2[3]);
            v50 = *(_OWORD *)(a2 + 5);
            v51 = *(_OWORD *)(a2 + 7);
            *(_QWORD *)(a1 + 552) = a2[9];
            *(_OWORD *)(a1 + 520) = v50;
            *(_OWORD *)(a1 + 536) = v51;
            v52 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 72) + 144))(*(_QWORD *)(a1 + 72));
            *(_DWORD *)(a1 + 512) = (_DWORD)v52;
            v53 = *re::networkLogObjects(v52);
            v54 = os_log_type_enabled(v53, OS_LOG_TYPE_INFO);
            if (v54)
            {
              v55 = *(_DWORD *)(a1 + 512);
              *(_DWORD *)v72 = 67109120;
              *(_DWORD *)&v72[4] = v55;
              _os_log_impl(&dword_21C69B000, v53, OS_LOG_TYPE_INFO, "Transport preferred packet size: %d", v72, 8u);
            }
            v56 = *(_DWORD *)(a1 + 512);
            v25 = v56 > 0x14;
            if (v56 > 0x14)
            {
              *(_DWORD *)(a1 + 516) = v56 - 3;
              re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 576), a2[10]);
              *(_BYTE *)(a1 + 584) = *((_BYTE *)a2 + 88);
              v58 = *re::networkLogObjects(v57);
              v59 = os_log_type_enabled(v58, OS_LOG_TYPE_INFO);
              if (v59)
              {
                v60 = *(unsigned __int8 *)(a1 + 584);
                *(_DWORD *)v72 = 67109120;
                *(_DWORD *)&v72[4] = v60;
                _os_log_impl(&dword_21C69B000, v58, OS_LOG_TYPE_INFO, "Transport throttling enabled: %d", v72, 8u);
              }
              *(_BYTE *)(a1 + 585) = *((_BYTE *)a2 + 89);
              v61 = *re::networkLogObjects((re *)v59);
              if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
              {
                v62 = *(unsigned __int8 *)(a1 + 585);
                *(_DWORD *)v72 = 67109120;
                *(_DWORD *)&v72[4] = v62;
                _os_log_impl(&dword_21C69B000, v61, OS_LOG_TYPE_INFO, "Transport message fragmentation enabled: %d", v72, 8u);
              }
            }
            else
            {
              v63 = *re::networkLogObjects((re *)v54);
              if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              {
                v66 = *(_DWORD *)(a1 + 512);
                *(_DWORD *)v72 = 67109120;
                *(_DWORD *)&v72[4] = v66;
                _os_log_error_impl(&dword_21C69B000, v63, OS_LOG_TYPE_ERROR, "Invalid preferred packet size for transport: %u", v72, 8u);
              }
            }
            if (*(_QWORD *)buf && (buf[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
            return v25;
          }
          if ((_DWORD)v37 == 1)
          {
            v38 = re::globalAllocators(v37);
            v39 = (re::TransportCommandsDispatch *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v38[2] + 32))(v38[2], 24, 8);
            v40 = re::TransportCommandsDispatch::TransportCommandsDispatch(v39);
            goto LABEL_51;
          }
          v44 = *re::networkLogObjects(v37);
          v37 = (re *)os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v37)
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_21C69B000, v44, OS_LOG_TYPE_DEFAULT, "Unknown thread mode. Defaulting to ThreadWaitAndWake", buf, 2u);
          }
        }
        v45 = re::globalAllocators(v37);
        v46 = (re::TransportCommandsThreadedProtocol *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v45[2] + 32))(v45[2], 144, 8);
        v40 = re::TransportCommandsThreadedProtocol::TransportCommandsThreadedProtocol(v46, *(re::ProtocolLayer **)(a1 + 72));
        goto LABEL_51;
      }
      v26 = 32 * v18;
      v27 = 0uLL;
      v28 = v18;
      do
      {
        v29 = *(_QWORD *)(a1 + 112);
        v30 = (__n128 *)(v29 + v26);
        v31 = *(_QWORD *)(v29 + v26);
        if (v31)
        {
          if ((v30->n128_u8[8] & 1) != 0)
          {
            (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v31 + 40))(v31, *(_QWORD *)(v29 + v26 + 16), v27);
            v27 = 0uLL;
          }
          *v30 = v27;
          v30[1] = v27;
          v20 = *(_QWORD *)(a1 + 96);
        }
        ++v28;
        v26 += 32;
      }
      while (v28 < v20);
    }
    else
    {
      if (*(_QWORD *)(a1 + 88) < v18)
      {
        v18 = (unint64_t)re::DynamicArray<re::Address>::setCapacity((_QWORD *)(a1 + 80), v18);
        v20 = *(_QWORD *)(a1 + 96);
      }
      v21 = v19 - v20;
      if (v19 > v20)
      {
        v22 = 32 * v20;
        do
        {
          v23 = *(_QWORD *)(a1 + 112) + v22;
          *(_OWORD *)v23 = 0u;
          *(_OWORD *)(v23 + 16) = 0u;
          v18 = (unint64_t)re::DynamicString::setCapacity((_QWORD *)v23, 0);
          v22 += 32;
          --v21;
        }
        while (v21);
      }
    }
    *(_QWORD *)(a1 + 96) = v19;
    ++*(_DWORD *)(a1 + 104);
    goto LABEL_39;
  }
  v24 = *(_QWORD *)(a1 + 72);
  if (v24)
  {

    *(_QWORD *)(a1 + 72) = 0;
  }
  return 0;
}

uint64_t re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*(unsigned __int16 *a1)
{
  unint64_t v1;

  v1 = a1[5];
  if (*(_QWORD *)(*(_QWORD *)a1 + 16) <= v1)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 16 * v1) + 136 * a1[4];
}

_DWORD *re::DataArray<re::Connection>::deinit(_DWORD *result)
{
  _QWORD *v1;
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (!result[11])
    return result;
  v1 = result;
  re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)&v13, (uint64_t)result, 0);
  if ((_QWORD *)v13 != v1 || WORD4(v13) != 0xFFFFLL || (DWORD2(v13) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v4 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v13);
      re::DataArray<re::Connection>::destroy((uint64_t)v1, v4);
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v13);
    }
    while ((_QWORD *)v13 != v1 || WORD4(v13) != 0xFFFF || WORD5(v13) != 0xFFFF);
  }
  v7 = v1[2];
  v8 = v7 - 1;
  if (v7 != 1)
  {
    v9 = 16 * v7 - 16;
    do
    {
      if (v7 <= v8)
      {
        v16 = 0u;
        v17 = 0u;
        v14 = 0u;
        v15 = 0u;
        v13 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_34:
        v16 = 0u;
        v17 = 0u;
        v14 = 0u;
        v15 = 0u;
        v13 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v10 = (_QWORD *)(v1[4] + v9);
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, *v10);
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v10[1]);
      v11 = v1[2];
      if (v11 <= v8)
        goto LABEL_34;
      v7 = v11 - 1;
      if (v11 - 1 > v8)
      {
        *(_OWORD *)(v1[4] + v9) = *(_OWORD *)(v1[4] + 16 * v11 - 16);
        v7 = v1[2] - 1;
      }
      v1[2] = v7;
      ++*((_DWORD *)v1 + 6);
      v9 -= 16;
      --v8;
    }
    while (v8);
    v1[6] = 0xFFFFFFFF00000000;
    if (v7)
      goto LABEL_27;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v13 = 0u;
    v1 = (_QWORD *)MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v1[6] = 0xFFFFFFFF00000000;
LABEL_27:
  v12 = (_QWORD *)v1[4];
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, *v12);
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v12[1]);
  result = (_DWORD *)*v1;
  if (*v1)
  {
    if (v1[4])
      result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 40))(result);
    v1[4] = 0;
    v1[1] = 0;
    v1[2] = 0;
    *v1 = 0;
    ++*((_DWORD *)v1 + 6);
  }
  *((_DWORD *)v1 + 11) = 0;
  return result;
}

double re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit(uint64_t *a1, double result)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 v7;
  uint64_t v8;
  __n128 *v9;
  int v10;
  uint64_t v11;
  __n128 *v12;
  uint64_t v13;

  v3 = *a1;
  if (v3)
  {
    v4 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0uLL;
      do
      {
        v8 = a1[2];
        v9 = (__n128 *)(v8 + v5);
        v10 = *(_DWORD *)(v8 + v5 + 8);
        if (v10 < 0)
        {
          v9->n128_u32[2] = v10 & 0x7FFFFFFF;
          v13 = v9[1].n128_i64[0];
          v12 = v9 + 1;
          v11 = v13;
          if (v13)
          {
            if ((*(_BYTE *)(v8 + v5 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v8 + v5 + 32), v7);
              v7 = 0uLL;
            }
            *v12 = v7;
            v12[1] = v7;
            v4 = *((unsigned int *)a1 + 8);
          }
        }
        ++v6;
        v5 += 56;
      }
      while (v6 < v4);
      v3 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::Transport::flushNetworkEvents(re::Transport *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  size_t v11;
  uint8_t *v12;
  size_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  re::Transport *v19;
  re::Transport *v20;
  uint64_t v21;
  re::Transport **v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 41);
  v3 = re::globalAllocators(this)[2];
  v19 = (re::Transport *)&off_24E072B80;
  v20 = this;
  v21 = v3;
  v22 = &v19;
  (*(void (**)(uint64_t, re::Transport **))(*(_QWORD *)v2 + 16))(v2, &v19);
  if (v22)
  {
    (*(void (**)(re::Transport **))*v22)(v22);
    if (v22 != &v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 40))(v21);
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 41) + 24))(*((_QWORD *)this + 41));
  result = re::Transport::discardTimedoutPacketFragments((uint64_t)this);
  if (*((_QWORD *)this + 70))
  {
    result = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)&v19, (uint64_t)this + 120, 0);
    if ((re::Transport *)((char *)this + 120) != v19
      || (unsigned __int16)v20 != 0xFFFFLL
      || (v20 & 0xFFFF0000) != 0xFFFF0000)
    {
      do
      {
        v5 = *(_QWORD *)(re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v19)
                       + 40);
        if (v5)
        {
          v6 = 0;
          do
          {
            v7 = *((_QWORD *)this + 70);
            v8 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v19);
            v9 = v6;
            v10 = (*(uint64_t (**)(uint64_t, re::Transport *, unint64_t, _QWORD))(*(_QWORD *)v7 + 64))(v7, this, v8, v6);
            if (v11)
            {
              v12 = (uint8_t *)v10;
              v13 = v11;
              do
              {
                re::Transport::onReceiveData((uint64_t)this, v5, v6, v12, v13);
                v14 = *((_QWORD *)this + 70);
                v15 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v19);
                v12 = (uint8_t *)(*(uint64_t (**)(uint64_t, re::Transport *, unint64_t, _QWORD))(*(_QWORD *)v14 + 64))(v14, this, v15, v6);
                v13 = v16;
              }
              while (v16);
            }
            ++v6;
          }
          while (v9 < 9);
        }
        result = (uint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v19);
      }
      while (v19 != (re::Transport *)((char *)this + 120) || (unsigned __int16)v20 != 0xFFFF || WORD1(v20) != 0xFFFF);
    }
  }
  return result;
}

uint64_t re::Transport::discardTimedoutPacketFragments(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  re *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  uint64_t v14;
  int *v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  unint64_t v24;
  BOOL v25;
  NSObject *v26;
  int v27;
  uint64_t v30;
  _DWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint8_t buf[8];
  uint64_t v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(this + 585))
  {
    v1 = this;
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 568) + 32))(*(_QWORD *)(this + 568));
    if ((unint64_t)(this - *(_QWORD *)(v1 + 592)) >= 0x3E8)
    {
      v2 = this;
      v30 = v1;
      v3 = v1 + 120;
      this = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)buf, v3, 0);
      v33 = *(_QWORD *)buf;
      v34 = v36;
      if (v3 != *(_QWORD *)buf || (unsigned __int16)v36 != 0xFFFFLL || (v36 & 0xFFFF0000) != 4294901760)
      {
        do
        {
          v6 = (re *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v33);
          v7 = *((_QWORD *)v6 + 5);
          if (v7)
          {
            v8 = 0;
            v32 = *((_QWORD *)v6 + 5);
            do
            {
              v9 = v7 + 48 * v8;
              v10 = *(unsigned int *)(v9 + 464);
              if ((_DWORD)v10)
              {
                v11 = 0;
                v12 = (int *)(*(_QWORD *)(v7 + 48 * v8 + 448) + 8);
                while (1)
                {
                  v13 = *v12;
                  v12 += 20;
                  if (v13 < 0)
                    break;
                  if (v10 == ++v11)
                  {
                    v11 = *(unsigned int *)(v9 + 464);
                    break;
                  }
                }
              }
              else
              {
                v11 = 0;
              }
              if (v10 <= v11
                || (v14 = *(_QWORD *)(v7 + 48 * v8 + 448),
                    (*(_DWORD *)(v14 + 80 * v11 + 8) & 0x80000000) != 0))
              {
LABEL_23:
                if ((_DWORD)v10 != (_DWORD)v11)
                {
                  v31 = (_DWORD *)(v9 + 464);
                  v17 = v11;
                  v18 = (uint64_t *)(v32 + 48 * v8 + 448);
                  do
                  {
                    v19 = v17;
                    v20 = *v18;
                    v21 = *(unsigned __int16 *)(*v18 + 80 * v17 + 12);
                    if (v10 <= (int)v11 + 1)
                      v22 = v11 + 1;
                    else
                      v22 = v10;
                    v23 = v11;
                    while (1)
                    {
                      v17 = (v23 + 1);
                      if (v22 - 1 == v23)
                        break;
                      ++v23;
                      LODWORD(v11) = v17;
                      if ((*(_DWORD *)(v20 + 80 * v17 + 8) & 0x80000000) != 0)
                        goto LABEL_33;
                    }
                    LODWORD(v11) = v22;
LABEL_33:
                    v24 = *(_QWORD *)(v20 + 80 * v19 + 72);
                    if (v24)
                      v25 = v24 >= v2;
                    else
                      v25 = 1;
                    if (!v25)
                    {
                      v26 = *re::networkLogObjects(v6);
                      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                      {
                        v27 = *(_DWORD *)(v20 + 80 * v19 + 64);
                        *(_DWORD *)buf = 67109632;
                        *(_DWORD *)&buf[4] = v21;
                        LOWORD(v36) = 1024;
                        *(_DWORD *)((char *)&v36 + 2) = v8;
                        HIWORD(v36) = 1024;
                        v37 = v27;
                        _os_log_impl(&dword_21C69B000, v26, OS_LOG_TYPE_DEFAULT, "Message %u on channel %u timed-out waiting for fragment %u.", buf, 0x14u);
                      }
                      v6 = (re *)re::Transport::discardPacketFragments(v32, v8, v21);
                      LODWORD(v10) = *v31;
                    }
                  }
                  while ((_DWORD)v10 != (_DWORD)v11);
                }
              }
              else
              {
                v15 = (int *)(v14 + 80 * v11 + 88);
                while ((_DWORD)v10 - 1 != (_DWORD)v11)
                {
                  v16 = *v15;
                  v15 += 20;
                  LODWORD(v11) = v11 + 1;
                  if (v16 < 0)
                    goto LABEL_23;
                }
              }
              ++v8;
              v7 = v32;
            }
            while (v8 != 10);
          }
          this = (uint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v33);
        }
        while (v33 != v3 || (unsigned __int16)v34 != 0xFFFF || WORD1(v34) != 0xFFFF);
      }
      *(_QWORD *)(v30 + 592) = v2;
    }
  }
  return this;
}

uint64_t re::Transport::onReceiveData(uint64_t a1, uint64_t a2, uint64_t a3, uint8_t *a4, size_t a5)
{
  uint64_t v6;
  uint64_t *PacketHeaderFromBuffer;
  uint64_t v8;
  NSObject *v9;
  uint64_t result;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  uint8_t *v21;
  int v22;
  unsigned __int16 v23;
  unint64_t v24;
  uint64_t v25;
  re *v26;
  unsigned int v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  char *v50;
  re *v51;
  uint8_t *v52;
  size_t v53;
  uint64_t v54;
  compression_algorithm v55;
  size_t v56;
  re *v57;
  re *v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  re *v62;
  int v63;
  unsigned int v64;
  NSObject *v65;
  NSObject *v66;
  uint64_t v67;
  unint64_t **v68;
  unsigned int *v69;
  int v70;
  unsigned int v71;
  unint64_t *v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  id v78;
  NSObject *v79;
  _BOOL8 v80;
  const char *v81;
  NSObject *v82;
  uint32_t v83;
  NSObject *v84;
  unsigned int v85;
  uint64_t v86;
  _anonymous_namespace_ *v87;
  _anonymous_namespace_ *v88;
  NSObject *v89;
  uint64_t v90;
  size_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unsigned int v97;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  size_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  __int16 v109;
  unsigned __int8 v110;
  unsigned __int8 v111;
  __int16 v112;
  uint8_t *src_buffer;
  size_t src_size;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  _BYTE v119[12];
  __int16 v120;
  int v121;
  __int16 v122;
  uint64_t v123;
  __int16 v124;
  unint64_t v125;
  uint8_t buf[32];
  __int128 v127;
  __int128 v128;
  __int128 v129;
  uint64_t v130;

  v6 = a1;
  v130 = *MEMORY[0x24BDAC8D0];
  src_buffer = a4;
  src_size = a5;
  v109 = 0;
  v110 = 1;
  v111 = a3;
  v112 = 0;
  if (a5)
  {
    PacketHeaderFromBuffer = re::Transport::readPacketHeaderFromBuffer(a1, (uint64_t)a4, a3, (uint64_t)&v109);
    v8 = v111;
    if (v111 >= 0xBuLL)
    {
      v9 = *re::networkLogObjects((re *)PacketHeaderFromBuffer);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v8;
        _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", buf, 8u);
      }
      result = re::internal::enableSignposts(0, 0);
      if ((_DWORD)result)
        return kdebug_trace();
      return result;
    }
    src_buffer = (uint8_t *)re::Slice<unsigned char>::range(&src_buffer, 3uLL, src_size);
    src_size = v11;
  }
  else
  {
    v8 = a3;
  }
  v12 = re::internal::enableHighFrequencyNetworkTracing(0, 0);
  if ((_DWORD)v12)
  {
    v13 = *(_QWORD *)(v6 + 600);
    if (v13)
    {
      v14 = *(_QWORD *)(v13 + 2296);
      if (v14)
      {
        v15 = *(uint64_t **)(v13 + 2312);
        v16 = 8 * v14;
        while (1)
        {
          v17 = *v15;
          if (*(_QWORD *)(*v15 + 32) == *(_QWORD *)(a2 + 24))
            break;
          ++v15;
          v16 -= 8;
          if (!v16)
            goto LABEL_15;
        }
        v78 = (id)(v17 + 8);

      }
    }
LABEL_15:
    v12 = re::internal::enableSignposts(0, 0);
    if ((_DWORD)v12)
    {
      v12 = re::internal::enableHighFrequencyNetworkTracing(0, 0);
      if ((_DWORD)v12)
        v12 = kdebug_trace();
    }
  }
  v106 = 0;
  v107 = 0;
  v108 = 0;
  v18 = src_size;
  if (!HIBYTE(v109))
    goto LABEL_61;
  if (src_size <= 9)
  {
    v19 = *re::networkLogObjects((re *)v12);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
LABEL_46:
      memset(buf, 0, 24);
      goto LABEL_47;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v8;
    v20 = "Discarding fragment with invalid size (channel=%u)";
LABEL_22:
    _os_log_impl(&dword_21C69B000, v19, OS_LOG_TYPE_INFO, v20, buf, 8u);
    goto LABEL_46;
  }
  v21 = src_buffer;
  v22 = v110;
  v117 = 0;
  *(_QWORD *)buf = src_buffer;
  *(_DWORD *)&buf[8] = src_size;
  buf[12] = 0;
  *(_OWORD *)&buf[16] = 0uLL;
  *(_DWORD *)v119 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)buf, 0x10u, (unsigned int *)v119);
  v23 = *(_WORD *)v119;
  LOWORD(v115) = *(_WORD *)v119;
  *(_DWORD *)v119 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)buf, 0x20u, (unsigned int *)v119);
  v24 = *(unsigned int *)v119;
  HIDWORD(v115) = *(_DWORD *)v119;
  *(_DWORD *)v119 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)buf, 0x20u, (unsigned int *)v119);
  v25 = *(unsigned int *)v119;
  v116 = *(_DWORD *)v119;
  v118 = 0;
  *(_QWORD *)v119 = 0;
  v26 = (re *)re::BiasedVLQ::read((re::BiasedVLQ *)&v118, (re::BitReader *)buf, (uint64_t *)v119);
  if (!(_DWORD)v26
    || (v27 = *(_DWORD *)v119,
        LODWORD(v117) = *(_DWORD *)v119,
        v118 = 0,
        v26 = (re *)re::BiasedVLQ::read((re::BiasedVLQ *)&v118, (re::BitReader *)buf, (uint64_t *)v119),
        (v26 & 1) == 0))
  {
    v42 = *re::networkLogObjects(v26);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v8;
      _os_log_impl(&dword_21C69B000, v42, OS_LOG_TYPE_INFO, "Discarding fragment with unreadable header (channel=%u)", buf, 8u);
    }
    goto LABEL_46;
  }
  HIDWORD(v117) = *(_DWORD *)v119;
  if (!(_DWORD)v25)
  {
    v79 = *re::networkLogObjects(v26);
    v80 = os_log_type_enabled(v79, OS_LOG_TYPE_ERROR);
    if (!v80)
      goto LABEL_103;
    *(_QWORD *)buf = 67110144;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = 1;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = -1;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v23;
    *(_WORD *)&buf[26] = 1024;
    *(_DWORD *)&buf[28] = v24;
    v81 = "Fragment count is not within range %u [%u, %u]. Fragment %u, %u will be discarded.";
    v82 = v79;
    v83 = 32;
LABEL_102:
    _os_log_error_impl(&dword_21C69B000, v82, OS_LOG_TYPE_ERROR, v81, buf, v83);
    goto LABEL_103;
  }
  if (v24 >= v25)
  {
    v18 = *re::networkLogObjects(v26);
    v80 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!v80)
      goto LABEL_103;
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v24;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v25;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = v23;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v24;
    v81 = "Fragment index is out of bounds [%u, %u]. Fragment %u, %u will be discarded.";
    v82 = v18;
    v83 = 26;
    goto LABEL_102;
  }
  if (!v27)
  {
    v84 = *re::networkLogObjects(v26);
    v80 = os_log_type_enabled(v84, OS_LOG_TYPE_ERROR);
    if (v80)
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v23;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v24;
      v81 = "Big packet size is not set. Fragment %u, %u will be discarded.";
      v82 = v84;
      v83 = 14;
      goto LABEL_102;
    }
LABEL_103:
    v19 = *re::networkLogObjects((re *)v80);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      goto LABEL_46;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v8;
    v20 = "Discarding fragment with invalid header values (channel=%u)";
    goto LABEL_22;
  }
  v28 = 11;
  if (v27 >= 0x80)
  {
    v29 = v27;
    do
    {
      v30 = v29 >> 14;
      v29 >>= 7;
      ++v28;
    }
    while (v30);
  }
  v31 = 1;
  if (*(_DWORD *)v119 >= 0x80u)
  {
    v32 = *(unsigned int *)v119;
    do
    {
      ++v31;
      v33 = v32 >> 14;
      v32 >>= 7;
    }
    while (v33);
  }
  v34 = (v31 + v28);
  if ((unint64_t)v18 <= v34)
  {
    v19 = *re::networkLogObjects(v26);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      goto LABEL_46;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v8;
    v20 = "Discarding fragment with empty payload (channel=%u)";
    goto LABEL_22;
  }
  v102 = (size_t)v18 - v34;
  v103 = *(unsigned int *)v119;
  v104 = v34;
  v18 = (a2 + 48 * v8 + 432);
  v105 = v23;
  v35 = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::tryGet((uint64_t)v18, v23);
  if (!v35)
  {
    v127 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    v36 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v105) ^ ((0xBF58476D1CE4E5B9 * v105) >> 27));
    v37 = v36 ^ (v36 >> 31);
    if (v18->isa)
    {
      v38 = a2 + 48 * v8;
      v39 = v37 % *(unsigned int *)(v38 + 456);
      v40 = *(unsigned int *)(*(_QWORD *)(v38 + 440) + 4 * v39);
      if ((_DWORD)v40 != 0x7FFFFFFF)
      {
        v41 = *(_QWORD *)(a2 + 48 * v8 + 448);
        if (*(unsigned __int16 *)(v41 + 80 * v40 + 12) == (_DWORD)v105)
        {
LABEL_43:
          v35 = v41 + 80 * v40 + 16;
LABEL_111:
          v87 = *(_anonymous_namespace_ **)buf;
          if (*(_QWORD *)buf && *(_QWORD *)&buf[8])
            v87 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, *(_QWORD *)&buf[16]);
          *(_QWORD *)(v35 + 32) = v25;
          *(_QWORD *)(v35 + 40) = v89;
          if (!v89)
          {
            re::internal::assertLog((re::internal *)4, v90, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
            result = _os_crash();
            __break(1u);
            return result;
          }
          v18 = v89;
          v91 = v25 - 1;
          if (v91)
          {
            bzero(v89, v91);
            v18 = ((char *)v18 + v91);
          }
          LOBYTE(v18->isa) = 0;
          *(_DWORD *)(v35 + 48) = 0;
          goto LABEL_118;
        }
        while (1)
        {
          LODWORD(v40) = *(_DWORD *)(v41 + 80 * v40 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v40 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int16 *)(v41 + 80 * v40 + 12) == (_DWORD)v105)
            goto LABEL_43;
        }
      }
    }
    else
    {
      LODWORD(v39) = 0;
    }
    v85 = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove((uint64_t)v18, v39, v37, &v115, (uint64_t)buf);
    v86 = a2 + 48 * v8;
    ++*(_DWORD *)(v86 + 472);
    v35 = *(_QWORD *)(v86 + 448) + 80 * v85 + 16;
    if (*(_QWORD *)&buf[24] && (_QWORD)v127)
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)&buf[24] + 40))(*(_QWORD *)&buf[24], *((_QWORD *)&v127 + 1));
    goto LABEL_111;
  }
LABEL_118:
  v92 = v104;
  if (!v22)
  {
    v93 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 568) + 32))(*(_QWORD *)(v6 + 568));
    v92 = v104;
    *(_QWORD *)(v35 + 56) = v93 + 1000;
  }
  memcpy((void *)(*(_QWORD *)(v35 + 16) + v103), &v21[v92], v102);
  v94 = *(_QWORD *)(v35 + 32);
  if (v94 <= v24)
  {
    v118 = 0;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v119 = 136315906;
    *(_QWORD *)&v119[4] = "operator[]";
    v120 = 1024;
    v121 = 468;
    v122 = 2048;
    v123 = v24;
    v124 = 2048;
    v125 = v94;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v95 = *(_QWORD *)(v35 + 40);
  *(_BYTE *)(v95 + v24) = 1;
  v96 = *(unsigned int *)(v35 + 48);
  if (v94 > v96)
  {
    v97 = v96 + 1;
    while (*(_BYTE *)(v95 + v96))
    {
      *(_DWORD *)(v35 + 48) = v97;
      v96 = v97;
      if (v94 <= v97++)
        goto LABEL_125;
    }
    goto LABEL_46;
  }
LABEL_125:
  *(_OWORD *)buf = *(_OWORD *)v35;
  v99 = *(_QWORD *)(v35 + 16);
  *(_QWORD *)(v35 + 8) = 0;
  *(_QWORD *)(v35 + 16) = 0;
  *(_QWORD *)v35 = 0;
  *(_QWORD *)&buf[16] = v99;
  re::Transport::discardPacketFragments(a2, v8, v105);
LABEL_47:
  re::FixedArray<unsigned char>::operator=(&v106, (uint64_t *)buf);
  v44 = *(_QWORD *)buf;
  if (*(_QWORD *)buf)
    v45 = *(_QWORD *)&buf[8] == 0;
  else
    v45 = 1;
  if (!v45)
    v44 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, *(_QWORD *)&buf[16]);
  if (!v107)
    goto LABEL_91;
  v46 = re::Transport::readPacketHeaderFromBuffer(v44, v108, v43, (uint64_t)&v109);
  v8 = v111;
  if (v111 < 0xBuLL)
  {
    v49 = v107;
    v50 = (char *)(v107 + 1);
    if ((unint64_t)(v107 + 1) <= 3)
    {
      v115 = 0;
      v128 = 0u;
      v129 = 0u;
      v127 = 0u;
      memset(buf, 0, sizeof(buf));
      v6 = MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v119 = 136315906;
      *(_QWORD *)&v119[4] = "slice";
      v120 = 1024;
      v121 = 502;
      v122 = 2048;
      v123 = 3;
      v124 = 2048;
      v125 = (unint64_t)v50;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      v18 = (v107 - 3);
      if ((unint64_t)(v107 - 3) < 0xFFFFFFFFFFFFFFFDLL)
      {
        src_buffer = (uint8_t *)(v108 + 3);
        src_size = v107 - 3;
LABEL_61:
        if ((_BYTE)v109 && (unint64_t)v18 > 3)
        {
          v51 = (re *)*(unsigned int *)src_buffer;
          v52 = (uint8_t *)re::Slice<unsigned char>::range(&src_buffer, 4uLL, (unint64_t)v18);
          src_buffer = v52;
          src_size = v53;
          if (v51 > 0x8000000)
          {
            v65 = *re::networkLogObjects((re *)v52);
            if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&buf[4] = (_DWORD)v51;
              *(_WORD *)&buf[8] = 2048;
              *(_QWORD *)&buf[10] = 0x8000000;
              _os_log_error_impl(&dword_21C69B000, v65, OS_LOG_TYPE_ERROR, "Inbound message decompressedLen(%u) exceeds kMaxSupportedMessageSize (%zu), message may be corrupted.", buf, 0x12u);
            }
            goto LABEL_91;
          }
          v50 = re::PacketPool::allocate(*(re::PacketPool **)(v6 + 384), ((_DWORD)v51 + 3));
          re::Packet::offsetBy((uint64_t)v50, 3);
          v54 = *((_QWORD *)v50 + 1);
          *(_BYTE *)(v54 + 2) = 0;
          *(_WORD *)v54 = 0;
          re::Transport::writePacketHeader((uint64_t)v50, (unsigned __int8 *)&v109, 8);
          v56 = compression_decode_scratch_buffer_size(v55);
          if (*(_QWORD *)(v6 + 448) < v56)
            re::DynamicArray<unsigned char>::resize(v6 + 440, v56);
          v57 = (re *)compression_decode_buffer(*((uint8_t **)v50 + 2), *((unsigned int *)v50 + 7), src_buffer, src_size, *(void **)(v6 + 472), v55);
          if (v57 != v51)
          {
            v58 = v57;
            v59 = *re::networkLogObjects(v57);
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = v58;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = (_DWORD)v51;
              _os_log_error_impl(&dword_21C69B000, v59, OS_LOG_TYPE_ERROR, "Inbound message decompressed length (%zu) is not the expected length (%u), message discarded!", buf, 0x12u);
            }
            re::PacketPool::free(*(re::PacketPool **)(v6 + 384), (re::Packet *)v50);
            goto LABEL_91;
          }
        }
        else
        {
          v50 = re::PacketPool::allocate(*(re::PacketPool **)(v6 + 384), ((_DWORD)v18 + 3));
          re::Packet::offsetBy((uint64_t)v50, 3);
          v60 = *((_QWORD *)v50 + 1);
          *(_BYTE *)(v60 + 2) = 0;
          *(_WORD *)v60 = 0;
          re::Transport::writePacketHeader((uint64_t)v50, (unsigned __int8 *)&v109, 8);
          memcpy(*((void **)v50 + 2), src_buffer, src_size);
          LODWORD(v51) = src_size;
        }
        *((_DWORD *)v50 + 6) = (_DWORD)v51;
        os_unfair_lock_lock((os_unfair_lock_t)(a2 + 1764));
        v61 = *(_QWORD *)(a2 + 24);
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 1764));
        if (!v61)
        {
          v66 = *re::networkLogObjects(v62);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl(&dword_21C69B000, v66, OS_LOG_TYPE_DEBUG, "Received data for unbound connection object.", buf, 2u);
          }
          goto LABEL_89;
        }
        if ((_DWORD)v8 != 1)
        {
          v64 = v8;
LABEL_81:
          v67 = a2 + 40 * v64;
          v68 = (unint64_t **)(v67 + 1312);
          v69 = (unsigned int *)(v67 + 1336);
          v70 = *((_DWORD *)v50 + 6);
          do
            v71 = __ldxr(v69);
          while (__stlxr(v71 + v70, v69));
          v72 = (unint64_t *)(a2 + 40 * v64 + 1344);
          v73 = *((unsigned int *)v50 + 7);
          do
            v74 = __ldxr(v72);
          while (__stlxr(v74 + v73, v72));
          v75 = (unint64_t *)(a2 + 40 * v64 + 1328);
          do
            v76 = __ldxr(v75);
          while (__stlxr(v76 + 1, v75));
          atomic_store((unint64_t)v50, *v68);
          *v68 = (unint64_t *)v50;
          goto LABEL_88;
        }
        v63 = re::Transport::dispatchPacketToStream((re::Transport *)v6, (re::Packet *)v50, *(_QWORD *)(a2 + 24));
        if (!v63)
        {
LABEL_88:
          (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(v6 + 608) + 24))(*(_QWORD *)(v6 + 608), *(_QWORD *)(a2 + 24), v8, *((_QWORD *)v50 + 2), *((unsigned int *)v50 + 6));
          goto LABEL_89;
        }
        if (v63 == 2)
        {
          v64 = 1;
          goto LABEL_81;
        }
LABEL_128:
        re::PacketPool::free(*(re::PacketPool **)(v6 + 384), (re::Packet *)v50);
LABEL_89:
        v77 = *(_QWORD *)(v6 + 576);
        if (v77)
          (*(void (**)(uint64_t, size_t))(*(_QWORD *)v77 + 40))(v77, src_size);
        goto LABEL_91;
      }
    }
    re::internal::assertLog((re::internal *)7, v47, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu", "!overflow", "slice", 508, 3, v18, v49);
    _os_crash();
    __break(1u);
    re::internal::assertLog((re::internal *)7, v100, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size = %zu", "endIndexExclusive <= m_size", "slice", 512, 3, v18, v101);
    _os_crash();
    __break(1u);
    goto LABEL_128;
  }
  v48 = *re::networkLogObjects((re *)v46);
  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v8;
    _os_log_error_impl(&dword_21C69B000, v48, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", buf, 8u);
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
LABEL_91:
  result = v106;
  if (v106 && v107)
    return (*(uint64_t (**)(void))(*(_QWORD *)v106 + 40))();
  return result;
}

void re::Transport::flushOutgoingData(re::Transport *this)
{
  re::Transport *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[3];
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  v1 = this;
  v7 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 584))
    this = (re::Transport *)re::Transport::queueThrottledPacketsForSend(this);
  v2 = *((_QWORD *)v1 + 41);
  v3 = re::globalAllocators(this)[2];
  v4[0] = &off_24E072BD8;
  v4[1] = v1;
  v5 = v3;
  v6 = v4;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 16))(v2, v4);
  if (v6)
  {
    (*(void (**)(_QWORD *))*v6)(v6);
    if (v6 != v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
  }
  (*(void (**)(_QWORD))(**((_QWORD **)v1 + 41) + 24))(*((_QWORD *)v1 + 41));
  re::PacketPool::emitAriadneSignpost(*((os_unfair_lock_s **)v1 + 48));
}

uint64_t re::Transport::queueThrottledPacketsForSend(re::Transport *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  re::NetworkFeatureFlags *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unint64_t v40;
  re *v41;
  BOOL v42;
  re *v43;
  NSObject *v44;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  NSObject *log;
  unsigned int v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  _BYTE buf[18];
  __int16 v65;
  int v66;
  __int16 v67;
  unint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 71) + 32))(*((_QWORD *)this + 71));
  v4 = v2 - *((_DWORD *)this + 176);
  *((_QWORD *)this + 88) = v2;
  if (v4 <= 0x3E8)
  {
    v5 = *((unsigned int *)this + 174);
    if (v5 >= 0x14)
    {
      re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) ", "m_index < kHistorySize", "measure", 1985);
      _os_crash();
      __break(1u);
    }
    *((_DWORD *)this + 175) = *((_DWORD *)this + 175) + v4 - *((_DWORD *)this + v5 + 154);
    *((_DWORD *)this + v5 + 154) = v4;
    v6 = *((_DWORD *)this + 174);
    if ((v6 + 1) <= 0x13)
      v7 = v6 + 1;
    else
      v7 = 0;
    *((_DWORD *)this + 174) = v7;
  }
  v8 = *((_DWORD *)this + 175);
  if (v8 < 0x14)
    v9 = 1;
  else
    v9 = v8 / 0x14;
  v10 = *((_QWORD *)this + 72);
  if (v10)
    v11 = *(_QWORD *)(v10 + 80) * v9 / 0x3E8uLL;
  else
    v11 = -1;
  v12 = (char *)this + 120;
  result = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)buf, (uint64_t)this + 120, 0);
  v62 = *(char **)buf;
  v63 = *(_QWORD *)&buf[8];
  if ((re::Transport *)((char *)this + 120) == *(re::Transport **)buf
    && *(unsigned __int16 *)&buf[8] == 0xFFFFLL
    && (*(_DWORD *)&buf[8] & 0xFFFF0000) == 0xFFFF0000)
  {
    return result;
  }
  v14 = 0;
  do
  {
    v15 = re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v62);
    if (*(_QWORD *)(v15 + 96))
    {
      ++v14;
      *(_DWORD *)(v15 + 112) = 1023;
    }
    result = (uint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v62);
  }
  while (v62 != v12 || (unsigned __int16)v63 != 0xFFFF || WORD1(v63) != 0xFFFF);
  if (!v14 || !v11)
    return result;
  do
  {
    result = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)buf, (uint64_t)v12, 0);
    v62 = *(char **)buf;
    v63 = *(_QWORD *)&buf[8];
    if (v12 == *(char **)buf
      && *(unsigned __int16 *)&buf[8] == 0xFFFFLL
      && (*(_DWORD *)&buf[8] & 0xFFFF0000) == 4294901760)
    {
      continue;
    }
    while (2)
    {
      v20 = (re::NetworkFeatureFlags *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v62);
      if (!*((_DWORD *)v20 + 28))
        goto LABEL_65;
      v21 = (uint64_t)v20;
      v22 = re::NetworkFeatureFlags::enableTransportLog(v20);
      if ((_DWORD)v22)
      {
        v23 = *re::networkLogObjects((re *)v22);
        v22 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v22)
        {
          v53 = *(_QWORD *)(v21 + 24);
          if ((*(_BYTE *)(v21 + 16) & 1) == 0)
            v53 = v21 + 17;
          v54 = *((_QWORD *)this + 72);
          if (v54)
            v55 = *(_DWORD *)(v54 + 72);
          else
            v55 = -1;
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = v53;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v55;
          v65 = 1024;
          v66 = v9;
          v67 = 2048;
          v68 = v11;
          _os_log_debug_impl(&dword_21C69B000, v23, OS_LOG_TYPE_DEBUG, "Trying to send packet for connection: %s, total available bandwidth: %d bps, time slice: %d ms, slice bandwidth: %llu bits\n", buf, 0x22u);
        }
      }
      v24 = *(_QWORD *)(v21 + 96);
      if (v24)
        v25 = v11 == 0;
      else
        v25 = 1;
      if (v25)
        goto LABEL_57;
      v61 = v14;
      v26 = (uint64_t)v12;
      if (!*(_DWORD *)(v21 + 116))
      {
        v47 = *((_QWORD *)this + 75);
        if (v47)
        {
          v22 = re::DataArray<re::Connection>::handle(v26, v21);
          v48 = *(_QWORD *)(v47 + 2296);
          if (v48)
          {
            v49 = *(uint64_t **)(v47 + 2312);
            v50 = 8 * v48;
            while (1)
            {
              v51 = *v49;
              if (*(_QWORD *)(*v49 + 32) == v22)
                break;
              ++v49;
              v50 -= 8;
              if (!v50)
                goto LABEL_44;
            }
            v52 = (id)(v51 + 8);
            *(_DWORD *)(v21 + 116) = *(_DWORD *)(v51 + 72);

          }
        }
      }
LABEL_44:
      v27 = *(unsigned __int8 *)(v21 + 108);
      v28 = *(_DWORD *)(v21 + 112);
      v29 = v27 + 1;
      v30 = 40 * v27;
      v31 = *(unsigned __int8 *)(v21 + 108);
      v32 = v31;
      while (1)
      {
        v33 = 1 << (v32 % 0xA);
        if ((v33 & v28) != 0)
          break;
LABEL_48:
        ++v32;
        ++v29;
        v30 += 40;
        ++v27;
        if (v32 >= v31 + 10)
          goto LABEL_56;
      }
      v34 = *(_QWORD *)(v21 + 40);
      if (!atomic_load(*(unint64_t **)(v34 + v30 - 400 * (v27 / 0xA) + 40)))
      {
        v28 = *(_DWORD *)(v21 + 112) & (v33 ^ 0x3FF);
        *(_DWORD *)(v21 + 112) = v28;
        v31 = *(unsigned __int8 *)(v21 + 108);
        goto LABEL_48;
      }
      v60 = v32 % 0xA;
      v36 = re::PacketQueue::dequeue((unint64_t **)(v34 + v30 - 400 * (v27 / 0xA) + 32));
      v37 = (unint64_t)v36;
      --*(_QWORD *)(v21 + 96);
      v38 = (8 * *((_DWORD *)v36 + 6));
      v39 = v11 >= v38;
      v40 = v11 - v38;
      if (v39)
        v11 = v40;
      else
        v11 = 0;
      v41 = (re *)re::NetworkFeatureFlags::enableTransportLog((re::NetworkFeatureFlags *)v36);
      if ((_DWORD)v41)
      {
        log = *re::networkLogObjects(v41);
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          if ((*(_QWORD *)(v21 + 16) & 1) != 0)
            v57 = *(_QWORD *)(v21 + 24);
          else
            v57 = v21 + 17;
          v58 = *(_DWORD *)(v37 + 24);
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v57;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v60;
          v65 = 1024;
          v66 = v58;
        }
      }
      v22 = re::Transport::queuePacketForProtocol((uint64_t)this, v37, v21, v60);
      *(_BYTE *)(v21 + 108) = v29 % 0xA;
LABEL_56:
      v24 = *(_QWORD *)(v21 + 96);
      v12 = (char *)v26;
      v14 = v61;
LABEL_57:
      if (v24)
        v42 = *(_DWORD *)(v21 + 112) == 0;
      else
        v42 = 1;
      if (v42)
      {
        v43 = (re *)re::NetworkFeatureFlags::enableTransportLog((re::NetworkFeatureFlags *)v22);
        if ((_DWORD)v43)
        {
          v44 = *re::networkLogObjects(v43);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
            if ((*(_QWORD *)(v21 + 16) & 1) != 0)
              v56 = *(_QWORD *)(v21 + 24);
            else
              v56 = v21 + 17;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v56;
            _os_log_debug_impl(&dword_21C69B000, v44, OS_LOG_TYPE_DEBUG, "No more send channels for connection: %s", buf, 0xCu);
          }
        }
        --v14;
        *(_DWORD *)(v21 + 112) = 0;
      }
LABEL_65:
      result = (uint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v62);
      if (v62 != v12 || (unsigned __int16)v63 != 0xFFFF || WORD1(v63) != 0xFFFF)
        continue;
      break;
    }
  }
  while (v14 && v11);
  return result;
}

unint64_t re::Transport::connect(re::Transport *this, const re::Address *a2)
{
  uint64_t v4;
  unint64_t Connection;
  re *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  char v11;
  unint64_t v12;
  _BYTE v13[24];
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::tryGet((uint64_t)this + 272, a2);
  if (v4)
    return *(_QWORD *)v4;
  Connection = re::Transport::createConnection(this, a2);
  v7 = re::DynamicString::DynamicString((re::DynamicString *)&v10, a2);
  v12 = Connection;
  v8 = re::globalAllocators(v7)[2];
  v14 = v8;
  v15 = 0;
  if (v8)
    v9 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, 56, 0);
  else
    v9 = 0;
  *v9 = off_24E072C30;
  v9[1] = this;
  re::DynamicString::DynamicString((re::DynamicString *)(v9 + 2), (const re::DynamicString *)&v10);
  v9[6] = v12;
  v15 = v9;
  (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 41) + 16))(*((_QWORD *)this + 41), v13);
  if (v15)
  {
    (**(void (***)(_BYTE *))v15)(v15);
    if (v15 != v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
    v15 = 0;
  }
  if (v10 && (v11 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v10 + 40))();
  return Connection;
}

uint64_t re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::tryGet(uint64_t a1, re::Address *this)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = re::Address::hash(this);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==((uint64_t)this, v6 + 56 * v5 + 16))
  {
    v5 = *(_DWORD *)(v6 + 56 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v6 + 56 * v5 + 48;
}

unint64_t re::Transport::createConnection(re::Transport *this, const re::Address *a2)
{
  NSObject *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  int v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  size_t v18;
  size_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v29;
  __int128 v30;
  uint8_t buf[32];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if ((*((_BYTE *)this + 488) & 1) != 0)
      v6 = (char *)*((_QWORD *)this + 62);
    else
      v6 = (char *)this + 489;
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v7 = (char *)*((_QWORD *)a2 + 2);
    else
      v7 = (char *)a2 + 9;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v6;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v7;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Create connection(%s->%s)", buf, 0x16u);
  }
  v8 = *((_DWORD *)this + 44);
  if ((v8 + 1) >> 24)
    v9 = 1;
  else
    v9 = v8 + 1;
  *((_DWORD *)this + 44) = v9;
  v10 = *((unsigned __int16 *)this + 86);
  v11 = *((unsigned __int16 *)this + 87);
  if (v10 != 0xFFFF || (_DWORD)v11 != 0xFFFF)
  {
    if (*((_QWORD *)this + 17) > v11)
    {
      v13 = (_QWORD *)(*((_QWORD *)this + 19) + 16 * v11);
      *(_DWORD *)(v13[1] + 4 * v10) = v9;
      v14 = *v13 + 136 * v10;
      *((_DWORD *)this + 43) = *(_DWORD *)v14;
      goto LABEL_23;
    }
    v33 = 0u;
    v34 = 0u;
    v32 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_40;
  }
  if (*((_DWORD *)this + 42) >= *((_DWORD *)this + 41))
    re::DataArray<re::Connection>::allocBlock((_QWORD *)this + 15);
  v15 = *((_QWORD *)this + 17);
  v11 = (unsigned __int16)(v15 - 1);
  if (!v15)
  {
LABEL_40:
    v29 = 0;
    v33 = 0u;
    v34 = 0u;
    v32 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v30) = 136315906;
    *(_QWORD *)((char *)&v30 + 4) = "operator[]";
    WORD6(v30) = 1024;
    HIWORD(v30) = 789;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_41:
    re::internal::assertLog((re::internal *)5, v5, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v10, v29, v30);
    _os_crash();
    __break(1u);
  }
  v10 = *((unsigned int *)this + 42);
  if (v10 >= 0x10000)
    goto LABEL_41;
  v16 = (_QWORD *)(*((_QWORD *)this + 19) + 16 * v11);
  *((_DWORD *)this + 42) = v10 + 1;
  *(_DWORD *)(v16[1] + 4 * v10) = *((_DWORD *)this + 44);
  v14 = *v16 + 136 * v10;
LABEL_23:
  ++*((_DWORD *)this + 40);
  *(_DWORD *)v14 = 0;
  re::DynamicString::DynamicString((re::DynamicString *)(v14 + 8), a2);
  *(_OWORD *)(v14 + 68) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_QWORD *)(v14 + 84) = 0x7FFFFFFFLL;
  *(_QWORD *)(v14 + 96) = 0;
  *(_DWORD *)(v14 + 104) = 0;
  *(_BYTE *)(v14 + 108) = 0;
  *(_QWORD *)(v14 + 112) = 0;
  *(_BYTE *)(v14 + 120) = 0;
  *(_QWORD *)(v14 + 128) = 0x8000000000000000;
  v17 = (v11 << 16) | ((unint64_t)(*((_DWORD *)this + 44) & 0xFFFFFF) << 32) | v10;
  v18 = re::Address::hash(a2);
  v19 = v18;
  if (!*((_QWORD *)this + 34))
  {
    LODWORD(v20) = 0;
    goto LABEL_30;
  }
  v20 = v18 % *((unsigned int *)this + 74);
  v21 = *(unsigned int *)(*((_QWORD *)this + 35) + 4 * v20);
  if ((_DWORD)v21 == 0x7FFFFFFF)
  {
LABEL_30:
    v23 = *((unsigned int *)this + 77);
    if ((_DWORD)v23 == 0x7FFFFFFF)
    {
      v23 = *((unsigned int *)this + 76);
      v24 = v23;
      if ((_DWORD)v23 == *((_DWORD *)this + 74))
      {
        re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::setCapacity((uint64_t)this + 272, 2 * *((_DWORD *)this + 75));
        LODWORD(v20) = v19 % *((unsigned int *)this + 74);
        v24 = *((_DWORD *)this + 76);
      }
      *((_DWORD *)this + 76) = v24 + 1;
      v25 = *((_QWORD *)this + 36);
      v26 = *(_DWORD *)(v25 + 56 * v23 + 8);
    }
    else
    {
      v25 = *((_QWORD *)this + 36);
      v26 = *(_DWORD *)(v25 + 56 * v23 + 8);
      *((_DWORD *)this + 77) = v26 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v25 + 56 * v23 + 8) = v26 | 0x80000000;
    *(_DWORD *)(*((_QWORD *)this + 36) + 56 * v23 + 8) = *(_DWORD *)(*((_QWORD *)this + 36) + 56 * v23 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 35) + 4 * v20);
    *(_QWORD *)(*((_QWORD *)this + 36) + 56 * v23) = v19;
    re::DynamicString::DynamicString((re::DynamicString *)(*((_QWORD *)this + 36) + 56 * v23 + 16), a2);
    *(_QWORD *)(*((_QWORD *)this + 36) + 56 * v23 + 48) = v17;
    *(_DWORD *)(*((_QWORD *)this + 35) + 4 * v20) = v23;
    ++*((_DWORD *)this + 75);
    ++*((_DWORD *)this + 78);
    goto LABEL_36;
  }
  v22 = *((_QWORD *)this + 36);
  while (!re::DynamicString::operator==((uint64_t)a2, v22 + 56 * v21 + 16))
  {
    v21 = *(_DWORD *)(v22 + 56 * v21 + 8) & 0x7FFFFFFF;
    if (v21 == 0x7FFFFFFF)
      goto LABEL_30;
  }
LABEL_36:
  v27 = *((_QWORD *)this + 70);
  if (v27)
    (*(void (**)(uint64_t, re::Transport *, unint64_t))(*(_QWORD *)v27 + 32))(v27, this, v17);
  return v17;
}

void re::Transport::disconnect(re::Transport *this, unint64_t a2, int a3)
{
  _anonymous_namespace_ *v6;
  NSObject *v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;

  v6 = (_anonymous_namespace_ *)re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (v6)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    re::DynamicString::setCapacity(&v9, 0);
    v8 = 1;
    v13 = a3;
    re::Transport::connectionStateEvent((uint64_t)this, a2, &v8);
    if (v9)
    {
      if ((v10 & 1) != 0)
        (*(void (**)(void))(*v9 + 40))();
    }
  }
  else
  {
    v7 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v8) = 0;
      _os_log_debug_impl(&dword_21C69B000, v7, OS_LOG_TYPE_DEBUG, "Attempt to disconnect connection that does not exist. This can happen if connection broke right before this request.", (uint8_t *)&v8, 2u);
    }
  }
}

uint64_t re::DataArray<re::Connection>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  BOOL v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (v3 = *(_DWORD *)(a1 + 44)) : (v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((v4 = *(_QWORD *)(a1 + 32),
          (v5 = *(_DWORD *)(*(_QWORD *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (v6 = 0),
         v6)))
  {
    return *(_QWORD *)(v4 + 16 * WORD1(a2)) + 136 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

void re::Transport::connectionStateEvent(uint64_t a1, unint64_t a2, int *a3)
{
  uint64_t v6;
  re *v7;
  int v8;
  int v9;
  re *v10;
  unint64_t v11;
  id v12;
  uint64_t v13;
  void *v14;
  re *v15;
  int v16;
  uint64_t v17;
  id v18;
  int v19;
  NSObject *v20;
  int v21;
  const char *v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  re *v27;
  uint64_t v28;
  uint64_t (**v29)();
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t (***v33)();
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v6 = a1 + 120;
  v7 = (re *)re::DataArray<re::Connection>::get(a1 + 120, a2);
  v8 = *(_DWORD *)v7;
  if (*(_DWORD *)v7 != 2)
  {
    if (v8 != 1)
    {
      if (v8)
        return;
      switch(*a3)
      {
        case 0:
          re::Transport::connectionSetState(a1, a2, 1);
          (***(void (****)(_QWORD, unint64_t))(a1 + 608))(*(_QWORD *)(a1 + 608), a2);
          return;
        case 1:
          re::Transport::connectionSetState(a1, a2, 2);
          return;
        case 2:
          goto LABEL_22;
        case 3:
          goto LABEL_21;
        default:
          v20 = *re::networkLogObjects(v7);
          if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            return;
          v25 = *a3;
          LODWORD(v29) = 67109120;
          HIDWORD(v29) = v25;
          v22 = "Unexpected event: %d in 'Pending' state.";
          break;
      }
LABEL_33:
      _os_log_impl(&dword_21C69B000, v20, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&v29, 8u);
      return;
    }
    v15 = (re *)re::DataArray<re::Connection>::get(v6, a2);
    v16 = *a3;
    if (*a3 == 3)
    {
      v15 = (re *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 608) + 16))(*(_QWORD *)(a1 + 608), a2, *((unsigned __int8 *)a3 + 40));
    }
    else if (v16 != 2)
    {
      if (v16 != 1)
      {
        v20 = *re::networkLogObjects(v15);
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          return;
        v24 = *a3;
        LODWORD(v29) = 67109120;
        HIDWORD(v29) = v24;
        v22 = "Unexpected event: %d in 'Active' state.";
        goto LABEL_33;
      }
      v17 = *((_QWORD *)v15 + 5);
      if (v17)
      {
        v18 = (id)(v17 + 8);
        v19 = a3[11];
        v15 = (re *)(id)(v17 + 8);
      }
      else
      {
        v19 = a3[11];
      }
      v32 = re::globalAllocators(v15)[2];
      v26 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v32 + 32))(v32, 32, 0);
      *(_QWORD *)v26 = &off_24E072CE0;
      *(_QWORD *)(v26 + 8) = a1;
      *(_QWORD *)(v26 + 16) = v17;
      *(_BYTE *)(v26 + 24) = v19 != 0;
      v33 = (uint64_t (***)())v26;
      (*(void (**)(_QWORD, uint64_t (***)()))(**(_QWORD **)(a1 + 328) + 16))(*(_QWORD *)(a1 + 328), &v29);
      if (v33)
      {
        ((void (*)(uint64_t (***)()))**v33)(v33);
        if (v33 != &v29)
          (*(void (**)(uint64_t))(*(_QWORD *)v32 + 40))(v32);
      }
      re::Transport::connectionSetState(a1, a2, 2);
      v28 = re::globalAllocators(v27)[2];
      v29 = &off_24E072D38;
      v30 = a1;
      v31 = a2;
      v32 = v28;
      v33 = &v29;
      (*(void (**)(_QWORD, uint64_t (***)()))(**(_QWORD **)(a1 + 320) + 16))(*(_QWORD *)(a1 + 320), &v29);
      if (v33)
      {
        ((void (*)(uint64_t (***)()))**v33)(v33);
        if (v33 != &v29)
          (*(void (**)(uint64_t))(*(_QWORD *)v32 + 40))(v32);
      }
      if (v17)
      {
        v14 = (void *)(v17 + 8);
        goto LABEL_44;
      }
      return;
    }
    v23 = re::globalAllocators(v15)[2];
    v29 = &off_24E072D90;
    v30 = a1;
    v31 = a2;
    v32 = v23;
    v33 = &v29;
    (*(void (**)(_QWORD, uint64_t (***)()))(**(_QWORD **)(a1 + 320) + 16))(*(_QWORD *)(a1 + 320), &v29);
    if (v33)
    {
      ((void (*)(uint64_t (***)()))**v33)(v33);
      if (v33 != &v29)
        (*(void (**)(uint64_t))(*(_QWORD *)v32 + 40))(v32);
    }
    return;
  }
  v9 = *a3;
  if (*a3 == 3)
  {
LABEL_21:
    (*(void (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 608) + 16))(*(_QWORD *)(a1 + 608), a2, *((unsigned __int8 *)a3 + 40));
    goto LABEL_22;
  }
  if (v9 == 2)
  {
LABEL_22:
    re::Transport::destroyConnection((re::Transport *)a1, a2);
    return;
  }
  if (v9)
  {
    v20 = *re::networkLogObjects(v7);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      return;
    v21 = *a3;
    LODWORD(v29) = 67109120;
    HIDWORD(v29) = v21;
    v22 = "Unexpected event: %d in 'Closing' state.";
    goto LABEL_33;
  }
  v10 = (re *)re::DataArray<re::Connection>::get(v6, a2);
  v11 = *((_QWORD *)v10 + 5);
  if (v11)
  {
    v12 = (id)(v11 + 8);
    v10 = (re *)(id)(v11 + 8);
  }
  v13 = re::globalAllocators(v10)[2];
  v29 = &off_24E072DE8;
  v30 = a1;
  v31 = v11;
  v32 = v13;
  v33 = &v29;
  (*(void (**)(_QWORD, uint64_t (***)()))(**(_QWORD **)(a1 + 328) + 16))(*(_QWORD *)(a1 + 328), &v29);
  if (v33)
  {
    ((void (*)(uint64_t (***)()))**v33)(v33);
    if (v33 != &v29)
      (*(void (**)(uint64_t))(*(_QWORD *)v32 + 40))(v32);
  }
  if (v11)
  {
    v14 = (void *)(v11 + 8);
LABEL_44:

  }
}

unint64_t re::DataArray<re::Connection>::handle(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    v5 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    while (v4 != 0x10000)
    {
      v6 = a2 - *(v5 - 1);
      if (v6 >= -135)
      {
        v7 = 0xF0F0F0F0F0F0F0F1 * (v6 >> 3);
        if (v7 < *(unsigned int *)(a1 + 44))
          goto LABEL_8;
      }
      ++v4;
      v5 += 2;
      v3 += 0x10000;
      if (v2 == v4)
        goto LABEL_7;
    }
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) blockIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 692, 0x10000);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) element isn't in data array", "!\"Unreachable code\"", "handle", 707);
    _os_crash();
    __break(1u);
LABEL_8:
    if (v7 < 0x10000)
      return v3 & 0xFFFF0000 | ((unint64_t)(*(_DWORD *)(*v5 + 4 * v7) & 0xFFFFFF) << 32) | v7;
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) arrayIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 700, v7);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::Transport::queuePacketForProtocol(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  re *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t **v26;
  unsigned int *v27;
  int v28;
  unsigned int v29;
  unint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  re::Session *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  id v47;
  uint64_t v48;
  unsigned int v49;
  _BYTE buf[24];
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;

  v4 = a4;
  v8 = a4;
  v53 = *MEMORY[0x24BDAC8D0];
  v9 = re::DataArray<re::Connection>::handle(a1 + 120, a3);
  v10 = *(_DWORD *)(a3 + 104) + 1;
  *(_DWORD *)(a3 + 104) = v10;
  v11 = *(_QWORD *)(a2 + 8) + 1;
  *(_QWORD *)buf = &off_24E072668;
  *(_QWORD *)&buf[8] = v11;
  *(_DWORD *)&buf[16] = 4;
  buf[20] = 0;
  v51 = 0;
  v52 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)buf, v10, 0x10u);
  v12 = *(uint64_t **)(a1 + 560);
  if (v12)
  {
    result = (*(uint64_t (**)(uint64_t *, uint64_t, unint64_t, uint64_t, _QWORD, unint64_t))(*v12 + 48))(v12, a1, v9, v8, *(unsigned int *)(a2 + 32), a2);
    if (!result)
      return result;
    a2 = result;
    *(_QWORD *)buf = *(_QWORD *)(result + 8) + 1;
    *(_DWORD *)&buf[8] = 4;
    buf[12] = 0;
    *(_QWORD *)&buf[16] = 0;
    v51 = 0;
    v49 = 0;
    v12 = re::BitReader::readUInt32Bits((uint64_t *)buf, 0x20u, &v49);
  }
  v14 = *(_QWORD *)(a3 + 16);
  if ((v14 & 1) != 0)
    v15 = v14 >> 1;
  else
    v15 = v14 >> 1;
  if (v4 <= 9 && v15)
  {
    v16 = *(_QWORD *)(a1 + 576);
    if (v16)
    {
      v17 = (re *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)v16 + 32))(v16, a2);
      if ((_DWORD)v17)
      {
        if ((_DWORD)v17 == 1)
        {
          v18 = *re::networkLogObjects(v17);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
          {
            if ((*(_QWORD *)(a3 + 16) & 1) != 0)
              v19 = *(_QWORD *)(a3 + 24);
            else
              v19 = a3 + 17;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v19;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v8;
            _os_log_impl(&dword_21C69B000, v18, OS_LOG_TYPE_INFO, "Stats filter triggered event for {destination: %s, channel: %u}", buf, 0x12u);
          }
          goto LABEL_18;
        }
        v20 = *re::networkLogObjects(v17);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          if ((*(_QWORD *)(a3 + 16) & 1) != 0)
            v45 = *(_QWORD *)(a3 + 24);
          else
            v45 = a3 + 17;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v45;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v8;
          v46 = "Stats filter returned error for {destination: %s, channel: %u}";
LABEL_63:
          _os_log_error_impl(&dword_21C69B000, v20, OS_LOG_TYPE_ERROR, v46, buf, 0x12u);
        }
      }
    }
  }
  else
  {
    v20 = *re::networkLogObjects((re *)v12);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      if ((*(_QWORD *)(a3 + 16) & 1) != 0)
        v48 = *(_QWORD *)(a3 + 24);
      else
        v48 = a3 + 17;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v48;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      v46 = "Cannot collect stats for invalid connection {address: %s, channel: %d}";
      goto LABEL_63;
    }
  }
LABEL_18:
  if (*(_BYTE *)(a1 + 584))
  {
    v21 = *(_DWORD *)(a3 + 116);
    v22 = v21 == 0;
    v23 = (v21 >> 4) & 1;
    if (v22)
      v23 = 1;
    if (v23)
      LODWORD(v8) = 0;
    else
      LODWORD(v8) = v4;
  }
  v24 = *(_QWORD *)(a3 + 40);
  v25 = v24 + 40 * v8;
  v26 = (unint64_t **)(v25 + 912);
  v27 = (unsigned int *)(v25 + 936);
  v28 = *(_DWORD *)(a2 + 24);
  do
    v29 = __ldxr(v27);
  while (__stlxr(v29 + v28, v27));
  v30 = (unint64_t *)(v24 + 40 * v8 + 944);
  v31 = *(unsigned int *)(a2 + 28);
  do
    v32 = __ldxr(v30);
  while (__stlxr(v32 + v31, v30));
  v33 = (unint64_t *)(v24 + 40 * v8 + 928);
  do
    v34 = __ldxr(v33);
  while (__stlxr(v34 + 1, v33));
  atomic_store(a2, *v26);
  *v26 = (unint64_t *)a2;
  ++*(_DWORD *)(*(_QWORD *)(a3 + 40) + 1712);
  if (!*(_BYTE *)(a3 + 120))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 184));
    v35 = *(_QWORD *)(a1 + 224);
    v36 = *(_QWORD *)(a1 + 208);
    if (v36)
    {
      v37 = 8 * v36;
      v38 = *(_QWORD **)(a1 + 224);
      while (*v38 != *(_QWORD *)(a3 + 40))
      {
        ++v38;
        v37 -= 8;
        if (!v37)
        {
          v38 = (_QWORD *)(v35 + 8 * v36);
          break;
        }
      }
    }
    else
    {
      v38 = *(_QWORD **)(a1 + 224);
    }
    if (v36 == ((uint64_t)v38 - v35) >> 3)
      re::DynamicArray<re::SharedPtr<re::ProtocolHandle>>::add((_anonymous_namespace_ *)(a1 + 192), (uint64_t *)(a3 + 40));
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 184));
  }
  result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
  if ((_DWORD)result)
  {
    v39 = *(re::Session **)(a1 + 600);
    if (v39)
    {
      re::Session::peerID(v39);
      v40 = *(_QWORD *)(a1 + 600);
      v41 = *(_QWORD *)(v40 + 2296);
      if (v41)
      {
        v42 = *(uint64_t **)(v40 + 2312);
        v43 = 8 * v41;
        while (1)
        {
          v44 = *v42;
          if (*(_QWORD *)(*v42 + 32) == v9)
            break;
          ++v42;
          v43 -= 8;
          if (!v43)
            goto LABEL_55;
        }
        v47 = (id)(v44 + 8);

      }
    }
LABEL_55:
    result = re::internal::enableSignposts(0, 0);
    if ((_DWORD)result)
    {
      result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
      if ((_DWORD)result)
        return kdebug_trace();
    }
  }
  return result;
}

void re::Transport::cleanupPendingQueues(re::PacketPool **this, unint64_t **a2)
{
  uint64_t i;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t *v7;
  unint64_t *v8;
  unint64_t *v9;
  unint64_t *v10;
  NSObject *v11;
  uint8_t v12[16];

  if (a2)
  {
    for (i = 0; i != 10; ++i)
    {
      v5 = re::PacketQueue::dequeue(&a2[5 * i + 4]);
      if (v5)
      {
        v6 = v5;
        do
        {
          re::PacketPool::free(this[48], (re::Packet *)v6);
          v6 = re::PacketQueue::dequeue(&a2[5 * i + 4]);
        }
        while (v6);
      }
      v7 = re::PacketQueue::dequeue(&a2[5 * i + 114]);
      if (v7)
      {
        v8 = v7;
        do
        {
          re::PacketPool::free(this[48], (re::Packet *)v8);
          v8 = re::PacketQueue::dequeue(&a2[5 * i + 114]);
        }
        while (v8);
      }
      v9 = re::PacketQueue::dequeue(&a2[5 * i + 164]);
      if (v9)
      {
        v10 = v9;
        do
        {
          re::PacketPool::free(this[48], (re::Packet *)v10);
          v10 = re::PacketQueue::dequeue(&a2[5 * i + 164]);
        }
        while (v10);
      }
    }
  }
  else
  {
    v11 = *re::networkLogObjects((re *)this);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      _os_log_error_impl(&dword_21C69B000, v11, OS_LOG_TYPE_ERROR, "Cannot cleanup pending queues for invalid handle: nil", v12, 2u);
    }
  }
}

uint64_t re::Transport::writePacketHeader(uint64_t a1, unsigned __int8 *a2, char a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  _QWORD v8[2];
  int v9;
  char v10;
  uint64_t v11;
  uint64_t v12;

  v5 = *(_QWORD *)(a1 + 8);
  *(_BYTE *)(v5 + 2) = 0;
  *(_WORD *)v5 = 0;
  v6 = *(_QWORD *)(a1 + 8);
  v8[0] = &off_24E072668;
  v8[1] = v6;
  v9 = 3;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)v8, *a2, 1u);
  result = re::BitWriter::writeUInt32Bits((uint64_t)v8, a2[1], 1u);
  if ((a3 & 8) != 0)
  {
    re::BitWriter::writeUInt32Bits((uint64_t)v8, a2[2], 1u);
    re::BitWriter::writeUInt32Bits((uint64_t)v8, 0, 1u);
    re::BitWriter::writeUInt32Bits((uint64_t)v8, a2[3] + 1, 4u);
    return re::BitWriter::writeUInt32Bits((uint64_t)v8, *((unsigned __int16 *)a2 + 2), 0x10u);
  }
  return result;
}

uint64_t *re::Transport::readPacketHeaderFromBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *result;
  unsigned int v6;
  uint64_t v7;
  int v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v7 = a2;
  v8 = 3;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  *(_BYTE *)a4 = v12 != 0;
  v12 = 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  *(_BYTE *)(a4 + 1) = v12 != 0;
  v12 = 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  *(_BYTE *)(a4 + 2) = v12 != 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  v6 = 0;
  re::BitReader::readUInt32Bits(&v7, 4u, &v6);
  if (v6)
    *(_BYTE *)(a4 + 3) = v6 - 1;
  v12 = 0;
  result = re::BitReader::readUInt32Bits(&v7, 0x10u, &v12);
  *(_WORD *)(a4 + 4) = v12;
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<re::ProtocolHandle>>::add(_anonymous_namespace_ *result, uint64_t *a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v3 = result;
  v5 = *((_QWORD *)result + 1);
  v4 = *((_QWORD *)result + 2);
  if (v4 >= v5)
  {
    v6 = v4 + 1;
    if (v5 < v4 + 1)
    {
      if (*(_QWORD *)result)
      {
        v7 = 2 * v5;
        if (!v5)
          v7 = 8;
        if (v7 <= v6)
          v8 = v6;
        else
          v8 = v7;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(result, v8);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    v4 = *((_QWORD *)v3 + 2);
  }
  v9 = *a2;
  *(_QWORD *)(*((_QWORD *)v3 + 4) + 8 * v4) = *a2;
  if (v9)
  {
    result = (_anonymous_namespace_ *)(id)(v9 + 8);
    v4 = *((_QWORD *)v3 + 2);
  }
  *((_QWORD *)v3 + 2) = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::Transport::send(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, int a5, int a6, char a7)
{
  unint64_t v7;
  NSObject *v9;
  uint64_t result;
  NSObject *v11;
  re *v16;
  uint64_t v17;
  std::chrono::steady_clock::time_point v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  unint64_t v24;
  NSObject *v25;
  unint64_t v26;
  NSObject *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  compression_algorithm v32;
  char *v33;
  uint64_t v34;
  size_t v35;
  size_t v36;
  size_t v37;
  size_t v38;
  int v39;
  _DWORD *v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  int v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t **v63;
  unsigned int *v64;
  unsigned int v65;
  unint64_t *v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t **v73;
  unsigned int *v74;
  int v75;
  unsigned int v76;
  unint64_t *v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t *v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  unsigned int v85;
  unsigned int v86;
  uint64_t v87;
  unsigned int v88;
  char v89;
  char v90;
  uint64_t v92;
  _BYTE buf[22];
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;

  v7 = a3;
  v96 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a3 + 24) >> 27)
  {
    v9 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v23 = *(_DWORD *)(v7 + 24);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v23;
      *(_WORD *)&buf[8] = 2048;
      *(_QWORD *)&buf[10] = 0x8000000;
      _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "Outbound message length (%u) exceeds kMaxSupportedMessageSize (%zu), message will be discarded.", buf, 0x12u);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 4;
  }
  if (a4 >= 0xA)
  {
    v11 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v11, OS_LOG_TYPE_ERROR, "Attempt to send data to an invalid channel", buf, 2u);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 1;
  }
  v16 = (re *)re::DataArray<re::Connection>::tryGet(a1 + 120, a2);
  if (v16)
  {
    v17 = (uint64_t)v16;
    if (*(_DWORD *)v16 == 1)
    {
      if (*((_BYTE *)v16 + 120))
      {
        v18.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        if (v18.__d_.__rep_ >= *(_QWORD *)(v17 + 128))
        {
          v19 = *re::networkLogObjects((re *)v18.__d_.__rep_);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            if ((*(_BYTE *)(v17 + 16) & 1) != 0)
              v20 = *(_QWORD *)(v17 + 24);
            else
              v20 = v17 + 17;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v20;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = a4;
            _os_log_impl(&dword_21C69B000, v19, OS_LOG_TYPE_DEFAULT, "Sending data on paused connection '%s', channel %d", buf, 0x12u);
          }
          v18.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
          *(_QWORD *)(v17 + 128) = v18.__d_.__rep_ + 2000000000;
        }
        v24 = atomic_load((unint64_t *)(*(_QWORD *)(v17 + 40) + 944));
        if (v24 >= 0x20000001)
        {
          v25 = *re::networkLogObjects((re *)v18.__d_.__rep_);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            if ((*(_BYTE *)(v17 + 16) & 1) != 0)
              v83 = *(_QWORD *)(v17 + 24);
            else
              v83 = v17 + 17;
            v84 = atomic_load((unint64_t *)(*(_QWORD *)(v17 + 40) + 944));
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v83;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v84;
            _os_log_error_impl(&dword_21C69B000, v25, OS_LOG_TYPE_ERROR, "Send queue on connection '%s' has overflowed (%zu bytes), disconnecting", buf, 0x16u);
          }
          (*(void (**)(_QWORD, unint64_t, uint64_t))(**(_QWORD **)(a1 + 608) + 16))(*(_QWORD *)(a1 + 608), a2, 4);
          re::Transport::disconnect((re::Transport *)a1, a2, 1);
        }
        v26 = atomic_load((unint64_t *)(*(_QWORD *)(v17 + 40) + 944));
        if (v26 >= 0x8000001)
        {
          v27 = *re::networkLogObjects((re *)v18.__d_.__rep_);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            if ((*(_BYTE *)(v17 + 16) & 1) != 0)
              v28 = *(_QWORD *)(v17 + 24);
            else
              v28 = v17 + 17;
            v29 = atomic_load((unint64_t *)(*(_QWORD *)(v17 + 40) + 944));
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v28;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v29;
            _os_log_impl(&dword_21C69B000, v27, OS_LOG_TYPE_DEFAULT, "Send queue on connection '%s' is very large (%zu bytes)", buf, 0x16u);
          }
          (*(void (**)(_QWORD, unint64_t, uint64_t))(**(_QWORD **)(a1 + 608) + 16))(*(_QWORD *)(a1 + 608), a2, 3);
        }
      }
      if ((*(_BYTE *)(v17 + 16) & 1) != 0)
        v30 = *(_QWORD *)(v17 + 24);
      else
        v30 = v17 + 17;
      v31 = *(unsigned __int8 *)(a1 + 392);
      if (v31 != 4 && a6)
      {
        v33 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 384), (*(_DWORD *)(v7 + 28) + 3));
        re::Packet::offsetBy((uint64_t)v33, 3);
        v34 = *((_QWORD *)v33 + 1);
        *(_BYTE *)(v34 + 2) = 0;
        *(_WORD *)v34 = 0;
        v35 = compression_encode_scratch_buffer_size(v32);
        if (*(_QWORD *)(a1 + 408) < v35)
          re::DynamicArray<unsigned char>::resize(a1 + 400, v35);
        v36 = *(unsigned int *)(v7 + 24);
        if (v36 <= 4)
          v37 = 0;
        else
          v37 = v36 - 4;
        v38 = compression_encode_buffer((uint8_t *)(*((_QWORD *)v33 + 2) + 4), v37, *(const uint8_t **)(v7 + 16), v36, *(void **)(a1 + 432), v32);
        if (v38)
        {
          v39 = v38;
          v41 = *((_QWORD *)v33 + 1);
          v40 = (_DWORD *)*((_QWORD *)v33 + 2);
          *((_DWORD *)v33 + 7) += (_DWORD)v40 - v41;
          *v40 = *(_DWORD *)(v7 + 24);
          *((_QWORD *)v33 + 2) = v41;
          v90 = 1;
          *(_WORD *)buf = 1;
          buf[2] = a5 == 0;
          buf[3] = a4;
          *(_WORD *)&buf[4] = 0;
          re::Transport::writePacketHeader((uint64_t)v33, buf, a7);
          *((_DWORD *)v33 + 6) = v39 + 7;
          re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
          v7 = (unint64_t)v33;
          goto LABEL_48;
        }
        re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v33);
      }
      *(_DWORD *)(v7 + 28) += 3;
      *(_QWORD *)(v7 + 16) = *(_QWORD *)(v7 + 8);
      *(_WORD *)buf = 0;
      buf[2] = a5 == 0;
      buf[3] = a4;
      *(_WORD *)&buf[4] = 0;
      re::Transport::writePacketHeader(v7, buf, a7);
      v90 = 0;
      *(_DWORD *)(v7 + 24) += 3;
LABEL_48:
      *(_DWORD *)(v7 + 32) = a5;
      if (*(_BYTE *)(a1 + 585))
      {
        v88 = (unsigned __int16)re::Transport::generateNextPacketSeqNumber(void)::packetSeqNumber;
        v89 = a7;
        ++re::Transport::generateNextPacketSeqNumber(void)::packetSeqNumber;
        v42 = *(_DWORD *)(v7 + 24);
        v43 = 2;
        if (v42 >= 0x80)
        {
          v44 = *(unsigned int *)(v7 + 24);
          do
          {
            v45 = v44 >> 14;
            v44 >>= 7;
            v43 += 2;
          }
          while (v45);
        }
        if (v42)
        {
          v46 = 0;
          v47 = 0;
          v86 = *(_DWORD *)(a1 + 512) - v43 - 13;
          v85 = (v42 + v86 - 1) / v86;
          v87 = v17;
          do
          {
            v48 = *(unsigned int *)(v7 + 24);
            v49 = 1;
            if (v48 >= 0x80)
            {
              do
              {
                ++v49;
                v50 = v48 >> 14;
                v48 >>= 7;
              }
              while (v50);
            }
            v51 = 1;
            if (v46 >= 0x80)
            {
              v52 = v46;
              do
              {
                ++v51;
                v53 = v52 >> 14;
                v52 >>= 7;
              }
              while (v53);
            }
            if (v42 >= v86)
              v54 = v86;
            else
              v54 = v42;
            v55 = v54 + v49 + v51;
            v56 = v55 + 10;
            v57 = v55 + 13;
            v58 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 384), (v55 + 13));
            re::Packet::offsetBy((uint64_t)v58, 3);
            v59 = *((_QWORD *)v58 + 1);
            *(_BYTE *)(v59 + 2) = 0;
            *(_WORD *)v59 = 0;
            v60 = *((_QWORD *)v58 + 2);
            *(_QWORD *)buf = &off_24E072668;
            *(_QWORD *)&buf[8] = v60;
            *(_DWORD *)&buf[16] = v56;
            buf[20] = 0;
            v94 = 0;
            v95 = 0;
            re::BitWriter::writeUInt32Bits((uint64_t)buf, v88, 0x10u);
            re::BitWriter::writeUInt32Bits((uint64_t)buf, v47, 0x20u);
            re::BitWriter::writeUInt32Bits((uint64_t)buf, v85, 0x20u);
            v92 = 0;
            re::BiasedVLQ::write((re::BiasedVLQ *)&v92, (re::BitWriter *)buf, *(unsigned int *)(v7 + 24));
            v92 = 0;
            re::BiasedVLQ::write((re::BiasedVLQ *)&v92, (re::BitWriter *)buf, v46);
            re::BitWriter::writeData((re::BitWriter *)buf, (const void *)(*(_QWORD *)(v7 + 8) + v46), v54);
            *((_DWORD *)v58 + 7) += 3;
            *((_QWORD *)v58 + 2) = *((_QWORD *)v58 + 1);
            *((_DWORD *)v58 + 8) = *(_DWORD *)(v7 + 32);
            LOBYTE(v92) = v90;
            BYTE1(v92) = 1;
            BYTE2(v92) = *(_DWORD *)(v7 + 32) == 0;
            BYTE3(v92) = a4;
            WORD2(v92) = 0;
            re::Transport::writePacketHeader((uint64_t)v58, (unsigned __int8 *)&v92, v89);
            *((_DWORD *)v58 + 6) = v57;
            if (*(_BYTE *)(a1 + 584))
            {
              v61 = *(_QWORD *)(v87 + 40);
              v62 = v61 + 40 * a4;
              v63 = (unint64_t **)(v62 + 32);
              v64 = (unsigned int *)(v62 + 56);
              do
                v65 = __ldxr(v64);
              while (__stlxr(v65 + v57, v64));
              v66 = (unint64_t *)(v61 + 40 * a4 + 64);
              v67 = *((unsigned int *)v58 + 7);
              do
                v68 = __ldxr(v66);
              while (__stlxr(v68 + v67, v66));
              v69 = (unint64_t *)(v61 + 40 * a4 + 48);
              do
                v70 = __ldxr(v69);
              while (__stlxr(v70 + 1, v69));
              atomic_store((unint64_t)v58, *v63);
              *v63 = (unint64_t *)v58;
              ++*(_QWORD *)(v87 + 96);
            }
            else
            {
              re::Transport::queuePacketForProtocol(a1, (unint64_t)v58, v87, a4);
            }
            v46 += v54;
            ++v47;
            v42 -= v54;
          }
          while (v42);
        }
        re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
      }
      else
      {
        if (*(_BYTE *)(a1 + 584))
        {
          v71 = *(_QWORD *)(v17 + 40);
          v72 = v71 + 40 * a4;
          v73 = (unint64_t **)(v72 + 32);
          v74 = (unsigned int *)(v72 + 56);
          v75 = *(_DWORD *)(v7 + 24);
          do
            v76 = __ldxr(v74);
          while (__stlxr(v76 + v75, v74));
          v77 = (unint64_t *)(v71 + 40 * a4 + 64);
          v78 = *(unsigned int *)(v7 + 28);
          do
            v79 = __ldxr(v77);
          while (__stlxr(v79 + v78, v77));
          v80 = (unint64_t *)(v71 + 40 * a4 + 48);
          do
            v81 = __ldxr(v80);
          while (__stlxr(v81 + 1, v80));
          result = 0;
          atomic_store(v7, *v73);
          *v73 = (unint64_t *)v7;
          ++*(_QWORD *)(v17 + 96);
          return result;
        }
        re::Transport::queuePacketForProtocol(a1, v7, v17, a4);
      }
      return 0;
    }
    v22 = *re::networkLogObjects(v16);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      if ((*(_BYTE *)(v17 + 16) & 1) != 0)
        v82 = *(_QWORD *)(v17 + 24);
      else
        v82 = v17 + 17;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v82;
      _os_log_error_impl(&dword_21C69B000, v22, OS_LOG_TYPE_ERROR, "Attempt to send data to connection '%s' that is disconnected", buf, 0xCu);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 3;
  }
  else
  {
    v21 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v21, OS_LOG_TYPE_ERROR, "Attempt to send data to connection that does not exist", buf, 2u);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 2;
  }
}

double `anonymous namespace'::logDebugConnectionStatsForHandle(uint64_t a1, uint64_t a2, int a3)
{
  std::chrono::steady_clock::time_point v6;
  double result;
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  re *v13;
  NSObject *v14;
  int v15;
  const char *v16;
  int v17;
  int v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  const char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v6.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
  v8 = v6.__d_.__rep_ - *(_QWORD *)(a1 + 1720);
  if (v8 >= 0x1389)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1760));
    v9 = *(_DWORD *)(a1 + 1744);
    v10 = *(_DWORD *)(a1 + 1748);
    v11 = *(_DWORD *)(a1 + 1752);
    v12 = *(_DWORD *)(a1 + 1756);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1760));
    v14 = *re::networkLogObjects(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_DWORD *)(a1 + 1712);
      v16 = "onReceive";
      v17 = *(_DWORD *)(a1 + 1716);
      if (a3)
        v16 = "onSend";
      v18 = 136317186;
      v19 = a2;
      v20 = 1024;
      v21 = v15;
      v22 = 1024;
      v23 = v17;
      v24 = 1024;
      v25 = v12;
      v26 = 1024;
      v27 = v10;
      v28 = 1024;
      v29 = v11;
      v30 = 1024;
      v31 = v9;
      v32 = 2048;
      v33 = v8;
      v34 = 2080;
      v35 = v16;
      _os_log_impl(&dword_21C69B000, v14, OS_LOG_TYPE_DEFAULT, "Connection Stats: address=%s, outbound=%d, inbound=%d, ProtocolConnectionStats: send=%u(%u bytes), recv=%u(%u bytes) <period=%llu ms, %s>", (uint8_t *)&v18, 0x44u);
    }
    result = 0.0;
    *(_QWORD *)(a1 + 1712) = 0;
    *(std::chrono::steady_clock::time_point *)(a1 + 1720) = v6;
  }
  return result;
}

BOOL re::Transport::receive(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t **a4)
{
  re *v6;
  re *v7;
  unint64_t *v8;
  _BOOL8 result;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  NSObject *v14;
  char *v15;
  uint8_t buf[4];
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a3 >= 0xA)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid channel", "channel < kChannelIdMaxChannels", "receive", 1058);
    _os_crash();
    __break(1u);
  }
  v6 = (re *)re::DataArray<re::Connection>::tryGet(a1 + 120, a2);
  if (!v6)
  {
    v10 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_WORD *)buf = 0;
    v11 = "Attempt to receive data from connection that does not exist";
    v12 = v10;
    v13 = 2;
LABEL_13:
    _os_log_error_impl(&dword_21C69B000, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
    return 0;
  }
  v7 = v6;
  if (*(_DWORD *)v6 == 1)
  {
    v8 = re::PacketQueue::dequeue((unint64_t **)(*((_QWORD *)v6 + 5) + 40 * a3 + 1312));
    *a4 = v8;
    return v8 != 0;
  }
  v14 = *re::networkLogObjects(v6);
  result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  if (result)
  {
    if ((*((_BYTE *)v7 + 16) & 1) != 0)
      v15 = (char *)*((_QWORD *)v7 + 3);
    else
      v15 = (char *)v7 + 17;
    *(_DWORD *)buf = 136315138;
    v17 = v15;
    v11 = "Attempt to receive data from connection '%s' that is disconnected";
    v12 = v14;
    v13 = 12;
    goto LABEL_13;
  }
  return result;
}

re::DynamicString *re::Transport::connectionAddress@<X0>(re::Transport *this@<X0>, uint64_t a2@<X1>, re::DynamicString *a3@<X8>)
{
  uint64_t v4;

  v4 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (v4)
    return re::DynamicString::DynamicString(a3, (const re::DynamicString *)(v4 + 8));
  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  *((_QWORD *)a3 + 3) = 0;
  return (re::DynamicString *)re::DynamicString::setCapacity(a3, 0);
}

void re::Transport::connectionStats(re::Transport *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  char v6;

  v4 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (v4 && (v5 = *(_QWORD *)(v4 + 40)) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 1760));
    *(_OWORD *)(a3 + 4) = *(_OWORD *)(v5 + 1736);
    *(_QWORD *)(a3 + 20) = *(_QWORD *)(v5 + 1752);
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 1760));
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  *(_BYTE *)a3 = v6;
}

void re::Transport::hostStats(re::Transport *this@<X0>, uint64_t a2@<X8>)
{
  os_unfair_lock_s *v4;
  int v5;

  v4 = (os_unfair_lock_s *)((char *)this + 368);
  os_unfair_lock_lock((os_unfair_lock_t)this + 92);
  v5 = *((unsigned __int8 *)this + 340);
  *(_BYTE *)a2 = v5;
  if (v5)
  {
    *(_QWORD *)(a2 + 20) = *((_QWORD *)this + 45);
    *(_OWORD *)(a2 + 4) = *(_OWORD *)((char *)this + 344);
  }
  os_unfair_lock_unlock(v4);
}

void re::Transport::connectionSetState(uint64_t a1, int a2, int a3)
{
  re *v5;
  NSObject *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  char *v14;
  __int16 v15;
  char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v5 = (re *)re::DataArray<re::Connection>::get(a1 + 120, a2);
  v6 = *re::networkLogObjects(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((*(_BYTE *)(a1 + 488) & 1) != 0)
      v7 = *(_QWORD *)(a1 + 496);
    else
      v7 = a1 + 489;
    v8 = (char *)*((_QWORD *)v5 + 3);
    v9 = s_debugStateNames[*(int *)v5];
    v10 = s_debugStateNames[a3];
    if ((*((_QWORD *)v5 + 2) & 1) == 0)
      v8 = (char *)v5 + 17;
    v11 = 136315906;
    v12 = v7;
    v13 = 2080;
    v14 = v8;
    v15 = 2080;
    v16 = v9;
    v17 = 2080;
    v18 = v10;
    _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "Connection(%s->%s) state changed %s->%s", (uint8_t *)&v11, 0x2Au);
  }
  *(_DWORD *)v5 = a3;
}

uint64_t re::DataArray<re::Connection>::get(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(a2)) + 136 * (unsigned __int16)a2;
}

void re::Transport::destroyConnection(re::Transport *this, unint64_t a2)
{
  char *v4;
  char *v5;
  NSObject *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  size_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  int v35;
  _BYTE v36[24];
  uint64_t v37;
  _QWORD v38[4];

  v38[3] = *MEMORY[0x24BDAC8D0];
  v4 = (char *)this + 120;
  v5 = (char *)re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  v6 = *re::networkLogObjects((re *)v5);
  if (v5)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_BYTE *)this + 488) & 1) != 0)
        v7 = (char *)*((_QWORD *)this + 62);
      else
        v7 = (char *)this + 489;
      if ((v5[16] & 1) != 0)
        v8 = (char *)*((_QWORD *)v5 + 3);
      else
        v8 = v5 + 17;
      v9 = s_debugStateNames[*(int *)v5];
      v10 = *((_QWORD *)v5 + 5);
      *(_DWORD *)v36 = 136315906;
      *(_QWORD *)&v36[4] = v7;
      *(_WORD *)&v36[12] = 2080;
      *(_QWORD *)&v36[14] = v8;
      *(_WORD *)&v36[22] = 2080;
      v37 = (uint64_t)v9;
      LOWORD(v38[0]) = 2048;
      *(_QWORD *)((char *)v38 + 2) = v10;
      _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "Destroy connection (%s->%s) (%s) bound to protocol handle %p", v36, 0x2Au);
    }
    v11 = *((_QWORD *)this + 70);
    if (v11)
      (*(void (**)(uint64_t, re::Transport *, unint64_t))(*(_QWORD *)v11 + 40))(v11, this, a2);
    v12 = *((_QWORD *)v5 + 5);
    if (v12)
    {
      v13 = (id)(v12 + 8);
      os_unfair_lock_lock((os_unfair_lock_t)(v12 + 1764));
      *(_QWORD *)(v12 + 24) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 1764));
      v14 = re::globalAllocators((re *)(id)(v12 + 8))[2];
      *(_QWORD *)v36 = &off_24E0730A8;
      *(_QWORD *)&v36[8] = this;
      *(_QWORD *)&v36[16] = v12;
      v37 = v14;
      v38[0] = v36;
      (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 41) + 16))(*((_QWORD *)this + 41), v36);
      if (v38[0])
      {
        (**(void (***)(_QWORD))v38[0])(v38[0]);
        if ((_BYTE *)v38[0] != v36)
          (*(void (**)(uint64_t))(*(_QWORD *)v37 + 40))(v37);
      }

    }
    v15 = re::Address::hash((re::Address *)(v5 + 8));
    if (*((_QWORD *)this + 34))
    {
      v16 = v15 % *((unsigned int *)this + 74);
      v17 = *((_QWORD *)this + 35);
      v18 = *(unsigned int *)(v17 + 4 * v16);
      if ((_DWORD)v18 != 0x7FFFFFFF)
      {
        v19 = *((_QWORD *)this + 36);
        if (re::DynamicString::operator==((uint64_t)(v5 + 8), v19 + 56 * v18 + 16))
        {
          *(_DWORD *)(v17 + 4 * v16) = *(_DWORD *)(v19 + 56 * v18 + 8) & 0x7FFFFFFF;
LABEL_26:
          v22 = *((_QWORD *)this + 36);
          v23 = v22 + 56 * v18;
          v26 = *(_DWORD *)(v23 + 8);
          v25 = (int *)(v23 + 8);
          v24 = v26;
          if (v26 < 0)
          {
            *v25 = v24 & 0x7FFFFFFF;
            v27 = v22 + 56 * v18;
            v30 = *(_QWORD *)(v27 + 16);
            v29 = v27 + 16;
            v28 = v30;
            if (v30)
            {
              if ((*(_BYTE *)(v29 + 8) & 1) != 0)
                (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v28 + 40))(v28, *(_QWORD *)(v29 + 16));
              *(_OWORD *)v29 = 0u;
              *(_OWORD *)(v29 + 16) = 0u;
            }
            v22 = *((_QWORD *)this + 36);
            v24 = *(_DWORD *)(v22 + 56 * v18 + 8);
          }
          *(_DWORD *)(v22 + 56 * v18 + 8) = *((_DWORD *)this + 77) | v24 & 0x80000000;
          *((_DWORD *)this + 77) = v18;
          --*((_DWORD *)this + 75);
          ++*((_DWORD *)this + 78);
        }
        else
        {
          while (1)
          {
            v20 = v18;
            v21 = *(_DWORD *)(v19 + 56 * v18 + 8);
            v18 = v21 & 0x7FFFFFFF;
            if ((v21 & 0x7FFFFFFF) == 0x7FFFFFFF)
              break;
            if (re::DynamicString::operator==((uint64_t)(v5 + 8), v19 + 56 * v18 + 16))
            {
              *(_DWORD *)(v19 + 56 * v20 + 8) = *(_DWORD *)(v19 + 56 * v20 + 8) & 0x80000000 | *(_DWORD *)(v19 + 56 * v18 + 8) & 0x7FFFFFFF;
              goto LABEL_26;
            }
          }
        }
      }
    }
    while (*((_DWORD *)v5 + 19))
    {
      v31 = *((unsigned int *)v5 + 20);
      v32 = *((_QWORD *)v5 + 8);
      v33 = 0;
      if ((_DWORD)v31)
      {
        v34 = (int *)(v32 + 8);
        while (1)
        {
          v35 = *v34;
          v34 += 8;
          if (v35 < 0)
            break;
          if (v31 == ++v33)
          {
            LODWORD(v33) = *((_DWORD *)v5 + 20);
            break;
          }
        }
      }
      re::Transport::removeStream(this, a2, *(_QWORD *)(v32 + 32 * v33 + 16));
    }
    re::DataArray<re::Connection>::destroy((uint64_t)v4, a2);
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v36 = 134217984;
    *(_QWORD *)&v36[4] = a2;
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "Trying to destroy invalid connection handle (%llu).", v36, 0xCu);
  }
}

void re::Transport::onConnected(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3, const re::Address *a4)
{
  char *v7;
  char *v8;
  uint64_t v9;
  _QWORD *v10;
  NSObject *v11;
  char *v12;
  __int128 v13;
  char v14;
  re::ProtocolHandle *v15;
  _BYTE v16[24];
  uint64_t v17;
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v7 = (char *)a3 + 8;
    v8 = (char *)a3 + 8;
    *(_QWORD *)&v13 = this;
    re::DynamicString::DynamicString((re::DynamicString *)((char *)&v13 + 8), a4);
    v15 = a3;
    v9 = re::globalAllocators((re *)v7)[2];
    v17 = v9;
    v18 = 0;
    if (v9)
      v10 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v9 + 32))(v9, 56, 0);
    else
      v10 = 0;
    *v10 = off_24E072E40;
    v10[1] = v13;
    re::DynamicString::DynamicString((re::DynamicString *)(v10 + 2), (const re::DynamicString *)((char *)&v13 + 8));
    v10[6] = v15;
    v15 = 0;
    v18 = v10;
    (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 40) + 16))(*((_QWORD *)this + 40), v16);
    if (v18)
    {
      (**(void (***)(_BYTE *))v18)(v18);
      if (v18 != v16)
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
      v18 = 0;
    }
    if (v15)
    {

      v15 = 0;
    }
    if (*((_QWORD *)&v13 + 1))
    {
      if ((v14 & 1) != 0)
        (*(void (**)(void))(**((_QWORD **)&v13 + 1) + 40))();
    }

  }
  else
  {
    v11 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      if ((*((_QWORD *)a4 + 1) & 1) != 0)
        v12 = (char *)*((_QWORD *)a4 + 2);
      else
        v12 = (char *)a4 + 9;
      LODWORD(v13) = 136315138;
      *(_QWORD *)((char *)&v13 + 4) = v12;
      _os_log_error_impl(&dword_21C69B000, v11, OS_LOG_TYPE_ERROR, "onConnected: Invalid handle provided for '%s'!", (uint8_t *)&v13, 0xCu);
    }
  }
}

void `non-virtual thunk to're::Transport::onConnected(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3, const re::Address *a4)
{
  re::Transport::onConnected((re::Transport *)((char *)this - 24), a2, a3, a4);
}

void re::Transport::onDisconnected(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3, const re::Address *a4)
{
  char *v7;
  NSObject *v8;
  char *v9;
  re *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  char *v14;
  char *v15;
  __int128 v16;
  _QWORD v17[4];
  _BYTE v18[24];
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v7 = (char *)a3 + 8;
    v8 = *re::networkLogObjects((re *)(char *)a3 + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      if ((*((_QWORD *)a4 + 1) & 1) != 0)
        v15 = (char *)*((_QWORD *)a4 + 2);
      else
        v15 = (char *)a4 + 9;
      LODWORD(v16) = 136315138;
      *(_QWORD *)((char *)&v16 + 4) = v15;
      _os_log_debug_impl(&dword_21C69B000, v8, OS_LOG_TYPE_DEBUG, "queueTransportCommand '%s' OnDisconnected", (uint8_t *)&v16, 0xCu);
    }
    *(_QWORD *)&v16 = this;
    *((_QWORD *)&v16 + 1) = a3;
    v9 = v7;
    v10 = re::DynamicString::DynamicString((re::DynamicString *)v17, a4);
    v11 = re::globalAllocators(v10)[2];
    v19 = v11;
    v20 = 0;
    if (v11)
      v12 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 56, 0);
    else
      v12 = 0;
    *(_QWORD *)v12 = off_24E072E98;
    *(_OWORD *)(v12 + 8) = v16;
    *((_QWORD *)&v16 + 1) = 0;
    re::DynamicString::DynamicString((re::DynamicString *)(v12 + 24), (const re::DynamicString *)v17);
    v20 = (_BYTE *)v12;
    (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 40) + 16))(*((_QWORD *)this + 40), v18);
    if (v20)
    {
      (**(void (***)(_BYTE *))v20)(v20);
      if (v20 != v18)
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19);
      v20 = 0;
    }
    if (v17[0])
    {
      if ((v17[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v17[0] + 40))();
      memset(v17, 0, sizeof(v17));
    }
    if (*((_QWORD *)&v16 + 1))

  }
  else
  {
    v13 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if ((*((_QWORD *)a4 + 1) & 1) != 0)
        v14 = (char *)*((_QWORD *)a4 + 2);
      else
        v14 = (char *)a4 + 9;
      LODWORD(v16) = 136315138;
      *(_QWORD *)((char *)&v16 + 4) = v14;
      _os_log_error_impl(&dword_21C69B000, v13, OS_LOG_TYPE_ERROR, "onDisconnected: Invalid handle provided for '%s'!", (uint8_t *)&v16, 0xCu);
    }
  }
}

void `non-virtual thunk to're::Transport::onDisconnected(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3, const re::Address *a4)
{
  re::Transport::onDisconnected((re::Transport *)((char *)this - 24), a2, a3, a4);
}

void re::Transport::onError(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  void *v7;
  id v8;
  uint64_t v9;
  _BYTE v10[24];
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v7 = (void *)(a3 + 8);
    v8 = (id)(a3 + 8);
    v11 = re::globalAllocators((re *)v7)[2];
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 32))(v11, 32, 0);
    *(_QWORD *)v9 = &off_24E072EF0;
    *(_QWORD *)(v9 + 8) = a1;
    *(_QWORD *)(v9 + 16) = a3;
    *(_BYTE *)(v9 + 24) = a4;
    v12 = (_BYTE *)v9;
    (*(void (**)(_QWORD, _BYTE *))(**(_QWORD **)(a1 + 320) + 16))(*(_QWORD *)(a1 + 320), v10);
    if (v12)
    {
      (**(void (***)(_BYTE *))v12)(v12);
      if (v12 != v10)
        (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
    }

  }
}

void `non-virtual thunk to're::Transport::onError(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  re::Transport::onError(a1 - 24, a2, a3, a4);
}

void re::Transport::onUnresponsive(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3)
{
  char *v5;
  char *v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[3];
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = (char *)a3 + 8;
    v6 = (char *)a3 + 8;
    v7 = re::globalAllocators((re *)v5)[2];
    v9[0] = &off_24E072F48;
    v9[1] = this;
    v9[2] = a3;
    v10 = v7;
    v11 = v9;
    (*(void (**)(_QWORD, _QWORD *))(**((_QWORD **)this + 40) + 16))(*((_QWORD *)this + 40), v9);
    if (v11)
    {
      (*(void (**)(_QWORD *))*v11)(v11);
      if (v11 != v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
    }

  }
  else
  {
    v8 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9[0]) = 0;
      _os_log_error_impl(&dword_21C69B000, v8, OS_LOG_TYPE_ERROR, "onUnresponsive: Invalid handle!", (uint8_t *)v9, 2u);
    }
  }
}

void `non-virtual thunk to're::Transport::onUnresponsive(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3)
{
  re::Transport::onUnresponsive((re::Transport *)((char *)this - 24), a2, a3);
}

void re::Transport::onResponsive(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3)
{
  char *v5;
  char *v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[3];
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = (char *)a3 + 8;
    v6 = (char *)a3 + 8;
    v7 = re::globalAllocators((re *)v5)[2];
    v9[0] = &off_24E072FA0;
    v9[1] = this;
    v9[2] = a3;
    v10 = v7;
    v11 = v9;
    (*(void (**)(_QWORD, _QWORD *))(**((_QWORD **)this + 40) + 16))(*((_QWORD *)this + 40), v9);
    if (v11)
    {
      (*(void (**)(_QWORD *))*v11)(v11);
      if (v11 != v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
    }

  }
  else
  {
    v8 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9[0]) = 0;
      _os_log_error_impl(&dword_21C69B000, v8, OS_LOG_TYPE_ERROR, "onResponsive: Invalid handle!", (uint8_t *)v9, 2u);
    }
  }
}

void `non-virtual thunk to're::Transport::onResponsive(re::Transport *this, re::ProtocolLayer *a2, re::ProtocolHandle *a3)
{
  re::Transport::onResponsive((re::Transport *)((char *)this - 24), a2, a3);
}

void re::Transport::onReceiveAsync(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, uint64_t a6)
{
  unsigned __int8 v6;
  re *v13;
  NSObject *v14;
  char *v15;
  id v16;
  uint64_t v17;
  NSObject *v18;
  _QWORD v19[6];
  uint8_t buf[4];
  unsigned int v21;
  uint64_t v22;
  uint8_t *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v6 = atomic_load((unsigned __int8 *)(a1 + 336));
  if ((v6 & 1) != 0)
  {
    v13 = (re *)re::DataArray<re::Connection>::tryGet(a1 + 120, *(_QWORD *)(a3 + 24));
    if (v13)
    {
      if (a4 < 0xA)
      {
        v15 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 384), a6);
        *((_DWORD *)v15 + 6) = a6;
        memcpy(*((void **)v15 + 2), a5, a6);
        v16 = (id)(a3 + 8);
        v22 = re::globalAllocators((re *)(id)(a3 + 8))[2];
        v17 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v22 + 32))(v22, 48, 0);
        *(_QWORD *)v17 = &off_24E072FF8;
        *(_QWORD *)(v17 + 8) = a1;
        *(_QWORD *)(v17 + 16) = a2;
        *(_QWORD *)(v17 + 24) = a3;
        *(_BYTE *)(v17 + 32) = a4;
        *(_QWORD *)(v17 + 40) = v15;
        v23 = (uint8_t *)v17;
        (*(void (**)(_QWORD, uint8_t *))(**(_QWORD **)(a1 + 320) + 16))(*(_QWORD *)(a1 + 320), buf);
        if (v23)
        {
          (**(void (***)(uint8_t *))v23)(v23);
          if (v23 != buf)
            (*(void (**)(uint64_t))(*(_QWORD *)v22 + 40))(v22);
        }
        v18 = *(NSObject **)(a1 + 376);
        v19[0] = MEMORY[0x24BDAC760];
        v19[1] = 0x40000000;
        v19[2] = ___ZN2re9Transport14onReceiveAsyncEPNS_13ProtocolLayerEPNS_14ProtocolHandleENS_9ChannelIdEPKvj_block_invoke;
        v19[3] = &__block_descriptor_tmp_6;
        v19[4] = a1;
        v19[5] = v18;
        dispatch_async(v18, v19);

      }
      else
      {
        v14 = *re::networkLogObjects(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          v21 = a4;
          _os_log_error_impl(&dword_21C69B000, v14, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", buf, 8u);
        }
        if (re::internal::enableSignposts(0, 0))
          kdebug_trace();
      }
    }
  }
}

void `non-virtual thunk to're::Transport::onReceiveAsync(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, uint64_t a6)
{
  re::Transport::onReceiveAsync(a1 - 24, a2, a3, a4, a5, a6);
}

uint64_t re::Transport::onReceive(re *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint8_t *a5, unsigned int a6)
{
  NSObject *v8;
  uint64_t result;
  uint64_t v13;
  const char *v14;
  double v15;
  size_t v16;
  uint64_t v17;
  size_t v18;
  _DWORD v19[2];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a4 < 0xA)
  {
    ++*(_DWORD *)(a3 + 1716);
    v13 = re::DataArray<re::Connection>::tryGet((uint64_t)a1 + 120, *(_QWORD *)(a3 + 24));
    if (v13)
    {
      if ((*(_BYTE *)(v13 + 16) & 1) != 0)
        v14 = *(const char **)(v13 + 24);
      else
        v14 = (const char *)(v13 + 17);
    }
    else
    {
      v14 = "N/A";
    }
    v16 = a6;
    v17 = *((_QWORD *)a1 + 70);
    if (v17)
    {
      result = (*(uint64_t (**)(uint64_t, re *, _QWORD, uint64_t, uint8_t *, _QWORD, double))(*(_QWORD *)v17 + 56))(v17, a1, *(_QWORD *)(a3 + 24), a4, a5, a6, v15);
      if (!v18)
        return result;
      a5 = (uint8_t *)result;
      v16 = v18;
    }
    return re::Transport::onReceiveData((uint64_t)a1, a3, a4, a5, v16);
  }
  else
  {
    v8 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v19[0] = 67109120;
      v19[1] = a4;
      _os_log_error_impl(&dword_21C69B000, v8, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", (uint8_t *)v19, 8u);
    }
    result = re::internal::enableSignposts(0, 0);
    if ((_DWORD)result)
      return kdebug_trace();
  }
  return result;
}

uint64_t `non-virtual thunk to're::Transport::onReceive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint8_t *a5, unsigned int a6)
{
  return re::Transport::onReceive((re *)(a1 - 24), a2, a3, a4, a5, a6);
}

uint64_t *re::FixedArray<unsigned char>::operator=(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result != a2)
  {
    v2 = *result;
    v3 = *a2;
    if (*result)
      v4 = v2 == v3;
    else
      v4 = 1;
    if (v4)
    {
      *result = v3;
      *a2 = v2;
      v5 = result[1];
      v6 = result[2];
      v7 = a2[2];
      result[1] = a2[1];
      result[2] = v7;
      a2[1] = v5;
      a2[2] = v6;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      result = (uint64_t *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::Transport::dispatchPacketToStream(re::Transport *this, re::Packet *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  char *WeakRetained;
  char *v11;
  uint64_t v12;
  unsigned int *v13;
  int v14;
  unsigned int v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char v26;
  uint64_t v27;
  uint64_t v28;

  v5 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a3);
  if (!v5)
    return 1;
  if (!*(_DWORD *)(v5 + 76))
    return 2;
  v6 = v5 + 48;
  v7 = *((_QWORD *)a2 + 2);
  v25 = *((_DWORD *)a2 + 6);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v23 = 0xFFFFFFFFLL;
  v24 = v7;
  v22 = 0;
  re::BiasedVLQ::read((re::BiasedVLQ *)&v22, (re::BitReader *)&v24, &v23);
  v22 = v23;
  v8 = (_QWORD *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v6, &v22);
  if (!v8)
    return 3;
  if (*v8 >= *((_QWORD *)this + 6) || v26 != 0)
    return 3;
  WeakRetained = (char *)objc_loadWeakRetained((id *)(*((_QWORD *)this + 8) + 8 * *v8));
  if (!WeakRetained)
    return 3;
  v11 = WeakRetained;

  if (HIDWORD(v27))
    v12 = (v27 + 1);
  else
    v12 = v27;
  re::Packet::offsetBy((uint64_t)a2, v12);
  v13 = (unsigned int *)(v11 + 80);
  v14 = *((_DWORD *)a2 + 6);
  do
    v15 = __ldxr(v13);
  while (__stlxr(v15 + v14, v13));
  v16 = (unint64_t *)(v11 + 88);
  v17 = *((unsigned int *)a2 + 7);
  do
    v18 = __ldxr(v16);
  while (__stlxr(v18 + v17, v16));
  v19 = (unint64_t *)(v11 + 72);
  do
    v20 = __ldxr(v19);
  while (__stlxr(v20 + 1, v19));
  atomic_store((unint64_t)a2, *((unint64_t **)v11 + 7));
  *((_QWORD *)v11 + 7) = a2;
  result = *((_QWORD *)v11 + 12);
  if (result)
  {
    (*(void (**)(uint64_t, _QWORD))(result + 16))(result, *((_QWORD *)v11 + 5));
    return 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::tryGet(uint64_t a1, unsigned __int16 a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a2) ^ ((0xBF58476D1CE4E5B9 * a2) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(unsigned __int16 *)(v5 + 80 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 80 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(unsigned __int16 *)(v5 + 80 * v3 + 12) == a2)
        return v5 + 80 * v3 + 16;
    }
    return 0;
  }
  return v5 + 80 * v3 + 16;
}

uint64_t re::Transport::discardPacketFragments(uint64_t a1, unsigned int a2, unsigned int a3)
{
  _QWORD *v6;
  uint64_t result;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  _QWORD *v17;
  _DWORD *v18;

  v6 = (_QWORD *)(a1 + 48 * a2 + 432);
  result = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::tryGet((uint64_t)v6, a3);
  if (result)
  {
    if (*v6)
    {
      v8 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a3) ^ ((0xBF58476D1CE4E5B9 * a3) >> 27));
      v9 = a1 + 48 * a2;
      v10 = (v8 ^ (v8 >> 31)) % *(unsigned int *)(v9 + 456);
      v11 = *(_QWORD *)(v9 + 440);
      v12 = *(unsigned int *)(v11 + 4 * v10);
      if ((_DWORD)v12 != 0x7FFFFFFF)
      {
        v13 = a1 + 48 * a2;
        v14 = *(_QWORD *)(v13 + 448);
        if (*(unsigned __int16 *)(v14 + 80 * v12 + 12) == a3)
        {
          *(_DWORD *)(v11 + 4 * v10) = *(_DWORD *)(v14 + 80 * v12 + 8) & 0x7FFFFFFF;
LABEL_9:
          v17 = (_QWORD *)(v13 + 448);
          result = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::EntryWithHash::free(*(_QWORD *)(v13 + 448) + 80 * v12);
          v18 = (_DWORD *)(a1 + 48 * a2);
          *(_DWORD *)(*v17 + 80 * v12 + 8) = *(_DWORD *)(*v17 + 80 * v12 + 8) & 0x80000000 | v18[117];
          v18[117] = v12;
          --v18[115];
          ++v18[118];
        }
        else
        {
          while (1)
          {
            v15 = v12;
            v16 = *(_DWORD *)(v14 + 80 * v12 + 8);
            v12 = v16 & 0x7FFFFFFF;
            if ((v16 & 0x7FFFFFFF) == 0x7FFFFFFF)
              break;
            if (*(unsigned __int16 *)(v14 + 80 * v12 + 12) == a3)
            {
              *(_DWORD *)(v14 + 80 * v15 + 8) = *(_DWORD *)(v14 + 80 * v15 + 8) & 0x80000000 | *(_DWORD *)(v14 + 80 * v12 + 8) & 0x7FFFFFFF;
              goto LABEL_9;
            }
          }
        }
      }
    }
  }
  return result;
}

_QWORD *re::Transport::setDisconnectTimeout(re::Transport *this, int a2)
{
  uint64_t v4;
  _QWORD *result;
  _QWORD v6[2];
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = re::globalAllocators(this)[2];
  v6[0] = &off_24E073050;
  v6[1] = this;
  v7 = a2;
  v8 = v4;
  v9 = v6;
  (*(void (**)(_QWORD, _QWORD *))(**((_QWORD **)this + 41) + 16))(*((_QWORD *)this + 41), v6);
  result = v9;
  if (v9)
  {
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *))*v9)(v9);
    if (v9 != v6)
      return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
  }
  return result;
}

void re::Transport::removeStream(re::Transport *this, uint64_t a2, uint64_t a3)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  const char *v28;
  NSObject *v29;
  uint32_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  id *v34;
  id *v35;
  uint64_t v36;
  uint64_t v37[2];
  int v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  unint64_t v43;
  __int16 v44;
  unint64_t v45;
  _OWORD to[5];
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v37[0] = a3;
  v4 = (char *)this + 120;
  v5 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (!v5)
  {
    v27 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      return;
    LOWORD(to[0]) = 0;
    v28 = "Failed to remove unicast stream. Invalid connection handle.";
    v29 = v27;
    v30 = 2;
    goto LABEL_30;
  }
  v6 = v5;
  v7 = v5 + 48;
  v8 = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v5 + 48, v37);
  if (!v8)
  {
    v31 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      return;
    if ((*(_BYTE *)(v6 + 16) & 1) != 0)
      v32 = *(_QWORD *)(v6 + 24);
    else
      v32 = v6 + 17;
    LODWORD(to[0]) = 136315394;
    *(_QWORD *)((char *)to + 4) = v32;
    WORD6(to[0]) = 2048;
    *(_QWORD *)((char *)to + 14) = v37[0];
    v28 = "Connection %s does not have stream %llu.";
    v29 = v31;
    v30 = 22;
LABEL_30:
    _os_log_error_impl(&dword_21C69B000, v29, OS_LOG_TYPE_ERROR, v28, (uint8_t *)to, v30);
    return;
  }
  v10 = (unint64_t)v8;
  v11 = *((_QWORD *)this + 6);
  if (*v8 >= v11)
  {
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) ", "*index < m_streams.size()", "removeStream", 1921);
    _os_crash();
    __break(1u);
LABEL_32:
    v37[1] = 0;
    memset(to, 0, sizeof(to));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v38 = 136315906;
    v39 = "operator[]";
    v40 = 1024;
    v41 = 789;
    v42 = 2048;
    v43 = v10;
    v44 = 2048;
    v45 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v12 = *(_QWORD *)(*((_QWORD *)this + 8) + 8 * v11 - 8);
  if (v12)
    v13 = v12 - 8;
  else
    v13 = 0;
  v14 = re::DataArray<re::Connection>::tryGet((uint64_t)v4, *(_QWORD *)(v13 + 40));
  if (v14)
  {
    v15 = v14;
    v18 = *(_QWORD *)(v14 + 48);
    v16 = v14 + 48;
    v17 = v18;
    v19 = *(_QWORD *)(*((_QWORD *)this + 8) + 8 * *((_QWORD *)this + 6) - 8);
    if (v19)
      v20 = v19 - 8;
    else
      v20 = 0;
    v21 = *(_QWORD *)(v20 + 48);
    *(_QWORD *)&to[0] = v21;
    v22 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v21 ^ (v21 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v21 ^ (v21 >> 30))) >> 27));
    v23 = v22 ^ (v22 >> 31);
    if (v17)
    {
      v24 = v23 % *(unsigned int *)(v15 + 72);
      v25 = *(unsigned int *)(*(_QWORD *)(v15 + 56) + 4 * v24);
      if ((_DWORD)v25 != 0x7FFFFFFF)
      {
        v26 = *(_QWORD *)(v15 + 64);
        if (*(_QWORD *)(v26 + 32 * v25 + 16) == v21)
        {
LABEL_16:
          *(_QWORD *)(v26 + 32 * v25 + 24) = *(_QWORD *)v10;
LABEL_24:
          ++*(_DWORD *)(v15 + 88);
          goto LABEL_25;
        }
        while (1)
        {
          v25 = *(_DWORD *)(v26 + 32 * v25 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v25 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v26 + 32 * v25 + 16) == v21)
            goto LABEL_16;
        }
      }
    }
    else
    {
      LODWORD(v24) = 0;
    }
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<unsigned long &>(v16, v24, v23, to, (_QWORD *)v10);
    goto LABEL_24;
  }
LABEL_25:
  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v7, v37);
  v7 = *((_QWORD *)this + 6);
  v10 = *(_QWORD *)v10;
  if (v7 <= v10)
    goto LABEL_32;
  v33 = *((_QWORD *)this + 8);
  v34 = (id *)(v33 + 8 * v7 - 8);
  v35 = (id *)(v33 + 8 * v10);
  *(_QWORD *)&to[0] = 0;
  objc_moveWeak((id *)to, v34);
  re::ArcWeakPtr<re::TransportStream>::operator=(v34, v35);
  re::ArcWeakPtr<re::TransportStream>::operator=(v35, (id *)to);
  objc_destroyWeak((id *)to);
  v36 = *((_QWORD *)this + 8) + 8 * *((_QWORD *)this + 6);
  objc_destroyWeak((id *)(v36 - 8));
  *(_QWORD *)(v36 - 8) = 0;
  --*((_QWORD *)this + 6);
  ++*((_DWORD *)this + 14);
}

uint64_t *re::DataArray<re::Connection>::destroy(uint64_t a1, unint64_t a2)
{
  int v2;
  unint64_t v4;
  uint64_t *result;
  uint64_t *v6;
  __n128 v7;
  uint64_t v8;

  v2 = a2;
  v4 = a2 >> 16;
  result = (uint64_t *)re::DataArray<re::Connection>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (result)
  {
    v6 = result;
    v7.n128_f64[0] = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(result + 6);
    v8 = v6[5];
    if (v8)
    {

      v6[5] = 0;
    }
    result = (uint64_t *)v6[1];
    if (result)
    {
      if ((v6[2] & 1) != 0)
        result = (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, __n128))(*result + 40))(result, v6[3], v7);
      *(_OWORD *)(v6 + 1) = 0u;
      *(_OWORD *)(v6 + 3) = 0u;
    }
    if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *(_DWORD *)v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
  return result;
}

char *re::Transport::createMultiplexedPacket(re::PacketPool **this, uint64_t a2, int a3)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v10;
  _QWORD v11[2];
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;

  v4 = re::PacketPool::allocate(this[48], (a3 + 19));
  re::Packet::offsetBy((uint64_t)v4, 3);
  v5 = *((_QWORD *)v4 + 1);
  *(_BYTE *)(v5 + 2) = 0;
  *(_WORD *)v5 = 0;
  v6 = *((_QWORD *)v4 + 2);
  v7 = *((_DWORD *)v4 + 7);
  v11[0] = &off_24E072668;
  v11[1] = v6;
  v12 = v7;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v10 = 0;
  re::BiasedVLQ::write((re::BiasedVLQ *)&v10, (re::BitWriter *)v11, a2);
  if (HIDWORD(v14))
    v8 = (v14 + 1);
  else
    v8 = v14;
  re::Packet::offsetBy((uint64_t)v4, v8);
  return v4;
}

uint64_t re::Packet::offsetTo(uint64_t this, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  int v4;

  v2 = *(_DWORD *)(this + 28);
  if (v2 < a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "capacity() >= offset", "offsetTo", 125);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    v3 = *(_QWORD *)(this + 8);
    v4 = *(_DWORD *)(this + 16) - v3 - a2;
    *(_QWORD *)(this + 16) = v3 + a2;
    *(_DWORD *)(this + 24) += v4;
    *(_DWORD *)(this + 28) = v4 + v2;
  }
  return this;
}

BOOL re::Transport::registerStream(re::Transport *this, re::TransportStream *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  re *v9;
  NSObject *v10;
  _BOOL8 result;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  NSObject *v15;
  char *v16;
  _anonymous_namespace_ *inited;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  BOOL v22;
  unint64_t v23;
  unint64_t v24;
  id *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  id v31;
  unint64_t v32;
  uint8_t buf[24];
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v32 = a3;
  v6 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a4);
  if (!v6)
  {
    v15 = *re::networkLogObjects(0);
    result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_WORD *)buf = 0;
    v12 = "Failed to register unicast stream. Invalid connection handle.";
    v13 = v15;
    v14 = 2;
    goto LABEL_7;
  }
  v7 = v6;
  v8 = (_QWORD *)(v6 + 48);
  v9 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v6 + 48, (uint64_t *)&v32);
  if (v9)
  {
    v10 = *re::networkLogObjects(v9);
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v32;
    v12 = "Failed to register unicast stream. Stream %llu already exists.";
    v13 = v10;
    v14 = 12;
LABEL_7:
    _os_log_error_impl(&dword_21C69B000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return 0;
  }
  *(_QWORD *)buf = *((_QWORD *)this + 6);
  if (a2)
    v16 = (char *)a2 + 8;
  else
    v16 = 0;
  inited = (_anonymous_namespace_ *)objc_initWeak(&v31, v16);
  v18 = *((_QWORD *)this + 5);
  v19 = *((_QWORD *)this + 6);
  if (v19 >= v18)
  {
    v20 = v19 + 1;
    if (v18 < v19 + 1)
    {
      if (*((_QWORD *)this + 4))
      {
        v21 = 2 * v18;
        v22 = v18 == 0;
        v23 = 8;
        if (!v22)
          v23 = v21;
        if (v23 <= v20)
          v24 = v20;
        else
          v24 = v23;
        re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity((_QWORD *)this + 4, v24);
      }
      else
      {
        re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity((_QWORD *)this + 4, v20);
        ++*((_DWORD *)this + 14);
      }
    }
    v19 = *((_QWORD *)this + 6);
  }
  v25 = (id *)(*((_QWORD *)this + 8) + 8 * v19);
  *v25 = 0;
  objc_moveWeak(v25, &v31);
  ++*((_QWORD *)this + 6);
  ++*((_DWORD *)this + 14);
  objc_destroyWeak(&v31);
  v26 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) >> 27));
  v27 = v26 ^ (v26 >> 31);
  if (!*v8)
  {
    LODWORD(v28) = 0;
    goto LABEL_29;
  }
  v28 = v27 % *(unsigned int *)(v7 + 72);
  v29 = *(unsigned int *)(*(_QWORD *)(v7 + 56) + 4 * v28);
  if ((_DWORD)v29 == 0x7FFFFFFF)
  {
LABEL_29:
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<unsigned long &>((uint64_t)v8, v28, v27, &v32, buf);
    ++*(_DWORD *)(v7 + 88);
    return 1;
  }
  v30 = *(_QWORD *)(v7 + 64);
  if (*(_QWORD *)(v30 + 32 * v29 + 16) != v32)
  {
    while (1)
    {
      v29 = *(_DWORD *)(v30 + 32 * v29 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v29 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v30 + 32 * v29 + 16) == v32)
        return 1;
    }
    goto LABEL_29;
  }
  return 1;
}

_QWORD *re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072A78;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072A78;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 72) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 72), *(_QWORD *)(a1 + 16), 1);
}

_QWORD *re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E072A78;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072A78;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072AD0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072AD0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(v2 + 72) + 56))(*(_QWORD *)(v2 + 72), *(_QWORD *)(a1 + 16), 1);
  re::Transport::cleanupPendingQueues((re::PacketPool **)v2, *(unint64_t ***)(a1 + 16));
}

_QWORD *re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E072AD0;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072AD0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::size()
{
  return 24;
}

void re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 72) + 40))(*(_QWORD *)(v1 + 72));
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 72) + 112))(*(_QWORD *)(v1 + 72), 0);
}

_QWORD *re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E072B28;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E072B28;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::size()
{
  return 16;
}

void re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 72) + 88))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 72));
}

_QWORD *re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E072B80;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E072B80;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::size()
{
  return 16;
}

void re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 8);
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v1 + 72) + 72))(*(_QWORD *)(v1 + 72)))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v1 + 184));
    v2 = *(_QWORD *)(v1 + 208);
    if (v2)
    {
      v3 = *(_QWORD *)(v1 + 192);
      v4 = *(_QWORD *)(v1 + 224);
      *(_QWORD *)(v1 + 192) = *(_QWORD *)(v1 + 232);
      v5 = *(_QWORD *)(v1 + 200);
      *(_OWORD *)(v1 + 200) = *(_OWORD *)(v1 + 240);
      *(_QWORD *)(v1 + 240) = v5;
      *(_QWORD *)(v1 + 248) = v2;
      *(_QWORD *)(v1 + 224) = *(_QWORD *)(v1 + 264);
      *(_QWORD *)(v1 + 232) = v3;
      *(_QWORD *)(v1 + 264) = v4;
      ++*(_DWORD *)(v1 + 256);
      ++*(_DWORD *)(v1 + 216);
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 184));
      v6 = *(_QWORD *)(v1 + 248);
      if (v6)
      {
        v7 = *(uint64_t **)(v1 + 264);
        v8 = &v7[v6];
        do
        {
          v9 = *v7 + 1312;
          *(_QWORD *)&v20 = *v7 + 912;
          *((_QWORD *)&v20 + 1) = v9;
          LOBYTE(v21) = 0;
          (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 72) + 80))(*(_QWORD *)(v1 + 72));
          v11 = *((_QWORD *)&v20 + 1);
          v10 = v20;
          while (v10 != v11)
          {
            if (atomic_load(*(unint64_t **)(v10 + 8)))
            {
              os_unfair_lock_lock((os_unfair_lock_t)(v1 + 184));
              v13 = *(_QWORD *)(v1 + 224);
              v14 = *(_QWORD *)(v1 + 208);
              if (v14)
              {
                v15 = 8 * v14;
                v16 = *(_QWORD **)(v1 + 224);
                while (*v16 != *v7)
                {
                  ++v16;
                  v15 -= 8;
                  if (!v15)
                  {
                    v16 = (_QWORD *)(v13 + 8 * v14);
                    break;
                  }
                }
              }
              else
              {
                v16 = *(_QWORD **)(v1 + 224);
              }
              if (v14 == ((uint64_t)v16 - v13) >> 3)
                re::DynamicArray<re::SharedPtr<re::ProtocolHandle>>::add((_anonymous_namespace_ *)(v1 + 192), v7);
              os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 184));
              break;
            }
            v11 = *((_QWORD *)&v20 + 1);
            v10 = v20 + 40;
            *(_QWORD *)&v20 = v20 + 40;
            LOBYTE(v21) = v21 + 1;
          }
          ++v7;
        }
        while (v7 != v8);
        v17 = *(_QWORD *)(v1 + 248);
        v18 = *(_QWORD *)(v1 + 264);
        *(_QWORD *)(v1 + 248) = 0;
        if (v17)
        {
          v19 = 8 * v17;
          do
          {
            if (*(_QWORD *)v18)
            {

              *(_QWORD *)v18 = 0;
            }
            v18 += 8;
            v19 -= 8;
          }
          while (v19);
        }
      }
      else
      {
        *(_QWORD *)(v1 + 248) = 0;
      }
      ++*(_DWORD *)(v1 + 256);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 184));
    }
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(v1 + 72) + 88))(*(_QWORD *)(v1 + 72));
  v20 = 0uLL;
  v21 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 368));
  if ((*(unsigned int (**)(_QWORD, __int128 *))(**(_QWORD **)(v1 + 72) + 128))(*(_QWORD *)(v1 + 72), &v20))
  {
    if (!*(_BYTE *)(v1 + 340))
      *(_BYTE *)(v1 + 340) = 1;
    *(_OWORD *)(v1 + 344) = v20;
    *(_QWORD *)(v1 + 360) = v21;
  }
  else if (*(_BYTE *)(v1 + 340))
  {
    *(_BYTE *)(v1 + 340) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 368));
}

_QWORD *re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E072BD8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24E072BD8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::size()
{
  return 16;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24E072C30;
  v3 = (_OWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 32));
    *v3 = 0u;
    v3[1] = 0u;
  }
  return a1;
}

void re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24E072C30;
  v3 = (_OWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 32));
    *v3 = 0u;
    v3[1] = 0u;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2;
  re *v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  NSObject *v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  __int128 buf;
  uint64_t v13;
  uint64_t v14;
  __int128 *p_buf;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 8);
  v3 = (re *)(*(_QWORD *(**)(os_unfair_lock_s **__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(v2 + 72) + 48))(&v11, *(_QWORD *)(v2 + 72), a1 + 16);
  v4 = v11;
  if (v11)
  {
    v5 = *(_QWORD *)(a1 + 48);
    os_unfair_lock_lock(v11 + 441);
    *(_QWORD *)&v4[6]._os_unfair_lock_opaque = v5;
    os_unfair_lock_unlock(v4 + 441);
  }
  else
  {
    v6 = *re::networkLogObjects(v3);
    v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (v7)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        v10 = *(_QWORD *)(a1 + 32);
      else
        v10 = a1 + 25;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v10;
      _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "Failed to connect to %s", (uint8_t *)&buf, 0xCu);
    }
    v8 = *(_QWORD *)(a1 + 48);
    v9 = re::globalAllocators((re *)v7)[2];
    *(_QWORD *)&buf = &off_24E072C88;
    *((_QWORD *)&buf + 1) = v2;
    v13 = v8;
    v14 = v9;
    p_buf = &buf;
    (*(void (**)(_QWORD, __int128 *))(**(_QWORD **)(v2 + 320) + 16))(*(_QWORD *)(v2 + 320), &buf);
    if (p_buf)
    {
      (**(void (***)(__int128 *))p_buf)(p_buf);
      if (p_buf != &buf)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
    }
  }
  if (v11)

}

_QWORD *re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::cloneInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;

  v4 = a1[1];
  *a2 = off_24E072C30;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  a2[6] = a1[6];
  return a2;
}

_QWORD *re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::moveInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;

  v4 = a1[1];
  *a2 = off_24E072C30;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  a2[6] = a1[6];
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::size()
{
  return 56;
}

void re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

_anonymous_namespace_ *re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::operator()(_anonymous_namespace_ *result)
{
  uint64_t v1;
  unsigned __int8 v2;
  _anonymous_namespace_ *v3;
  int v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  int v10;

  v1 = *((_QWORD *)result + 1);
  v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if ((v2 & 1) != 0)
  {
    v3 = result;
    result = (_anonymous_namespace_ *)re::DataArray<re::Connection>::tryGet(v1 + 120, *((_QWORD *)result + 2));
    if (result)
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      re::DynamicString::setCapacity(&v5, 0);
      v10 = 0;
      v4 = 3;
      v9 = 2;
      re::Transport::connectionStateEvent(v1, *((_QWORD *)v3 + 2), &v4);
      result = (_anonymous_namespace_ *)v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*v5 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072C88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072C88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072CE0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072CE0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 72) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 72), *(_QWORD *)(a1 + 16), *(unsigned __int8 *)(a1 + 24));
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;

  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a2 = &off_24E072CE0;
  *(_QWORD *)(a2 + 8) = v5;
  *(_QWORD *)(a2 + 16) = v4;
  if (v4)
    v6 = (id)(v4 + 8);
  *(_BYTE *)(a2 + 24) = *(_BYTE *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072CE0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a2 + 24) = *(_BYTE *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::size()
{
  return 32;
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result + 8);
  v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if ((v2 & 1) != 0)
  {
    v3 = *(_QWORD *)(v1 + 608);
    if (v3)
      return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 8))(v3, *(_QWORD *)(result + 16));
  }
  return result;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072D38;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072D38;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::size()
{
  return 24;
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v2;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if ((v2 & 1) != 0)
  {
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v1 + 608) + 8))(*(_QWORD *)(v1 + 608), *(_QWORD *)(a1 + 16));
    re::Transport::destroyConnection((re::Transport *)v1, *(_QWORD *)(a1 + 16));
  }
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072D90;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072D90;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072DE8;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072DE8;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 72) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 72), *(_QWORD *)(a1 + 16), 1);
}

_QWORD *re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E072DE8;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072DE8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::size()
{
  return 24;
}

uint64_t re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24E072E40;
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {

    *(_QWORD *)(a1 + 48) = 0;
  }
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 32));
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24E072E40;
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {

    *(_QWORD *)(a1 + 48) = 0;
  }
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 32));
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  unsigned __int8 *v1;
  unsigned __int8 v2;
  re::DynamicString *v4;
  uint64_t *v5;
  unint64_t Connection;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  int v12;
  _BYTE v13[12];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v1 = *(unsigned __int8 **)(a1 + 8);
  v2 = atomic_load(v1 + 336);
  if ((v2 & 1) == 0)
    return;
  v4 = (re::DynamicString *)(a1 + 16);
  v5 = (uint64_t *)re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::tryGet((uint64_t)(v1 + 272), (re::Address *)(a1 + 16));
  if (v5)
  {
    Connection = *v5;
    v7 = re::DataArray<re::Connection>::tryGet((uint64_t)(v1 + 120), *v5);
    if (!v7)
    {
      v8 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        if ((*(_BYTE *)(a1 + 24) & 1) != 0)
          v9 = *(_QWORD *)(a1 + 32);
        else
          v9 = a1 + 25;
        v12 = 136315138;
        *(_QWORD *)v13 = v9;
        _os_log_fault_impl(&dword_21C69B000, v8, OS_LOG_TYPE_FAULT, "Connection '%s' found in m_addrToConnections but missing from m_connections!", (uint8_t *)&v12, 0xCu);
      }
      return;
    }
  }
  else
  {
    Connection = re::Transport::createConnection((re::Transport *)v1, (const re::Address *)(a1 + 16));
    v7 = re::DataArray<re::Connection>::get((uint64_t)(v1 + 120), Connection);
  }
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v7 + 40), *(_QWORD *)(a1 + 48));
  v10 = *(_QWORD *)(a1 + 48);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 1764));
  *(_QWORD *)(v10 + 24) = Connection;
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 1764));
  v14 = 0;
  v15 = 0;
  v16 = 0;
  re::DynamicString::setCapacity(&v13[4], 0);
  v17 = 0;
  v12 = 0;
  re::DynamicString::operator=((re::DynamicString *)&v13[4], v4);
  re::Transport::connectionStateEvent((uint64_t)v1, Connection, &v12);
  if (*(_QWORD *)&v13[4] && (v14 & 1) != 0)
    (*(void (**)(_QWORD))(**(_QWORD **)&v13[4] + 40))(*(_QWORD *)&v13[4]);
}

_QWORD *re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::cloneInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;

  v4 = a1[1];
  *a2 = off_24E072E40;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  v5 = a1[6];
  a2[6] = v5;
  if (v5)
    v6 = (id)(v5 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::moveInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;

  v4 = a1[1];
  *a2 = off_24E072E40;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  a2[6] = a1[6];
  a1[6] = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::size()
{
  return 56;
}

uint64_t re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24E072E98;
  v3 = (_OWORD *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 40));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *(_QWORD *)(a1 + 16);
  if (v4)
  {

    *(_QWORD *)(a1 + 16) = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24E072E98;
  v3 = (_OWORD *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 40));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *(_QWORD *)(a1 + 16);
  if (v4)
  {

    *(_QWORD *)(a1 + 16) = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  unint64_t v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  _BYTE v10[12];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 8);
  v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if ((v2 & 1) != 0)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
    v5 = re::DataArray<re::Connection>::tryGet(v1 + 120, v4);
    if (v5)
    {
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v5 + 40), *(_QWORD *)(a1 + 16));
      v11 = 0;
      v12 = 0;
      v13 = 0;
      re::DynamicString::setCapacity(&v10[4], 0);
      v14 = 0;
      v9 = 2;
      re::Transport::connectionStateEvent(v1, v4, &v9);
      if (*(_QWORD *)&v10[4])
      {
        if ((v11 & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v10[4] + 40))();
      }
    }
    else
    {
      v7 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        if ((*(_BYTE *)(a1 + 32) & 1) != 0)
          v8 = *(_QWORD *)(a1 + 40);
        else
          v8 = a1 + 33;
        v9 = 136315138;
        *(_QWORD *)v10 = v8;
        _os_log_impl(&dword_21C69B000, v7, OS_LOG_TYPE_DEFAULT, "Connection for address '%s' is already destroyed.Check logs for prior connection errors.", (uint8_t *)&v9, 0xCu);
      }
    }
  }
}

_QWORD *re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::cloneInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;

  v5 = a1[1];
  v4 = a1[2];
  *a2 = off_24E072E98;
  a2[1] = v5;
  a2[2] = v4;
  if (v4)
    v6 = (id)(v4 + 8);
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 3), (const re::DynamicString *)(a1 + 3));
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = off_24E072E98;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 24), (const re::DynamicString *)(a1 + 24));
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::size()
{
  return 56;
}

_QWORD *re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072EF0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072EF0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  unint64_t v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  NSObject *v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  int v14;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if ((v2 & 1) != 0)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
    v5 = re::DataArray<re::Connection>::tryGet(v1 + 120, v4);
    if (v5)
    {
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v5 + 40), *(_QWORD *)(a1 + 16));
      v10 = 0;
      v11 = 0;
      v12 = 0;
      re::DynamicString::setCapacity(&v9, 0);
      v14 = 0;
      v8 = 3;
      v13 = *(_BYTE *)(a1 + 24);
      re::Transport::connectionStateEvent(v1, v4, &v8);
      if (v9)
      {
        if ((v10 & 1) != 0)
          (*(void (**)(void))(*v9 + 40))();
      }
    }
    else
    {
      v7 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v8) = 0;
        _os_log_debug_impl(&dword_21C69B000, v7, OS_LOG_TYPE_DEBUG, "Connection was destroyed before error event.", (uint8_t *)&v8, 2u);
      }
    }
  }
}

uint64_t re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  id v6;

  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)a2 = &off_24E072EF0;
  *(_QWORD *)(a2 + 8) = v5;
  *(_QWORD *)(a2 + 16) = v4;
  if (v4)
    v6 = (id)(v4 + 8);
  *(_BYTE *)(a2 + 24) = *(_BYTE *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072EF0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_BYTE *)(a2 + 24) = *(_BYTE *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::size()
{
  return 32;
}

_QWORD *re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072F48;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072F48;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result + 8);
  v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if ((v2 & 1) != 0)
  {
    v3 = *(_QWORD *)(*(_QWORD *)(result + 16) + 24);
    result = re::DataArray<re::Connection>::tryGet(v1 + 120, v3);
    if (result)
    {
      if (!*(_BYTE *)(result + 120))
      {
        *(_BYTE *)(result + 120) = 1;
        return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 608) + 32))(*(_QWORD *)(v1 + 608), v3);
      }
    }
  }
  return result;
}

_QWORD *re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E072F48;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072F48;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072FA0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072FA0;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result + 8);
  v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if ((v2 & 1) != 0)
  {
    v3 = *(_QWORD *)(*(_QWORD *)(result + 16) + 24);
    result = re::DataArray<re::Connection>::tryGet(v1 + 120, v3);
    if (result)
    {
      if (*(_BYTE *)(result + 120))
      {
        *(_BYTE *)(result + 120) = 0;
        *(_QWORD *)(result + 128) = 0x8000000000000000;
        return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v1 + 608) + 40))(*(_QWORD *)(v1 + 608), v3);
      }
    }
  }
  return result;
}

_QWORD *re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E072FA0;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072FA0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072FF8;
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E072FF8;
  v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = atomic_load((unsigned __int8 *)(v2 + 336));
  if ((v3 & 1) != 0 && re::DataArray<re::Connection>::tryGet(v2 + 120, *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24)))
    (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v2 + 64))(v2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(unsigned __int8 *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16), *(unsigned int *)(*(_QWORD *)(a1 + 40) + 24));
  re::PacketPool::free(*(re::PacketPool **)(v2 + 384), *(re::Packet **)(a1 + 40));
}

uint64_t re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  id v5;

  *(_QWORD *)a2 = &off_24E072FF8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 24) = v4;
  if (v4)
    v5 = (id)(v4 + 8);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E072FF8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::size()
{
  return 48;
}

void re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::~Callable()
{
  JUMPOUT(0x220780CD0);
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 72) + 136))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 72), *(unsigned int *)(a1 + 16));
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E073050;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E073050;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::size()
{
  return 24;
}

_QWORD *re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E0730A8;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24E0730A8;
  v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x220780CD0);
}

void re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  (*(void (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(v2 + 72) + 56))(*(_QWORD *)(v2 + 72), *(_QWORD *)(a1 + 16), 1);
  re::Transport::cleanupPendingQueues((re::PacketPool **)v2, *(unint64_t ***)(a1 + 16));
}

_QWORD *re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;

  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *a2 = &off_24E0730A8;
  a2[1] = v4;
  a2[2] = v3;
  if (v3)
    v5 = (id)(v3 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24E0730A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::size()
{
  return 24;
}

_anonymous_namespace_ *re::DataArray<re::Connection>::allocBlock(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _anonymous_namespace_ *result;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;

  v3 = 136 * *((unsigned int *)a1 + 11);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(_QWORD *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  v6 = v4;
  v1 = 4 * *((unsigned int *)a1 + 11);
  result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(_QWORD *)(*a1 + 8));
    result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  v9 = result;
  v11 = a1[1];
  v10 = a1[2];
  if (v10 >= v11)
  {
    v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        v13 = 2 * v11;
        if (!v11)
          v13 = 8;
        if (v13 <= v12)
          v14 = v12;
        else
          v14 = v13;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v14);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    v10 = a1[2];
  }
  v15 = (uint64_t *)(a1[4] + 16 * v10);
  *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

void re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  signed int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE v30[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v30, 0, 36);
          *(_QWORD *)&v30[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::init((uint64_t)v30, v13, v12);
          v15 = *(_OWORD *)v30;
          *(_OWORD *)v30 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v30[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v30[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v30[24];
          *(_OWORD *)&v30[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v30[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = 0;
            v22 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v22 - 8) & 0x80000000) != 0)
                re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove(a1, *(_QWORD *)(v22 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v22 - 16), v22 - 4, v22);
              ++v21;
              v22 += 80;
            }
            while (v21 < v20);
          }
          re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)v30);
        }
      }
      else
      {
        if (v12)
          v25 = 2 * v11;
        else
          v25 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 80 * v9 + 8);
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 80 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 80 * v9 + 8) = v24 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v9) = a3;
  *(_WORD *)(*(_QWORD *)(a1 + 16) + 80 * v9 + 12) = *a4;
  v26 = *(_QWORD *)(a1 + 16) + 80 * v9;
  *(_QWORD *)(v26 + 16) = 0;
  *(_QWORD *)(v26 + 24) = 0;
  *(_QWORD *)(v26 + 32) = 0;
  *(_QWORD *)(v26 + 16) = *(_QWORD *)a5;
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(v26 + 24) = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(a5 + 8) = 0;
  v27 = *(_QWORD *)(v26 + 32);
  *(_QWORD *)(v26 + 32) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)(a5 + 16) = v27;
  *(_QWORD *)(v26 + 40) = 0;
  *(_QWORD *)(v26 + 48) = 0;
  *(_QWORD *)(v26 + 56) = 0;
  *(_QWORD *)(v26 + 40) = *(_QWORD *)(a5 + 24);
  *(_QWORD *)(a5 + 24) = 0;
  *(_QWORD *)(v26 + 48) = *(_QWORD *)(a5 + 32);
  *(_QWORD *)(a5 + 32) = 0;
  v28 = *(_QWORD *)(v26 + 56);
  *(_QWORD *)(v26 + 56) = *(_QWORD *)(a5 + 40);
  *(_QWORD *)(a5 + 40) = v28;
  *(_OWORD *)(v26 + 64) = *(_OWORD *)(a5 + 48);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 80 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_21C701D20, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::FixedArray<unsigned char>::init<>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v7;
  size_t v8;

  *a1 = a2;
  a1[1] = a3;
  if (a3)
  {
    v5 = (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3, 1);
    a1[2] = v5;
    if (v5)
    {
      v7 = v5;
      v8 = a3 - 1;
      if (v8)
      {
        bzero(v5, v8);
        v7 += v8;
      }
      *v7 = 0;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
  }
}

void re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  unint64_t *v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  signed int v20;
  _BYTE v21[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v21, 0, 36);
      *(_QWORD *)&v21[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::init((uint64_t)v21, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v21;
      v6 = *(unint64_t **)(a1 + 16);
      v7 = *(_OWORD *)&v21[8];
      *(_OWORD *)v21 = v5;
      *(_QWORD *)&v21[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v21[24];
      *(_OWORD *)&v21[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v21[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        do
        {
          if ((v6[1] & 0x80000000) != 0)
          {
            v13 = *v6;
            v14 = *(unsigned int *)(a1 + 24);
            v15 = *v6 % v14;
            v16 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v16 == 0x7FFFFFFF)
            {
              v16 = *(unsigned int *)(a1 + 32);
              v17 = v16;
              if ((_DWORD)v16 == (_DWORD)v14)
              {
                re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::setCapacity(a1, (2 * v11));
                v15 = v13 % *(unsigned int *)(a1 + 24);
                v17 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v17 + 1;
              v18 = *(_QWORD *)(a1 + 16);
              v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
            }
            else
            {
              v18 = *(_QWORD *)(a1 + 16);
              v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
              *(_DWORD *)(a1 + 36) = v19 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v18 + 56 * v16 + 8) = v19 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v15);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16) = v13;
            re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 16), (const re::DynamicString *)(v6 + 2));
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 48) = v6[6];
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v15) = v16;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v6 += 7;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit((uint64_t *)v21, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v20 = a2;
    else
      v20 = 3;
  }
}

_QWORD *re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  id *v7;
  id *v8;
  uint64_t v9;
  uint64_t v10;
  id *v11;
  id *v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = (id *)result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (id *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        v12 = v7;
        do
        {
          *v12++ = 0;
          objc_moveWeak(v11, v8);
          objc_destroyWeak(v8);
          *v8++ = 0;
          v11 = v12;
          v10 -= 8;
        }
        while (v10);
        v8 = (id *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, id *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<unsigned long &>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  v13 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

id *re::ArcWeakPtr<re::TransportStream>::operator=(id *location, id *a2)
{
  if (a2 != location)
  {
    objc_destroyWeak(location);
    *location = 0;
    objc_moveWeak(location, a2);
  }
  return location;
}

uint64_t re::BitReader::seekTo(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;

  if (!*(_BYTE *)(result + 12))
  {
    if (HIDWORD(a2))
      v2 = a2 + 1;
    else
      v2 = a2;
    v3 = *(_DWORD *)(result + 8);
    if (v2 <= v3)
    {
      return re::BitReader::applyMarker(result, a2);
    }
    else
    {
      *(_DWORD *)(result + 16) = v3;
      *(_DWORD *)(result + 20) = 0;
      *(_BYTE *)(result + 12) = 1;
    }
  }
  return result;
}

uint64_t re::BitReader::applyMarker(uint64_t result, uint64_t a2)
{
  if (HIDWORD(a2))
  {
    *(_DWORD *)(result + 16) = a2 + 1;
    *(_DWORD *)(result + 20) = 8 - HIDWORD(a2);
    *(_QWORD *)(result + 24) = 0;
    if (HIDWORD(a2) != 8)
      *(_QWORD *)(result + 24) = (unint64_t)*(unsigned __int8 *)(*(_QWORD *)result + a2) >> SBYTE4(a2);
  }
  else
  {
    *(_DWORD *)(result + 16) = a2;
    *(_DWORD *)(result + 20) = 0;
    *(_QWORD *)(result + 24) = 0;
  }
  return result;
}

uint64_t *re::BitReader::readUInt32Bits(uint64_t *this, unsigned int a2, unsigned int *a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;

  *a3 = 0;
  if (!*((_BYTE *)this + 12))
  {
    v3 = *((_DWORD *)this + 2);
    v5 = *((_DWORD *)this + 4);
    v4 = *((_DWORD *)this + 5);
    if (v4 + 8 * (v3 - v5) >= a2)
    {
      if (v4 >= a2)
      {
        v8 = this[3];
      }
      else
      {
        v7 = *this;
        v8 = this[3];
        do
        {
          *((_DWORD *)this + 4) = v5 + 1;
          v8 |= (unint64_t)*(unsigned __int8 *)(v7 + v5) << v4;
          this[3] = v8;
          v4 += 8;
          *((_DWORD *)this + 5) = v4;
          ++v5;
        }
        while (v4 < a2);
      }
      *a3 = v8 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a2);
      this[3] = v8 >> a2;
      v6 = *((_DWORD *)this + 5) - a2;
    }
    else
    {
      v6 = 0;
      *((_BYTE *)this + 12) = 1;
      *((_DWORD *)this + 4) = v3;
    }
    *((_DWORD *)this + 5) = v6;
  }
  return this;
}

uint64_t *re::BitReader::readUInt64Bits(re::BitReader *this, unsigned int a2, unint64_t *a3)
{
  uint64_t *result;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9[2];

  if (a2 < 0x21)
  {
    v8 = 0;
    result = re::BitReader::readUInt32Bits((uint64_t *)this, a2, &v8);
    v7 = v8;
  }
  else
  {
    *(_QWORD *)v9 = 0;
    re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, &v9[1]);
    result = re::BitReader::readUInt32Bits((uint64_t *)this, a2 - 32, v9);
    v7 = v9[1] | ((unint64_t)v9[0] << 32);
  }
  *a3 = v7;
  return result;
}

uint64_t *re::BitReader::readUInt64(re::BitReader *this, unint64_t *a2)
{
  uint64_t *result;
  unsigned int v5[2];

  *(_QWORD *)v5 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, &v5[1]);
  result = re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, v5);
  *a2 = v5[1] | ((unint64_t)v5[0] << 32);
  return result;
}

uint64_t RESyncableGetTypeId(uint64_t result)
{
  if (result)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 88) + 16) + 32);
  return result;
}

uint64_t RESyncableGetTypeInfo(uint64_t result)
{
  if (result)
    return *(_QWORD *)(*(_QWORD *)(result + 88) + 16);
  return result;
}

uint64_t RESyncableReadState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  char v11;
  uint64_t v12;
  uint64_t v13;

  result = 0;
  if (a1 && a3)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 16);
    v7 = *(_QWORD *)(a3 + 8);
    if (v7)
    {
      v8 = *(_QWORD *)(v7 + 8);
      if (*(_DWORD *)(v7 + 28))
        LODWORD(v7) = *(_DWORD *)(v7 + 24) + 1;
      else
        LODWORD(v7) = *(_DWORD *)(v7 + 24);
    }
    else
    {
      v8 = 0;
    }
    v9 = v8;
    v10 = v7;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)(v6 + 80) + 16))(*(_QWORD *)(v6 + 80), &v9, a2, a4);
  }
  return result;
}

uint64_t RESyncableIsDestroyed(uint64_t result)
{
  if (result)
    return (*(unsigned __int8 *)(result + 128) >> 2) & 1;
  return result;
}

uint64_t RESyncableGetGuid(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t RESyncableGetParent(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 80);
  return result;
}

uint64_t RESyncableGetChildCount(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 200);
  return result;
}

uint64_t RESyncableGetChild(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(_QWORD *)(result + 200) <= a2)
      return 0;
    else
      return *(_QWORD *)(*(_QWORD *)(result + 216) + 8 * a2);
  }
  return result;
}

void *RESyncableSetUserData(void *result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[5];

  if (result)
  {
    if (a2 && a3)
    {
      v3[0] = MEMORY[0x24BDAC760];
      v3[1] = 0x40000000;
      v3[2] = __RESyncableSetUserData_block_invoke;
      v3[3] = &unk_24E0730F8;
      v3[4] = a3;
      return re::SyncObject::setUserData((uint64_t)result, a2, v3);
    }
    else
    {
      return re::SyncObject::setUserData((uint64_t)result, a2, 0);
    }
  }
  return result;
}

uint64_t RESyncableGetUserData(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 112);
  return result;
}

uint64_t RESyncableIsAuthoritative(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 80);
    if (v1)
    {
      do
      {
        v2 = result;
        result = v1;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 88) + 16) + 73))
          break;
        v1 = *(_QWORD *)(v1 + 80);
        v2 = result;
      }
      while (v1);
    }
    else
    {
      v2 = result;
    }
    return *(_BYTE *)(v2 + 170) != 0;
  }
  return result;
}

BOOL RESyncableSetLocked(uint64_t a1, char a2)
{
  if (a1 && !*(_QWORD *)(a1 + 160) && !*(_QWORD *)(a1 + 136))
    *(_BYTE *)(a1 + 152) = a2;
  return a1 != 0;
}

uint64_t RESyncableIsLocked(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 80);
    if (v1)
    {
      do
      {
        v2 = result;
        result = v1;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 88) + 16) + 73))
          break;
        v1 = *(_QWORD *)(v1 + 80);
        v2 = result;
      }
      while (v1);
    }
    else
    {
      v2 = result;
    }
    return *(_BYTE *)(v2 + 152) != 0;
  }
  return result;
}

BOOL RESyncableSetMigrateWhenAbandoned(uint64_t a1, char a2)
{
  if (a1)
    *(_BYTE *)(a1 + 171) = a2;
  return a1 != 0;
}

uint64_t RESyncableIsMigrateWhenAbandoned(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 80);
    if (v1)
    {
      do
      {
        v2 = result;
        result = v1;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 88) + 16) + 73))
          break;
        v1 = *(_QWORD *)(v1 + 80);
        v2 = result;
      }
      while (v1);
    }
    else
    {
      v2 = result;
    }
    return *(_BYTE *)(v2 + 171) != 0;
  }
  return result;
}

uint64_t RESyncableGetOwnerPeerID(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 80);
    if (v1)
    {
      do
      {
        v2 = result;
        result = v1;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 88) + 16) + 73))
          break;
        v1 = *(_QWORD *)(v1 + 80);
        v2 = result;
      }
      while (v1);
    }
    else
    {
      v2 = result;
    }
    return *(_QWORD *)(v2 + 160);
  }
  return result;
}

re::SyncObject *RESyncableGetFromPeerID(re::SyncObject *result)
{
  if (result)
    return (re::SyncObject *)re::SyncObject::fromPeerID(result);
  return result;
}

BOOL RESyncableIsOpaque(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 88) + 16) + 72) != 0;
  return result;
}

re::SyncObject *RESyncableHandoffOwnership(re::SyncObject *this, uint64_t a2)
{
  if (this)
    return (re::SyncObject *)re::SyncObject::handOff(this, a2);
  return this;
}

uint64_t RESyncableHasOwnership(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 80);
    if (v1)
    {
      do
      {
        v2 = result;
        result = v1;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v2 + 88) + 16) + 73))
          break;
        v1 = *(_QWORD *)(v1 + 80);
        v2 = result;
      }
      while (v1);
    }
    else
    {
      v2 = result;
    }
    return *(_QWORD *)(v2 + 160) == 0;
  }
  return result;
}

uint64_t RESyncableSetDirectView(uint64_t result, re::SyncView *a2)
{
  if (result)
  {
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 88) + 16) + 74))
    {
      re::SyncObject::setViewDirectly((re::SyncObject *)result, a2);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t RESyncableGetDirectView(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 96);
  return result;
}

_QWORD *RESyncableGetHierarchicalView(_QWORD *result)
{
  if (result)
  {
    while (!*(_BYTE *)(*(_QWORD *)(result[11] + 16) + 74))
    {
      result = (_QWORD *)result[10];
      if (!result)
        return result;
    }
    return (_QWORD *)result[12];
  }
  return result;
}

uint64_t RESyncReadContextGetSyncable(uint64_t **a1)
{
  uint64_t v1;
  id v2;

  if (!a1)
    return 0;
  v1 = **a1;
  if (v1)
  {
    v2 = (id)(v1 + 8);

  }
  return v1;
}

uint64_t RESyncableSetHoldID(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 32) = a2;
  return result;
}

uint64_t RESyncableGetHoldID(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

BOOL re::MultipeerDiscoveryView::init(id *this, ObjCObject a2)
{
  uint64_t v2;
  _anonymous_namespace_ *v5;
  id v6;
  re *v7;
  uint64_t *v8;
  MCIdentity *v9;
  uint64_t v10;
  void *v11;
  re *v12;
  re *v13;
  uint64_t v14;
  re *v15;
  MCPeerID *v16;
  uint64_t *v17;
  MCIdentity *v18;
  uint64_t v19;
  NSObject *v20;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint8_t buf[16];
  _BYTE v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)a2.var0;
  if (*(_QWORD *)a2.var0)
  {
    v5 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(this + 3, 0);
    ++*((_DWORD *)this + 12);
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(this + 14, 0);
    ++*((_DWORD *)this + 34);
    v6 = *(id *)a2.var0;
    objc_msgSend(v6, "myPeerID");
    v7 = (re *)objc_claimAutoreleasedReturnValue();
    v8 = re::globalAllocators(v7);
    v9 = (MCIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 72, 8);
    MCIdentity::MCIdentity(v9, (MCPeerID *)v7, 1);
    *(_QWORD *)buf = v10;
    re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add(this + 26, buf);
    if (*(_QWORD *)buf)
    {

      *(_QWORD *)buf = 0;
    }

    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    objc_msgSend(v6, "connectedPeers", 0);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = (re *)objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v22, v27, 16);
    if (v12)
    {
      v13 = v12;
      v14 = *(_QWORD *)v23;
      do
      {
        v15 = 0;
        do
        {
          if (*(_QWORD *)v23 != v14)
            objc_enumerationMutation(v11);
          v16 = *(MCPeerID **)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)v15);
          v17 = re::globalAllocators(v12);
          v18 = (MCIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v17[2] + 32))(v17[2], 72, 8);
          MCIdentity::MCIdentity(v18, v16, 0);
          *(_QWORD *)buf = v19;
          v12 = (re *)re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add(this + 26, buf);
          if (*(_QWORD *)buf)

          v15 = (re *)((char *)v15 + 1);
        }
        while (v13 != v15);
        v12 = (re *)objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v22, v27, 16);
        v13 = v12;
      }
      while (v12);
    }

    re::ObjCObject::operator=(this + 25, (id *)a2.var0);
  }
  else
  {
    v20 = *re::networkLogObjects((re *)this);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_21C69B000, v20, OS_LOG_TYPE_ERROR, "Invalid MCSession.", buf, 2u);
    }
  }
  return v2 != 0;
}

_QWORD *re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  *a2 = 0;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t re::MultipeerDiscoveryView::didJoinEvent(re::MultipeerDiscoveryView *this)
{
  return (uint64_t)this + 24;
}

uint64_t re::MultipeerDiscoveryView::didLeaveEvent(re::MultipeerDiscoveryView *this)
{
  return (uint64_t)this + 112;
}

uint64_t re::MultipeerDiscoveryView::identitiesCount(re::MultipeerDiscoveryView *this)
{
  return *((_QWORD *)this + 28);
}

_QWORD *re::MultipeerDiscoveryView::identityAtIndex@<X0>(_QWORD *this@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  if (this[28] <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = *(_QWORD *)(this[30] + 8 * a2);
  *a3 = v3;
  if (v3)
    return (id)(v3 + 8);
  return this;
}

id re::MultipeerDiscoveryView::multipeerIdAtIndex@<X0>(re::MultipeerDiscoveryView *this@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  id result;

  if (*((_QWORD *)this + 28) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  result = *(id *)(*(_QWORD *)(*((_QWORD *)this + 30) + 8 * a2) + 24);
  *a3 = result;
  return result;
}

void re::MultipeerDiscoveryView::requestIdentity(uint64_t a1, uint64_t a2)
{
  id v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  MCPeerID *v10;
  _BOOL8 v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v4 = *(id *)(a1 + 200);
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v17 = v4;
  objc_msgSend(v4, "connectedPeers");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v22;
    do
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v22 != v8)
          objc_enumerationMutation(v5);
        v10 = *(MCPeerID **)(*((_QWORD *)&v21 + 1) + 8 * i);
        +[REMultipeerHelper makeAddressFromPeerID:](REMultipeerHelper, "makeAddressFromPeerID:", v10);
        v11 = re::DynamicString::operator==(a2, (uint64_t)&v19);
        if (v11)
        {
          v12 = re::globalAllocators((re *)v11);
          v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12[2] + 32))(v12[2], 72, 8);
          MCIdentity::MCIdentity((MCIdentity *)v13, v10, 0);
          v14 = *(_QWORD *)(a1 + 224);
          if (v14 >= *(_QWORD *)(a1 + 216))
          {
            re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::growCapacity((_QWORD *)(a1 + 208), v14 + 1);
            v14 = *(_QWORD *)(a1 + 224);
          }
          *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * v14) = v13;
          if (v13)
          {
            v15 = (id)(v13 + 8);
            ++*(_QWORD *)(a1 + 224);
            ++*(_DWORD *)(a1 + 232);
            v18 = v13;
            v16 = (id)(v13 + 8);
          }
          else
          {
            *(_QWORD *)(a1 + 224) = v14 + 1;
            ++*(_DWORD *)(a1 + 232);
            v18 = 0;
          }
          re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(a1 + 24, a1);
          if (v18)

          if (v13)
        }
        if (v19 && (v20 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v19 + 40))();
      }
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    }
    while (v7);
  }

}

BOOL re::MultipeerDiscoveryView::removeIdentity(uint64_t a1, _QWORD *a2)
{
  _BOOL8 v4;
  id v5;
  uint64_t v7;

  v4 = re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::remove(a1 + 208, a2);
  if (v4)
  {
    v7 = *a2;
    if (*a2)
      v5 = (id)(*a2 + 8);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(a1 + 112, a1);
    if (v7)

  }
  return v4;
}

BOOL re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::remove(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    v4 = 8 * v3;
    v5 = *(_QWORD **)(a1 + 32);
    while (*v5 != *a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        v5 = (_QWORD *)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    v5 = *(_QWORD **)(a1 + 32);
  }
  v6 = (uint64_t)v5 - v2;
  v7 = v6 >> 3;
  if (v6 >> 3 != v3)
    re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(a1, v6 >> 3);
  return v7 != v3;
}

void re::MultipeerDiscoveryView::createProtocolLayer(id *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  id v6;

  v4 = re::globalAllocators((re *)this);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 80, 8);
  v6 = this[25];
  re::MultipeerProtocolLayer::MultipeerProtocolLayer(v5, &v6);

  *a2 = v5;
}

void re::MultipeerDiscoveryView::~MultipeerDiscoveryView(re::MultipeerDiscoveryView *this)
{
  *(_QWORD *)this = &off_24E073128;
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 208);

  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 14);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E073128;
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 208);

  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 14);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t re::MultipeerDiscoveryView::authData(re::MultipeerDiscoveryView *this)
{
  return 0;
}

void MCIdentity::MCIdentity(MCIdentity *this, MCPeerID *a2, char a3)
{
  MCPeerID *v5;
  _anonymous_namespace_ *v6;
  void *v7;
  MCPeerID *v8;
  uint64_t v9;
  char v10;

  v5 = a2;
  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = off_24E0731B0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 7) = 0;
  re::DynamicString::setCapacity((_QWORD *)this + 4, 0);
  *((_BYTE *)this + 64) = 0;
  v7 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v5;
  v8 = v5;

  +[REMultipeerHelper makeAddressFromPeerID:](REMultipeerHelper, "makeAddressFromPeerID:", v8);
  re::DynamicString::operator=((MCIdentity *)((char *)this + 32), (re::DynamicString *)&v9);
  if (v9 && (v10 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v9 + 40))();
  *((_BYTE *)this + 64) = a3;
}

void MCIdentity::~MCIdentity(MCIdentity *this)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24E0731B0;
  v3 = (_OWORD *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 6));
    *v3 = 0u;
    v3[1] = 0u;
  }

  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24E0731B0;
  v3 = (_OWORD *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 6));
    *v3 = 0u;
    v3[1] = 0u;
  }

  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t MCIdentity::displayName(id *this)
{
  id v1;
  uint64_t v2;

  objc_msgSend(this[3], "displayName");
  v1 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v2 = objc_msgSend(v1, "UTF8String");

  return v2;
}

re::DynamicString *MCIdentity::address@<X0>(MCIdentity *this@<X0>, re::DynamicString *a2@<X8>)
{
  return re::DynamicString::DynamicString(a2, (MCIdentity *)((char *)this + 32));
}

uint64_t MCIdentity::isLocal(MCIdentity *this)
{
  return *((unsigned __int8 *)this + 64);
}

_QWORD *re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::TcpProtocolLayer::TcpProtocolLayer(uint64_t a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24E073210;
  *(_DWORD *)(a1 + 24) = -1;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 68) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 116) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 128) = *(_DWORD *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 136), (const re::DynamicString *)(a2 + 8));
  *(_WORD *)(a1 + 168) = *(_WORD *)(a2 + 40);
  *(_DWORD *)(a1 + 176) = 10;
  *(_WORD *)(a1 + 180) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = -1;
  *(_QWORD *)(a1 + 200) = 0;
  return a1;
}

void re::TcpProtocolLayer::~TcpProtocolLayer(re::TcpProtocolLayer *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24E073210;
  if (*((_DWORD *)this + 6) != -1)
    re::TcpProtocolLayer::deinit(this);
  v2 = *((_QWORD *)this + 17);
  if (v2)
  {
    if ((*((_BYTE *)this + 144) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 19));
    *(_OWORD *)((char *)this + 136) = 0u;
    *(_OWORD *)((char *)this + 152) = 0u;
  }
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 10);
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 4);
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::TcpProtocolLayer::~TcpProtocolLayer(this);
  JUMPOUT(0x220780CD0);
}

BOOL re::TcpProtocolLayer::init(uint64_t a1, uint64_t a2)
{
  re::IP *v3;
  re *v4;
  NSObject *v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  re *v10;
  int v11;
  NSObject *v12;
  int v13;
  int v14;
  re *v15;
  re *v16;
  NSObject *v17;
  const char *v18;
  int *v19;
  char *v20;
  const char *v21;
  uint8_t *p_changelist;
  NSObject *v23;
  uint32_t v24;
  int v25;
  NSObject *v26;
  re *v27;
  int v28;
  NSObject *v29;
  re *v30;
  NSObject *v31;
  re *v32;
  re *v33;
  re *v34;
  NSObject *v35;
  const char *v36;
  int v37;
  NSObject *v38;
  const char *v39;
  int *v40;
  char *v41;
  const char *v42;
  int *v43;
  char *v44;
  int *v45;
  char *v46;
  socklen_t v47;
  int v48;
  addrinfo *v49;
  int v50;
  const char *v51;
  kevent64_s changelist;
  sockaddr v53;
  char __str[8];
  __int16 v55;
  addrinfo v56;
  _BYTE v57[32];
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 8);
  *(_WORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 24) = kqueue();
  if ((*(_BYTE *)(a1 + 144) & 1) != 0)
    v3 = *(re::IP **)(a1 + 152);
  else
    v3 = (re::IP *)(a1 + 145);
  v4 = (re *)re::IP::makeFromString(v3, (uint64_t)v57);
  if (!v57[0])
  {
    v5 = *re::networkLogObjects(v4);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    if ((*(_BYTE *)(a1 + 144) & 1) != 0)
      v8 = *(_QWORD *)(a1 + 152);
    else
      v8 = a1 + 145;
    v56.ai_flags = 136315138;
    *(_QWORD *)&v56.ai_family = v8;
    v21 = "An error occurred while trying to create an Tcp server host. Invalid bind address: %s";
    goto LABEL_47;
  }
  if (v57[8])
  {
    v5 = *re::networkLogObjects(v4);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    if ((*(_BYTE *)(a1 + 144) & 1) != 0)
      v7 = *(_QWORD *)(a1 + 152);
    else
      v7 = a1 + 145;
    v56.ai_flags = 136315138;
    *(_QWORD *)&v56.ai_family = v7;
    v21 = "An error occurred while trying to create an Tcp server host. Tcp only supports IPv4. IPv6 requested. (%s)";
LABEL_47:
    p_changelist = (uint8_t *)&v56;
    v23 = v5;
LABEL_48:
    v24 = 12;
    goto LABEL_49;
  }
  memset(&v56.ai_addrlen, 0, 32);
  v56.ai_flags = 0;
  *(_QWORD *)&v56.ai_family = 0x100000002;
  v56.ai_protocol = 6;
  v55 = 0;
  *(_QWORD *)__str = 0;
  snprintf(__str, 0xAuLL, "%i", *(unsigned __int16 *)(a1 + 168));
  v49 = 0;
  if ((*(_BYTE *)(a1 + 144) & 1) != 0)
    v9 = *(const char **)(a1 + 152);
  else
    v9 = (const char *)(a1 + 145);
  v10 = (re *)getaddrinfo(v9, __str, &v56, &v49);
  if ((_DWORD)v10)
  {
    v11 = (int)v10;
    v12 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v36 = gai_strerror(v11);
      LODWORD(changelist.ident) = 136315138;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v36;
      _os_log_error_impl(&dword_21C69B000, v12, OS_LOG_TYPE_ERROR, "getaddrinfo failed: %s", (uint8_t *)&changelist, 0xCu);
    }
    freeaddrinfo(v49);
    return 0;
  }
  v13 = socket(v49->ai_family, v49->ai_socktype, v49->ai_protocol);
  *(_DWORD *)(a1 + 192) = v13;
  v48 = 1;
  setsockopt(v13, 0xFFFF, 4, &v48, 4u);
  v14 = bind(*(_DWORD *)(a1 + 192), v49->ai_addr, v49->ai_addrlen);
  freeaddrinfo(v49);
  v49 = 0;
  if (v14 < 0)
  {
    v17 = *re::networkLogObjects(v15);
    result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v18 = gai_strerror(v14);
    v19 = __error();
    v20 = strerror(*v19);
    LODWORD(changelist.ident) = 136315650;
    *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)__str;
    LOWORD(changelist.fflags) = 2080;
    *(_QWORD *)((char *)&changelist.fflags + 2) = v18;
    HIWORD(changelist.data) = 2080;
    changelist.udata = (uint64_t)v20;
    v21 = "bind on port %s failed: %s errno = %s";
    p_changelist = (uint8_t *)&changelist;
    v23 = v17;
    v24 = 32;
    goto LABEL_49;
  }
  v47 = 16;
  v16 = (re *)getsockname(*(_DWORD *)(a1 + 192), &v53, &v47);
  if ((v16 & 0x80000000) != 0)
  {
    v25 = (int)v16;
    v26 = *re::networkLogObjects(v16);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v40 = __error();
      v41 = strerror(*v40);
      v42 = gai_strerror(v25);
      LODWORD(changelist.ident) = 136315394;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v41;
      LOWORD(changelist.fflags) = 2080;
      *(_QWORD *)((char *)&changelist.fflags + 2) = v42;
      _os_log_error_impl(&dword_21C69B000, v26, OS_LOG_TYPE_ERROR, "getsockname: %s : %s", (uint8_t *)&changelist, 0x16u);
    }
  }
  else
  {
    *(_WORD *)(a1 + 180) = bswap32(*(unsigned __int16 *)v53.sa_data) >> 16;
  }
  v27 = (re *)fcntl(*(_DWORD *)(a1 + 192), 3, 0);
  v28 = (int)v27;
  if ((v27 & 0x80000000) != 0)
  {
    v29 = *re::networkLogObjects(v27);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      v43 = __error();
      v44 = strerror(*v43);
      LODWORD(changelist.ident) = 136315138;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v44;
      _os_log_error_impl(&dword_21C69B000, v29, OS_LOG_TYPE_ERROR, "Could not get server socket flags: %s\n", (uint8_t *)&changelist, 0xCu);
    }
  }
  v30 = (re *)fcntl(*(_DWORD *)(a1 + 192), 4, v28 | 4u);
  if ((v30 & 0x80000000) != 0)
  {
    v31 = *re::networkLogObjects(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v45 = __error();
      v46 = strerror(*v45);
      LODWORD(changelist.ident) = 136315138;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v46;
      _os_log_error_impl(&dword_21C69B000, v31, OS_LOG_TYPE_ERROR, "Could set server socket to be non blocking: %s\n", (uint8_t *)&changelist, 0xCu);
    }
  }
  changelist.ident = *(int *)(a1 + 192);
  *(_DWORD *)&changelist.filter = 0x1FFFF;
  memset(&changelist.fflags, 0, 36);
  v32 = (re *)kevent64(*(_DWORD *)(a1 + 24), &changelist, 1, 0, 0, 0, 0);
  if ((_DWORD)v32 == -1)
  {
    v35 = *re::networkLogObjects(v32);
    result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(v50) = 0;
    v21 = "kevent failed";
LABEL_42:
    p_changelist = (uint8_t *)&v50;
    v23 = v35;
    v24 = 2;
LABEL_49:
    _os_log_error_impl(&dword_21C69B000, v23, OS_LOG_TYPE_ERROR, v21, p_changelist, v24);
    return 0;
  }
  changelist.ident = 0;
  *(_DWORD *)&changelist.filter = 393206;
  memset(&changelist.fflags, 0, 36);
  v33 = (re *)kevent64(*(_DWORD *)(a1 + 24), &changelist, 1, 0, 0, 0, 0);
  if ((_DWORD)v33 == -1)
  {
    v35 = *re::networkLogObjects(v33);
    result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    LOWORD(v50) = 0;
    v21 = "kevent failed";
    goto LABEL_42;
  }
  v34 = (re *)listen(*(_DWORD *)(a1 + 192), *(_DWORD *)(a1 + 128));
  if ((v34 & 0x80000000) != 0)
  {
    v37 = (int)v34;
    v38 = *re::networkLogObjects(v34);
    result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v39 = gai_strerror(v37);
      v50 = 136315138;
      v51 = v39;
      v21 = "listen failed: %s";
      p_changelist = (uint8_t *)&v50;
      v23 = v38;
      goto LABEL_48;
    }
  }
  else
  {
    if (re::internal::enableSignposts(0, 0))
      kdebug_trace();
    return 1;
  }
  return result;
}

uint64_t re::TcpProtocolLayer::deinit(re::TcpProtocolLayer *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  re *v11;
  NSObject *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  id v21;
  id v22;
  uint64_t v23;
  re *v24;
  NSObject *v25;
  void *v26;
  int v27;
  int v28;
  uint64_t result;
  char *v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v2 = *((unsigned int *)this + 28);
  v30 = (char *)this + 80;
  v3 = 0;
  if ((_DWORD)v2)
  {
    v4 = (int *)(*((_QWORD *)this + 12) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 6;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v6 = v3;
    do
    {
      v7 = *((_QWORD *)this + 12) + 24 * v6;
      v8 = *(_QWORD *)(v7 + 16);
      if (v8)
        v9 = (id)(v8 + 8);
      v10 = *((_QWORD *)this + 23);
      if (v10)
        (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, uint64_t))(*(_QWORD *)v10 + 8))(v10, this, v8, v8 + 1776);
      v11 = (re *)close(*(_DWORD *)(v7 + 12));
      v12 = *re::networkLogObjects(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v32 = "deinit";
        v33 = 1024;
        v34 = 230;
        v35 = 2048;
        v36 = v8;
        _os_log_impl(&dword_21C69B000, v12, OS_LOG_TYPE_DEFAULT, "%s:%u queueing close on handle %p", buf, 0x1Cu);
      }
      (*(void (**)(re::TcpProtocolLayer *, uint64_t, uint64_t))(*(_QWORD *)this + 56))(this, v8, 1);
      if (v8)

      if (*((_DWORD *)this + 28) <= (v3 + 1))
        v13 = v3 + 1;
      else
        v13 = *((_DWORD *)this + 28);
      while (1)
      {
        v6 = (v3 + 1);
        if (v13 - 1 == (_DWORD)v3)
          break;
        LODWORD(v3) = v3 + 1;
        v14 = v6;
        if ((*(_DWORD *)(*((_QWORD *)this + 12) + 24 * v6 + 8) & 0x80000000) != 0)
          goto LABEL_23;
      }
      v14 = v13;
LABEL_23:
      LODWORD(v3) = v14;
    }
    while ((_DWORD)v2 != v14);
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)v30);
  v15 = *((unsigned int *)this + 16);
  if ((_DWORD)v15)
  {
    v16 = 0;
    v17 = (int *)(*((_QWORD *)this + 6) + 8);
    while (1)
    {
      v18 = *v17;
      v17 += 6;
      if (v18 < 0)
        break;
      if (v15 == ++v16)
      {
        LODWORD(v16) = *((_DWORD *)this + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if ((_DWORD)v15 != (_DWORD)v16)
  {
    v19 = v16;
    do
    {
      v20 = *(_QWORD *)(*((_QWORD *)this + 6) + 24 * v19 + 16);
      if (v20)
      {
        v21 = (id)(v20 + 8);
        v22 = (id)(v20 + 8);
      }
      v23 = *((_QWORD *)this + 23);
      if (v23)
        (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, uint64_t))(*(_QWORD *)v23 + 8))(v23, this, v20, v20 + 1776);
      v24 = (re *)close(*(_DWORD *)(v20 + 1772));
      v25 = *re::networkLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v32 = "deinit";
        v33 = 1024;
        v34 = 242;
        v35 = 2048;
        v36 = v20;
        _os_log_impl(&dword_21C69B000, v25, OS_LOG_TYPE_DEFAULT, "%s:%u queueing close on handle %p", buf, 0x1Cu);
      }
      (*(void (**)(re::TcpProtocolLayer *, uint64_t, uint64_t))(*(_QWORD *)this + 56))(this, v20, 1);
      v26 = (void *)(v20 + 8);

      if (*((_DWORD *)this + 16) <= (v16 + 1))
        v27 = v16 + 1;
      else
        v27 = *((_DWORD *)this + 16);
      while (1)
      {
        v19 = (v16 + 1);
        if (v27 - 1 == (_DWORD)v16)
          break;
        LODWORD(v16) = v16 + 1;
        v28 = v19;
        if ((*(_DWORD *)(*((_QWORD *)this + 6) + 24 * v19 + 8) & 0x80000000) != 0)
          goto LABEL_45;
      }
      v28 = v27;
LABEL_45:
      LODWORD(v16) = v28;
    }
    while ((_DWORD)v15 != v28);
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)this + 32);
  close(*((_DWORD *)this + 48));
  shutdown(*((_DWORD *)this + 48), 2);
  result = close(*((_DWORD *)this + 6));
  *((_DWORD *)this + 6) = -1;
  *((_WORD *)this + 90) = 0;
  *((_DWORD *)this + 48) = -1;
  return result;
}

void re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_21C701D20, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *(unsigned int *)(a1 + 32);
          }
        }
        v4 += 24;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v9;
  }
}

uint64_t re::TcpProtocolLayer::open@<X0>(re::TcpProtocolLayer *this@<X0>, const re::Address *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;
  uint32_t v7;
  NSObject *v8;
  char *v9;
  int v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  kevent64_s buf;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  result = (*(uint64_t (**)(re::TcpProtocolLayer *))(*(_QWORD *)this + 160))(this);
  v15 = result;
  if ((result & 0x80000000) != 0)
  {
    *a3 = 0;
  }
  else
  {
    v7 = result;
    v8 = *re::networkLogObjects((re *)result);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      if ((*((_QWORD *)a2 + 1) & 1) != 0)
        v9 = (char *)*((_QWORD *)a2 + 2);
      else
        v9 = (char *)a2 + 9;
      v10 = *((unsigned __int16 *)this + 90);
      LODWORD(buf.ident) = 136315650;
      *(uint64_t *)((char *)&buf.ident + 4) = (uint64_t)v9;
      LOWORD(buf.fflags) = 1024;
      *(uint32_t *)((char *)&buf.fflags + 2) = v7;
      WORD1(buf.data) = 1024;
      HIDWORD(buf.data) = v10;
      _os_log_impl(&dword_21C69B000, v8, OS_LOG_TYPE_INFO, "[ConDebug] Connecting to %s with socket %i from port %i", (uint8_t *)&buf, 0x18u);
    }
    v16 = 1;
    LODWORD(buf.ident) = v7;
    re::make::shared::object<re::TcpProtocolHandle,int &,re::TcpConnectionStatus &,re::Address const&>((re *)&v14, &buf, &v16, a2);
    v11 = v14;
    buf.ident = v14;
    if (v14)
      v12 = (id)(v14 + 8);
    re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add((uint64_t)this + 32, (uint64_t *)&buf);
    if (buf.ident)

    re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>((uint64_t)this + 80, &v15, (uint64_t *)&v14);
    buf.ident = v7;
    *(_OWORD *)&buf.filter = 0x5FFFEuLL;
    buf.udata = v11;
    buf.ext[0] = 0;
    buf.ext[1] = 0;
    result = kevent64(*((_DWORD *)this + 6), &buf, 1, 0, 0, 0, 0);
    if ((_DWORD)result == -1)
    {
      re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "open", 275);
      result = _os_crash();
      __break(1u);
    }
    else
    {
      *a3 = v11;
    }
  }
  return result;
}

uint64_t re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::addAsMove(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

void re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>(uint64_t a1, int *a2, uint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  uint64_t v19;

  v6 = *a2;
  v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  v8 = v7 ^ (v7 >> 31);
  v9 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    v9 = v8 % *(unsigned int *)(a1 + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v19 = *(_QWORD *)(a1 + 16);
      if (*(_DWORD *)(v19 + 24 * v10 + 12) == (_DWORD)v6)
        return;
      while (1)
      {
        LODWORD(v10) = *(_DWORD *)(v19 + 24 * v10 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v19 + 24 * v10 + 12) == (_DWORD)v6)
          return;
      }
    }
  }
  v11 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
    v11 = *(unsigned int *)(a1 + 32);
    v12 = v11;
    if ((_DWORD)v11 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(a1 + 24);
      v12 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
  }
  else
  {
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 24 * v11 + 8) = v14 | 0x80000000;
  v15 = v9;
  v16 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(v16 + 4 * v9);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11) = v8;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 12) = *a2;
  v17 = *a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 16) = *a3;
  if (v17)
  {
    v18 = (id)(v17 + 8);
    v16 = *(_QWORD *)(a1 + 8);
  }
  *(_DWORD *)(v16 + 4 * v15) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

void re::TcpProtocolLayer::setSocketOptions(re::TcpProtocolLayer *this)
{
  int v1;
  re *v2;
  NSObject *v3;
  re *v4;
  NSObject *v5;
  int *v6;
  char *v7;
  int *v8;
  char *v9;
  int v10;
  uint8_t buf[4];
  char *v12;
  uint64_t v13;

  v1 = (int)this;
  v13 = *MEMORY[0x24BDAC8D0];
  v10 = 1;
  v2 = (re *)setsockopt((int)this, 6, 1, &v10, 4u);
  if ((v2 & 0x80000000) != 0)
  {
    v3 = *re::networkLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v6 = __error();
      v7 = strerror(*v6);
      *(_DWORD *)buf = 136315138;
      v12 = v7;
      _os_log_error_impl(&dword_21C69B000, v3, OS_LOG_TYPE_ERROR, "Could not set TCP_NODELAY %s\n", buf, 0xCu);
    }
  }
  v10 = 1;
  v4 = (re *)setsockopt(v1, 0xFFFF, 4130, &v10, 4u);
  if ((v4 & 0x80000000) != 0)
  {
    v5 = *re::networkLogObjects(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = __error();
      v9 = strerror(*v8);
      *(_DWORD *)buf = 136315138;
      v12 = v9;
      _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "Could not set SO_NOSIGPIPE %s\n", buf, 0xCu);
    }
  }
}

uint64_t re::TcpProtocolLayer::connectToAddress(re::TcpProtocolLayer *this, const re::Address *a2)
{
  re *IPPortPair;
  const char *v4;
  re::TcpProtocolLayer *v5;
  re *v6;
  NSObject *v7;
  NSObject *v8;
  re *v10;
  re *v11;
  int v12;
  NSObject *v13;
  re *v14;
  NSObject *v15;
  uint64_t v16;
  int *v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  const char *v23;
  char *v24;
  int *v25;
  char *v26;
  int *v27;
  char *v28;
  char *v29;
  const char *v30;
  int *v31;
  char *v32;
  addrinfo *v33;
  _BYTE buf[12];
  __int16 v35;
  _BYTE v36[10];
  char *v37;
  char __str[8];
  __int16 v39;
  addrinfo v40;
  _BYTE v41[8];
  _WORD v42[16];
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  IPPortPair = (re *)re::Address::getIPPortPair(a2, (uint64_t)v41);
  if (v41[0])
  {
    memset(&v40.ai_addrlen, 0, 32);
    v40.ai_flags = 0;
    *(_QWORD *)&v40.ai_family = 0x100000002;
    v40.ai_protocol = 6;
    v39 = 0;
    *(_QWORD *)__str = 0;
    snprintf(__str, 0xAuLL, "%i", v42[12]);
    v33 = 0;
    re::IP::generateString((re::IP *)v42, (re::DynamicString *)buf);
    if ((buf[8] & 1) != 0)
      v4 = *(const char **)&v36[2];
    else
      v4 = &buf[9];
    v5 = (re::TcpProtocolLayer *)getaddrinfo(v4, __str, &v40, &v33);
    v6 = *(re **)buf;
    if (*(_QWORD *)buf && (buf[8] & 1) != 0)
      v6 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
    if ((_DWORD)v5)
    {
      v7 = *re::networkLogObjects(v6);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
LABEL_10:
        freeaddrinfo(v33);
        return (uint64_t)v5;
      }
      v23 = gai_strerror((int)v5);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v23;
      v20 = "getaddrinfo failed: %s";
      v21 = v7;
      v22 = 12;
LABEL_28:
      _os_log_error_impl(&dword_21C69B000, v21, OS_LOG_TYPE_ERROR, v20, buf, v22);
      goto LABEL_10;
    }
    v10 = (re *)socket(v33->ai_family, v33->ai_socktype, v33->ai_protocol);
    v5 = v10;
    if ((v10 & 0x80000000) != 0)
    {
      v19 = *re::networkLogObjects(v10);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        goto LABEL_10;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = (_DWORD)v5;
      v20 = "Opening socket failed with %i";
      v21 = v19;
      v22 = 8;
      goto LABEL_28;
    }
    v11 = (re *)fcntl((int)v10, 3, 0);
    v12 = (int)v11;
    if ((v11 & 0x80000000) != 0)
    {
      v13 = *re::networkLogObjects(v11);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v25 = __error();
        v26 = strerror(*v25);
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v26;
        _os_log_error_impl(&dword_21C69B000, v13, OS_LOG_TYPE_ERROR, "Could not get socket flags: %s\n", buf, 0xCu);
      }
    }
    v14 = (re *)fcntl((int)v5, 4, v12 | 4u);
    if ((v14 & 0x80000000) != 0)
    {
      v15 = *re::networkLogObjects(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v27 = __error();
        v28 = strerror(*v27);
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v28;
        _os_log_error_impl(&dword_21C69B000, v15, OS_LOG_TYPE_ERROR, "Could not set socket to be non blocking: %s\n", buf, 0xCu);
      }
    }
    re::TcpProtocolLayer::setSocketOptions(v5);
    v16 = connect((int)v5, v33->ai_addr, v33->ai_addrlen);
    freeaddrinfo(v33);
    if ((v16 & 0x80000000) != 0)
    {
      v17 = __error();
      if (*v17 != 36)
      {
        v18 = *re::networkLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          if ((*((_QWORD *)a2 + 1) & 1) != 0)
            v29 = (char *)*((_QWORD *)a2 + 2);
          else
            v29 = (char *)a2 + 9;
          v30 = gai_strerror(v16);
          v31 = __error();
          v32 = strerror(*v31);
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v29;
          v35 = 2080;
          *(_QWORD *)v36 = v30;
          *(_WORD *)&v36[8] = 2080;
          v37 = v32;
          _os_log_error_impl(&dword_21C69B000, v18, OS_LOG_TYPE_ERROR, "Failed to connect to %s : %s errno = %s", buf, 0x20u);
        }
        return v16;
      }
    }
  }
  else
  {
    v8 = *re::networkLogObjects(IPPortPair);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if ((*((_QWORD *)a2 + 1) & 1) != 0)
        v24 = (char *)*((_QWORD *)a2 + 2);
      else
        v24 = (char *)a2 + 9;
      v40.ai_flags = 136315138;
      *(_QWORD *)&v40.ai_family = v24;
      _os_log_error_impl(&dword_21C69B000, v8, OS_LOG_TYPE_ERROR, "Expected ip:port address: %s", (uint8_t *)&v40, 0xCu);
    }
    return 0xFFFFFFFFLL;
  }
  return (uint64_t)v5;
}

void re::TcpProtocolLayer::close(re::PacketPool **this, re::ProtocolHandle *a2)
{
  NSObject *v4;
  re *v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  re::Packet *v9;
  NSObject *v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  char *v15;
  _BYTE v16[12];
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects((re *)this);
  v5 = (re *)os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v5)
  {
    v6 = *((unsigned __int16 *)this + 90);
    *(_DWORD *)v16 = 134218240;
    *(_QWORD *)&v16[4] = a2;
    v17 = 1024;
    v18 = v6;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "[ConDebug] Closing peer handle(%p) on port %i", v16, 0x12u);
  }
  if (a2)
    v5 = (char *)a2 + 8;
  if (*((_QWORD *)a2 + 226))
  {
    v7 = *re::networkLogObjects(v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *((_QWORD *)a2 + 226);
      *(_DWORD *)v16 = 134217984;
      *(_QWORD *)&v16[4] = v8;
      _os_log_impl(&dword_21C69B000, v7, OS_LOG_TYPE_DEFAULT, "Packet %p freed", v16, 0xCu);
    }
    re::PacketPool::free(this[25], *((re::Packet **)a2 + 226));
    *((_QWORD *)a2 + 226) = 0;
  }
  v9 = (re::Packet *)*((_QWORD *)a2 + 230);
  if (v9)
  {
    re::PacketPool::free(this[25], v9);
    *((_QWORD *)a2 + 230) = 0;
  }
  v10 = *re::networkLogObjects(v5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *((unsigned __int16 *)this + 90);
    v12 = *((_DWORD *)a2 + 443);
    *(_DWORD *)v16 = 134218496;
    *(_QWORD *)&v16[4] = a2;
    v17 = 1024;
    v18 = v11;
    v19 = 1024;
    v20 = v12;
    _os_log_impl(&dword_21C69B000, v10, OS_LOG_TYPE_DEFAULT, "Closed peer handle(%p) on port %i socket %i", v16, 0x18u);
  }
  (*((void (**)(re::PacketPool **, _QWORD))*this + 22))(this, *((unsigned int *)a2 + 443));
  v13 = (char *)a2 + 8;
  v14 = (char *)a2 + 8;
  *(_DWORD *)v16 = *((_DWORD *)a2 + 443);
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::remove((uint64_t)(this + 10), (int *)v16);
  *(_QWORD *)v16 = a2;
  v15 = (char *)a2 + 8;
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove((uint64_t)(this + 4), (uint64_t *)v16);
  if (*(_QWORD *)v16)

}

uint64_t re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::remove(uint64_t a1, int *a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = *a2;
  v4 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) >> 27));
  v5 = (v4 ^ (v4 >> 31)) % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v9 + 24 * v7 + 12) != (_DWORD)v3)
  {
    while (1)
    {
      v10 = v7;
      v11 = *(_DWORD *)(v9 + 24 * v7 + 8);
      v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      if (*(_DWORD *)(v9 + 24 * v7 + 12) == (_DWORD)v3)
      {
        *(_DWORD *)(v9 + 24 * v10 + 8) = *(_DWORD *)(v9 + 24 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  v12 = *(_QWORD *)(a1 + 16);
  v13 = v12 + 24 * v7;
  v16 = *(_DWORD *)(v13 + 8);
  v14 = (int *)(v13 + 8);
  v15 = v16;
  if (v16 < 0)
  {
    *v14 = v15 & 0x7FFFFFFF;
    v17 = v12 + 24 * v7;
    v20 = *(_QWORD *)(v17 + 16);
    v19 = (_QWORD *)(v17 + 16);
    v18 = v20;
    if (v20)
    {

      *v19 = 0;
    }
  }
  v21 = *(_QWORD *)(a1 + 16) + 24 * v7;
  v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v22 + 1;
  return 1;
}

void re::TcpProtocolLayer::disconnect(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  int *v9;
  uint64_t v10;
  kevent64_s changelist;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 1768) != 4)
  {
    *(_DWORD *)(a2 + 1768) = 3;
    if (a3)
    {
      changelist.ident = *(int *)(a2 + 1772);
      *(_DWORD *)&changelist.filter = 196607;
      memset(&changelist.fflags, 0, 36);
      if (kevent64(*(_DWORD *)(a1 + 24), &changelist, 1, 0, 0, 0, 0) == -1)
      {
        __error();
        v9 = __error();
        re::internal::assertLog((re::internal *)5, v10, "assertion failure: '%s' (%s:line %i) kevent failed %d", "!\"Unreachable code\"", "disconnect", 455, *v9);
        _os_crash();
        __break(1u);
      }
      else
      {
        close(*(_DWORD *)(a2 + 1772));
        v5 = *(_QWORD *)(a1 + 184);
        if (v5)
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 8))(v5, a1, a2, a2 + 1776);
      }
    }
    else
    {
      v6 = *re::networkLogObjects((re *)a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a2 + 1772);
        v8 = *(unsigned __int16 *)(a1 + 180);
        LODWORD(changelist.ident) = 67109632;
        HIDWORD(changelist.ident) = v7;
        changelist.filter = 2048;
        *(_QWORD *)&changelist.flags = a2;
        WORD1(changelist.data) = 1024;
        HIDWORD(changelist.data) = v8;
        _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "[ConDebug] disconnecting peer(%i) handle(%p) on port %i", (uint8_t *)&changelist, 0x18u);
      }
    }
  }
}

void re::TcpProtocolLayer::getAddressFromSocket(re::TcpProtocolLayer *this@<X0>, int *a2@<X2>, int a3@<W1>, re::DynamicString *a4@<X8>)
{
  re *v8;
  NSObject *v9;
  const char *v10;
  int *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  socklen_t v17;
  sockaddr v18;
  uint8_t buf[4];
  const char *v20;
  _DWORD v21[3];
  __int16 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  *((_QWORD *)a4 + 3) = 0;
  re::DynamicString::setCapacity(a4, 0);
  v17 = 128;
  v8 = (re *)getpeername(a3, &v18, &v17);
  *a2 = (int)v8;
  if ((v8 & 0x80000000) != 0)
  {
    v9 = *re::networkLogObjects(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = gai_strerror(*a2);
      v11 = __error();
      v12 = strerror(*v11);
      *(_DWORD *)buf = 136315394;
      v20 = v10;
      LOWORD(v21[0]) = 2080;
      *(_QWORD *)((char *)v21 + 2) = v12;
      _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "getpeername failed: %s errno = %s", buf, 0x16u);
    }
  }
  else if (v18.sa_family == 2)
  {
    memset(v21, 0, sizeof(v21));
    buf[0] = 0;
    HIDWORD(v20) = *(_DWORD *)&v18.sa_data[2];
    v22 = bswap32(*(unsigned __int16 *)v18.sa_data) >> 16;
    re::Address::makeFromIPAndPort((unsigned __int16 *)buf, (re::DynamicString *)&v15);
    re::DynamicString::operator=(a4, (re::DynamicString *)&v15);
    if (v15)
    {
      if ((v16 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    }
  }
  else
  {
    v13 = re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet((uint64_t)this + 80, a3);
    if (v13)
    {
      re::DynamicString::operator=(a4, (re::DynamicString *)(*(_QWORD *)v13 + 1776));
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) IPv6 not supported yet", "!\"Unreachable code\"", "getAddressFromSocket", 486);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(uint64_t a1, int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v5 + 24 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 24 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_DWORD *)(v5 + 24 * v3 + 12) == a2)
        return v5 + 24 * v3 + 16;
    }
    return 0;
  }
  return v5 + 24 * v3 + 16;
}

void re::TcpProtocolLayer::sendPacketParts(uint64_t a1, uint64_t a2)
{
  int v4;
  unint64_t v5;
  ssize_t v6;
  ssize_t v7;
  int *v8;
  NSObject *v9;
  int *v10;
  int *v11;
  char *v12;
  _DWORD v13[2];
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)(a1 + 1772);
  v5 = *(_QWORD *)(a1 + 1824);
  if (v5 > 7)
  {
LABEL_4:
    v7 = send(v4, (const void *)(*(_QWORD *)(a2 + 16) + v5 - 8), *(unsigned int *)(a2 + 24) - (v5 - 8), 0);
    if ((v7 & 0x8000000000000000) == 0)
    {
      *(_QWORD *)(a1 + 1824) += v7;
      return;
    }
    v8 = __error();
    if (*v8 != 35)
    {
      v9 = *re::networkLogObjects((re *)v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        goto LABEL_12;
    }
    return;
  }
  v6 = send(*(_DWORD *)(a1 + 1772), (const void *)(a1 + 5 * v5 + 1816), 8uLL, 0);
  if ((v6 & 0x8000000000000000) == 0)
  {
    v5 = *(_QWORD *)(a1 + 1824) + v6;
    *(_QWORD *)(a1 + 1824) = v5;
    if (v5 < 8)
      return;
    goto LABEL_4;
  }
  v10 = __error();
  if (*v10 != 35)
  {
    v9 = *re::networkLogObjects((re *)v10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      v11 = __error();
      v12 = strerror(*v11);
      v13[0] = 67109378;
      v13[1] = v4;
      v14 = 2080;
      v15 = v12;
      _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "send to %i failed: errno = %s", (uint8_t *)v13, 0x12u);
    }
  }
}

uint64_t re::TcpProtocolLayer::connectionAdded(re::TcpProtocolLayer *this, re::TcpProtocolLayer *a2)
{
  re *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  re *v8;
  uint64_t ident;
  NSObject *v10;
  uint32_t v11;
  _BYTE *v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  id v16;
  id v17;
  uint64_t v18;
  re *v19;
  NSObject *v20;
  uint32_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t result;
  int *v25;
  char *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _BYTE v31[7];
  _BYTE *v32;
  int v33;
  int v34;
  int v35;
  kevent64_s buf;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v33 = 0;
  v34 = (int)a2;
  v4 = (re *)(*(_QWORD *(**)(uint64_t *__return_ptr))(*(_QWORD *)this + 168))(&v29);
  if (v33 < 0)
  {
    v13 = *re::networkLogObjects(v4);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v25 = __error();
      v26 = strerror(*v25);
      v27 = gai_strerror(v33);
      LODWORD(buf.ident) = 67109634;
      HIDWORD(buf.ident) = (_DWORD)a2;
      buf.filter = 2080;
      *(_QWORD *)&buf.flags = v26;
      WORD1(buf.data) = 2080;
      *(int64_t *)((char *)&buf.data + 4) = (int64_t)v27;
      _os_log_error_impl(&dword_21C69B000, v13, OS_LOG_TYPE_ERROR, "getpeername to %i failed: errno = %s, error = %s", (uint8_t *)&buf, 0x1Cu);
    }
    re::TcpProtocolLayer::connectionError(this, (int)a2);
    goto LABEL_35;
  }
  re::TcpProtocolLayer::setSocketOptions(a2);
  re::TcpProtocolLayer::setupKeepAlive(this, (int)a2);
  if (*((_QWORD *)this + 10))
  {
    v5 = (int)a2;
    v6 = 0xBF58476D1CE4E5B9 * ((int)a2 ^ ((unint64_t)(int)a2 >> 30));
    v7 = *(unsigned int *)(*((_QWORD *)this + 11)
                         + 4
                         * (((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31))
                          % *((unsigned int *)this + 26)));
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v14 = *((_QWORD *)this + 12);
      v15 = *(_DWORD *)(v14 + 24 * v7 + 12);
      if (v15 == (_DWORD)a2)
      {
LABEL_14:
        ident = *(_QWORD *)(v14 + 24 * v7 + 16);
        if (ident)
        {
          v16 = (id)(ident + 8);
          buf.ident = ident;
          v17 = (id)(ident + 8);
        }
        else
        {
          buf.ident = 0;
        }
        v28 = ident;
        v19 = (re *)re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove((uint64_t)this + 32, (uint64_t *)&buf);
        if (buf.ident)

        *(_DWORD *)(ident + 1768) = 2;
        v20 = *re::networkLogObjects(v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          v21 = *((unsigned __int16 *)this + 90);
          if ((v30 & 1) != 0)
            v22 = v32;
          else
            v22 = v31;
          LODWORD(buf.ident) = 134218754;
          *(uint64_t *)((char *)&buf.ident + 4) = ident;
          LOWORD(buf.fflags) = 1024;
          *(uint32_t *)((char *)&buf.fflags + 2) = v21;
          WORD1(buf.data) = 1024;
          HIDWORD(buf.data) = (_DWORD)a2;
          LOWORD(buf.udata) = 2080;
          *(uint64_t *)((char *)&buf.udata + 2) = (uint64_t)v22;
          _os_log_impl(&dword_21C69B000, v20, OS_LOG_TYPE_INFO, "[ConDebug] %p Outgoing connection complete on port(%i) socket(%i) from %s", (uint8_t *)&buf, 0x22u);
        }
        (***((void (****)(_QWORD, re::TcpProtocolLayer *, uint64_t, uint64_t *))this + 23))(*((_QWORD *)this + 23), this, ident, &v29);
        goto LABEL_32;
      }
      v18 = v7;
      while (1)
      {
        LODWORD(v18) = *(_DWORD *)(v14 + 24 * v18 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v18 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v14 + 24 * v18 + 12) == (_DWORD)a2)
        {
          if (v15 != (_DWORD)a2)
          {
            while (1)
            {
              LODWORD(v7) = *(_DWORD *)(v14 + 24 * v7 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v7 == 0x7FFFFFFF)
                break;
              if (*(_DWORD *)(v14 + 24 * v7 + 12) == (_DWORD)a2)
                goto LABEL_14;
            }
            LODWORD(v7) = 0x7FFFFFFF;
          }
          goto LABEL_14;
        }
      }
    }
  }
  LODWORD(v28) = (_DWORD)a2;
  v35 = 2;
  v8 = re::make::shared::object<re::TcpProtocolHandle,int &,re::TcpConnectionStatus &,re::Address const&>((re *)&buf, &v28, &v35, (const re::DynamicString *)&v29);
  ident = buf.ident;
  v28 = buf.ident;
  v10 = *re::networkLogObjects(v8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    v11 = *((unsigned __int16 *)this + 90);
    if ((v30 & 1) != 0)
      v12 = v32;
    else
      v12 = v31;
    LODWORD(buf.ident) = 134218754;
    *(uint64_t *)((char *)&buf.ident + 4) = ident;
    LOWORD(buf.fflags) = 1024;
    *(uint32_t *)((char *)&buf.fflags + 2) = v11;
    WORD1(buf.data) = 1024;
    HIDWORD(buf.data) = (_DWORD)a2;
    LOWORD(buf.udata) = 2080;
    *(uint64_t *)((char *)&buf.udata + 2) = (uint64_t)v12;
    _os_log_impl(&dword_21C69B000, v10, OS_LOG_TYPE_INFO, "[ConDebug] %p Incoming connection complete  on port(%i) socket(%i) from %s", (uint8_t *)&buf, 0x22u);
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>((uint64_t)this + 80, &v34, (uint64_t *)&v28);
  (***((void (****)(_QWORD, re::TcpProtocolLayer *, uint64_t, uint64_t *))this + 23))(*((_QWORD *)this + 23), this, ident, &v29);
  v5 = (int)a2;
LABEL_32:
  buf.ident = v5;
  *(_OWORD *)&buf.filter = 0x5FFFFuLL;
  buf.udata = ident;
  buf.ext[0] = 0;
  buf.ext[1] = 0;
  if (kevent64(*((_DWORD *)this + 6), &buf, 1, 0, 0, 0, 0) == -1)
  {
    re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "connectionAdded", 569);
    result = _os_crash();
    __break(1u);
    return result;
  }
  if (ident)

LABEL_35:
  result = v29;
  if (v29)
  {
    if ((v30 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v29 + 40))();
  }
  return result;
}

uint64_t re::TcpProtocolLayer::connectionError(re::TcpProtocolLayer *this, int a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v4 = re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet((uint64_t)this + 80, a2);
  if (v4)
  {
    v5 = (_QWORD *)v4;
    v6 = *((_QWORD *)this + 23);
    if (v6)
      (*(void (**)(uint64_t, re::TcpProtocolLayer *, _QWORD, uint64_t))(*(_QWORD *)v6 + 16))(v6, this, *v5, 2);
    *(_DWORD *)(*v5 + 1768) = 5;
  }
  return shutdown(a2, 2);
}

void re::TcpProtocolLayer::setupKeepAlive(re::TcpProtocolLayer *this, int a2)
{
  re *v4;
  NSObject *v5;
  re *v6;
  NSObject *v7;
  re *v8;
  NSObject *v9;
  re *v10;
  NSObject *v11;
  int *v12;
  char *v13;
  const char *v14;
  re *v15;
  int *v16;
  char *v17;
  int *v18;
  char *v19;
  int *v20;
  char *v21;
  int *v22;
  char *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint8_t buf[4];
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 44))
  {
    v27 = 1;
    v4 = (re *)setsockopt(a2, 0xFFFF, 8, &v27, 4u);
    if ((v4 & 0x80000000) != 0)
    {
      v5 = *re::networkLogObjects(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v16 = __error();
        v17 = strerror(*v16);
        *(_DWORD *)buf = 136315138;
        v29 = v17;
        _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "Could not set SO_KEEPALIVE %s\n", buf, 0xCu);
      }
    }
    v26 = *((_DWORD *)this + 44);
    v6 = (re *)setsockopt(a2, 6, 16, &v26, 4u);
    if ((v6 & 0x80000000) != 0)
    {
      v7 = *re::networkLogObjects(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v18 = __error();
        v19 = strerror(*v18);
        *(_DWORD *)buf = 136315138;
        v29 = v19;
        _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "Could not set TCP_KEEPALIVE %s\n", buf, 0xCu);
      }
    }
    v25 = 5;
    v8 = (re *)setsockopt(a2, 6, 257, &v25, 4u);
    if ((v8 & 0x80000000) != 0)
    {
      v9 = *re::networkLogObjects(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v20 = __error();
        v21 = strerror(*v20);
        *(_DWORD *)buf = 136315138;
        v29 = v21;
        _os_log_error_impl(&dword_21C69B000, v9, OS_LOG_TYPE_ERROR, "Could not set TCP_KEEPINTVL %s\n", buf, 0xCu);
      }
    }
    v24 = 4;
    v10 = (re *)setsockopt(a2, 6, 258, &v24, 4u);
    if ((v10 & 0x80000000) != 0)
    {
      v11 = *re::networkLogObjects(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v12 = __error();
        v13 = strerror(*v12);
        *(_DWORD *)buf = 136315138;
        v29 = v13;
        v14 = "Could not set TCP_KEEPCNT %s\n";
LABEL_18:
        _os_log_error_impl(&dword_21C69B000, v11, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
      }
    }
  }
  else
  {
    v27 = 0;
    v15 = (re *)setsockopt(a2, 0xFFFF, 8, &v27, 4u);
    if ((v15 & 0x80000000) != 0)
    {
      v11 = *re::networkLogObjects(v15);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v22 = __error();
        v23 = strerror(*v22);
        *(_DWORD *)buf = 136315138;
        v29 = v23;
        v14 = "Could not set SO_KEEPALIVE %s\n";
        goto LABEL_18;
      }
    }
  }
}

void re::TcpProtocolLayer::update(re::TcpProtocolLayer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  kevent64_s *v5;
  re::TcpProtocolLayer *ident;
  uint64_t udata;
  int filter;
  re::TcpProtocolLayer *v9;
  re::TcpProtocolLayer *v10;
  re *v11;
  NSObject *v12;
  _BYTE *v13;
  int v14;
  unsigned __int8 *v15;
  unint64_t v16;
  int v17;
  int v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  re *v25;
  NSObject *v26;
  int *v27;
  char *v28;
  const char *v29;
  uint64_t v30;
  NSObject *v31;
  int *v32;
  char *v33;
  NSObject *v34;
  const char *v35;
  uint32_t v36;
  int v37;
  NSObject *v38;
  NSObject *v39;
  kevent64_s *v40;
  int *p_fflags;
  uint32_t fflags;
  NSObject *v43;
  _BOOL8 v44;
  uint64_t v45;
  int v46;
  int v47;
  char *v48;
  int *v49;
  char *v50;
  NSObject *v51;
  const char *v52;
  uint32_t v53;
  int v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  NSObject *v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  re *v68;
  NSObject *v69;
  uint64_t v70;
  id v71;
  re *v72;
  int v73;
  NSObject *v74;
  int v75;
  char *data;
  int *v77;
  char *v78;
  const char *v79;
  int *v80;
  char *v81;
  char *v82;
  int *v83;
  char *v84;
  int *v85;
  char *v86;
  const char *v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  id v94;
  unsigned int *v95;
  uint64_t v96;
  unint64_t *v97;
  int v98;
  uint64_t v99;
  int v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105[2];
  char v106;
  _BYTE v107[27];
  socklen_t v108;
  timespec timeout;
  _BYTE v110[16];
  kevent64_s changelist;
  kevent64_s eventlist[32];
  uint8_t buf[4];
  _BYTE v114[24];
  uint64_t v115;

  v115 = *MEMORY[0x24BDAC8D0];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v110, 6022, (uint64_t)this);
  timeout.tv_sec = 0;
  timeout.tv_nsec = 0;
  v2 = kevent64(*((_DWORD *)this + 6), 0, 0, eventlist, 32, 0, &timeout);
  if ((int)v2 >= 1)
  {
    v4 = 0;
    v103 = v2;
    do
    {
      v5 = &eventlist[v4];
      ident = (re::TcpProtocolLayer *)v5->ident;
      udata = v5->udata;
      if (udata)
        v2 = (uint64_t)(id)(udata + 8);
      filter = (unsigned __int16)eventlist[v4].filter;
      if (filter == 65526)
      {
        changelist.ident = (int)ident;
        *(_DWORD *)&changelist.filter = 2686966;
        memset(&changelist.fflags, 0, 36);
        v2 = kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0);
        if ((_DWORD)v2 == -1)
        {
          re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "update", 589);
          _os_crash();
          __break(1u);
LABEL_139:
          re::internal::assertLog((re::internal *)4, v102, "assertion failure: '%s' (%s:line %i) Accept", "!\"Unreachable code\"", "update", 597);
          _os_crash();
          __break(1u);
LABEL_140:
          re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Unknown event", "!\"Unreachable code\"", "update", 639);
          _os_crash();
          __break(1u);
LABEL_141:
          re::internal::assertLog((re::internal *)4, v56, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "update", 666);
          _os_crash();
          __break(1u);
LABEL_142:
          re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "update", 631);
          _os_crash();
          __break(1u);
LABEL_143:
          re::internal::assertLog((re::internal *)4, v45, "assertion failure: '%s' (%s:line %i) Invalid Connection status", "!\"Unreachable code\"", "update", 679);
          _os_crash();
          __break(1u);
        }
      }
      else
      {
        if (*((_DWORD *)this + 48) == (_DWORD)ident)
        {
          v108 = 128;
          v9 = (re::TcpProtocolLayer *)accept((int)ident, (sockaddr *)&changelist, &v108);
          if ((_DWORD)v9 == -1)
            goto LABEL_139;
          v10 = v9;
          *(_DWORD *)&v114[16] = 0;
          *(_QWORD *)&v114[8] = 0;
          buf[0] = 0;
          *(_DWORD *)&v114[4] = HIDWORD(changelist.ident);
          *(_WORD *)&v114[20] = bswap32(WORD1(changelist.ident)) >> 16;
          v11 = (re *)re::Address::makeFromIPAndPort((unsigned __int16 *)buf, (re::DynamicString *)v105);
          v12 = *re::networkLogObjects(v11);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
          {
            v13 = v107;
            if ((v106 & 1) != 0)
              v13 = *(_BYTE **)&v107[7];
            v14 = *((unsigned __int16 *)this + 90);
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)v114 = v13;
            *(_WORD *)&v114[8] = 1024;
            *(_DWORD *)&v114[10] = v14;
            *(_WORD *)&v114[14] = 1024;
            *(_DWORD *)&v114[16] = (_DWORD)v10;
            _os_log_impl(&dword_21C69B000, v12, OS_LOG_TYPE_INFO, "[ConDebug] Accepting connection(%s) on port(%i) socket(%i)", buf, 0x18u);
          }
          re::TcpProtocolLayer::connectionAdded(this, v10);
          v2 = *(_QWORD *)v105;
          if (*(_QWORD *)v105 && (v106 & 1) != 0)
            v2 = (*(uint64_t (**)(void))(**(_QWORD **)v105 + 40))();
        }
        else if (filter == 65534)
        {
          if (*(_DWORD *)(udata + 1768) == 1)
          {
            v105[0] = 0;
            v108 = 4;
            v25 = (re *)getsockopt((int)ident, 0xFFFF, 4103, v105, &v108);
            if ((v25 & 0x80000000) != 0)
            {
              v37 = (int)v25;
              v38 = *re::networkLogObjects(v25);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                v77 = __error();
                v78 = strerror(*v77);
                v79 = gai_strerror(v37);
                LODWORD(changelist.ident) = 67109634;
                HIDWORD(changelist.ident) = (_DWORD)ident;
                changelist.filter = 2080;
                *(_QWORD *)&changelist.flags = v78;
                WORD1(changelist.data) = 2080;
                *(int64_t *)((char *)&changelist.data + 4) = (int64_t)v79;
                _os_log_error_impl(&dword_21C69B000, v38, OS_LOG_TYPE_ERROR, "getsockopt to %i failed: errno = %s error =%s", (uint8_t *)&changelist, 0x1Cu);
              }
              re::TcpProtocolLayer::connectionError(this, (int)ident);
            }
            else if (v105[0])
            {
              v26 = *re::networkLogObjects(v25);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                v27 = __error();
                v28 = strerror(*v27);
                v29 = gai_strerror(v105[0]);
                LODWORD(changelist.ident) = 67109634;
                HIDWORD(changelist.ident) = (_DWORD)ident;
                changelist.filter = 2080;
                *(_QWORD *)&changelist.flags = v28;
                WORD1(changelist.data) = 2080;
                *(int64_t *)((char *)&changelist.data + 4) = (int64_t)v29;
                _os_log_error_impl(&dword_21C69B000, v26, OS_LOG_TYPE_ERROR, "getsockopt to %i failed: errno = %s error =%s", (uint8_t *)&changelist, 0x1Cu);
              }
            }
            else
            {
              v72 = (re *)(*(_QWORD *(**)(kevent64_s *__return_ptr, re::TcpProtocolLayer *, re::TcpProtocolLayer *, int *))(*(_QWORD *)this + 168))(&changelist, this, ident, v105);
              v73 = v105[0];
              v74 = *re::networkLogObjects(v72);
              if (v73 < 0)
              {
                if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                {
                  v85 = __error();
                  v86 = strerror(*v85);
                  v87 = gai_strerror(v105[0]);
                  *(_DWORD *)buf = 67109634;
                  *(_DWORD *)v114 = (_DWORD)ident;
                  *(_WORD *)&v114[4] = 2080;
                  *(_QWORD *)&v114[6] = v86;
                  *(_WORD *)&v114[14] = 2080;
                  *(_QWORD *)&v114[16] = v87;
                  _os_log_error_impl(&dword_21C69B000, v74, OS_LOG_TYPE_ERROR, "getAddressFromSocket to %i failed: errno = %s, error = %s", buf, 0x1Cu);
                }
                re::TcpProtocolLayer::connectionError(this, (int)ident);
              }
              else
              {
                if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
                {
                  v75 = *((unsigned __int16 *)this + 90);
                  data = (char *)&changelist.filter + 1;
                  if ((changelist.filter & 1) != 0)
                    data = (char *)changelist.data;
                  *(_DWORD *)buf = 67109634;
                  *(_DWORD *)v114 = v75;
                  *(_WORD *)&v114[4] = 1024;
                  *(_DWORD *)&v114[6] = (_DWORD)ident;
                  *(_WORD *)&v114[10] = 2080;
                  *(_QWORD *)&v114[12] = data;
                  _os_log_impl(&dword_21C69B000, v74, OS_LOG_TYPE_INFO, "[ConDebug] Server accepted connection on port(%i) socket(%i) from %s", buf, 0x18u);
                }
                re::TcpProtocolLayer::connectionAdded(this, ident);
              }
              if (changelist.ident && (changelist.filter & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)changelist.ident + 40))();
            }
            changelist.ident = (int)ident;
            *(_DWORD *)&changelist.filter = 720894;
            memset(&changelist.fflags, 0, 36);
            v2 = kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0);
            if ((_DWORD)v2 == -1)
              goto LABEL_142;
          }
        }
        else
        {
          if (filter != 0xFFFF)
            goto LABEL_140;
          v15 = (unsigned __int8 *)(udata + 1848);
          v16 = *(_QWORD *)(udata + 1856);
          while (1)
          {
            v17 = *(_DWORD *)(udata + 1772);
            if (v16 <= 7)
            {
              v2 = recv(*(_DWORD *)(udata + 1772), &v15[v16], 8 - v16, 0);
              v18 = v2;
              if (v2 < 0)
              {
                v2 = (uint64_t)__error();
                if (*(_DWORD *)v2 == 35)
                  goto LABEL_50;
                v39 = *re::networkLogObjects((re *)v2);
                if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                {
                  v82 = strerror(v18);
                  v83 = __error();
                  v84 = strerror(*v83);
                  LODWORD(changelist.ident) = 67109634;
                  HIDWORD(changelist.ident) = v17;
                  changelist.filter = 2080;
                  *(_QWORD *)&changelist.flags = v82;
                  WORD1(changelist.data) = 2080;
                  *(int64_t *)((char *)&changelist.data + 4) = (int64_t)v84;
                  v34 = v39;
                  v35 = "recv %i failed: errno = %s %s";
                  v36 = 28;
LABEL_105:
                  _os_log_error_impl(&dword_21C69B000, v34, OS_LOG_TYPE_ERROR, v35, (uint8_t *)&changelist, v36);
                }
LABEL_49:
                v2 = re::TcpProtocolLayer::connectionError(this, v17);
                goto LABEL_50;
              }
              v16 = *(_QWORD *)(udata + 1856) + v2;
              *(_QWORD *)(udata + 1856) = v16;
              if (v16 < 8)
                goto LABEL_50;
            }
            if (*v15 >= 0xAu)
              break;
            v19 = *(char **)(udata + 1840);
            v20 = *(unsigned int *)(udata + 1852);
            if (!v19)
            {
              v19 = re::PacketPool::allocate(*((re::PacketPool **)this + 25), v20);
              *(_QWORD *)(udata + 1840) = v19;
              *((_DWORD *)v19 + 6) = *(_DWORD *)(udata + 1852);
              v16 = *(_QWORD *)(udata + 1856);
              LODWORD(v20) = *(_DWORD *)(udata + 1852);
            }
            v2 = recv(v17, (void *)(*((_QWORD *)v19 + 2) + v16 - 8), v20 - v16 + 8, 0);
            if (v2 < 0)
            {
              v2 = (uint64_t)__error();
              if (*(_DWORD *)v2 == 35)
                goto LABEL_50;
              v31 = *re::networkLogObjects((re *)v2);
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
              {
                v32 = __error();
                v33 = strerror(*v32);
                LODWORD(changelist.ident) = 67109378;
                HIDWORD(changelist.ident) = v17;
                changelist.filter = 2080;
                *(_QWORD *)&changelist.flags = v33;
                v34 = v31;
                v35 = "recv %i failed: errno = %s";
                v36 = 18;
                goto LABEL_105;
              }
              goto LABEL_49;
            }
            v21 = *(_QWORD *)(udata + 1856) + v2;
            *(_QWORD *)(udata + 1856) = v21;
            v3 = *(_QWORD *)(udata + 1840);
            if (*(unsigned int *)(v3 + 24) + 8 != v21)
              goto LABEL_50;
            v22 = *((_QWORD *)this + 23);
            if (v22)
            {
              (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v22 + 24))(v22, this, udata, *(unsigned __int8 *)(udata + 1848), *(_QWORD *)(v3 + 16));
              v3 = *(_QWORD *)(udata + 1840);
            }
            v23 = _MergedGlobals++;
            *(_DWORD *)(udata + 1864) = v23;
            re::PacketPool::free(*((re::PacketPool **)this + 25), (re::Packet *)v3);
            v16 = 0;
            *(_QWORD *)(udata + 1840) = 0;
            *(_BYTE *)(udata + 1848) = 10;
            *(_DWORD *)(udata + 1860) = 0;
            *(_QWORD *)(udata + 1852) = 0;
            v24 = dword_25529B144++;
            *(_DWORD *)(udata + 1864) = v24;
          }
          v30 = *((_QWORD *)this + 23);
          if (v30)
            (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, _QWORD))(*(_QWORD *)v30 + 16))(v30, this, udata, 0);
          *(_DWORD *)(udata + 1768) = 5;
          v2 = shutdown(v17, 2);
        }
LABEL_50:
        if ((__int16)eventlist[v4].flags < 0)
        {
          v40 = &eventlist[v4];
          fflags = v40->fflags;
          p_fflags = (int *)&v40->fflags;
          v43 = *re::networkLogObjects((re *)v2);
          v44 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
          if (fflags)
          {
            if (v44)
            {
              v46 = *((unsigned __int16 *)this + 90);
              v47 = *p_fflags;
              v48 = strerror(*p_fflags);
              v49 = __error();
              v50 = strerror(*v49);
              LODWORD(changelist.ident) = 67110146;
              HIDWORD(changelist.ident) = v46;
              changelist.filter = 1024;
              *(_DWORD *)&changelist.flags = (_DWORD)ident;
              HIWORD(changelist.fflags) = 1024;
              LODWORD(changelist.data) = v47;
              WORD2(changelist.data) = 2080;
              *(int64_t *)((char *)&changelist.data + 6) = (int64_t)v48;
              HIWORD(changelist.udata) = 2080;
              changelist.ext[0] = (uint64_t)v50;
              v51 = v43;
              v52 = "[ConDebug] Connection Closed on port(%i) socket(%i) reason %i:%s %s";
              v53 = 40;
              goto LABEL_60;
            }
          }
          else if (v44)
          {
            v54 = *((unsigned __int16 *)this + 90);
            LODWORD(changelist.ident) = 67109376;
            HIDWORD(changelist.ident) = v54;
            changelist.filter = 1024;
            *(_DWORD *)&changelist.flags = (_DWORD)ident;
            v51 = v43;
            v52 = "[ConDebug] Connection Closed on port(%i) socket(%i)";
            v53 = 14;
LABEL_60:
            _os_log_impl(&dword_21C69B000, v51, OS_LOG_TYPE_DEFAULT, v52, (uint8_t *)&changelist, v53);
          }
          if (!udata)
          {
            v63 = *re::networkLogObjects((re *)v44);
            v2 = os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)v2)
            {
              LODWORD(changelist.ident) = 67109120;
              HIDWORD(changelist.ident) = (_DWORD)ident;
              _os_log_impl(&dword_21C69B000, v63, OS_LOG_TYPE_DEFAULT, "Unknown connection closed %i", (uint8_t *)&changelist, 8u);
            }
            goto LABEL_53;
          }
          v55 = *(_DWORD *)(udata + 1768);
          if (v55 > 5)
            goto LABEL_97;
          if (((1 << v55) & 0x2C) == 0)
          {
            if (v55 != 1)
              goto LABEL_143;
            changelist.ident = (int)ident;
            *(_DWORD *)&changelist.filter = 720894;
            memset(&changelist.fflags, 0, 36);
            v68 = (re *)kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0);
            if ((_DWORD)v68 == -1)
            {
              v69 = *re::networkLogObjects(v68);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
              {
                v80 = __error();
                v81 = strerror(*v80);
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)v114 = v81;
                _os_log_error_impl(&dword_21C69B000, v69, OS_LOG_TYPE_ERROR, "kevent failed: %s", buf, 0xCu);
              }
            }
            re::TcpProtocolLayer::connectionError(this, (int)ident);
            goto LABEL_97;
          }
          changelist.ident = (int)ident;
          *(_DWORD *)&changelist.filter = 196607;
          memset(&changelist.fflags, 0, 36);
          if (kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0) == -1)
            goto LABEL_141;
          v57 = *((_QWORD *)this + 23);
          v58 = *((_QWORD *)this + 10);
          if (v57)
          {
            if (v58)
            {
              v59 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * ((int)ident ^ ((unint64_t)(int)ident >> 30))) ^ ((0xBF58476D1CE4E5B9 * ((int)ident ^ ((unint64_t)(int)ident >> 30))) >> 27));
              v60 = (v59 ^ (v59 >> 31)) % *((unsigned int *)this + 26);
              v61 = *((_QWORD *)this + 12);
              v62 = *(unsigned int *)(*((_QWORD *)this + 11) + 4 * v60);
              if ((_DWORD)v62 != 0x7FFFFFFF)
              {
                while (*(_DWORD *)(v61 + 24 * v62 + 12) != (_DWORD)ident)
                {
                  v62 = *(_DWORD *)(v61 + 24 * v62 + 8) & 0x7FFFFFFF;
                  if (v62 == 0x7FFFFFFF)
                    goto LABEL_84;
                }
LABEL_85:
                v70 = *(_QWORD *)(v61 + 24 * v62 + 16);
                if (v70)
                {
                  v71 = (id)(v70 + 8);
                  (*(void (**)(_QWORD, re::TcpProtocolLayer *, uint64_t, uint64_t))(**((_QWORD **)this + 23)
                                                                                           + 8))(*((_QWORD *)this + 23), this, v70, v70 + 1776);
                  *(_DWORD *)(udata + 1768) = 3;

                }
                else
                {
                  (*(void (**)(uint64_t, re::TcpProtocolLayer *, _QWORD, uint64_t))(*(_QWORD *)v57 + 8))(v57, this, 0, 1776);
                }
LABEL_97:
                *(_DWORD *)(udata + 1768) = 4;
LABEL_52:

                goto LABEL_53;
              }
            }
            else
            {
              v61 = *((_QWORD *)this + 12);
            }
LABEL_84:
            LODWORD(v62) = 0x7FFFFFFF;
            goto LABEL_85;
          }
          if (v58)
          {
            v64 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * ((int)ident ^ ((unint64_t)(int)ident >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                                  * ((int)ident ^ ((unint64_t)(int)ident >> 30))) >> 27));
            v65 = (v64 ^ (v64 >> 31)) % *((unsigned int *)this + 26);
            v66 = *((_QWORD *)this + 12);
            v67 = *(unsigned int *)(*((_QWORD *)this + 11) + 4 * v65);
            if ((_DWORD)v67 != 0x7FFFFFFF)
            {
              while (*(_DWORD *)(v66 + 24 * v67 + 12) != (_DWORD)ident)
              {
                v67 = *(_DWORD *)(v66 + 24 * v67 + 8) & 0x7FFFFFFF;
                if (v67 == 0x7FFFFFFF)
                  goto LABEL_95;
              }
              goto LABEL_96;
            }
          }
          else
          {
            v66 = *((_QWORD *)this + 12);
          }
LABEL_95:
          LODWORD(v67) = 0x7FFFFFFF;
LABEL_96:
          (*(void (**)(re::TcpProtocolLayer *, _QWORD, _QWORD))(*(_QWORD *)this + 56))(this, *(_QWORD *)(v66 + 24 * v67 + 16), 0);
          goto LABEL_97;
        }
      }
      if (udata)
        goto LABEL_52;
LABEL_53:
      ++v4;
    }
    while (v4 != v103);
  }
  v88 = *((unsigned int *)this + 28);
  if ((_DWORD)v88)
  {
    v89 = 0;
    v90 = (int *)(*((_QWORD *)this + 12) + 8);
    while (1)
    {
      v91 = *v90;
      v90 += 6;
      if (v91 < 0)
        break;
      if (v88 == ++v89)
      {
        LODWORD(v89) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  else
  {
    LODWORD(v89) = 0;
  }
  if ((_DWORD)v88 != (_DWORD)v89)
  {
    v92 = v89;
    v104 = *((_DWORD *)this + 28);
    while (1)
    {
      v93 = *(_QWORD *)(*((_QWORD *)this + 12) + 24 * v92 + 16);
      if (v93)
        v94 = (id)(v93 + 8);
      v95 = *(unsigned int **)(v93 + 1808);
      if (!v95)
        goto LABEL_119;
      re::TcpProtocolLayer::sendPacketParts(v93, *(_QWORD *)(v93 + 1808));
      if (v95[6] + 8 == *(_QWORD *)(v93 + 1824))
        break;
LABEL_130:

      if (*((_DWORD *)this + 28) <= (v89 + 1))
        v100 = v89 + 1;
      else
        v100 = *((_DWORD *)this + 28);
      while (1)
      {
        v92 = (v89 + 1);
        if (v100 - 1 == (_DWORD)v89)
          break;
        LODWORD(v89) = v89 + 1;
        v101 = v92;
        if ((*(_DWORD *)(*((_QWORD *)this + 12) + 24 * v92 + 8) & 0x80000000) != 0)
          goto LABEL_137;
      }
      v101 = v100;
LABEL_137:
      LODWORD(v89) = v101;
      if ((_DWORD)v88 == v101)
        goto LABEL_138;
    }
    *(_QWORD *)(v93 + 1808) = 0;
    *(_BYTE *)(v93 + 1816) = 10;
    *(_QWORD *)(v93 + 1828) = 0;
    *(_QWORD *)(v93 + 1820) = 0;
    re::PacketPool::free(*((re::PacketPool **)this + 25), (re::Packet *)v95);
LABEL_119:
    v96 = 0;
    while (1)
    {
      v97 = re::PacketQueue::dequeue((unint64_t **)(v93 + 40 * v96 + 912));
      if (v97)
        break;
LABEL_124:
      if (++v96 == 10)
      {
        LODWORD(v88) = v104;
        if (!*(_QWORD *)(v93 + 1808) && *(_DWORD *)(v93 + 1768) == 3)
        {
          close(*(_DWORD *)(v93 + 1772));
          v99 = *((_QWORD *)this + 23);
          if (v99)
            (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, uint64_t))(*(_QWORD *)v99 + 8))(v99, this, v93, v93 + 1776);
        }
        goto LABEL_130;
      }
    }
    v88 = (uint64_t)v97;
    while (1)
    {
      *(_BYTE *)(v93 + 1816) = v96;
      *(_DWORD *)(v93 + 1820) = *(_DWORD *)(v88 + 24);
      v98 = re::TcpProtocolLayer::update(void)::debug--;
      *(_DWORD *)(v93 + 1832) = v98;
      re::TcpProtocolLayer::sendPacketParts(v93, v88);
      if (*(unsigned int *)(v88 + 24) + 8 != *(_QWORD *)(v93 + 1824))
        break;
      *(_BYTE *)(v93 + 1816) = 10;
      *(_QWORD *)(v93 + 1820) = 0;
      *(_QWORD *)(v93 + 1828) = 0;
      re::PacketPool::free(*((re::PacketPool **)this + 25), (re::Packet *)v88);
      v88 = (uint64_t)re::PacketQueue::dequeue((unint64_t **)(v93 + 40 * v96 + 912));
      if (!v88)
        goto LABEL_124;
    }
    *(_QWORD *)(v93 + 1808) = v88;
    LODWORD(v88) = v104;
    goto LABEL_130;
  }
LABEL_138:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v110);
}

void re::TcpProtocolLayer::wait(re::TcpProtocolLayer *this)
{
  re *v1;
  NSObject *v2;
  int *v3;
  char *v4;
  kevent64_s v5;
  uint8_t buf[4];
  char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v1 = (re *)kevent64(*((_DWORD *)this + 6), 0, 0, &v5, 1, 0, 0);
  if ((_DWORD)v1 == -1)
  {
    v2 = *re::networkLogObjects(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = __error();
      v4 = strerror(*v3);
      *(_DWORD *)buf = 136315138;
      v7 = v4;
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "kevent failed %s", buf, 0xCu);
    }
  }
}

void re::TcpProtocolLayer::wakeup(re::TcpProtocolLayer *this)
{
  re *v1;
  NSObject *v2;
  int *v3;
  char *v4;
  kevent64_s v5;
  uint8_t buf[4];
  char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v5.ident = 0;
  *(_QWORD *)&v5.filter = 0x10000000004FFF6;
  memset(&v5.data, 0, 32);
  v1 = (re *)kevent64(*((_DWORD *)this + 6), &v5, 1, 0, 0, 0, 0);
  if ((_DWORD)v1 == -1)
  {
    v2 = *re::networkLogObjects(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = __error();
      v4 = strerror(*v3);
      *(_DWORD *)buf = 136315138;
      v7 = v4;
      _os_log_error_impl(&dword_21C69B000, v2, OS_LOG_TYPE_ERROR, "kevent failed %s", buf, 0xCu);
    }
  }
}

uint64_t re::TcpProtocolLayer::setListener(uint64_t this, ProtocolLayerListener *a2)
{
  *(_QWORD *)(this + 184) = a2;
  return this;
}

unint64_t re::TcpProtocolLayer::localAddresses(re::TcpProtocolLayer *this, re::Address *a2, unint64_t a3)
{
  re::IP *v6;
  unint64_t v7;
  re *v8;
  sockaddr *ifa_addr;
  ifaddrs *v10;
  unsigned int ifa_flags;
  int v12;
  int v13;
  re::Address *v14;
  NSObject *v15;
  int v16;
  ifaddrs *v17;
  NSObject *v18;
  int v19;
  char v21[16];
  uint64_t v22;
  __int16 v23;
  uint8_t buf[8];
  __int128 v25;
  uint64_t v26;
  ifaddrs *v27[2];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if ((*((_QWORD *)this + 18) & 1) != 0)
    v6 = (re::IP *)*((_QWORD *)this + 19);
  else
    v6 = (re::TcpProtocolLayer *)((char *)this + 145);
  if (!strcmp((const char *)v6, "0.0.0.0"))
  {
    v27[0] = 0;
    v8 = (re *)getifaddrs(v27);
    if ((v8 & 0x80000000) != 0)
    {
      v18 = *re::networkLogObjects(v8);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *__error();
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v19;
        _os_log_impl(&dword_21C69B000, v18, OS_LOG_TYPE_DEFAULT, "TcpProtocolLayer: Unable to list network adapters(errno=%d).", buf, 8u);
      }
      return 0;
    }
    else
    {
      v10 = v27[0];
      if (v27[0])
      {
        v7 = 0;
        do
        {
          ifa_addr = v10->ifa_addr;
          if (ifa_addr)
          {
            ifa_flags = v10->ifa_flags;
            if ((ifa_flags & 1) != 0 && ifa_addr->sa_family == 2)
            {
              v13 = *(_DWORD *)&ifa_addr->sa_data[2];
              ifa_addr = (sockaddr *)((char *)ifa_addr + 4);
              v12 = v13;
              if ((unsigned __int16)v13 != 65193 && ((ifa_flags & 8) == 0 || v12 == 16777343))
              {
                v14 = (re::Address *)inet_ntop(2, ifa_addr, v21, 0x11u);
                if (v14)
                {
                  if (v7 < a3)
                  {
                    re::Address::makeFromIPAndPort(v14, (const char *)*((unsigned __int16 *)this + 90), (re::DynamicString *)buf);
                    re::DynamicString::operator=((re::Address *)((char *)a2 + 32 * v7), (re::DynamicString *)buf);
                    if (*(_QWORD *)buf)
                    {
                      if ((v25 & 1) != 0)
                        (*(void (**)(void))(**(_QWORD **)buf + 40))();
                    }
                  }
                  ++v7;
                }
                else
                {
                  v15 = *re::networkLogObjects(0);
                  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                  {
                    v16 = *__error();
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)&buf[4] = v16;
                    _os_log_impl(&dword_21C69B000, v15, OS_LOG_TYPE_DEFAULT, "TcpProtocolLayer: Failed to get string representation of ip(errno=%d).", buf, 8u);
                  }
                }
              }
            }
          }
          v10 = v10->ifa_next;
        }
        while (v10);
        v17 = v27[0];
      }
      else
      {
        v17 = 0;
        v7 = 0;
      }
      MEMORY[0x220780F1C](v17, ifa_addr);
    }
  }
  else
  {
    re::IP::makeFromString(v6, (uint64_t)buf);
    *(_OWORD *)v27 = v25;
    v28 = v26;
    if (a3)
    {
      *(_OWORD *)v21 = *(_OWORD *)v27;
      v22 = v28;
      v23 = *((_WORD *)this + 90);
      re::Address::makeFromIPAndPort((unsigned __int16 *)v21, (re::DynamicString *)buf);
      re::DynamicString::operator=(a2, (re::DynamicString *)buf);
      if (*(_QWORD *)buf)
      {
        if ((v25 & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)buf + 40))();
      }
    }
    return 1;
  }
  return v7;
}

uint64_t re::TcpProtocolLayer::hostStats()
{
  return 0;
}

uint64_t re::TcpProtocolLayer::preferredPacketSize(re::TcpProtocolLayer *this)
{
  return 0x10000;
}

void re::TcpProtocolLayer::setDisconnectTimeout(re::TcpProtocolLayer *this, unsigned int a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;

  if (a2 <= 0x3E8)
    v3 = 1000;
  else
    v3 = a2;
  *((_DWORD *)this + 44) = v3 / 0x3E8;
  v4 = *((unsigned int *)this + 28);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*((_QWORD *)this + 12) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    do
    {
      re::TcpProtocolLayer::setupKeepAlive(this, *(_DWORD *)(*((_QWORD *)this + 12) + 24 * v8 + 12));
      v9 = *((_DWORD *)this + 28);
      if (v9 <= (int)v5 + 1)
        v10 = v5 + 1;
      else
        v10 = *((_DWORD *)this + 28);
      v11 = v5;
      while (1)
      {
        v8 = (v11 + 1);
        if (v10 - 1 == v11)
          break;
        ++v11;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*((_QWORD *)this + 12) + 24 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_20;
      }
      LODWORD(v5) = v10;
LABEL_20:
      ;
    }
    while (v9 != (_DWORD)v5);
  }
}

uint64_t re::ProtocolLayer::preferredThreadMode(re::ProtocolLayer *this)
{
  return 0;
}

re::DynamicString *re::make::shared::object<re::TcpProtocolHandle,int &,re::TcpConnectionStatus &,re::Address const&>(re *a1, _DWORD *a2, _DWORD *a3, const re::DynamicString *a4)
{
  uint64_t *v8;
  uint64_t v9;
  re::ProtocolHandle *v10;
  re::DynamicString *result;

  v8 = re::globalAllocators(a1);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 1872, 8);
  LODWORD(a2) = *a2;
  LODWORD(a3) = *a3;
  v10 = re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v9);
  *(_QWORD *)v10 = off_24E0732F0;
  *((_DWORD *)v10 + 442) = (_DWORD)a3;
  *((_DWORD *)v10 + 443) = (_DWORD)a2;
  result = re::DynamicString::DynamicString((re::ProtocolHandle *)((char *)v10 + 1776), a4);
  *(_QWORD *)(v9 + 1808) = 0;
  *(_BYTE *)(v9 + 1816) = 10;
  *(_QWORD *)(v9 + 1828) = 0;
  *(_QWORD *)(v9 + 1820) = 0;
  *(_QWORD *)(v9 + 1840) = 0;
  *(_BYTE *)(v9 + 1848) = 10;
  *(_QWORD *)(v9 + 1860) = 0;
  *(_QWORD *)(v9 + 1852) = 0;
  *(_QWORD *)a1 = v9;
  return result;
}

void re::TcpProtocolHandle::~TcpProtocolHandle(re::TcpProtocolHandle *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_24E0732F0;
  v2 = *((_QWORD *)this + 222);
  if (v2)
  {
    if ((*((_BYTE *)this + 1784) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 224));
    *((_OWORD *)this + 111) = 0u;
    *((_OWORD *)this + 112) = 0u;
  }
  re::ProtocolHandle::~ProtocolHandle(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = off_24E0732F0;
  v2 = *((_QWORD *)this + 222);
  if (v2)
  {
    if ((*((_BYTE *)this + 1784) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 224));
    *((_OWORD *)this + 111) = 0u;
    *((_OWORD *)this + 112) = 0u;
  }
  re::ProtocolHandle::~ProtocolHandle(this);
  JUMPOUT(0x220780CD0);
}

uint64_t re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  v12 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *a5 = 0;
  *(_DWORD *)(v12 + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (_DWORD *)(*(_QWORD *)&v13[16] + v10 + 12), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 24 * v9 + 8) = v12 | 0x80000000;
  v13 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9) = a3;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 12) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v9 + 16) = *a5;
  *a5 = 0;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

double RESyncCustomLeaderElectionCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 112, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E073338;
  result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_QWORD *)(v2 + 104) = 0;
  return result;
}

const void **RESyncCustomLeaderElectionDeinit(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[3]);
    result = (const void **)_Block_copy(a2);
    v3[3] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionInit(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[4]);
    result = (const void **)_Block_copy(a2);
    v3[4] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionDestroy(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[5]);
    result = (const void **)_Block_copy(a2);
    v3[5] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionProcessCapabilities(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[6]);
    result = (const void **)_Block_copy(a2);
    v3[6] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionProcessPeerHelloSetLeader(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[7]);
    result = (const void **)_Block_copy(a2);
    v3[7] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionRunLoop(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[8]);
    result = (const void **)_Block_copy(a2);
    v3[8] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionIsLeader(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[9]);
    result = (const void **)_Block_copy(a2);
    v3[9] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionHandleMigration(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[10]);
    result = (const void **)_Block_copy(a2);
    v3[10] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionAddPeer(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[11]);
    result = (const void **)_Block_copy(a2);
    v3[11] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionRemovePeer(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[12]);
    result = (const void **)_Block_copy(a2);
    v3[12] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionSetSession(const void **result, const void *a2)
{
  const void **v3;

  if (result)
  {
    v3 = result;
    _Block_release(result[13]);
    result = (const void **)_Block_copy(a2);
    v3[13] = result;
  }
  return result;
}

_QWORD *RESyncLeaderElectionCreateCustom(_QWORD *a1)
{
  void *v2;
  re *v3;
  uint64_t *v4;
  _QWORD *v5;
  id v6;
  _QWORD *v7;

  if (!a1)
    return 0;
  v2 = a1 + 1;
  v3 = a1 + 1;
  if (a1[3] && a1[4] && a1[6] && a1[8] && a1[9] && a1[10] && a1[11] && a1[12] && a1[13])
  {
    v4 = re::globalAllocators(v3);
    v5 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 40, 8);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v5, 0);
    *v5 = &off_24E073380;
    v5[4] = a1;
    v6 = v2;

    v7 = v5 + 1;
  }
  else
  {
    v5 = 0;
  }

  return v5;
}

void `anonymous namespace'::CustomLeaderElectionImpl::~CustomLeaderElectionImpl(const void **this)
{
  *this = &off_24E073338;
  _Block_release(this[13]);
  _Block_release(this[12]);
  _Block_release(this[11]);
  _Block_release(this[10]);
  _Block_release(this[9]);
  _Block_release(this[8]);
  _Block_release(this[7]);
  _Block_release(this[6]);
  _Block_release(this[5]);
  _Block_release(this[4]);
  _Block_release(this[3]);
  *this = &off_24E0707C0;
  objc_destructInstance(this + 1);
}

{
  JUMPOUT(0x220780CD0);
}

void `anonymous namespace'::CustomLeaderElection::~CustomLeaderElection(_anonymous_namespace_::CustomLeaderElection *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  v3 = *(_QWORD *)(v2 + 40);
  if (!v3 || ((*(void (**)(void))(v3 + 16))(), (v2 = *((_QWORD *)this + 4)) != 0))
  {

    *((_QWORD *)this + 4) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  JUMPOUT(0x220780CD0);
}

uint64_t `anonymous namespace'::CustomLeaderElection::deinit(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 24) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::setup(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 32) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::processCapabilities(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 48) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::processPeerHelloSetLeader(_anonymous_namespace_::CustomLeaderElection *this)
{
  uint64_t result;

  result = *(_QWORD *)(*((_QWORD *)this + 4) + 56);
  if (result)
    return (*(uint64_t (**)(void))(result + 16))();
  return result;
}

uint64_t `anonymous namespace'::CustomLeaderElection::runLoop(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 64) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::isLeader(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 72) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::handleMigration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::addPeer(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 88) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::removePeer(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 96) + 16))();
}

uint64_t `anonymous namespace'::CustomLeaderElection::setSession(_anonymous_namespace_::CustomLeaderElection *this, re::Session *a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 4) + 104) + 16))();
}

uint64_t RESyncBitWriterGetRequiredSize()
{
  return 40;
}

uint64_t RESyncBitWriterConstructNoAlloc(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;

  v4 = 0;
  if (a1 && a2 >= 0x28)
  {
    *(_QWORD *)a1 = &off_24E072668;
    *(_QWORD *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 16) = a4;
    *(_BYTE *)(a1 + 20) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    return a1;
  }
  return v4;
}

uint64_t RESyncBitWriterConstructNoAllocWithStartingBitMarker(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2 >= 0x28)
    {
      *(_QWORD *)a1 = &off_24E072668;
      *(_QWORD *)(a1 + 8) = a3;
      *(_DWORD *)(a1 + 16) = a4;
      *(_BYTE *)(a1 + 20) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      re::BitWriter::rollbackTo(a1, a5);
      return a1;
    }
  }
  return result;
}

uint64_t RESyncBitWriterBackedRequiredSize()
{
  return 56;
}

uint64_t RESyncBitWriterConstructBackedNoAlloc(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;

  v6 = 0;
  if (a1 && a2 >= 0x38)
  {
    *(_DWORD *)(a1 + 16) = a4;
    *(_BYTE *)(a1 + 20) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)a1 = &off_24E0726B8;
    *(_QWORD *)(a1 + 8) = a3;
    v6 = a1;
    *(_QWORD *)(a1 + 40) = a6;
    *(_QWORD *)(a1 + 48) = a5;
  }
  return v6;
}

uint64_t RESyncBitWriterDestructNoDealloc(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t RESyncBitWriterWriteUInt8(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 8u);
}

uint64_t RESyncBitWriterWriteUInt16(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 0x10u);
}

uint64_t RESyncBitWriterWriteUInt32(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 0x20u);
}

uint64_t RESyncBitWriterWriteUInt64(uint64_t a1, uint64_t a2)
{
  unsigned int v2;

  v2 = HIDWORD(a2);
  re::BitWriter::writeUInt32Bits(a1, a2, 0x20u);
  return re::BitWriter::writeUInt32Bits(a1, v2, 0x20u);
}

uint64_t RESyncBitWriterWriteBool(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 1u);
}

uint64_t RESyncBitWriterWriteFloat(uint64_t a1, float a2)
{
  return re::BitWriter::writeUInt32Bits(a1, LODWORD(a2), 0x20u);
}

uint64_t RESyncBitWriterWitePeerID(uint64_t a1, uint64_t a2)
{
  unsigned int v2;

  v2 = HIDWORD(a2);
  re::BitWriter::writeUInt32Bits(a1, a2, 0x20u);
  return re::BitWriter::writeUInt32Bits(a1, v2, 0x20u);
}

uint64_t RESyncBitWriterMakeMarker(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t RESyncBitWriterClear(uint64_t result)
{
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  return result;
}

uint64_t RESyncBitWriterIsOverflow(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 20);
}

uint64_t RESyncBitWriterData(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t RESyncBitWriterSize(uint64_t a1)
{
  unsigned int v1;

  v1 = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28))
    return v1 + 1;
  else
    return v1;
}

uint64_t RESyncBitWriterBitsLeft(_DWORD *a1)
{
  return (8 * (a1[4] - a1[6]) - a1[7]);
}

uint64_t RESyncBitWriterOpenBuffer(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  re::BitWriter::alignToByte((_DWORD *)a1);
  LODWORD(v5) = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28))
    v5 = (v5 + 1);
  else
    v5 = v5;
  v6 = *(_QWORD *)(a1 + 8) + v5;
  *a2 = re::BitWriter::bytesLeft((re::BitWriter *)a1, v4);
  return v6;
}

uint64_t RESyncBitWriterGrowBuffer(re::BitWriter *a1, int a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  (*(void (**)(re::BitWriter *, _QWORD))(*(_QWORD *)a1 + 16))(a1, (a2 - *((_DWORD *)a1 + 2) + *a3));
  LODWORD(v6) = *((_DWORD *)a1 + 6);
  if (*((_DWORD *)a1 + 7))
    v6 = (v6 + 1);
  else
    v6 = v6;
  v7 = *((_QWORD *)a1 + 1) + v6;
  *(_QWORD *)a3 = re::BitWriter::bytesLeft(a1, v5);
  return v7;
}

BOOL RESyncBitWriterCloseBuffer(uint64_t a1, int a2, int a3)
{
  return re::BitWriter::rollbackTo(a1, (a2 + a3 - *(_DWORD *)(a1 + 8)));
}

uint64_t re::SyncCommitDump::log(NSObject *a1, uint64_t a2, const char *a3)
{
  uint64_t result;
  float v7;
  const char *v8;
  const char *v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  const char *v13;
  const char *v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  const char *v18;
  int v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  int v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  double v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  result = os_log_type_enabled(a1, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    v7 = *(float *)(a2 + 24);
    v8 = "Commit";
    if (a3)
      v8 = a3;
    if (v7 <= 0.0)
    {
      v18 = "(Atomic)";
      v19 = *(unsigned __int8 *)(a2 + 28);
      if ((*(_BYTE *)a2 & 1) == 0)
        v18 = (const char *)&unk_21C704343;
      v20 = *(_QWORD *)(a2 + 8);
      v12 = (*(_BYTE *)a2 & 2) == 0;
      v23 = 136316162;
      v21 = "(Held)";
      if (v12)
        v21 = (const char *)&unk_21C704343;
      v24 = v8;
      v25 = 2080;
      v26 = v18;
      if (v19)
        v22 = "(Fwd)";
      else
        v22 = (const char *)&unk_21C704343;
      v27 = 2080;
      v28 = v21;
      v29 = 2080;
      v30 = v22;
      v31 = 2048;
      v32 = v20;
      v15 = "%s %s%s%s Peer=%llu";
      v16 = a1;
      v17 = 52;
    }
    else
    {
      v9 = "(Atomic)";
      v10 = *(unsigned __int8 *)(a2 + 28);
      if ((*(_BYTE *)a2 & 1) == 0)
        v9 = (const char *)&unk_21C704343;
      v11 = *(_QWORD *)(a2 + 8);
      v12 = (*(_BYTE *)a2 & 2) == 0;
      v23 = 136316418;
      v13 = "(Held)";
      if (v12)
        v13 = (const char *)&unk_21C704343;
      v24 = v8;
      v25 = 2080;
      v26 = v9;
      if (v10)
        v14 = "(Fwd)";
      else
        v14 = (const char *)&unk_21C704343;
      v27 = 2080;
      v28 = v13;
      v29 = 2080;
      v30 = v14;
      v31 = 2048;
      v32 = v11;
      v33 = 2048;
      v34 = v7;
      v15 = "%s %s%s%s Peer=%llu TTL=%0.2f";
      v16 = a1;
      v17 = 62;
    }
    _os_log_debug_impl(&dword_21C69B000, v16, OS_LOG_TYPE_DEBUG, v15, (uint8_t *)&v23, v17);
    return re::SyncSnapshotDump::log(a1, a2, a3);
  }
  return result;
}

uint64_t re::SyncCommitDump::log(re *a1, uint64_t a2, const char *a3)
{
  uint64_t v5;
  re::NetworkFeatureFlags *v6;
  NSObject *v7;
  uint64_t result;
  uint64_t v9;

  v5 = (uint64_t)a1;
  v6 = (re::NetworkFeatureFlags *)re::networkLogObjects(a1);
  v7 = *(NSObject **)v6;
  result = re::NetworkFeatureFlags::enableSyncCommitLog(v6);
  if ((_DWORD)result && a2)
  {
    v9 = 72 * a2;
    do
    {
      result = re::SyncCommitDump::log(v7, v5, a3);
      v5 += 72;
      v9 -= 72;
    }
    while (v9);
  }
  return result;
}

uint64_t re::BiasedVLQ::write(re::BiasedVLQ *this, re::BitWriter *a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v4 = *(_QWORD *)this + a3;
  if (v4 < 0x80)
  {
    v5 = *(_QWORD *)this + a3;
  }
  else
  {
    do
    {
      re::BitWriter::writeUInt32Bits((uint64_t)a2, v4 & 0x7F | 0x80, 8u);
      v5 = v4 >> 7;
      v6 = v4 >> 14;
      v4 >>= 7;
    }
    while (v6);
  }
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v5, 8u);
  return 1;
}

uint64_t re::BiasedVLQ::read(re::BiasedVLQ *this, re::BitReader *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v9;

  v6 = 0;
  v7 = 0;
  do
  {
    v9 = 0;
    re::BitReader::readUInt32Bits((uint64_t *)a2, 8u, &v9);
    v7 |= (unint64_t)(v9 & 0x7F) << v6;
    v6 += 7;
  }
  while ((v9 & 0x80) != 0);
  *a3 = v7 - *(_QWORD *)this;
  return 1;
}

uint64_t re::SyncSnapshot::writeObject(_QWORD *a1, re::SyncObject **a2)
{
  re::SyncObject *v4;
  char *v5;
  re::SyncObject *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  _QWORD v10[2];
  char v11;

  re::SyncObject::addState(*a2, 0, 0);
  v4 = *a2;
  v10[0] = v4;
  if (v4)
  {
    v5 = (char *)v4 + 8;
    v6 = *a2;
  }
  else
  {
    v6 = 0;
  }
  v10[1] = re::SyncObject::latestStateHandle(v6);
  v11 = 0;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v10);
  if (v10[0])

  v7 = a1[4] + 24 * a1[2];
  v9 = *(_QWORD *)(v7 - 24);
  result = v7 - 24;
  ++*(_WORD *)(v9 + 176);
  return result;
}

_QWORD *re::DynamicArray<re::internal::SyncSnapshotEntry>::add(_QWORD *this, uint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::internal::SyncSnapshotEntry>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = v3[4] + 24 * v4;
  *(_QWORD *)v5 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  v6 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(v5 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(v5 + 8) = v6;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

BOOL re::SyncSnapshot::writeDestroyedObject(_QWORD *a1, re::SyncObject **a2)
{
  re::SyncObject *v4;
  unint64_t LatestState;
  re::SyncObject *v6;
  char *v7;
  re::SyncObject *v8;
  re::SyncObject *v9;
  re::SyncObject *v10;
  re::SyncObject *v11;
  re::SyncObject *v12;
  uint64_t v13;
  char *v14;
  _QWORD v16[2];
  char v17;
  re::SyncObject *v18;

  *((_BYTE *)*a2 + 128) |= 4u;
  v4 = *a2;
  *((_WORD *)v4 + 88) = *((_WORD *)*a2 + 88) + 1;
  LatestState = re::SyncObject::getLatestState(v4);
  if (LatestState)
  {
    v6 = *a2;
    v16[0] = v6;
    if (v6)
    {
      v7 = (char *)v6 + 8;
      v8 = *a2;
    }
    else
    {
      v8 = 0;
    }
    v16[1] = re::SyncObject::latestStateHandle(v8);
    v17 = 2;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v16);
    if (v16[0])

    *(_WORD *)(LatestState + 84) = 0;
    *(_QWORD *)(LatestState + 88) = 0;
    ++*(_DWORD *)(LatestState + 80);
  }
  else
  {
    v9 = *a2;
    v10 = (re::SyncObject *)*((_QWORD *)*a2 + 10);
    v11 = *a2;
    if (v10)
    {
      v12 = *a2;
      do
      {
        v11 = v12;
        v12 = v10;
        if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)v11 + 11) + 16) + 73))
          break;
        v10 = (re::SyncObject *)*((_QWORD *)v10 + 10);
        v11 = v12;
      }
      while (v10);
    }
    if (*((_BYTE *)v11 + 170))
    {
      v13 = *((_QWORD *)v9 + 11);
      v18 = *a2;
      v14 = (char *)v9 + 8;
      re::SyncObjectTypedStore::removeObject(v13, (uint64_t)&v18);
      if (v18)

    }
  }
  return LatestState != 0;
}

BOOL re::SyncSnapshot::addToView(_QWORD *a1, re::SyncObject **a2)
{
  unint64_t v4;
  re::SyncObject *v5;
  char *v6;
  NSObject *v7;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  _BYTE v15[22];
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = re::SyncObject::latestStateHandle(*a2);
  if (v4 == -1)
  {
    v7 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = *((_QWORD *)*a2 + 3);
      v10 = *(_QWORD **)(*((_QWORD *)*a2 + 11) + 16);
      v11 = v10[4];
      v12 = v10[6];
      v13 = (char *)v10[7];
      v14 = (char *)v10 + 49;
      if ((v12 & 1) != 0)
        v14 = v13;
      *(_DWORD *)v15 = 134218498;
      *(_QWORD *)&v15[4] = v9;
      *(_WORD *)&v15[12] = 2048;
      *(_QWORD *)&v15[14] = v11;
      v16 = 2080;
      v17 = v14;
      _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "Sync object without snapshot while adding to view (id: %llu, type: %llu[%s]).", v15, 0x20u);
    }
  }
  else
  {
    v5 = *a2;
    *(_QWORD *)v15 = v5;
    if (v5)
      v6 = (char *)v5 + 8;
    *(_QWORD *)&v15[8] = v4;
    v15[16] = 1;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v15);
    if (*(_QWORD *)v15)

  }
  return v4 != -1;
}

BOOL re::SyncSnapshot::removeFromView(_QWORD *a1, re::SyncObject **a2)
{
  unint64_t v4;
  re::SyncObject *v5;
  char *v6;
  NSObject *v7;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  _BYTE v15[22];
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = re::SyncObject::latestStateHandle(*a2);
  if (v4 == -1)
  {
    v7 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = *((_QWORD *)*a2 + 3);
      v10 = *(_QWORD **)(*((_QWORD *)*a2 + 11) + 16);
      v11 = v10[4];
      v12 = v10[6];
      v13 = (char *)v10[7];
      v14 = (char *)v10 + 49;
      if ((v12 & 1) != 0)
        v14 = v13;
      *(_DWORD *)v15 = 134218498;
      *(_QWORD *)&v15[4] = v9;
      *(_WORD *)&v15[12] = 2048;
      *(_QWORD *)&v15[14] = v11;
      v16 = 2080;
      v17 = v14;
      _os_log_error_impl(&dword_21C69B000, v7, OS_LOG_TYPE_ERROR, "Sync object without snapshot while removing from view (id: %llu, type: %llu[%s]).", v15, 0x20u);
    }
  }
  else
  {
    v5 = *a2;
    *(_QWORD *)v15 = v5;
    if (v5)
      v6 = (char *)v5 + 8;
    *(_QWORD *)&v15[8] = v4;
    v15[16] = 2;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v15);
    if (*(_QWORD *)v15)

  }
  return v4 != -1;
}

uint64_t re::SyncSnapshot::readAt(re::SyncSnapshot *this, unint64_t a2)
{
  uint64_t v2;

  if (*((_QWORD *)this + 2) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v2 = *((_QWORD *)this + 4) + 24 * a2;
  if (!re::SyncObject::getState(*(re::SyncObject **)v2, *(_QWORD *)(v2 + 8)))
    re::SyncObject::getOldestState(*(re::SyncObject **)v2);
  return v2;
}

re::DebugProtocolLayer *re::DebugProtocolLayer::DebugProtocolLayer(re::DebugProtocolLayer *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E073420;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_QWORD *)((char *)this + 84) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  *(_QWORD *)((char *)this + 132) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 18) = dispatch_semaphore_create(0);
  *((_QWORD *)this + 19) = dispatch_semaphore_create(0);
  return this;
}

void re::DebugProtocolLayer::~DebugProtocolLayer(re::DebugProtocolLayer *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24E073420;
  dispatch_release(*((dispatch_object_t *)this + 18));
  *((_QWORD *)this + 18) = 0;
  dispatch_release(*((dispatch_object_t *)this + 19));
  *((_QWORD *)this + 19) = 0;
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 12);
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 6);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {

    *((_QWORD *)this + 5) = 0;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::DebugProtocolLayer::~DebugProtocolLayer(this);
  JUMPOUT(0x220780CD0);
}

uint64_t re::DebugProtocolLayer::init(re::_anonymous_namespace_ *a1, uint64_t a2)
{
  unint64_t v2;
  re::_anonymous_namespace_ *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  void *v19;
  uint64_t v20;
  _QWORD **v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *j;
  unint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  void *v34;

  v3 = a1;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
    a1 = (re::_anonymous_namespace_ *)(id)(v4 + 8);
  v5 = *((_QWORD *)v3 + 5);
  *((_QWORD *)v3 + 5) = v4;
  if (v5)

  std::recursive_mutex::lock(&stru_25529BC18);
  v6 = qword_25529BC10;
  LODWORD(qword_25529BC10) = qword_25529BC10 + 1;
  *((_DWORD *)v3 + 8) = v6;
  v7 = qword_25529BBF0;
  if (qword_25529BBF0)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)qword_25529BBF0);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v2 = v6;
      if (qword_25529BBF0 <= (unint64_t)v6)
        v2 = v6 % (unint64_t)qword_25529BBF0;
    }
    else
    {
      v2 = (qword_25529BBF0 - 1) & v6;
    }
    v9 = *(uint64_t ***)(qword_25529BBE8 + 8 * v2);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (*((_DWORD *)i + 4) == v6)
            goto LABEL_78;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= qword_25529BBF0)
              v11 %= (unint64_t)qword_25529BBF0;
          }
          else
          {
            v11 &= qword_25529BBF0 - 1;
          }
          if (v11 != v2)
            break;
        }
      }
    }
  }
  v12 = operator new(0x20uLL);
  *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = v6;
  v12[3] = v3;
  v13 = (float)(unint64_t)(qword_25529BC00 + 1);
  if (!v7 || (float)(*(float *)&dword_25529BC08 * (float)v7) < v13)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v13 / *(float *)&dword_25529BC08);
    if (v15 <= v16)
      prime = (int8x8_t)v16;
    else
      prime = (int8x8_t)v15;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = qword_25529BBF0;
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_34;
    if (*(_QWORD *)&prime < v7)
    {
      v24 = vcvtps_u32_f32((float)(unint64_t)qword_25529BC00 / *(float *)&dword_25529BC08);
      if (v7 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        v24 = std::__next_prime(v24);
      }
      else
      {
        v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2)
          v24 = v26;
      }
      if (*(_QWORD *)&prime <= v24)
        prime = (int8x8_t)v24;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = qword_25529BBF0;
      }
      else
      {
        if (prime)
        {
LABEL_34:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v18 = operator new(8 * *(_QWORD *)&prime);
          v19 = (void *)qword_25529BBE8;
          qword_25529BBE8 = (uint64_t)v18;
          if (v19)
            operator delete(v19);
          v20 = 0;
          qword_25529BBF0 = (uint64_t)prime;
          do
            *(_QWORD *)(qword_25529BBE8 + 8 * v20++) = 0;
          while (*(_QWORD *)&prime != v20);
          v21 = (_QWORD **)qword_25529BBF8;
          if (qword_25529BBF8)
          {
            v22 = *(_QWORD *)(qword_25529BBF8 + 8);
            v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(_QWORD *)&prime)
                v22 %= *(_QWORD *)&prime;
            }
            else
            {
              v22 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(qword_25529BBE8 + 8 * v22) = &qword_25529BBF8;
            for (j = *v21; j; v22 = v28)
            {
              v28 = j[1];
              if (v23.u32[0] > 1uLL)
              {
                if (v28 >= *(_QWORD *)&prime)
                  v28 %= *(_QWORD *)&prime;
              }
              else
              {
                v28 &= *(_QWORD *)&prime - 1;
              }
              if (v28 != v22)
              {
                if (!*(_QWORD *)(qword_25529BBE8 + 8 * v28))
                {
                  *(_QWORD *)(qword_25529BBE8 + 8 * v28) = v21;
                  goto LABEL_59;
                }
                *v21 = (_QWORD *)*j;
                *j = **(_QWORD **)(qword_25529BBE8 + 8 * v28);
                **(_QWORD **)(qword_25529BBE8 + 8 * v28) = j;
                j = v21;
              }
              v28 = v22;
LABEL_59:
              v21 = (_QWORD **)j;
              j = (_QWORD *)*j;
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_63;
        }
        v34 = (void *)qword_25529BBE8;
        qword_25529BBE8 = 0;
        if (v34)
          operator delete(v34);
        v7 = 0;
        qword_25529BBF0 = 0;
      }
    }
LABEL_63:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v2 = v6 % v7;
      else
        v2 = v6;
    }
    else
    {
      v2 = (v7 - 1) & v6;
    }
  }
  v29 = qword_25529BBE8;
  v30 = *(_QWORD **)(qword_25529BBE8 + 8 * v2);
  if (v30)
  {
    *v12 = *v30;
LABEL_76:
    *v30 = v12;
    goto LABEL_77;
  }
  v31 = qword_25529BBF8;
  *v12 = qword_25529BBF8;
  qword_25529BBF8 = (uint64_t)v12;
  *(_QWORD *)(v29 + 8 * v2) = &qword_25529BBF8;
  if (v31)
  {
    v32 = *(_QWORD *)(v31 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v30 = (_QWORD *)(qword_25529BBE8 + 8 * v32);
    goto LABEL_76;
  }
LABEL_77:
  ++qword_25529BC00;
LABEL_78:
  std::recursive_mutex::unlock(&stru_25529BC18);
  return 1;
}

void re::`anonymous namespace'::interconnect(re::_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_1);
  if ((v1 & 1) == 0)
  {
    if (__cxa_guard_acquire(&_MergedGlobals_1))
    {
      *(_OWORD *)&qword_25529BBF8 = 0u;
      *(_OWORD *)&qword_25529BBE8 = 0u;
      dword_25529BC08 = 1065353216;
      qword_25529BC10 = 0x100000001;
      MEMORY[0x220780C1C](&unk_25529BC18);
      __cxa_guard_release(&_MergedGlobals_1);
    }
  }
}

void re::DebugProtocolLayer::deinit(re::DebugProtocolLayer *this)
{
  re::_anonymous_namespace_ *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  re::_anonymous_namespace_ *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint8x8_t v20;
  unint64_t v21;
  void **v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;

  std::recursive_mutex::lock(&stru_25529BC18);
  v3 = *((unsigned int *)this + 20);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 8) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 6;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 20);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v3 != (_DWORD)v4)
  {
    v7 = v4;
    do
    {
      v8 = *(_QWORD *)(*((_QWORD *)this + 8) + 24 * v7 + 16);
      if (v8)
        v2 = (re::_anonymous_namespace_ *)(id)(v8 + 8);
      re::DebugProtocolInterconnect::sendDisconnect((re::DebugProtocolInterconnect *)*(unsigned int *)(v8 + 1776), *(_DWORD *)(v8 + 1784));

      if (*((_DWORD *)this + 20) <= (v4 + 1))
        v9 = v4 + 1;
      else
        v9 = *((_DWORD *)this + 20);
      while (1)
      {
        v7 = (v4 + 1);
        if (v9 - 1 == (_DWORD)v4)
          break;
        LODWORD(v4) = v4 + 1;
        v10 = v7;
        if ((*(_DWORD *)(*((_QWORD *)this + 8) + 24 * v7 + 8) & 0x80000000) != 0)
          goto LABEL_18;
      }
      v10 = v9;
LABEL_18:
      LODWORD(v4) = v10;
    }
    while ((_DWORD)v3 != v10);
  }
  while (*((_DWORD *)this + 31))
  {
    v11 = *((unsigned int *)this + 32);
    v12 = *((_QWORD *)this + 14);
    v13 = 0;
    if ((_DWORD)v11)
    {
      v14 = (int *)(v12 + 8);
      while (1)
      {
        v15 = *v14;
        v14 += 6;
        if (v15 < 0)
          break;
        if (v11 == ++v13)
        {
          LODWORD(v13) = *((_DWORD *)this + 32);
          break;
        }
      }
    }
    re::DebugProtocolLayer::withlock_close(this, *(_DWORD **)(v12 + 24 * v13 + 16));
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)this + 48);
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)this + 96);
  v17 = *((_QWORD *)this + 5);
  if (v17)
  {

    *((_QWORD *)this + 5) = 0;
  }
  std::recursive_mutex::lock(&stru_25529BC18);
  v18 = qword_25529BBF0;
  if (!qword_25529BBF0)
    goto LABEL_74;
  v19 = *((int *)this + 8);
  v20 = (uint8x8_t)vcnt_s8((int8x8_t)qword_25529BBF0);
  v20.i16[0] = vaddlv_u8(v20);
  if (v20.u32[0] > 1uLL)
  {
    v21 = *((int *)this + 8);
    if (qword_25529BBF0 <= v19)
      v21 = v19 % qword_25529BBF0;
  }
  else
  {
    v21 = (qword_25529BBF0 - 1) & v19;
  }
  v22 = *(void ***)(qword_25529BBE8 + 8 * v21);
  if (!v22)
    goto LABEL_74;
  v23 = (uint64_t *)*v22;
  if (!*v22)
    goto LABEL_74;
  v24 = qword_25529BBF0 - 1;
  while (1)
  {
    v25 = v23[1];
    if (v25 == v19)
      break;
    if (v20.u32[0] > 1uLL)
    {
      if (v25 >= qword_25529BBF0)
        v25 %= (unint64_t)qword_25529BBF0;
    }
    else
    {
      v25 &= v24;
    }
    if (v25 != v21)
      goto LABEL_74;
LABEL_44:
    v23 = (uint64_t *)*v23;
    if (!v23)
      goto LABEL_74;
  }
  if (*((_DWORD *)v23 + 4) != (_DWORD)v19)
    goto LABEL_44;
  v26 = *v23;
  if (v20.u32[0] > 1uLL)
  {
    if (qword_25529BBF0 <= v19)
      v19 %= (unint64_t)qword_25529BBF0;
  }
  else
  {
    v19 &= v24;
  }
  v27 = *(uint64_t **)(qword_25529BBE8 + 8 * v19);
  do
  {
    v28 = v27;
    v27 = (uint64_t *)*v27;
  }
  while (v27 != v23);
  if (v28 == &qword_25529BBF8)
    goto LABEL_63;
  v29 = v28[1];
  if (v20.u32[0] > 1uLL)
  {
    if (v29 >= qword_25529BBF0)
      v29 %= (unint64_t)qword_25529BBF0;
  }
  else
  {
    v29 &= v24;
  }
  if (v29 == v19)
  {
LABEL_65:
    if (v26)
    {
      v30 = *(_QWORD *)(v26 + 8);
      goto LABEL_67;
    }
  }
  else
  {
LABEL_63:
    if (!v26)
      goto LABEL_64;
    v30 = *(_QWORD *)(v26 + 8);
    if (v20.u32[0] > 1uLL)
    {
      v31 = *(_QWORD *)(v26 + 8);
      if (v30 >= qword_25529BBF0)
        v31 = v30 % qword_25529BBF0;
    }
    else
    {
      v31 = v30 & v24;
    }
    if (v31 != v19)
    {
LABEL_64:
      *(_QWORD *)(qword_25529BBE8 + 8 * v19) = 0;
      v26 = *v23;
      goto LABEL_65;
    }
LABEL_67:
    if (v20.u32[0] > 1uLL)
    {
      if (v30 >= v18)
        v30 %= v18;
    }
    else
    {
      v30 &= v24;
    }
    if (v30 != v19)
    {
      *(_QWORD *)(qword_25529BBE8 + 8 * v30) = v28;
      v26 = *v23;
    }
  }
  *v28 = v26;
  *v23 = 0;
  --qword_25529BC00;
  operator delete(v23);
LABEL_74:
  *((_DWORD *)this + 8) = 0;
  std::recursive_mutex::unlock(&stru_25529BC18);
  std::recursive_mutex::unlock(&stru_25529BC18);
}

void re::DebugProtocolInterconnect::sendDisconnect(re::DebugProtocolInterconnect *this, int a2)
{
  int v3;
  uint64_t *v4;
  uint64_t v5;
  re *v6;
  _DWORD *v7;
  NSObject *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v3 = (int)this;
  v17 = *MEMORY[0x24BDAC8D0];
  std::recursive_mutex::lock(&stru_25529BC18);
  v4 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v3);
  if (v4)
  {
    v5 = v4[3];
    if (v5)
    {
      v6 = (re *)re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(v5 + 96, a2);
      if (v6)
      {
        v7 = *(_DWORD **)v6;
        if (*(_QWORD *)v6)
        {
          v8 = *re::networkLogObjects(v6);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            v9 = *(_DWORD *)(v5 + 32);
            v10 = v7[444];
            LODWORD(v12) = 67109632;
            HIDWORD(v12) = v9;
            v13 = 1024;
            v14 = v10;
            v15 = 1024;
            LODWORD(v16) = a2;
            _os_log_impl(&dword_21C69B000, v8, OS_LOG_TYPE_DEFAULT, "[DebugLayer disconnected] local=%d remote=%d connection=%d", (uint8_t *)&v12, 0x14u);
          }
          v7[447] = 3;
          v11 = *(_QWORD *)(v5 + 24);
          if (v11)
          {
            (*(void (**)(uint64_t, uint64_t, _DWORD *, uint64_t *))(*(_QWORD *)v11 + 8))(v11, v5, v7, &v12);
            if (v12)
            {
              if ((v13 & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v12 + 40))();
            }
          }
        }
      }
    }
  }
  std::recursive_mutex::unlock(&stru_25529BC18);
}

void re::DebugProtocolLayer::withlock_close(re *a1, _DWORD *a2)
{
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v4 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *((_DWORD *)a1 + 8);
    v6 = a2[444];
    v7 = a2[446];
    LODWORD(v9) = 67109632;
    HIDWORD(v9) = v5;
    v10 = 1024;
    v11 = v6;
    v12 = 1024;
    v13 = v7;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "[DebugLayer close] local=%d remote=%d connection=%d", (uint8_t *)&v9, 0x14u);
  }
  a2[447] = 3;
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::remove((uint64_t)a1 + 96, a2 + 446);
  v8 = a2 + 2;
  v9 = a2;
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove((uint64_t)a1 + 48, (uint64_t *)&v9);
  if (v9)

}

void re::DebugProtocolLayer::send(re::_anonymous_namespace_ *a1, int *a2, uint64_t a3)
{
  re::_anonymous_namespace_ *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  re::PacketPool **v14;

  std::recursive_mutex::lock(&stru_25529BC18);
  v7 = *(_QWORD *)a3;
  v8 = *(_QWORD *)(a3 + 8);
  while (v7 != v8)
  {
    v9 = atomic_load(*(unint64_t **)(v7 + 8));
    v10 = atomic_load((unint64_t *)(*(_QWORD *)a3 + 16));
    if (v9)
    {
      v11 = v10 + 1;
      do
      {
        if (!--v11)
          break;
        v12 = *(unsigned __int8 *)(a3 + 16);
        v13 = a2[444];
        if (v13 == -1)
          re::DebugProtocolInterconnect::broadcastPacket(a2[442], v12, v9);
        else
          re::DebugProtocolInterconnect::sendPacket(a2[444], a2[446], v12, v9);
        *((_DWORD *)a1 + 43) += *(_DWORD *)(v9 + 24);
        ++*((_DWORD *)a1 + 45);
        v14 = (re::PacketPool **)re::PacketQueue::dequeue(*(unint64_t ***)a3);
        re::PacketPool::free(v14[7], (re::Packet *)v14);
        v9 = atomic_load(*(unint64_t **)(*(_QWORD *)a3 + 8));
      }
      while (v9);
    }
    v8 = *(_QWORD *)(a3 + 8);
    v7 = *(_QWORD *)a3 + 40;
    *(_QWORD *)a3 = v7;
    ++*(_BYTE *)(a3 + 16);
  }
  std::recursive_mutex::unlock(&stru_25529BC18);
}

intptr_t re::DebugProtocolLayer::update(dispatch_semaphore_t *this)
{
  return dispatch_semaphore_signal(this[19]);
}

void re::DebugProtocolInterconnect::broadcastPacket(int a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  _DWORD *v13;
  _DWORD *v14;
  int v15;
  int v16;

  std::recursive_mutex::lock(&stru_25529BC18);
  v6 = (_QWORD *)qword_25529BBF8;
  if (qword_25529BBF8)
  {
    do
    {
      v7 = v6[3];
      if (*(_DWORD *)(v7 + 32) != a1)
      {
        v8 = *(unsigned int *)(v7 + 80);
        if ((_DWORD)v8)
        {
          v9 = 0;
          v10 = (int *)(*(_QWORD *)(v7 + 64) + 8);
          while (1)
          {
            v11 = *v10;
            v10 += 6;
            if (v11 < 0)
              break;
            if (v8 == ++v9)
            {
              LODWORD(v9) = *(_DWORD *)(v7 + 80);
              break;
            }
          }
        }
        else
        {
          LODWORD(v9) = 0;
        }
        if ((_DWORD)v8 != (_DWORD)v9)
        {
          v12 = v9;
          do
          {
            v13 = *(_DWORD **)(*(_QWORD *)(v7 + 64) + 24 * v12 + 16);
            if (v13)
              v14 = v13 + 2;
            if (v13[444] == a1)
              re::DebugProtocolLayer::withlock_receive(v7, v13[446], a2, *(_QWORD *)(a3 + 16), *(_DWORD *)(a3 + 24));

            if (*(_DWORD *)(v7 + 80) <= (v9 + 1))
              v15 = v9 + 1;
            else
              v15 = *(_DWORD *)(v7 + 80);
            while (1)
            {
              v12 = (v9 + 1);
              if (v15 - 1 == (_DWORD)v9)
                break;
              LODWORD(v9) = v9 + 1;
              v16 = v12;
              if ((*(_DWORD *)(*(_QWORD *)(v7 + 64) + 24 * v12 + 8) & 0x80000000) != 0)
                goto LABEL_22;
            }
            v16 = v15;
LABEL_22:
            LODWORD(v9) = v16;
          }
          while ((_DWORD)v8 != v16);
        }
      }
      v6 = (_QWORD *)*v6;
    }
    while (v6);
  }
  std::recursive_mutex::unlock(&stru_25529BC18);
}

void re::DebugProtocolInterconnect::sendPacket(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;

  std::recursive_mutex::lock(&stru_25529BC18);
  v8 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(a1);
  if (v8)
  {
    v9 = v8[3];
    if (v9)
      re::DebugProtocolLayer::withlock_receive(v9, a2, a3, *(_QWORD *)(a4 + 16), *(_DWORD *)(a4 + 24));
  }
  std::recursive_mutex::unlock(&stru_25529BC18);
}

intptr_t re::DebugProtocolLayer::wait(dispatch_semaphore_t *this)
{
  return dispatch_semaphore_wait(this[18], 0xFFFFFFFFFFFFFFFFLL);
}

intptr_t re::DebugProtocolLayer::wakeup(dispatch_semaphore_t *this)
{
  dispatch_semaphore_signal(this[18]);
  return dispatch_semaphore_wait(this[19], 0xFFFFFFFFFFFFFFFFLL);
}

uint64_t re::DebugProtocolLayer::setListener(uint64_t this, ProtocolLayerListener *a2)
{
  *(_QWORD *)(this + 24) = a2;
  return this;
}

uint64_t re::DebugProtocolLayer::localAddresses(re::DebugProtocolLayer *this, re::Address *a2, uint64_t a3)
{
  uint64_t v5;
  char v6;

  if (a3)
  {
    re::DynamicString::operator=(a2, (re::DynamicString *)&v5);
    if (v5)
    {
      if ((v6 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v5 + 40))();
    }
  }
  return 1;
}

uint64_t re::`anonymous namespace'::formatAddress(re::_anonymous_namespace_ *this, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  char v6;

  if ((_DWORD)a3)
  {
    re::DynamicString::format((re::DynamicString *)"debug://%d/%d", (re::DynamicString *)&v5, a2, a3);
  }
  else
  {
    if ((_DWORD)a2 == -1)
      return re::DebugProtocolLayer::broadcastAddress(this);
    re::DynamicString::format((re::DynamicString *)"debug://%d", (re::DynamicString *)&v5, a2);
  }
  re::DynamicString::DynamicString(this, (const re::DynamicString *)&v5);
  result = v5;
  if (v5)
  {
    if ((v6 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
  }
  return result;
}

uint64_t re::DebugProtocolLayer::hostStats(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  v2 = *(_OWORD *)(a1 + 160);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 176);
  *(_OWORD *)a2 = v2;
  return 1;
}

void re::DebugProtocolLayer::open(re::DebugProtocolLayer *this@<X0>, const re::Address *a2@<X1>, _QWORD *a3@<X8>)
{
  const char *v6;
  char v7;
  const char *v8;
  const char *v9;
  re::_anonymous_namespace_ *v10;
  int v11;
  const char *v12;
  int v13;
  _DWORD *v14;
  _DWORD *v15;
  re *v16;
  NSObject *v17;
  _BOOL8 v18;
  int v19;
  int v20;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  _DWORD *v26;
  _DWORD *v27;
  re::_anonymous_namespace_ *v28;
  void (***v29)(_QWORD, uint64_t, _DWORD *, uint8_t *);
  uint64_t *v30;
  re::DebugProtocolLayer *v31;
  uint64_t *v32;
  uint64_t v33;
  re *v34;
  uint64_t v35;
  NSObject *v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t *v40;
  _DWORD *v41;
  uint64_t v42;
  _DWORD *v43;
  int v44;
  uint8_t buf[8];
  __int16 v46;
  int v47;
  __int16 v48;
  const char *v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  std::recursive_mutex::lock(&stru_25529BC18);
  v42 = 0;
  re::DebugProtocolLayer::broadcastAddress((re::DebugProtocolLayer *)buf);
  v7 = v46;
  v6 = v49;
  if ((v46 & 1) != 0)
    v8 = v49;
  else
    v8 = (char *)&v46 + 1;
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a2 + 2);
  else
    v9 = (char *)a2 + 9;
  v10 = (re::_anonymous_namespace_ *)strcmp(v8, v9);
  v11 = (int)v10;
  if ((v7 & 1) != 0)
  {
    v10 = *(re::_anonymous_namespace_ **)buf;
    if (*(_QWORD *)buf)
      v10 = (re::_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, const char *))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, v6);
  }
  if (v11)
  {
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v12 = (const char *)*((_QWORD *)a2 + 2);
    else
      v12 = (char *)a2 + 9;
    v10 = (re::_anonymous_namespace_ *)sscanf(v12, "debug://%d/%d", (char *)&v42 + 4, &v42);
    if ((int)v10 < 1)
    {
      *a3 = 0;
      goto LABEL_50;
    }
  }
  else
  {
    HIDWORD(v42) = -1;
  }
  v13 = HIDWORD(qword_25529BC10)++;
  re::make::shared::object<re::DebugProtocolHandle>((re *)&v41);
  v14 = v41;
  v41[442] = *((_DWORD *)this + 8);
  v14[443] = v13;
  v14[444] = HIDWORD(v42);
  v14[445] = 0;
  v14[446] = v13;
  v14[447] = 1;
  *(_QWORD *)buf = v14;
  v15 = v14 + 2;
  re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add((uint64_t)this + 48, (uint64_t *)buf);
  if (*(_QWORD *)buf)

  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>((uint64_t)this + 96, v14 + 446, (uint64_t *)&v41);
  v17 = *re::networkLogObjects(v16);
  v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v18)
  {
    v19 = *((_DWORD *)this + 8);
    *(_DWORD *)buf = 67109632;
    *(_DWORD *)&buf[4] = v19;
    v46 = 1024;
    v47 = HIDWORD(v42);
    v48 = 1024;
    LODWORD(v49) = v13;
    _os_log_impl(&dword_21C69B000, v17, OS_LOG_TYPE_DEFAULT, "[DebugLayer connect] local=%d remote=%d connection=%d", buf, 0x14u);
  }
  v20 = HIDWORD(v42);
  v21 = *((_DWORD *)this + 8);
  std::recursive_mutex::lock(&stru_25529BC18);
  if (v20 == -1)
  {
    v40 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v21);
    if (v40)
      v40 = (uint64_t *)v40[3];
    re::DebugProtocolLayer::withlock_connected((re::DebugProtocolLayer *)v40, v13);
  }
  else
  {
    v22 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v20);
    if (v22 && (v23 = v22[3]) != 0)
    {
      v44 = v13;
      v24 = *re::networkLogObjects((re *)v22);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v25 = *(_DWORD *)(v23 + 32);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&buf[4] = v25;
        v46 = 1024;
        v47 = v21;
        v48 = 1024;
        LODWORD(v49) = v13;
        _os_log_impl(&dword_21C69B000, v24, OS_LOG_TYPE_DEFAULT, "[DebugLayer accepted] local=%d remote=%d connection=%d", buf, 0x14u);
      }
      re::make::shared::object<re::DebugProtocolHandle>((re *)&v43);
      v26 = v43;
      v43[442] = *(_DWORD *)(v23 + 32);
      v26[443] = 0;
      v26[444] = v21;
      v26[445] = v13;
      v26[446] = v13;
      v26[447] = 2;
      *(_QWORD *)buf = v26;
      v27 = v26 + 2;
      re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add(v23 + 48, (uint64_t *)buf);
      if (*(_QWORD *)buf)

      re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>(v23 + 96, &v44, (uint64_t *)&v43);
      v29 = *(void (****)(_QWORD, uint64_t, _DWORD *, uint8_t *))(v23 + 24);
      if (v29)
      {
        (**v29)(v29, v23, v26, buf);
        v28 = *(re::_anonymous_namespace_ **)buf;
        if (*(_QWORD *)buf)
        {
          if ((v46 & 1) != 0)
            v28 = (re::_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
        }
      }
      std::recursive_mutex::lock(&stru_25529BC18);
      v30 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v21);
      if (v30)
      {
        v31 = (re::DebugProtocolLayer *)v30[3];
        if (v31)
          re::DebugProtocolLayer::withlock_connected(v31, v13);
      }
      std::recursive_mutex::unlock(&stru_25529BC18);

    }
    else
    {
      v32 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v21);
      if (v32)
      {
        v33 = v32[3];
        if (v33)
        {
          v34 = (re *)re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(v33 + 96, v13);
          if (v34)
          {
            v35 = *(_QWORD *)v34;
            if (*(_QWORD *)v34)
            {
              v36 = *re::networkLogObjects(v34);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                v37 = *(_DWORD *)(v33 + 32);
                v38 = *(_DWORD *)(v35 + 1776);
                *(_DWORD *)buf = 67109632;
                *(_DWORD *)&buf[4] = v37;
                v46 = 1024;
                v47 = v38;
                v48 = 1024;
                LODWORD(v49) = v13;
                _os_log_impl(&dword_21C69B000, v36, OS_LOG_TYPE_DEFAULT, "[DebugLayer error] local=%d remote=%d connection=%d", buf, 0x14u);
              }
              if ((*(_DWORD *)(v35 + 1788) - 1) <= 2)
              {
                v39 = *(_QWORD *)(v33 + 24);
                if (v39)
                  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v39 + 16))(v39, v33, v35, 2);
                *(_DWORD *)(v35 + 1788) = 4;
              }
            }
          }
        }
      }
    }
  }
  std::recursive_mutex::unlock(&stru_25529BC18);
  *a3 = v14;
LABEL_50:
  std::recursive_mutex::unlock(&stru_25529BC18);
}

void re::DebugProtocolLayer::close(re::_anonymous_namespace_ *a1, _DWORD *a2)
{
  std::recursive_mutex::lock(&stru_25529BC18);
  re::DebugProtocolLayer::withlock_close(a1, a2);
  std::recursive_mutex::unlock(&stru_25529BC18);
}

void re::DebugProtocolLayer::disconnect(re::PacketPool **this, re::ProtocolHandle *a2)
{
  re *v4;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  int v12;
  re::PacketPool *v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  std::recursive_mutex::lock(&stru_25529BC18);
  v5 = *re::networkLogObjects(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *((_DWORD *)this + 8);
    v7 = *((_DWORD *)a2 + 444);
    v8 = *((_DWORD *)a2 + 446);
    LODWORD(v14) = 67109632;
    HIDWORD(v14) = v6;
    v15 = 1024;
    v16 = v7;
    v17 = 1024;
    LODWORD(v18) = v8;
    _os_log_impl(&dword_21C69B000, v5, OS_LOG_TYPE_DEFAULT, "[DebugLayer disconnect] local=%d remote=%d connection=%d", (uint8_t *)&v14, 0x14u);
  }
  if (*((_DWORD *)a2 + 447) != 3)
  {
    v9 = 0;
    *((_DWORD *)a2 + 447) = 3;
    do
    {
      v10 = re::PacketQueue::dequeue((unint64_t **)a2 + 5 * v9 + 114);
      if (v10)
      {
        v11 = v10;
        do
        {
          v12 = *((_DWORD *)a2 + 444);
          if (v12 == -1)
            re::DebugProtocolInterconnect::broadcastPacket(*((_DWORD *)a2 + 442), v9, (uint64_t)v11);
          else
            re::DebugProtocolInterconnect::sendPacket(*((_DWORD *)a2 + 444), *((_DWORD *)a2 + 446), v9, (uint64_t)v11);
          *((_DWORD *)this + 43) += *((_DWORD *)v11 + 6);
          ++*((_DWORD *)this + 45);
          re::PacketPool::free(this[5], (re::Packet *)v11);
          v10 = re::PacketQueue::dequeue((unint64_t **)a2 + 5 * v9 + 114);
          v11 = v10;
        }
        while (v10);
      }
      ++v9;
    }
    while (v9 != 10);
    re::DebugProtocolInterconnect::sendDisconnect((re::DebugProtocolInterconnect *)*((unsigned int *)a2 + 444), *((_DWORD *)a2 + 446));
    v13 = this[3];
    if (v13)
    {
      (*(void (**)(re::PacketPool *, re::PacketPool **, re::ProtocolHandle *, uint64_t *))(*(_QWORD *)v13 + 8))(v13, this, a2, &v14);
      if (v14)
      {
        if ((v15 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v14 + 40))();
      }
    }
  }
  std::recursive_mutex::unlock(&stru_25529BC18);
}

void re::DebugProtocolLayer::withlock_connected(re::DebugProtocolLayer *this, int a2)
{
  re *v4;
  _DWORD *v5;
  NSObject *v6;
  int v7;
  int v8;
  void (***v9)(_QWORD, re::DebugProtocolLayer *, _DWORD *, uint64_t *);
  uint64_t v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = (re *)re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet((uint64_t)this + 96, a2);
  if (v4)
  {
    v5 = *(_DWORD **)v4;
    if (*(_QWORD *)v4)
    {
      v6 = *re::networkLogObjects(v4);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *((_DWORD *)this + 8);
        v8 = v5[444];
        LODWORD(v10) = 67109632;
        HIDWORD(v10) = v7;
        v11 = 1024;
        v12 = v8;
        v13 = 1024;
        LODWORD(v14) = a2;
        _os_log_impl(&dword_21C69B000, v6, OS_LOG_TYPE_DEFAULT, "[DebugLayer connected] local=%d remote=%d connection=%d", (uint8_t *)&v10, 0x14u);
      }
      if (v5[447] == 1)
      {
        v5[447] = 2;
        v9 = (void (***)(_QWORD, re::DebugProtocolLayer *, _DWORD *, uint64_t *))*((_QWORD *)this + 3);
        if (v9)
        {
          (**v9)(v9, this, v5, &v10);
          if (v10)
          {
            if ((v11 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v10 + 40))();
          }
        }
      }
    }
  }
}

uint64_t re::DebugProtocolLayer::withlock_receive(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result;

  result = re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(a1 + 96, a2);
  if (result && *(_QWORD *)result)
  {
    *(_DWORD *)(a1 + 168) += a5;
    ++*(_DWORD *)(a1 + 176);
    result = *(_QWORD *)(a1 + 24);
    if (result)
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 24))(result, a1);
  }
  return result;
}

uint64_t re::DebugProtocolLayer::preferredThreadMode(re::DebugProtocolLayer *this)
{
  return 2;
}

uint64_t re::DebugProtocolLayer::broadcastAddress(re::DebugProtocolLayer *this)
{
  uint64_t result;
  uint64_t v3;
  char v4;

  re::DynamicString::DynamicString(this, (const re::DynamicString *)&v3);
  result = v3;
  if (v3)
  {
    if ((v4 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v3 + 40))();
  }
  return result;
}

uint64_t re::DebugProtocolLayer::drainsPacketSink(re::DebugProtocolLayer *this)
{
  return 1;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

uint64_t *std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(int a1)
{
  uint8x8_t v1;
  unint64_t v2;
  uint64_t *i;
  unint64_t v4;

  if (!qword_25529BBF0)
    return 0;
  v1 = (uint8x8_t)vcnt_s8((int8x8_t)qword_25529BBF0);
  v1.i16[0] = vaddlv_u8(v1);
  if (v1.u32[0] > 1uLL)
  {
    v2 = a1;
    if (qword_25529BBF0 <= (unint64_t)a1)
      v2 = a1 % (unint64_t)qword_25529BBF0;
  }
  else
  {
    v2 = (qword_25529BBF0 - 1) & a1;
  }
  i = *(uint64_t **)(qword_25529BBE8 + 8 * v2);
  if (i)
  {
    for (i = (uint64_t *)*i; i; i = (uint64_t *)*i)
    {
      v4 = i[1];
      if (v4 == a1)
      {
        if (*((_DWORD *)i + 4) == a1)
          return i;
      }
      else
      {
        if (v1.u32[0] > 1uLL)
        {
          if (v4 >= qword_25529BBF0)
            v4 %= (unint64_t)qword_25529BBF0;
        }
        else
        {
          v4 &= qword_25529BBF0 - 1;
        }
        if (v4 != v2)
          return 0;
      }
    }
  }
  return i;
}

re::ProtocolHandle *re::make::shared::object<re::DebugProtocolHandle>(re *a1)
{
  uint64_t *v2;
  _QWORD *v3;
  re::ProtocolHandle *result;

  v2 = re::globalAllocators(a1);
  v3 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 1792, 8);
  bzero(v3, 0x700uLL);
  result = re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v3);
  *v3 = &off_24E0734E8;
  v3[221] = 0;
  v3[223] = 0;
  v3[222] = 0;
  *(_QWORD *)a1 = v3;
  return result;
}

void re::DebugProtocolHandle::~DebugProtocolHandle(re::DebugProtocolHandle *this)
{
  re::ProtocolHandle::~ProtocolHandle(this);
  JUMPOUT(0x220780CD0);
}

uint64_t re::SharedAppSyncUnpacker::unpackCommit(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  int v12;
  unsigned int v13;
  _QWORD v14[2];
  uint64_t v15;
  uint64_t v16;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;

  v8 = *(unsigned int *)(a2 + 16);
  if (*(_BYTE *)(a2 + 12))
    v9 = 0;
  else
    v9 = *(_QWORD *)a2 + v8;
  v10 = (*(_DWORD *)(a2 + 8) - v8);
  v14[0] = v9;
  v14[1] = v10;
  v17 = -1;
  v18 = 0;
  v19 = 0;
  v21 = 0;
  v15 = v9;
  v16 = v9 + v10;
  result = re::SharedAppSyncUnpacker::parseCommit((uint64_t)a1, (re::snapshot::DecoderOPACK *)v14, a3, a4);
  if (!*(_BYTE *)(a2 + 12))
  {
    v12 = v15 - LODWORD(v14[0]);
    *(_QWORD *)(a2 + 24) = 0;
    v13 = *(_DWORD *)(a2 + 16) + v12;
    *(_QWORD *)(a2 + 16) = v13;
    if (v13 > *(_DWORD *)(a2 + 8))
      *(_BYTE *)(a2 + 12) = 1;
  }
  return result;
}

uint64_t re::SharedAppSyncUnpacker::parseCommit(uint64_t a1, re::snapshot::DecoderOPACK *this, uint64_t a3, uint64_t a4)
{
  re *v8;
  re *v9;
  uint64_t Integer;
  uint64_t v11;
  re *v12;
  unint64_t v13;
  BOOL v14;
  char v15;
  re *v16;
  re::SyncObjectStore *v17;
  re *v18;
  uint64_t v19;
  NSObject *v20;
  re::SyncObjectStore *v21;
  re::SyncObjectStore *v22;
  uint64_t v23;
  uint64_t v24;
  re::SyncObjectTypedStore **Object;
  re::SyncObject *v26;
  re::SyncObject *v27;
  uint64_t shouldAcceptUpdate;
  int v29;
  re::SyncObjectStore *v30;
  _BOOL8 v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  __int128 v36;
  BOOL v37;
  char v38;
  _BOOL4 isStateDataChanged;
  unsigned __int16 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  re::BitWriter *v44;
  const void *v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  BOOL v49;
  char v50;
  char v51;
  re::SyncObject *v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v55;
  re::SyncObjectStore *v56;
  _BOOL8 v57;
  NSObject *v58;
  uint64_t v59;
  NSObject *v60;
  const char *v61;
  NSObject *v62;
  uint64_t v63;
  uint32_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  re::SyncOpaqueTypeInfo *v69;
  re::SyncOpaqueTypeInfo *v70;
  NSObject *v71;
  uint64_t result;
  const char *v73;
  NSObject *v74;
  const char *v75;
  char v76;
  _anonymous_namespace_ *v77;
  unint64_t v78;
  __int128 v79;
  re::SyncObject *v80;
  re::SyncObject *v81;
  uint64_t v82;
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  unint64_t v86[2];
  unsigned __int16 v87[2];
  unsigned __int16 v88;
  char v89;
  re::SyncOpaqueTypeInfo *v90;
  _BYTE buf[24];
  re::SyncOpaqueTypeInfo *v92;
  __int16 v93;
  uint64_t v94;
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  v8 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
  if ((v8 & 1) == 0)
  {
    v71 = *re::networkLogObjects(v8);
    result = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      *(_WORD *)buf = 0;
      v73 = "Commit doesn't begin with an object header";
      goto LABEL_105;
    }
    return result;
  }
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, (_BYTE *)a3);
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned long long>((uint64_t)this, (_QWORD *)(a3 + 16));
  re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
  *(_QWORD *)(a3 + 8) = *(_QWORD *)(a1 + 8);
  v78 = 0;
  v9 = (re *)re::snapshot::DecoderOPACK::beginDictionary(this, &v78);
  if ((_DWORD)v9)
  {
    v77 = (_anonymous_namespace_ *)(a3 + 32);
    while (1)
    {
      while (1)
      {
        while (1)
        {
          do
          {
            if (re::snapshot::DecoderOPACK::endDictionary(this, &v78))
              return 2;
            Integer = re::snapshot::DecoderOPACK::readInteger(this, 0);
            if (!Integer)
            {
              v74 = *re::networkLogObjects(0);
              shouldAcceptUpdate = os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
              if (!(_DWORD)shouldAcceptUpdate)
                goto LABEL_103;
              *(_WORD *)buf = 0;
              v75 = "Expected valid guid";
              goto LABEL_108;
            }
            v11 = Integer;
            v90 = (re::SyncOpaqueTypeInfo *)-1;
            v12 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
            if ((v12 & 1) == 0)
            {
              v74 = *re::networkLogObjects(v12);
              shouldAcceptUpdate = os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
              if (!(_DWORD)shouldAcceptUpdate)
                goto LABEL_103;
              *(_WORD *)buf = 0;
              v75 = "Expected object header";
              goto LABEL_108;
            }
            v89 = 0;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, &v89);
            v88 = 0;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>((uint64_t)this, &v88);
            *(_QWORD *)&v85 = 0;
            WORD4(v85) = 0;
            LOBYTE(v86[0]) = 0;
            v86[1] = 0;
            *(_DWORD *)v87 = 0x10000;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,re::SyncOwnershipInfo>((uint64_t)this, (uint64_t)&v85);
            v13 = v86[1];
            if (!v86[1])
            {
              v13 = *(_QWORD *)(a1 + 8);
              v86[1] = v13;
            }
            if (v13 == *(_QWORD *)(a1 + 16))
            {
              v14 = 1;
            }
            else if (*(_BYTE *)(a1 + 72))
            {
              v14 = v13 == *(_QWORD *)(a4 + 8);
            }
            else
            {
              v14 = 0;
            }
            LOBYTE(v87[1]) = v14;
            v15 = v89;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<6,unsigned long long>((uint64_t)this, &v90);
            v84 = 0xFFFFFFFFFFFFFFFFLL;
            if ((v15 & 1) != 0)
            {
              re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<8,unsigned long long>((uint64_t)this, &v84);
              re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<9,unsigned long long>((uint64_t)this, (_QWORD *)&v84 + 1);
            }
            v82 = 0;
            v83 = 0;
            v16 = (re *)re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<11,re::Slice<unsigned char>>((uint64_t)this, &v82);
            if (*((_QWORD *)this + 3) == *((_QWORD *)this + 2))
            {
              v74 = *re::networkLogObjects(v16);
              shouldAcceptUpdate = os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
              if (!(_DWORD)shouldAcceptUpdate)
                goto LABEL_103;
              *(_WORD *)buf = 0;
              v75 = "Failed to unpack sync object.";
LABEL_108:
              _os_log_error_impl(&dword_21C69B000, v74, OS_LOG_TYPE_ERROR, v75, buf, 2u);
LABEL_103:
              v71 = *re::networkLogObjects((re *)shouldAcceptUpdate);
              result = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
              if ((_DWORD)result)
              {
                *(_WORD *)buf = 0;
                v73 = "Failure reading object in commit";
LABEL_105:
                _os_log_error_impl(&dword_21C69B000, v71, OS_LOG_TYPE_ERROR, v73, buf, 2u);
                return 0;
              }
              return result;
            }
            re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
            v17 = *(re::SyncObjectStore **)a1;
            *(_QWORD *)buf = v90;
            v18 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v17 + 504, (uint64_t *)buf);
            if (!v18 || (v19 = *(_QWORD *)(*(_QWORD *)v18 + 16)) == 0)
            {
              v20 = *re::networkLogObjects(v18);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v90;
                _os_log_impl(&dword_21C69B000, v20, OS_LOG_TYPE_DEFAULT, "Unknown object typeID=%llu. Assuming opaque type.", buf, 0xCu);
              }
              v21 = *(re::SyncObjectStore **)a1;
              re::SyncOpaqueTypeInfo::make(v90, (uint64_t)buf);
              re::SyncObjectStore::addType(v21, (const re::SyncObjectTypeInfo *)buf);
              re::SyncObjectTypeInfo::~SyncObjectTypeInfo((re::SyncObjectTypeInfo *)buf);
              v22 = *(re::SyncObjectStore **)a1;
              *(_QWORD *)buf = v90;
              v23 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v22 + 504, (uint64_t *)buf);
              if (v23)
                v19 = *(_QWORD *)(*(_QWORD *)v23 + 16);
              else
                v19 = 0;
            }
            v24 = *(_QWORD *)(v19 + 136);
          }
          while (v24 && !(*(unsigned int (**)(uint64_t, uint64_t))(v24 + 16))(v24, a4));
          Object = re::SyncObjectStore::findObject(*(re::SyncObjectStore **)a1, (uint64_t)v90, v11, (re::SyncObjectTypedStore ***)&v81);
          v26 = v81;
          v27 = v81;
          if (!v81)
            break;
LABEL_27:
          shouldAcceptUpdate = re::SyncObject::shouldAcceptUpdate(v27, v86[1], v87[0]);
          if (*(_BYTE *)(a1 + 73) || (_DWORD)shouldAcceptUpdate)
          {
            if ((_DWORD)shouldAcceptUpdate
              && (v34 = *(_QWORD *)(a1 + 16),
                  v35 = *((unsigned __int16 *)v27 + 84),
                  v36 = *(_OWORD *)v86,
                  *(_OWORD *)((char *)v27 + 136) = v85,
                  *(_OWORD *)((char *)v27 + 152) = v36,
                  *((_DWORD *)v27 + 42) = *(_DWORD *)v87,
                  *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v27 + 11) + 16) + 73))
              && (v35 < v87[0] || ((_QWORD)v85 == v34 ? (v37 = (_QWORD)v85 == 0) : (v37 = 1), !v37)))
            {
              v38 = 4;
            }
            else
            {
              v38 = 0;
            }
            isStateDataChanged = re::SyncObject::isStateDataChanged(v27, v88, *(_QWORD *)(a1 + 8));
            if (isStateDataChanged)
            {
              v40 = v88;
              v76 = v38;
              v41 = v82;
              v42 = a4;
              v43 = v83;
              v44 = (re::BitWriter *)re::SyncObject::addState(v27, v88, *(_QWORD *)(a1 + 8));
              *((_WORD *)v27 + 88) = v40;
              v45 = (const void *)v41;
              v38 = v76;
              v46 = v43;
              a4 = v42;
              re::BitWriter::writeData(v44, v45, v46);
            }
            v47 = re::SyncObject::latestStateHandle(v27);
            if (v47 == -1)
            {
              v55 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
              shouldAcceptUpdate = os_log_type_enabled(v55, OS_LOG_TYPE_ERROR);
              if ((_DWORD)shouldAcceptUpdate)
              {
                v65 = *((_QWORD *)v27 + 3);
                v66 = *(_QWORD **)(*((_QWORD *)v27 + 11) + 16);
                v67 = v66[4];
                v68 = v66[6];
                v69 = (re::SyncOpaqueTypeInfo *)v66[7];
                v70 = (re::SyncOpaqueTypeInfo *)((char *)v66 + 49);
                if ((v68 & 1) != 0)
                  v70 = v69;
                *(_DWORD *)buf = 134218498;
                *(_QWORD *)&buf[4] = v65;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v67;
                *(_WORD *)&buf[22] = 2080;
                v92 = v70;
                _os_log_error_impl(&dword_21C69B000, v55, OS_LOG_TYPE_ERROR, "Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).", buf, 0x20u);
                v29 = 0;
LABEL_82:

                goto LABEL_83;
              }
              v29 = 0;
            }
            else
            {
              v48 = v47;
              v49 = v26 == 0;
              memset(buf, 0, 17);
              re::SharedPtr<re::SyncObject>::reset((uint64_t *)buf, (uint64_t)v27);
              *(_QWORD *)&buf[8] = v48;
              if (isStateDataChanged)
                v50 = 8;
              else
                v50 = 0;
              v51 = v38 | v49 | v50 | buf[16] & 0xF2;
              buf[16] = v51;
              if ((v15 & 4) != 0)
              {
                *((_BYTE *)v27 + 128) |= 4u;
                buf[16] = v51 | 2;
              }
              shouldAcceptUpdate = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v77, (uint64_t)buf);
              if (*((_QWORD *)&v84 + 1) && !*((_QWORD *)v27 + 10))
              {
                re::SyncObjectStore::findObject(*(re::SyncObjectStore **)a1, (uint64_t)v90, *((uint64_t *)&v84 + 1), (re::SyncObjectTypedStore ***)&v80);
                v52 = v80;
                if (v80)
                {
                  re::SyncObject::bindWithParent(v27, v80);

                }
                else
                {
                  v79 = v84;
                  shouldAcceptUpdate = re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(a1 + 24, (uint64_t *)&v81, &v79);
                }
              }
              if (*(_QWORD *)buf)

              v29 = 2;
              v27 = v81;
            }
          }
          else
          {
            v29 = 2;
          }
          if (v27)
            goto LABEL_82;
LABEL_83:
          if (!v29)
            goto LABEL_103;
        }
        if ((v15 & 4) != 0)
          break;
        v30 = *(re::SyncObjectStore **)a1;
        *(_QWORD *)buf = v11;
        *(_QWORD *)&buf[8] = v90;
        *(_QWORD *)&buf[16] = 0;
        v31 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)v30 + 600, (uint64_t *)buf);
        if (v31)
        {
          v32 = *re::networkLogObjects((re *)v31);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            if ((*(_BYTE *)(v19 + 48) & 1) != 0)
              v33 = *(_QWORD *)(v19 + 56);
            else
              v33 = v19 + 49;
            *(_DWORD *)buf = 134218498;
            *(_QWORD *)&buf[4] = v11;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v33;
            *(_WORD *)&buf[22] = 2048;
            v92 = v90;
            v60 = v32;
            v61 = "Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)";
LABEL_73:
            v64 = 32;
            goto LABEL_74;
          }
        }
        else
        {
          v56 = *(re::SyncObjectStore **)a1;
          *(_QWORD *)buf = *((_QWORD *)&v84 + 1);
          *(_QWORD *)&buf[8] = v84;
          *(_QWORD *)&buf[16] = 0;
          v57 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)v56 + 600, (uint64_t *)buf);
          if (v57)
          {
            v58 = *re::networkLogObjects((re *)v57);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
            {
              if ((*(_BYTE *)(v19 + 48) & 1) != 0)
                v59 = *(_QWORD *)(v19 + 56);
              else
                v59 = v19 + 49;
              *(_DWORD *)buf = 134218754;
              *(_QWORD *)&buf[4] = v11;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v59;
              *(_WORD *)&buf[22] = 2048;
              v92 = v90;
              v93 = 2048;
              v94 = *((_QWORD *)&v84 + 1);
              v60 = v58;
              v61 = "Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu";
              v64 = 42;
LABEL_74:
              _os_log_impl(&dword_21C69B000, v60, OS_LOG_TYPE_DEFAULT, v61, buf, v64);
            }
          }
          else
          {
            if ((v15 & 1) != 0)
            {
              re::SyncObjectStore::createIncomingObject(*(re::SyncObjectStore **)a1, (const re::SyncOwnershipInfo *)&v85, (unint64_t)v90, v11, (uint64_t *)buf);
              v27 = *(re::SyncObject **)buf;
              v81 = *(re::SyncObject **)buf;
              goto LABEL_27;
            }
            v62 = *re::networkLogObjects((re *)v57);
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
            {
              if ((*(_BYTE *)(v19 + 48) & 1) != 0)
                v63 = *(_QWORD *)(v19 + 56);
              else
                v63 = v19 + 49;
              *(_DWORD *)buf = 134218498;
              *(_QWORD *)&buf[4] = v11;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v63;
              *(_WORD *)&buf[22] = 2048;
              v92 = v90;
              _os_log_impl(&dword_21C69B000, v62, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
            }
          }
        }
      }
      v53 = *re::networkLogObjects((re *)Object);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        if ((*(_BYTE *)(v19 + 48) & 1) != 0)
          v54 = *(_QWORD *)(v19 + 56);
        else
          v54 = v19 + 49;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v11;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v54;
        *(_WORD *)&buf[22] = 2048;
        v92 = v90;
        v60 = v53;
        v61 = "Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)";
        goto LABEL_73;
      }
    }
  }
  v71 = *re::networkLogObjects(v9);
  result = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    *(_WORD *)buf = 0;
    v73 = "Expected dictionary of entries";
    goto LABEL_105;
  }
  return result;
}

double RESyncServiceObserverCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;
  double result;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 80, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E073530;
  result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_QWORD *)(v2 + 72) = 0;
  return result;
}

double RESyncServiceAddObserver(_DWORD *a1, uint64_t a2, double result)
{
  _DWORD *v5;
  double v6;
  _DWORD *v7;
  double v8;
  _anonymous_namespace_ *v9;
  __n128 v10;
  _anonymous_namespace_ *v11;
  __n128 v12;
  _anonymous_namespace_ *v13;
  double v14;
  _anonymous_namespace_ *v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (a1 && a2)
  {
    v5 = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 32))(a1);
    v18 = a2;
    *(_QWORD *)&v19 = re::ServiceObserverProxy::didAdd;
    *((_QWORD *)&v19 + 1) = 0;
    *(_QWORD *)&v20 = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke;
    v6 = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::addSubscription(v5, (uint64_t)&v18);
    v7 = (_DWORD *)(*(uint64_t (**)(_DWORD *, double))(*(_QWORD *)a1 + 40))(a1, v6);
    v18 = a2;
    *(_QWORD *)&v19 = re::ServiceObserverProxy::willRemove;
    *((_QWORD *)&v19 + 1) = 0;
    *(_QWORD *)&v20 = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke;
    v8 = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::addSubscription(v7, (uint64_t)&v18);
    v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, double))(*(_QWORD *)a1 + 48))(a1, v8);
    *(_QWORD *)&v16 = a2;
    *((_QWORD *)&v16 + 1) = re::ServiceObserverProxy::didReceiveOwnershipRequest;
    *(_QWORD *)&v17 = 0;
    *((_QWORD *)&v17 + 1) = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,void const*&&,unsigned long &&,BOOL &)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v9, &v16, (uint64_t)&v18);
    if (!(_BYTE)v18)
    {
      if (*((_DWORD *)v9 + 20))
      {
        LOBYTE(v18) = 1;
        v19 = v16;
        v20 = v17;
        v10 = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)v9 + 40, (uint64_t)&v18);
      }
      else
      {
        v10 = re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add(v9, (uint64_t)&v16);
      }
    }
    v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, __n128))(*(_QWORD *)a1 + 56))(a1, v10);
    *(_QWORD *)&v16 = a2;
    *((_QWORD *)&v16 + 1) = re::ServiceObserverProxy::didReceiveOwnershipResponse;
    *(_QWORD *)&v17 = 0;
    *((_QWORD *)&v17 + 1) = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,re::OwnershipResponseResult&&)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v11, &v16, (uint64_t)&v18);
    if (!(_BYTE)v18)
    {
      if (*((_DWORD *)v11 + 20))
      {
        LOBYTE(v18) = 1;
        v19 = v16;
        v20 = v17;
        v12 = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)v11 + 40, (uint64_t)&v18);
      }
      else
      {
        v12 = re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add(v11, (uint64_t)&v16);
      }
    }
    v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, __n128))(*(_QWORD *)a1 + 64))(a1, v12);
    v18 = a2;
    *(_QWORD *)&v19 = re::ServiceObserverProxy::didReceiveOwnershipHandoff;
    *((_QWORD *)&v19 + 1) = 0;
    *(_QWORD *)&v20 = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&)#1}::__invoke;
    v14 = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::addSubscription(v13, (uint64_t)&v18);
    v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, double))(*(_QWORD *)a1 + 72))(a1, v14);
    v18 = a2;
    *(_QWORD *)&v19 = re::ServiceObserverProxy::didReceiveOwnershipChange;
    *((_QWORD *)&v19 + 1) = 0;
    *(_QWORD *)&v20 = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&)#1}::__invoke;
    re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::addSubscription(v15, (uint64_t)&v18);
    *(_QWORD *)&v16 = a2;
    *((_QWORD *)&v16 + 1) = re::ServiceObserverProxy::dataDidArrive;
    *(_QWORD *)&v17 = 0;
    *((_QWORD *)&v17 + 1) = re::Event<re::NetworkSyncService>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService>::Subscription const&)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)(a1 + 84), &v16, (uint64_t)&v18);
    if (!(_BYTE)v18)
    {
      if (a1[104])
      {
        LOBYTE(v18) = 1;
        v19 = v16;
        v20 = v17;
        *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)(a1 + 94), (uint64_t)&v18).n128_u64[0];
      }
      else
      {
        *(_QWORD *)&result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)(a1 + 84), (uint64_t)&v16).n128_u64[0];
      }
    }
  }
  return result;
}

uint64_t re::ServiceObserverProxy::didAdd(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 24);
  if (v3)
    (*(void (**)(uint64_t, _QWORD))(v3 + 16))(v3, *a3);
  return 0;
}

uint64_t re::ServiceObserverProxy::willRemove(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
    (*(void (**)(uint64_t, _QWORD))(v3 + 16))(v3, *a3);
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipRequest(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, a2, *a3);
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipResponse(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 48);
  if (v3)
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, a2, *a3);
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipHandoff(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 56);
  if (v3)
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, a2, *a3);
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipChange(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 64);
  if (v3)
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, a2, *a3);
  return 0;
}

uint64_t re::ServiceObserverProxy::dataDidArrive(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 72);
  if (v1)
    (*(void (**)(void))(v1 + 16))();
  return 0;
}

void RESyncServiceRemoveObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __int128 *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v19;
  unint64_t v20;
  __int128 *v21;
  __int128 v22;
  _BYTE v23[8];
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (a1 && a2)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
    re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::unsubscribe<re::ServiceObserverProxy>(v4, a2);
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::unsubscribe<re::ServiceObserverProxy>(v5, a2);
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v6, a2);
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v7, a2);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    if (*(_QWORD *)(v8 + 16))
    {
      v9 = v8;
      v10 = 0;
      v11 = v8 + 40;
      do
      {
        v12 = (__int128 *)(*(_QWORD *)(v9 + 32) + 32 * v10);
        if (*(_QWORD *)v12 == a2)
        {
          if (!*(_DWORD *)(v9 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)v9, v10);
            continue;
          }
          v23[0] = 0;
          v13 = v12[1];
          v24 = *v12;
          v25 = v13;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v11, (uint64_t)v23);
        }
        ++v10;
      }
      while (v10 < *(_QWORD *)(v9 + 16));
    }
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
    if (*(_QWORD *)(v14 + 16))
    {
      v15 = v14;
      v16 = 0;
      v17 = v14 + 40;
      do
      {
        v18 = (__int128 *)(*(_QWORD *)(v15 + 32) + 32 * v16);
        if (*(_QWORD *)v18 == a2)
        {
          if (!*(_DWORD *)(v15 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)v15, v16);
            continue;
          }
          v23[0] = 0;
          v19 = v18[1];
          v24 = *v18;
          v25 = v19;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v17, (uint64_t)v23);
        }
        ++v16;
      }
      while (v16 < *(_QWORD *)(v15 + 16));
    }
    if (*(_QWORD *)(a1 + 352))
    {
      v20 = 0;
      do
      {
        v21 = (__int128 *)(*(_QWORD *)(a1 + 368) + 32 * v20);
        if (*(_QWORD *)v21 == a2)
        {
          if (!*(_DWORD *)(a1 + 416))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)(a1 + 336), v20);
            continue;
          }
          v23[0] = 0;
          v22 = v21[1];
          v24 = *v21;
          v25 = v22;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(a1 + 376, (uint64_t)v23);
        }
        ++v20;
      }
      while (v20 < *(_QWORD *)(a1 + 352));
    }
  }
}

void re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::unsubscribe<re::ServiceObserverProxy>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _anonymous_namespace_ *v5;
  __int128 *v6;
  __int128 v7;
  _BYTE v8[8];
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 16))
  {
    v4 = 0;
    v5 = (_anonymous_namespace_ *)(a1 + 40);
    do
    {
      v6 = (__int128 *)(*(_QWORD *)(a1 + 32) + 32 * v4);
      if (*(_QWORD *)v6 == a2)
      {
        if (!*(_DWORD *)(a1 + 80))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)a1, v4);
          continue;
        }
        v8[0] = 0;
        v7 = v6[1];
        v9 = *v6;
        v10 = v7;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription,true>>::add(v5, (uint64_t)v8);
      }
      ++v4;
    }
    while (v4 < *(_QWORD *)(a1 + 16));
  }
}

void *RESyncServiceObserverOnSessionDidAdd(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 24);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

void *RESyncServiceObserverOnSessionWillRemove(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 32);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void *RESyncServiceObserverOnSessionDidReceiveOwnershipRequest(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 40);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void *RESyncServiceObserverOnSessionDidReceiveOwnershipResponse(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 48);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 48) = result;
  return result;
}

void RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff(re *a1, const void *a2)
{
  const void *v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff";
    v8 = 2080;
    v9 = "observer != __null";
    goto LABEL_10;
  }
  if (!a2)
  {
    v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff";
    v8 = 2080;
    v9 = "sessionDidReceiveOwnershipHandoff != __null";
LABEL_10:
    _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  v4 = (const void *)*((_QWORD *)a1 + 7);
  if (v4 != a2)
  {
    _Block_release(v4);
    *((_QWORD *)a1 + 7) = _Block_copy(a2);
  }
}

void RESyncServiceObserverOnSessionDidReceiveOwnershipChange(re *a1, const void *a2)
{
  const void *v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipChange";
    v8 = 2080;
    v9 = "observer != __null";
    goto LABEL_10;
  }
  if (!a2)
  {
    v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    v6 = 136315394;
    v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipChange";
    v8 = 2080;
    v9 = "sessionDidReceiveOwnershipChange != __null";
LABEL_10:
    _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  v4 = (const void *)*((_QWORD *)a1 + 8);
  if (v4 != a2)
  {
    _Block_release(v4);
    *((_QWORD *)a1 + 8) = _Block_copy(a2);
  }
}

void *RESyncServiceObserverOnDataArrive(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 72);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

void RESyncTransferReportObserverCreate(re *a1)
{
  uint64_t *v1;
  uint64_t v2;

  v1 = re::globalAllocators(a1);
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 32, 8);
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(_QWORD *)v2 = &off_24E073578;
  *(_QWORD *)(v2 + 24) = 0;
}

double RESyncServiceAddTransferReportObserver(uint64_t a1, uint64_t a2)
{
  _anonymous_namespace_ *v3;
  double result;
  __int128 v5;
  __int128 v6;
  char v7[8];
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a2)
    {
      v3 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
      *(_QWORD *)&v5 = a2;
      *((_QWORD *)&v5 + 1) = re::TransferReportObserverProxy::onTransferReportSend;
      *(_QWORD *)&v6 = 0;
      *((_QWORD *)&v6 + 1) = re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::createSubscription<re::TransferReportObserverProxy>(re::TransferReportObserverProxy *,REEventHandlerResult (re::TransferReportObserverProxy::*)(re::NetworkSyncService*,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::Subscription const&,re::Session *&&,unsigned long long &&,re::Session *&&,re::Session *&&,re::Session *&&,unsigned int &&)#1}::__invoke;
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, &v5, (uint64_t)v7);
      if (!v7[0])
      {
        if (*((_DWORD *)v3 + 20))
        {
          v7[0] = 1;
          v8 = v5;
          v9 = v6;
          *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)v3 + 40, (uint64_t)v7).n128_u64[0];
        }
        else
        {
          *(_QWORD *)&result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v3, (uint64_t)&v5).n128_u64[0];
        }
      }
    }
  }
  return result;
}

uint64_t re::TransferReportObserverProxy::onTransferReportSend(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    (*(void (**)(void))(v1 + 16))();
  return 0;
}

void RESyncServiceRemoveTransferReportObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  const void *v9;
  _BYTE v10[8];
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (a1 && a2)
  {
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
    if (*(_QWORD *)(v3 + 16))
    {
      v4 = v3;
      v5 = 0;
      v6 = v3 + 40;
      do
      {
        v7 = (__int128 *)(*(_QWORD *)(v4 + 32) + 32 * v5);
        if (*(_QWORD *)v7 == a2)
        {
          if (!*(_DWORD *)(v4 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((_QWORD *)v4, v5);
            continue;
          }
          v10[0] = 0;
          v8 = v7[1];
          v11 = *v7;
          v12 = v8;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v6, (uint64_t)v10);
        }
        ++v5;
      }
      while (v5 < *(_QWORD *)(v4 + 16));
    }
    v9 = *(const void **)(a2 + 24);
    if (v9)
    {
      _Block_release(v9);
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
}

void *RESyncTransferReportObserverOnTransferReportSend(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 24);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

uint64_t RESyncServiceStartSyncWithSession(re *a1, uint64_t a2)
{
  id v3;
  uint64_t v4;
  NSObject *v6;
  uint64_t v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136315394;
    v9 = "RESyncServiceStartSyncWithSession";
    v10 = 2080;
    v11 = "service != __null";
LABEL_11:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  if (!a2)
  {
    v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136315394;
    v9 = "RESyncServiceStartSyncWithSession";
    v10 = 2080;
    v11 = "session != __null";
    goto LABEL_11;
  }
  v7 = a2;
  v3 = (id)(a2 + 8);
  v4 = (*(uint64_t (**)(re *, uint64_t *))(*(_QWORD *)a1 + 88))(a1, &v7);
  if (v7)

  return v4;
}

uint64_t RESyncServiceCreateSessionAndStartSync(re *a1, uint64_t a2)
{
  uint64_t v2;
  id v3;
  NSObject *v5;
  _BYTE v6[12];
  __int16 v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)v6 = 136315394;
    *(_QWORD *)&v6[4] = "RESyncServiceCreateSessionAndStartSync";
    v7 = 2080;
    v8 = "service != nullptr";
LABEL_11:
    _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", v6, 0x16u);
    return 0;
  }
  if (!a2)
  {
    v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)v6 = 136315394;
    *(_QWORD *)&v6[4] = "RESyncServiceCreateSessionAndStartSync";
    v7 = 2080;
    v8 = "configuration != nullptr";
    goto LABEL_11;
  }
  (*(void (**)(_BYTE *__return_ptr, re *, uint64_t))(*(_QWORD *)a1 + 104))(v6, a1, a2 + 24);
  v2 = *(_QWORD *)v6;
  v3 = (id)(*(_QWORD *)v6 + 8);
  if (*(_QWORD *)v6)

  return v2;
}

uint64_t RESyncServiceCreateSyncSession(re *a1, uint64_t a2)
{
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  char *v10;
  char *v11;
  uint64_t *v12;
  uint64_t v13;
  NSObject *v15;
  _BYTE v16[24];
  char v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  re *v21;
  char v22;
  int v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v15 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)v16 = 136315394;
    *(_QWORD *)&v16[4] = "RESyncServiceCreateSyncSession";
    *(_WORD *)&v16[12] = 2080;
    *(_QWORD *)&v16[14] = "service != __null";
LABEL_18:
    _os_log_error_impl(&dword_21C69B000, v15, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", v16, 0x16u);
    return 0;
  }
  if (!a2)
  {
    v15 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)v16 = 136315394;
    *(_QWORD *)&v16[4] = "RESyncServiceCreateSyncSession";
    *(_WORD *)&v16[12] = 2080;
    *(_QWORD *)&v16[14] = "session != __null";
    goto LABEL_18;
  }
  v4 = (void *)(a2 + 8);
  v5 = (id)(a2 + 8);
  *(_OWORD *)v16 = xmmword_21C702DE0;
  *(_QWORD *)&v16[16] = 0xFFFFFFFF00010000;
  v17 = 0;
  v18 = a2;
  v6 = v4;
  v7 = (*(uint64_t (**)(re *))(*(_QWORD *)a1 + 152))(a1);
  v8 = v7;
  v19 = v7;
  if (v7)
    v9 = (id)(v7 + 8);
  v10 = (char *)(*(uint64_t (**)(re *))(*(_QWORD *)a1 + 160))(a1);
  v11 = v10;
  v20 = v10;
  if (v10)
    v10 = v10 + 8;
  v21 = a1;
  v22 = *(_BYTE *)(a2 + 2223);
  v23 = *(_DWORD *)(a2 + 2224);
  v24 = *(_BYTE *)(a2 + 2237);
  v12 = re::globalAllocators((re *)v10);
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12[2] + 32))(v12[2], 664, 8);
  re::SyncObjectManager::SyncObjectManager(v13, (__int128 *)v16);
  if (v11)

  if (v8)
  return v13;
}

uint64_t RESyncServiceStartSync(re *a1, uint64_t a2)
{
  id v3;
  uint64_t v4;
  NSObject *v6;
  uint64_t v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!a1)
  {
    v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136315394;
    v9 = "RESyncServiceStartSync";
    v10 = 2080;
    v11 = "service != __null";
LABEL_11:
    _os_log_error_impl(&dword_21C69B000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  if (!a2)
  {
    v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136315394;
    v9 = "RESyncServiceStartSync";
    v10 = 2080;
    v11 = "session != __null";
    goto LABEL_11;
  }
  v7 = a2;
  v3 = (id)(a2 + 8);
  v4 = (*(uint64_t (**)(re *, uint64_t *))(*(_QWORD *)a1 + 96))(a1, &v7);
  if (v7)

  return v4;
}

void RESyncServiceStopSyncWithSession(uint64_t a1, uint64_t a2)
{
  id v3;
  uint64_t v4;

  v4 = a2;
  if (a2)
    v3 = (id)(a2 + 8);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 112))(a1, &v4);
  if (v4)

}

uint64_t RESyncServiceStopSync(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1);
}

uint64_t RESyncServiceGetSyncSession(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;

  result = 0;
  if (a1 && a2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
    if (v5)
    {
      v6 = v5;
      v7 = 0;
      while (1)
      {
        v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
        if (v9 <= v7)
        {
          re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, v9);
          _os_crash();
          __break(1u);
          goto LABEL_15;
        }
        (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(v8 + 8 * v7) + 32))(&v13);
        v10 = v13;
        if (v13)

        if (v10 == a2)
          break;
        if (v6 == ++v7)
          return 0;
      }
      v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 128))(a1);
      if (v12 > v7)
        return *(_QWORD *)(v11 + 8 * v7);
LABEL_15:
      re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, v12);
      result = _os_crash();
      __break(1u);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *RESyncServiceConfigCreateNoAlloc(_QWORD *a1, unint64_t a2)
{
  _QWORD *v2;

  v2 = 0;
  if (a1 && a2 >= 0x18)
  {
    *a1 = 0;
    a1[1] = 0;
    v2 = a1;
    a1[2] = 0;
  }
  return v2;
}

re::SyncObjectStore *RESyncServiceConfigCreateDefaultNoAlloc(_QWORD *a1, unint64_t a2)
{
  re::SyncObjectStore *result;
  uint64_t *v4;
  uint64_t v5;

  result = 0;
  if (a1 && a2 >= 0x18)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    v4 = re::globalAllocators(0);
    v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 648, 8);
    result = re::SyncObjectStore::SyncObjectStore((re::SyncObjectStore *)v5);
    if (result)
    {
      re::SharedPtr<re::SyncObject>::reset(a1 + 1, v5);

      return (re::SyncObjectStore *)a1;
    }
  }
  return result;
}

void RESyncServiceConfigDestruct(uint64_t a1)
{
  uint64_t v2;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {

      *(_QWORD *)(a1 + 8) = 0;
    }
  }
}

uint64_t RESyncServiceConfigGetSize()
{
  return 24;
}

_QWORD *RESyncServiceConfigSetSchemaHash(_QWORD *result, uint64_t a2)
{
  if (result)
    *result = a2;
  return result;
}

uint64_t RESyncServiceConfigSetDispatchQueue(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2)
      *(_QWORD *)(result + 16) = a2;
  }
  return result;
}

uint64_t RESyncCreateSyncService(re *a1)
{
  uint64_t *v2;
  uint64_t v3;

  v2 = re::globalAllocators(a1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 864, 8);
  re::NetworkSyncManager::NetworkSyncManager((re::NetworkSyncManager *)v3);
  if (a1 && v3)
  {
    re::NetworkSyncManager::init(v3, (uint64_t *)a1);
  }
  else if (v3)
  {

    return 0;
  }
  return v3;
}

uint64_t RESyncServiceRemoveSyncable(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;

  result = 1;
  if (a1 && a2)
  {
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 152))(a1);
    if (v5)
    {
      v6 = v5;
      v8 = a2;
      v7 = a2 + 1;
      re::SyncObjectStore::removeObject(v6, (uint64_t *)&v8);

      re::SyncObject::unbindFromParent(a2);
      return 0;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

re::NetworkSyncManager *RESyncServiceCreateWithDefaultConfig(re *a1)
{
  uint64_t *v1;
  re::NetworkSyncManager *v2;
  re *v3;
  uint64_t *v4;
  uint64_t v5;
  void *v6;
  uint64_t v8;
  uint64_t v9[2];

  v1 = re::globalAllocators(a1);
  v2 = (re::NetworkSyncManager *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 864, 8);
  re::NetworkSyncManager::NetworkSyncManager(v2);
  if (v3)
  {
    v4 = re::globalAllocators(v3);
    v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 648, 8);
    if (re::SyncObjectStore::SyncObjectStore((re::SyncObjectStore *)v5))
    {
      v8 = 0;
      v9[0] = 0;
      v9[1] = MEMORY[0x24BDAC9B8];
      re::SharedPtr<re::SyncObject>::reset(v9, v5);
      re::NetworkSyncManager::init((uint64_t)v2, &v8);
      if (v9[0])

    }
    else
    {
      v6 = (char *)v2 + 8;

      return 0;
    }
  }
  return v2;
}

uint64_t RESyncServiceRegisterTypeInfo(uint64_t a1, re::SyncObjectTypeInfo *a2)
{
  uint64_t result;
  uint64_t v5;
  re::SyncObjectStore *v6;
  uint64_t v7;
  uint64_t v8;

  result = 1;
  if (a1 && a2)
  {
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 152))(a1);
    if (v5)
    {
      v6 = (re::SyncObjectStore *)v5;
      v8 = *((_QWORD *)a2 + 4);
      v7 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v5 + 504, &v8);
      if (v7 && *(_QWORD *)(*(_QWORD *)v7 + 16))
      {
        return 3;
      }
      else
      {
        re::SyncObjectStore::addType(v6, a2);
        return 0;
      }
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t RESyncServiceGetTypeInfo(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  if (result)
  {
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 152))(result);
    v4 = a2;
    result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v3 + 504, &v4);
    if (result)
    {
      if (*(_QWORD *)result)
        return *(_QWORD *)(*(_QWORD *)result + 16);
      else
        return 0;
    }
  }
  return result;
}

uint64_t RESyncServiceGetSessionCount(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)result + 128))(result);
    return v1;
  }
  return result;
}

uint64_t RESyncServiceGetSession(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  if (result)
  {
    v3 = result;
    (*(void (**)(uint64_t))(*(_QWORD *)result + 128))(result);
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 128))(v3);
    if (v5 <= a2)
    {
      re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a2, v5);
      result = _os_crash();
      __break(1u);
    }
    else
    {
      return *(_QWORD *)(v4 + 8 * a2);
    }
  }
  return result;
}

uint64_t RESyncServiceCreateSyncableWithTypeInfo(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 152))(a1))
    return RESyncServiceCreateSyncableWithTypeId(a1, *(_QWORD *)(a2 + 32));
  else
    return 0;
}

uint64_t RESyncServiceCreateSyncableWithTypeId(uint64_t result, unint64_t a2)
{
  re::SyncObjectStore *v3;
  unint64_t v4;

  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 152))(result);
    if (result)
    {
      v3 = (re::SyncObjectStore *)result;
      v4 = a2;
      result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(result + 504, (uint64_t *)&v4);
      if (result)
      {
        if (*(_QWORD *)(*(_QWORD *)result + 16))
        {
          re::SyncObjectStore::create(v3, a2, (uint64_t *)&v4);
          return v4;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t RESyncServiceCreateIncomingSyncable(uint64_t result, unint64_t a2, uint64_t a3)
{
  re::SyncObjectStore *v5;
  unint64_t v6;
  __int16 v7;
  char v8;
  uint64_t v9;
  int v10;
  uuid_t out;

  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 152))(result);
    if (result)
    {
      v5 = (re::SyncObjectStore *)result;
      v6 = a2;
      result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(result + 504, (uint64_t *)&v6);
      if (result)
      {
        if (*(_QWORD *)(*(_QWORD *)result + 16))
        {
          v6 = 0;
          v7 = 0;
          v8 = 0;
          v10 = 0x10000;
          v9 = a3;
          uuid_generate_random(out);
          re::SyncObjectStore::createIncomingObject(v5, (const re::SyncOwnershipInfo *)&v6, a2, (*(_QWORD *)&out[8] + (*(_QWORD *)out << 6) + (*(_QWORD *)out >> 2) - 0x61C8864680B583E9) ^ *(_QWORD *)out, (uint64_t *)out);
          return *(_QWORD *)out;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t RESyncServiceRequestOwnership(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  uint64_t v15;

  if (result)
  {
    v10 = result;
    v11 = *(_QWORD *)(a2 + 80);
    v12 = a2;
    if (v11)
    {
      v13 = a2;
      do
      {
        v12 = v13;
        v13 = v11;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 88) + 16) + 73))
          break;
        v11 = *(_QWORD *)(v11 + 80);
        v12 = v13;
      }
      while (v11);
    }
    if (*(_QWORD *)(v12 + 160))
    {
      v15 = a2;
      if (a2)
        v14 = (id)(a2 + 8);
      (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, double))(*(_QWORD *)v10 + 136))(v10, &v15, a3, a4, a5, a6);
      if (v15)

      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t RESyncServiceAfterFrameUpdate(re::NetworkSyncManager *a1)
{
  if (!a1)
    return 1;
  re::NetworkSyncManager::afterFrameUpdate(a1);
  return 0;
}

uint64_t RESyncServiceBeforeFrameUpdate(re::RoutingTable **a1)
{
  if (!a1)
    return 1;
  re::NetworkSyncManager::beforeFrameUpdate(a1);
  return 0;
}

void RESyncServiceAddView(uint64_t a1, re::SyncView *a2)
{
  re::SyncViewManager *v3;

  if (a1)
  {
    if (a2)
    {
      v3 = (re::SyncViewManager *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
      re::SyncViewManager::addView(v3, a2);
    }
  }
}

void RESyncServiceRemoveView(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  if (a1)
  {
    if (a2)
    {
      v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
      re::SyncViewManager::removeView(v3, a2);
    }
  }
}

re::SyncObjectTypedStore **RESyncServiceFindSyncableWithGuid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::SyncObjectStore *v5;
  re::SyncObjectTypedStore **v6;
  re::SyncObjectTypedStore **v8;

  if (!a1)
    return 0;
  v5 = (re::SyncObjectStore *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 152))(a1);
  if (!v5)
    return 0;
  re::SyncObjectStore::findObject(v5, a2, a3, &v8);
  v6 = v8;
  if (v8)

  return v6;
}

_QWORD *RESyncServiceGetObjectCountForType(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v2 = result[7];
    v3 = a2;
    result = (_QWORD *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v2 + 504, &v3);
    if (result)
    {
      if (*result)
        return *(_QWORD **)(*result + 64);
      else
        return 0;
    }
  }
  return result;
}

uint64_t RESyncServiceGetLocalPeerId(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 168))(result);
  return result;
}

void re::ServiceObserverProxy::~ServiceObserverProxy(const void **this)
{
  re::ServiceObserverProxy::~ServiceObserverProxy(this);
  JUMPOUT(0x220780CD0);
}

{
  *this = &off_24E073530;
  _Block_release(this[3]);
  _Block_release(this[4]);
  _Block_release(this[5]);
  _Block_release(this[6]);
  _Block_release(this[7]);
  _Block_release(this[8]);
  _Block_release(this[9]);
  *this = &off_24E0707C0;
  objc_destructInstance(this + 1);
}

uint64_t re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t *);
  _QWORD *v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  uint64_t v11;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t *))a2[1];
  v4 = a2[2];
  v6 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t *))(*v6 + v5);
  v7 = *a3;
  v11 = v7;
  if (v7)
    v8 = (id)(v7 + 8);
  v9 = v5(v6, a1, &v11);
  if (v11)

  return v9;
}

uint64_t re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,void const*&&,unsigned long &&,BOOL &)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t (*v7)(_QWORD *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD);
  uint64_t v8;
  _QWORD *v9;

  v7 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))a2[1];
  v8 = a2[2];
  v9 = (_QWORD *)(*a2 + (v8 >> 1));
  if ((v8 & 1) != 0)
    v7 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(*v9 + v7);
  return v7(v9, a1, a3, *a4, *a5, *a6);
}

uint64_t re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,re::OwnershipResponseResult&&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4, unsigned __int8 *a5)
{
  uint64_t (*v6)(_QWORD *, uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v7;
  _QWORD *v8;

  v6 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t, _QWORD, _QWORD))a2[1];
  v7 = a2[2];
  v8 = (_QWORD *)(*a2 + (v7 >> 1));
  if ((v7 & 1) != 0)
    v6 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD, _QWORD))(*v8 + v6);
  return v6(v8, a1, a3, *a4, *a5);
}

double re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::addSubscription(_anonymous_namespace_ *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (*((_DWORD *)a1 + 20))
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)a1 + 40, (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add(a1, a2).n128_u64[0];
    }
  }
  return result;
}

uint64_t re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&)#1}::__invoke(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t, _QWORD);
  uint64_t v6;
  _QWORD *v7;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t, _QWORD))a2[1];
  v6 = a2[2];
  v7 = (_QWORD *)(*a2 + (v6 >> 1));
  if ((v6 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD))(*v7 + v5);
  return v5(v7, a1, a3, *a4);
}

uint64_t re::Event<re::NetworkSyncService>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

void re::TransferReportObserverProxy::~TransferReportObserverProxy(re::TransferReportObserverProxy *this)
{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::createSubscription<re::TransferReportObserverProxy>(re::TransferReportObserverProxy *,REEventHandlerResult (re::TransferReportObserverProxy::*)(re::NetworkSyncService*,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::Subscription const&,re::Session *&&,unsigned long long &&,re::Session *&&,re::Session *&&,re::Session *&&,unsigned int &&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7, unsigned int *a8)
{
  uint64_t (*v9)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v10;
  _QWORD *v11;

  v9 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a2[1];
  v10 = a2[2];
  v11 = (_QWORD *)(*a2 + (v10 >> 1));
  if ((v10 & 1) != 0)
    v9 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*v11 + v9);
  return v9(v11, a1, *a3, *a4, *a5, *a6, *a7, *a8);
}

uint64_t re::DebugDiscoveryView::DebugDiscoveryView(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  re *v7;
  uint64_t *v8;
  re::DebugDiscoveryIdentity *v9;
  re *v10;
  uint64_t v11;
  unint64_t v12;
  const re::Address *v13;
  uint64_t *v14;
  re::DebugDiscoveryIdentity *v15;
  re::DebugDiscoveryIdentity *v17;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24E0735C0;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 24), (const re::DynamicString *)a2);
  v4 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 56) = v4;
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 112) = 0;
  v5 = (_anonymous_namespace_ *)re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator=<24ul>(a1 + 80, a2 + 56);
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  v6 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 160), 0);
  ++*(_DWORD *)(a1 + 184);
  v7 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((_QWORD *)(a1 + 248), 0);
  ++*(_DWORD *)(a1 + 272);
  v8 = re::globalAllocators(v7);
  v9 = (re::DebugDiscoveryIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 64, 8);
  v17 = re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(v9, 1, (const re::Address *)(a1 + 24));
  v10 = (re *)re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add((_QWORD *)(a1 + 120), &v17);
  if (v17)

  if (*(_QWORD *)(a1 + 64))
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = (const re::Address *)(*(_QWORD *)(a1 + 56) + v11);
      v14 = re::globalAllocators(v10);
      v15 = (re::DebugDiscoveryIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14[2] + 32))(v14[2], 64, 8);
      v17 = re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(v15, 0, v13);
      v10 = (re *)re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add((_QWORD *)(a1 + 120), &v17);
      if (v17)

      ++v12;
      v11 += 32;
    }
    while (v12 < *(_QWORD *)(a1 + 64));
  }
  return a1;
}

void re::DebugDiscoveryView::~DebugDiscoveryView(re::DebugDiscoveryView *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &off_24E0735C0;
  v2 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v2)
  {
    v3 = *((_QWORD *)this + 19);
    v4 = 8 * v2;
    do
    {
      if (*(_QWORD *)v3)
      {

        *(_QWORD *)v3 = 0;
      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  v5 = *((_QWORD *)this + 31);
  ++*((_DWORD *)this + 36);
  if (v5)
  {
    if (*((_QWORD *)this + 35))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    *((_QWORD *)this + 31) = 0;
    ++*((_DWORD *)this + 68);
  }
  v6 = *((_QWORD *)this + 20);
  if (v6)
  {
    if (*((_QWORD *)this + 24))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 24) = 0;
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 20) = 0;
    ++*((_DWORD *)this + 46);
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 31);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((uint64_t *)this + 20);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 120);
  re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)this + 80);
  v7 = *((_QWORD *)this + 3);
  if (v7)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::DebugDiscoveryView::~DebugDiscoveryView(this);
  JUMPOUT(0x220780CD0);
}

void re::DebugDiscoveryView::requestIdentity(re *a1, const re::Address *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  BOOL v9;
  uint64_t *v10;
  re::DebugDiscoveryIdentity *v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  re::DebugDiscoveryIdentity *v15;
  char v16;

  v4 = *((_QWORD *)a1 + 17);
  if (v4)
  {
    v5 = (uint64_t *)*((_QWORD *)a1 + 19);
    v6 = 8 * v4;
    while (1)
    {
      v7 = *v5;
      if (*v5)
        v8 = (id)(v7 + 8);
      (*(void (**)(re::DebugDiscoveryIdentity **__return_ptr, uint64_t))(*(_QWORD *)v7 + 40))(&v15, v7);
      v9 = re::DynamicString::operator==((uint64_t)a2, (uint64_t)&v15);
      if (v15 && (v16 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v15 + 40))();

      if (v9)
        break;
      ++v5;
      v6 -= 8;
      if (!v6)
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    v10 = re::globalAllocators(a1);
    v11 = (re::DebugDiscoveryIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 64, 8);
    v15 = re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(v11, 0, a2);
    re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add((_QWORD *)a1 + 15, &v15);
    if (v15)

    v12 = *(_QWORD *)(*((_QWORD *)a1 + 19) + 8 * *((_QWORD *)a1 + 17) - 8);
    v14 = v12;
    if (v12)
      v13 = (id)(v12 + 8);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise((uint64_t)a1 + 160, (uint64_t)a1);
    if (v14)

  }
}

BOOL re::DebugDiscoveryView::removeIdentity(uint64_t a1, _QWORD *a2)
{
  _BOOL8 v4;
  id v5;
  uint64_t v7;

  v4 = re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::remove(a1 + 120, a2);
  if (v4)
  {
    v7 = *a2;
    if (*a2)
      v5 = (id)(*a2 + 8);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(a1 + 248, a1);
    if (v7)

  }
  return v4;
}

void re::DebugDiscoveryView::addIdentityWithAddress(re::DebugDiscoveryView *this, const re::Address *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  BOOL v9;
  uint64_t *v10;
  re::DebugDiscoveryIdentity *v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  re::DebugDiscoveryIdentity *v15;
  char v16;

  v4 = *((_QWORD *)this + 17);
  if (v4)
  {
    v5 = (uint64_t *)*((_QWORD *)this + 19);
    v6 = 8 * v4;
    while (1)
    {
      v7 = *v5;
      if (*v5)
        v8 = (id)(v7 + 8);
      (*(void (**)(re::DebugDiscoveryIdentity **__return_ptr, uint64_t))(*(_QWORD *)v7 + 40))(&v15, v7);
      v9 = re::DynamicString::operator==((uint64_t)a2, (uint64_t)&v15);
      if (v15 && (v16 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v15 + 40))();

      if (v9)
        break;
      ++v5;
      v6 -= 8;
      if (!v6)
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    v10 = re::globalAllocators(this);
    v11 = (re::DebugDiscoveryIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 64, 8);
    v15 = re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(v11, 0, a2);
    re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add((_QWORD *)this + 15, &v15);
    if (v15)

    v12 = *(_QWORD *)(*((_QWORD *)this + 19) + 8 * *((_QWORD *)this + 17) - 8);
    v14 = v12;
    if (v12)
      v13 = (id)(v12 + 8);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise((uint64_t)this + 160, (uint64_t)this);
    if (v14)

  }
}

void re::DebugDiscoveryView::removeIdentityWithAddress(re::DebugDiscoveryView *this, const re::Address *a2)
{
  unint64_t v4;
  _BOOL4 v5;
  unint64_t v6;
  uint64_t v7;
  id v8;
  id v9;
  uint64_t v10;
  _OWORD v11[5];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 17))
  {
    v4 = 0;
    while (1)
    {
      (*(void (**)(_OWORD *__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 19) + 8 * v4) + 40))(v11);
      v5 = re::DynamicString::operator==((uint64_t)a2, (uint64_t)v11);
      if (*(_QWORD *)&v11[0] && (BYTE8(v11[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
      v6 = *((_QWORD *)this + 17);
      if (v5)
        break;
      if (++v4 >= v6)
        return;
    }
    if (v6 <= v4)
    {
      memset(v11, 0, sizeof(v11));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v7 = *(_QWORD *)(*((_QWORD *)this + 19) + 8 * v4);
    if (v7)
    {
      v8 = (id)(v7 + 8);
      re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt((uint64_t)this + 120, v4);
      v10 = v7;
      v9 = (id)(v7 + 8);
    }
    else
    {
      re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt((uint64_t)this + 120, v4);
      v10 = 0;
    }
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise((uint64_t)this + 248, (uint64_t)this);
    if (v10)

    if (v7)
  }
}

_QWORD *re::DebugDiscoveryView::createProtocolLayer@<X0>(re::DebugDiscoveryView *this@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5;
  _QWORD *result;
  int v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  re::DebugProtocolLayer *v16;
  int v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v5 = *((_QWORD *)this + 14);
  if (v5)
    return (*(_QWORD *(**)(uint64_t *__return_ptr))(*(_QWORD *)v5 + 16))(a3);
  v7 = *((_DWORD *)this + 18);
  switch(v7)
  {
    case 4:
      LOBYTE(v17) = 1;
      v20 = 0;
      v21 = 0;
      v19 = 0;
      v12 = (re *)re::DynamicString::setCapacity(&v18, 0);
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v13 = re::globalAllocators(v12);
      v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13[2] + 32))(v13[2], 224, 8);
      v11 = re::NWProtocolLayer::NWProtocolLayer(v14, (uint64_t)&v17);
      break;
    case 3:
      v15 = re::globalAllocators(0);
      v16 = (re::DebugProtocolLayer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15[2] + 32))(v15[2], 184, 8);
      result = re::DebugProtocolLayer::DebugProtocolLayer(v16);
      *a3 = (uint64_t)result;
      return result;
    case 2:
      v17 = 128;
      v22 = 0;
      v9 = re::globalAllocators(v8);
      v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9[2] + 32))(v9[2], 208, 8);
      v11 = re::TcpProtocolLayer::TcpProtocolLayer(v10, (uint64_t)&v17);
      break;
    default:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not implemented", "!\"Unreachable code\"", "createProtocolLayer", 109);
      result = (_QWORD *)_os_crash();
      __break(1u);
      return result;
  }
  *a3 = v11;
  result = v18;
  if (v18)
  {
    if ((v19 & 1) != 0)
      return (_QWORD *)(*(uint64_t (**)(void))(*v18 + 40))();
  }
  return result;
}

uint64_t re::DebugDiscoveryView::createWithAddresses@<X0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  char v13;
  uint64_t v14;
  char v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  int v18;
  _BYTE v19[24];
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  re::DynamicString::DynamicString((re::DynamicString *)&v14, (const re::DynamicString *)&v12);
  if (v12 && (v13 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v12 + 40))();
  v16 = a1;
  v17 = a2;
  v18 = 2;
  v20 = *(_QWORD *)(a3 + 24);
  v21 = 0;
  v8 = (re *)re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator=<24ul>((uint64_t)v19, a3);
  v9 = re::globalAllocators(v8);
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9[2] + 32))(v9[2], 336, 8);
  *a4 = re::DebugDiscoveryView::DebugDiscoveryView(v10, (uint64_t)&v14);
  if (v21)
  {
    (**(void (***)(_BYTE *))v21)(v21);
    if (v21 != v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
    v21 = 0;
  }
  result = v14;
  if (v14)
  {
    if ((v15 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v14 + 40))();
  }
  return result;
}

uint64_t re::DebugDiscoveryView::didJoinEvent(re::DebugDiscoveryView *this)
{
  return (uint64_t)this + 160;
}

uint64_t re::DebugDiscoveryView::didLeaveEvent(re::DebugDiscoveryView *this)
{
  return (uint64_t)this + 248;
}

uint64_t re::DebugDiscoveryView::identitiesCount(re::DebugDiscoveryView *this)
{
  return *((_QWORD *)this + 17);
}

_QWORD *re::DebugDiscoveryView::identityAtIndex@<X0>(_QWORD *this@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  if (this[17] <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = *(_QWORD *)(this[19] + 8 * a2);
  *a3 = v3;
  if (v3)
    return (id)(v3 + 8);
  return this;
}

uint64_t re::DebugDiscoveryView::authData(re::DebugDiscoveryView *this)
{
  return 0;
}

uint64_t re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(a1);
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      v6 = a1;
      if (v5 >= 0x19)
      {
        v7 = v5;
        v8 = *(_QWORD *)(a1 + 24);
        if (v8)
          v6 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, v7, 0);
        else
          v6 = 0;
      }
      *(_QWORD *)(a1 + 32) = v6;
      (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 24))(*(_QWORD *)(a2 + 32));
    }
  }
  return a1;
}

re::DebugDiscoveryIdentity *re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(re::DebugDiscoveryIdentity *this, char a2, const re::Address *a3)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = off_24E073648;
  *((_BYTE *)this + 24) = a2;
  re::DynamicString::DynamicString((re::DebugDiscoveryIdentity *)((char *)this + 32), a3);
  return this;
}

void re::DebugDiscoveryIdentity::~DebugDiscoveryIdentity(re::DebugDiscoveryIdentity *this)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24E073648;
  v3 = (_OWORD *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 6));
    *v3 = 0u;
    v3[1] = 0u;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24E073648;
  v3 = (_OWORD *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 6));
    *v3 = 0u;
    v3[1] = 0u;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x220780CD0);
}

uint64_t re::DebugDiscoveryIdentity::displayName(re::DebugDiscoveryIdentity *this)
{
  if ((*((_BYTE *)this + 40) & 1) != 0)
    return *((_QWORD *)this + 6);
  else
    return (uint64_t)this + 41;
}

re::DynamicString *re::DebugDiscoveryIdentity::address@<X0>(re::DebugDiscoveryIdentity *this@<X0>, re::DynamicString *a2@<X8>)
{
  return re::DynamicString::DynamicString(a2, (re::DebugDiscoveryIdentity *)((char *)this + 32));
}

uint64_t re::DebugDiscoveryIdentity::isLocal(re::DebugDiscoveryIdentity *this)
{
  return *((unsigned __int8 *)this + 24);
}

uint64_t re::NetworkFeatureFlags::enableTransportLog(re::NetworkFeatureFlags *this)
{
  unsigned __int8 v1;
  void **p_cache;
  uint64_t v4;
  const char *v5;

  p_cache = MCSessionHandler.cache;
  if ((v1 & 1) == 0)
  {
    p_cache = (void **)(MCSessionHandler + 16);
    if ((_DWORD)v4)
    {
      re::NetworkFeatureFlags::enableTransportLog(void)::enable = re::NetworkFeatureFlags::enableTransportLog(void)::$_0::operator()(v4, v5);
      p_cache = (void **)(MCSessionHandler + 16);
    }
  }
  return *((unsigned __int8 *)p_cache + 2880);
}

BOOL re::NetworkFeatureFlags::enableTransportLog(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  re *v2;
  unsigned __int8 v3;
  NSObject *v4;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"network.transport.enableLog", a2, (char *)v6);
  if (LOBYTE(v6[0]))
    v3 = BYTE1(v6[0]);
  else
    v3 = 0;
  v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Transport log enabled: %d", (uint8_t *)v6, 8u);
  }
  return v3 != 0;
}

uint64_t re::NetworkFeatureFlags::overrideTransportThrottling(uint64_t this)
{
  unsigned __int8 v1;
  const char *v2;
  int v3;
  unsigned int v4;

  if ((v1 & 1) == 0)
  {
    v4 = this;
    LODWORD(this) = v4;
    if (v3)
    {
      re::NetworkFeatureFlags::overrideTransportThrottling(BOOL)::$_0::operator()(v4, v2);
      LODWORD(this) = v4;
    }
  }
  if (re::NetworkFeatureFlags::overrideTransportThrottling(BOOL)::enable)
    return byte_25529BB51 != 0;
  else
    return this;
}

void re::NetworkFeatureFlags::overrideTransportThrottling(BOOL)::$_0::operator()(uint64_t a1, const char *a2)
{
  re *v2;
  NSObject *v3;
  _DWORD v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"network.transport.enableThrottling", a2, &re::NetworkFeatureFlags::overrideTransportThrottling(BOOL)::enable);
  if (re::NetworkFeatureFlags::overrideTransportThrottling(BOOL)::enable)
  {
    v3 = *re::networkLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109120;
      v4[1] = byte_25529BB51;
      _os_log_impl(&dword_21C69B000, v3, OS_LOG_TYPE_DEFAULT, "Transport throttling override enabled: %d", (uint8_t *)v4, 8u);
    }
  }
}

uint64_t re::NetworkFeatureFlags::overrideMessageFragmentation(uint64_t this)
{
  unsigned __int8 v1;
  const char *v2;
  int v3;
  unsigned int v4;

  if ((v1 & 1) == 0)
  {
    v4 = this;
    LODWORD(this) = v4;
    if (v3)
    {
      re::NetworkFeatureFlags::overrideMessageFragmentation(BOOL)::$_0::operator()(v4, v2);
      LODWORD(this) = v4;
    }
  }
  if (re::NetworkFeatureFlags::overrideMessageFragmentation(BOOL)::enable)
    return byte_25529BB61 != 0;
  else
    return this;
}

void re::NetworkFeatureFlags::overrideMessageFragmentation(BOOL)::$_0::operator()(uint64_t a1, const char *a2)
{
  re *v2;
  NSObject *v3;
  _DWORD v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"network.transport.enableMessageFragmentation", a2, &re::NetworkFeatureFlags::overrideMessageFragmentation(BOOL)::enable);
  if (re::NetworkFeatureFlags::overrideMessageFragmentation(BOOL)::enable)
  {
    v3 = *re::networkLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109120;
      v4[1] = byte_25529BB61;
      _os_log_impl(&dword_21C69B000, v3, OS_LOG_TYPE_DEFAULT, "Transport message fragmentation override enabled: %d", (uint8_t *)v4, 8u);
    }
  }
}

uint64_t re::NetworkFeatureFlags::enableSyncCommitLog(re::NetworkFeatureFlags *this)
{
  unsigned __int8 v1;
  void **p_cache;
  uint64_t v4;
  const char *v5;

  p_cache = MCSessionHandler.cache;
  if ((v1 & 1) == 0)
  {
    p_cache = (void **)(MCSessionHandler + 16);
    if ((_DWORD)v4)
    {
      re::NetworkFeatureFlags::enableSyncCommitLog(void)::enable = re::NetworkFeatureFlags::enableSyncCommitLog(void)::$_0::operator()(v4, v5);
      p_cache = (void **)(MCSessionHandler + 16);
    }
  }
  return *((unsigned __int8 *)p_cache + 2928);
}

BOOL re::NetworkFeatureFlags::enableSyncCommitLog(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  re *v2;
  unsigned __int8 v3;
  NSObject *v4;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"network.syncCommit.enableLog", a2, (char *)v6);
  if (LOBYTE(v6[0]))
    v3 = BYTE1(v6[0]);
  else
    v3 = 0;
  v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "SyncCommit log enabled: %d", (uint8_t *)v6, 8u);
  }
  return v3 != 0;
}

uint64_t re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(re::NetworkFeatureFlags *this)
{
  unsigned __int8 v1;
  void **p_cache;
  uint64_t v4;
  const char *v5;

  p_cache = MCSessionHandler.cache;
  if ((v1 & 1) == 0)
  {
    p_cache = (void **)(MCSessionHandler + 16);
    if ((_DWORD)v4)
    {
      re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(void)::size = re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(void)::$_0::operator()(v4, v5);
      p_cache = (void **)(MCSessionHandler + 16);
    }
  }
  return *((unsigned int *)p_cache + 736);
}

uint64_t re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  re *v2;
  uint64_t v3;
  NSObject *v4;
  int v6;
  unsigned int v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  re::Defaults::uintValue((re::Defaults *)"network.syncObjectStateHistoryBufferSize", a2, (uint64_t)&v6);
  if ((_BYTE)v6)
    v3 = v7;
  else
    v3 = 16;
  v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 67109120;
    v7 = v3;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "syncObjectStateHistoryBufferSize is: %u", (uint8_t *)&v6, 8u);
  }
  return v3;
}

uint64_t re::NetworkFeatureFlags::enableSharedAppSpecialization(re::NetworkFeatureFlags *this)
{
  unsigned __int8 v1;
  void **p_cache;
  uint64_t v4;
  const char *v5;

  p_cache = MCSessionHandler.cache;
  if ((v1 & 1) == 0)
  {
    p_cache = (void **)(MCSessionHandler + 16);
    if ((_DWORD)v4)
    {
      re::NetworkFeatureFlags::enableSharedAppSpecialization(void)::enable = re::NetworkFeatureFlags::enableSharedAppSpecialization(void)::$_0::operator()(v4, v5);
      p_cache = (void **)(MCSessionHandler + 16);
    }
  }
  return *((unsigned __int8 *)p_cache + 2960);
}

BOOL re::NetworkFeatureFlags::enableSharedAppSpecialization(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  re *v2;
  unsigned __int8 v3;
  NSObject *v4;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"network.sharedAppSpecialization", a2, (char *)v6);
  if (LOBYTE(v6[0]))
    v3 = BYTE1(v6[0]);
  else
    v3 = 1;
  v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl(&dword_21C69B000, v4, OS_LOG_TYPE_DEFAULT, "Shared App Specialization enabled: %d", (uint8_t *)v6, 8u);
  }
  return v3 != 0;
}

id RESyncRetain(uint64_t a1)
{
  return (id)(a1 + 8);
}

void RESyncRelease(uint64_t a1)
{

}

uint64_t RESyncGetRetainCount(uint64_t a1)
{
  return objc_msgSend((id)(a1 + 8), "retainCount");
}

re::SyncObjectTypeInfo *re::SyncObjectTypeInfo::SyncObjectTypeInfo(re::SyncObjectTypeInfo *this, const re::SyncObjectTypeInfo *a2)
{
  __int16 v4;
  char v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24E0736A8;
  *((_BYTE *)this + 24) = *((_BYTE *)a2 + 24);
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  re::DynamicString::DynamicString((re::SyncObjectTypeInfo *)((char *)this + 40), (const re::SyncObjectTypeInfo *)((char *)a2 + 40));
  v4 = *((_WORD *)a2 + 36);
  v5 = *((_BYTE *)a2 + 74);
  *((_OWORD *)this + 5) = 0u;
  *((_WORD *)this + 36) = v4;
  *((_BYTE *)this + 74) = v5;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  v6 = (const void *)*((_QWORD *)a2 + 10);
  if (v6)
    *((_QWORD *)this + 10) = _Block_copy(v6);
  v7 = (const void *)*((_QWORD *)a2 + 11);
  if (v7)
    *((_QWORD *)this + 11) = _Block_copy(v7);
  v8 = (const void *)*((_QWORD *)a2 + 12);
  if (v8)
    *((_QWORD *)this + 12) = _Block_copy(v8);
  v9 = (const void *)*((_QWORD *)a2 + 13);
  if (v9)
    *((_QWORD *)this + 13) = _Block_copy(v9);
  v10 = (const void *)*((_QWORD *)a2 + 14);
  if (v10)
    *((_QWORD *)this + 14) = _Block_copy(v10);
  v11 = (const void *)*((_QWORD *)a2 + 15);
  if (v11)
    *((_QWORD *)this + 15) = _Block_copy(v11);
  v12 = (const void *)*((_QWORD *)a2 + 16);
  if (v12)
    *((_QWORD *)this + 16) = _Block_copy(v12);
  v13 = (const void *)*((_QWORD *)a2 + 17);
  if (v13)
    *((_QWORD *)this + 17) = _Block_copy(v13);
  return this;
}

void re::SyncObjectTypeInfo::~SyncObjectTypeInfo(re::SyncObjectTypeInfo *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  uint64_t v10;

  *(_QWORD *)this = &off_24E0736A8;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
  {
    _Block_release(v2);
    *((_QWORD *)this + 10) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
  {
    _Block_release(v3);
    *((_QWORD *)this + 11) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
  {
    _Block_release(v4);
    *((_QWORD *)this + 12) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 13);
  if (v5)
  {
    _Block_release(v5);
    *((_QWORD *)this + 13) = 0;
  }
  v6 = (const void *)*((_QWORD *)this + 14);
  if (v6)
  {
    _Block_release(v6);
    *((_QWORD *)this + 14) = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 15);
  if (v7)
  {
    _Block_release(v7);
    *((_QWORD *)this + 15) = 0;
  }
  v8 = (const void *)*((_QWORD *)this + 16);
  if (v8)
  {
    _Block_release(v8);
    *((_QWORD *)this + 16) = 0;
  }
  v9 = (const void *)*((_QWORD *)this + 17);
  if (v9)
  {
    _Block_release(v9);
    *((_QWORD *)this + 17) = 0;
  }
  v10 = *((_QWORD *)this + 5);
  if (v10)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::SyncObjectTypeInfo::~SyncObjectTypeInfo(this);
  JUMPOUT(0x220780CD0);
}

void *re::SyncObjectTypeInfo::setReadSnapshotCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 80);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 80) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setWriteSnapshotCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 88);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 88) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setReadPayloadCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 96);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 96) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setReadPayloadDeltaCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 104);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 104) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setWritePayloadCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 112);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 112) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setWritePayloadDeltaCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 120);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 120) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setShouldPackCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 128);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 128) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setShouldUnpackCb(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 136);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 136) = result;
  return result;
}

uint64_t RESyncReadContextIsNew(uint64_t a1)
{
  return *(_BYTE *)(*(_QWORD *)a1 + 16) & 1;
}

uint64_t RESyncReadContextIsDataChanged(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(_QWORD *)a1 + 16) >> 3) & 1;
}

uint64_t RESyncReadContextIsDestroyed(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(_QWORD *)a1 + 16) >> 1) & 1;
}

uint64_t RESyncReadContextIsChangedOwner(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(_QWORD *)a1 + 16) >> 2) & 1;
}

uint64_t RESyncReadContextGetStateData(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
    return *(_QWORD *)(v1 + 8);
  else
    return 0;
}

uint64_t RESyncReadContextGetStateSize(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;

  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0;
  v2 = *(_DWORD *)(v1 + 24);
  if (*(_DWORD *)(v1 + 28))
    return v2 + 1;
  else
    return v2;
}

uint64_t re::PacketStatsFilter::init(uint64_t a1, _OWORD *a2)
{
  __int128 v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  __int128 v9;
  uint64_t (*v10)(uint64_t, _QWORD *);
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = a2[1];
  *(_OWORD *)(a1 + 40) = *a2;
  *(_OWORD *)(a1 + 56) = v3;
  v4 = *(_anonymous_namespace_ **)(a1 + 40);
  if (v4)
  {
    v8 = a1;
    v9 = xmmword_21C703750;
    v10 = re::Event<re::Session,re::BandwidthEventData const&>::createSubscription<re::PacketStatsFilter>(re::PacketStatsFilter *,REEventHandlerResult (re::PacketStatsFilter::*)(re::Session*,re::BandwidthEventData const&))::{lambda(re::Session*,re::Event<re::Session,re::BandwidthEventData const&>::Subscription const&,re::BandwidthEventData const&)#1}::__invoke;
    re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::addSubscription(v4, (uint64_t)&v8);
  }
  v5 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  v6 = a1 + 224;
  re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::setCapacity((_QWORD *)v6, 0);
  ++*(_DWORD *)(v6 + 24);
  *(_BYTE *)(v6 - 200) = 1;
  return 1;
}

void re::PacketStatsFilter::~PacketStatsFilter(re::PacketStatsFilter *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_24E0736F0;
  re::PacketStatsFilter::deInit(this);
  v3 = (uint64_t *)((char *)this + 224);
  v2 = *((_QWORD *)this + 28);
  if (v2)
  {
    if (*((_QWORD *)this + 32))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 29) = 0;
    *((_QWORD *)this + 30) = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 62);
  }
  v4 = *((_QWORD *)this + 33);
  if (v4)
  {
    if (*((_QWORD *)this + 37))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      v5 = *v3;
    }
    else
    {
      v5 = 0;
    }
    *((_QWORD *)this + 37) = 0;
    *((_QWORD *)this + 34) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 33) = 0;
    ++*((_DWORD *)this + 72);
    if (v5)
    {
      if (*((_QWORD *)this + 32))
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      *((_QWORD *)this + 32) = 0;
      *((_QWORD *)this + 29) = 0;
      *((_QWORD *)this + 30) = 0;
      *v3 = 0;
      ++*((_DWORD *)this + 62);
    }
  }
  *(_QWORD *)this = &off_24E0707C0;
  objc_destructInstance((char *)this + 8);
}

{
  re::PacketStatsFilter::~PacketStatsFilter(this);
  JUMPOUT(0x220780CD0);
}

void re::PacketStatsFilter::deInit(re::PacketStatsFilter *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  if (*((_BYTE *)this + 24))
  {
    v3 = (_QWORD *)((char *)this + 224);
    v2 = *((_QWORD *)this + 28);
    if (v2)
    {
      if (*((_QWORD *)this + 32))
        (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
      *((_QWORD *)this + 32) = 0;
      v3[1] = 0;
      v3[2] = 0;
      *v3 = 0;
      ++*((_DWORD *)this + 62);
    }
    v4 = *((_QWORD *)this + 5);
    if (v4)
      re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::unsubscribe<re::ServiceObserverProxy>(v4, (uint64_t)this);
    *((_BYTE *)this + 24) = 0;
  }
}

double re::PacketStatsFilter::update(re::PacketStatsFilter *this)
{
  uint64_t v2;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v3;
  double result;

  v2 = *((_QWORD *)this + 8);
  if (v2)
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2);
  else
    v3 = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
  if (*((_QWORD *)this + 26) + 100 < v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 54);
    re::PacketStatsFilter::pruneStaleBandwidthUsages(this);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 54);
  }
  result = 0.0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  return result;
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep re::PacketStatsFilter::pruneStaleBandwidthUsages(re::PacketStatsFilter *this)
{
  uint64_t v2;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result;
  unsigned int v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  int v8;
  int v9;
  unint64_t *v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;

  v2 = *((_QWORD *)this + 8);
  if (v2)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2);
  else
    result = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
  v4 = 0;
  v5 = *((_QWORD *)this + 26);
  do
  {
    if (v5 + 100 >= result)
      break;
    v6 = (unint64_t *)((char *)this + 72);
    v7 = *((_QWORD *)this + 9);
    v8 = *((_DWORD *)this + 50);
    if ((v8 + 1) <= 9)
      v9 = v8 + 1;
    else
      v9 = 0;
    *((_DWORD *)this + 50) = v9;
    v10 = &v6[v9];
    v11 = v10[6];
    v12 = v7 >= v11;
    v13 = v7 - v11;
    if (!v12)
      v13 = 0;
    *v6 = v13;
    v10[6] = 0;
    v5 = result;
    if (v4 <= 8)
      v5 = *((_QWORD *)this + 26) + 100;
    *((_QWORD *)this + 26) = v5;
    ++v4;
  }
  while (v4 != 10);
  return result;
}

int64x2_t re::PacketStatsFilter::updateChannelBandwidthUsages(re::PacketStatsFilter *a1, uint64_t a2)
{
  int64x2_t *v3;
  uint64_t v4;
  uint64_t v5;
  __int8 *v6;
  int64x2_t v7;
  int64x2_t result;

  v3 = (int64x2_t *)a1;
  v4 = (8 * *(_DWORD *)(a2 + 24));
  re::PacketStatsFilter::pruneStaleBandwidthUsages(a1);
  v5 = v3[4].i64[1];
  v3 = (int64x2_t *)((char *)v3 + 72);
  v3->i64[0] = v5 + v4;
  v6 = &v3->i8[8 * v3[8].u32[0]];
  *((_QWORD *)v6 + 6) += v4;
  v7 = vdupq_n_s64(1uLL);
  v7.i64[0] = *(unsigned int *)(a2 + 24);
  result = vaddq_s64(v3[1], v7);
  v3[1] = result;
  return result;
}

void re::PacketStatsFilter::raiseCongestionEvent(uint64_t a1)
{
  _anonymous_namespace_ *v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t i;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  _OWORD v12[2];
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unint64_t v19;
  __int16 v20;
  unint64_t v21;
  _OWORD v22[5];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = (_anonymous_namespace_ *)(a1 + 224);
  v3 = *(_DWORD *)(a1 + 304);
  *(_DWORD *)(a1 + 304) = v3 + 1;
  if (*(_QWORD *)(a1 + 240))
  {
    v4 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 256) + 32 * v4 + 24))(a1) == 1)
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v2, v4);
      else
        ++v4;
    }
    while (v4 < *(_QWORD *)(a1 + 240));
    v3 = *(_DWORD *)(a1 + 304) - 1;
  }
  *(_DWORD *)(a1 + 304) = v3;
  if (!v3)
  {
    v5 = *(_QWORD *)(a1 + 280);
    if (v5)
    {
      v6 = 0;
      for (i = 0; i != v5; ++i)
      {
        v8 = *(_QWORD *)(a1 + 280);
        if (v8 <= i)
        {
          memset(v22, 0, sizeof(v22));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v14 = 136315906;
          v15 = "operator[]";
          v16 = 1024;
          v17 = 789;
          v18 = 2048;
          v19 = i;
          v20 = 2048;
          v21 = v8;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v9 = *(_QWORD *)(a1 + 296) + v6;
        v10 = *(_QWORD *)(v9 + 32);
        v11 = *(_OWORD *)(v9 + 16);
        v12[0] = *(_OWORD *)v9;
        v12[1] = v11;
        v13 = v10;
        if (LOBYTE(v12[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v2, (_QWORD *)v12 + 1, (uint64_t)v22);
          if (!LOBYTE(v22[0]))
            re::DynamicArray<re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription>::add(v2, (uint64_t)v12 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable(v2, (_QWORD *)v12 + 1);
        }
        v6 += 40;
      }
    }
  }
}

uint64_t re::PacketStatsFilter::handle(re::PacketStatsFilter *this, const re::Packet *a2)
{
  int v2;
  uint64_t v5;
  uint64_t v6;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v11;
  re *v12;
  NSObject *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v19;
  uint64_t v20;
  _BYTE v22[32];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v2 = *((_DWORD *)a2 + 6);
  if (v2)
  {
    v5 = (8 * v2);
    v6 = *((_QWORD *)this + 8);
    if (v6)
      v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 32))(v6);
    else
      v7 = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
    v10 = *((_QWORD *)this + 4);
    v11 = *((unsigned int *)this + 14);
    os_unfair_lock_lock((os_unfair_lock_t)this + 54);
    if ((unint64_t)(*((_QWORD *)this + 9) + v5) <= *((_QWORD *)this + 10) || v7 - v10 <= v11)
    {
      re::PacketStatsFilter::updateChannelBandwidthUsages(this, (uint64_t)a2);
      v9 = 0;
    }
    else
    {
      v14 = *re::networkLogObjects(v12);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        v16 = *((_QWORD *)this + 10);
        v17 = *((_QWORD *)this + 9) + v5;
        *(_DWORD *)v22 = 134218240;
        *(_QWORD *)&v22[4] = v17;
        *(_WORD *)&v22[12] = 2048;
        *(_QWORD *)&v22[14] = v16;
        _os_log_impl(&dword_21C69B000, v14, OS_LOG_TYPE_INFO, "Max bandwidth exceeded. Current bandwidth: %llu bps, Max bandwidth: %llu bps", v22, 0x16u);
      }
      v18 = *((_QWORD *)this + 8);
      if (v18)
        v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 32))(v18);
      else
        v19 = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
      v20 = *((unsigned int *)a2 + 6);
      *(_QWORD *)v22 = v19;
      *(_QWORD *)&v22[8] = v20;
      *(_OWORD *)&v22[16] = *(_OWORD *)((char *)this + 72);
      (*(void (**)(re::PacketStatsFilter *, _BYTE *))(*(_QWORD *)this + 64))(this, v22);
      *((_QWORD *)this + 4) = v7;
      re::PacketStatsFilter::updateChannelBandwidthUsages(this, (uint64_t)a2);
      v9 = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 54);
  }
  else
  {
    v8 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v22 = 0;
      _os_log_error_impl(&dword_21C69B000, v8, OS_LOG_TYPE_ERROR, "Invalid packet data size: 0", v22, 2u);
    }
    return 3;
  }
  return v9;
}

uint64_t re::PacketStatsFilter::handleBandwithEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v5;
  re *v6;
  NSObject *v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a3 + 8))
  {
    v5 = (os_unfair_lock_s *)(a1 + 216);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
    *(_QWORD *)(a1 + 80) = *(_QWORD *)(a3 + 16);
    v7 = *re::networkLogObjects(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = *(_QWORD *)(a1 + 80);
      v10 = 134217984;
      v11 = v8;
      _os_log_impl(&dword_21C69B000, v7, OS_LOG_TYPE_INFO, "Max bandwidth changed: %llu bps", (uint8_t *)&v10, 0xCu);
    }
    os_unfair_lock_unlock(v5);
  }
  return 0;
}

int64x2_t re::PacketStatsFilter::handleReceiveStats(re::PacketStatsFilter *this, uint64_t a2)
{
  int64x2_t v2;
  int64x2_t result;

  v2 = vdupq_n_s64(1uLL);
  v2.i64[0] = a2;
  result = vaddq_s64(*(int64x2_t *)((char *)this + 104), v2);
  *(int64x2_t *)((char *)this + 104) = result;
  return result;
}

uint64_t re::Event<re::Session,re::BandwidthEventData const&>::createSubscription<re::PacketStatsFilter>(re::PacketStatsFilter *,REEventHandlerResult (re::PacketStatsFilter::*)(re::Session*,re::BandwidthEventData const&))::{lambda(re::Session*,re::Event<re::Session,re::BandwidthEventData const&>::Subscription const&,re::BandwidthEventData const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

uint64_t *re::foundationSerializationLogObjects(re *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    re::foundationSerializationLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Serialization");
  }
  return &re::foundationSerializationLogObjects(void)::logObjects;
}

uint64_t re::snapshot::Encoder::error(re::snapshot::Encoder *this, const char *__format, ...)
{
  re::DynamicString *v3;
  unint64_t v4;
  unint64_t v5;
  va_list va;

  va_start(va, __format);
  v3 = (re::snapshot::Encoder *)((char *)this + 32);
  v4 = *((_QWORD *)this + 5);
  if ((v4 & 1) != 0)
    v5 = v4 >> 1;
  else
    v5 = v4 >> 1;
  if (v5)
    re::DynamicString::append((re::snapshot::Encoder *)((char *)this + 32), "\n", 1uLL);
  return re::DynamicString::vappendf(v3, __format, va);
}

unsigned int *re::snapshot::EncoderOPACK::operator<<(unsigned int *this, int a2)
{
  unsigned int *v2;
  char v3;
  uint64_t v4;
  uint64_t v5;

  v2 = this;
  if (a2)
    v3 = 1;
  else
    v3 = 2;
  v4 = this[2];
  if (v4 < this[3])
    goto LABEL_5;
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v4 + 1);
  if ((_DWORD)this)
  {
    LODWORD(v4) = v2[2];
LABEL_5:
    v5 = *(_QWORD *)v2;
    v2[2] = v4 + 1;
    *(_BYTE *)(v5 + v4) = v3;
  }
  return this;
}

uint64_t *re::snapshot::Decoder::error(const char **this, const char *a2, ...)
{
  re *v4;
  NSObject *v5;
  uint64_t *result;
  const char *v7;
  int v8;
  char *v9;
  uint64_t *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  char *v19;
  uint64_t v20;
  va_list va;

  va_start(va, a2);
  v20 = *MEMORY[0x24BDAC8D0];
  v11 = 0;
  v12 = 0;
  v13 = 0;
  re::DynamicString::setCapacity(&v10, 0);
  v4 = (re *)re::DynamicString::vassignf((re::DynamicString *)&v10, a2, va);
  v5 = *re::foundationSerializationLogObjects(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v7 = this[7];
    if (!v7)
      v7 = "<unknown>";
    v8 = *((_DWORD *)this + 8);
    if ((v11 & 1) != 0)
      v9 = v12;
    else
      v9 = (char *)&v11 + 1;
    *(_DWORD *)buf = 136315650;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 2080;
    v19 = v9;
    _os_log_error_impl(&dword_21C69B000, v5, OS_LOG_TYPE_ERROR, "Snapshot reader (%s:%d): %s", buf, 0x1Cu);
  }
  this[2] = this[3];
  *((_BYTE *)this + 36) = 1;
  result = v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v10 + 40))();
  }
  return result;
}

uint64_t *re::snapshot::DecoderOPACK::operator>>(uint64_t *result, _BYTE *a2)
{
  unsigned __int8 *v2;
  int v3;

  v2 = (unsigned __int8 *)result[2];
  if ((unint64_t)v2 >= result[3])
  {
    v3 = 0;
  }
  else
  {
    result[2] = (uint64_t)(v2 + 1);
    v3 = *v2;
    if (v3 == 1)
    {
      *a2 = 1;
      return result;
    }
    if (v3 == 2)
    {
      *a2 = 0;
      return result;
    }
  }
  return re::snapshot::Decoder::error((const char **)result, "expected BOOL, found tag %x", v3);
}

uint64_t re::snapshot::DecoderOPACK::beginData(re::snapshot::DecoderOPACK *this, unint64_t *a2, int a3)
{
  unint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v4 = (unsigned __int8 *)*((_QWORD *)this + 2);
  v3 = *((_QWORD *)this + 3);
  if ((unint64_t)v4 >= v3)
  {
    if (a3)
    {
LABEL_7:
      v9 = 0;
      *((_QWORD *)this + 2) = v4 - 1;
    }
    else
    {
LABEL_28:
      re::snapshot::Decoder::error((const char **)this, "expected data, found tag %x");
      return 0;
    }
  }
  else
  {
    v6 = v4 + 1;
    *((_QWORD *)this + 2) = v4 + 1;
    v7 = *v4;
    switch(*v4)
    {
      case 0x91u:
        if ((unsigned __int8 *)v3 != v6)
        {
          v8 = v4[1];
          v6 = v4 + 2;
          goto LABEL_14;
        }
        re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 1uLL, 0);
        goto LABEL_23;
      case 0x92u:
        v10 = v3 - (_QWORD)v6;
        if (v10 > 1)
        {
          v8 = *(unsigned __int16 *)(v4 + 1);
          v6 = v4 + 3;
          goto LABEL_14;
        }
        v11 = 2;
        goto LABEL_22;
      case 0x93u:
        v10 = v3 - (_QWORD)v6;
        if (v10 > 3)
        {
          v8 = *(unsigned int *)(v4 + 1);
          v6 = v4 + 5;
          goto LABEL_14;
        }
        v11 = 4;
        goto LABEL_22;
      case 0x94u:
        v10 = v3 - (_QWORD)v6;
        if (v10 > 7)
        {
          v8 = *(_QWORD *)(v4 + 1);
          v6 = v4 + 9;
LABEL_14:
          *((_QWORD *)this + 2) = v6;
          goto LABEL_15;
        }
        v11 = 8;
LABEL_22:
        re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", v11, v10);
LABEL_23:
        *a2 = 0;
        goto LABEL_24;
      default:
        if ((v7 + 111) <= 0xDEu)
        {
          ++v4;
          if (!a3)
            goto LABEL_28;
          goto LABEL_7;
        }
        v8 = (v7 - 112);
LABEL_15:
        *a2 = v8;
        if (v3 - (unint64_t)v6 < v8)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun in data: size = %zu, only %zu bytes left");
          return 0;
        }
LABEL_24:
        v9 = 1;
        break;
    }
  }
  return v9;
}

uint64_t re::snapshot::DecoderOPACK::beginDictionary(re::snapshot::DecoderOPACK *this, unint64_t *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  unsigned __int8 *v4;
  int v5;
  unint64_t v6;

  v2 = (unsigned __int8 *)*((_QWORD *)this + 2);
  v3 = *((_QWORD *)this + 3);
  if ((unint64_t)v2 >= v3)
    goto LABEL_8;
  v4 = v2 + 1;
  *((_QWORD *)this + 2) = v2 + 1;
  v5 = *v2;
  if ((v5 + 32) > 0xEu)
  {
    if (v5 == 239)
    {
      *a2 = -1;
      return 1;
    }
LABEL_8:
    re::snapshot::Decoder::error((const char **)this, "expected dictionary, found tag %x");
    return 0;
  }
  v6 = (v5 - 224);
  *a2 = v6;
  if (v3 - (unint64_t)v4 >= v6)
    return 1;
  re::snapshot::Decoder::error((const char **)this, "overrun in beginDictionary: %zu items, only %zu bytes remaining");
  return 0;
}

BOOL re::snapshot::DecoderOPACK::endDictionary(re::snapshot::DecoderOPACK *this, unint64_t *a2)
{
  _BYTE *v2;
  unint64_t v3;

  v2 = (_BYTE *)*((_QWORD *)this + 2);
  v3 = *a2;
  if ((unint64_t)v2 >= *((_QWORD *)this + 3))
  {
    if (v3)
      re::snapshot::Decoder::error((const char **)this, "reached end of buffer but expected more dictionary entries");
  }
  else
  {
    if (v3 <= 0xE)
    {
      *a2 = v3 - 1;
      return v3 == 0;
    }
    if (*v2 != 3)
      return 0;
    *((_QWORD *)this + 2) = v2 + 1;
  }
  return 1;
}

uint64_t re::snapshot::DecoderOPACK::beginObject(re::snapshot::DecoderOPACK *this, const char **a2)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v8;
  int Integer;
  const char *v10;

  v3 = (unsigned __int8 *)*((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 3);
  if ((unint64_t)v3 >= v4)
  {
    v6 = 0;
    goto LABEL_13;
  }
  v5 = v3 + 1;
  *((_QWORD *)this + 2) = v3 + 1;
  v6 = *v3;
  if (v6 != 239)
  {
LABEL_13:
    re::snapshot::Decoder::error((const char **)this, "expected object, found tag %x", v6);
    return 0;
  }
  if ((unint64_t)v5 >= v4 || (v8 = *v5, v8 == 3))
  {
    Integer = 0x7FFFFFFF;
  }
  else if ((v8 - 7) > 0x28)
  {
    Integer = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
  }
  else
  {
    *((_QWORD *)this + 2) = v3 + 2;
    Integer = v8 - 8;
  }
  *((_DWORD *)this + 8) = Integer;
  if (a2)
  {
    v10 = (const char *)*((_QWORD *)this + 7);
    *((_QWORD *)this + 7) = *a2;
    *a2 = v10;
  }
  return 1;
}

uint64_t *re::snapshot::DecoderOPACK::endObject(uint64_t *this, const char *a2)
{
  uint64_t *v3;
  unsigned __int8 *v4;
  unint64_t i;
  int v6;

  v3 = this;
  v4 = (unsigned __int8 *)this[2];
  for (i = this[3]; (unint64_t)v4 < i; i = v3[3])
  {
    v3[2] = (uint64_t)(v4 + 1);
    v6 = *v4;
    if (v6 == 3)
      break;
    this = re::snapshot::DecoderOPACK::skip(v3, v6);
    v4 = (unsigned __int8 *)v3[2];
  }
  v3[7] = (uint64_t)a2;
  return this;
}

unsigned int *re::snapshot::EncoderOPACK::writeInteger(unsigned int *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  uint64_t v5;

  if (a2 == (int)a2)
    return re::snapshot::EncoderOPACK::writeInteger(this, a2);
  v2 = this[2];
  if (v2 + 9 <= (unint64_t)this[3])
    goto LABEL_4;
  v4 = this;
  v5 = a2;
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v2 + 9);
  if ((_DWORD)this)
  {
    this = v4;
    a2 = v5;
    v2 = v4[2];
LABEL_4:
    v3 = *(_QWORD *)this;
    this[2] = v2 + 1;
    *(_BYTE *)(v3 + v2) = 51;
    *(_QWORD *)(*(_QWORD *)this + this[2]) = a2;
    this[2] += 8;
  }
  return this;
}

unsigned int *re::snapshot::EncoderOPACK::beginData(unsigned int *this, unint64_t a2, unint64_t a3)
{
  unsigned int *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = this;
  if (a3 > 0x20)
  {
    if (a3 > 0xFF)
    {
      v12 = this[3];
      if (a3 >> 16)
      {
        v16 = this[2];
        if (HIDWORD(a3))
        {
          if (v16 + 9 > v12)
          {
            this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v16 + 9);
            if (!(_DWORD)this)
              return this;
            v16 = v4[2];
          }
          v20 = *(_QWORD *)v4;
          v4[2] = v16 + 1;
          *(_BYTE *)(v20 + v16) = -108;
          *(_QWORD *)(*(_QWORD *)v4 + v4[2]) = a2;
          v11 = v4[2] + 8;
LABEL_19:
          v4[2] = v11;
          return this;
        }
        v17 = v16 + 5;
        if (v16 + 5 <= v12)
        {
LABEL_15:
          if (HIDWORD(a2))
          {
            re::internal::assertLog((re::internal *)5, v17, "assertion failure: '%s' (%s:line %i) count %zu exceeds uint32_t capacity", "!overflow", "beginData", 163, a2);
            this = (unsigned int *)_os_crash();
            __break(1u);
            return this;
          }
          v18 = *(_QWORD *)v4;
          v19 = v4[2];
          v4[2] = v19 + 1;
          *(_BYTE *)(v18 + v19) = -109;
          *(_DWORD *)(*(_QWORD *)v4 + v4[2]) = a2;
          v11 = v4[2] + 4;
          goto LABEL_19;
        }
LABEL_30:
        this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)v4, v17);
        if (!(_DWORD)this)
          return this;
        goto LABEL_15;
      }
      v13 = this[2] + 3;
      if (v13 <= v12)
      {
LABEL_11:
        if (a2 < 0x10000)
        {
          v14 = *(_QWORD *)v4;
          v15 = v4[2];
          v4[2] = v15 + 1;
          *(_BYTE *)(v14 + v15) = -110;
          *(_WORD *)(*(_QWORD *)v4 + v4[2]) = a2;
          v11 = v4[2] + 2;
          goto LABEL_19;
        }
        re::internal::assertLog((re::internal *)5, v13, "assertion failure: '%s' (%s:line %i) count %zu exceeds uint16_t capacity", "!overflow", "beginData", 155, a2);
        _os_crash();
        __break(1u);
        goto LABEL_30;
      }
    }
    else
    {
      v8 = this[2] + 2;
      if (v8 > this[3])
      {
        this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v8);
        if (!(_DWORD)this)
          return this;
      }
      if (a2 < 0x100)
      {
        v9 = *(_QWORD *)v4;
        v10 = v4[2];
        v4[2] = v10 + 1;
        *(_BYTE *)(v9 + v10) = -111;
        *(_BYTE *)(*(_QWORD *)v4 + v4[2]) = a2;
        v11 = v4[2] + 1;
        goto LABEL_19;
      }
      re::internal::assertLog((re::internal *)5, v8, "assertion failure: '%s' (%s:line %i) count %zu exceeds uint8_t capacity", "!overflow", "beginData", 147, a2);
      _os_crash();
      __break(1u);
    }
    this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)v4, v13);
    if (!(_DWORD)this)
      return this;
    goto LABEL_11;
  }
  v5 = a2 + 112;
  if (a2 + 112 >= 0x100)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) tag %zu exceeds uint8_t capacity", "!overflow", "beginData", 141, v5);
    _os_crash();
    __break(1u);
  }
  else
  {
    v6 = this[2];
    if (v6 < this[3])
    {
LABEL_4:
      v7 = *(_QWORD *)v4;
      v4[2] = v6 + 1;
      *(_BYTE *)(v7 + v6) = v5;
      return this;
    }
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)v4, v6 + 1);
  if ((_DWORD)this)
  {
    LODWORD(v6) = v4[2];
    goto LABEL_4;
  }
  return this;
}

unsigned int *re::snapshot::EncoderOPACK::writeInteger(unsigned int *this, int a2)
{
  char v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = a2;
  v3 = this;
  if ((a2 + 1) > 0x28)
  {
    v6 = this[2];
    if (v6 + 2 > (unint64_t)this[3])
    {
      this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v6 + 2);
      if (!(_DWORD)this)
        return this;
      v6 = v3[2];
    }
    v7 = *(_QWORD *)v3;
    v3[2] = v6 + 1;
    *(_BYTE *)(v7 + v6) = 48;
    *(_BYTE *)(*(_QWORD *)v3 + v3[2]++) = v2;
    return this;
  }
  v4 = this[2];
  if (v4 < this[3])
  {
LABEL_3:
    v5 = *(_QWORD *)v3;
    v3[2] = v4 + 1;
    *(_BYTE *)(v5 + v4) = v2 + 8;
    return this;
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v4 + 1);
  if ((_DWORD)this)
  {
    LODWORD(v4) = v3[2];
    goto LABEL_3;
  }
  return this;
}

{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  __int16 v5;

  if (a2 == (char)a2)
    return re::snapshot::EncoderOPACK::writeInteger(this, (char)a2);
  v2 = this[2];
  if (v2 + 3 <= (unint64_t)this[3])
    goto LABEL_4;
  v5 = a2;
  v4 = this;
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v2 + 3);
  if ((_DWORD)this)
  {
    this = v4;
    v2 = v4[2];
    LOWORD(a2) = v5;
LABEL_4:
    v3 = *(_QWORD *)this;
    this[2] = v2 + 1;
    *(_BYTE *)(v3 + v2) = 49;
    *(_WORD *)(*(_QWORD *)this + this[2]) = a2;
    this[2] += 2;
  }
  return this;
}

{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  int v5;

  if (a2 == (__int16)a2)
    return re::snapshot::EncoderOPACK::writeInteger(this, (__int16)a2);
  v2 = this[2];
  if (v2 + 5 <= (unint64_t)this[3])
    goto LABEL_4;
  v5 = a2;
  v4 = this;
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v2 + 5);
  if ((_DWORD)this)
  {
    this = v4;
    v2 = v4[2];
    a2 = v5;
LABEL_4:
    v3 = *(_QWORD *)this;
    this[2] = v2 + 1;
    *(_BYTE *)(v3 + v2) = 50;
    *(_DWORD *)(*(_QWORD *)this + this[2]) = a2;
    this[2] += 4;
  }
  return this;
}

uint64_t *re::snapshot::DecoderOPACK::skip(uint64_t *result, int a2)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  unint64_t v13;
  unsigned __int8 *v14;
  unsigned __int8 *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unsigned __int8 *v28;
  uint64_t v29;
  int v30;
  unsigned __int8 *v31;
  uint64_t v32;
  unsigned __int8 *v33;
  uint64_t v34;

  v2 = result;
  if (a2 <= 96)
  {
    switch(a2)
    {
      case '0':
        v3 = result[2] + 1;
        goto LABEL_48;
      case '1':
        v3 = result[2] + 2;
        goto LABEL_48;
      case '2':
      case '5':
        v3 = result[2] + 4;
        goto LABEL_48;
      case '3':
      case '6':
        v3 = result[2] + 8;
        goto LABEL_48;
      case '4':
        goto LABEL_35;
      default:
        if ((a2 - 1) < 2 || a2 == 4)
          return result;
LABEL_35:
        if ((a2 - 7) < 0x29)
          return result;
        v25 = (a2 - 64);
        if (v25 <= 0x20 || (v25 = (a2 - 112), v25 <= 0x20))
        {
          v3 = result[2] + v25;
          goto LABEL_48;
        }
        if ((a2 + 48) > 0xEu)
        {
          if ((a2 + 32) > 0xEu)
          {
            result = re::snapshot::Decoder::error((const char **)result, "unexpected tag while skipping: %x", a2);
          }
          else if (a2 >= 0xE1)
          {
            v30 = a2 - 223;
            do
            {
              v31 = (unsigned __int8 *)v2[2];
              if ((unint64_t)v31 >= v2[3])
              {
                v32 = 0;
              }
              else
              {
                v2[2] = (uint64_t)(v31 + 1);
                v32 = *v31;
              }
              re::snapshot::DecoderOPACK::skip(v2, v32);
              v33 = (unsigned __int8 *)v2[2];
              if ((unint64_t)v33 >= v2[3])
              {
                v34 = 0;
              }
              else
              {
                v2[2] = (uint64_t)(v33 + 1);
                v34 = *v33;
              }
              result = (uint64_t *)re::snapshot::DecoderOPACK::skip(v2, v34);
              --v30;
            }
            while (v30 > 1);
          }
        }
        else if (a2 >= 0xD1)
        {
          v27 = a2 - 207;
          do
          {
            v28 = (unsigned __int8 *)v2[2];
            if ((unint64_t)v28 >= v2[3])
            {
              v29 = 0;
            }
            else
            {
              v2[2] = (uint64_t)(v28 + 1);
              v29 = *v28;
            }
            result = (uint64_t *)re::snapshot::DecoderOPACK::skip(v2, v29);
            --v27;
          }
          while (v27 > 1);
        }
        break;
    }
  }
  else if (a2 <= 144)
  {
    switch(a2)
    {
      case 'a':
LABEL_7:
        v4 = (unsigned __int8 *)result[2];
        v5 = (unsigned __int8 *)result[3];
        if (v5 != v4)
        {
          v8 = *v4;
          v6 = v4 + 1;
          v7 = v8;
          goto LABEL_30;
        }
        result = re::snapshot::Decoder::error((const char **)result, "overrun: attempted to read %zu bytes, only %zu remaining", 1uLL, 0);
        goto LABEL_46;
      case 'b':
LABEL_26:
        v16 = (unsigned __int8 *)result[2];
        v5 = (unsigned __int8 *)result[3];
        v17 = v5 - v16;
        if ((unint64_t)(v5 - v16) > 1)
        {
          v18 = *(unsigned __int16 *)v16;
          v6 = v16 + 2;
          v7 = v18;
          goto LABEL_30;
        }
        v26 = 2;
        goto LABEL_44;
      case 'c':
LABEL_28:
        v19 = (unsigned __int8 *)result[2];
        v5 = (unsigned __int8 *)result[3];
        v17 = v5 - v19;
        if ((unint64_t)(v5 - v19) <= 3)
        {
          v26 = 4;
          goto LABEL_44;
        }
        v20 = *(_DWORD *)v19;
        v6 = v19 + 4;
        v7 = v20;
LABEL_30:
        result[2] = (uint64_t)v6;
        v21 = v5 - v6;
        if (v21 >= v7)
          goto LABEL_47;
        goto LABEL_34;
      case 'd':
LABEL_32:
        v22 = (_QWORD *)result[2];
        v23 = result[3];
        v17 = v23 - (_QWORD)v22;
        if ((unint64_t)(v23 - (_QWORD)v22) <= 7)
        {
          v26 = 8;
LABEL_44:
          result = re::snapshot::Decoder::error((const char **)result, "overrun: attempted to read %zu bytes, only %zu remaining", v26, v17);
LABEL_46:
          v7 = 0;
          v6 = (unsigned __int8 *)v2[2];
        }
        else
        {
          v24 = *v22;
          v6 = (unsigned __int8 *)(v22 + 1);
          v7 = v24;
          result[2] = (uint64_t)v6;
          v21 = v23 - (_QWORD)v6;
          if (v24 > v21)
          {
LABEL_34:
            result = re::snapshot::Decoder::error((const char **)result, "invalid size when skipping string or data: %zu, only %zu remaining", v7, v21);
            v6 = (unsigned __int8 *)v2[2];
            v7 = v2[3] - (_QWORD)v6;
          }
        }
LABEL_47:
        v3 = (uint64_t)&v6[v7];
        break;
      default:
        goto LABEL_35;
    }
LABEL_48:
    v2[2] = v3;
  }
  else
  {
    switch(a2)
    {
      case 145:
        goto LABEL_7;
      case 146:
        goto LABEL_26;
      case 147:
        goto LABEL_28;
      case 148:
        goto LABEL_32;
      default:
        if (a2 != 223 && a2 != 239)
          goto LABEL_35;
        v10 = (unsigned __int8 *)result[2];
        v9 = result[3];
        if ((unint64_t)v10 >= v9)
        {
          v11 = 0;
        }
        else
        {
          result[2] = (uint64_t)(v10 + 1);
          v11 = *v10++;
        }
        if ((unint64_t)v10 < v9 && v11 != 3)
        {
          do
          {
            result = (uint64_t *)re::snapshot::DecoderOPACK::skip(v2, v11);
            v12 = (unsigned __int8 *)v2[2];
            v13 = v2[3];
            if ((unint64_t)v12 >= v13)
              break;
            v14 = v12 + 1;
            v2[2] = (uint64_t)(v12 + 1);
            v11 = *v12;
          }
          while ((unint64_t)v14 < v13 && v11 != 3);
        }
        break;
    }
  }
  return result;
}

uint64_t re::snapshot::DecoderOPACK::readInteger(re::snapshot::DecoderOPACK *this, uint64_t a2)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unsigned __int8 *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;

  v3 = (unsigned __int8 *)*((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 3);
  if ((unint64_t)v3 >= v4)
  {
LABEL_18:
    re::snapshot::Decoder::error((const char **)this, "expected integer, found tag %x");
  }
  else
  {
    v5 = v3 + 1;
    *((_QWORD *)this + 2) = v3 + 1;
    v6 = *v3;
    switch(*v3)
    {
      case '0':
        if ((unint64_t)v5 < v4)
        {
          *((_QWORD *)this + 2) = v3 + 2;
          a2 = (char)v3[1];
        }
        break;
      case '1':
        v7 = v4 - (_QWORD)v5;
        if (v7 <= 1)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 2uLL, v7);
        }
        else
        {
          LOWORD(a2) = *(_WORD *)(v3 + 1);
          *((_QWORD *)this + 2) = v3 + 3;
        }
        a2 = (__int16)a2;
        break;
      case '2':
        v8 = v4 - (_QWORD)v5;
        if (v8 <= 3)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 4uLL, v8);
        }
        else
        {
          LODWORD(a2) = *(_DWORD *)(v3 + 1);
          *((_QWORD *)this + 2) = v3 + 5;
        }
        a2 = (int)a2;
        break;
      case '3':
        if (v4 - (unint64_t)v5 <= 7)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining");
        }
        else
        {
          a2 = *(_QWORD *)(v3 + 1);
          *((_QWORD *)this + 2) = v3 + 9;
        }
        break;
      default:
        if ((v6 - 7) > 0x28)
          goto LABEL_18;
        a2 = (char)(v6 - 8);
        break;
    }
  }
  return a2;
}

uint64_t re::profilerThreadContext(re *this)
{
  uint64_t (*v1)(_QWORD);
  re::ProfilerThreadContext *v3;

  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
    re::ProfilerThreadContext::ProfilerThreadContext(v3);
    _tlv_atexit((void (__cdecl *)(void *))re::ProfilerThreadContext::~ProfilerThreadContext, v3);
  }
  return re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
}

void re::ProfilerThreadContext::~ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    *((_QWORD *)this + 13) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 9);
  if (v4)
  {
    *((_QWORD *)this + 10) = v4;
    operator delete(v4);
  }
}

re::ProfilerThreadContext *re::ProfilerThreadContext::ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  unint64_t v2;
  _opaque_pthread_t *v3;
  pthread_t v4;

  *(_BYTE *)this = 0;
  do
    v2 = __ldaxr(&re::ProfilerThreadContext::s_threadId);
  while (__stlxr(v2 + 1, &re::ProfilerThreadContext::s_threadId));
  *((_QWORD *)this + 8) = v2;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((_BYTE *)this + 184) = 0;
  v3 = pthread_self();
  if (!pthread_getname_np(v3, (char *)this, 0x40uLL) && !*(_BYTE *)this)
  {
    v4 = pthread_self();
    snprintf((char *)this, 0x40uLL, "Thread %p", v4);
  }
  *((_QWORD *)this + 22) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  std::vector<re::ProfilerCategory>::reserve((unint64_t *)this + 12, 0x20uLL);
  return this;
}

void std::vector<re::ProfilerCategory>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      abort();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

uint64_t re::ProfilerConfig::isStatisticCollectionEnabled(re::ProfilerConfig *this)
{
  unsigned __int8 v1;
  void **p_cache;
  int v4;
  const char *v5;
  char v6;
  char v7[2];

  p_cache = MCSessionHandler.cache;
  if ((v1 & 1) == 0)
  {
    p_cache = (void **)(MCSessionHandler + 16);
    if (v4)
    {
      re::Defaults::BOOLValue((re::Defaults *)"profiler.statisticcollection.enable", v5, v7);
      v6 = v7[1];
      if (!v7[0])
        v6 = 1;
      re::ProfilerConfig::isStatisticCollectionEnabled(void)::enabled = v6;
      p_cache = (void **)(MCSessionHandler + 16);
    }
  }
  return *((unsigned __int8 *)p_cache + 3000);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x24BDBB780]();
  return result;
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x24BDAC720](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x24BDAC738](aBlock);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

std::__thread_struct *__cdecl std::__thread_struct::__thread_struct(std::__thread_struct *this)
{
  return (std::__thread_struct *)MEMORY[0x24BEDB038](this);
}

void std::__thread_struct::~__thread_struct(std::__thread_struct *this)
{
  MEMORY[0x24BEDB040](this);
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
  MEMORY[0x24BEDB088](this);
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
  MEMORY[0x24BEDB090](this);
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x24BEDB0A0](this);
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
  MEMORY[0x24BEDB0F8](this);
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
  MEMORY[0x24BEDB110](this, __lk);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x24BEDB118](this);
}

std::__thread_specific_ptr<std::__thread_struct> *std::__thread_local_data(void)
{
  return (std::__thread_specific_ptr<std::__thread_struct> *)MEMORY[0x24BEDB198]();
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
  MEMORY[0x24BEDB1B0](*(_QWORD *)&__ev, __what_arg);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x24BEDB368](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x24BEDB370](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x24BEDB380](this);
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x24BEDB3E0]();
}

void std::thread::join(std::thread *this)
{
  MEMORY[0x24BEDB468](this);
}

void std::thread::~thread(std::thread *this)
{
  MEMORY[0x24BEDB478](this);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_24E06FDC0(__p);
}

void operator delete(void *__p, std::align_val_t a2)
{
  off_24E06FDC8(__p, a2);
}

uint64_t operator delete()
{
  return off_24E06FDD0();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24E06FDD8(__sz);
}

uint64_t operator new()
{
  return off_24E06FDE0();
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

uint64_t _os_crash()
{
  return MEMORY[0x24BDACB50]();
}

uint64_t _os_crash_msg()
{
  return MEMORY[0x24BDACB58]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB68](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB88](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x24BDACBA8]();
}

void _tlv_atexit(void (__cdecl *termFunc)(void *), void *objAddr)
{
  MEMORY[0x24BDACF10](termFunc, objAddr);
}

void abort(void)
{
  MEMORY[0x24BDAD008]();
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x24BDAD030](*(_QWORD *)&a1, a2, a3);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x24BDAD2C8](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x24BEDCE40](cls, name, imp, types);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB978](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(_QWORD *)&algorithm);
}

size_t compression_decode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB980](*(_QWORD *)&algorithm);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB988](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(_QWORD *)&algorithm);
}

size_t compression_encode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB990](*(_QWORD *)&algorithm);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x24BDADA10](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x24BDADCA8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC8](queue, block);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x24BDADCD8](queue, context, work);
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  return MEMORY[0x24BDADD48](data, applier);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x24BDADD60](buffer, size, queue, destructor);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return MEMORY[0x24BDADD90](data);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEB8](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x24BDADEC8](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED8](label, attr, target);
}

void *__cdecl dispatch_queue_get_specific(dispatch_queue_t queue, const void *key)
{
  return (void *)MEMORY[0x24BDADEF0](queue, key);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  MEMORY[0x24BDADF00](queue, key, context, destructor);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x24BDADF20](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x24BDAE2E8](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

void freeaddrinfo(addrinfo *a1)
{
  MEMORY[0x24BDAE458](a1);
}

void freeifaddrs(ifaddrs *a1)
{
  MEMORY[0x24BDAE468](a1);
}

const char *__cdecl gai_strerror(int a1)
{
  return (const char *)MEMORY[0x24BDAE598](*(_QWORD *)&a1);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x24BDAE5A0](a1, a2, a3, a4);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x24BDAE660](a1);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x24BDAE6C0](*(_QWORD *)&a1, a2, a3);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x24BDAE770](*(_QWORD *)&a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return MEMORY[0x24BDAE778](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4, a5);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x24BDAE8B0](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int inet_pton(int a1, const char *a2, void *a3)
{
  return MEMORY[0x24BDAE8B8](*(_QWORD *)&a1, a2, a3);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x24BDAE958]();
}

int kevent64(int kq, const kevent64_s *changelist, int nchanges, kevent64_s *eventlist, int nevents, unsigned int flags, const timespec *timeout)
{
  return MEMORY[0x24BDAE970](*(_QWORD *)&kq, changelist, *(_QWORD *)&nchanges, eventlist, *(_QWORD *)&nevents, *(_QWORD *)&flags, timeout);
}

int kqueue(void)
{
  return MEMORY[0x24BDAE998]();
}

int listen(int a1, int a2)
{
  return MEMORY[0x24BDAEA78](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return (malloc_zone_t *)MEMORY[0x24BDAED10](start_size, *(_QWORD *)&flags);
}

void malloc_destroy_zone(malloc_zone_t *zone)
{
  MEMORY[0x24BDAED28](zone);
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
  MEMORY[0x24BDAED58](zone, name);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x24BDAED80](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAEDA8](zone, alignment, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
  MEMORY[0x24BDAEDC0](zone, ptr);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

void nw_connection_batch(nw_connection_t connection, dispatch_block_t batch_block)
{
  MEMORY[0x24BDE0AF0](connection, batch_block);
}

void nw_connection_cancel(nw_connection_t connection)
{
  MEMORY[0x24BDE0AF8](connection);
}

nw_endpoint_t nw_connection_copy_endpoint(nw_connection_t connection)
{
  return (nw_endpoint_t)MEMORY[0x24BDE0B40](connection);
}

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  return (nw_connection_t)MEMORY[0x24BDE0B68](endpoint, parameters);
}

nw_data_transfer_report_t nw_connection_create_new_data_transfer_report(nw_connection_t connection)
{
  return (nw_data_transfer_report_t)MEMORY[0x24BDE0B78](connection);
}

uint64_t nw_connection_create_with_connected_socket_and_parameters()
{
  return MEMORY[0x24BDE0B88]();
}

void nw_connection_force_cancel(nw_connection_t connection)
{
  MEMORY[0x24BDE0BA8](connection);
}

void nw_connection_receive_message(nw_connection_t connection, nw_connection_receive_completion_t completion)
{
  MEMORY[0x24BDE0C38](connection, completion);
}

void nw_connection_send(nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
  MEMORY[0x24BDE0C58](connection, content, context, is_complete, completion);
}

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
  MEMORY[0x24BDE0C98](connection, queue);
}

void nw_connection_set_state_changed_handler(nw_connection_t connection, nw_connection_state_changed_handler_t handler)
{
  MEMORY[0x24BDE0CB0](connection, handler);
}

void nw_connection_start(nw_connection_t connection)
{
  MEMORY[0x24BDE0CD0](connection);
}

uint64_t nw_connection_state_to_string()
{
  return MEMORY[0x24BDE0CF0]();
}

nw_protocol_metadata_t nw_content_context_copy_protocol_metadata(nw_content_context_t context, nw_protocol_definition_t protocol)
{
  return (nw_protocol_metadata_t)MEMORY[0x24BDE0D00](context, protocol);
}

nw_content_context_t nw_content_context_create(const char *context_identifier)
{
  return (nw_content_context_t)MEMORY[0x24BDE0D10](context_identifier);
}

BOOL nw_content_context_get_is_final(nw_content_context_t context)
{
  return MEMORY[0x24BDE0D20](context);
}

void nw_content_context_set_metadata_for_protocol(nw_content_context_t context, nw_protocol_metadata_t protocol_metadata)
{
  MEMORY[0x24BDE0D40](context, protocol_metadata);
}

uint64_t nw_context_create()
{
  return MEMORY[0x24BDE0DA0]();
}

uint64_t nw_context_set_isolate_protocol_stack()
{
  return MEMORY[0x24BDE0DC0]();
}

uint64_t nw_context_set_scheduling_mode()
{
  return MEMORY[0x24BDE0DD0]();
}

void nw_data_transfer_report_collect(nw_data_transfer_report_t report, dispatch_queue_t queue, nw_data_transfer_report_collect_block_t collect_block)
{
  MEMORY[0x24BDE0DD8](report, queue, collect_block);
}

uint64_t nw_data_transfer_report_get_received_ip_packet_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x24BDE0DE0](report, *(_QWORD *)&path_index);
}

uint64_t nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x24BDE0DE8](report, *(_QWORD *)&path_index);
}

uint64_t nw_data_transfer_report_get_sent_ip_packet_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x24BDE0DF0](report, *(_QWORD *)&path_index);
}

uint64_t nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x24BDE0DF8](report, *(_QWORD *)&path_index);
}

uint64_t nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x24BDE0E00](report, *(_QWORD *)&path_index);
}

uint64_t nw_endpoint_create_host_with_numeric_port()
{
  return MEMORY[0x24BDE0E98]();
}

uint64_t nw_endpoint_get_description()
{
  return MEMORY[0x24BDE0EF8]();
}

const char *__cdecl nw_endpoint_get_hostname(nw_endpoint_t endpoint)
{
  return (const char *)MEMORY[0x24BDE0F20](endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return MEMORY[0x24BDE0F40](endpoint);
}

int nw_error_get_error_code(nw_error_t error)
{
  return MEMORY[0x24BDE0FB8](error);
}

nw_error_domain_t nw_error_get_error_domain(nw_error_t error)
{
  return MEMORY[0x24BDE0FC8](error);
}

nw_protocol_definition_t nw_framer_create_definition(const char *identifier, uint32_t flags, nw_framer_start_handler_t start_handler)
{
  return (nw_protocol_definition_t)MEMORY[0x24BDE10F8](identifier, *(_QWORD *)&flags, start_handler);
}

nw_protocol_options_t nw_framer_create_options(nw_protocol_definition_t framer_definition)
{
  return (nw_protocol_options_t)MEMORY[0x24BDE1110](framer_definition);
}

BOOL nw_framer_deliver_input_no_copy(nw_framer_t framer, size_t input_length, nw_framer_message_t message, BOOL is_complete)
{
  return MEMORY[0x24BDE1128](framer, input_length, message, is_complete);
}

BOOL nw_framer_message_access_value(nw_framer_message_t message, const char *key, void *access_value)
{
  return MEMORY[0x24BDE1140](message, key, access_value);
}

nw_framer_message_t nw_framer_message_create(nw_framer_t framer)
{
  return (nw_framer_message_t)MEMORY[0x24BDE1150](framer);
}

void nw_framer_message_set_value(nw_framer_message_t message, const char *key, void *value, nw_framer_message_dispose_value_t dispose_value)
{
  MEMORY[0x24BDE1158](message, key, value, dispose_value);
}

BOOL nw_framer_parse_input(nw_framer_t framer, size_t minimum_incomplete_length, size_t maximum_length, uint8_t *temp_buffer, nw_framer_parse_completion_t parse)
{
  return MEMORY[0x24BDE1160](framer, minimum_incomplete_length, maximum_length, temp_buffer, parse);
}

nw_framer_message_t nw_framer_protocol_create_message(nw_protocol_definition_t definition)
{
  return (nw_framer_message_t)MEMORY[0x24BDE1178](definition);
}

void nw_framer_set_input_handler(nw_framer_t framer, nw_framer_input_handler_t input_handler)
{
  MEMORY[0x24BDE1180](framer, input_handler);
}

void nw_framer_set_output_handler(nw_framer_t framer, nw_framer_output_handler_t output_handler)
{
  MEMORY[0x24BDE1190](framer, output_handler);
}

void nw_framer_write_output(nw_framer_t framer, const uint8_t *output_buffer, size_t output_length)
{
  MEMORY[0x24BDE11A0](framer, output_buffer, output_length);
}

BOOL nw_framer_write_output_no_copy(nw_framer_t framer, size_t output_length)
{
  return MEMORY[0x24BDE11B8](framer, output_length);
}

void nw_listener_cancel(nw_listener_t listener)
{
  MEMORY[0x24BDE1440](listener);
}

nw_listener_t nw_listener_create(nw_parameters_t parameters)
{
  return (nw_listener_t)MEMORY[0x24BDE1448](parameters);
}

nw_listener_t nw_listener_create_with_port(const char *port, nw_parameters_t parameters)
{
  return (nw_listener_t)MEMORY[0x24BDE1458](port, parameters);
}

uint16_t nw_listener_get_port(nw_listener_t listener)
{
  return MEMORY[0x24BDE1460](listener);
}

void nw_listener_set_new_connection_handler(nw_listener_t listener, nw_listener_new_connection_handler_t handler)
{
  MEMORY[0x24BDE1488](listener, handler);
}

void nw_listener_set_queue(nw_listener_t listener, dispatch_queue_t queue)
{
  MEMORY[0x24BDE1498](listener, queue);
}

void nw_listener_set_state_changed_handler(nw_listener_t listener, nw_listener_state_changed_handler_t handler)
{
  MEMORY[0x24BDE14A0](listener, handler);
}

void nw_listener_start(nw_listener_t listener)
{
  MEMORY[0x24BDE14A8](listener);
}

nw_parameters_t nw_parameters_copy(nw_parameters_t parameters)
{
  return (nw_parameters_t)MEMORY[0x24BDE1518](parameters);
}

nw_protocol_stack_t nw_parameters_copy_default_protocol_stack(nw_parameters_t parameters)
{
  return (nw_protocol_stack_t)MEMORY[0x24BDE1528](parameters);
}

nw_parameters_t nw_parameters_create(void)
{
  return (nw_parameters_t)MEMORY[0x24BDE1558]();
}

uint64_t nw_parameters_set_context()
{
  return MEMORY[0x24BDE1648]();
}

void nw_parameters_set_local_endpoint(nw_parameters_t parameters, nw_endpoint_t local_endpoint)
{
  MEMORY[0x24BDE16C8](parameters, local_endpoint);
}

uint64_t nw_parameters_set_no_delay()
{
  return MEMORY[0x24BDE16E8]();
}

void nw_parameters_set_reuse_local_address(nw_parameters_t parameters, BOOL reuse_local_address)
{
  MEMORY[0x24BDE1758](parameters, reuse_local_address);
}

BOOL nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x24BDE1F40](metadata);
}

void nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t stack, nw_protocol_options_t protocol)
{
  MEMORY[0x24BDE2040](stack, protocol);
}

void nw_protocol_stack_set_transport_protocol(nw_protocol_stack_t stack, nw_protocol_options_t protocol)
{
  MEMORY[0x24BDE2058](stack, protocol);
}

nw_protocol_options_t nw_tcp_create_options(void)
{
  return (nw_protocol_options_t)MEMORY[0x24BDE2508]();
}

void nw_tcp_options_set_enable_keepalive(nw_protocol_options_t options, BOOL enable_keepalive)
{
  MEMORY[0x24BDE25B8](options, enable_keepalive);
}

void nw_tcp_options_set_keepalive_count(nw_protocol_options_t options, uint32_t keepalive_count)
{
  MEMORY[0x24BDE25C0](options, *(_QWORD *)&keepalive_count);
}

void nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t options, uint32_t keepalive_idle_time)
{
  MEMORY[0x24BDE25C8](options, *(_QWORD *)&keepalive_idle_time);
}

void nw_tcp_options_set_keepalive_interval(nw_protocol_options_t options, uint32_t keepalive_interval)
{
  MEMORY[0x24BDE25D0](options, *(_QWORD *)&keepalive_interval);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x24BEDCF90](superclass, name, extraBytes);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

id objc_constructInstance(Class cls, void *bytes)
{
  return (id)MEMORY[0x24BEDCFF8](cls, bytes);
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x24BEDD030](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x24BEDD038](location);
}

void *__cdecl objc_destructInstance(id obj)
{
  return (void *)MEMORY[0x24BEDD040](obj);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x24BEDD088](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x24BEDD0C0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x24BEDD0E8](location);
}

void objc_moveWeak(id *to, id *from)
{
  MEMORY[0x24BEDD0F8](to, from);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

void objc_registerClassPair(Class cls)
{
  MEMORY[0x24BEDD170](cls);
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x24BEDD2C0](a1);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x24BEDD420](location, obj);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x24BDAF368](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

uint64_t os_log_with_args()
{
  return MEMORY[0x24BDAF3A0]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF460](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x24BDAF488](lock);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x24BDAF818](a1, a2, a3, a4);
}

int pthread_getname_np(pthread_t a1, char *a2, size_t a3)
{
  return MEMORY[0x24BDAF850](a1, a2, a3);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x24BDAF978]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x24BDAF9A8](a1, a2);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x24BDAFAE0](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x24BDAFCE8](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x24BDAFD78](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4, *(_QWORD *)&a5);
}

int shutdown(int a1, int a2)
{
  return MEMORY[0x24BDAFDB0](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x24BDAFE50](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFEA0](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x24BDAFF00](__dst, __src);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

void uuid_generate_random(uuid_t out)
{
  MEMORY[0x24BDB0320](out);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

