uint64_t specialized PgQuery_RenameStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t RangeVar;
  uint64_t v5;
  uint64_t Node;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  char v15;

  *(_QWORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  *(_QWORD *)(v1 + 32) = 0;
  *(_BYTE *)(v1 + 40) = 1;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v5, 1, 1, Node);
  v7 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subname);
  *v7 = 0;
  v7[1] = 0xE000000000000000;
  v8 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newname);
  *v8 = 0;
  v8[1] = 0xE000000000000000;
  v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior;
  *(_QWORD *)v9 = 0;
  *(_BYTE *)(v9 + 8) = 1;
  v10 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk) = 0;
  v11 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(v1 + 24) = v11;
  v12 = *(_BYTE *)(a1 + 40);
  *(_QWORD *)(v1 + 32) = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v1 + 40) = v12;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object, v5, &demangling cache variable for type metadata for PgQuery_Node?);
  v13 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subname
                  + 8);
  *v7 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subname);
  v7[1] = v13;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v14 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newname
                  + 8);
  *v8 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newname);
  v8[1] = v14;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v15 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior
                 + 8);
  *(_QWORD *)v9 = *(_QWORD *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior);
  *(_BYTE *)(v9 + 8) = v15;
  *(_BYTE *)(v1 + v10) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk);
  return v1;
}

uint64_t specialized PgQuery_RuleStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t RangeVar;
  _QWORD *v5;
  uint64_t v6;
  uint64_t Node;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;

  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  v5 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rulename);
  *v5 = 0;
  v5[1] = 0xE000000000000000;
  v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v6, 1, 1, Node);
  v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__event;
  *(_QWORD *)v8 = 0;
  *(_BYTE *)(v8 + 8) = 1;
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__instead;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__instead) = 0;
  v10 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__actions;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__actions) = MEMORY[0x1E0DEE9D8];
  v11 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  v12 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rulename
                  + 8);
  *v5 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rulename);
  v5[1] = v12;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  v13 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__event
                 + 8);
  *(_QWORD *)v8 = *(_QWORD *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__event);
  *(_BYTE *)(v8 + 8) = v13;
  *(_BYTE *)(v1 + v9) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__instead);
  *(_QWORD *)(v1 + v10) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__actions);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(v1 + v11) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TransactionStmtKind, &type metadata for PgQuery_TransactionStmtKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TransactionStmtKind, &type metadata for PgQuery_TransactionStmtKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TransactionStmtKind, &type metadata for PgQuery_TransactionStmtKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TransactionStmtKind, &type metadata for PgQuery_TransactionStmtKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

uint64_t specialized PgQuery_ViewStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t RangeVar;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Node;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;

  v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__view;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  v5 = MEMORY[0x1E0DEE9D8];
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aliases;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aliases) = MEMORY[0x1E0DEE9D8];
  v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v7, 1, 1, Node);
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace) = 0;
  v10 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options) = v5;
  v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOption;
  *(_QWORD *)v11 = 0;
  *(_BYTE *)(v11 + 8) = 1;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__view, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  *(_QWORD *)(v1 + v6) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aliases);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_BYTE *)(v1 + v9) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace);
  *(_QWORD *)(v1 + v10) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v12 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOption
                 + 8);
  *(_QWORD *)v11 = *(_QWORD *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOption);
  *(_BYTE *)(v11 + 8) = v12;
  return v1;
}

uint64_t specialized PgQuery_CreateTableAsStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  uint64_t v5;
  uint64_t IntoClause;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__into;
  IntoClause = type metadata accessor for PgQuery_IntoClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(IntoClause - 8) + 56))(v5, 1, 1, IntoClause);
  v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind;
  *(_QWORD *)v7 = 0;
  *(_BYTE *)(v7 + 8) = 1;
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isSelectInto;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isSelectInto) = 0;
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__into, v5, &demangling cache variable for type metadata for PgQuery_IntoClause?);
  v10 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind
                 + 8);
  *(_QWORD *)v7 = *(_QWORD *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind);
  *(_BYTE *)(v7 + 8) = v10;
  *(_BYTE *)(v1 + v8) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isSelectInto);
  *(_BYTE *)(v1 + v9) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_VariableSetKind, &type metadata for PgQuery_VariableSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_VariableSetKind, &type metadata for PgQuery_VariableSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_VariableSetKind, &type metadata for PgQuery_VariableSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_VariableSetKind, &type metadata for PgQuery_VariableSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_DiscardMode, &type metadata for PgQuery_DiscardMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_DiscardMode, &type metadata for PgQuery_DiscardMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_DiscardMode, &type metadata for PgQuery_DiscardMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_DiscardMode, &type metadata for PgQuery_DiscardMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleStmtType, &type metadata for PgQuery_RoleStmtType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleStmtType, &type metadata for PgQuery_RoleStmtType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleStmtType, &type metadata for PgQuery_RoleStmtType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleStmtType, &type metadata for PgQuery_RoleStmtType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ReindexObjectType, &type metadata for PgQuery_ReindexObjectType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ReindexObjectType, &type metadata for PgQuery_ReindexObjectType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ReindexObjectType, &type metadata for PgQuery_ReindexObjectType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ReindexObjectType, &type metadata for PgQuery_ReindexObjectType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

uint64_t specialized PgQuery_CreateCastStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t TypeName;
  void (*v5)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t ObjectWithArgs;
  uint64_t v9;
  uint64_t v10;
  char v11;

  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sourcetype;
  TypeName = type metadata accessor for PgQuery_TypeName(0);
  v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(TypeName - 8) + 56);
  v5(v3, 1, 1, TypeName);
  v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targettype;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targettype, 1, 1, TypeName);
  v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__func;
  ObjectWithArgs = type metadata accessor for PgQuery_ObjectWithArgs(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(ObjectWithArgs - 8) + 56))(v7, 1, 1, ObjectWithArgs);
  v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__context;
  *(_QWORD *)v9 = 0;
  *(_BYTE *)(v9 + 8) = 1;
  v10 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inout;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inout) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sourcetype, v3, &demangling cache variable for type metadata for PgQuery_TypeName?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targettype, v6, &demangling cache variable for type metadata for PgQuery_TypeName?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__func, v7, &demangling cache variable for type metadata for PgQuery_ObjectWithArgs?);
  v11 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__context
                 + 8);
  *(_QWORD *)v9 = *(_QWORD *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__context);
  *(_BYTE *)(v9 + 8) = v11;
  *(_BYTE *)(v1 + v10) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inout);
  return v1;
}

uint64_t specialized PgQuery_AlterObjectDependsStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t RangeVar;
  uint64_t v5;
  uint64_t Node;
  void (*v7)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v8;
  uint64_t v9;
  char v10;

  *(_QWORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
  Node = type metadata accessor for PgQuery_Node(0);
  v7 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56);
  v7(v5, 1, 1, Node);
  v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__extname;
  v7(v1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__extname, 1, 1, Node);
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__remove;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__remove) = 0;
  v10 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(v1 + 24) = v10;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object, v5, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__extname, v8, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_BYTE *)(v1 + v9) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__remove);
  return v1;
}

uint64_t specialized PgQuery_AlterObjectSchemaStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t RangeVar;
  uint64_t v5;
  uint64_t Node;
  _QWORD *v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  *(_QWORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v5, 1, 1, Node);
  v7 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newschema);
  *v7 = 0;
  v7[1] = 0xE000000000000000;
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk) = 0;
  v9 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(v1 + 24) = v9;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object, v5, &demangling cache variable for type metadata for PgQuery_Node?);
  v10 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newschema
                  + 8);
  *v7 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newschema);
  v7[1] = v10;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(v1 + v8) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk);
  return v1;
}

uint64_t outlined assign with take of PgQuery_Node?(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;

  v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 40))(a2, a1, v5);
  return a2;
}

unint64_t lazy protocol witness table accessor for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterTSConfigType, &type metadata for PgQuery_AlterTSConfigType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterTSConfigType, &type metadata for PgQuery_AlterTSConfigType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterTSConfigType, &type metadata for PgQuery_AlterTSConfigType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterTSConfigType, &type metadata for PgQuery_AlterTSConfigType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ImportForeignSchemaType, &type metadata for PgQuery_ImportForeignSchemaType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ImportForeignSchemaType, &type metadata for PgQuery_ImportForeignSchemaType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ImportForeignSchemaType, &type metadata for PgQuery_ImportForeignSchemaType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ImportForeignSchemaType, &type metadata for PgQuery_ImportForeignSchemaType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterSubscriptionType, &type metadata for PgQuery_AlterSubscriptionType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterSubscriptionType, &type metadata for PgQuery_AlterSubscriptionType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterSubscriptionType, &type metadata for PgQuery_AlterSubscriptionType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AlterSubscriptionType, &type metadata for PgQuery_AlterSubscriptionType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

uint64_t specialized PgQuery_A_Expr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  void (*v5)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  char v8;

  *(_QWORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  *(_QWORD *)(v1 + 32) = MEMORY[0x1E0DEE9D8];
  v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr;
  Node = type metadata accessor for PgQuery_Node(0);
  v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  v6 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr, 1, 1, Node);
  v7 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v8 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(v1 + 24) = v8;
  *(_QWORD *)(v1 + 32) = *(_QWORD *)(a1 + 32);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

_QWORD *specialized PgQuery_FuncCall._StorageClass.init(copying:)(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t Node;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t WindowDef;
  uint64_t v12;

  v3 = MEMORY[0x1E0DEE9D8];
  v1[2] = MEMORY[0x1E0DEE9D8];
  v1[3] = v3;
  v1[4] = v3;
  v4 = (uint64_t)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggFilter;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v4, 1, 1, Node);
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggWithinGroup;
  *((_BYTE *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggWithinGroup) = 0;
  v7 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggStar;
  *((_BYTE *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggStar) = 0;
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggDistinct;
  *((_BYTE *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggDistinct) = 0;
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcVariadic;
  *((_BYTE *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcVariadic) = 0;
  v10 = (uint64_t)v1
      + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__over;
  WindowDef = type metadata accessor for PgQuery_WindowDef(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(WindowDef - 8) + 56))(v10, 1, 1, WindowDef);
  v12 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)((char *)v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v1[2] = a1[2];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v1[3] = a1[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v1[4] = a1[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggFilter, v4, &demangling cache variable for type metadata for PgQuery_Node?);
  *((_BYTE *)v1 + v6) = *((_BYTE *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggWithinGroup);
  *((_BYTE *)v1 + v7) = *((_BYTE *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggStar);
  *((_BYTE *)v1 + v8) = *((_BYTE *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggDistinct);
  *((_BYTE *)v1 + v9) = *((_BYTE *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcVariadic);
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__over, v10, &demangling cache variable for type metadata for PgQuery_WindowDef?);
  *(_DWORD *)((char *)v1 + v12) = *(_DWORD *)((char *)a1
                                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

_QWORD *specialized PgQuery_ResTarget._StorageClass.init(copying:)(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t Node;
  uint64_t v5;
  uint64_t v6;

  v1[2] = 0;
  v1[3] = 0xE000000000000000;
  v1[4] = MEMORY[0x1E0DEE9D8];
  v3 = (uint64_t)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)((char *)v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v6 = a1[3];
  v1[2] = a1[2];
  v1[3] = v6;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v1[4] = a1[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)((char *)v1 + v5) = *(_DWORD *)((char *)a1
                                           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_SortBy._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  char v10;

  v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyDir;
  *(_QWORD *)v5 = 0;
  *(_BYTE *)(v5 + 8) = 1;
  v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyNulls;
  *(_QWORD *)v6 = 0;
  *(_BYTE *)(v6 + 8) = 1;
  v7 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOp;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOp) = MEMORY[0x1E0DEE9D8];
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  v9 = *(_BYTE *)(a1
                + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyDir
                + 8);
  *(_QWORD *)v5 = *(_QWORD *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyDir);
  *(_BYTE *)(v5 + 8) = v9;
  v10 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyNulls
                 + 8);
  *(_QWORD *)v6 = *(_QWORD *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyNulls);
  *(_BYTE *)(v6 + 8) = v10;
  *(_QWORD *)(v1 + v7) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOp);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_WindowDef._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t Node;
  void (*v6)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0xE000000000000000;
  *(_QWORD *)(v1 + 32) = 0;
  *(_QWORD *)(v1 + 40) = 0xE000000000000000;
  v3 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1 + 48) = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1 + 56) = v3;
  *(_DWORD *)(v1 + 64) = 0;
  v4 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset;
  Node = type metadata accessor for PgQuery_Node(0);
  v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56);
  v6(v4, 1, 1, Node);
  v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset;
  v6(v1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset, 1, 1, Node);
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v9 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v1 + 24) = v9;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v10 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v1 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v1 + 40) = v10;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + 48) = *(_QWORD *)(a1 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + 56) = *(_QWORD *)(a1 + 56);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + 64) = *(_DWORD *)(a1 + 64);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset, v4, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_RangeTableSample._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  void (*v5)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  Node = type metadata accessor for PgQuery_Node(0);
  v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__method;
  v7 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__method) = MEMORY[0x1E0DEE9D8];
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = v7;
  v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__repeatable;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__repeatable, 1, 1, Node);
  v10 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_QWORD *)(v1 + v6) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__method);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v8) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__repeatable, v9, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_RangeTableFunc._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  void (*v5)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t Alias;
  uint64_t v12;

  *(_BYTE *)(v1 + 16) = 0;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__docexpr;
  Node = type metadata accessor for PgQuery_Node(0);
  v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr, 1, 1, Node);
  v7 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namespaces;
  v8 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namespaces) = MEMORY[0x1E0DEE9D8];
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__columns;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__columns) = v8;
  v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias;
  Alias = type metadata accessor for PgQuery_Alias(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Alias - 8) + 56))(v10, 1, 1, Alias);
  v12 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  *(_BYTE *)(v1 + 16) = *(_BYTE *)(a1 + 16);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__docexpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_QWORD *)(v1 + v7) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namespaces);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v9) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__columns);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias, v10, &demangling cache variable for type metadata for PgQuery_Alias?);
  *(_DWORD *)(v1 + v12) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_RangeTableFuncCol._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t TypeName;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Node;
  void (*v9)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0xE000000000000000;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
  TypeName = type metadata accessor for PgQuery_TypeName(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(TypeName - 8) + 56))(v3, 1, 1, TypeName);
  v5 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__forOrdinality;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__forOrdinality) = 0;
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull) = 0;
  v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colexpr;
  Node = type metadata accessor for PgQuery_Node(0);
  v9 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56);
  v9(v7, 1, 1, Node);
  v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexpr;
  v9(v1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexpr, 1, 1, Node);
  v11 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v12 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v1 + 24) = v12;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName, v3, &demangling cache variable for type metadata for PgQuery_TypeName?);
  *(_BYTE *)(v1 + v5) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__forOrdinality);
  *(_BYTE *)(v1 + v6) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colexpr, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexpr, v10, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_ColumnDef._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t TypeName;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t Node;
  void (*v10)(void);
  _QWORD *v11;
  uint64_t v12;
  uint64_t RangeVar;
  _QWORD *v14;
  uint64_t v15;
  uint64_t CollateClause;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0xE000000000000000;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
  v28 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
  TypeName = type metadata accessor for PgQuery_TypeName(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(TypeName - 8) + 56))(v3, 1, 1, TypeName);
  v26 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhcount;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhcount) = 0;
  v5 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isLocal;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isLocal) = 0;
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull) = 0;
  v25 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isFromType;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isFromType) = 0;
  v7 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__storage);
  *v7 = 0;
  v7[1] = 0xE000000000000000;
  v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawDefault;
  v31 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawDefault;
  Node = type metadata accessor for PgQuery_Node(0);
  v10 = *(void (**)(void))(*(_QWORD *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v10)(v8, 1, 1, Node);
  v27 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedDefault;
  v10();
  v11 = (_QWORD *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identity);
  *v11 = 0;
  v11[1] = 0xE000000000000000;
  v12 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identitySequence;
  v30 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identitySequence;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(RangeVar - 8) + 56))(v12, 1, 1, RangeVar);
  v14 = (_QWORD *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generated);
  *v14 = 0;
  v14[1] = 0xE000000000000000;
  v15 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collClause;
  v32 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collClause;
  CollateClause = type metadata accessor for PgQuery_CollateClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CollateClause - 8) + 56))(v15, 1, 1, CollateClause);
  v29 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid) = 0;
  v17 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints;
  v18 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints) = MEMORY[0x1E0DEE9D8];
  v19 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fdwoptions;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fdwoptions) = v18;
  v33 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v20 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v1 + 24) = v20;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName, v28, &demangling cache variable for type metadata for PgQuery_TypeName?);
  *(_DWORD *)(v1 + v26) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhcount);
  *(_BYTE *)(v1 + v5) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isLocal);
  *(_BYTE *)(v1 + v6) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull);
  *(_BYTE *)(v1 + v25) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isFromType);
  v21 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__storage
                  + 8);
  *v7 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__storage);
  v7[1] = v21;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawDefault, v31, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedDefault, v27, &demangling cache variable for type metadata for PgQuery_Node?);
  v22 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identity
                  + 8);
  *v11 = *(_QWORD *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identity);
  v11[1] = v22;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identitySequence, v30, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  v23 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generated
                  + 8);
  *v14 = *(_QWORD *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generated);
  v14[1] = v23;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collClause, v32, &demangling cache variable for type metadata for PgQuery_CollateClause?);
  *(_DWORD *)(v1 + v29) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid);
  *(_QWORD *)(v1 + v17) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v19) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fdwoptions);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v33) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_IndexElem._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  char v15;

  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0xE000000000000000;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexcolname);
  *v5 = 0;
  v5[1] = 0xE000000000000000;
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation;
  v7 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation) = MEMORY[0x1E0DEE9D8];
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass) = v7;
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclassopts;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclassopts) = v7;
  v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordering;
  *(_QWORD *)v10 = 0;
  *(_BYTE *)(v10 + 8) = 1;
  v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nullsOrdering;
  *(_QWORD *)v11 = 0;
  *(_BYTE *)(v11 + 8) = 1;
  v12 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v1 + 24) = v12;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  v13 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexcolname
                  + 8);
  *v5 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexcolname);
  v5[1] = v13;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v6) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v8) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v9) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclassopts);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v14 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordering
                 + 8);
  *(_QWORD *)v10 = *(_QWORD *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordering);
  *(_BYTE *)(v10 + 8) = v14;
  v15 = *(_BYTE *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nullsOrdering
                 + 8);
  *(_QWORD *)v11 = *(_QWORD *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nullsOrdering);
  *(_BYTE *)(v11 + 8) = v15;
  return v1;
}

uint64_t specialized PgQuery_Constraint._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  void (*v5)(void);
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t RangeVar;
  uint64_t v13;
  _QWORD *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  *(_QWORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  *(_QWORD *)(v1 + 32) = 0;
  *(_QWORD *)(v1 + 40) = 0xE000000000000000;
  *(_WORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 52) = 0;
  *(_BYTE *)(v1 + 56) = 0;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawExpr;
  v26 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawExpr;
  Node = type metadata accessor for PgQuery_Node(0);
  v5 = *(void (**)(void))(*(_QWORD *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v3, 1, 1, Node);
  v6 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedExpr);
  *v6 = 0;
  v6[1] = 0xE000000000000000;
  v7 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generatedWhen);
  *v7 = 0;
  v7[1] = 0xE000000000000000;
  v27 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__keys;
  v8 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__keys) = MEMORY[0x1E0DEE9D8];
  v28 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__including;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__including) = v8;
  v29 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__exclusions;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__exclusions) = v8;
  v30 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options) = v8;
  v9 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexname);
  *v9 = 0;
  v9[1] = 0xE000000000000000;
  v10 = (_QWORD *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexspace);
  *v10 = 0;
  v10[1] = 0xE000000000000000;
  v32 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc) = 0;
  v31 = (_QWORD *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  *v31 = 0;
  v31[1] = 0xE000000000000000;
  v35 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  v5();
  v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pktable;
  v33 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pktable;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(RangeVar - 8) + 56))(v11, 1, 1, RangeVar);
  v13 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkAttrs;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkAttrs) = v8;
  v34 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pkAttrs;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pkAttrs) = v8;
  v14 = (_QWORD *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkMatchtype);
  *v14 = 0;
  v14[1] = 0xE000000000000000;
  v36 = (_QWORD *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkUpdAction);
  *v36 = 0;
  v36[1] = 0xE000000000000000;
  v37 = (_QWORD *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkDelAction);
  *v37 = 0;
  v37[1] = 0xE000000000000000;
  v38 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldConpfeqop;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldConpfeqop) = v8;
  v41 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldPktableOid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldPktableOid) = 0;
  v40 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipValidation;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipValidation) = 0;
  v39 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initiallyValid;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initiallyValid) = 0;
  v15 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(v1 + 24) = v15;
  v16 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v1 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v1 + 40) = v16;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(v1 + 48) = *(_BYTE *)(a1 + 48);
  *(_BYTE *)(v1 + 49) = *(_BYTE *)(a1 + 49);
  *(_DWORD *)(v1 + 52) = *(_DWORD *)(a1 + 52);
  *(_BYTE *)(v1 + 56) = *(_BYTE *)(a1 + 56);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawExpr, v26, &demangling cache variable for type metadata for PgQuery_Node?);
  v17 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedExpr
                  + 8);
  *v6 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedExpr);
  v6[1] = v17;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v18 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generatedWhen
                  + 8);
  *v7 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generatedWhen);
  v7[1] = v18;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v27) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__keys);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v28) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__including);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v29) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__exclusions);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v30) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v19 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexname
                  + 8);
  *v9 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexname);
  v9[1] = v19;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v20 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexspace
                  + 8);
  *v10 = *(_QWORD *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexspace);
  v10[1] = v20;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(v1 + v32) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc);
  v21 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod
                  + 8);
  *v31 = *(_QWORD *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  v31[1] = v21;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v35, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pktable, v33, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  *(_QWORD *)(v1 + v13) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkAttrs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v34) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pkAttrs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v22 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkMatchtype
                  + 8);
  *v14 = *(_QWORD *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkMatchtype);
  v14[1] = v22;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v23 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkUpdAction
                  + 8);
  *v36 = *(_QWORD *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkUpdAction);
  v36[1] = v23;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v24 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkDelAction
                  + 8);
  *v37 = *(_QWORD *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkDelAction);
  v37[1] = v24;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v38) = *(_QWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldConpfeqop);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v41) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldPktableOid);
  *(_BYTE *)(v1 + v40) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipValidation);
  *(_BYTE *)(v1 + v39) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initiallyValid);
  return v1;
}

_QWORD *specialized PgQuery_DefElem._StorageClass.init(copying:)(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t Node;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  v1[2] = 0;
  v1[3] = 0xE000000000000000;
  v1[4] = 0;
  v1[5] = 0xE000000000000000;
  v3 = (uint64_t)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = (char *)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defaction;
  *(_QWORD *)v5 = 0;
  v5[8] = 1;
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)((char *)v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v7 = a1[3];
  v1[2] = a1[2];
  v1[3] = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v8 = a1[5];
  v1[4] = a1[4];
  v1[5] = v8;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  v9 = *((_BYTE *)a1
       + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defaction
       + 8);
  *(_QWORD *)v5 = *(_QWORD *)((char *)a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defaction);
  v5[8] = v9;
  *(_DWORD *)((char *)v1 + v6) = *(_DWORD *)((char *)a1
                                           + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_WithCheckOption._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  *(_QWORD *)(v1 + 32) = 0;
  *(_QWORD *)(v1 + 40) = 0xE000000000000000;
  *(_QWORD *)(v1 + 48) = 0;
  *(_QWORD *)(v1 + 56) = 0xE000000000000000;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__qual;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cascaded;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cascaded) = 0;
  v6 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(v1 + 24) = v6;
  v7 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v1 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v1 + 40) = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(v1 + 48) = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(v1 + 56) = v8;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__qual, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_BYTE *)(v1 + v5) = *(_BYTE *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cascaded);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_GroupingSetKind, &type metadata for PgQuery_GroupingSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_GroupingSetKind, &type metadata for PgQuery_GroupingSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_GroupingSetKind, &type metadata for PgQuery_GroupingSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_GroupingSetKind, &type metadata for PgQuery_GroupingSetKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

uint64_t specialized PgQuery_WindowClause._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t Node;
  void (*v6)(void);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0xE000000000000000;
  *(_QWORD *)(v1 + 32) = 0;
  *(_QWORD *)(v1 + 40) = 0xE000000000000000;
  v3 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1 + 48) = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1 + 56) = v3;
  *(_DWORD *)(v1 + 64) = 0;
  v4 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset;
  v18 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset;
  Node = type metadata accessor for PgQuery_Node(0);
  v6 = *(void (**)(void))(*(_QWORD *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v6)(v4, 1, 1, Node);
  v17 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset;
  v6();
  v7 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startInRangeFunc;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startInRangeFunc) = 0;
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endInRangeFunc;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endInRangeFunc) = 0;
  v9 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeColl;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeColl) = 0;
  v10 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeAsc;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeAsc) = 0;
  v11 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeNullsFirst;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeNullsFirst) = 0;
  v12 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref) = 0;
  v13 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__copiedOrder;
  *(_BYTE *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__copiedOrder) = 0;
  v14 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v1 + 24) = v14;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v15 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v1 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v1 + 40) = v15;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + 48) = *(_QWORD *)(a1 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + 56) = *(_QWORD *)(a1 + 56);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + 64) = *(_DWORD *)(a1 + 64);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset, v18, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset, v17, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startInRangeFunc);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endInRangeFunc);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeColl);
  *(_BYTE *)(v1 + v10) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeAsc);
  *(_BYTE *)(v1 + v11) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeNullsFirst);
  *(_DWORD *)(v1 + v12) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref);
  *(_BYTE *)(v1 + v13) = *(_BYTE *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__copiedOrder);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockClauseStrength, &type metadata for PgQuery_LockClauseStrength);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockClauseStrength, &type metadata for PgQuery_LockClauseStrength);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockClauseStrength, &type metadata for PgQuery_LockClauseStrength);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockClauseStrength, &type metadata for PgQuery_LockClauseStrength);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockWaitPolicy, &type metadata for PgQuery_LockWaitPolicy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockWaitPolicy, &type metadata for PgQuery_LockWaitPolicy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockWaitPolicy, &type metadata for PgQuery_LockWaitPolicy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockWaitPolicy, &type metadata for PgQuery_LockWaitPolicy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

uint64_t specialized PgQuery_InferClause._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)(v1 + 16) = MEMORY[0x1E0DEE9D8];
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = (_QWORD *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__conname);
  *v5 = 0;
  v5[1] = 0xE000000000000000;
  v6 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  v7 = *(_QWORD *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__conname
                 + 8);
  *v5 = *(_QWORD *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__conname);
  v5[1] = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_OnConflictClause._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t InferClause;
  uint64_t v5;
  uint64_t v6;
  uint64_t Node;
  uint64_t v8;
  char v9;

  *(_QWORD *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 24) = 1;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__infer;
  InferClause = type metadata accessor for PgQuery_InferClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(InferClause - 8) + 56))(v3, 1, 1, InferClause);
  v5 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList) = MEMORY[0x1E0DEE9D8];
  v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v6, 1, 1, Node);
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v9 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(v1 + 24) = v9;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__infer, v3, &demangling cache variable for type metadata for PgQuery_InferClause?);
  *(_QWORD *)(v1 + v5) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t outlined assign with copy of PgQuery_Node?(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;

  v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 24))(a2, a1, v5);
  return a2;
}

unint64_t lazy protocol witness table accessor for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleSpecType, &type metadata for PgQuery_RoleSpecType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleSpecType, &type metadata for PgQuery_RoleSpecType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleSpecType, &type metadata for PgQuery_RoleSpecType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_RoleSpecType, &type metadata for PgQuery_RoleSpecType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

uint64_t specialized PgQuery_PartitionElem._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t Node;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)(v1 + 16) = 0;
  *(_QWORD *)(v1 + 24) = 0xE000000000000000;
  v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
  Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Node - 8) + 56))(v3, 1, 1, Node);
  v5 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation;
  v6 = MEMORY[0x1E0DEE9D8];
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation) = MEMORY[0x1E0DEE9D8];
  v7 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass;
  *(_QWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass) = v6;
  v8 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v9 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v1 + 24) = v9;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_QWORD *)(v1 + v5) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v1 + v7) = *(_QWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_Token and conformance PgQuery_Token()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_Token, &type metadata for PgQuery_Token);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_Token, &type metadata for PgQuery_Token);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_Token, &type metadata for PgQuery_Token);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_Token, &type metadata for PgQuery_Token);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_KeywordKind, &type metadata for PgQuery_KeywordKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_KeywordKind, &type metadata for PgQuery_KeywordKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_KeywordKind, &type metadata for PgQuery_KeywordKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_KeywordKind, &type metadata for PgQuery_KeywordKind);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

ValueMetadata *type metadata accessor for PgQuery_TableLikeOption()
{
  return &type metadata for PgQuery_TableLikeOption;
}

ValueMetadata *type metadata accessor for PgQuery_ClusterOption()
{
  return &type metadata for PgQuery_ClusterOption;
}

ValueMetadata *type metadata accessor for PgQuery_AggStrategy()
{
  return &type metadata for PgQuery_AggStrategy;
}

ValueMetadata *type metadata accessor for PgQuery_SetOpCmd()
{
  return &type metadata for PgQuery_SetOpCmd;
}

ValueMetadata *type metadata accessor for PgQuery_SetOpStrategy()
{
  return &type metadata for PgQuery_SetOpStrategy;
}

ValueMetadata *type metadata accessor for PgQuery_LockTupleMode()
{
  return &type metadata for PgQuery_LockTupleMode;
}

ValueMetadata *type metadata accessor for PgQuery_KeywordKind()
{
  return &type metadata for PgQuery_KeywordKind;
}

ValueMetadata *type metadata accessor for PgQuery_Token()
{
  return &type metadata for PgQuery_Token;
}

ValueMetadata *type metadata accessor for PgQuery_RoleSpecType()
{
  return &type metadata for PgQuery_RoleSpecType;
}

uint64_t getEnumTagSinglePayload for PgQuery_Null()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t storeEnumTagSinglePayload for PgQuery_Null()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

uint64_t getEnumTagSinglePayload for PgQuery_A_Star()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t storeEnumTagSinglePayload for PgQuery_A_Star()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

uint64_t getEnumTagSinglePayload for PgQuery_CheckPointStmt()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t storeEnumTagSinglePayload for PgQuery_CheckPointStmt()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

uint64_t initializeBufferWithCopyOfBuffer for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for UnknownStorage();
  return (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v4 - 8))(a1, a2, v4);
}

uint64_t destroy for PgQuery_Null(uint64_t a1)
{
  uint64_t v2;

  v2 = type metadata accessor for UnknownStorage();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v2 - 8) + 8))(a1, v2);
}

uint64_t initializeWithCopy for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a1, a2, v4);
  return a1;
}

uint64_t assignWithCopy for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 24))(a1, a2, v4);
  return a1;
}

uint64_t initializeWithTake for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 32))(a1, a2, v4);
  return a1;
}

uint64_t assignWithTake for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 40))(a1, a2, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for PgQuery_Expr()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t __swift_get_extra_inhabitant_index_453Tm(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for UnknownStorage();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 48))(a1, a2, v4);
}

uint64_t storeEnumTagSinglePayload for PgQuery_Expr()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

uint64_t __swift_store_extra_inhabitant_index_454Tm(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for UnknownStorage();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 56))(a1, a2, a2, v4);
}

uint64_t type metadata completion function for PgQuery_Null()
{
  uint64_t result;
  unint64_t v1;

  result = type metadata accessor for UnknownStorage();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for PgQuery_LockWaitPolicy()
{
  return &type metadata for PgQuery_LockWaitPolicy;
}

ValueMetadata *type metadata accessor for PgQuery_LockClauseStrength()
{
  return &type metadata for PgQuery_LockClauseStrength;
}

ValueMetadata *type metadata accessor for PgQuery_GroupingSetKind()
{
  return &type metadata for PgQuery_GroupingSetKind;
}

ValueMetadata *type metadata accessor for PgQuery_AlterSubscriptionType()
{
  return &type metadata for PgQuery_AlterSubscriptionType;
}

ValueMetadata *type metadata accessor for PgQuery_ImportForeignSchemaType()
{
  return &type metadata for PgQuery_ImportForeignSchemaType;
}

ValueMetadata *type metadata accessor for PgQuery_AlterTSConfigType()
{
  return &type metadata for PgQuery_AlterTSConfigType;
}

ValueMetadata *type metadata accessor for PgQuery_ReindexObjectType()
{
  return &type metadata for PgQuery_ReindexObjectType;
}

ValueMetadata *type metadata accessor for PgQuery_RoleStmtType()
{
  return &type metadata for PgQuery_RoleStmtType;
}

ValueMetadata *type metadata accessor for PgQuery_DiscardMode()
{
  return &type metadata for PgQuery_DiscardMode;
}

ValueMetadata *type metadata accessor for PgQuery_VariableSetKind()
{
  return &type metadata for PgQuery_VariableSetKind;
}

ValueMetadata *type metadata accessor for PgQuery_TransactionStmtKind()
{
  return &type metadata for PgQuery_TransactionStmtKind;
}

ValueMetadata *type metadata accessor for PgQuery_FetchDirection()
{
  return &type metadata for PgQuery_FetchDirection;
}

ValueMetadata *type metadata accessor for PgQuery_GrantTargetType()
{
  return &type metadata for PgQuery_GrantTargetType;
}

_QWORD *initializeBufferWithCopyOfBuffer for PgQuery_ScanToken(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (_QWORD *)a1;
  v4 = *(_DWORD *)(*(_QWORD *)(a3 - 8) + 80);
  if ((v4 & 0x20000) != 0)
  {
    v9 = *a2;
    *v3 = *a2;
    v3 = (_QWORD *)(v9 + ((v4 + 16) & ~(unint64_t)v4));
    swift_retain();
  }
  else
  {
    *(_QWORD *)a1 = *a2;
    *(_QWORD *)(a1 + 8) = a2[1];
    *(_BYTE *)(a1 + 16) = *((_BYTE *)a2 + 16);
    *(_QWORD *)(a1 + 24) = a2[3];
    v5 = *(int *)(a3 + 32);
    v6 = a1 + v5;
    v7 = (uint64_t)a2 + v5;
    *(_BYTE *)(a1 + 32) = *((_BYTE *)a2 + 32);
    v8 = type metadata accessor for UnknownStorage();
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 16))(v6, v7, v8);
  }
  return v3;
}

uint64_t destroy for PgQuery_RowMarkClause(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + *(int *)(a2 + 32);
  v3 = type metadata accessor for UnknownStorage();
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v3 - 8) + 8))(v2, v3);
}

uint64_t initializeWithCopy for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  v4 = *(int *)(a3 + 32);
  v5 = a1 + v4;
  v6 = a2 + v4;
  v7 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 16))(v5, v6, v7);
  return a1;
}

uint64_t assignWithCopy for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  v5 = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = v5;
  v6 = *(int *)(a3 + 32);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 24))(v7, v8, v9);
  return a1;
}

uint64_t initializeWithTake for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  v4 = *(int *)(a3 + 32);
  v5 = a1 + v4;
  v6 = a2 + v4;
  v7 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 32))(v5, v6, v7);
  return a1;
}

uint64_t assignWithTake for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 32);
  v4 = *(int *)(a3 + 32);
  v5 = a1 + v4;
  v6 = a2 + v4;
  v7 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 40))(v5, v6, v7);
  return a1;
}

uint64_t getEnumTagSinglePayload for PgQuery_ScanToken()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t sub_18DAE29F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a1 + *(int *)(a3 + 32);
  v5 = type metadata accessor for UnknownStorage();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 48))(v4, a2, v5);
}

uint64_t storeEnumTagSinglePayload for PgQuery_ScanToken()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

uint64_t sub_18DAE2A44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = a1 + *(int *)(a4 + 32);
  v6 = type metadata accessor for UnknownStorage();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 56))(v5, a2, a2, v6);
}

uint64_t type metadata completion function for PgQuery_ScanToken()
{
  return type metadata completion function for PgQuery_InlineCodeBlock();
}

unint64_t lazy protocol witness table accessor for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockTupleMode, &type metadata for PgQuery_LockTupleMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockTupleMode, &type metadata for PgQuery_LockTupleMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockTupleMode, &type metadata for PgQuery_LockTupleMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_LockTupleMode, &type metadata for PgQuery_LockTupleMode);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpStrategy, &type metadata for PgQuery_SetOpStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpStrategy, &type metadata for PgQuery_SetOpStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpStrategy, &type metadata for PgQuery_SetOpStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpStrategy, &type metadata for PgQuery_SetOpStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpCmd, &type metadata for PgQuery_SetOpCmd);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpCmd, &type metadata for PgQuery_SetOpCmd);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpCmd, &type metadata for PgQuery_SetOpCmd);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_SetOpCmd, &type metadata for PgQuery_SetOpCmd);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AggStrategy, &type metadata for PgQuery_AggStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AggStrategy, &type metadata for PgQuery_AggStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AggStrategy, &type metadata for PgQuery_AggStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_AggStrategy, &type metadata for PgQuery_AggStrategy);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ClusterOption, &type metadata for PgQuery_ClusterOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ClusterOption, &type metadata for PgQuery_ClusterOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ClusterOption, &type metadata for PgQuery_ClusterOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_ClusterOption, &type metadata for PgQuery_ClusterOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TableLikeOption, &type metadata for PgQuery_TableLikeOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TableLikeOption, &type metadata for PgQuery_TableLikeOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TableLikeOption, &type metadata for PgQuery_TableLikeOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for PgQuery_TableLikeOption, &type metadata for PgQuery_TableLikeOption);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

BOOL specialized == infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1 == a3;
}

uint64_t sub_18DAE4004(uint64_t a1, unsigned __int8 a2)
{
  return ((uint64_t (*)(uint64_t))((char *)sub_18DAE4060 + 4 * byte_18DC2B98D[a2]))(1279346002);
}

uint64_t sub_18DAE4060(uint64_t a1)
{
  uint64_t v1;
  char v2;

  if (a1 == 1279346002 && v1 == 0xE400000000000000)
    v2 = 1;
  else
    v2 = _stringCompareWithSmolCheck(_:_:expecting:)();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v2 & 1;
}

uint64_t specialized == infix<A>(_:_:)()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v5;

  v0 = SQLFunction.rawValue.getter();
  v2 = v1;
  if (v0 == SQLFunction.rawValue.getter() && v2 == v3)
    v5 = 1;
  else
    v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v5 & 1;
}

BiomeSQLParser::SQLFunction_optional __swiftcall SQLFunction.init(rawValue:)(Swift::String rawValue)
{
  char *v1;
  char *v2;
  uint64_t v3;
  BiomeSQLParser::SQLFunction_optional result;
  char v5;
  char v6;

  v2 = v1;
  v3 = _findStringSwitchCaseWithCache(cases:string:cache:)();
  result.value = swift_bridgeObjectRelease();
  v5 = 0;
  v6 = 80;
  switch(v3)
  {
    case 0:
      goto LABEL_82;
    case 1:
      v5 = 1;
      goto LABEL_82;
    case 2:
      v5 = 2;
      goto LABEL_82;
    case 3:
      v5 = 3;
      goto LABEL_82;
    case 4:
      v5 = 4;
      goto LABEL_82;
    case 5:
      v5 = 5;
      goto LABEL_82;
    case 6:
      v5 = 6;
      goto LABEL_82;
    case 7:
      v5 = 7;
      goto LABEL_82;
    case 8:
      v5 = 8;
      goto LABEL_82;
    case 9:
      v5 = 9;
      goto LABEL_82;
    case 10:
      v5 = 10;
      goto LABEL_82;
    case 11:
      v5 = 11;
      goto LABEL_82;
    case 12:
      v5 = 12;
      goto LABEL_82;
    case 13:
      v5 = 13;
      goto LABEL_82;
    case 14:
      v5 = 14;
      goto LABEL_82;
    case 15:
      v5 = 15;
      goto LABEL_82;
    case 16:
      v5 = 16;
      goto LABEL_82;
    case 17:
      v5 = 17;
      goto LABEL_82;
    case 18:
      v5 = 18;
      goto LABEL_82;
    case 19:
      v5 = 19;
      goto LABEL_82;
    case 20:
      v5 = 20;
      goto LABEL_82;
    case 21:
      v5 = 21;
      goto LABEL_82;
    case 22:
      v5 = 22;
      goto LABEL_82;
    case 23:
      v5 = 23;
      goto LABEL_82;
    case 24:
      v5 = 24;
      goto LABEL_82;
    case 25:
      v5 = 25;
      goto LABEL_82;
    case 26:
      v5 = 26;
      goto LABEL_82;
    case 27:
      v5 = 27;
      goto LABEL_82;
    case 28:
      v5 = 28;
      goto LABEL_82;
    case 29:
      v5 = 29;
      goto LABEL_82;
    case 30:
      v5 = 30;
      goto LABEL_82;
    case 31:
      v5 = 31;
      goto LABEL_82;
    case 32:
      v5 = 32;
      goto LABEL_82;
    case 33:
      v5 = 33;
      goto LABEL_82;
    case 34:
      v5 = 34;
      goto LABEL_82;
    case 35:
      v5 = 35;
      goto LABEL_82;
    case 36:
      v5 = 36;
      goto LABEL_82;
    case 37:
      v5 = 37;
      goto LABEL_82;
    case 38:
      v5 = 38;
      goto LABEL_82;
    case 39:
      v5 = 39;
      goto LABEL_82;
    case 40:
      v5 = 40;
      goto LABEL_82;
    case 41:
      v5 = 41;
      goto LABEL_82;
    case 42:
      v5 = 42;
      goto LABEL_82;
    case 43:
      v5 = 43;
      goto LABEL_82;
    case 44:
      v5 = 44;
      goto LABEL_82;
    case 45:
      v5 = 45;
      goto LABEL_82;
    case 46:
      v5 = 46;
      goto LABEL_82;
    case 47:
      v5 = 47;
      goto LABEL_82;
    case 48:
      v5 = 48;
      goto LABEL_82;
    case 49:
      v5 = 49;
      goto LABEL_82;
    case 50:
      v5 = 50;
      goto LABEL_82;
    case 51:
      v5 = 51;
      goto LABEL_82;
    case 52:
      v5 = 52;
      goto LABEL_82;
    case 53:
      v5 = 53;
      goto LABEL_82;
    case 54:
      v5 = 54;
      goto LABEL_82;
    case 55:
      v5 = 55;
      goto LABEL_82;
    case 56:
      v5 = 56;
      goto LABEL_82;
    case 57:
      v5 = 57;
      goto LABEL_82;
    case 58:
      v5 = 58;
      goto LABEL_82;
    case 59:
      v5 = 59;
      goto LABEL_82;
    case 60:
      v5 = 60;
      goto LABEL_82;
    case 61:
      v5 = 61;
      goto LABEL_82;
    case 62:
      v5 = 62;
      goto LABEL_82;
    case 63:
      v5 = 63;
      goto LABEL_82;
    case 64:
      v5 = 64;
      goto LABEL_82;
    case 65:
      v5 = 65;
      goto LABEL_82;
    case 66:
      v5 = 66;
      goto LABEL_82;
    case 67:
      v5 = 67;
      goto LABEL_82;
    case 68:
      v5 = 68;
      goto LABEL_82;
    case 69:
      v5 = 69;
      goto LABEL_82;
    case 70:
      v5 = 70;
      goto LABEL_82;
    case 71:
      v5 = 71;
      goto LABEL_82;
    case 72:
      v5 = 72;
      goto LABEL_82;
    case 73:
      v5 = 73;
      goto LABEL_82;
    case 74:
      v5 = 74;
      goto LABEL_82;
    case 75:
      v5 = 75;
      goto LABEL_82;
    case 76:
      v5 = 76;
      goto LABEL_82;
    case 77:
      v5 = 77;
      goto LABEL_82;
    case 78:
      v5 = 78;
      goto LABEL_82;
    case 79:
      v5 = 79;
LABEL_82:
      v6 = v5;
      break;
    case 80:
      break;
    case 81:
      v6 = 81;
      break;
    case 82:
      v6 = 82;
      break;
    case 83:
      v6 = 83;
      break;
    case 84:
      v6 = 84;
      break;
    case 85:
      v6 = 85;
      break;
    case 86:
      v6 = 86;
      break;
    case 87:
      v6 = 87;
      break;
    case 88:
      v6 = 88;
      break;
    case 89:
      v6 = 89;
      break;
    case 90:
      v6 = 90;
      break;
    case 91:
      v6 = 91;
      break;
    case 92:
      v6 = 92;
      break;
    case 93:
      v6 = 93;
      break;
    case 94:
      v6 = 94;
      break;
    case 95:
      v6 = 95;
      break;
    case 96:
      v6 = 96;
      break;
    case 97:
      v6 = 97;
      break;
    default:
      v6 = 98;
      break;
  }
  *v2 = v6;
  return result;
}

void *static SQLFunction.allCases.getter()
{
  return &outlined read-only object #0 of static SQLFunction.allCases.getter;
}

uint64_t SQLFunction.rawValue.getter()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_18DAE4550 + 4 * word_18DC2B9F4[*v0]))(7561825, 0xE300000000000000);
}

uint64_t sub_18DAE4550()
{
  return 892497250;
}

uint64_t sub_18DAE4560()
{
  return 0x7365676E616863;
}

uint64_t sub_18DAE4578()
{
  return 1918986339;
}

uint64_t sub_18DAE4588()
{
  return 0x656373656C616F63;
}

uint64_t sub_18DAE45A0()
{
  return 0x7369645F656D7563;
}

uint64_t sub_18DAE45C0()
{
  return 0x5F746E6572727563;
}

uint64_t sub_18DAE4B04()
{
  return 0x66746E697270;
}

uint64_t sub_18DAE4B18()
{
  return 0x65746F7571;
}

uint64_t sub_18DAE4B2C()
{
  return 0x6D6F646E6172;
}

uint64_t sub_18DAE4B40()
{
  return 0x6C626D6F646E6172;
}

uint64_t sub_18DAE4B5C()
{
  return 1802396018;
}

uint64_t sub_18DAE4B6C()
{
  return 0x6563616C706572;
}

uint64_t sub_18DAE4B84()
{
  return 0x646E756F72;
}

uint64_t sub_18DAE4B98()
{
  return 0x626D756E5F776F72;
}

uint64_t sub_18DAE4BB8()
{
  return 0x6568636565727472;
}

uint64_t sub_18DAE4BD8()
{
  return 0x7065646565727472;
}

uint64_t sub_18DAE4C14()
{
  return 0x6D69727472;
}

uint64_t sub_18DAE4C2C()
{
  return 1852270963;
}

uint64_t sub_18DAE4C3C()
{
  return 0x74657070696E73;
}

unint64_t sub_18DAE4C54()
{
  return 0xD000000000000018;
}

unint64_t sub_18DAE4C6C()
{
  return 0xD000000000000019;
}

uint64_t sub_18DAE4C84()
{
  return 0x6C5F6574696C7173;
}

void sub_18DAE4CA8()
{
  JUMPOUT(0x18DAE4CBCLL);
}

uint64_t sub_18DAE4CC8()
{
  return 0x765F6574696C7173;
}

void sub_18DAE4CEC()
{
  JUMPOUT(0x18DAE4CF8);
}

uint64_t sub_18DAE4D04()
{
  return 0x727473627573;
}

uint64_t sub_18DAE4D18()
{
  return 0x6E69727473627573;
}

uint64_t sub_18DAE4D38()
{
  return 1701669236;
}

uint64_t sub_18DAE4D48()
{
  return 0x68635F6C61746F74;
}

uint64_t sub_18DAE4D6C()
{
  return 1835627124;
}

uint64_t sub_18DAE4D7C()
{
  return 0x666F65707974;
}

uint64_t sub_18DAE4D90()
{
  return 0x65646F63696E75;
}

uint64_t sub_18DAE4DA8()
{
  return 0x6E776F6E6B6E75;
}

uint64_t sub_18DAE4DC0()
{
  return 0x796C656B696C6E75;
}

uint64_t sub_18DAE4DD8()
{
  return 0x7265707075;
}

uint64_t sub_18DAE4DEC()
{
  return 1684632949;
}

uint64_t sub_18DAE4DFC()
{
  return 0x6F6C625F64697575;
}

uint64_t sub_18DAE4E1C()
{
  return 0x7274735F64697575;
}

uint64_t sub_18DAE4E34()
{
  return 0x626F6C626F72657ALL;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SQLFunction()
{
  return specialized == infix<A>(_:_:)();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLFunction()
{
  Hasher.init(_seed:)();
  SQLFunction.rawValue.getter();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SQLFunction()
{
  SQLFunction.rawValue.getter();
  String.hash(into:)();
  return swift_bridgeObjectRelease();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SQLFunction()
{
  Hasher.init(_seed:)();
  SQLFunction.rawValue.getter();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

BiomeSQLParser::SQLFunction_optional protocol witness for RawRepresentable.init(rawValue:) in conformance SQLFunction(Swift::String *a1)
{
  return SQLFunction.init(rawValue:)(*a1);
}

uint64_t protocol witness for RawRepresentable.rawValue.getter in conformance SQLFunction@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result;
  uint64_t v3;

  result = SQLFunction.rawValue.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

void protocol witness for static CaseIterable.allCases.getter in conformance SQLFunction(_QWORD *a1@<X8>)
{
  *a1 = &outlined read-only object #0 of static SQLFunction.allCases.getter;
}

#error "18DAE4FAC: too big function (funcsize=0)"

uint64_t specialized static Array<A>.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t, uint64_t, uint64_t);
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t Node;

  v4 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  v42 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](v4);
  v6 = (char *)&v34 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1E0C80A78](v7);
  v9 = (char *)&v34 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v41 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
  MEMORY[0x1E0C80A78](v41);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  v12 = MEMORY[0x1E0C80A78](Node);
  v14 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = *(_QWORD *)(a1 + 16);
  if (v18 != *(_QWORD *)(a2 + 16))
    return 0;
  if (!v18 || a1 == a2)
    return 1;
  v36 = v9;
  v34 = v6;
  v39 = v4;
  v19 = (*(unsigned __int8 *)(v15 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80);
  v40 = *(_QWORD *)(v15 + 72);
  v37 = a1;
  v38 = a2;
  v35 = v14;
  while (1)
  {
    outlined init with copy of PgQuery_RawStmt(a1 + v19, (uint64_t)v17, type metadata accessor for PgQuery_Node);
    outlined init with copy of PgQuery_RawStmt(a2 + v19, (uint64_t)v14, type metadata accessor for PgQuery_Node);
    v20 = *(int *)(Node + 20);
    v21 = *(_QWORD *)&v17[v20];
    v22 = *(_QWORD *)&v14[v20];
    if (v21 == v22)
      goto LABEL_12;
    v23 = v22 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
    v24 = (uint64_t)&v11[*(int *)(v41 + 48)];
    outlined init with copy of PgQuery_Alias?(v21 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, (uint64_t)v11, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined init with copy of PgQuery_Alias?(v23, v24, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v25 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v42 + 48);
    v26 = v39;
    if (v25((uint64_t)v11, 1, v39) == 1)
    {
      v27 = v25(v24, 1, v26);
      swift_retain();
      swift_retain();
      if (v27 != 1)
        goto LABEL_16;
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v11, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      goto LABEL_11;
    }
    v28 = (uint64_t)v11;
    v29 = (uint64_t)v11;
    v30 = (uint64_t)v36;
    outlined init with copy of PgQuery_Alias?(v28, (uint64_t)v36, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v25(v24, 1, v26) == 1)
      break;
    v31 = (uint64_t)v34;
    outlined init with take of PgQuery_OidList(v24, (uint64_t)v34, type metadata accessor for PgQuery_Node.OneOf_Node);
    swift_retain();
    swift_retain();
    v32 = static PgQuery_Node.OneOf_Node.== infix(_:_:)(v30, v31);
    outlined destroy of PgQuery_Alias(v31, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of PgQuery_Alias(v30, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of (key: String, value: StorableValue)(v29, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v11 = (char *)v29;
    v14 = v35;
    if ((v32 & 1) == 0)
      goto LABEL_17;
LABEL_11:
    swift_release();
    swift_release();
    a1 = v37;
    a2 = v38;
LABEL_12:
    type metadata accessor for UnknownStorage();
    lazy protocol witness table accessor for type PgQuery_ScanToken and conformance PgQuery_ScanToken(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, (uint64_t (*)(uint64_t))MEMORY[0x1E0D3E998], MEMORY[0x1E0D3E9A8]);
    if ((dispatch thunk of static Equatable.== infix(_:_:)() & 1) == 0)
      goto LABEL_18;
    outlined destroy of PgQuery_Alias((uint64_t)v14, type metadata accessor for PgQuery_Node);
    outlined destroy of PgQuery_Alias((uint64_t)v17, type metadata accessor for PgQuery_Node);
    v19 += v40;
    if (!--v18)
      return 1;
  }
  swift_retain();
  swift_retain();
  outlined destroy of PgQuery_Alias(v30, type metadata accessor for PgQuery_Node.OneOf_Node);
  v11 = (char *)v29;
  v14 = v35;
LABEL_16:
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v11, &demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
LABEL_17:
  swift_release();
  swift_release();
LABEL_18:
  outlined destroy of PgQuery_Alias((uint64_t)v14, type metadata accessor for PgQuery_Node);
  outlined destroy of PgQuery_Alias((uint64_t)v17, type metadata accessor for PgQuery_Node);
  return 0;
}

{
  uint64_t v2;
  uint64_t v3;
  char v4;
  _BYTE v6[193];
  _BYTE v7[200];
  _BYTE v8[200];
  _BYTE v9[200];

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 == *(_QWORD *)(a2 + 16))
  {
    if (!v2 || a1 == a2)
      return 1;
    v3 = a2 + 32;
    outlined init with copy of AggregationFunction(a1 + 32, (uint64_t)v9);
    outlined init with copy of AggregationFunction(v3, (uint64_t)v8);
    v4 = specialized static AggregationFunction.AggregationType.== infix(_:_:)(v9, v8);
    outlined init with copy of AggregationFunction((uint64_t)v9, (uint64_t)v7);
    outlined init with copy of AggregationFunction((uint64_t)v8, (uint64_t)v6);
    if ((v4 & 1) != 0)
      __asm { BR              X10 }
    outlined destroy of AggregationFunction((uint64_t)v6);
    outlined destroy of AggregationFunction((uint64_t)v7);
    outlined destroy of AggregationFunction((uint64_t)v8);
    outlined destroy of AggregationFunction((uint64_t)v9);
  }
  return 0;
}

{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t ScanToken;

  ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  v4 = MEMORY[0x1E0C80A78](ScanToken);
  v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v4);
  v9 = (char *)&v17 - v8;
  v10 = *(_QWORD *)(a1 + 16);
  if (v10 != *(_QWORD *)(a2 + 16))
    return 0;
  if (v10 && a1 != a2)
  {
    v11 = (*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80);
    v17 = *(_QWORD *)(v7 + 72);
    while (1)
    {
      outlined init with copy of PgQuery_RawStmt(a1 + v11, (uint64_t)v9, type metadata accessor for PgQuery_ScanToken);
      outlined init with copy of PgQuery_RawStmt(a2 + v11, (uint64_t)v6, type metadata accessor for PgQuery_ScanToken);
      if (*(_DWORD *)v9 != *(_DWORD *)v6)
        break;
      if (*((_DWORD *)v9 + 1) != *((_DWORD *)v6 + 1))
        break;
      v12 = *((_QWORD *)v6 + 1);
      v13 = v6[16];
      v14 = PgQuery_Token.rawValue.getter(*((_QWORD *)v9 + 1), v9[16]);
      if (v14 != PgQuery_Token.rawValue.getter(v12, v13))
        break;
      v15 = *((_QWORD *)v6 + 3);
      if (v6[32] == 1)
        __asm { BR              X10 }
      if (*((_QWORD *)v9 + 3) != v15)
        break;
      type metadata accessor for UnknownStorage();
      lazy protocol witness table accessor for type PgQuery_ScanToken and conformance PgQuery_ScanToken(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, (uint64_t (*)(uint64_t))MEMORY[0x1E0D3E998], MEMORY[0x1E0D3E9A8]);
      if ((dispatch thunk of static Equatable.== infix(_:_:)() & 1) == 0)
        break;
      outlined destroy of PgQuery_Alias((uint64_t)v6, type metadata accessor for PgQuery_ScanToken);
      outlined destroy of PgQuery_Alias((uint64_t)v9, type metadata accessor for PgQuery_ScanToken);
      v11 += v17;
      if (!--v10)
        return 1;
    }
    outlined destroy of PgQuery_Alias((uint64_t)v6, type metadata accessor for PgQuery_ScanToken);
    outlined destroy of PgQuery_Alias((uint64_t)v9, type metadata accessor for PgQuery_ScanToken);
    return 0;
  }
  return 1;
}

{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != *(_QWORD *)(a2 + 16))
    return 0;
  if (v2)
  {
    if (a1 != a2)
      __asm { BR              X10 }
  }
  return 1;
}

BOOL specialized static Array<A>.== infix(_:_:)(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a1[2];
  if (v2 != a2[2])
    return 0;
  if (!v2 || a1 == a2)
    return 1;
  if (a1[4] != a2[4])
    return 0;
  v3 = a1 + 5;
  v4 = a2 + 5;
  v5 = v2 - 1;
  do
  {
    result = v5 == 0;
    if (!v5)
      break;
    v8 = *v3++;
    v7 = v8;
    v9 = *v4++;
    --v5;
  }
  while (v7 == v9);
  return result;
}

uint64_t specialized static Array<A>.== infix(_:_:)(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t Node;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t RawStmt;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, uint64_t, uint64_t);
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t (*v51)(uint64_t, uint64_t, uint64_t);
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  int v62;
  int v63;
  BOOL v64;
  char v65;
  uint64_t *v67;
  uint64_t v68[2];
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  char *v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;

  v2 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  v76 = *(_QWORD *)(v2 - 8);
  v77 = v2;
  MEMORY[0x1E0C80A78](v2);
  v80 = (char *)v68 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1E0C80A78](v4);
  v73 = (uint64_t)v68 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
  MEMORY[0x1E0C80A78](v6);
  v8 = (char *)v68 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  v10 = *(_QWORD *)(Node - 8);
  MEMORY[0x1E0C80A78](Node);
  v12 = (char *)v68 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1E0C80A78](v13);
  v15 = (char *)v68 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node?, PgQuery_Node?));
  MEMORY[0x1E0C80A78](v16);
  v18 = (char *)v68 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  RawStmt = type metadata accessor for PgQuery_RawStmt(0);
  v20 = MEMORY[0x1E0C80A78](RawStmt);
  v21 = MEMORY[0x1E0C80A78](v20);
  v26 = *(_QWORD *)(a1 + 16);
  if (v26 != *(_QWORD *)(v25 + 16))
    return 0;
  v85 = v16;
  v78 = v10;
  v79 = Node;
  v74 = (char *)v68 - v23;
  v75 = v8;
  v69 = v6;
  v83 = v12;
  if (!v26 || a1 == v25)
    return 1;
  v27 = v25;
  v84 = v21;
  v72 = v15;
  v28 = (*(unsigned __int8 *)(v22 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v22 + 80);
  v81 = *(_QWORD *)(v22 + 72);
  v29 = v24;
  v30 = (uint64_t)v74;
  v31 = v85;
  v82 = v25;
  v70 = a1;
  v71 = v24;
  v68[0] = (uint64_t)v18;
  while (1)
  {
    outlined init with copy of PgQuery_RawStmt(a1 + v28, v30, type metadata accessor for PgQuery_RawStmt);
    outlined init with copy of PgQuery_RawStmt(v27 + v28, v29, type metadata accessor for PgQuery_RawStmt);
    v32 = *(int *)(v84 + 20);
    v33 = *(_QWORD *)(v30 + v32);
    v34 = *(_QWORD *)(v29 + v32);
    if (v33 == v34)
      goto LABEL_22;
    v35 = v34
        + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt;
    v36 = (uint64_t)&v18[*(int *)(v31 + 48)];
    outlined init with copy of PgQuery_Alias?(v33 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt, (uint64_t)v18, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined init with copy of PgQuery_Alias?(v35, v36, &demangling cache variable for type metadata for PgQuery_Node?);
    v37 = v79;
    v38 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v78 + 48);
    if (v38((uint64_t)v18, 1, v79) == 1)
    {
      v39 = v38(v36, 1, v37);
      swift_retain();
      swift_retain();
      if (v39 != 1)
      {
        v67 = &demangling cache variable for type metadata for (PgQuery_Node?, PgQuery_Node?);
        goto LABEL_31;
      }
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v18, &demangling cache variable for type metadata for PgQuery_Node?);
      goto LABEL_19;
    }
    v40 = (uint64_t)v18;
    v41 = (uint64_t)v80;
    v42 = (uint64_t)v72;
    outlined init with copy of PgQuery_Alias?(v40, (uint64_t)v72, &demangling cache variable for type metadata for PgQuery_Node?);
    if (v38(v36, 1, v37) == 1)
    {
      swift_retain();
      swift_retain();
      v67 = &demangling cache variable for type metadata for (PgQuery_Node?, PgQuery_Node?);
      v18 = (char *)v68[0];
      v30 = (uint64_t)v74;
      goto LABEL_30;
    }
    v43 = v36;
    v44 = (uint64_t)v83;
    outlined init with take of PgQuery_OidList(v43, (uint64_t)v83, type metadata accessor for PgQuery_Node);
    v45 = *(int *)(v37 + 20);
    v46 = *(_QWORD *)(v42 + v45);
    v47 = *(_QWORD *)(v44 + v45);
    if (v46 == v47)
    {
      swift_retain();
      swift_retain();
      v30 = (uint64_t)v74;
      goto LABEL_18;
    }
    v48 = v47 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
    v49 = (uint64_t)v75;
    v50 = (uint64_t)&v75[*(int *)(v69 + 48)];
    v68[1] = v47;
    outlined init with copy of PgQuery_Alias?(v46 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, (uint64_t)v75, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined init with copy of PgQuery_Alias?(v48, v50, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v51 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v76 + 48);
    v52 = v49;
    v53 = v77;
    if (v51(v52, 1, v77) == 1)
    {
      v54 = v51(v50, 1, v53);
      swift_retain();
      swift_retain();
      swift_retain();
      swift_retain();
      v55 = (uint64_t)v83;
      v30 = (uint64_t)v74;
      v56 = (uint64_t)v75;
      if (v54 != 1)
        goto LABEL_28;
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v75, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      goto LABEL_17;
    }
    v57 = v73;
    outlined init with copy of PgQuery_Alias?((uint64_t)v75, v73, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v51(v50, 1, v53) == 1)
      break;
    outlined init with take of PgQuery_OidList(v50, v41, type metadata accessor for PgQuery_Node.OneOf_Node);
    swift_retain();
    swift_retain();
    swift_retain();
    swift_retain();
    v58 = static PgQuery_Node.OneOf_Node.== infix(_:_:)(v57, v41);
    outlined destroy of PgQuery_Alias(v41, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of PgQuery_Alias(v57, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v75, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v55 = (uint64_t)v83;
    v30 = (uint64_t)v74;
    if ((v58 & 1) == 0)
      goto LABEL_29;
LABEL_17:
    swift_release();
    swift_release();
LABEL_18:
    type metadata accessor for UnknownStorage();
    lazy protocol witness table accessor for type PgQuery_ScanToken and conformance PgQuery_ScanToken(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, (uint64_t (*)(uint64_t))MEMORY[0x1E0D3E998], MEMORY[0x1E0D3E9A8]);
    v59 = (uint64_t)v72;
    v60 = (uint64_t)v83;
    v61 = dispatch thunk of static Equatable.== infix(_:_:)();
    outlined destroy of PgQuery_Alias(v60, type metadata accessor for PgQuery_Node);
    outlined destroy of PgQuery_Alias(v59, type metadata accessor for PgQuery_Node);
    v18 = (char *)v68[0];
    outlined destroy of (key: String, value: StorableValue)(v68[0], &demangling cache variable for type metadata for PgQuery_Node?);
    if ((v61 & 1) == 0)
      goto LABEL_32;
LABEL_19:
    if (*(_DWORD *)(v33
                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation) != *(_DWORD *)(v34 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation))
      goto LABEL_32;
    v62 = *(_DWORD *)(v33
                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen);
    v63 = *(_DWORD *)(v34
                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen);
    swift_release();
    swift_release();
    v64 = v62 == v63;
    a1 = v70;
    v29 = v71;
    if (!v64)
      goto LABEL_33;
LABEL_22:
    type metadata accessor for UnknownStorage();
    lazy protocol witness table accessor for type PgQuery_ScanToken and conformance PgQuery_ScanToken(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, (uint64_t (*)(uint64_t))MEMORY[0x1E0D3E998], MEMORY[0x1E0D3E9A8]);
    v65 = dispatch thunk of static Equatable.== infix(_:_:)();
    v31 = v85;
    if ((v65 & 1) == 0)
      goto LABEL_33;
    outlined destroy of PgQuery_Alias(v29, type metadata accessor for PgQuery_RawStmt);
    outlined destroy of PgQuery_Alias(v30, type metadata accessor for PgQuery_RawStmt);
    v27 = v82;
    v28 += v81;
    if (!--v26)
      return 1;
  }
  swift_retain();
  swift_retain();
  swift_retain();
  swift_retain();
  outlined destroy of PgQuery_Alias(v57, type metadata accessor for PgQuery_Node.OneOf_Node);
  v55 = (uint64_t)v83;
  v30 = (uint64_t)v74;
  v56 = (uint64_t)v75;
LABEL_28:
  outlined destroy of (key: String, value: StorableValue)(v56, &demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
LABEL_29:
  swift_release();
  swift_release();
  outlined destroy of PgQuery_Alias(v55, type metadata accessor for PgQuery_Node);
  v67 = &demangling cache variable for type metadata for PgQuery_Node?;
  v18 = (char *)v68[0];
LABEL_30:
  outlined destroy of PgQuery_Alias((uint64_t)v72, type metadata accessor for PgQuery_Node);
LABEL_31:
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v18, v67);
LABEL_32:
  swift_release();
  swift_release();
  v29 = v71;
LABEL_33:
  outlined destroy of PgQuery_Alias(v29, type metadata accessor for PgQuery_RawStmt);
  outlined destroy of PgQuery_Alias(v30, type metadata accessor for PgQuery_RawStmt);
  return 0;
}

uint64_t specialized static Array<A>.== infix(_:_:)(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2[2])
    return 0;
  if (v2 && (_QWORD *)a1 != a2)
  {
    v3 = *(unsigned __int8 *)(a1 + 48);
    v4 = *(_QWORD *)(a1 + 32) == a2[4] && *(_QWORD *)(a1 + 40) == a2[5];
    if (v4 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
      __asm { BR              X8 }
    return 0;
  }
  return 1;
}

uint64_t specialized static Array._allocateUninitialized(_:)(uint64_t result)
{
  return specialized static Array._allocateUninitialized(_:)(result);
}

{
  return specialized static Array._allocateUninitialized(_:)(result);
}

{
  uint64_t v1;

  if (result < 0)
  {
    __break(1u);
  }
  else
  {
    v1 = result;
    if (result)
    {
      __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for [AggregationFunction]);
      result = static Array._allocateBufferUninitialized(minimumCapacity:)();
      *(_QWORD *)(result + 16) = v1;
    }
    else
    {
      return MEMORY[0x1E0DEE9D8];
    }
  }
  return result;
}

{
  return specialized static Array._allocateUninitialized(_:)(result);
}

{
  uint64_t v1;

  if (result < 0)
  {
    __break(1u);
  }
  else
  {
    v1 = result;
    if (result)
    {
      result = static Array._allocateBufferUninitialized(minimumCapacity:)();
      *(_QWORD *)(result + 16) = v1;
    }
    else
    {
      return MEMORY[0x1E0DEE9D8];
    }
  }
  return result;
}

uint64_t specialized static Array._adoptStorage(_:count:)(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(result + 24) = 2 * a2;
  return result;
}

unint64_t lazy protocol witness table accessor for type SQLFunction and conformance SQLFunction()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLFunction and conformance SQLFunction;
  if (!lazy protocol witness table cache variable for type SQLFunction and conformance SQLFunction)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLFunction, &type metadata for SQLFunction);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLFunction and conformance SQLFunction);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type [SQLFunction] and conformance [A]()
{
  unint64_t result;
  uint64_t v1;

  result = lazy protocol witness table cache variable for type [SQLFunction] and conformance [A];
  if (!lazy protocol witness table cache variable for type [SQLFunction] and conformance [A])
  {
    v1 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for [SQLFunction]);
    result = MEMORY[0x193FED7A0](MEMORY[0x1E0DEAF50], v1);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type [SQLFunction] and conformance [A]);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for SQLFunction(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0x9F)
    goto LABEL_17;
  if (a2 + 97 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 97) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 97;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 97;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 97;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0x62;
  v8 = v6 - 98;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLFunction(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 97 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 97) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0x9F)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0x9E)
    return ((uint64_t (*)(void))((char *)&loc_18DB1AB18 + 4 * byte_18DC2BBB6[v4]))();
  *a1 = a2 + 97;
  return ((uint64_t (*)(void))((char *)sub_18DB1AB4C + 4 * byte_18DC2BBB1[v4]))();
}

uint64_t sub_18DB1AB4C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB1AB54(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB1AB5CLL);
  return result;
}

uint64_t sub_18DB1AB68(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB1AB70);
  *(_BYTE *)result = a2 + 97;
  return result;
}

uint64_t sub_18DB1AB74(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB1AB7C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for SQLFunction()
{
  return &type metadata for SQLFunction;
}

uint64_t outlined init with copy of PgQuery_RawStmt(uint64_t a1, uint64_t a2, uint64_t (*a3)(_QWORD))
{
  uint64_t v5;

  v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t outlined init with copy of AggregationFunction(uint64_t a1, uint64_t a2)
{
  initializeWithCopy for AggregationFunction(a2, a1);
  return a2;
}

uint64_t outlined destroy of AggregationFunction(uint64_t a1)
{
  destroy for AggregationFunction(a1);
  return a1;
}

void specialized RawRepresentable<>.hash(into:)(uint64_t a1, char a2)
{
  __asm { BR              X10 }
}

uint64_t sub_18DB1AC90()
{
  String.hash(into:)();
  return swift_bridgeObjectRelease();
}

uint64_t SQLExpression.init(expressionNode:schemas:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[40];
  uint64_t v13[5];

  v9 = specialized ColumnResolver.init(schemas:)(a2);
  if (v4)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(a3, type metadata accessor for SQLTokenInformation);
    return outlined destroy of PgQuery_Alias(a1, type metadata accessor for PgQuery_Node);
  }
  else
  {
    buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(a1, a2, v9, v10, a3, v13);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined init with copy of Aggregation((uint64_t)v13, (uint64_t)v12);
    SQLExpression.init(rootNode:)((uint64_t)v12, a4);
    outlined destroy of PgQuery_Alias(a3, type metadata accessor for SQLTokenInformation);
    outlined destroy of PgQuery_Alias(a1, type metadata accessor for PgQuery_Node);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v13);
  }
}

uint64_t buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t BitString;
  uint64_t v7;
  uint64_t Float;
  uint64_t v9;
  uint64_t Integer;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Node;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t ColumnRef;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t NullTest;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t BoolExpr;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t A_Expr;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t A_Const;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  char *v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int (*v79)(uint64_t, uint64_t, uint64_t);
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int EnumCaseMultiPayload;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t (*v95)(uint64_t);
  char v96;
  char v97;
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t (*v112)(uint64_t);
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  unsigned int (*v118)(uint64_t, uint64_t, uint64_t);
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t countAndFlagsBits;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t (*v148)(uint64_t);
  int *v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  char v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  uint64_t v177;
  Swift::Int32 v178;
  Swift::String v179;
  uint64_t v180;
  char isUniquelyReferenced_nonNull_native;
  unint64_t v182;
  unint64_t v183;
  uint64_t v184;
  uint64_t v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  char v196;
  char v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  char v208;
  uint64_t *v209;
  uint64_t v210;
  unint64_t v211;
  char v212;
  char v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t v217;
  uint64_t v218;
  char *v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  int *v235;
  uint64_t *v236;
  uint64_t *v237;
  uint64_t *v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  char *v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t *v248;
  uint64_t String;
  uint64_t v250;
  uint64_t v251;
  char *v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  Swift::String v256;
  Swift::String v257;
  uint64_t v258;

  v242 = a5;
  v243 = a3;
  v244 = a4;
  v241 = a2;
  v258 = a1;
  v248 = a6;
  BitString = type metadata accessor for PgQuery_BitString(0);
  MEMORY[0x1E0C80A78](BitString);
  v238 = (uint64_t *)((char *)&v217 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
  Float = type metadata accessor for PgQuery_Float(0);
  MEMORY[0x1E0C80A78](Float);
  v237 = (uint64_t *)((char *)&v217 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  Integer = type metadata accessor for PgQuery_Integer(0);
  MEMORY[0x1E0C80A78](Integer);
  v235 = (int *)((char *)&v217 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  String = type metadata accessor for PgQuery_String(0);
  v12 = MEMORY[0x1E0C80A78](String);
  v236 = (uint64_t *)((char *)&v217 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v12);
  v245 = (char *)&v217 - v14;
  Node = type metadata accessor for PgQuery_Node(0);
  v218 = *(_QWORD *)(Node - 8);
  MEMORY[0x1E0C80A78](Node);
  v255 = (uint64_t)&v217 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Locale?);
  MEMORY[0x1E0C80A78](v17);
  v219 = (char *)&v217 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  ColumnRef = type metadata accessor for PgQuery_ColumnRef(0);
  v20 = MEMORY[0x1E0C80A78](ColumnRef);
  v240 = (uint64_t)&v217 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v20);
  v239 = (uint64_t)&v217 - v22;
  v23 = type metadata accessor for PgQuery_FuncCall(0);
  v24 = MEMORY[0x1E0C80A78](v23);
  v233 = (uint64_t)&v217 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v24);
  v234 = (uint64_t)&v217 - v26;
  NullTest = type metadata accessor for PgQuery_NullTest(0);
  v28 = MEMORY[0x1E0C80A78](NullTest);
  v224 = (uint64_t)&v217 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v28);
  v225 = (uint64_t)&v217 - v30;
  BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
  v32 = MEMORY[0x1E0C80A78](BoolExpr);
  v222 = (uint64_t)&v217 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v32);
  v223 = (uint64_t)&v217 - v34;
  A_Expr = type metadata accessor for PgQuery_A_Expr(0);
  v36 = MEMORY[0x1E0C80A78](A_Expr);
  v231 = (uint64_t)&v217 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v36);
  v232 = (uint64_t)&v217 - v38;
  v39 = type metadata accessor for SQLTokenInformation(0);
  v40 = MEMORY[0x1E0C80A78](v39);
  v246 = (uint64_t)&v217 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0);
  v42 = MEMORY[0x1E0C80A78](v40);
  v230 = (uint64_t)&v217 - v43;
  v44 = MEMORY[0x1E0C80A78](v42);
  v221 = (uint64_t)&v217 - v45;
  v46 = MEMORY[0x1E0C80A78](v44);
  v220 = (uint64_t)&v217 - v47;
  v48 = MEMORY[0x1E0C80A78](v46);
  v229 = (uint64_t)&v217 - v49;
  MEMORY[0x1E0C80A78](v48);
  v228 = (uint64_t)&v217 - v50;
  A_Const = type metadata accessor for PgQuery_A_Const(0);
  v52 = MEMORY[0x1E0C80A78](A_Const);
  v226 = (uint64_t)&v217 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v52);
  v227 = (uint64_t)&v217 - v54;
  v55 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  v56 = *(_QWORD *)(v55 - 8);
  MEMORY[0x1E0C80A78](v55);
  v58 = (char *)&v217 - ((v57 + 15) & 0xFFFFFFFFFFFFFFF0);
  v59 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
  MEMORY[0x1E0C80A78](v59);
  v61 = (char *)&v217 - ((v60 + 15) & 0xFFFFFFFFFFFFFFF0);
  v62 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v63 = MEMORY[0x1E0C80A78](v62);
  v250 = (uint64_t)&v217 - ((v64 + 15) & 0xFFFFFFFFFFFFFFF0);
  v65 = MEMORY[0x1E0C80A78](v63);
  v247 = (uint64_t)&v217 - v66;
  v67 = MEMORY[0x1E0C80A78](v65);
  v253 = (uint64_t)&v217 - v68;
  v69 = MEMORY[0x1E0C80A78](v67);
  v71 = (char *)&v217 - v70;
  MEMORY[0x1E0C80A78](v69);
  v73 = (char *)&v217 - v72;
  v74 = (char *)*(int *)(Node + 20);
  v251 = Node;
  v252 = v74;
  v75 = *(_QWORD *)&v74[v258]
      + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v56 + 56))((char *)&v217 - v72, 1, 1, v55);
  v76 = (uint64_t)&v61[*(int *)(v59 + 48)];
  v77 = v75;
  v78 = v55;
  outlined init with copy of PgQuery_Alias?(v77, (uint64_t)v61, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined init with copy of PgQuery_Alias?((uint64_t)v73, v76, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v79 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v56 + 48);
  if (v79((uint64_t)v61, 1, v78) == 1)
  {
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v73, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v79(v76, 1, v78) == 1)
    {
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v61, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_13:
      type metadata accessor for SQLExpressionError();
      lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
      swift_allocError();
      swift_storeEnumTagMultiPayload();
      return swift_willThrow();
    }
    goto LABEL_6;
  }
  outlined init with copy of PgQuery_Alias?((uint64_t)v61, (uint64_t)v71, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if (v79(v76, 1, v78) == 1)
  {
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v73, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of PgQuery_Alias((uint64_t)v71, type metadata accessor for PgQuery_Node.OneOf_Node);
LABEL_6:
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v61, &demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
    goto LABEL_7;
  }
  outlined init with take of PgQuery_OidList(v76, (uint64_t)v58, type metadata accessor for PgQuery_Node.OneOf_Node);
  specialized static PgQuery_Node.OneOf_Node.== infix(_:_:)((uint64_t)v71, (uint64_t)v58);
  v97 = v96;
  outlined destroy of PgQuery_Alias((uint64_t)v58, type metadata accessor for PgQuery_Node.OneOf_Node);
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v73, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined destroy of PgQuery_Alias((uint64_t)v71, type metadata accessor for PgQuery_Node.OneOf_Node);
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v61, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if ((v97 & 1) != 0)
    goto LABEL_13;
LABEL_7:
  v80 = v258;
  v81 = v253;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v252[v258]+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v253, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if (v79(v81, 1, v78) != 1)
  {
    v83 = v247;
    outlined init with copy of PgQuery_Alias?(v81, v247, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    v252 = (char *)v79;
    v85 = v254;
    v86 = (uint64_t)v248;
    switch(EnumCaseMultiPayload)
    {
      case 166:
        v87 = v232;
        outlined init with take of PgQuery_OidList(v83, v232, type metadata accessor for PgQuery_A_Expr);
        v88 = v231;
        outlined init with copy of PgQuery_RawStmt(v87, v231, type metadata accessor for PgQuery_A_Expr);
        v89 = v229;
        outlined init with copy of PgQuery_RawStmt(v242, v229, type metadata accessor for SQLTokenInformation);
        *(_QWORD *)(v86 + 24) = &unk_1E263BC10;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionAExpr;
        v90 = swift_allocObject();
        v91 = v90 + 16;
        *(_QWORD *)v86 = v90;
        v92 = v241;
        swift_bridgeObjectRetain();
        v93 = v243;
        swift_bridgeObjectRetain();
        v94 = v244;
        swift_bridgeObjectRetain();
        SQLExpressionAExpr.init(expr:schemas:columnResolver:tokenInformation:)(v88, v92, v93, v94, v89, v91);
        v95 = type metadata accessor for PgQuery_A_Expr;
        if (!v85)
          goto LABEL_11;
        goto LABEL_35;
      case 167:
        v258 = v78;
        v113 = v239;
        outlined init with take of PgQuery_OidList(v83, v239, type metadata accessor for PgQuery_ColumnRef);
        v114 = v113;
        v115 = v240;
        outlined init with copy of PgQuery_RawStmt(v114, v240, type metadata accessor for PgQuery_ColumnRef);
        outlined init with copy of PgQuery_RawStmt(v242, v246, type metadata accessor for SQLTokenInformation);
        *(_QWORD *)(v86 + 24) = &unk_1E263E7A8;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionColumnRef;
        v242 = swift_allocObject();
        *(_QWORD *)v86 = v242;
        v116 = *(_QWORD *)v115;
        v117 = *(_QWORD *)(*(_QWORD *)v115 + 16);
        v118 = (unsigned int (*)(uint64_t, uint64_t, uint64_t))v252;
        if (v117)
        {
          v257._countAndFlagsBits = MEMORY[0x1E0DEE9D8];
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v117, 0);
          v119 = *(unsigned __int8 *)(v218 + 80);
          v247 = v116;
          v120 = v116 + ((v119 + 32) & ~v119);
          v121 = *(_QWORD *)(v218 + 72);
          v122 = (uint64_t *)v245;
          while (1)
          {
            v123 = v255;
            outlined init with copy of PgQuery_RawStmt(v120, v255, type metadata accessor for PgQuery_Node);
            v124 = v250;
            outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v123 + *(int *)(v251 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v250, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
            if (v118(v124, 1, v258) == 1)
              break;
            if (swift_getEnumCaseMultiPayload() != 222)
            {
              outlined destroy of PgQuery_Alias(v124, type metadata accessor for PgQuery_Node.OneOf_Node);
              goto LABEL_25;
            }
            outlined init with take of PgQuery_OidList(v124, (uint64_t)v122, type metadata accessor for PgQuery_String);
LABEL_26:
            v126 = *v122;
            v125 = v122[1];
            swift_bridgeObjectRetain();
            outlined destroy of PgQuery_Alias((uint64_t)v122, type metadata accessor for PgQuery_String);
            outlined destroy of PgQuery_Alias(v255, type metadata accessor for PgQuery_Node);
            countAndFlagsBits = v257._countAndFlagsBits;
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(countAndFlagsBits + 16) + 1, 1);
              v122 = (uint64_t *)v245;
              countAndFlagsBits = v257._countAndFlagsBits;
            }
            v129 = *(_QWORD *)(countAndFlagsBits + 16);
            v128 = *(_QWORD *)(countAndFlagsBits + 24);
            if (v129 >= v128 >> 1)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v128 > 1, v129 + 1, 1);
              v122 = (uint64_t *)v245;
              countAndFlagsBits = v257._countAndFlagsBits;
            }
            *(_QWORD *)(countAndFlagsBits + 16) = v129 + 1;
            v130 = countAndFlagsBits + 16 * v129;
            *(_QWORD *)(v130 + 32) = v126;
            *(_QWORD *)(v130 + 40) = v125;
            v120 += v121;
            --v117;
            v118 = (unsigned int (*)(uint64_t, uint64_t, uint64_t))v252;
            if (!v117)
            {
              swift_bridgeObjectRelease();
              goto LABEL_49;
            }
          }
          outlined destroy of (key: String, value: StorableValue)(v124, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_25:
          *v122 = 0;
          v122[1] = 0xE000000000000000;
          UnknownStorage.init()();
          goto LABEL_26;
        }
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        countAndFlagsBits = MEMORY[0x1E0DEE9D8];
LABEL_49:
        v257._countAndFlagsBits = countAndFlagsBits;
        v171 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
        v172 = lazy protocol witness table accessor for type [String] and conformance [A]();
        String = v171;
        v247 = v172;
        v173 = BidirectionalCollection<>.joined(separator:)();
        v251 = v174;
        v175 = *(_QWORD *)(countAndFlagsBits + 16);
        v250 = v173;
        if (v175)
        {
          v176 = 0;
          LODWORD(v252) = *(_DWORD *)(v240 + 8);
          v177 = countAndFlagsBits + 40;
          v258 = MEMORY[0x1E0DEE9D8];
          while (1)
          {
            v178 = (_DWORD)v252 + v176;
            if (__OFADD__((_DWORD)v252, v176))
            {
              __break(1u);
LABEL_79:
              __break(1u);
LABEL_80:
              __break(1u);
LABEL_81:
              __break(1u);
LABEL_82:
              __break(1u);
              JUMPOUT(0x18DB1C5D4);
            }
            swift_bridgeObjectRetain();
            v179 = SQLTokenInformation.tokenName(location:)(v178);
            v254 = v180;
            if (v180)
              break;
            isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
            LODWORD(v255) = v176;
            if ((isUniquelyReferenced_nonNull_native & 1) == 0)
            {
              specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v258 + 16) + 1, 1, v258);
              v258 = v187;
            }
            v183 = *(_QWORD *)(v258 + 16);
            v182 = *(_QWORD *)(v258 + 24);
            if (v183 >= v182 >> 1)
            {
              specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v182 > 1, v183 + 1, 1, v258);
              v258 = v188;
            }
            v184 = v258;
            *(_QWORD *)(v258 + 16) = v183 + 1;
            *(Swift::String *)(v184 + 16 * v183 + 32) = v179;
            v185 = String.count.getter();
            swift_bridgeObjectRelease();
            if (v185 < (uint64_t)0xFFFFFFFF80000000)
              goto LABEL_79;
            if (v185 > 0x7FFFFFFF)
              goto LABEL_80;
            v186 = v255 + v185;
            if (__OFADD__((_DWORD)v255, (_DWORD)v185))
              goto LABEL_81;
            v176 = v186 + 1;
            if (__OFADD__(v186, 1))
              goto LABEL_82;
            v177 += 16;
            if (!--v175)
              goto LABEL_64;
          }
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          outlined destroy of PgQuery_Alias(v246, type metadata accessor for SQLTokenInformation);
          outlined destroy of PgQuery_Alias(v240, type metadata accessor for PgQuery_ColumnRef);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
        }
        else
        {
          v258 = MEMORY[0x1E0DEE9D8];
LABEL_64:
          swift_bridgeObjectRelease();
          v257._countAndFlagsBits = v258;
          v189 = BidirectionalCollection<>.joined(separator:)();
          v191 = v190;
          swift_bridgeObjectRelease();
          v257 = String.lowercased()();
          v193 = v250;
          v192 = v251;
          v256 = String.lowercased()();
          v194 = type metadata accessor for Locale();
          v195 = (uint64_t)v219;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v194 - 8) + 56))(v219, 1, 1, v194);
          lazy protocol witness table accessor for type String and conformance String();
          StringProtocol.range<A>(of:options:range:locale:)();
          v197 = v196;
          outlined destroy of (key: String, value: StorableValue)(v195, &demangling cache variable for type metadata for Locale?);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          if ((v197 & 1) == 0)
          {
            v198 = String.subscript.getter();
            v200 = v199;
            v202 = v201;
            v204 = v203;
            swift_bridgeObjectRelease();
            v205 = MEMORY[0x193FEC5A0](v198, v200, v202, v204);
            v207 = v206;
            swift_bridgeObjectRelease();
            v208 = specialized Set.contains(_:)(v193, v192, v244);
            v81 = v253;
            if ((v208 & 1) == 0)
            {
              v210 = v243;
              if (*(_QWORD *)(v243 + 16))
              {
                swift_bridgeObjectRetain();
                v211 = specialized __RawDictionaryStorage.find<A>(_:)();
                if ((v212 & 1) != 0)
                {
                  v213 = *(_BYTE *)(*(_QWORD *)(v210 + 56) + v211);
                  swift_bridgeObjectRelease();
                  swift_bridgeObjectRelease();
                  swift_bridgeObjectRelease_n();
                  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
                  v214 = swift_allocObject();
                  *(_OWORD *)(v214 + 16) = xmmword_18DC0CE20;
                  *(_QWORD *)(v214 + 32) = v205;
                  *(_QWORD *)(v214 + 40) = v207;
                  *(_BYTE *)(v214 + 48) = v213;
                  outlined destroy of PgQuery_Alias(v246, type metadata accessor for SQLTokenInformation);
                  outlined destroy of PgQuery_Alias(v240, type metadata accessor for PgQuery_ColumnRef);
                  v215 = v242;
                  *(_QWORD *)(v242 + 16) = 63;
                  *(_QWORD *)(v215 + 24) = 0xE100000000000000;
                  *(_BYTE *)(v215 + 32) = v213;
                  *(_QWORD *)(v215 + 40) = v214;
                  *(_QWORD *)(v215 + 48) = MEMORY[0x1E0DEE9D8];
                  outlined destroy of PgQuery_Alias(v239, type metadata accessor for PgQuery_ColumnRef);
                  return outlined destroy of (key: String, value: StorableValue)(v81, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
                }
                swift_bridgeObjectRelease();
              }
            }
            type metadata accessor for SQLExpressionError();
            lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
            swift_allocError();
            *v216 = v193;
            v216[1] = v192;
            swift_storeEnumTagMultiPayload();
            swift_bridgeObjectRetain();
            swift_willThrow();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            outlined destroy of PgQuery_Alias(v246, type metadata accessor for SQLTokenInformation);
            outlined destroy of PgQuery_Alias(v240, type metadata accessor for PgQuery_ColumnRef);
            swift_bridgeObjectRelease();
LABEL_75:
            swift_bridgeObjectRelease();
            outlined destroy of PgQuery_Alias(v239, type metadata accessor for PgQuery_ColumnRef);
            v147 = (uint64_t)v248;
LABEL_76:
            __swift_deallocate_boxed_opaque_existential_1(v147);
            return outlined destroy of (key: String, value: StorableValue)(v81, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          }
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          type metadata accessor for SQLExpressionError();
          lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
          swift_allocError();
          *v209 = v193;
          v209[1] = v192;
          v209[2] = v189;
          v209[3] = v191;
          swift_storeEnumTagMultiPayload();
          swift_willThrow();
          outlined destroy of PgQuery_Alias(v246, type metadata accessor for SQLTokenInformation);
          outlined destroy of PgQuery_Alias(v240, type metadata accessor for PgQuery_ColumnRef);
        }
        v81 = v253;
        goto LABEL_75;
      case 168:
      case 171:
      case 172:
      case 173:
      case 174:
      case 175:
      case 176:
      case 177:
      case 178:
      case 179:
      case 180:
      case 181:
      case 182:
      case 183:
      case 184:
      case 185:
      case 186:
      case 187:
      case 188:
      case 189:
      case 190:
      case 191:
      case 192:
      case 193:
      case 194:
      case 195:
      case 196:
      case 197:
      case 198:
      case 199:
      case 200:
      case 201:
      case 202:
      case 203:
      case 204:
      case 205:
      case 206:
      case 207:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
        goto LABEL_17;
      case 169:
        v131 = v83;
        v83 = v227;
        outlined init with take of PgQuery_OidList(v131, v227, type metadata accessor for PgQuery_A_Const);
        v132 = v226;
        outlined init with copy of PgQuery_RawStmt(v83, v226, type metadata accessor for PgQuery_A_Const);
        v133 = v228;
        outlined init with copy of PgQuery_RawStmt(v242, v228, type metadata accessor for SQLTokenInformation);
        *(_QWORD *)(v86 + 24) = &unk_1E263BCC8;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionConst;
        v134 = swift_allocObject();
        v135 = v134 + 16;
        *(_QWORD *)v86 = v134;
        v136 = v241;
        swift_bridgeObjectRetain();
        v137 = v243;
        swift_bridgeObjectRetain();
        v138 = v244;
        swift_bridgeObjectRetain();
        SQLExpressionConst.init(const:schemas:columnResolver:tokenInformation:)(v132, v136, v137, v138, v133, v135);
        v95 = type metadata accessor for PgQuery_A_Const;
        if (!v85)
          goto LABEL_44;
        v139 = v83;
        goto LABEL_36;
      case 170:
        v87 = v234;
        outlined init with take of PgQuery_OidList(v83, v234, type metadata accessor for PgQuery_FuncCall);
        v140 = v233;
        outlined init with copy of PgQuery_RawStmt(v87, v233, type metadata accessor for PgQuery_FuncCall);
        v141 = v230;
        outlined init with copy of PgQuery_RawStmt(v242, v230, type metadata accessor for SQLTokenInformation);
        *(_QWORD *)(v86 + 24) = &unk_1E263DAA8;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionFuncCall;
        v142 = swift_allocObject();
        v143 = v142 + 16;
        *(_QWORD *)v86 = v142;
        v144 = v241;
        swift_bridgeObjectRetain();
        v145 = v243;
        swift_bridgeObjectRetain();
        v146 = v244;
        swift_bridgeObjectRetain();
        SQLExpressionFuncCall.init(function:schemas:columnResolver:tokenInformation:)(v140, v144, v145, v146, v141, v143);
        v95 = type metadata accessor for PgQuery_FuncCall;
        if (!v85)
        {
LABEL_11:
          outlined destroy of PgQuery_Alias(v87, v95);
          return outlined destroy of (key: String, value: StorableValue)(v81, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        }
LABEL_35:
        v139 = v87;
LABEL_36:
        outlined destroy of PgQuery_Alias(v139, v95);
        v147 = v86;
        goto LABEL_76;
      case 220:
        v148 = type metadata accessor for PgQuery_Integer;
        v149 = v235;
        outlined init with take of PgQuery_OidList(v83, (uint64_t)v235, type metadata accessor for PgQuery_Integer);
        v150 = *v149;
        *(_QWORD *)(v86 + 24) = &unk_1E263D550;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionInteger;
        *(_DWORD *)v86 = v150;
        *(_BYTE *)(v86 + 4) = 0;
        v151 = MEMORY[0x1E0DEE9D8];
        *(_QWORD *)(v86 + 8) = MEMORY[0x1E0DEE9D8];
        *(_QWORD *)(v86 + 16) = v151;
        v152 = (uint64_t)v149;
        goto LABEL_42;
      case 221:
        v148 = type metadata accessor for PgQuery_Float;
        v153 = v237;
        outlined init with take of PgQuery_OidList(v83, (uint64_t)v237, type metadata accessor for PgQuery_Float);
        v155 = *v153;
        v154 = v153[1];
        *(_QWORD *)(v86 + 24) = &unk_1E263BD78;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionFloat;
        v156 = swift_allocObject();
        *(_QWORD *)v86 = v156;
        *(_QWORD *)(v156 + 16) = v155;
        *(_QWORD *)(v156 + 24) = v154;
        v157 = 1;
        goto LABEL_41;
      case 222:
        v148 = type metadata accessor for PgQuery_String;
        v153 = v236;
        outlined init with take of PgQuery_OidList(v83, (uint64_t)v236, type metadata accessor for PgQuery_String);
        v159 = *v153;
        v158 = v153[1];
        *(_QWORD *)(v86 + 24) = &unk_1E263CC50;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionString;
        v156 = swift_allocObject();
        *(_QWORD *)v86 = v156;
        *(_QWORD *)(v156 + 16) = v159;
        *(_QWORD *)(v156 + 24) = v158;
        v157 = 2;
        goto LABEL_41;
      case 223:
        v148 = type metadata accessor for PgQuery_BitString;
        v153 = v238;
        outlined init with take of PgQuery_OidList(v83, (uint64_t)v238, type metadata accessor for PgQuery_BitString);
        v161 = *v153;
        v160 = v153[1];
        *(_QWORD *)(v86 + 24) = &unk_1E263E6F0;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionBitString;
        v156 = swift_allocObject();
        *(_QWORD *)v86 = v156;
        *(_QWORD *)(v156 + 16) = v161;
        *(_QWORD *)(v156 + 24) = v160;
        v157 = 4;
LABEL_41:
        *(_BYTE *)(v156 + 32) = v157;
        v162 = MEMORY[0x1E0DEE9D8];
        *(_QWORD *)(v156 + 40) = MEMORY[0x1E0DEE9D8];
        *(_QWORD *)(v156 + 48) = v162;
        swift_bridgeObjectRetain();
        v152 = (uint64_t)v153;
LABEL_42:
        outlined destroy of PgQuery_Alias(v152, v148);
        return outlined destroy of (key: String, value: StorableValue)(v81, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      case 224:
        v248[3] = (uint64_t)&unk_1E263B3B0;
        *(_QWORD *)(v86 + 32) = &protocol witness table for SQLExpressionNull;
        v163 = swift_allocObject();
        *(_QWORD *)v86 = v163;
        *(_QWORD *)(v163 + 16) = 1280070990;
        *(_QWORD *)(v163 + 24) = 0xE400000000000000;
        *(_BYTE *)(v163 + 32) = 7;
        v164 = MEMORY[0x1E0DEE9D8];
        *(_QWORD *)(v163 + 40) = MEMORY[0x1E0DEE9D8];
        *(_QWORD *)(v163 + 48) = v164;
        v95 = type metadata accessor for PgQuery_Node.OneOf_Node;
LABEL_44:
        outlined destroy of PgQuery_Alias(v83, v95);
        return outlined destroy of (key: String, value: StorableValue)(v81, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      default:
        v99 = v254;
        v100 = v248;
        if (EnumCaseMultiPayload == 16)
        {
          v165 = v223;
          outlined init with take of PgQuery_OidList(v83, v223, type metadata accessor for PgQuery_BoolExpr);
          v166 = v222;
          outlined init with copy of PgQuery_RawStmt(v165, v222, type metadata accessor for PgQuery_BoolExpr);
          v167 = v220;
          outlined init with copy of PgQuery_RawStmt(v242, v220, type metadata accessor for SQLTokenInformation);
          v100[3] = (uint64_t)&unk_1E263D498;
          v100[4] = (uint64_t)&protocol witness table for SQLExpressioBoolExpr;
          v168 = v241;
          swift_bridgeObjectRetain();
          v169 = v243;
          swift_bridgeObjectRetain();
          v170 = v244;
          swift_bridgeObjectRetain();
          SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)(v166, v168, v169, v170, v167);
          v110 = v99;
          v111 = v165;
          v112 = type metadata accessor for PgQuery_BoolExpr;
        }
        else
        {
          if (EnumCaseMultiPayload != 37)
          {
LABEL_17:
            outlined destroy of PgQuery_Alias(v83, type metadata accessor for PgQuery_Node.OneOf_Node);
            break;
          }
          v101 = v83;
          v102 = v225;
          outlined init with take of PgQuery_OidList(v101, v225, type metadata accessor for PgQuery_NullTest);
          v103 = v224;
          outlined init with copy of PgQuery_RawStmt(v102, v224, type metadata accessor for PgQuery_NullTest);
          v104 = v221;
          outlined init with copy of PgQuery_RawStmt(v242, v221, type metadata accessor for SQLTokenInformation);
          v100[3] = (uint64_t)&unk_1E263DB58;
          v100[4] = (uint64_t)&protocol witness table for SQLExpressionNullTest;
          v105 = swift_allocObject();
          v106 = v105 + 16;
          *v100 = v105;
          v107 = v241;
          swift_bridgeObjectRetain();
          v108 = v243;
          swift_bridgeObjectRetain();
          v109 = v244;
          swift_bridgeObjectRetain();
          SQLExpressionNullTest.init(nullTest:schemas:columnResolver:tokenInformation:)(v103, v107, v108, v109, v104, v106);
          v110 = v99;
          v111 = v102;
          v112 = type metadata accessor for PgQuery_NullTest;
        }
        outlined destroy of PgQuery_Alias(v111, v112);
        if (!v110)
          return outlined destroy of (key: String, value: StorableValue)(v81, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        v147 = (uint64_t)v100;
        goto LABEL_76;
    }
  }
  type metadata accessor for SQLExpressionError();
  lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
  swift_allocError();
  outlined init with copy of PgQuery_RawStmt(v80, v82, type metadata accessor for PgQuery_Node);
  swift_storeEnumTagMultiPayload();
  swift_willThrow();
  return outlined destroy of (key: String, value: StorableValue)(v81, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
}

uint64_t SQLExpression.init(rootNode:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;

  outlined init with copy of Aggregation(a1, a2);
  v4 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((_QWORD *)a2, v4);
  *(_QWORD *)(a2 + 40) = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 8))(v4, v5);
  *(_QWORD *)(a2 + 48) = v6;
  v7 = *(_QWORD *)(a2 + 24);
  v8 = *(_QWORD *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((_QWORD *)a2, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 16))(&v19, v7, v8);
  *(_BYTE *)(a2 + 56) = v19;
  v9 = *(_QWORD *)(a2 + 24);
  v10 = *(_QWORD *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((_QWORD *)a2, v9);
  *(_QWORD *)(a2 + 64) = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 24))(v9, v10);
  v11 = *(_QWORD *)(a2 + 24);
  v12 = *(_QWORD *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((_QWORD *)a2, v11);
  *(_QWORD *)(a2 + 72) = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 32))(v11, v12);
  v13 = *(_QWORD *)(a2 + 24);
  v14 = *(_QWORD *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((_QWORD *)a2, v13);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(v13, v14);
  v17 = v16;
  result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *(_QWORD *)(a2 + 80) = v15;
  *(_QWORD *)(a2 + 88) = v17;
  return result;
}

uint64_t SQLExpression.CodingKeys.stringValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_18DB1C818 + 4 * byte_18DC2BE48[a1]))(0xD000000000000010, 0x800000018DCD1200);
}

uint64_t sub_18DB1C818()
{
  return 0x79546E7275746572;
}

uint64_t sub_18DB1C834(uint64_t a1)
{
  return a1 + 4;
}

uint64_t sub_18DB1C84C()
{
  return 0x73676E69646E6962;
}

uint64_t sub_18DB1C864()
{
  return 7106931;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance SQLExpression.CodingKeys(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void protocol witness for Hashable.hash(into:) in conformance SQLExpression.CodingKeys()
{
  unsigned __int8 *v0;

  Hasher._combine(_:)(*v0);
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance SQLExpression.CodingKeys()
{
  unsigned __int8 *v0;

  return SQLExpression.CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance SQLExpression.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized SQLExpression.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance SQLExpression.CodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 5;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance SQLExpression.CodingKeys()
{
  lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance SQLExpression.CodingKeys()
{
  lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t SQLExpression.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v10;
  char v11;

  v3 = v1;
  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<SQLExpression.CodingKeys>);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v8 = (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  LOBYTE(v10) = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v2)
  {
    LOBYTE(v10) = *(_BYTE *)(v3 + 56);
    v11 = 1;
    lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    v10 = *(_QWORD *)(v3 + 64);
    v11 = 2;
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for [AggregationFunction]);
    lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](&lazy protocol witness table cache variable for type [AggregationFunction] and conformance <A> [A], (uint64_t *)&demangling cache variable for type metadata for [AggregationFunction], (uint64_t (*)(void))lazy protocol witness table accessor for type AggregationFunction and conformance AggregationFunction);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    v10 = *(_QWORD *)(v3 + 72);
    v11 = 3;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [Binding]);
    lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](&lazy protocol witness table cache variable for type [Binding] and conformance <A> [A], &demangling cache variable for type metadata for [Binding], (uint64_t (*)(void))lazy protocol witness table accessor for type Binding and conformance Binding);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    LOBYTE(v10) = 4;
    KeyedEncodingContainer.encode(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

unint64_t lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLExpression.CodingKeys, &type metadata for SQLExpression.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLExpression.CodingKeys, &type metadata for SQLExpression.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLExpression.CodingKeys, &type metadata for SQLExpression.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLExpression.CodingKeys, &type metadata for SQLExpression.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLDataType, &type metadata for SQLDataType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLDataType, &type metadata for SQLDataType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLDataType, &type metadata for SQLDataType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLDataType, &type metadata for SQLDataType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction and conformance AggregationFunction()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction and conformance AggregationFunction;
  if (!lazy protocol witness table cache variable for type AggregationFunction and conformance AggregationFunction)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction, &type metadata for AggregationFunction);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction and conformance AggregationFunction);
  }
  return result;
}

uint64_t lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](unint64_t *a1, uint64_t *a2, uint64_t (*a3)(void))
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = *a1;
  if (!result)
  {
    v6 = __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    v7 = a3();
    result = MEMORY[0x193FED7A0](MEMORY[0x1E0DEAF10], v6, &v7);
    atomic_store(result, a1);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Binding and conformance Binding()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Binding and conformance Binding;
  if (!lazy protocol witness table cache variable for type Binding and conformance Binding)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Binding, &type metadata for Binding);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding and conformance Binding);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Binding and conformance Binding;
  if (!lazy protocol witness table cache variable for type Binding and conformance Binding)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Binding, &type metadata for Binding);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding and conformance Binding);
  }
  return result;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SQLExpression(_QWORD *a1)
{
  return SQLExpression.encode(to:)(a1);
}

void Binding.dataType.getter(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 16);
}

BiomeSQLParser::Binding __swiftcall Binding.init(name:dataType:)(Swift::String name, BiomeSQLParser::SQLDataType dataType)
{
  uint64_t v2;
  char v3;
  BiomeSQLParser::Binding result;

  v3 = *(_BYTE *)dataType;
  *(Swift::String *)v2 = name;
  *(_BYTE *)(v2 + 16) = v3;
  result.name = name;
  result.dataType = dataType;
  return result;
}

void Binding.hash(into:)()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(unsigned __int8 *)(v0 + 16);
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  __asm { BR              X9 }
}

uint64_t sub_18DB1CD74()
{
  String.hash(into:)();
  return swift_bridgeObjectRelease();
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance Binding.CodingKeys()
{
  _BYTE *v0;

  if (*v0)
    return 0x6570795461746164;
  else
    return 1701667182;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance Binding.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized Binding.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance Binding.CodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Binding.CodingKeys()
{
  lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Binding.CodingKeys()
{
  lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t Binding.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v8;
  uint64_t v9;
  int v10;
  char v11;
  char v12;
  char v13;

  v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<Binding.CodingKeys>);
  v9 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](v4);
  v6 = (char *)&v8 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = *(unsigned __int8 *)(v1 + 16);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v13 = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v2)
  {
    v12 = v10;
    v11 = 1;
    lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v6, v4);
}

void Binding.hashValue.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(unsigned __int8 *)(v0 + 16);
  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  __asm { BR              X9 }
}

Swift::Int sub_18DB1D07C()
{
  String.hash(into:)();
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Binding(_QWORD *a1)
{
  return Binding.encode(to:)(a1);
}

void protocol witness for Hashable._rawHashValue(seed:) in conformance Binding()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(unsigned __int8 *)(v0 + 16);
  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  __asm { BR              X9 }
}

Swift::Int sub_18DB1D1AC()
{
  String.hash(into:)();
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

void static Binding.== infix(_:_:)(uint64_t a1, _QWORD *a2)
{
  char v2;
  BOOL v3;

  v2 = *(_BYTE *)(a1 + 16);
  v3 = *(_QWORD *)a1 == *a2 && *(_QWORD *)(a1 + 8) == a2[1];
  if (v3 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
    specialized == infix<A>(_:_:)(v2);
}

void protocol witness for static Equatable.== infix(_:_:) in conformance Binding(uint64_t a1, _QWORD *a2)
{
  char v2;
  BOOL v3;

  v2 = *(_BYTE *)(a1 + 16);
  v3 = *(_QWORD *)a1 == *a2 && *(_QWORD *)(a1 + 8) == a2[1];
  if (v3 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
    specialized == infix<A>(_:_:)(v2);
}

void _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSDySSSiG_SSs5NeverOTg5181_s14BiomeSQLParser14ColumnResolver33_B787555787B9EFBBEFB0C9C5225A4FB7LLV7schemasADSayAA6SchemaVG_tKcfcS2S3key_Si5valuet_tcfu_32a168a102879cc1a6a91172b0770f0c91SSAI_SiAJtSSTf3nnnpk_nTf1cn_n(uint64_t a1)
{
  uint64_t v1;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    v24 = MEMORY[0x1E0DEE9D8];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v1, 0);
    v4 = specialized Dictionary.startIndex.getter(a1);
    v5 = 0;
    v6 = a1 + 64;
    v20 = v1;
    v21 = v3;
    v22 = a1 + 64;
    while ((v4 & 0x8000000000000000) == 0 && v4 < 1 << *(_BYTE *)(a1 + 32))
    {
      v9 = (unint64_t)v4 >> 6;
      if ((*(_QWORD *)(v6 + 8 * ((unint64_t)v4 >> 6)) & (1 << v4)) == 0)
        goto LABEL_23;
      if (*(_DWORD *)(a1 + 36) != v3)
        goto LABEL_24;
      v10 = (uint64_t *)(*(_QWORD *)(a1 + 48) + 16 * v4);
      v11 = v10[1];
      v23 = *v10;
      v13 = *(_QWORD *)(v24 + 16);
      v12 = *(_QWORD *)(v24 + 24);
      swift_bridgeObjectRetain();
      if (v13 >= v12 >> 1)
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v12 > 1, v13 + 1, 1);
      *(_QWORD *)(v24 + 16) = v13 + 1;
      v14 = v24 + 16 * v13;
      *(_QWORD *)(v14 + 32) = v23;
      *(_QWORD *)(v14 + 40) = v11;
      v7 = 1 << *(_BYTE *)(a1 + 32);
      if (v4 >= v7)
        goto LABEL_25;
      v6 = a1 + 64;
      v15 = *(_QWORD *)(v22 + 8 * v9);
      if ((v15 & (1 << v4)) == 0)
        goto LABEL_26;
      v3 = v21;
      if (*(_DWORD *)(a1 + 36) != v21)
        goto LABEL_27;
      v16 = v15 & (-2 << (v4 & 0x3F));
      if (v16)
      {
        v7 = __clz(__rbit64(v16)) | v4 & 0xFFFFFFFFFFFFFFC0;
        v8 = v20;
      }
      else
      {
        v17 = v9 + 1;
        v18 = (unint64_t)(v7 + 63) >> 6;
        v8 = v20;
        if (v9 + 1 < v18)
        {
          v19 = *(_QWORD *)(v22 + 8 * v17);
          if (v19)
          {
LABEL_20:
            v7 = __clz(__rbit64(v19)) + (v17 << 6);
          }
          else
          {
            while (v18 - 2 != v9)
            {
              v19 = *(_QWORD *)(a1 + 80 + 8 * v9++);
              if (v19)
              {
                v17 = v9 + 1;
                goto LABEL_20;
              }
            }
          }
        }
      }
      ++v5;
      v4 = v7;
      if (v5 == v8)
        return;
    }
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
  }
}

uint64_t specialized SQLExpressionNode.sql()()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  int64_t v14;
  int64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD v24[2];
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v1 = v0;
  v2 = SQLExpressionAExpr.expressionString.getter();
  v4 = v3;
  v32 = v2;
  v33 = v3;
  lazy protocol witness table accessor for type String and conformance String();
  v5 = 0;
  v6 = 0;
  v23 = (_QWORD *)(v0 + 40);
  lazy protocol witness table accessor for type String and conformance String();
  while (1)
  {
    v30 = v2;
    v31 = v4;
    v28 = 63;
    v29 = 0xE100000000000000;
    BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v25 & 1) != 0)
      return v2;
    outlined init with copy of PgQuery_Alias?(v1, (uint64_t)v24, &demangling cache variable for type metadata for SQLExpressionNode?);
    v7 = v26;
    if (v26)
    {
      v8 = v27;
      __swift_project_boxed_opaque_existential_1(v24, v26);
      v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 32))(v7, v8);
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v24);
    }
    else
    {
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v24, &demangling cache variable for type metadata for SQLExpressionNode?);
      v9 = MEMORY[0x1E0DEE9D8];
    }
    v11 = *(_QWORD *)(v1 + 64);
    v10 = *(_QWORD *)(v1 + 72);
    __swift_project_boxed_opaque_existential_1(v23, v11);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 32))(v11, v10);
    v13 = *(_QWORD *)(result + 16);
    v14 = *(_QWORD *)(v9 + 16);
    v15 = v14 + v13;
    if (__OFADD__(v14, v13))
      break;
    v16 = result;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((_DWORD)result && v15 <= *(_QWORD *)(v9 + 24) >> 1)
    {
      if (*(_QWORD *)(v16 + 16))
        goto LABEL_10;
    }
    else
    {
      if (v14 <= v15)
        v20 = v14 + v13;
      else
        v20 = v14;
      result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v20, 1, (char *)v9);
      v9 = result;
      if (*(_QWORD *)(v16 + 16))
      {
LABEL_10:
        if ((*(_QWORD *)(v9 + 24) >> 1) - *(_QWORD *)(v9 + 16) < v13)
          goto LABEL_25;
        result = swift_arrayInitWithCopy();
        if (v13)
        {
          v17 = *(_QWORD *)(v9 + 16);
          v18 = __OFADD__(v17, v13);
          v19 = v17 + v13;
          if (v18)
            goto LABEL_26;
          *(_QWORD *)(v9 + 16) = v19;
        }
        goto LABEL_19;
      }
    }
    if (v13)
      goto LABEL_24;
LABEL_19:
    result = swift_bridgeObjectRelease();
    if (v6 >= *(_QWORD *)(v9 + 16))
      goto LABEL_23;
    v21 = *(_QWORD *)(v9 + v5 + 32);
    v22 = *(_QWORD *)(v9 + v5 + 40);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    v24[0] = v21;
    v24[1] = v22;
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    ++v6;
    v2 = v32;
    v4 = v33;
    v5 += 24;
  }
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
LABEL_25:
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  v1 = v0[3];
  v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
  v10 = v3;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  v4 = 0;
  for (i = 0; ; ++i)
  {
    BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v9 & 1) != 0)
      return v3;
    v6 = v0[3];
    v7 = v0[4];
    __swift_project_boxed_opaque_existential_1(v0, v6);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 32))(v6, v7);
    if (i >= *(_QWORD *)(result + 16))
      break;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    v3 = v10;
    v4 += 24;
  }
  __break(1u);
  return result;
}

{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  char v7;
  uint64_t v8;

  v1 = SQLExpressionNullTest.expressionString.getter();
  v8 = v1;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  v2 = 0;
  for (i = 0; ; ++i)
  {
    BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v7 & 1) != 0)
      return v1;
    v4 = v0[3];
    v5 = v0[4];
    __swift_project_boxed_opaque_existential_1(v0, v4);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 32))(v4, v5);
    if (i >= *(_QWORD *)(result + 16))
      break;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    v1 = v8;
    v2 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t result;
  char v5;
  uint64_t v6;

  v1 = *v0;
  v6 = *v0;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  swift_bridgeObjectRetain();
  v2 = 0;
  for (i = 0; ; ++i)
  {
    result = BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v5 & 1) != 0)
      return v1;
    if (i >= *(_QWORD *)(v0[4] + 16))
      break;
    String.replaceSubrange<A>(_:with:)();
    v1 = v6;
    v2 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t result;
  char v5;
  uint64_t v6;

  v1 = *v0;
  v6 = *v0;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  swift_bridgeObjectRetain();
  v2 = 0;
  for (i = 0; ; ++i)
  {
    result = BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v5 & 1) != 0)
      return v1;
    if (i >= *(_QWORD *)(v0[3] + 16))
      break;
    String.replaceSubrange<A>(_:with:)();
    v1 = v6;
    v2 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t v0;
  Swift::String v1;
  Swift::String v2;
  uint64_t v3;
  unint64_t i;
  uint64_t result;
  char v6;

  lazy protocol witness table accessor for type String and conformance String();
  v1._countAndFlagsBits = StringProtocol.replacingOccurrences<A, B>(of:with:options:range:)();
  String.append(_:)(v1);
  swift_bridgeObjectRelease();
  v2._countAndFlagsBits = 39;
  v2._object = (void *)0xE100000000000000;
  String.append(_:)(v2);
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  v3 = 0;
  for (i = 0; ; ++i)
  {
    result = BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v6 & 1) != 0)
      return 39;
    if (i >= *(_QWORD *)(*(_QWORD *)(v0 + 32) + 16))
      break;
    String.replaceSubrange<A>(_:with:)();
    v3 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t inited;
  Swift::String v3;
  char v4;
  uint64_t result;
  uint64_t v6;
  Swift::String v7;
  char v8;
  char v9;

  v1 = *(_QWORD *)(v0 + 200);
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  swift_bridgeObjectRetain();
  BidirectionalCollection<>.firstRange<A>(of:)();
  if ((v9 & 1) != 0)
    return v1;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
  inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_18DC0CE20;
  v3 = AggregationFunction.name()();
  v4 = *(_BYTE *)(v0 + 193);
  *(Swift::String *)(inited + 32) = v3;
  *(_BYTE *)(inited + 48) = v4;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  String.replaceSubrange<A>(_:with:)();
  swift_bridgeObjectRelease();
  BidirectionalCollection<>.firstRange<A>(of:)();
  if (v9 == 1)
    return v1;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
  v6 = swift_initStackObject();
  *(_OWORD *)(v6 + 16) = xmmword_18DC0CE20;
  v7 = AggregationFunction.name()();
  result = v7._countAndFlagsBits;
  v8 = *(_BYTE *)(v0 + 193);
  *(Swift::String *)(v6 + 32) = v7;
  *(_BYTE *)(v6 + 48) = v8;
  __break(1u);
  return result;
}

uint64_t specialized SQLExpressionNode.sql()(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int64_t v14;
  int64_t v15;
  char *isUniquelyReferenced_nonNull_native;
  int64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  _QWORD v27[2];
  char v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;

  if ((a3 & 1) != 0)
    __asm { BR              X9 }
  v4 = 0;
  v5 = 0xE000000000000000;
  v35 = 0;
  v36 = 0xE000000000000000;
  lazy protocol witness table accessor for type String and conformance String();
  v6 = 0;
  v25 = a1 + 32;
  v26 = a1;
  lazy protocol witness table accessor for type String and conformance String();
  while (1)
  {
    v33 = v4;
    v34 = v5;
    v31 = 63;
    v32 = 0xE100000000000000;
    BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v28 & 1) != 0)
      return v4;
    v7 = *(_QWORD *)(a1 + 16);
    if (v7)
    {
      swift_bridgeObjectRetain_n();
      v8 = v25;
      v9 = (char *)MEMORY[0x1E0DEE9D8];
      while (1)
      {
        outlined init with copy of Aggregation(v8, (uint64_t)v27);
        v10 = v29;
        v11 = v30;
        __swift_project_boxed_opaque_existential_1(v27, v29);
        v12 = (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 32))(v10, v11);
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v27);
        v13 = *(_QWORD *)(v12 + 16);
        v14 = *((_QWORD *)v9 + 2);
        v15 = v14 + v13;
        if (__OFADD__(v14, v13))
        {
          __break(1u);
LABEL_28:
          __break(1u);
LABEL_29:
          __break(1u);
LABEL_30:
          __break(1u);
          goto LABEL_31;
        }
        isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
        if ((_DWORD)isUniquelyReferenced_nonNull_native && v15 <= *((_QWORD *)v9 + 3) >> 1)
        {
          if (*(_QWORD *)(v12 + 16))
            goto LABEL_18;
        }
        else
        {
          if (v14 <= v15)
            v17 = v14 + v13;
          else
            v17 = v14;
          v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(isUniquelyReferenced_nonNull_native, v17, 1, v9);
          if (*(_QWORD *)(v12 + 16))
          {
LABEL_18:
            if ((*((_QWORD *)v9 + 3) >> 1) - *((_QWORD *)v9 + 2) < v13)
              goto LABEL_29;
            swift_arrayInitWithCopy();
            if (v13)
            {
              v18 = *((_QWORD *)v9 + 2);
              v19 = __OFADD__(v18, v13);
              v20 = v18 + v13;
              if (v19)
                goto LABEL_30;
              *((_QWORD *)v9 + 2) = v20;
            }
            goto LABEL_8;
          }
        }
        if (v13)
          goto LABEL_28;
LABEL_8:
        swift_bridgeObjectRelease();
        v8 += 40;
        if (!--v7)
        {
          swift_bridgeObjectRelease_n();
          goto LABEL_24;
        }
      }
    }
    v9 = (char *)MEMORY[0x1E0DEE9D8];
LABEL_24:
    if (v6 >= *((_QWORD *)v9 + 2))
    {
LABEL_31:
      __break(1u);
      JUMPOUT(0x18DB1DD64);
    }
    v21 = &v9[24 * v6];
    v23 = *((_QWORD *)v21 + 4);
    v22 = *((_QWORD *)v21 + 5);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    v27[0] = v23;
    v27[1] = v22;
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    ++v6;
    v4 = v35;
    v5 = v36;
    a1 = v26;
  }
}

uint64_t specialized SQLExpressionNode.sql()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t i;
  uint64_t result;
  char v8;
  uint64_t v9;

  v4 = dispatch thunk of CustomStringConvertible.description.getter();
  v9 = v4;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  v5 = 0;
  for (i = a3 + 40; ; i += 24)
  {
    result = BidirectionalCollection<>.firstRange<A>(of:)();
    if ((v8 & 1) != 0)
      return v4;
    if (v5 >= *(_QWORD *)(a3 + 16))
      break;
    String.replaceSubrange<A>(_:with:)();
    ++v5;
    v4 = v9;
  }
  __break(1u);
  return result;
}

uint64_t specialized SQLExpressionNode.sql()(char a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  Swift::String v19;
  Swift::String v20;
  Swift::String v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t result;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int64_t v32;
  int64_t v33;
  uint64_t v34;
  int64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v2 = a2;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = MEMORY[0x1E0DEE9D8];
  v43 = v4;
  if (v4)
  {
    v51 = MEMORY[0x1E0DEE9D8];
    swift_bridgeObjectRetain();
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v4, 0);
    v6 = v2 + 32;
    v5 = v51;
    do
    {
      outlined init with copy of Aggregation(v6, (uint64_t)&v46);
      v7 = v49;
      v8 = v50;
      __swift_project_boxed_opaque_existential_1(&v46, v49);
      v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
      v11 = v10;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v46);
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v5 + 16) + 1, 1);
        v5 = v51;
      }
      v13 = *(_QWORD *)(v5 + 16);
      v12 = *(_QWORD *)(v5 + 24);
      if (v13 >= v12 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v12 > 1, v13 + 1, 1);
        v5 = v51;
      }
      *(_QWORD *)(v5 + 16) = v13 + 1;
      v14 = v5 + 16 * v13;
      *(_QWORD *)(v14 + 32) = v9;
      *(_QWORD *)(v14 + 40) = v11;
      v6 += 40;
      --v4;
    }
    while (v4);
    v2 = a2;
    swift_bridgeObjectRelease();
  }
  v46 = v5;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  v15 = BidirectionalCollection<>.joined(separator:)();
  v17 = v16;
  swift_bridgeObjectRelease();
  LOBYTE(v46) = a1;
  v46 = SQLFunction.rawValue.getter();
  v47 = v18;
  v19._countAndFlagsBits = 40;
  v19._object = (void *)0xE100000000000000;
  String.append(_:)(v19);
  v20._countAndFlagsBits = v15;
  v20._object = v17;
  String.append(_:)(v20);
  swift_bridgeObjectRelease();
  v21._countAndFlagsBits = 41;
  v21._object = (void *)0xE100000000000000;
  String.append(_:)(v21);
  v22 = v46;
  v51 = v46;
  v52 = v47;
  lazy protocol witness table accessor for type String and conformance String();
  v23 = lazy protocol witness table accessor for type String and conformance String();
  v45 = 0;
  v42 = v2 + 32;
  while (1)
  {
    v24 = v23;
    result = BidirectionalCollection<>.firstRange<A>(of:)();
    v26 = v43;
    if ((v48 & 1) != 0)
      return v22;
    if (v43)
      break;
    v28 = MEMORY[0x1E0DEE9D8];
LABEL_30:
    v23 = v24;
    if (v45 >= *(_QWORD *)(v28 + 16))
      goto LABEL_37;
    v39 = v28 + 24 * v45;
    v41 = *(_QWORD *)(v39 + 32);
    v40 = *(_QWORD *)(v39 + 40);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    v46 = v41;
    v47 = v40;
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    ++v45;
    v22 = v51;
  }
  swift_bridgeObjectRetain_n();
  v27 = v42;
  v28 = MEMORY[0x1E0DEE9D8];
  while (1)
  {
    outlined init with copy of Aggregation(v27, (uint64_t)&v46);
    v29 = v49;
    v30 = v50;
    __swift_project_boxed_opaque_existential_1(&v46, v49);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v30 + 32))(v29, v30);
    v31 = *(_QWORD *)(result + 16);
    v32 = *(_QWORD *)(v28 + 16);
    v33 = v32 + v31;
    if (__OFADD__(v32, v31))
      break;
    v34 = result;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((_DWORD)result && v33 <= *(_QWORD *)(v28 + 24) >> 1)
    {
      if (*(_QWORD *)(v34 + 16))
        goto LABEL_24;
    }
    else
    {
      if (v32 <= v33)
        v35 = v32 + v31;
      else
        v35 = v32;
      result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v35, 1, (char *)v28);
      v28 = result;
      if (*(_QWORD *)(v34 + 16))
      {
LABEL_24:
        if ((*(_QWORD *)(v28 + 24) >> 1) - *(_QWORD *)(v28 + 16) < v31)
          goto LABEL_35;
        result = swift_arrayInitWithCopy();
        if (v31)
        {
          v36 = *(_QWORD *)(v28 + 16);
          v37 = __OFADD__(v36, v31);
          v38 = v36 + v31;
          if (v37)
            goto LABEL_36;
          *(_QWORD *)(v28 + 16) = v38;
        }
        goto LABEL_14;
      }
    }
    if (v31)
    {
      __break(1u);
      break;
    }
LABEL_14:
    swift_bridgeObjectRelease();
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v46);
    v27 += 40;
    if (!--v26)
    {
      result = swift_bridgeObjectRelease_n();
      goto LABEL_30;
    }
  }
  __break(1u);
LABEL_35:
  __break(1u);
LABEL_36:
  __break(1u);
LABEL_37:
  __break(1u);
  return result;
}

uint64_t SQLExpressionConstString.expressionString.getter()
{
  Swift::String v0;
  Swift::String v1;

  lazy protocol witness table accessor for type String and conformance String();
  v0._countAndFlagsBits = StringProtocol.replacingOccurrences<A, B>(of:with:options:range:)();
  String.append(_:)(v0);
  swift_bridgeObjectRelease();
  v1._countAndFlagsBits = 39;
  v1._object = (void *)0xE100000000000000;
  String.append(_:)(v1);
  return 39;
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionConstString()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t protocol witness for SQLExpressionNode.expressionString.getter in conformance SQLExpressionInteger()
{
  return dispatch thunk of CustomStringConvertible.description.getter();
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionInteger(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 4);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionInteger()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionInteger()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionInteger()
{
  unsigned int *v0;

  return specialized SQLExpressionNode.sql()(*v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32), *((_QWORD *)v0 + 1), *((_QWORD *)v0 + 2));
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionNull(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 16);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionNull()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionNull()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionNull()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t SQLExpressionConst.init(const:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t String;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t Node;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int (*v28)(char *, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  void *v52;
  _UNKNOWN **v53;
  uint64_t v54;

  v48 = a3;
  v49 = a5;
  v46 = a2;
  v47 = a4;
  v45 = a6;
  String = type metadata accessor for PgQuery_String(0);
  MEMORY[0x1E0C80A78](String);
  v43 = (uint64_t *)((char *)&v42 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v10 = MEMORY[0x1E0C80A78](v9);
  v44 = (uint64_t)&v42 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v10);
  v50 = (uint64_t)&v42 - v12;
  v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  v14 = MEMORY[0x1E0C80A78](v13);
  v16 = (char *)&v42 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v42 - v17;
  Node = type metadata accessor for PgQuery_Node(0);
  v20 = *(_QWORD *)(Node - 8);
  v21 = MEMORY[0x1E0C80A78](Node);
  v23 = (char *)&v42 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v42 - v24;
  v26 = a1;
  v42 = *(int *)(type metadata accessor for PgQuery_A_Const(0) + 20);
  v27 = *(_QWORD *)(a1 + v42);
  outlined init with copy of PgQuery_Alias?(v27 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_A_ConstP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, (uint64_t)v18, &demangling cache variable for type metadata for PgQuery_Node?);
  v28 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48);
  if (v28(v18, 1, Node) == 1)
  {
    UnknownStorage.init()();
    v29 = *(int *)(Node + 20);
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)&v25[v29] = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v18, &demangling cache variable for type metadata for PgQuery_Node?);
  }
  else
  {
    outlined init with take of PgQuery_OidList((uint64_t)v18, (uint64_t)v25, type metadata accessor for PgQuery_Node);
  }
  v30 = v50;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v25[*(int *)(Node + 20)]+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v50, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined destroy of PgQuery_Alias((uint64_t)v25, type metadata accessor for PgQuery_Node);
  v31 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v31 - 8) + 48))(v30, 1, v31) != 1)
  {
    v32 = v44;
    outlined init with copy of PgQuery_Alias?(v30, v44, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (swift_getEnumCaseMultiPayload() == 222)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      v33 = v43;
      outlined init with take of PgQuery_OidList(v32, (uint64_t)v43, type metadata accessor for PgQuery_String);
      v35 = *v33;
      v34 = v33[1];
      v52 = &unk_1E263EFA0;
      v53 = &protocol witness table for SQLExpressionConstString;
      v36 = swift_allocObject();
      *(_QWORD *)&v51 = v36;
      *(_QWORD *)(v36 + 16) = v35;
      *(_QWORD *)(v36 + 24) = v34;
      *(_BYTE *)(v36 + 32) = 2;
      v37 = MEMORY[0x1E0DEE9D8];
      *(_QWORD *)(v36 + 40) = MEMORY[0x1E0DEE9D8];
      *(_QWORD *)(v36 + 48) = v37;
      swift_bridgeObjectRetain();
      outlined destroy of PgQuery_Alias(v49, type metadata accessor for SQLTokenInformation);
      outlined destroy of PgQuery_Alias(v26, type metadata accessor for PgQuery_A_Const);
      outlined destroy of PgQuery_Alias((uint64_t)v33, type metadata accessor for PgQuery_String);
      outlined init with take of Aggregation(&v51, v45);
      return outlined destroy of (key: String, value: StorableValue)(v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    outlined destroy of PgQuery_Alias(v32, type metadata accessor for PgQuery_Node.OneOf_Node);
    v27 = *(_QWORD *)(v26 + v42);
  }
  outlined init with copy of PgQuery_Alias?(v27 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_A_ConstP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, (uint64_t)v16, &demangling cache variable for type metadata for PgQuery_Node?);
  if (v28(v16, 1, Node) == 1)
  {
    UnknownStorage.init()();
    v38 = *(int *)(Node + 20);
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)&v23[v38] = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v16, &demangling cache variable for type metadata for PgQuery_Node?);
  }
  else
  {
    outlined init with take of PgQuery_OidList((uint64_t)v16, (uint64_t)v23, type metadata accessor for PgQuery_Node);
  }
  v39 = v49;
  v40 = v54;
  buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(&v51, v23, v46, v48, v47, v49);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_Alias(v39, type metadata accessor for SQLTokenInformation);
  outlined destroy of PgQuery_Alias(v26, type metadata accessor for PgQuery_A_Const);
  outlined destroy of PgQuery_Alias((uint64_t)v23, type metadata accessor for PgQuery_Node);
  if (!v40)
    outlined init with take of Aggregation(&v51, v45);
  return outlined destroy of (key: String, value: StorableValue)(v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionConst()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionColumnRef()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t SQLExpressionAExpr.init(expr:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t Node;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t (*v33)(char *, uint64_t, uint64_t);
  uint64_t v34;
  _OWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t result;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t *v71;
  int EnumCaseMultiPayload;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  char v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t String;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  __int128 v110[3];
  uint64_t v111;

  v104 = a3;
  v108 = a4;
  v109 = a5;
  v107 = a2;
  v103 = a6;
  v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v8 = MEMORY[0x1E0C80A78](v7);
  v94 = (uint64_t)&v90 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v8);
  v93 = (uint64_t)&v90 - v10;
  String = type metadata accessor for PgQuery_String(0);
  v11 = MEMORY[0x1E0C80A78](String);
  v92 = (uint64_t *)((char *)&v90 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v11);
  v91 = (uint64_t *)((char *)&v90 - v13);
  Node = type metadata accessor for PgQuery_Node(0);
  v15 = *(_QWORD *)(Node - 8);
  v16 = MEMORY[0x1E0C80A78](Node);
  v98 = (uint64_t)&v90 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v18 = MEMORY[0x1E0C80A78](v16);
  v97 = (uint64_t)&v90 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v101 = (uint64_t)&v90 - v21;
  MEMORY[0x1E0C80A78](v20);
  v100 = (uint64_t)&v90 - v22;
  v23 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  v24 = MEMORY[0x1E0C80A78](v23);
  v106 = (uint64_t)&v90 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  v26 = MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v90 - v27;
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v90 - v29;
  v31 = *(int *)(type metadata accessor for PgQuery_A_Expr(0) + 20);
  v32 = a1;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)(a1 + v31)+ OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr, (uint64_t)v30, &demangling cache variable for type metadata for PgQuery_Node?);
  v96 = v15;
  v33 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v15 + 48);
  LODWORD(a1) = v33(v30, 1, Node);
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v30, &demangling cache variable for type metadata for PgQuery_Node?);
  v102 = v31;
  if ((_DWORD)a1 == 1)
  {
    v35 = (_OWORD *)v103;
    v34 = v104;
    *(_QWORD *)(v103 + 32) = 0;
    *v35 = 0u;
    v35[1] = 0u;
    v36 = v105;
    v37 = v108;
  }
  else
  {
    v38 = v103;
    v99 = v32;
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v32 + v31)+ OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr, (uint64_t)v28, &demangling cache variable for type metadata for PgQuery_Node?);
    v39 = v33(v28, 1, Node);
    v90 = Node;
    if (v39 == 1)
    {
      v40 = v100;
      UnknownStorage.init()();
      v41 = *(int *)(Node + 20);
      v34 = v104;
      v42 = v105;
      if (one-time initialization token for defaultInstance != -1)
        swift_once();
      v43 = v38;
      *(_QWORD *)(v40 + v41) = static PgQuery_Node._StorageClass.defaultInstance;
      swift_retain();
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v28, &demangling cache variable for type metadata for PgQuery_Node?);
    }
    else
    {
      v40 = v100;
      outlined init with take of PgQuery_OidList((uint64_t)v28, v100, type metadata accessor for PgQuery_Node);
      v34 = v104;
      v42 = v105;
      v43 = v38;
    }
    v32 = v99;
    v37 = v108;
    v44 = v109;
    buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(v110, v40, v107, v34, v108, v109);
    if (v42)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v44, type metadata accessor for SQLTokenInformation);
      outlined destroy of PgQuery_Alias(v32, type metadata accessor for PgQuery_A_Expr);
      return outlined destroy of PgQuery_Alias(v40, type metadata accessor for PgQuery_Node);
    }
    outlined destroy of PgQuery_Alias(v40, type metadata accessor for PgQuery_Node);
    v35 = (_OWORD *)v43;
    outlined init with take of (key: String, value: StorableValue)((uint64_t)v110, v43, &demangling cache variable for type metadata for SQLExpressionNode?);
    Node = v90;
    v36 = 0;
  }
  v46 = v35;
  v47 = v106;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v32 + v102)+ OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr, v106, &demangling cache variable for type metadata for PgQuery_Node?);
  if (v33((char *)v47, 1, Node) == 1)
  {
    v48 = v101;
    UnknownStorage.init()();
    v49 = *(int *)(Node + 20);
    v50 = v107;
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)(v48 + v49) = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of (key: String, value: StorableValue)(v106, &demangling cache variable for type metadata for PgQuery_Node?);
    v37 = v108;
  }
  else
  {
    v51 = v47;
    v48 = v101;
    outlined init with take of PgQuery_OidList(v51, v101, type metadata accessor for PgQuery_Node);
    v50 = v107;
  }
  v52 = v109;
  buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(v110, v48, v50, v34, v37, v109);
  if (v36)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v52, type metadata accessor for SQLTokenInformation);
    outlined destroy of PgQuery_Alias(v32, type metadata accessor for PgQuery_A_Expr);
    outlined destroy of PgQuery_Alias(v48, type metadata accessor for PgQuery_Node);
    return outlined destroy of (key: String, value: StorableValue)((uint64_t)v46, &demangling cache variable for type metadata for SQLExpressionNode?);
  }
  outlined destroy of PgQuery_Alias(v48, type metadata accessor for PgQuery_Node);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  v53 = v46;
  v54 = v46 + 5;
  result = outlined init with take of Aggregation(v110, (uint64_t)(v46 + 5));
  v55 = *(_QWORD *)(v32 + v102);
  if (*(_BYTE *)(v55 + 24) != 1 || (v56 = *(_QWORD *)(v55 + 16), ((1 << v56) & 0x1FDFD) != 0))
  {
    type metadata accessor for SQLExpressionError();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
    swift_allocError();
    outlined init with copy of PgQuery_RawStmt(v32, v57, type metadata accessor for PgQuery_A_Expr);
    swift_storeEnumTagMultiPayload();
    swift_willThrow();
    outlined destroy of PgQuery_Alias(v109, type metadata accessor for SQLTokenInformation);
    outlined destroy of PgQuery_Alias(v32, type metadata accessor for PgQuery_A_Expr);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v46, &demangling cache variable for type metadata for SQLExpressionNode?);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v54);
  }
  v99 = v32;
  if (v56 != 1)
  {
    v65 = *(_QWORD *)(v55 + 32);
    if (!*(_QWORD *)(v65 + 16))
    {
LABEL_51:
      __break(1u);
      return result;
    }
    v66 = v98;
    outlined init with copy of PgQuery_RawStmt(v65 + ((*(unsigned __int8 *)(v96 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v96 + 80)), v98, type metadata accessor for PgQuery_Node);
    v67 = *(_QWORD *)(v66 + *(int *)(Node + 20))
        + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
    v68 = v94;
    outlined init with copy of PgQuery_Alias?(v67, v94, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v69 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v69 - 8) + 48))(v68, 1, v69) == 1)
    {
      outlined destroy of (key: String, value: StorableValue)(v68, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      v70 = v92;
      v64 = v109;
    }
    else
    {
      EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
      v64 = v109;
      if (EnumCaseMultiPayload == 222)
      {
        v70 = v92;
        outlined init with take of PgQuery_OidList(v68, (uint64_t)v92, type metadata accessor for PgQuery_String);
LABEL_37:
        outlined destroy of PgQuery_Alias(v98, type metadata accessor for PgQuery_Node);
        v76 = (uint64_t)v70;
        v78 = *v70;
        v77 = v70[1];
        swift_bridgeObjectRetain();
        outlined destroy of PgQuery_Alias(v76, type metadata accessor for PgQuery_String);
        if (v78 == 8289825 && v77 == 0xE300000000000000)
        {
          v75 = 0x454B494C20544F4ELL;
          swift_bridgeObjectRelease();
          v74 = 0xE800000000000000;
        }
        else
        {
          v79 = _stringCompareWithSmolCheck(_:_:expecting:)();
          swift_bridgeObjectRelease();
          v80 = (v79 & 1) == 0;
          if ((v79 & 1) != 0)
            v75 = 0x454B494C20544F4ELL;
          else
            v75 = 1162561868;
          if (v80)
            v74 = 0xE400000000000000;
          else
            v74 = 0xE800000000000000;
        }
        goto LABEL_46;
      }
      outlined destroy of PgQuery_Alias(v68, type metadata accessor for PgQuery_Node.OneOf_Node);
      v70 = v92;
    }
    *v70 = 0;
    v70[1] = 0xE000000000000000;
    UnknownStorage.init()();
    goto LABEL_37;
  }
  v58 = *(_QWORD *)(v55 + 32);
  if (!*(_QWORD *)(v58 + 16))
  {
    __break(1u);
    goto LABEL_51;
  }
  v59 = v97;
  outlined init with copy of PgQuery_RawStmt(v58 + ((*(unsigned __int8 *)(v96 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v96 + 80)), v97, type metadata accessor for PgQuery_Node);
  v60 = *(_QWORD *)(v59 + *(int *)(Node + 20))
      + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
  v61 = v93;
  outlined init with copy of PgQuery_Alias?(v60, v93, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v62 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  v63 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v62 - 8) + 48))(v61, 1, v62);
  v64 = v109;
  if (v63 == 1)
  {
    outlined destroy of (key: String, value: StorableValue)(v61, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_33:
    v71 = v91;
    *v91 = 0;
    v71[1] = 0xE000000000000000;
    UnknownStorage.init()();
    goto LABEL_34;
  }
  if (swift_getEnumCaseMultiPayload() != 222)
  {
    outlined destroy of PgQuery_Alias(v61, type metadata accessor for PgQuery_Node.OneOf_Node);
    goto LABEL_33;
  }
  v71 = v91;
  outlined init with take of PgQuery_OidList(v61, (uint64_t)v91, type metadata accessor for PgQuery_String);
LABEL_34:
  outlined destroy of PgQuery_Alias(v97, type metadata accessor for PgQuery_Node);
  v73 = (uint64_t)v71;
  v75 = *v71;
  v74 = v71[1];
  swift_bridgeObjectRetain();
  outlined destroy of PgQuery_Alias(v73, type metadata accessor for PgQuery_String);
LABEL_46:
  v46[10] = v75;
  v46[11] = v74;
  v81 = v46[3];
  if (v81)
  {
    v82 = v46[4];
    v83 = __swift_project_boxed_opaque_existential_1(v53, v53[3]);
    v84 = *(_QWORD *)(v81 - 8);
    MEMORY[0x1E0C80A78](v83);
    v86 = (char *)&v90 - ((v85 + 15) & 0xFFFFFFFFFFFFFFF0);
    (*(void (**)(char *))(v84 + 16))(v86);
    (*(void (**)(char *__return_ptr, uint64_t, uint64_t))(v82 + 16))((char *)&v111 + 1, v81, v82);
    (*(void (**)(char *, uint64_t))(v84 + 8))(v86, v81);
    v87 = BYTE1(v111);
    v64 = v109;
  }
  else
  {
    v87 = 8;
  }
  BYTE1(v111) = v87;
  v88 = v53[8];
  v89 = v53[9];
  __swift_project_boxed_opaque_existential_1(v54, v88);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v89 + 16))(&v111, v88, v89);
  swift_bridgeObjectRetain();
  static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:)((uint64_t)&v111 + 1);
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_Alias(v64, type metadata accessor for SQLTokenInformation);
  result = outlined destroy of PgQuery_Alias(v99, type metadata accessor for PgQuery_A_Expr);
  *((_BYTE *)v53 + 96) = v110[0];
  return result;
}

void static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:)(uint64_t a1)
{
  __asm { BR              X9 }
}

uint64_t sub_18DB1FCEC()
{
  _BYTE *v0;
  char v2;
  uint64_t result;

  v2 = _stringCompareWithSmolCheck(_:_:expecting:)();
  result = swift_bridgeObjectRelease();
  if ((v2 & 1) == 0)
    __asm { BR              X9 }
  *v0 = 7;
  return result;
}

uint64_t sub_18DB20150()
{
  uint64_t v0;
  char v1;

  v1 = _stringCompareWithSmolCheck(_:_:expecting:)(0x676E69727473, 0xE600000000000000, 1702125924, 0xE400000000000000, 0);
  swift_bridgeObjectRelease(0xE600000000000000);
  if ((v1 & 1) != 0)
    JUMPOUT(0x18DB2026CLL);
  return ((uint64_t (*)(uint64_t))((char *)sub_18DB201E4 + 4 * byte_18DC2BE7D[v0]))(0x72656765746E69);
}

uint64_t sub_18DB20164()
{
  uint64_t v0;
  char v1;

  v1 = _stringCompareWithSmolCheck(_:_:expecting:)(1635017060, 0xE400000000000000, 1702125924, 0xE400000000000000, 0);
  swift_bridgeObjectRelease(0xE400000000000000);
  if ((v1 & 1) != 0)
    JUMPOUT(0x18DB2026CLL);
  return ((uint64_t (*)(uint64_t))((char *)sub_18DB201E4 + 4 * byte_18DC2BE7D[v0]))(0x72656765746E69);
}

uint64_t sub_18DB20174()
{
  uint64_t v0;
  char v1;

  v1 = _stringCompareWithSmolCheck(_:_:expecting:)(1852797802, 0xE400000000000000, 1702125924, 0xE400000000000000, 0);
  swift_bridgeObjectRelease(0xE400000000000000);
  if ((v1 & 1) != 0)
    JUMPOUT(0x18DB2026CLL);
  return ((uint64_t (*)(uint64_t))((char *)sub_18DB201E4 + 4 * byte_18DC2BE7D[v0]))(0x72656765746E69);
}

void sub_18DB20184()
{
  JUMPOUT(0x18DB20190);
}

uint64_t sub_18DB201E4()
{
  uint64_t v0;
  char v1;

  v1 = _stringCompareWithSmolCheck(_:_:expecting:)();
  swift_bridgeObjectRelease();
  if ((v1 & 1) != 0)
    JUMPOUT(0x18DB20020);
  return ((uint64_t (*)(uint64_t))((char *)sub_18DB20298 + 4 * byte_18DC2BE84[v0]))(1702125924);
}

uint64_t sub_18DB20298()
{
  uint64_t v0;
  char v1;
  uint64_t v2;

  v1 = _stringCompareWithSmolCheck(_:_:expecting:)();
  v2 = swift_bridgeObjectRelease();
  if ((v1 & 1) != 0)
    JUMPOUT(0x18DB20020);
  return ((uint64_t (*)(uint64_t))((char *)&loc_18DB20338 + 4 * byte_18DC2BE8C[v0]))(v2);
}

uint64_t specialized Sequence<>.contains(_:)(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v9;
  uint64_t i;
  uint64_t v11;
  BOOL v12;

  v3 = a3[2];
  if (!v3)
    return 0;
  if (a3[4] == a1 && a3[5] == a2)
    return 1;
  result = _stringCompareWithSmolCheck(_:_:expecting:)();
  if ((result & 1) != 0)
    return 1;
  if (v3 == 1)
    return 0;
  v9 = a3 + 7;
  for (i = 1; ; ++i)
  {
    v11 = i + 1;
    if (__OFADD__(i, 1))
      break;
    v12 = *(v9 - 1) == a1 && *v9 == a2;
    if (v12 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
      return 1;
    result = 0;
    v9 += 2;
    if (v11 == v3)
      return result;
  }
  __break(1u);
  return result;
}

uint64_t specialized Sequence<>.contains(_:)(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 16))
  {
    swift_bridgeObjectRetain();
    __asm { BR              X9 }
  }
  return 0;
}

uint64_t SQLExpressionAExpr.expressionString.getter()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  Swift::String v11;
  Swift::String v12;
  void *v13;
  uint64_t v14;
  Swift::String v15;
  Swift::String v16;
  Swift::String v17;
  Swift::String v18;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v1 = v0[8];
  v2 = v0[9];
  __swift_project_boxed_opaque_existential_1(v0 + 5, v1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
  v5 = v4;
  outlined init with copy of PgQuery_Alias?((uint64_t)v0, (uint64_t)&v20, &demangling cache variable for type metadata for SQLExpressionNode?);
  v6 = v22;
  if (v22)
  {
    v7 = v23;
    __swift_project_boxed_opaque_existential_1(&v20, v22);
    v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
    v10 = v9;
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v20);
    v20 = 40;
    v21 = 0xE100000000000000;
    v11._countAndFlagsBits = v8;
    v11._object = v10;
    String.append(_:)(v11);
    swift_bridgeObjectRelease();
    v12._countAndFlagsBits = 32;
    v12._object = (void *)0xE100000000000000;
    String.append(_:)(v12);
  }
  else
  {
    outlined destroy of (key: String, value: StorableValue)((uint64_t)&v20, &demangling cache variable for type metadata for SQLExpressionNode?);
    v20 = 40;
    v21 = 0xE100000000000000;
  }
  v14 = v0[10];
  v13 = (void *)v0[11];
  swift_bridgeObjectRetain();
  v15._countAndFlagsBits = v14;
  v15._object = v13;
  String.append(_:)(v15);
  swift_bridgeObjectRelease();
  v16._countAndFlagsBits = 32;
  v16._object = (void *)0xE100000000000000;
  String.append(_:)(v16);
  v17._countAndFlagsBits = v3;
  v17._object = v5;
  String.append(_:)(v17);
  swift_bridgeObjectRelease();
  v18._countAndFlagsBits = 41;
  v18._object = (void *)0xE100000000000000;
  String.append(_:)(v18);
  return v20;
}

uint64_t SQLExpressionAExpr.aggregationFunctions.getter()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;
  uint64_t v10;

  outlined init with copy of PgQuery_Alias?((uint64_t)v0, (uint64_t)v8, &demangling cache variable for type metadata for SQLExpressionNode?);
  v1 = v9;
  if (v9)
  {
    v2 = v10;
    __swift_project_boxed_opaque_existential_1(v8, v9);
    v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 24))(v1, v2);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v8);
  }
  else
  {
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v8, &demangling cache variable for type metadata for SQLExpressionNode?);
    v3 = MEMORY[0x1E0DEE9D8];
  }
  v5 = v0[8];
  v4 = v0[9];
  __swift_project_boxed_opaque_existential_1(v0 + 5, v5);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 24))(v5, v4);
  v8[0] = v3;
  specialized Array.append<A>(contentsOf:)(v6);
  return v8[0];
}

uint64_t SQLExpressionAExpr.bindings.getter()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;
  uint64_t v10;

  outlined init with copy of PgQuery_Alias?((uint64_t)v0, (uint64_t)v8, &demangling cache variable for type metadata for SQLExpressionNode?);
  v1 = v9;
  if (v9)
  {
    v2 = v10;
    __swift_project_boxed_opaque_existential_1(v8, v9);
    v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 32))(v1, v2);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v8);
  }
  else
  {
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v8, &demangling cache variable for type metadata for SQLExpressionNode?);
    v3 = MEMORY[0x1E0DEE9D8];
  }
  v5 = v0[8];
  v4 = v0[9];
  __swift_project_boxed_opaque_existential_1(v0 + 5, v5);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 32))(v5, v4);
  v8[0] = v3;
  specialized Array.append<A>(contentsOf:)(v6);
  return v8[0];
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionAExpr(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 96);
}

uint64_t SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v11;
  uint64_t v12;
  uint64_t NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[8];

  v11 = *(int *)(type metadata accessor for PgQuery_BoolExpr(0) + 20);
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + v11)
                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  v17[2] = a2;
  v17[3] = a3;
  v17[4] = a4;
  v17[5] = a5;
  swift_bridgeObjectRetain();
  NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5((void (*)(__int128 *__return_ptr, uint64_t, uint64_t *))partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:), (uint64_t)v17, v12);
  if (v5)
  {
    outlined destroy of PgQuery_Alias(a1, type metadata accessor for PgQuery_BoolExpr);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return outlined destroy of PgQuery_Alias(a5, type metadata accessor for SQLTokenInformation);
  }
  else
  {
    v17[7] = NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    v15 = *(_QWORD *)(a1 + v11)
        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLop;
    if (*(_BYTE *)(v15 + 8) == 1)
      __asm { BR              X9 }
    type metadata accessor for SQLExpressionError();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
    swift_allocError();
    outlined init with copy of PgQuery_RawStmt(a1, v16, type metadata accessor for PgQuery_BoolExpr);
    swift_storeEnumTagMultiPayload();
    swift_willThrow();
    outlined destroy of PgQuery_Alias(a1, type metadata accessor for PgQuery_BoolExpr);
    outlined destroy of PgQuery_Alias(a5, type metadata accessor for SQLTokenInformation);
    return swift_bridgeObjectRelease();
  }
}

uint64_t SQLExpressioBoolExpr.expressionString.getter()
{
  uint64_t v0;

  if (*(_BYTE *)(v0 + 16) == 1)
    __asm { BR              X9 }
  return 0;
}

uint64_t SQLExpressioBoolExpr.aggregationFunctions.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  _QWORD v13[3];
  uint64_t v14;
  uint64_t v15;

  v1 = *(_QWORD *)(*(_QWORD *)v0 + 16);
  if (!v1)
    return MEMORY[0x1E0DEE9D8];
  v2 = *(_QWORD *)v0 + 32;
  swift_bridgeObjectRetain_n();
  v3 = MEMORY[0x1E0DEE9D8];
  while (1)
  {
    outlined init with copy of Aggregation(v2, (uint64_t)v13);
    v4 = v14;
    v5 = v15;
    __swift_project_boxed_opaque_existential_1(v13, v14);
    v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 24))(v4, v5);
    result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v13);
    v8 = *(_QWORD *)(v6 + 16);
    v9 = *(_QWORD *)(v3 + 16);
    if (__OFADD__(v9, v8))
      break;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((_DWORD)result && v9 + v8 <= *(_QWORD *)(v3 + 24) >> 1)
    {
      if (*(_QWORD *)(v6 + 16))
        goto LABEL_11;
    }
    else
    {
      result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)();
      v3 = result;
      if (*(_QWORD *)(v6 + 16))
      {
LABEL_11:
        if ((*(_QWORD *)(v3 + 24) >> 1) - *(_QWORD *)(v3 + 16) < v8)
          goto LABEL_20;
        result = swift_arrayInitWithCopy();
        if (v8)
        {
          v10 = *(_QWORD *)(v3 + 16);
          v11 = __OFADD__(v10, v8);
          v12 = v10 + v8;
          if (v11)
            goto LABEL_21;
          *(_QWORD *)(v3 + 16) = v12;
        }
        goto LABEL_4;
      }
    }
    if (v8)
      goto LABEL_19;
LABEL_4:
    swift_bridgeObjectRelease();
    v2 += 40;
    if (!--v1)
    {
      swift_bridgeObjectRelease_n();
      return v3;
    }
  }
  __break(1u);
LABEL_19:
  __break(1u);
LABEL_20:
  __break(1u);
LABEL_21:
  __break(1u);
  return result;
}

char *SQLExpressioBoolExpr.bindings.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *result;
  uint64_t v8;
  int64_t v9;
  int64_t v10;
  int64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  _QWORD v15[3];
  uint64_t v16;
  uint64_t v17;

  v1 = *(_QWORD *)(*(_QWORD *)v0 + 16);
  if (!v1)
    return (char *)MEMORY[0x1E0DEE9D8];
  v2 = *(_QWORD *)v0 + 32;
  swift_bridgeObjectRetain_n();
  v3 = (char *)MEMORY[0x1E0DEE9D8];
  while (1)
  {
    outlined init with copy of Aggregation(v2, (uint64_t)v15);
    v4 = v16;
    v5 = v17;
    __swift_project_boxed_opaque_existential_1(v15, v16);
    v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 32))(v4, v5);
    result = (char *)__swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v15);
    v8 = *(_QWORD *)(v6 + 16);
    v9 = *((_QWORD *)v3 + 2);
    v10 = v9 + v8;
    if (__OFADD__(v9, v8))
      break;
    result = (char *)swift_isUniquelyReferenced_nonNull_native();
    if ((_DWORD)result && v10 <= *((_QWORD *)v3 + 3) >> 1)
    {
      if (*(_QWORD *)(v6 + 16))
        goto LABEL_14;
    }
    else
    {
      if (v9 <= v10)
        v11 = v9 + v8;
      else
        v11 = v9;
      result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(result, v11, 1, v3);
      v3 = result;
      if (*(_QWORD *)(v6 + 16))
      {
LABEL_14:
        if ((*((_QWORD *)v3 + 3) >> 1) - *((_QWORD *)v3 + 2) < v8)
          goto LABEL_23;
        result = (char *)swift_arrayInitWithCopy();
        if (v8)
        {
          v12 = *((_QWORD *)v3 + 2);
          v13 = __OFADD__(v12, v8);
          v14 = v12 + v8;
          if (v13)
            goto LABEL_24;
          *((_QWORD *)v3 + 2) = v14;
        }
        goto LABEL_4;
      }
    }
    if (v8)
      goto LABEL_22;
LABEL_4:
    swift_bridgeObjectRelease();
    v2 += 40;
    if (!--v1)
    {
      swift_bridgeObjectRelease_n();
      return v3;
    }
  }
  __break(1u);
LABEL_22:
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressioBoolExpr(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 17);
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressioBoolExpr()
{
  uint64_t v0;

  return specialized SQLExpressionNode.sql()(*(_QWORD *)v0, *(_QWORD *)(v0 + 8), *(_BYTE *)(v0 + 16));
}

uint64_t SQLExpressionNullTest.init(nullTest:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t Node;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32[2];
  uint64_t v33;

  v30 = a3;
  v31 = a5;
  v10 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1E0C80A78](v10);
  v12 = (char *)&v27 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  v14 = *(_QWORD *)(Node - 8);
  MEMORY[0x1E0C80A78](Node);
  v16 = (char *)&v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v28 = a6;
  *(_BYTE *)(a6 + 49) = 0;
  v17 = *(int *)(type metadata accessor for PgQuery_NullTest(0) + 20);
  v33 = a1;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)(a1 + v17)+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, (uint64_t)v12, &demangling cache variable for type metadata for PgQuery_Node?);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v12, 1, Node) == 1)
  {
    UnknownStorage.init()();
    v18 = *(int *)(Node + 20);
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)&v16[v18] = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v12, &demangling cache variable for type metadata for PgQuery_Node?);
  }
  else
  {
    outlined init with take of PgQuery_OidList((uint64_t)v12, (uint64_t)v16, type metadata accessor for PgQuery_Node);
  }
  v19 = v31;
  v20 = v29;
  buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(v32, v16, a2, v30, a4, v31);
  if (v20)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v19, type metadata accessor for SQLTokenInformation);
    outlined destroy of PgQuery_Alias(v33, type metadata accessor for PgQuery_NullTest);
    return outlined destroy of PgQuery_Alias((uint64_t)v16, type metadata accessor for PgQuery_Node);
  }
  else
  {
    outlined destroy of PgQuery_Alias((uint64_t)v16, type metadata accessor for PgQuery_Node);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    v22 = v28;
    outlined init with take of Aggregation(v32, v28);
    v23 = v33;
    v24 = *(_QWORD *)(v33 + v17)
        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nulltesttype;
    if (*(_BYTE *)(v24 + 8) == 1 && (v25 = *(_QWORD *)v24) != 0)
    {
      outlined destroy of PgQuery_Alias(v19, type metadata accessor for SQLTokenInformation);
      result = outlined destroy of PgQuery_Alias(v23, type metadata accessor for PgQuery_NullTest);
      *(_QWORD *)(v22 + 40) = v25;
      *(_BYTE *)(v22 + 48) = 1;
    }
    else
    {
      type metadata accessor for SQLExpressionError();
      lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
      swift_allocError();
      outlined init with copy of PgQuery_RawStmt(v23, v26, type metadata accessor for PgQuery_NullTest);
      swift_storeEnumTagMultiPayload();
      swift_willThrow();
      outlined destroy of PgQuery_Alias(v19, type metadata accessor for SQLTokenInformation);
      outlined destroy of PgQuery_Alias(v23, type metadata accessor for PgQuery_NullTest);
      return __swift_destroy_boxed_opaque_existential_1Tm(v22);
    }
  }
  return result;
}

uint64_t SQLExpressionNullTest.expressionString.getter()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  Swift::String v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  Swift::String v9;

  if (*(_BYTE *)(v0 + 48) != 1)
    return 0;
  result = *(_QWORD *)(v0 + 40);
  if (result)
  {
    if (result == 1)
    {
      v2 = *(_QWORD *)(v0 + 24);
      v3 = *(_QWORD *)(v0 + 32);
      __swift_project_boxed_opaque_existential_1((_QWORD *)v0, v2);
      v4._countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8))(v2, v3);
      String.append(_:)(v4);
      swift_bridgeObjectRelease();
      v5 = 0x4C4C554E20534920;
      v6 = 0xE900000000000029;
    }
    else
    {
      _StringGuts.grow(_:)(16);
      swift_bridgeObjectRelease();
      v7 = *(_QWORD *)(v0 + 24);
      v8 = *(_QWORD *)(v0 + 32);
      __swift_project_boxed_opaque_existential_1((_QWORD *)v0, v7);
      v9._countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
      String.append(_:)(v9);
      swift_bridgeObjectRelease();
      v5 = 0x20544F4E20534920;
      v6 = 0xED0000294C4C554ELL;
    }
    String.append(_:)(*(Swift::String *)&v5);
    return 40;
  }
  return result;
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionNullTest(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 49);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionNullTest()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;

  v1 = v0[3];
  v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 24))(v1, v2);
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionNullTest()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;

  v1 = v0[3];
  v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 32))(v1, v2);
}

uint64_t protocol witness for SQLExpressionNode.expressionString.getter in conformance SQLExpressionAggregationFunction()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 200);
  swift_bridgeObjectRetain();
  return v1;
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionAggregationFunction(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 193);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionAggregationFunction()
{
  uint64_t v0;
  uint64_t v1;

  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<AggregationFunction>);
  v1 = swift_allocObject();
  *(_OWORD *)(v1 + 16) = xmmword_18DC0CE20;
  outlined init with copy of AggregationFunction(v0, v1 + 32);
  return v1;
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionAggregationFunction()
{
  uint64_t v0;
  uint64_t v1;
  Swift::String v2;
  char v3;

  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
  v1 = swift_allocObject();
  *(_OWORD *)(v1 + 16) = xmmword_18DC0CE20;
  v2 = AggregationFunction.name()();
  v3 = *(_BYTE *)(v0 + 193);
  *(Swift::String *)(v1 + 32) = v2;
  *(_BYTE *)(v1 + 48) = v3;
  return v1;
}

uint64_t SQLExpressionNonAggregationFunction.init(functionName:argList:)@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  Swift::String v8;
  char v9;
  uint64_t *v10;
  int64_t v12;
  uint64_t v13;
  Swift::OpaquePointer v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  _QWORD v23[3];
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;

  swift_bridgeObjectRetain();
  v8._countAndFlagsBits = a1;
  v8._object = a2;
  SQLFunction.init(rawValue:)(v8);
  v9 = v23[0];
  if (LOBYTE(v23[0]) == 98)
  {
    swift_bridgeObjectRelease();
    type metadata accessor for SQLExpressionError();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
    swift_allocError();
    *v10 = a1;
    v10[1] = (uint64_t)a2;
    swift_storeEnumTagMultiPayload();
    return swift_willThrow();
  }
  else
  {
    swift_bridgeObjectRelease();
    BYTE1(v27) = v23[0];
    v12 = *(_QWORD *)(a3 + 16);
    if (v12)
    {
      v22 = a4;
      v26 = (void *)MEMORY[0x1E0DEE9D8];
      swift_bridgeObjectRetain_n();
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v12, 0);
      v13 = a3 + 32;
      v14._rawValue = v26;
      do
      {
        outlined init with copy of Aggregation(v13, (uint64_t)v23);
        v15 = v24;
        v16 = v25;
        __swift_project_boxed_opaque_existential_1(v23, v24);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v16 + 16))(&v27, v15, v16);
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v23);
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((_QWORD *)v14._rawValue + 2) + 1, 1);
          v14._rawValue = v26;
        }
        v18 = *((_QWORD *)v14._rawValue + 2);
        v17 = *((_QWORD *)v14._rawValue + 3);
        if (v18 >= v17 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v17 > 1), v18 + 1, 1);
          v14._rawValue = v26;
        }
        v19 = v27;
        *((_QWORD *)v14._rawValue + 2) = v18 + 1;
        *((_BYTE *)v14._rawValue + v18 + 32) = v19;
        v13 += 40;
        --v12;
      }
      while (v12);
      swift_bridgeObjectRelease();
      a4 = v22;
    }
    else
    {
      swift_bridgeObjectRetain();
      v14._rawValue = (void *)MEMORY[0x1E0DEE9D8];
    }
    SQLFunction.returnType(argTypes:)(v14);
    swift_bridgeObjectRelease();
    if (v20)
    {
      swift_bridgeObjectRelease();
    }
    else
    {
      v21 = BYTE2(v27);
      *(_BYTE *)a4 = v9;
      *(_QWORD *)(a4 + 8) = a3;
      *(_BYTE *)(a4 + 16) = v21;
    }
    return swift_bridgeObjectRelease();
  }
}

uint64_t SQLExpressionNonAggregationFunction.expressionString.getter()
{
  char *v0;
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  Swift::String v18;
  Swift::String v19;
  Swift::String v20;
  _QWORD v22[3];
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v1 = *v0;
  v2 = *((_QWORD *)v0 + 1);
  v3 = *(_QWORD *)(v2 + 16);
  v4 = MEMORY[0x1E0DEE9D8];
  if (v3)
  {
    v25 = MEMORY[0x1E0DEE9D8];
    swift_bridgeObjectRetain();
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v3, 0);
    v5 = v2 + 32;
    v4 = v25;
    do
    {
      outlined init with copy of Aggregation(v5, (uint64_t)v22);
      v6 = v23;
      v7 = v24;
      __swift_project_boxed_opaque_existential_1(v22, v23);
      v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
      v10 = v9;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v22);
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v4 + 16) + 1, 1);
        v4 = v25;
      }
      v12 = *(_QWORD *)(v4 + 16);
      v11 = *(_QWORD *)(v4 + 24);
      if (v12 >= v11 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v11 > 1, v12 + 1, 1);
        v4 = v25;
      }
      *(_QWORD *)(v4 + 16) = v12 + 1;
      v13 = v4 + 16 * v12;
      *(_QWORD *)(v13 + 32) = v8;
      *(_QWORD *)(v13 + 40) = v10;
      v5 += 40;
      --v3;
    }
    while (v3);
    swift_bridgeObjectRelease();
  }
  v22[0] = v4;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  v14 = BidirectionalCollection<>.joined(separator:)();
  v16 = v15;
  swift_bridgeObjectRelease();
  LOBYTE(v22[0]) = v1;
  v22[0] = SQLFunction.rawValue.getter();
  v22[1] = v17;
  v18._countAndFlagsBits = 40;
  v18._object = (void *)0xE100000000000000;
  String.append(_:)(v18);
  v19._countAndFlagsBits = v14;
  v19._object = v16;
  String.append(_:)(v19);
  swift_bridgeObjectRelease();
  v20._countAndFlagsBits = 41;
  v20._object = (void *)0xE100000000000000;
  String.append(_:)(v20);
  return v22[0];
}

uint64_t SQLExpressionNonAggregationFunction.aggregationFunctions.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  _QWORD v14[3];
  uint64_t v15;
  uint64_t v16;

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (!v2)
    return MEMORY[0x1E0DEE9D8];
  v3 = v1 + 32;
  swift_bridgeObjectRetain_n();
  v4 = MEMORY[0x1E0DEE9D8];
  while (1)
  {
    outlined init with copy of Aggregation(v3, (uint64_t)v14);
    v5 = v15;
    v6 = v16;
    __swift_project_boxed_opaque_existential_1(v14, v15);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 24))(v5, v6);
    v8 = *(_QWORD *)(result + 16);
    v9 = *(_QWORD *)(v4 + 16);
    if (__OFADD__(v9, v8))
      break;
    v10 = result;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((_DWORD)result && v9 + v8 <= *(_QWORD *)(v4 + 24) >> 1)
    {
      if (*(_QWORD *)(v10 + 16))
        goto LABEL_11;
    }
    else
    {
      result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)();
      v4 = result;
      if (*(_QWORD *)(v10 + 16))
      {
LABEL_11:
        if ((*(_QWORD *)(v4 + 24) >> 1) - *(_QWORD *)(v4 + 16) < v8)
          goto LABEL_20;
        result = swift_arrayInitWithCopy();
        if (v8)
        {
          v11 = *(_QWORD *)(v4 + 16);
          v12 = __OFADD__(v11, v8);
          v13 = v11 + v8;
          if (v12)
            goto LABEL_21;
          *(_QWORD *)(v4 + 16) = v13;
        }
        goto LABEL_4;
      }
    }
    if (v8)
      goto LABEL_19;
LABEL_4:
    swift_bridgeObjectRelease();
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v14);
    v3 += 40;
    if (!--v2)
    {
      swift_bridgeObjectRelease_n();
      return v4;
    }
  }
  __break(1u);
LABEL_19:
  __break(1u);
LABEL_20:
  __break(1u);
LABEL_21:
  __break(1u);
  return result;
}

uint64_t SQLExpressionNonAggregationFunction.bindings.getter()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  int64_t v9;
  int64_t v10;
  uint64_t v11;
  int64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  _QWORD v16[3];
  uint64_t v17;
  uint64_t v18;

  v1 = *(_QWORD *)(v0 + 8);
  v2 = *(_QWORD *)(v1 + 16);
  if (!v2)
    return MEMORY[0x1E0DEE9D8];
  v3 = v1 + 32;
  swift_bridgeObjectRetain_n();
  v4 = MEMORY[0x1E0DEE9D8];
  while (1)
  {
    outlined init with copy of Aggregation(v3, (uint64_t)v16);
    v5 = v17;
    v6 = v18;
    __swift_project_boxed_opaque_existential_1(v16, v17);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 32))(v5, v6);
    v8 = *(_QWORD *)(result + 16);
    v9 = *(_QWORD *)(v4 + 16);
    v10 = v9 + v8;
    if (__OFADD__(v9, v8))
      break;
    v11 = result;
    result = swift_isUniquelyReferenced_nonNull_native();
    if ((_DWORD)result && v10 <= *(_QWORD *)(v4 + 24) >> 1)
    {
      if (*(_QWORD *)(v11 + 16))
        goto LABEL_14;
    }
    else
    {
      if (v9 <= v10)
        v12 = v9 + v8;
      else
        v12 = v9;
      result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v12, 1, (char *)v4);
      v4 = result;
      if (*(_QWORD *)(v11 + 16))
      {
LABEL_14:
        if ((*(_QWORD *)(v4 + 24) >> 1) - *(_QWORD *)(v4 + 16) < v8)
          goto LABEL_23;
        result = swift_arrayInitWithCopy();
        if (v8)
        {
          v13 = *(_QWORD *)(v4 + 16);
          v14 = __OFADD__(v13, v8);
          v15 = v13 + v8;
          if (v14)
            goto LABEL_24;
          *(_QWORD *)(v4 + 16) = v15;
        }
        goto LABEL_4;
      }
    }
    if (v8)
      goto LABEL_22;
LABEL_4:
    swift_bridgeObjectRelease();
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v16);
    v3 += 40;
    if (!--v2)
    {
      swift_bridgeObjectRelease_n();
      return v4;
    }
  }
  __break(1u);
LABEL_22:
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionNonAggregationFunction()
{
  uint64_t v0;

  return specialized SQLExpressionNode.sql()(*(_BYTE *)v0, *(_QWORD *)(v0 + 8));
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.AggregationType.AVGCodingKeys()
{
  return 0x6973736572707865;
}

void protocol witness for CodingKey.init(intValue:) in conformance AggregationFunction.AggregationType.AVGCodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 1;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.AVGCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.AVGCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.COUNTCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.COUNTCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys@<X0>(_BYTE *a1@<X8>)
{
  uint64_t result;

  result = swift_bridgeObjectRelease();
  *a1 = 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys();
  return CodingKey.debugDescription.getter();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLExpression.CodingKeys()
{
  unsigned __int8 *v0;
  Swift::UInt v1;

  v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.AggregationType.CodingKeys()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_18DB2220C + 4 * byte_18DC2BEB8[*v0]))(4675137, 0xE300000000000000);
}

uint64_t sub_18DB2220C()
{
  return 0x544E554F43;
}

uint64_t sub_18DB22220()
{
  return 0x54535F544E554F43;
}

uint64_t sub_18DB2223C()
{
  return 0x4F435F50554F5247;
}

uint64_t sub_18DB2225C()
{
  return 5783885;
}

uint64_t sub_18DB22268()
{
  return 5130573;
}

uint64_t sub_18DB22274()
{
  return 5068115;
}

uint64_t sub_18DB22280()
{
  return 0x4C41544F54;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized AggregationFunction.AggregationType.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance AggregationFunction.AggregationType.CodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 8;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.CodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.CodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys();
  return CodingKey.debugDescription.getter();
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  _BYTE *v0;

  if (*v0)
    return 0x6F74617261706573;
  else
    return 0x6973736572707865;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized AggregationFunction.AggregationType.GROUP_CONCATCodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.MAXCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.MAXCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.MINCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.MINCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.SUMCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.SUMCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.AVGCodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v5;
  uint64_t result;
  char v7;

  if (a1 == 0x6973736572707865 && a2 == 0xEA00000000006E6FLL)
  {
    result = swift_bridgeObjectRelease();
    v7 = 0;
  }
  else
  {
    v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    result = swift_bridgeObjectRelease();
    v7 = v5 ^ 1;
  }
  *a3 = v7 & 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.TOTALCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.TOTALCodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys();
  return CodingKey.debugDescription.getter();
}

void AggregationFunction.AggregationType.encode(to:)(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  _QWORD v12[7];
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE v30[216];
  uint64_t v31;

  v21 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.TOTALCodingKeys>);
  v26 = *(_QWORD *)(v21 - 8);
  MEMORY[0x1E0C80A78](v21);
  v20 = (char *)v12 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.SUMCodingKeys>);
  v25 = *(_QWORD *)(v19 - 8);
  MEMORY[0x1E0C80A78](v19);
  v18 = (char *)v12 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.MINCodingKeys>);
  v24 = *(_QWORD *)(v16 - 8);
  MEMORY[0x1E0C80A78](v16);
  v14 = (char *)v12 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.MAXCodingKeys>);
  v22 = *(_QWORD *)(v13 - 8);
  MEMORY[0x1E0C80A78](v13);
  v12[6] = (char *)v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.GROUP_CONCATCodingKeys>);
  v23 = *(_QWORD *)(v17 - 8);
  MEMORY[0x1E0C80A78](v17);
  v15 = (char *)v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.COUNT_STARCodingKeys>);
  v12[2] = *(_QWORD *)(v7 - 8);
  v12[3] = v7;
  MEMORY[0x1E0C80A78](v7);
  v8 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.COUNTCodingKeys>);
  v12[4] = *(_QWORD *)(v8 - 8);
  v12[5] = v8;
  MEMORY[0x1E0C80A78](v8);
  v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.AVGCodingKeys>);
  v12[1] = *(_QWORD *)(v9 - 8);
  MEMORY[0x1E0C80A78](v9);
  v28 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.CodingKeys>);
  v29 = *(_QWORD *)(v28 - 8);
  MEMORY[0x1E0C80A78](v28);
  v11 = (char *)v12 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys();
  v27 = v11;
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  outlined init with copy of AggregationFunction.AggregationType(v31, (uint64_t)v30);
  __asm { BR              X10 }
}

uint64_t sub_18DB228A4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *(_OWORD *)(v0 + 456);
  *(_OWORD *)(v0 + 336) = *(_OWORD *)(v0 + 440);
  *(_OWORD *)(v0 + 352) = v3;
  v4 = *(_OWORD *)(v0 + 488);
  *(_OWORD *)(v0 + 368) = *(_OWORD *)(v0 + 472);
  *(_OWORD *)(v0 + 384) = v4;
  v5 = *(_OWORD *)(v0 + 424);
  *(_OWORD *)(v0 + 304) = *(_OWORD *)(v0 + 408);
  *(_OWORD *)(v0 + 320) = v5;
  *(_BYTE *)(v0 + 208) = 0;
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys();
  v6 = *(_QWORD *)(v0 + 168);
  v7 = *(_QWORD *)(v0 + 176);
  KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
  lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v0 + 8) + 8))(v1, v2);
  outlined destroy of SQLExpression(v0 + 304);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v0 + 192) + 8))(v6, v7);
}

void sub_18DB22DAC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  *(_BYTE *)(v0 + 304) = 2;
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys();
  v2 = *(_QWORD *)(v0 + 168);
  v3 = *(_QWORD *)(v0 + 176);
  KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(v0 + 16) + 8))(v1, *(_QWORD *)(v0 + 24));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v0 + 192) + 8))(v2, v3);
  JUMPOUT(0x18DB22D88);
}

void protocol witness for Encodable.encode(to:) in conformance AggregationFunction.AggregationType(_QWORD *a1)
{
  AggregationFunction.AggregationType.encode(to:)(a1);
}

uint64_t AggregationFunction.init(functionName:args:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _BYTE v119[40];
  _QWORD v120[3];
  uint64_t v121;
  uint64_t v122;
  _QWORD v123[3];
  uint64_t v124;
  uint64_t v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int16 v138;
  uint64_t v139;

  v5 = a2;
  v6 = a1;
  if (a1 == 6780513 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    v8 = *(_QWORD *)(a3 + 16);
    if (v8)
    {
      if (v8 == 1)
      {
        swift_bridgeObjectRelease();
        if (*(_QWORD *)(a3 + 16))
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
          swift_bridgeObjectRelease();
          v9 = v124;
          v10 = v125;
          __swift_project_boxed_opaque_existential_1(v123, v124);
          v11 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v10 + 24))(v9, v10) + 16);
          swift_bridgeObjectRelease();
          if (v11)
          {
LABEL_8:
            v12 = v124;
            v13 = v125;
            __swift_project_boxed_opaque_existential_1(v123, v124);
            v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(v12, v13);
            v16 = v15;
            lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
            swift_allocError();
            *(_QWORD *)v17 = v14;
            *(_QWORD *)(v17 + 8) = v16;
            *(_QWORD *)(v17 + 16) = 0;
            *(_QWORD *)(v17 + 24) = 0;
            *(_BYTE *)(v17 + 32) = 3;
            swift_willThrow();
            return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
          }
          outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v120);
          SQLExpression.init(rootNode:)((uint64_t)v120, (uint64_t)&v126);
          v23 = 256;
          goto LABEL_26;
        }
        __break(1u);
        goto LABEL_102;
      }
      v139 = v6;
      v117 = v5;
      v120[0] = MEMORY[0x1E0DEE9D8];
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v8, 0);
      v24 = a3 + 32;
      v25 = v120[0];
      do
      {
        outlined init with copy of Aggregation(v24, (uint64_t)v123);
        v26 = v124;
        v27 = v125;
        __swift_project_boxed_opaque_existential_1(v123, v124);
        v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v27 + 40))(v26, v27);
        v30 = v29;
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v25 + 16) + 1, 1);
          v25 = v120[0];
        }
        v32 = *(_QWORD *)(v25 + 16);
        v31 = *(_QWORD *)(v25 + 24);
        if (v32 >= v31 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v31 > 1, v32 + 1, 1);
          v25 = v120[0];
        }
        *(_QWORD *)(v25 + 16) = v32 + 1;
        v33 = v25 + 16 * v32;
        *(_QWORD *)(v33 + 32) = v28;
        *(_QWORD *)(v33 + 40) = v30;
        v24 += 40;
        --v8;
      }
      while (v8);
      goto LABEL_59;
    }
LABEL_91:
    swift_bridgeObjectRelease();
    v25 = MEMORY[0x1E0DEE9D8];
    goto LABEL_92;
  }
  if (v6 == 0x746E756F63 && v5 == 0xE500000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    v19 = *(_QWORD *)(a3 + 16);
    if (!v19)
    {
      swift_bridgeObjectRelease();
      result = swift_bridgeObjectRelease();
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      v132 = 0u;
      v133 = 0u;
      v130 = 0u;
      v131 = 0u;
      v128 = 0u;
      v129 = 0u;
      v127 = 0u;
      v126 = 0u;
      v138 = 7;
      goto LABEL_39;
    }
    if (v19 != 1)
    {
      v139 = v6;
      v120[0] = MEMORY[0x1E0DEE9D8];
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v19, 0);
      v50 = a3 + 32;
      v25 = v120[0];
      do
      {
        outlined init with copy of Aggregation(v50, (uint64_t)v123);
        v51 = v124;
        v52 = v125;
        __swift_project_boxed_opaque_existential_1(v123, v124);
        v53 = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 40))(v51, v52);
        v55 = v54;
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v25 + 16) + 1, 1);
          v25 = v120[0];
        }
        v57 = *(_QWORD *)(v25 + 16);
        v56 = *(_QWORD *)(v25 + 24);
        if (v57 >= v56 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v56 > 1, v57 + 1, 1);
          v25 = v120[0];
        }
        *(_QWORD *)(v25 + 16) = v57 + 1;
        v58 = v25 + 16 * v57;
        *(_QWORD *)(v58 + 32) = v53;
        *(_QWORD *)(v58 + 40) = v55;
        v50 += 40;
        --v19;
      }
      while (v19);
      swift_bridgeObjectRelease();
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(_QWORD *)v59 = v139;
      *(_QWORD *)(v59 + 8) = v5;
      goto LABEL_93;
    }
    swift_bridgeObjectRelease();
    if (!*(_QWORD *)(a3 + 16))
    {
      __break(1u);
      JUMPOUT(0x18DB23C74);
    }
    outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
    swift_bridgeObjectRelease();
    v20 = v124;
    v21 = v125;
    __swift_project_boxed_opaque_existential_1(v123, v124);
    v22 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v21 + 24))(v20, v21) + 16);
    swift_bridgeObjectRelease();
    if (v22)
      goto LABEL_8;
    outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v120);
    SQLExpression.init(rootNode:)((uint64_t)v120, (uint64_t)&v126);
    v23 = 1;
LABEL_26:
    v138 = v23;
LABEL_27:
    result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
LABEL_39:
    v42 = v135;
    v43 = v137;
    *(_OWORD *)(a4 + 160) = v136;
    *(_OWORD *)(a4 + 176) = v43;
    v44 = v131;
    v45 = v133;
    v46 = v134;
    *(_OWORD *)(a4 + 96) = v132;
    *(_OWORD *)(a4 + 112) = v45;
    *(_OWORD *)(a4 + 128) = v46;
    *(_OWORD *)(a4 + 144) = v42;
    v47 = v127;
    v48 = v129;
    v49 = v130;
    *(_OWORD *)(a4 + 32) = v128;
    *(_OWORD *)(a4 + 48) = v48;
    *(_WORD *)(a4 + 192) = v138;
    *(_OWORD *)(a4 + 64) = v49;
    *(_OWORD *)(a4 + 80) = v44;
    *(_OWORD *)a4 = v126;
    *(_OWORD *)(a4 + 16) = v47;
    return result;
  }
  if (v6 == 0x6F635F70756F7267 && v5 == 0xEC0000007461636ELL
    || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    v34 = *(_QWORD *)(a3 + 16);
    switch(v34)
    {
      case 0:
        goto LABEL_91;
      case 1:
        swift_bridgeObjectRelease();
        if (*(_QWORD *)(a3 + 16))
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
          swift_bridgeObjectRelease();
          v60 = v124;
          v61 = v125;
          __swift_project_boxed_opaque_existential_1(v123, v124);
          v62 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v61 + 24))(v60, v61) + 16);
          swift_bridgeObjectRelease();
          if (v62)
            goto LABEL_8;
          outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v120);
          SQLExpression.init(rootNode:)((uint64_t)v120, (uint64_t)&v126);
          v132 = 0u;
          v133 = 0u;
          v134 = 0u;
          v135 = 0u;
          v136 = 0u;
          v137 = 0u;
          v23 = 514;
          goto LABEL_26;
        }
        break;
      case 2:
        swift_bridgeObjectRelease();
        v35 = *(_QWORD *)(a3 + 16);
        if (v35)
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
          if (v35 != 1)
          {
            outlined init with copy of Aggregation(a3 + 72, (uint64_t)v120);
            swift_bridgeObjectRelease();
            v36 = v124;
            v37 = v125;
            __swift_project_boxed_opaque_existential_1(v123, v124);
            v38 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v37 + 24))(v36, v37) + 16);
            swift_bridgeObjectRelease();
            if (v38)
            {
              v39 = v124;
              v40 = v125;
              v41 = v123;
            }
            else
            {
              v76 = v121;
              v77 = v122;
              __swift_project_boxed_opaque_existential_1(v120, v121);
              v78 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v77 + 24))(v76, v77) + 16);
              swift_bridgeObjectRelease();
              if (!v78)
              {
                outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v119);
                SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v126);
                outlined init with copy of Aggregation((uint64_t)v120, (uint64_t)v119);
                SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v132);
                v138 = 514;
                __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v120);
                goto LABEL_27;
              }
              v39 = v121;
              v40 = v122;
              v41 = v120;
            }
            __swift_project_boxed_opaque_existential_1(v41, v39);
            v79 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 40))(v39, v40);
            v81 = v80;
            lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
            swift_allocError();
            *(_QWORD *)v82 = v79;
            *(_QWORD *)(v82 + 8) = v81;
            *(_QWORD *)(v82 + 16) = 0;
            *(_QWORD *)(v82 + 24) = 0;
            *(_BYTE *)(v82 + 32) = 3;
            swift_willThrow();
            __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v120);
            return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
          }
        }
        else
        {
          __break(1u);
        }
        __break(1u);
        break;
      default:
        v139 = v6;
        v117 = v5;
        v120[0] = MEMORY[0x1E0DEE9D8];
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v34, 0);
        v63 = a3 + 32;
        v25 = v120[0];
        do
        {
          outlined init with copy of Aggregation(v63, (uint64_t)v123);
          v64 = v124;
          v65 = v125;
          __swift_project_boxed_opaque_existential_1(v123, v124);
          v66 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 40))(v64, v65);
          v68 = v67;
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v25 + 16) + 1, 1);
            v25 = v120[0];
          }
          v70 = *(_QWORD *)(v25 + 16);
          v69 = *(_QWORD *)(v25 + 24);
          if (v70 >= v69 >> 1)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v69 > 1, v70 + 1, 1);
            v25 = v120[0];
          }
          *(_QWORD *)(v25 + 16) = v70 + 1;
          v71 = v25 + 16 * v70;
          *(_QWORD *)(v71 + 32) = v66;
          *(_QWORD *)(v71 + 40) = v68;
          v63 += 40;
          --v34;
        }
        while (v34);
LABEL_59:
        swift_bridgeObjectRelease();
        v5 = v117;
        v6 = v139;
LABEL_92:
        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
        swift_allocError();
        *(_QWORD *)v59 = v6;
        *(_QWORD *)(v59 + 8) = v5;
LABEL_93:
        *(_QWORD *)(v59 + 16) = v25;
        *(_QWORD *)(v59 + 24) = 0;
        *(_BYTE *)(v59 + 32) = 4;
        return swift_willThrow();
    }
    __break(1u);
    JUMPOUT(0x18DB23D98);
  }
  if (v6 == 7889261 && v5 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a3 + 16) == 1)
    {
      outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
      swift_bridgeObjectRelease();
      v72 = v124;
      v73 = v125;
      __swift_project_boxed_opaque_existential_1(v123, v124);
      v74 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v73 + 24))(v72, v73) + 16);
      swift_bridgeObjectRelease();
      if (v74)
        goto LABEL_8;
      outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v120);
      SQLExpression.init(rootNode:)((uint64_t)v120, (uint64_t)&v126);
      v75 = 3;
      goto LABEL_73;
    }
  }
  else
  {
    if ((v6 != 7235949 || v5 != 0xE300000000000000) && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      if (v6 == 7173491 && v5 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
      {
        v88 = *(_QWORD *)(a3 + 16);
        if (!v88)
          goto LABEL_91;
        if (v88 != 1)
        {
          v139 = v6;
          v98 = v5;
          v120[0] = MEMORY[0x1E0DEE9D8];
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v88, 0);
          v99 = a3 + 32;
          v25 = v120[0];
          do
          {
            outlined init with copy of Aggregation(v99, (uint64_t)v123);
            v100 = v124;
            v101 = v125;
            __swift_project_boxed_opaque_existential_1(v123, v124);
            v102 = (*(uint64_t (**)(uint64_t, uint64_t))(v101 + 40))(v100, v101);
            v104 = v103;
            __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v25 + 16) + 1, 1);
              v25 = v120[0];
            }
            v106 = *(_QWORD *)(v25 + 16);
            v105 = *(_QWORD *)(v25 + 24);
            if (v106 >= v105 >> 1)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v105 > 1, v106 + 1, 1);
              v25 = v120[0];
            }
            *(_QWORD *)(v25 + 16) = v106 + 1;
            v107 = v25 + 16 * v106;
            *(_QWORD *)(v107 + 32) = v102;
            *(_QWORD *)(v107 + 40) = v104;
            v99 += 40;
            --v88;
          }
          while (v88);
          swift_bridgeObjectRelease();
          v5 = v98;
          v6 = v139;
          goto LABEL_92;
        }
        swift_bridgeObjectRelease();
        if (*(_QWORD *)(a3 + 16))
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
          swift_bridgeObjectRelease();
          v89 = v124;
          v90 = v125;
          __swift_project_boxed_opaque_existential_1(v123, v124);
          v91 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v90 + 24))(v89, v90) + 16);
          swift_bridgeObjectRelease();
          if (!v91)
          {
            outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v120);
            SQLExpression.init(rootNode:)((uint64_t)v120, (uint64_t)&v126);
            LOBYTE(v138) = 5;
            v92 = v124;
            v93 = v125;
            __swift_project_boxed_opaque_existential_1(v123, v124);
            (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(v93 + 16))(v120, v92, v93);
            __asm { BR              X10 }
          }
          goto LABEL_8;
        }
        __break(1u);
      }
      else
      {
        if ((v6 != 0x6C61746F74 || v5 != 0xE500000000000000)
          && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
        {
LABEL_102:
          swift_bridgeObjectRelease();
          goto LABEL_103;
        }
        v94 = *(_QWORD *)(a3 + 16);
        if (!v94)
          goto LABEL_91;
        if (v94 != 1)
        {
          v118 = v5;
          v120[0] = MEMORY[0x1E0DEE9D8];
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v94, 0);
          v108 = a3 + 32;
          v25 = v120[0];
          do
          {
            outlined init with copy of Aggregation(v108, (uint64_t)v123);
            v109 = v124;
            v110 = v125;
            __swift_project_boxed_opaque_existential_1(v123, v124);
            v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v110 + 40))(v109, v110);
            v113 = v112;
            __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v123);
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v25 + 16) + 1, 1);
              v25 = v120[0];
            }
            v115 = *(_QWORD *)(v25 + 16);
            v114 = *(_QWORD *)(v25 + 24);
            if (v115 >= v114 >> 1)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v114 > 1, v115 + 1, 1);
              v25 = v120[0];
            }
            *(_QWORD *)(v25 + 16) = v115 + 1;
            v116 = v25 + 16 * v115;
            *(_QWORD *)(v116 + 32) = v111;
            *(_QWORD *)(v116 + 40) = v113;
            v108 += 40;
            --v94;
          }
          while (v94);
          swift_bridgeObjectRelease();
          v5 = v118;
          goto LABEL_92;
        }
        swift_bridgeObjectRelease();
        if (*(_QWORD *)(a3 + 16))
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
          swift_bridgeObjectRelease();
          v95 = v124;
          v96 = v125;
          __swift_project_boxed_opaque_existential_1(v123, v124);
          v97 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v96 + 24))(v95, v96) + 16);
          swift_bridgeObjectRelease();
          if (v97)
            goto LABEL_8;
          outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v120);
          SQLExpression.init(rootNode:)((uint64_t)v120, (uint64_t)&v126);
          v23 = 262;
          goto LABEL_26;
        }
      }
      __break(1u);
      JUMPOUT(0x18DB23E3CLL);
    }
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a3 + 16) == 1)
    {
      outlined init with copy of Aggregation(a3 + 32, (uint64_t)v123);
      swift_bridgeObjectRelease();
      v83 = v124;
      v84 = v125;
      __swift_project_boxed_opaque_existential_1(v123, v124);
      v85 = *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(v84 + 24))(v83, v84) + 16);
      swift_bridgeObjectRelease();
      if (v85)
        goto LABEL_8;
      outlined init with copy of Aggregation((uint64_t)v123, (uint64_t)v120);
      SQLExpression.init(rootNode:)((uint64_t)v120, (uint64_t)&v126);
      v75 = 4;
LABEL_73:
      LOBYTE(v138) = v75;
      v86 = v124;
      v87 = v125;
      __swift_project_boxed_opaque_existential_1(v123, v124);
      (*(void (**)(char *__return_ptr, uint64_t, uint64_t))(v87 + 16))((char *)&v138 + 1, v86, v87);
      goto LABEL_27;
    }
  }
LABEL_103:
  result = swift_bridgeObjectRelease();
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_WORD *)(a4 + 192) = 255;
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.CodingKeys()
{
  _BYTE *v0;

  if (*v0)
    return 0x79546E7275746572;
  else
    return 0x7461676572676761;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized AggregationFunction.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.CodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.CodingKeys()
{
  lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t AggregationFunction.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE v10[16];

  v3 = v1;
  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.CodingKeys>);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v8 = &v10[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v10[15] = 0;
  lazy protocol witness table accessor for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v2)
  {
    v10[14] = *(_BYTE *)(v3 + 193);
    v10[13] = 1;
    lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance AggregationFunction(_QWORD *a1)
{
  return AggregationFunction.encode(to:)(a1);
}

uint64_t static AggregationFunction.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  char v4;
  char v5;
  char v6;
  char v7;
  _BYTE v9[193];
  _BYTE v10[200];

  specialized static AggregationFunction.AggregationType.== infix(_:_:)(a1, a2);
  v5 = v4;
  outlined init with copy of AggregationFunction(a1, (uint64_t)v10);
  outlined init with copy of AggregationFunction(a2, (uint64_t)v9);
  if ((v5 & 1) != 0)
  {
    specialized == infix<A>(_:_:)(v10[193]);
    v7 = v6;
  }
  else
  {
    v7 = 0;
  }
  outlined destroy of AggregationFunction((uint64_t)v9);
  outlined destroy of AggregationFunction((uint64_t)v10);
  return v7 & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance AggregationFunction(uint64_t a1, uint64_t a2)
{
  char v4;
  char v5;
  char v6;
  char v7;
  _BYTE v9[193];
  _BYTE v10[200];

  specialized static AggregationFunction.AggregationType.== infix(_:_:)(a1, a2);
  v5 = v4;
  outlined init with copy of AggregationFunction(a1, (uint64_t)v10);
  outlined init with copy of AggregationFunction(a2, (uint64_t)v9);
  if ((v5 & 1) != 0)
  {
    specialized == infix<A>(_:_:)(v10[193]);
    v7 = v6;
  }
  else
  {
    v7 = 0;
  }
  outlined destroy of AggregationFunction((uint64_t)v9);
  outlined destroy of AggregationFunction((uint64_t)v10);
  return v7 & 1;
}

uint64_t SQLExpressionFuncCall.init(function:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t Node;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5;
  uint64_t v32;
  uint64_t v33;
  __int128 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int16 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int16 v66;
  uint64_t v67;

  v39 = a6;
  Node = type metadata accessor for PgQuery_Node(0);
  v12 = *(_QWORD *)(Node - 8);
  MEMORY[0x1E0C80A78](Node);
  v14 = (char *)&v36 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  result = type metadata accessor for PgQuery_FuncCall(0);
  v16 = *(int *)(result + 20);
  v67 = a1;
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + v16) + 16);
  if (*(_QWORD *)(v17 + 16))
  {
    outlined init with copy of PgQuery_RawStmt(v17 + ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80)), (uint64_t)v14, type metadata accessor for PgQuery_Node);
    v18 = a2;
    v19 = a2;
    v20 = a3;
    v21 = a3;
    v22 = a4;
    v23 = v40;
    buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(&v54, v14, v19, v21, a4, a5);
    if (v23)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v67, type metadata accessor for PgQuery_FuncCall);
      outlined destroy of PgQuery_Alias((uint64_t)v14, type metadata accessor for PgQuery_Node);
      return outlined destroy of PgQuery_Alias(a5, type metadata accessor for SQLTokenInformation);
    }
    else
    {
      outlined destroy of PgQuery_Alias((uint64_t)v14, type metadata accessor for PgQuery_Node);
      v38 = 0;
      v25 = *((_QWORD *)&v55 + 1);
      v24 = v56;
      __swift_project_boxed_opaque_existential_1(&v54, *((uint64_t *)&v55 + 1));
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v25, v24);
      v27 = v26;
      v28 = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v54);
      v40 = &v36;
      v29 = *(_QWORD *)(*(_QWORD *)(v67 + v16) + 24);
      MEMORY[0x1E0C80A78](v28);
      *(&v36 - 4) = v18;
      *(&v36 - 3) = v20;
      *(&v36 - 2) = v22;
      *(&v36 - 1) = a5;
      swift_bridgeObjectRetain();
      v30 = v38;
      NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5((void (*)(__int128 *__return_ptr, uint64_t, uint64_t *))partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:), (uint64_t)(&v36 - 6), v29);
      if (v30)
      {
        swift_bridgeObjectRelease();
        outlined destroy of PgQuery_Alias(v67, type metadata accessor for PgQuery_FuncCall);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return outlined destroy of PgQuery_Alias(a5, type metadata accessor for SQLTokenInformation);
      }
      else
      {
        v32 = NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5;
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        v33 = v37;
        AggregationFunction.init(functionName:args:)(v37, (uint64_t)v27, v32, (uint64_t)&v41);
        if (v53 != 0xFF)
        {
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          v64 = v51;
          v65 = v52;
          v66 = v53;
          v60 = v47;
          v61 = v48;
          v62 = v49;
          v63 = v50;
          v56 = v43;
          v57 = v44;
          v58 = v45;
          v59 = v46;
          v54 = v41;
          v55 = v42;
          *((_QWORD *)&v42 + 1) = &unk_1E263FA98;
          *(_QWORD *)&v43 = &protocol witness table for SQLExpressionAggregationFunction;
          v35 = swift_allocObject();
          *(_QWORD *)&v41 = v35;
          outlined init with copy of AggregationFunction((uint64_t)&v54, v35 + 16);
          *(_QWORD *)(v35 + 216) = 63;
          *(_QWORD *)(v35 + 224) = 0xE100000000000000;
          outlined destroy of PgQuery_Alias(v67, type metadata accessor for PgQuery_FuncCall);
          outlined destroy of AggregationFunction((uint64_t)&v54);
          outlined destroy of PgQuery_Alias(a5, type metadata accessor for SQLTokenInformation);
          v34 = &v41;
        }
        else
        {
          outlined destroy of (key: String, value: StorableValue)((uint64_t)&v41, (uint64_t *)&demangling cache variable for type metadata for AggregationFunction?);
          *((_QWORD *)&v55 + 1) = &unk_1E263FB48;
          *(_QWORD *)&v56 = &protocol witness table for SQLExpressionNonAggregationFunction;
          SQLExpressionNonAggregationFunction.init(functionName:argList:)(v33, v27, v32, (uint64_t)&v54);
          outlined destroy of PgQuery_Alias(v67, type metadata accessor for PgQuery_FuncCall);
          outlined destroy of PgQuery_Alias(a5, type metadata accessor for SQLTokenInformation);
          v34 = &v54;
        }
        return outlined init with take of Aggregation(v34, v39);
      }
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t protocol witness for SQLExpressionNode.expressionString.getter in conformance SQLExpressionConst()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;

  v1 = v0[3];
  v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
}

uint64_t protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionConst()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;

  v1 = v0[3];
  v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 16))(v1, v2);
}

uint64_t SQLExpression.hash(into:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  v3 = *(_QWORD *)(v1 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)(a1, v3);
  return swift_bridgeObjectRelease();
}

Swift::Int SQLExpression.hashValue.getter()
{
  uint64_t v0;
  uint64_t v1;
  _BYTE v3[72];

  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  v1 = *(_QWORD *)(v0 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)((uint64_t)v3, v1);
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLExpression()
{
  uint64_t v0;
  uint64_t v1;
  _BYTE v3[72];

  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  v1 = *(_QWORD *)(v0 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)((uint64_t)v3, v1);
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SQLExpression(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  v3 = *(_QWORD *)(v1 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)(a1, v3);
  return swift_bridgeObjectRelease();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SQLExpression()
{
  uint64_t v0;
  uint64_t v1;
  _BYTE v3[72];

  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  v1 = *(_QWORD *)(v0 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)((uint64_t)v3, v1);
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

uint64_t specialized _NativeDictionary.filter(_:)(uint64_t isStackAllocationSafe)
{
  uint64_t v1;
  uint64_t v2;
  char v3;
  size_t v4;
  unint64_t *v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  int64_t v15;
  unint64_t v16;
  int64_t v17;
  BOOL v18;
  uint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  unint64_t v30;
  int64_t v31;
  uint64_t v32;
  int64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  unint64_t v41;
  int64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  Swift::Int v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char v52;
  unint64_t v53;
  BOOL v54;
  uint64_t v55;
  uint64_t v56;
  int64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t v63;
  int64_t v64;
  unint64_t v65;
  int64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  Swift::Int v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  char v76;
  unint64_t v77;
  BOOL v78;
  uint64_t v79;
  _QWORD v81[2];
  uint64_t v82;
  unint64_t *v83;
  int64_t v84;
  int64_t v85;
  uint64_t v86;

  v2 = isStackAllocationSafe;
  v86 = *MEMORY[0x1E0C80C00];
  v3 = *(_BYTE *)(isStackAllocationSafe + 32);
  v84 = (unint64_t)((1 << v3) + 63) >> 6;
  v4 = 8 * v84;
  if ((v3 & 0x3Fu) > 0xD)
  {
    isStackAllocationSafe = swift_stdlib_isStackAllocationSafe();
    if ((isStackAllocationSafe & 1) == 0)
    {
      v83 = (unint64_t *)swift_slowAlloc();
      bzero(v83, v4);
      v19 = 0;
      v20 = 0;
      v21 = v2 + 64;
      v22 = 1 << *(_BYTE *)(v2 + 32);
      if (v22 < 64)
        v23 = ~(-1 << v22);
      else
        v23 = -1;
      v24 = v23 & *(_QWORD *)(v2 + 64);
      v25 = (unint64_t)(v22 + 63) >> 6;
      v26 = v83;
      while (1)
      {
        if (v24)
        {
          v27 = __clz(__rbit64(v24));
          v24 &= v24 - 1;
          v28 = v27 | (v20 << 6);
        }
        else
        {
          v29 = v20 + 1;
          if (__OFADD__(v20, 1))
            goto LABEL_132;
          if (v29 >= v25)
            goto LABEL_58;
          v30 = *(_QWORD *)(v21 + 8 * v29);
          ++v20;
          if (!v30)
          {
            v20 = v29 + 1;
            if (v29 + 1 >= v25)
              goto LABEL_58;
            v30 = *(_QWORD *)(v21 + 8 * v20);
            if (!v30)
            {
              v20 = v29 + 2;
              if (v29 + 2 >= v25)
                goto LABEL_58;
              v30 = *(_QWORD *)(v21 + 8 * v20);
              if (!v30)
              {
                v20 = v29 + 3;
                if (v29 + 3 >= v25)
                  goto LABEL_58;
                v30 = *(_QWORD *)(v21 + 8 * v20);
                if (!v30)
                {
                  v31 = v29 + 4;
                  if (v31 >= v25)
                    goto LABEL_58;
                  v30 = *(_QWORD *)(v21 + 8 * v31);
                  if (!v30)
                  {
                    while (1)
                    {
                      v20 = v31 + 1;
                      if (__OFADD__(v31, 1))
                        goto LABEL_136;
                      if (v20 >= v25)
                        break;
                      v30 = *(_QWORD *)(v21 + 8 * v20);
                      ++v31;
                      if (v30)
                        goto LABEL_54;
                    }
LABEL_58:
                    if (!v19)
                    {
                      v2 = MEMORY[0x1E0DEE9E0];
                      goto LABEL_128;
                    }
                    if (v19 == *(_QWORD *)(v2 + 16))
                    {
                      swift_retain();
                      goto LABEL_128;
                    }
                    v82 = v1;
                    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Int>);
                    v56 = static _DictionaryStorage.allocate(capacity:)();
                    v57 = 0;
                    v58 = *v83;
                    v59 = v56 + 64;
                    while (1)
                    {
                      if (v58)
                      {
                        v62 = __clz(__rbit64(v58));
                        v58 &= v58 - 1;
                        v85 = v57;
                        v63 = v62 | (v57 << 6);
                      }
                      else
                      {
                        v64 = v57 + 1;
                        if (__OFADD__(v57, 1))
                          goto LABEL_135;
                        if (v64 >= v84)
                          goto LABEL_127;
                        v65 = v83[v64];
                        v66 = v57 + 1;
                        if (!v65)
                        {
                          v66 = v57 + 2;
                          if (v57 + 2 >= v84)
                            goto LABEL_127;
                          v65 = v83[v66];
                          if (!v65)
                          {
                            v66 = v57 + 3;
                            if (v57 + 3 >= v84)
                              goto LABEL_127;
                            v65 = v83[v66];
                            if (!v65)
                            {
                              v66 = v57 + 4;
                              if (v57 + 4 >= v84)
                                goto LABEL_127;
                              v65 = v83[v66];
                              if (!v65)
                              {
                                v66 = v57 + 5;
                                if (v57 + 5 >= v84)
                                  goto LABEL_127;
                                v65 = v83[v66];
                                if (!v65)
                                {
                                  v67 = v57 + 6;
                                  if (v57 + 6 >= v84)
                                    goto LABEL_127;
                                  v65 = v83[v67];
                                  if (!v65)
                                  {
                                    while (1)
                                    {
                                      v66 = v67 + 1;
                                      if (__OFADD__(v67, 1))
                                        goto LABEL_138;
                                      if (v66 >= v84)
                                        break;
                                      v65 = v83[v66];
                                      ++v67;
                                      if (v65)
                                        goto LABEL_117;
                                    }
LABEL_127:
                                    v2 = v56;
LABEL_128:
                                    MEMORY[0x193FED860](v83, -1, -1);
                                    return v2;
                                  }
                                  v66 = v57 + 6;
                                }
                              }
                            }
                          }
                        }
LABEL_117:
                        v58 = (v65 - 1) & v65;
                        v85 = v66;
                        v63 = __clz(__rbit64(v65)) + (v66 << 6);
                      }
                      v68 = (uint64_t *)(*(_QWORD *)(v2 + 48) + 16 * v63);
                      v70 = *v68;
                      v69 = v68[1];
                      v71 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8 * v63);
                      Hasher.init(_seed:)();
                      swift_bridgeObjectRetain();
                      String.hash(into:)();
                      v72 = Hasher._finalize()();
                      v73 = -1 << *(_BYTE *)(v56 + 32);
                      v74 = v72 & ~v73;
                      v75 = v74 >> 6;
                      if (((-1 << v74) & ~*(_QWORD *)(v59 + 8 * (v74 >> 6))) != 0)
                      {
                        v60 = __clz(__rbit64((-1 << v74) & ~*(_QWORD *)(v59 + 8 * (v74 >> 6)))) | v74 & 0x7FFFFFFFFFFFFFC0;
                      }
                      else
                      {
                        v76 = 0;
                        v77 = (unint64_t)(63 - v73) >> 6;
                        do
                        {
                          if (++v75 == v77 && (v76 & 1) != 0)
                            goto LABEL_131;
                          v78 = v75 == v77;
                          if (v75 == v77)
                            v75 = 0;
                          v76 |= v78;
                          v79 = *(_QWORD *)(v59 + 8 * v75);
                        }
                        while (v79 == -1);
                        v60 = __clz(__rbit64(~v79)) + (v75 << 6);
                      }
                      *(_QWORD *)(v59 + ((v60 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v60;
                      v61 = (_QWORD *)(*(_QWORD *)(v56 + 48) + 16 * v60);
                      *v61 = v70;
                      v61[1] = v69;
                      *(_QWORD *)(*(_QWORD *)(v56 + 56) + 8 * v60) = v71;
                      ++*(_QWORD *)(v56 + 16);
                      --v19;
                      v57 = v85;
                      if (!v19)
                        goto LABEL_127;
                    }
                  }
                  v20 = v31;
                }
              }
            }
          }
LABEL_54:
          v24 = (v30 - 1) & v30;
          v28 = __clz(__rbit64(v30)) + (v20 << 6);
        }
        if (*(uint64_t *)(*(_QWORD *)(v2 + 56) + 8 * v28) >= 2)
        {
          *(unint64_t *)((char *)v26 + ((v28 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v28;
          v18 = __OFADD__(v19++, 1);
          if (v18)
          {
            __break(1u);
            goto LABEL_58;
          }
        }
      }
    }
  }
  MEMORY[0x1E0C80A78](isStackAllocationSafe);
  v5 = (_QWORD *)((char *)v81 - ((v4 + 15) & 0x3FFFFFFFFFFFFFF0));
  bzero(v5, v4);
  v6 = 0;
  v7 = 0;
  v8 = v2 + 64;
  v9 = 1 << *(_BYTE *)(v2 + 32);
  v10 = -1;
  if (v9 < 64)
    v10 = ~(-1 << v9);
  v11 = v10 & *(_QWORD *)(v2 + 64);
  v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      v14 = v13 | (v7 << 6);
      goto LABEL_7;
    }
    v15 = v7 + 1;
    if (__OFADD__(v7, 1))
      goto LABEL_130;
    if (v15 >= v12)
      goto LABEL_28;
    v16 = *(_QWORD *)(v8 + 8 * v15);
    ++v7;
    if (!v16)
    {
      v7 = v15 + 1;
      if (v15 + 1 >= v12)
        goto LABEL_28;
      v16 = *(_QWORD *)(v8 + 8 * v7);
      if (!v16)
      {
        v7 = v15 + 2;
        if (v15 + 2 >= v12)
          goto LABEL_28;
        v16 = *(_QWORD *)(v8 + 8 * v7);
        if (!v16)
        {
          v7 = v15 + 3;
          if (v15 + 3 >= v12)
            goto LABEL_28;
          v16 = *(_QWORD *)(v8 + 8 * v7);
          if (!v16)
            break;
        }
      }
    }
LABEL_24:
    v11 = (v16 - 1) & v16;
    v14 = __clz(__rbit64(v16)) + (v7 << 6);
LABEL_7:
    if (*(uint64_t *)(*(_QWORD *)(v2 + 56) + 8 * v14) >= 2)
    {
      *(unint64_t *)((char *)v5 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
      v18 = __OFADD__(v6++, 1);
      if (v18)
      {
        __break(1u);
        goto LABEL_28;
      }
    }
  }
  v17 = v15 + 4;
  if (v17 >= v12)
    goto LABEL_28;
  v16 = *(_QWORD *)(v8 + 8 * v17);
  if (v16)
  {
    v7 = v17;
    goto LABEL_24;
  }
  while (1)
  {
    v7 = v17 + 1;
    if (__OFADD__(v17, 1))
      goto LABEL_134;
    if (v7 >= v12)
      break;
    v16 = *(_QWORD *)(v8 + 8 * v7);
    ++v17;
    if (v16)
      goto LABEL_24;
  }
LABEL_28:
  if (!v6)
    return MEMORY[0x1E0DEE9E0];
  if (v6 != *(_QWORD *)(v2 + 16))
  {
    v81[1] = v81;
    v82 = v1;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Int>);
    v32 = static _DictionaryStorage.allocate(capacity:)();
    v33 = 0;
    v83 = (_QWORD *)((char *)v81 - ((v4 + 15) & 0x3FFFFFFFFFFFFFF0));
    v34 = *v5;
    v35 = v32 + 64;
    while (1)
    {
      if (v34)
      {
        v38 = __clz(__rbit64(v34));
        v34 &= v34 - 1;
        v85 = v33;
        v39 = v38 | (v33 << 6);
      }
      else
      {
        v40 = v33 + 1;
        if (__OFADD__(v33, 1))
          goto LABEL_133;
        if (v40 >= v84)
          return v32;
        v41 = v83[v40];
        v42 = v33 + 1;
        if (!v41)
        {
          v42 = v33 + 2;
          if (v33 + 2 >= v84)
            return v32;
          v41 = v83[v42];
          if (!v41)
          {
            v42 = v33 + 3;
            if (v33 + 3 >= v84)
              return v32;
            v41 = v83[v42];
            if (!v41)
            {
              v42 = v33 + 4;
              if (v33 + 4 >= v84)
                return v32;
              v41 = v83[v42];
              if (!v41)
              {
                v42 = v33 + 5;
                if (v33 + 5 >= v84)
                  return v32;
                v41 = v83[v42];
                if (!v41)
                {
                  v43 = v33 + 6;
                  if (v33 + 6 >= v84)
                    return v32;
                  v41 = v83[v43];
                  if (!v41)
                  {
                    while (1)
                    {
                      v42 = v43 + 1;
                      if (__OFADD__(v43, 1))
                        break;
                      if (v42 >= v84)
                        return v32;
                      v41 = v83[v42];
                      ++v43;
                      if (v41)
                        goto LABEL_83;
                    }
LABEL_137:
                    __break(1u);
LABEL_138:
                    __break(1u);
                  }
                  v42 = v33 + 6;
                }
              }
            }
          }
        }
LABEL_83:
        v34 = (v41 - 1) & v41;
        v85 = v42;
        v39 = __clz(__rbit64(v41)) + (v42 << 6);
      }
      v44 = (uint64_t *)(*(_QWORD *)(v2 + 48) + 16 * v39);
      v46 = *v44;
      v45 = v44[1];
      v47 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8 * v39);
      Hasher.init(_seed:)();
      swift_bridgeObjectRetain();
      String.hash(into:)();
      v48 = Hasher._finalize()();
      v49 = -1 << *(_BYTE *)(v32 + 32);
      v50 = v48 & ~v49;
      v51 = v50 >> 6;
      if (((-1 << v50) & ~*(_QWORD *)(v35 + 8 * (v50 >> 6))) != 0)
      {
        v36 = __clz(__rbit64((-1 << v50) & ~*(_QWORD *)(v35 + 8 * (v50 >> 6)))) | v50 & 0x7FFFFFFFFFFFFFC0;
        goto LABEL_63;
      }
      v52 = 0;
      v53 = (unint64_t)(63 - v49) >> 6;
      do
      {
        if (++v51 == v53 && (v52 & 1) != 0)
        {
          __break(1u);
LABEL_130:
          __break(1u);
LABEL_131:
          __break(1u);
LABEL_132:
          __break(1u);
LABEL_133:
          __break(1u);
LABEL_134:
          __break(1u);
LABEL_135:
          __break(1u);
LABEL_136:
          __break(1u);
          goto LABEL_137;
        }
        v54 = v51 == v53;
        if (v51 == v53)
          v51 = 0;
        v52 |= v54;
        v55 = *(_QWORD *)(v35 + 8 * v51);
      }
      while (v55 == -1);
      v36 = __clz(__rbit64(~v55)) + (v51 << 6);
LABEL_63:
      *(_QWORD *)(v35 + ((v36 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v36;
      v37 = (_QWORD *)(*(_QWORD *)(v32 + 48) + 16 * v36);
      *v37 = v46;
      v37[1] = v45;
      *(_QWORD *)(*(_QWORD *)(v32 + 56) + 8 * v36) = v47;
      ++*(_QWORD *)(v32 + 16);
      --v6;
      v33 = v85;
      if (!v6)
        return v32;
    }
  }
  swift_retain();
  return v2;
}

void specialized Array<A>.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    v4 = *(unsigned __int8 *)(a2 + 48);
    swift_bridgeObjectRetain();
    String.hash(into:)();
    __asm { BR              X8 }
  }
}

void specialized static AggregationFunction.AggregationType.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  _BYTE v3[200];
  uint64_t v4;

  outlined init with copy of AggregationFunction.AggregationType(a1, (uint64_t)v3);
  outlined init with copy of AggregationFunction.AggregationType(a2, (uint64_t)&v4);
  __asm { BR              X10 }
}

uint64_t sub_18DB25370()
{
  _OWORD *v0;
  _OWORD *v1;
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  _OWORD v14[2];
  _BYTE v15[32];
  __int128 v16;
  __int128 v17;
  _QWORD *v18[12];
  uint64_t v19[12];
  uint64_t v20[12];
  uint64_t v21[12];
  _BYTE v22[96];
  char v23[96];
  _OWORD v24[2];
  _BYTE v25[32];
  __int128 v26;
  __int128 v27;
  _BYTE v28[200];
  _BYTE v29[464];

  outlined init with copy of AggregationFunction.AggregationType((uint64_t)v29, (uint64_t)v28);
  if (v29[392])
  {
    outlined destroy of SQLExpression((uint64_t)v28);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v29, &demangling cache variable for type metadata for (AggregationFunction.AggregationType, AggregationFunction.AggregationType));
    v12 = 0;
    return v12 & 1;
  }
  v2 = v1[3];
  *(_OWORD *)v15 = v1[2];
  *(_OWORD *)&v15[16] = v2;
  v3 = v1[5];
  v16 = v1[4];
  v17 = v3;
  v4 = v1[1];
  v14[0] = *v1;
  v14[1] = v4;
  v5 = v0[2];
  *(_OWORD *)&v25[16] = v0[3];
  *(_OWORD *)v25 = v5;
  v6 = v0[5];
  v26 = v0[4];
  v27 = v6;
  v7 = v0[1];
  v24[0] = *v0;
  v24[1] = v7;
  if (*(_OWORD *)&v15[8] == *(_OWORD *)&v25[8])
  {
    outlined init with copy of SQLExpression((uint64_t)v14, (uint64_t)v23);
    outlined init with copy of SQLExpression((uint64_t)v24, (uint64_t)v22);
  }
  else
  {
    v8 = _stringCompareWithSmolCheck(_:_:expecting:)();
    outlined init with copy of SQLExpression((uint64_t)v14, (uint64_t)v23);
    outlined init with copy of SQLExpression((uint64_t)v24, (uint64_t)v22);
    if ((v8 & 1) == 0)
    {
      outlined destroy of SQLExpression((uint64_t)v23);
      outlined destroy of SQLExpression((uint64_t)v22);
      outlined init with copy of SQLExpression((uint64_t)v14, (uint64_t)v21);
      outlined init with copy of SQLExpression((uint64_t)v24, (uint64_t)v20);
      goto LABEL_9;
    }
  }
  specialized == infix<A>(_:_:)(v23[56]);
  v10 = v9;
  outlined destroy of SQLExpression((uint64_t)v23);
  outlined destroy of SQLExpression((uint64_t)v22);
  outlined init with copy of SQLExpression((uint64_t)v14, (uint64_t)v21);
  outlined init with copy of SQLExpression((uint64_t)v24, (uint64_t)v20);
  if ((v10 & 1) == 0)
  {
LABEL_9:
    outlined destroy of SQLExpression((uint64_t)v21);
    outlined destroy of SQLExpression((uint64_t)v20);
    outlined init with copy of SQLExpression((uint64_t)v14, (uint64_t)v19);
    outlined init with copy of SQLExpression((uint64_t)v24, (uint64_t)v18);
    goto LABEL_10;
  }
  v11 = specialized static Array<A>.== infix(_:_:)(v21[8], v20[8]);
  outlined destroy of SQLExpression((uint64_t)v21);
  outlined destroy of SQLExpression((uint64_t)v20);
  outlined init with copy of SQLExpression((uint64_t)v14, (uint64_t)v19);
  outlined init with copy of SQLExpression((uint64_t)v24, (uint64_t)v18);
  if ((v11 & 1) == 0)
  {
LABEL_10:
    v12 = 0;
    goto LABEL_11;
  }
  v12 = specialized static Array<A>.== infix(_:_:)(v19[9], v18[9]);
LABEL_11:
  outlined destroy of SQLExpression((uint64_t)v19);
  outlined destroy of SQLExpression((uint64_t)v18);
  outlined destroy of SQLExpression((uint64_t)v24);
  outlined destroy of SQLExpression((uint64_t)v14);
  outlined destroy of AggregationFunction.AggregationType((uint64_t)v29);
  return v12 & 1;
}

uint64_t specialized static SQLExpression.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  char v5;
  char v6;
  char v7;
  char v8;
  char v9;
  _QWORD *v11[12];
  _BYTE v12[72];
  uint64_t v13;
  _BYTE v14[64];
  uint64_t v15;
  _BYTE v16[64];
  uint64_t v17;
  _BYTE v18[56];
  _BYTE v19[96];

  if (*(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 40) && *(_QWORD *)(a1 + 48) == *(_QWORD *)(a2 + 48))
  {
    outlined init with copy of SQLExpression(a1, (uint64_t)v19);
    outlined init with copy of SQLExpression(a2, (uint64_t)v18);
  }
  else
  {
    v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    outlined init with copy of SQLExpression(a1, (uint64_t)v19);
    outlined init with copy of SQLExpression(a2, (uint64_t)v18);
    if ((v5 & 1) == 0)
    {
      outlined destroy of SQLExpression((uint64_t)v18);
      outlined destroy of SQLExpression((uint64_t)v19);
      outlined init with copy of SQLExpression(a1, (uint64_t)v16);
      outlined init with copy of SQLExpression(a2, (uint64_t)v14);
LABEL_11:
      outlined destroy of SQLExpression((uint64_t)v16);
      outlined destroy of SQLExpression((uint64_t)v14);
      outlined init with copy of SQLExpression(a1, (uint64_t)v12);
      outlined init with copy of SQLExpression(a2, (uint64_t)v11);
      goto LABEL_12;
    }
  }
  specialized == infix<A>(_:_:)(v19[56]);
  v7 = v6;
  outlined destroy of SQLExpression((uint64_t)v18);
  outlined destroy of SQLExpression((uint64_t)v19);
  outlined init with copy of SQLExpression(a1, (uint64_t)v16);
  outlined init with copy of SQLExpression(a2, (uint64_t)v14);
  if ((v7 & 1) == 0)
    goto LABEL_11;
  v8 = specialized static Array<A>.== infix(_:_:)(v17, v15);
  outlined destroy of SQLExpression((uint64_t)v16);
  outlined destroy of SQLExpression((uint64_t)v14);
  outlined init with copy of SQLExpression(a1, (uint64_t)v12);
  outlined init with copy of SQLExpression(a2, (uint64_t)v11);
  if ((v8 & 1) == 0)
  {
LABEL_12:
    v9 = 0;
    goto LABEL_13;
  }
  v9 = specialized static Array<A>.== infix(_:_:)(v13, v11[9]);
LABEL_13:
  outlined destroy of SQLExpression((uint64_t)v12);
  outlined destroy of SQLExpression((uint64_t)v11);
  return v9 & 1;
}

unint64_t lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Binding.CodingKeys, &unk_1E263FCE0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Binding.CodingKeys, &unk_1E263FCE0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Binding.CodingKeys, &unk_1E263FCE0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Binding.CodingKeys, &unk_1E263FCE0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.CodingKeys, &unk_1E263BE00);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.CodingKeys, &unk_1E263BE00);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.CodingKeys, &unk_1E263BE00);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.CodingKeys, &unk_1E263BE00);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.TOTALCodingKeys, &unk_1E263C160);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.TOTALCodingKeys, &unk_1E263C160);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.TOTALCodingKeys, &unk_1E263C160);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.TOTALCodingKeys, &unk_1E263C160);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression;
  if (!lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLExpression, &type metadata for SQLExpression);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression;
  if (!lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLExpression, &type metadata for SQLExpression);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.SUMCodingKeys, &unk_1E263C040);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.SUMCodingKeys, &unk_1E263C040);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.SUMCodingKeys, &unk_1E263C040);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.SUMCodingKeys, &unk_1E263C040);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MINCodingKeys, &unk_1E263BFB0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MINCodingKeys, &unk_1E263BFB0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MINCodingKeys, &unk_1E263BFB0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MINCodingKeys, &unk_1E263BFB0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MAXCodingKeys, &unk_1E263BF20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MAXCodingKeys, &unk_1E263BF20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MAXCodingKeys, &unk_1E263BF20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.MAXCodingKeys, &unk_1E263BF20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.GROUP_CONCATCodingKeys, &unk_1E263C210);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.GROUP_CONCATCodingKeys, &unk_1E263C210);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.GROUP_CONCATCodingKeys, &unk_1E263C210);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.GROUP_CONCATCodingKeys, &unk_1E263C210);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.COUNT_STARCodingKeys, &unk_1E263C1F0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.COUNT_STARCodingKeys, &unk_1E263C1F0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.COUNT_STARCodingKeys, &unk_1E263C1F0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.COUNTCodingKeys, &unk_1E263C0D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.COUNTCodingKeys, &unk_1E263C0D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.COUNTCodingKeys, &unk_1E263C0D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.COUNTCodingKeys, &unk_1E263C0D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.AVGCodingKeys, &unk_1E263BE90);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.AVGCodingKeys, &unk_1E263BE90);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.AVGCodingKeys, &unk_1E263BE90);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType.AVGCodingKeys, &unk_1E263BE90);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.CodingKeys, &unk_1E263C330);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.CodingKeys, &unk_1E263C330);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.CodingKeys, &unk_1E263C330);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.CodingKeys, &unk_1E263C330);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for AggregationFunction.AggregationType, &type metadata for AggregationFunction.AggregationType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType);
  }
  return result;
}

uint64_t assignWithCopy for SQLExpression(uint64_t a1, uint64_t a2)
{
  __swift_assign_boxed_opaque_existential_1((uint64_t *)a1, (uint64_t *)a2);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_1(uint64_t *result, uint64_t *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[24];

  if (result != a2)
  {
    v3 = result;
    v4 = result[3];
    v5 = a2[3];
    if (v4 == v5)
    {
      v9 = *(_QWORD *)(v4 - 8);
      if ((*(_BYTE *)(v9 + 82) & 2) != 0)
      {
        v10 = *a2;
        swift_retain();
        result = (uint64_t *)swift_release();
        *v3 = v10;
      }
      else
      {
        return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t *, uint64_t))(v9 + 24))(result, a2, result[3]);
      }
    }
    else
    {
      result[3] = v5;
      result[4] = a2[4];
      v6 = *(_QWORD *)(v4 - 8);
      v7 = *(_QWORD *)(v5 - 8);
      v8 = *(_DWORD *)(v7 + 80);
      if ((*(_BYTE *)(v6 + 82) & 2) != 0)
      {
        if ((v8 & 0x20000) != 0)
        {
          *result = *a2;
          swift_retain();
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t *, uint64_t))(v7 + 16))(result, a2, v5);
        }
        return (uint64_t *)swift_release();
      }
      else
      {
        (*(void (**)(_BYTE *, uint64_t *, uint64_t))(v6 + 32))(v11, result, v4);
        if ((v8 & 0x20000) != 0)
        {
          *v3 = *a2;
          swift_retain();
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t *, uint64_t))(v7 + 16))(v3, a2, v5);
        }
        return (uint64_t *)(*(uint64_t (**)(_BYTE *, uint64_t))(v6 + 8))(v11, v4);
      }
    }
  }
  return result;
}

uint64_t assignWithTake for SQLExpression(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  swift_bridgeObjectRelease();
  v5 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = v5;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithCopy for Binding(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  return a1;
}

uint64_t assignWithTake for Binding(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  return a1;
}

uint64_t assignWithCopy for AggregationFunction(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    switch(*(_BYTE *)(a2 + 192))
    {
      case 0:
        v4 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v4;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        *(_BYTE *)(a1 + 192) = 0;
        goto LABEL_13;
      case 1:
        v14 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v14;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 1;
        goto LABEL_12;
      case 2:
        v16 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v16;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v16 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v17 = *(_QWORD *)(a2 + 120);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v17)
        {
          *(_QWORD *)(a1 + 120) = v17;
          *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
          (**(void (***)(uint64_t, uint64_t, uint64_t))(v17 - 8))(a1 + 96, a2 + 96, v17);
          *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
          *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
          *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
          *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
          *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
          *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
          *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
        }
        else
        {
          v23 = *(_OWORD *)(a2 + 112);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(a1 + 112) = v23;
          v24 = *(_OWORD *)(a2 + 128);
          v25 = *(_OWORD *)(a2 + 144);
          v26 = *(_OWORD *)(a2 + 176);
          *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
          *(_OWORD *)(a1 + 176) = v26;
          *(_OWORD *)(a1 + 128) = v24;
          *(_OWORD *)(a1 + 144) = v25;
        }
        *(_BYTE *)(a1 + 192) = 2;
        break;
      case 3:
        v18 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v18;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v18 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 3;
        goto LABEL_12;
      case 4:
        v19 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v19;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v19 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 4;
        goto LABEL_12;
      case 5:
        v20 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v20;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v20 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 5;
        goto LABEL_12;
      case 6:
        v21 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v21;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v21 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 6;
LABEL_12:
        *(_BYTE *)(a1 + 192) = v15;
LABEL_13:
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        break;
      default:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        v5 = *(_OWORD *)(a2 + 16);
        v6 = *(_OWORD *)(a2 + 32);
        v7 = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 64) = v7;
        *(_OWORD *)(a1 + 16) = v5;
        *(_OWORD *)(a1 + 32) = v6;
        v8 = *(_OWORD *)(a2 + 80);
        v9 = *(_OWORD *)(a2 + 96);
        v10 = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 128) = v10;
        *(_OWORD *)(a1 + 80) = v8;
        *(_OWORD *)(a1 + 96) = v9;
        v11 = *(_OWORD *)(a2 + 144);
        v12 = *(_OWORD *)(a2 + 160);
        v13 = *(_OWORD *)(a2 + 176);
        *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
        *(_OWORD *)(a1 + 160) = v12;
        *(_OWORD *)(a1 + 176) = v13;
        *(_OWORD *)(a1 + 144) = v11;
        break;
    }
  }
  *(_BYTE *)(a1 + 193) = *(_BYTE *)(a2 + 193);
  return a1;
}

uint64_t outlined destroy of AggregationFunction.AggregationType(uint64_t a1)
{
  destroy for AggregationFunction.AggregationType(a1);
  return a1;
}

uint64_t assignWithTake for AggregationFunction(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    v4 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 176) = v4;
    *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
    v5 = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(a1 + 112) = v5;
    v6 = *(_OWORD *)(a2 + 144);
    *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(a1 + 144) = v6;
    v7 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 48) = v7;
    v8 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 80) = v8;
    v9 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v9;
  }
  *(_BYTE *)(a1 + 193) = *(_BYTE *)(a2 + 193);
  return a1;
}

uint64_t getEnumTagSinglePayload for AggregationFunction(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xF9 && *(_BYTE *)(a1 + 194))
    return (*(_DWORD *)a1 + 249);
  v3 = *(unsigned __int8 *)(a1 + 192);
  if (v3 <= 7)
    v4 = -1;
  else
    v4 = v3 ^ 0xFF;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for AggregationFunction(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xF8)
  {
    *(_QWORD *)(result + 184) = 0;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_WORD *)(result + 192) = 0;
    *(_QWORD *)result = a2 - 249;
    if (a3 >= 0xF9)
      *(_BYTE *)(result + 194) = 1;
  }
  else
  {
    if (a3 >= 0xF9)
      *(_BYTE *)(result + 194) = 0;
    if (a2)
      *(_BYTE *)(result + 192) = -(char)a2;
  }
  return result;
}

uint64_t assignWithCopy for AggregationFunction.AggregationType(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  if (a1 != a2)
  {
    v4 = *(unsigned __int8 *)(a1 + 192);
    if (v4 >= 7)
      v4 = *(_DWORD *)a1 + 7;
    switch(v4)
    {
      case 0u:
      case 1u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        goto LABEL_6;
      case 2u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(_QWORD *)(a1 + 120))
        {
          __swift_destroy_boxed_opaque_existential_1Tm(a1 + 96);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
LABEL_6:
          swift_bridgeObjectRelease();
        }
        break;
      default:
        break;
    }
    v5 = *(unsigned __int8 *)(a2 + 192);
    if (v5 >= 7)
      v5 = *(_DWORD *)a2 + 7;
    switch(v5)
    {
      case 0u:
        v6 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v6;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        *(_BYTE *)(a1 + 192) = 0;
        goto LABEL_22;
      case 1u:
        v16 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v16;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v16 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v17 = 1;
        goto LABEL_21;
      case 2u:
        v18 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v18;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v18 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v19 = *(_QWORD *)(a2 + 120);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v19)
        {
          *(_QWORD *)(a1 + 120) = v19;
          *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
          (**(void (***)(uint64_t, uint64_t, uint64_t))(v19 - 8))(a1 + 96, a2 + 96, v19);
          *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
          *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
          *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
          *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
          *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
          *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
          *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
        }
        else
        {
          v25 = *(_OWORD *)(a2 + 112);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(a1 + 112) = v25;
          v26 = *(_OWORD *)(a2 + 128);
          v27 = *(_OWORD *)(a2 + 144);
          v28 = *(_OWORD *)(a2 + 176);
          *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
          *(_OWORD *)(a1 + 176) = v28;
          *(_OWORD *)(a1 + 128) = v26;
          *(_OWORD *)(a1 + 144) = v27;
        }
        *(_BYTE *)(a1 + 192) = 2;
        return a1;
      case 3u:
        v20 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v20;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v20 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v17 = 3;
        goto LABEL_21;
      case 4u:
        v21 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v21;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v21 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v17 = 4;
        goto LABEL_21;
      case 5u:
        v22 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v22;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v22 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v17 = 5;
        goto LABEL_21;
      case 6u:
        v23 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v23;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v23 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v17 = 6;
LABEL_21:
        *(_BYTE *)(a1 + 192) = v17;
LABEL_22:
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        break;
      default:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        v7 = *(_OWORD *)(a2 + 16);
        v8 = *(_OWORD *)(a2 + 32);
        v9 = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 64) = v9;
        *(_OWORD *)(a1 + 16) = v7;
        *(_OWORD *)(a1 + 32) = v8;
        v10 = *(_OWORD *)(a2 + 80);
        v11 = *(_OWORD *)(a2 + 96);
        v12 = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 128) = v12;
        *(_OWORD *)(a1 + 80) = v10;
        *(_OWORD *)(a1 + 96) = v11;
        v13 = *(_OWORD *)(a2 + 144);
        v14 = *(_OWORD *)(a2 + 160);
        v15 = *(_OWORD *)(a2 + 176);
        *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
        *(_OWORD *)(a1 + 160) = v14;
        *(_OWORD *)(a1 + 176) = v15;
        *(_OWORD *)(a1 + 144) = v13;
        break;
    }
  }
  return a1;
}

__n128 __swift_memcpy193_8(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __n128 result;
  __int128 v9;
  __int128 v10;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  v2 = *(_OWORD *)(a2 + 16);
  v3 = *(_OWORD *)(a2 + 32);
  v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(_OWORD *)(a1 + 16) = v2;
  *(_OWORD *)(a1 + 32) = v3;
  v5 = *(_OWORD *)(a2 + 80);
  v6 = *(_OWORD *)(a2 + 96);
  v7 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = v7;
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 96) = v6;
  result = *(__n128 *)(a2 + 144);
  v9 = *(_OWORD *)(a2 + 160);
  v10 = *(_OWORD *)(a2 + 176);
  *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
  *(_OWORD *)(a1 + 160) = v9;
  *(_OWORD *)(a1 + 176) = v10;
  *(__n128 *)(a1 + 144) = result;
  return result;
}

uint64_t assignWithTake for AggregationFunction.AggregationType(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  char v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;

  if (a1 != a2)
  {
    v4 = *(unsigned __int8 *)(a1 + 192);
    if (v4 >= 7)
      v4 = *(_DWORD *)a1 + 7;
    switch(v4)
    {
      case 0u:
      case 1u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        goto LABEL_6;
      case 2u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(_QWORD *)(a1 + 120))
        {
          __swift_destroy_boxed_opaque_existential_1Tm(a1 + 96);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
LABEL_6:
          swift_bridgeObjectRelease();
        }
        break;
      default:
        break;
    }
    v5 = *(unsigned __int8 *)(a2 + 192);
    if (v5 >= 7)
      v5 = *(_DWORD *)a2 + 7;
    switch(v5)
    {
      case 0u:
        v6 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v6;
        v7 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v7;
        v8 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v8;
        *(_BYTE *)(a1 + 192) = 0;
        return a1;
      case 1u:
        v15 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v15;
        v16 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v16;
        v17 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v17;
        v18 = 1;
        goto LABEL_20;
      case 2u:
        v19 = *(_OWORD *)(a2 + 144);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 144) = v19;
        v20 = *(_OWORD *)(a2 + 176);
        *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
        *(_OWORD *)(a1 + 176) = v20;
        v21 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v21;
        v22 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
        *(_OWORD *)(a1 + 112) = v22;
        v23 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v23;
        v24 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v24;
        v18 = 2;
        goto LABEL_20;
      case 3u:
        v25 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v25;
        v26 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v26;
        v27 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v27;
        v18 = 3;
        goto LABEL_20;
      case 4u:
        v28 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v28;
        v29 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v29;
        v30 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v30;
        v18 = 4;
        goto LABEL_20;
      case 5u:
        v31 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v31;
        v32 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v32;
        v33 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v33;
        v18 = 5;
        goto LABEL_20;
      case 6u:
        v34 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v34;
        v35 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v35;
        v36 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v36;
        v18 = 6;
LABEL_20:
        *(_BYTE *)(a1 + 192) = v18;
        break;
      default:
        v9 = *(_OWORD *)(a2 + 176);
        *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
        *(_OWORD *)(a1 + 176) = v9;
        *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
        v10 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
        *(_OWORD *)(a1 + 112) = v10;
        v11 = *(_OWORD *)(a2 + 144);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 144) = v11;
        v12 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v12;
        v13 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v13;
        v14 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v14;
        break;
    }
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for AggregationFunction.AggregationType(uint64_t a1, unsigned int a2)
{
  unsigned int v3;

  if (!a2)
    return 0;
  if (a2 >= 0xF9 && *(_BYTE *)(a1 + 193))
    return (*(_DWORD *)a1 + 249);
  v3 = *(unsigned __int8 *)(a1 + 192);
  if (v3 >= 8)
    return (v3 ^ 0xFF) + 1;
  else
    return 0;
}

uint64_t storeEnumTagSinglePayload for AggregationFunction.AggregationType(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xF8)
  {
    *(_BYTE *)(result + 192) = 0;
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)result = a2 - 249;
    if (a3 >= 0xF9)
      *(_BYTE *)(result + 193) = 1;
  }
  else
  {
    if (a3 >= 0xF9)
      *(_BYTE *)(result + 193) = 0;
    if (a2)
      *(_BYTE *)(result + 192) = -(char)a2;
  }
  return result;
}

uint64_t destructiveInjectEnumTag for AggregationFunction.AggregationType(uint64_t result, unsigned int a2)
{
  if (a2 > 6)
  {
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)result = a2 - 7;
    LOBYTE(a2) = 7;
  }
  *(_BYTE *)(result + 192) = a2;
  return result;
}

void *type metadata accessor for AggregationFunction.CodingKeys()
{
  return &unk_1E263C330;
}

uint64_t storeEnumTagSinglePayload for AggregationFunction.AggregationType.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 7 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 7) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF9)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF8)
    return ((uint64_t (*)(void))((char *)&loc_18DB2730C + 4 * byte_18DC2BF24[v4]))();
  *a1 = a2 + 7;
  return ((uint64_t (*)(void))((char *)sub_18DB27340 + 4 * byte_18DC2BF1F[v4]))();
}

uint64_t sub_18DB27340(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB27348(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB27350);
  return result;
}

uint64_t sub_18DB2735C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB27364);
  *(_BYTE *)result = a2 + 7;
  return result;
}

uint64_t sub_18DB27368(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB27370(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

void *type metadata accessor for AggregationFunction.AggregationType.CodingKeys()
{
  return &unk_1E263BE00;
}

void *type metadata accessor for AggregationFunction.AggregationType.AVGCodingKeys()
{
  return &unk_1E263BE90;
}

void *type metadata accessor for AggregationFunction.AggregationType.COUNTCodingKeys()
{
  return &unk_1E263C0D0;
}

void *type metadata accessor for AggregationFunction.AggregationType.COUNT_STARCodingKeys()
{
  return &unk_1E263C1F0;
}

void *type metadata accessor for AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  return &unk_1E263C210;
}

void *type metadata accessor for AggregationFunction.AggregationType.MAXCodingKeys()
{
  return &unk_1E263BF20;
}

void *type metadata accessor for AggregationFunction.AggregationType.MINCodingKeys()
{
  return &unk_1E263BFB0;
}

void *type metadata accessor for AggregationFunction.AggregationType.SUMCodingKeys()
{
  return &unk_1E263C040;
}

uint64_t storeEnumTagSinglePayload for AggregationFunction.AggregationType.AVGCodingKeys(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t v4;

  if ((a3 + 1) >= 0x10000)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) < 0x100)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3)
    v4 = v4;
  else
    v4 = 0;
  if (a2)
    return ((uint64_t (*)(void))((char *)sub_18DB27440 + 4 * byte_18DC2BF29[v4]))();
  else
    return ((uint64_t (*)(void))((char *)sub_18DB27460 + 4 * byte_18DC2BF2E[v4]))();
}

_BYTE *sub_18DB27440(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

_BYTE *sub_18DB27460(_BYTE *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_18DB27468(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

_WORD *sub_18DB27470(_WORD *result, __int16 a2)
{
  *result = a2;
  return result;
}

_WORD *sub_18DB27478(_WORD *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_18DB27480(_DWORD *result)
{
  *result = 0;
  return result;
}

void *type metadata accessor for AggregationFunction.AggregationType.TOTALCodingKeys()
{
  return &unk_1E263C160;
}

uint64_t getEnumTagSinglePayload for AggregationFunction.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFF)
    goto LABEL_17;
  if (a2 + 1 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 1) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 1;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 1;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 1;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 2;
  v8 = v6 - 2;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for AggregationFunction.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 1 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFF)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFE)
    return ((uint64_t (*)(void))((char *)&loc_18DB27578 + 4 * byte_18DC2BF38[v4]))();
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_18DB275AC + 4 * byte_18DC2BF33[v4]))();
}

uint64_t sub_18DB275AC(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB275B4(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB275BCLL);
  return result;
}

uint64_t sub_18DB275C8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB275D0);
  *(_BYTE *)result = a2 + 1;
  return result;
}

uint64_t sub_18DB275D4(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB275DC(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

void *type metadata accessor for Binding.CodingKeys()
{
  return &unk_1E263FCE0;
}

uint64_t getEnumTagSinglePayload for SQLExpression.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFC)
    goto LABEL_17;
  if (a2 + 4 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 4) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 4;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 4;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 4;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 5;
  v8 = v6 - 5;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpression.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 4 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 4) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFC)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFB)
    return ((uint64_t (*)(void))((char *)&loc_18DB276D4 + 4 * byte_18DC2BF42[v4]))();
  *a1 = a2 + 4;
  return ((uint64_t (*)(void))((char *)sub_18DB27708 + 4 * byte_18DC2BF3D[v4]))();
}

uint64_t sub_18DB27708(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB27710(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB27718);
  return result;
}

uint64_t sub_18DB27724(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB2772CLL);
  *(_BYTE *)result = a2 + 4;
  return result;
}

uint64_t sub_18DB27730(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB27738(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for SQLExpression.CodingKeys()
{
  return &type metadata for SQLExpression.CodingKeys;
}

_QWORD *initializeBufferWithCopyOfBuffer for SQLExpressionError(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t Node;
  uint64_t v9;
  uint64_t v11;
  uint64_t BoolExpr;
  uint64_t v13;
  uint64_t A_Expr;
  uint64_t v15;
  uint64_t NullTest;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v5 = *(_QWORD *)(a3 - 8);
  v6 = *(_DWORD *)(v5 + 80);
  if ((v6 & 0x20000) != 0)
  {
    v9 = *a2;
    *a1 = *a2;
    a1 = (_QWORD *)(v9 + ((v6 + 16) & ~(unint64_t)v6));
    swift_retain();
  }
  else
  {
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        v7 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v7 - 8) + 16))(a1, a2, v7);
        Node = type metadata accessor for PgQuery_Node(0);
        *(_QWORD *)((char *)a1 + *(int *)(Node + 20)) = *(_QWORD *)((char *)a2 + *(int *)(Node + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 1u:
        v11 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v11 - 8) + 16))(a1, a2, v11);
        BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
        *(_QWORD *)((char *)a1 + *(int *)(BoolExpr + 20)) = *(_QWORD *)((char *)a2 + *(int *)(BoolExpr + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 3u:
        v13 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v13 - 8) + 16))(a1, a2, v13);
        A_Expr = type metadata accessor for PgQuery_A_Expr(0);
        *(_QWORD *)((char *)a1 + *(int *)(A_Expr + 20)) = *(_QWORD *)((char *)a2 + *(int *)(A_Expr + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 4u:
        v15 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v15 - 8) + 16))(a1, a2, v15);
        NullTest = type metadata accessor for PgQuery_NullTest(0);
        *(_QWORD *)((char *)a1 + *(int *)(NullTest + 20)) = *(_QWORD *)((char *)a2 + *(int *)(NullTest + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 5u:
        v17 = a2[1];
        *a1 = *a2;
        a1[1] = v17;
        *((_BYTE *)a1 + 16) = *((_BYTE *)a2 + 16);
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      case 6u:
      case 0xBu:
        v18 = a2[1];
        *a1 = *a2;
        a1[1] = v18;
        v19 = a2[2];
        v20 = a2[3];
        a1[2] = v19;
        a1[3] = v20;
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      case 7u:
      case 8u:
      case 9u:
        v21 = a2[1];
        *a1 = *a2;
        a1[1] = v21;
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      case 0xAu:
        v22 = a2[1];
        *a1 = *a2;
        a1[1] = v22;
        a1[2] = a2[2];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      default:
        memcpy(a1, a2, *(_QWORD *)(v5 + 64));
        break;
    }
  }
  return a1;
}

uint64_t destroy for SQLExpressionError(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = swift_getEnumCaseMultiPayload();
  switch((int)result)
  {
    case 0:
      v3 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v3 - 8) + 8))(a1, v3);
      type metadata accessor for PgQuery_Node(0);
      return swift_release();
    case 1:
      v4 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v4 - 8) + 8))(a1, v4);
      type metadata accessor for PgQuery_BoolExpr(0);
      return swift_release();
    case 3:
      v5 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 8))(a1, v5);
      type metadata accessor for PgQuery_A_Expr(0);
      return swift_release();
    case 4:
      v6 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 8))(a1, v6);
      type metadata accessor for PgQuery_NullTest(0);
      return swift_release();
    case 5:
    case 7:
    case 8:
    case 9:
      goto LABEL_8;
    case 6:
    case 10:
    case 11:
      swift_bridgeObjectRelease();
LABEL_8:
      result = swift_bridgeObjectRelease();
      break;
    default:
      return result;
  }
  return result;
}

_QWORD *initializeWithCopy for SQLExpressionError(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t Node;
  uint64_t v8;
  uint64_t BoolExpr;
  uint64_t v10;
  uint64_t A_Expr;
  uint64_t v12;
  uint64_t NullTest;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  switch(swift_getEnumCaseMultiPayload())
  {
    case 0u:
      v6 = type metadata accessor for UnknownStorage();
      (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a1, a2, v6);
      Node = type metadata accessor for PgQuery_Node(0);
      *(_QWORD *)((char *)a1 + *(int *)(Node + 20)) = *(_QWORD *)((char *)a2 + *(int *)(Node + 20));
      swift_retain();
      goto LABEL_11;
    case 1u:
      v8 = type metadata accessor for UnknownStorage();
      (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v8 - 8) + 16))(a1, a2, v8);
      BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
      *(_QWORD *)((char *)a1 + *(int *)(BoolExpr + 20)) = *(_QWORD *)((char *)a2 + *(int *)(BoolExpr + 20));
      swift_retain();
      goto LABEL_11;
    case 3u:
      v10 = type metadata accessor for UnknownStorage();
      (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v10 - 8) + 16))(a1, a2, v10);
      A_Expr = type metadata accessor for PgQuery_A_Expr(0);
      *(_QWORD *)((char *)a1 + *(int *)(A_Expr + 20)) = *(_QWORD *)((char *)a2 + *(int *)(A_Expr + 20));
      swift_retain();
      goto LABEL_11;
    case 4u:
      v12 = type metadata accessor for UnknownStorage();
      (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v12 - 8) + 16))(a1, a2, v12);
      NullTest = type metadata accessor for PgQuery_NullTest(0);
      *(_QWORD *)((char *)a1 + *(int *)(NullTest + 20)) = *(_QWORD *)((char *)a2 + *(int *)(NullTest + 20));
      swift_retain();
      goto LABEL_11;
    case 5u:
      v14 = a2[1];
      *a1 = *a2;
      a1[1] = v14;
      *((_BYTE *)a1 + 16) = *((_BYTE *)a2 + 16);
      swift_bridgeObjectRetain();
      goto LABEL_11;
    case 6u:
    case 0xBu:
      v17 = a2[1];
      *a1 = *a2;
      a1[1] = v17;
      v18 = a2[2];
      v19 = a2[3];
      a1[2] = v18;
      a1[3] = v19;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      goto LABEL_11;
    case 7u:
    case 8u:
    case 9u:
      v15 = a2[1];
      *a1 = *a2;
      a1[1] = v15;
      swift_bridgeObjectRetain();
      goto LABEL_11;
    case 0xAu:
      v16 = a2[1];
      *a1 = *a2;
      a1[1] = v16;
      a1[2] = a2[2];
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
LABEL_11:
      swift_storeEnumTagMultiPayload();
      break;
    default:
      memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
      break;
  }
  return a1;
}

_QWORD *assignWithCopy for SQLExpressionError(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t Node;
  uint64_t v8;
  uint64_t BoolExpr;
  uint64_t v10;
  uint64_t A_Expr;
  uint64_t v12;
  uint64_t NullTest;

  if (a1 != a2)
  {
    outlined destroy of PgQuery_Alias((uint64_t)a1, (uint64_t (*)(_QWORD))type metadata accessor for SQLExpressionError);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        v6 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a1, a2, v6);
        Node = type metadata accessor for PgQuery_Node(0);
        *(_QWORD *)((char *)a1 + *(int *)(Node + 20)) = *(_QWORD *)((char *)a2 + *(int *)(Node + 20));
        swift_retain();
        goto LABEL_12;
      case 1u:
        v8 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v8 - 8) + 16))(a1, a2, v8);
        BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
        *(_QWORD *)((char *)a1 + *(int *)(BoolExpr + 20)) = *(_QWORD *)((char *)a2 + *(int *)(BoolExpr + 20));
        swift_retain();
        goto LABEL_12;
      case 3u:
        v10 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v10 - 8) + 16))(a1, a2, v10);
        A_Expr = type metadata accessor for PgQuery_A_Expr(0);
        *(_QWORD *)((char *)a1 + *(int *)(A_Expr + 20)) = *(_QWORD *)((char *)a2 + *(int *)(A_Expr + 20));
        swift_retain();
        goto LABEL_12;
      case 4u:
        v12 = type metadata accessor for UnknownStorage();
        (*(void (**)(_QWORD *, _QWORD *, uint64_t))(*(_QWORD *)(v12 - 8) + 16))(a1, a2, v12);
        NullTest = type metadata accessor for PgQuery_NullTest(0);
        *(_QWORD *)((char *)a1 + *(int *)(NullTest + 20)) = *(_QWORD *)((char *)a2 + *(int *)(NullTest + 20));
        swift_retain();
        goto LABEL_12;
      case 5u:
        *a1 = *a2;
        a1[1] = a2[1];
        *((_BYTE *)a1 + 16) = *((_BYTE *)a2 + 16);
        swift_bridgeObjectRetain();
        goto LABEL_12;
      case 6u:
      case 0xBu:
        *a1 = *a2;
        a1[1] = a2[1];
        a1[2] = a2[2];
        a1[3] = a2[3];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        goto LABEL_12;
      case 7u:
      case 8u:
      case 9u:
        *a1 = *a2;
        a1[1] = a2[1];
        swift_bridgeObjectRetain();
        goto LABEL_12;
      case 0xAu:
        *a1 = *a2;
        a1[1] = a2[1];
        a1[2] = a2[2];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
LABEL_12:
        swift_storeEnumTagMultiPayload();
        break;
      default:
        memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
        break;
    }
  }
  return a1;
}

uint64_t type metadata accessor for SQLExpressionError()
{
  uint64_t result;

  result = type metadata singleton initialization cache for SQLExpressionError;
  if (!type metadata singleton initialization cache for SQLExpressionError)
    return swift_getSingletonMetadata();
  return result;
}

char *initializeWithTake for SQLExpressionError(char *a1, char *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t Node;
  uint64_t v8;
  uint64_t BoolExpr;
  uint64_t v10;
  uint64_t A_Expr;
  uint64_t v12;
  uint64_t NullTest;

  switch(swift_getEnumCaseMultiPayload())
  {
    case 0u:
      v6 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v6 - 8) + 32))(a1, a2, v6);
      Node = type metadata accessor for PgQuery_Node(0);
      *(_QWORD *)&a1[*(int *)(Node + 20)] = *(_QWORD *)&a2[*(int *)(Node + 20)];
      goto LABEL_7;
    case 1u:
      v8 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v8 - 8) + 32))(a1, a2, v8);
      BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
      *(_QWORD *)&a1[*(int *)(BoolExpr + 20)] = *(_QWORD *)&a2[*(int *)(BoolExpr + 20)];
      goto LABEL_7;
    case 3u:
      v10 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v10 - 8) + 32))(a1, a2, v10);
      A_Expr = type metadata accessor for PgQuery_A_Expr(0);
      *(_QWORD *)&a1[*(int *)(A_Expr + 20)] = *(_QWORD *)&a2[*(int *)(A_Expr + 20)];
      goto LABEL_7;
    case 4u:
      v12 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v12 - 8) + 32))(a1, a2, v12);
      NullTest = type metadata accessor for PgQuery_NullTest(0);
      *(_QWORD *)&a1[*(int *)(NullTest + 20)] = *(_QWORD *)&a2[*(int *)(NullTest + 20)];
LABEL_7:
      swift_storeEnumTagMultiPayload();
      break;
    default:
      memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
      break;
  }
  return a1;
}

char *assignWithTake for SQLExpressionError(char *a1, char *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t Node;
  uint64_t v8;
  uint64_t BoolExpr;
  uint64_t v10;
  uint64_t A_Expr;
  uint64_t v12;
  uint64_t NullTest;

  if (a1 != a2)
  {
    outlined destroy of PgQuery_Alias((uint64_t)a1, (uint64_t (*)(_QWORD))type metadata accessor for SQLExpressionError);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        v6 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v6 - 8) + 32))(a1, a2, v6);
        Node = type metadata accessor for PgQuery_Node(0);
        *(_QWORD *)&a1[*(int *)(Node + 20)] = *(_QWORD *)&a2[*(int *)(Node + 20)];
        goto LABEL_8;
      case 1u:
        v8 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v8 - 8) + 32))(a1, a2, v8);
        BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
        *(_QWORD *)&a1[*(int *)(BoolExpr + 20)] = *(_QWORD *)&a2[*(int *)(BoolExpr + 20)];
        goto LABEL_8;
      case 3u:
        v10 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v10 - 8) + 32))(a1, a2, v10);
        A_Expr = type metadata accessor for PgQuery_A_Expr(0);
        *(_QWORD *)&a1[*(int *)(A_Expr + 20)] = *(_QWORD *)&a2[*(int *)(A_Expr + 20)];
        goto LABEL_8;
      case 4u:
        v12 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v12 - 8) + 32))(a1, a2, v12);
        NullTest = type metadata accessor for PgQuery_NullTest(0);
        *(_QWORD *)&a1[*(int *)(NullTest + 20)] = *(_QWORD *)&a2[*(int *)(NullTest + 20)];
LABEL_8:
        swift_storeEnumTagMultiPayload();
        break;
      default:
        memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
        break;
    }
  }
  return a1;
}

uint64_t type metadata completion function for SQLExpressionError()
{
  uint64_t result;
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  result = type metadata accessor for PgQuery_Node(319);
  if (v1 <= 0x3F)
  {
    result = type metadata accessor for PgQuery_BoolExpr(319);
    if (v2 <= 0x3F)
    {
      result = type metadata accessor for PgQuery_A_Expr(319);
      if (v3 <= 0x3F)
      {
        result = type metadata accessor for PgQuery_NullTest(319);
        if (v4 <= 0x3F)
        {
          swift_initEnumMetadataMultiPayload();
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t specialized ColumnResolver.init(schemas:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int64_t v11;
  unint64_t v12;
  int64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  char v24;
  unint64_t v25;
  uint64_t v26;
  _BOOL8 v27;
  uint64_t v28;
  char v29;
  unint64_t v30;
  unint64_t v31;
  char v32;
  _QWORD *v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  unint64_t v40;
  int64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  int64_t v54;
  unint64_t v55;
  int64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t *v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  int64_t v73;
  unint64_t v74;
  unint64_t v75;
  int64_t v76;
  unint64_t v77;
  int64_t v78;
  uint64_t *v79;
  uint64_t v80;
  void *v81;
  unint64_t v82;
  Swift::String v83;
  char isUniquelyReferenced_nonNull_native;
  char v85;
  unint64_t v86;
  uint64_t v87;
  _BOOL8 v88;
  char v89;
  unint64_t v90;
  char v91;
  uint64_t v92;
  uint64_t v93;
  Swift::String v94;
  Swift::String v95;
  Swift::String v96;
  char v97;
  char v98;
  unint64_t v99;
  uint64_t v100;
  _BOOL8 v101;
  char v102;
  unint64_t v103;
  char v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  void *v108;
  unint64_t v109;
  unint64_t v110;
  int64_t v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  int64_t v115;
  unint64_t v116;
  unint64_t v117;
  uint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  _QWORD *v121;
  unint64_t v122;
  int64_t v123;
  uint64_t v124;
  char *v125;
  char *v126;
  unint64_t v127;
  int64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  uint64_t v136;
  _QWORD *v137;
  unint64_t v138;
  int64_t v139;
  uint64_t result;
  unint64_t v141;
  int64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  int64_t v147;
  unint64_t v148;
  int64_t v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  int64_t v158;
  uint64_t v159;
  int64_t v160;
  unint64_t v161;
  char v162;
  unint64_t v163[2];
  uint64_t v164;

  v146 = *(_QWORD *)(a1 + 16);
  if (!v146)
  {
    v2 = MEMORY[0x1E0DEE9E0];
    goto LABEL_76;
  }
  v151 = a1 + 32;
  swift_bridgeObjectRetain();
  v1 = 0;
  v2 = MEMORY[0x1E0DEE9E0];
LABEL_4:
  v3 = *(_QWORD *)(v151 + 24 * v1 + 16);
  v154 = v1 + 1;
  v156 = v3 + 64;
  v4 = 1 << *(_BYTE *)(v3 + 32);
  if (v4 < 64)
    v5 = ~(-1 << v4);
  else
    v5 = -1;
  v6 = v5 & *(_QWORD *)(v3 + 64);
  v158 = (unint64_t)(v4 + 63) >> 6;
  swift_bridgeObjectRetain();
  v159 = v3;
  swift_bridgeObjectRetain_n();
  v7 = 0;
  while (1)
  {
    if (v6)
    {
      v8 = __clz(__rbit64(v6));
      v9 = (v6 - 1) & v6;
      v10 = v8 | (v7 << 6);
      goto LABEL_26;
    }
    v11 = v7 + 1;
    if (__OFADD__(v7, 1))
      goto LABEL_201;
    if (v11 >= v158)
    {
LABEL_3:
      swift_bridgeObjectRelease();
      swift_release();
      swift_bridgeObjectRelease();
      v1 = v154;
      if (v154 == v146)
      {
        swift_bridgeObjectRelease();
LABEL_76:
        v57 = specialized _NativeDictionary.filter(_:)(v2);
        swift_bridgeObjectRelease();
        _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSDySSSiG_SSs5NeverOTg5181_s14BiomeSQLParser14ColumnResolver33_B787555787B9EFBBEFB0C9C5225A4FB7LLV7schemasADSayAA6SchemaVG_tKcfcS2S3key_Si5valuet_tcfu_32a168a102879cc1a6a91172b0770f0c91SSAI_SiAJtSSTf3nnnpk_nTf1cn_n(v57);
        v59 = v58;
        swift_release();
        v60 = Set.init(minimumCapacity:)();
        v164 = v60;
        v61 = *(_QWORD *)(v59 + 16);
        if (v61)
        {
          v62 = (unint64_t *)(v59 + 40);
          do
          {
            v63 = *(v62 - 1);
            v64 = *v62;
            swift_bridgeObjectRetain();
            specialized Set._Variant.insert(_:)(v163, v63, v64);
            swift_bridgeObjectRelease();
            v62 += 2;
            --v61;
          }
          while (v61);
          swift_bridgeObjectRelease();
          v65 = v164;
          if (v146)
            goto LABEL_80;
        }
        else
        {
          v65 = v60;
          swift_bridgeObjectRelease();
          if (v146)
          {
LABEL_80:
            v66 = 0;
            v67 = MEMORY[0x1E0DEE9E0];
            v143 = a1 + 32;
            v152 = v65;
            while (1)
            {
              v68 = (unint64_t *)(v143 + 24 * v66);
              v153 = *v68;
              v155 = v68[1];
              v69 = v68[2];
              v145 = v66 + 1;
              v148 = v69 + 64;
              v70 = 1 << *(_BYTE *)(v69 + 32);
              v71 = v70 < 64 ? ~(-1 << v70) : -1;
              v72 = v71 & *(_QWORD *)(v69 + 64);
              v150 = (unint64_t)(v70 + 63) >> 6;
              swift_bridgeObjectRetain();
              v157 = v69;
              swift_bridgeObjectRetain_n();
              v73 = 0;
              while (v72)
              {
                v74 = __clz(__rbit64(v72));
                v72 &= v72 - 1;
                v160 = v73;
                v75 = v74 | (v73 << 6);
LABEL_101:
                v79 = (uint64_t *)(*(_QWORD *)(v157 + 48) + 16 * v75);
                v80 = *v79;
                v81 = (void *)v79[1];
                v162 = *(_BYTE *)(*(_QWORD *)(v157 + 56) + v75);
                swift_bridgeObjectRetain();
                if ((specialized Set.contains(_:)(v80, (uint64_t)v81, v65) & 1) != 0)
                {
                  v82 = v67;
                  goto LABEL_113;
                }
                v83 = String.lowercased()();
                isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
                v163[0] = v67;
                v86 = specialized __RawDictionaryStorage.find<A>(_:)();
                v87 = *(_QWORD *)(v67 + 16);
                v88 = (v85 & 1) == 0;
                if (__OFADD__(v87, v88))
                  goto LABEL_202;
                v89 = v85;
                if (*(_QWORD *)(v67 + 24) < v87 + v88)
                {
                  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)();
                  v82 = v163[0];
                  v90 = specialized __RawDictionaryStorage.find<A>(_:)();
                  if ((v89 & 1) != (v91 & 1))
                    goto LABEL_214;
                  v86 = v90;
                  if ((v89 & 1) == 0)
                    goto LABEL_110;
                  goto LABEL_107;
                }
                if ((isUniquelyReferenced_nonNull_native & 1) != 0)
                {
                  v82 = v67;
                  if ((v85 & 1) == 0)
                    goto LABEL_110;
LABEL_107:
                  *(_BYTE *)(*(_QWORD *)(v82 + 56) + v86) = v162;
                  goto LABEL_112;
                }
                __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
                v124 = static _DictionaryStorage.copy(original:)();
                v82 = v124;
                if (!*(_QWORD *)(v67 + 16))
                  goto LABEL_192;
                v125 = (char *)(v124 + 64);
                v126 = (char *)(v67 + 64);
                v127 = (unint64_t)((1 << *(_BYTE *)(v82 + 32)) + 63) >> 6;
                v141 = v67 + 64;
                if (v82 != v67 || v125 >= &v126[8 * v127])
                  memmove(v125, v126, 8 * v127);
                v128 = 0;
                *(_QWORD *)(v82 + 16) = *(_QWORD *)(v67 + 16);
                v129 = 1 << *(_BYTE *)(v67 + 32);
                if (v129 < 64)
                  v130 = ~(-1 << v129);
                else
                  v130 = -1;
                v131 = v130 & *(_QWORD *)(v67 + 64);
                v142 = (unint64_t)(v129 + 63) >> 6;
                while (1)
                {
                  if (v131)
                  {
                    v132 = __clz(__rbit64(v131));
                    v131 &= v131 - 1;
                    v133 = v132 | (v128 << 6);
                    goto LABEL_169;
                  }
                  v35 = __OFADD__(v128++, 1);
                  if (v35)
                    goto LABEL_210;
                  if (v128 >= v142)
                    goto LABEL_192;
                  v138 = *(_QWORD *)(v141 + 8 * v128);
                  if (!v138)
                    break;
LABEL_187:
                  v131 = (v138 - 1) & v138;
                  v133 = __clz(__rbit64(v138)) + (v128 << 6);
LABEL_169:
                  v134 = (uint64_t *)(*(_QWORD *)(v67 + 48) + 16 * v133);
                  v136 = *v134;
                  v135 = v134[1];
                  LOBYTE(v134) = *(_BYTE *)(*(_QWORD *)(v67 + 56) + v133);
                  v137 = (_QWORD *)(*(_QWORD *)(v82 + 48) + 16 * v133);
                  *v137 = v136;
                  v137[1] = v135;
                  *(_BYTE *)(*(_QWORD *)(v82 + 56) + v133) = (_BYTE)v134;
                  swift_bridgeObjectRetain();
                }
                v139 = v128 + 1;
                if (v128 + 1 >= v142)
                  goto LABEL_192;
                v138 = *(_QWORD *)(v141 + 8 * v139);
                if (v138)
                  goto LABEL_186;
                v139 = v128 + 2;
                if (v128 + 2 >= v142)
                  goto LABEL_192;
                v138 = *(_QWORD *)(v141 + 8 * v139);
                if (v138)
                  goto LABEL_186;
                v139 = v128 + 3;
                if (v128 + 3 >= v142)
                  goto LABEL_192;
                v138 = *(_QWORD *)(v141 + 8 * v139);
                if (v138)
                  goto LABEL_186;
                v139 = v128 + 4;
                if (v128 + 4 >= v142)
                  goto LABEL_192;
                v138 = *(_QWORD *)(v141 + 8 * v139);
                if (v138)
                  goto LABEL_186;
                v139 = v128 + 5;
                if (v128 + 5 >= v142)
                  goto LABEL_192;
                v138 = *(_QWORD *)(v141 + 8 * v139);
                if (v138)
                  goto LABEL_186;
                v139 = v128 + 6;
                if (v128 + 6 >= v142)
                  goto LABEL_192;
                v138 = *(_QWORD *)(v141 + 8 * v139);
                if (v138)
                {
LABEL_186:
                  v128 = v139;
                  goto LABEL_187;
                }
                while (1)
                {
                  v128 = v139 + 1;
                  if (__OFADD__(v139, 1))
                    goto LABEL_213;
                  if (v128 >= v142)
                    break;
                  v138 = *(_QWORD *)(v141 + 8 * v128);
                  ++v139;
                  if (v138)
                    goto LABEL_187;
                }
LABEL_192:
                swift_bridgeObjectRelease();
                if ((v89 & 1) != 0)
                  goto LABEL_107;
LABEL_110:
                *(_QWORD *)(v82 + 8 * (v86 >> 6) + 64) |= 1 << v86;
                *(Swift::String *)(*(_QWORD *)(v82 + 48) + 16 * v86) = v83;
                *(_BYTE *)(*(_QWORD *)(v82 + 56) + v86) = v162;
                v92 = *(_QWORD *)(v82 + 16);
                v35 = __OFADD__(v92, 1);
                v93 = v92 + 1;
                if (v35)
                  goto LABEL_205;
                *(_QWORD *)(v82 + 16) = v93;
                swift_bridgeObjectRetain();
LABEL_112:
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
LABEL_113:
                v163[0] = v153;
                v163[1] = v155;
                swift_bridgeObjectRetain();
                v94._countAndFlagsBits = 46;
                v94._object = (void *)0xE100000000000000;
                String.append(_:)(v94);
                v95._countAndFlagsBits = v80;
                v95._object = v81;
                String.append(_:)(v95);
                swift_bridgeObjectRelease();
                v96 = String.lowercased()();
                swift_bridgeObjectRelease();
                v97 = swift_isUniquelyReferenced_nonNull_native();
                v163[0] = v82;
                v99 = specialized __RawDictionaryStorage.find<A>(_:)();
                v100 = *(_QWORD *)(v82 + 16);
                v101 = (v98 & 1) == 0;
                if (__OFADD__(v100, v101))
                  goto LABEL_199;
                v102 = v98;
                if (*(_QWORD *)(v82 + 24) < v100 + v101)
                {
                  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)();
                  v67 = v163[0];
                  v103 = specialized __RawDictionaryStorage.find<A>(_:)();
                  if ((v102 & 1) != (v104 & 1))
                    goto LABEL_214;
                  v99 = v103;
                  if ((v102 & 1) != 0)
                    goto LABEL_86;
                  goto LABEL_120;
                }
                if ((v97 & 1) != 0)
                {
                  v67 = v82;
                  if ((v98 & 1) != 0)
                    goto LABEL_86;
                  goto LABEL_120;
                }
                __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
                v107 = static _DictionaryStorage.copy(original:)();
                v67 = v107;
                if (!*(_QWORD *)(v82 + 16))
                  goto LABEL_158;
                v108 = (void *)(v107 + 64);
                v109 = v82 + 64;
                v110 = (unint64_t)((1 << *(_BYTE *)(v67 + 32)) + 63) >> 6;
                if (v67 != v82 || (unint64_t)v108 >= v109 + 8 * v110)
                  memmove(v108, (const void *)(v82 + 64), 8 * v110);
                v111 = 0;
                *(_QWORD *)(v67 + 16) = *(_QWORD *)(v82 + 16);
                v112 = 1 << *(_BYTE *)(v82 + 32);
                if (v112 < 64)
                  v113 = ~(-1 << v112);
                else
                  v113 = -1;
                v114 = v113 & *(_QWORD *)(v82 + 64);
                v115 = (unint64_t)(v112 + 63) >> 6;
                while (2)
                {
                  if (v114)
                  {
                    v116 = __clz(__rbit64(v114));
                    v114 &= v114 - 1;
                    v117 = v116 | (v111 << 6);
LABEL_135:
                    v118 = (uint64_t *)(*(_QWORD *)(v82 + 48) + 16 * v117);
                    v120 = *v118;
                    v119 = v118[1];
                    LOBYTE(v118) = *(_BYTE *)(*(_QWORD *)(v82 + 56) + v117);
                    v121 = (_QWORD *)(*(_QWORD *)(v67 + 48) + 16 * v117);
                    *v121 = v120;
                    v121[1] = v119;
                    *(_BYTE *)(*(_QWORD *)(v67 + 56) + v117) = (_BYTE)v118;
                    swift_bridgeObjectRetain();
                    continue;
                  }
                  break;
                }
                v35 = __OFADD__(v111++, 1);
                if (v35)
                  goto LABEL_209;
                if (v111 >= v115)
                  goto LABEL_158;
                v122 = *(_QWORD *)(v109 + 8 * v111);
                if (v122)
                {
LABEL_153:
                  v114 = (v122 - 1) & v122;
                  v117 = __clz(__rbit64(v122)) + (v111 << 6);
                  goto LABEL_135;
                }
                v123 = v111 + 1;
                if (v111 + 1 >= v115)
                  goto LABEL_158;
                v122 = *(_QWORD *)(v109 + 8 * v123);
                if (v122)
                  goto LABEL_152;
                v123 = v111 + 2;
                if (v111 + 2 >= v115)
                  goto LABEL_158;
                v122 = *(_QWORD *)(v109 + 8 * v123);
                if (v122)
                  goto LABEL_152;
                v123 = v111 + 3;
                if (v111 + 3 >= v115)
                  goto LABEL_158;
                v122 = *(_QWORD *)(v109 + 8 * v123);
                if (v122)
                  goto LABEL_152;
                v123 = v111 + 4;
                if (v111 + 4 >= v115)
                  goto LABEL_158;
                v122 = *(_QWORD *)(v109 + 8 * v123);
                if (v122)
                  goto LABEL_152;
                v123 = v111 + 5;
                if (v111 + 5 >= v115)
                  goto LABEL_158;
                v122 = *(_QWORD *)(v109 + 8 * v123);
                if (v122)
                  goto LABEL_152;
                v123 = v111 + 6;
                if (v111 + 6 >= v115)
                  goto LABEL_158;
                v122 = *(_QWORD *)(v109 + 8 * v123);
                if (v122)
                {
LABEL_152:
                  v111 = v123;
                  goto LABEL_153;
                }
                while (1)
                {
                  v111 = v123 + 1;
                  if (__OFADD__(v123, 1))
                    goto LABEL_212;
                  if (v111 >= v115)
                    break;
                  v122 = *(_QWORD *)(v109 + 8 * v111);
                  ++v123;
                  if (v122)
                    goto LABEL_153;
                }
LABEL_158:
                swift_bridgeObjectRelease();
                if ((v102 & 1) != 0)
                {
LABEL_86:
                  *(_BYTE *)(*(_QWORD *)(v67 + 56) + v99) = v162;
                  goto LABEL_87;
                }
LABEL_120:
                *(_QWORD *)(v67 + 8 * (v99 >> 6) + 64) |= 1 << v99;
                *(Swift::String *)(*(_QWORD *)(v67 + 48) + 16 * v99) = v96;
                *(_BYTE *)(*(_QWORD *)(v67 + 56) + v99) = v162;
                v105 = *(_QWORD *)(v67 + 16);
                v35 = __OFADD__(v105, 1);
                v106 = v105 + 1;
                if (v35)
                  goto LABEL_203;
                *(_QWORD *)(v67 + 16) = v106;
                swift_bridgeObjectRetain();
LABEL_87:
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                v65 = v152;
                v73 = v160;
              }
              v35 = __OFADD__(v73, 1);
              v76 = v73 + 1;
              if (v35)
                goto LABEL_204;
              if (v76 < v150)
                break;
LABEL_81:
              swift_bridgeObjectRelease();
              swift_release();
              swift_bridgeObjectRelease();
              v66 = v145;
              if (v145 == v146)
                return v67;
            }
            v77 = *(_QWORD *)(v148 + 8 * v76);
            if (!v77)
            {
              v78 = v76 + 1;
              if (v76 + 1 >= v150)
                goto LABEL_81;
              v77 = *(_QWORD *)(v148 + 8 * v78);
              if (!v77)
              {
                v78 = v76 + 2;
                if (v76 + 2 >= v150)
                  goto LABEL_81;
                v77 = *(_QWORD *)(v148 + 8 * v78);
                if (!v77)
                {
                  v78 = v76 + 3;
                  if (v76 + 3 >= v150)
                    goto LABEL_81;
                  v77 = *(_QWORD *)(v148 + 8 * v78);
                  if (!v77)
                  {
                    while (1)
                    {
                      v76 = v78 + 1;
                      if (__OFADD__(v78, 1))
                        break;
                      if (v76 >= v150)
                        goto LABEL_81;
                      v77 = *(_QWORD *)(v148 + 8 * v76);
                      ++v78;
                      if (v77)
                        goto LABEL_100;
                    }
LABEL_207:
                    __break(1u);
LABEL_208:
                    __break(1u);
LABEL_209:
                    __break(1u);
LABEL_210:
                    __break(1u);
                    goto LABEL_211;
                  }
                }
              }
              v76 = v78;
            }
LABEL_100:
            v72 = (v77 - 1) & v77;
            v160 = v76;
            v75 = __clz(__rbit64(v77)) + (v76 << 6);
            goto LABEL_101;
          }
        }
        return MEMORY[0x1E0DEE9E0];
      }
      goto LABEL_4;
    }
    v12 = *(_QWORD *)(v156 + 8 * v11);
    ++v7;
    if (!v12)
    {
      v7 = v11 + 1;
      if (v11 + 1 >= v158)
        goto LABEL_3;
      v12 = *(_QWORD *)(v156 + 8 * v7);
      if (!v12)
      {
        v7 = v11 + 2;
        if (v11 + 2 >= v158)
          goto LABEL_3;
        v12 = *(_QWORD *)(v156 + 8 * v7);
        if (!v12)
        {
          v13 = v11 + 3;
          if (v13 >= v158)
            goto LABEL_3;
          v12 = *(_QWORD *)(v156 + 8 * v13);
          if (!v12)
          {
            while (1)
            {
              v7 = v13 + 1;
              if (__OFADD__(v13, 1))
                goto LABEL_206;
              if (v7 >= v158)
                goto LABEL_3;
              v12 = *(_QWORD *)(v156 + 8 * v7);
              ++v13;
              if (v12)
                goto LABEL_25;
            }
          }
          v7 = v13;
        }
      }
    }
LABEL_25:
    v9 = (v12 - 1) & v12;
    v10 = __clz(__rbit64(v12)) + (v7 << 6);
LABEL_26:
    v14 = (uint64_t *)(*(_QWORD *)(v159 + 48) + 16 * v10);
    v15 = *v14;
    v16 = v14[1];
    v17 = *(_QWORD *)(v2 + 16);
    swift_bridgeObjectRetain();
    if (v17)
    {
      swift_bridgeObjectRetain();
      v18 = specialized __RawDictionaryStorage.find<A>(_:)();
      if ((v19 & 1) != 0)
        v20 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8 * v18);
      else
        v20 = 0;
      swift_bridgeObjectRelease();
      v21 = v20 + 1;
      if (__OFADD__(v20, 1))
      {
        __break(1u);
LABEL_198:
        __break(1u);
LABEL_199:
        __break(1u);
LABEL_200:
        __break(1u);
LABEL_201:
        __break(1u);
LABEL_202:
        __break(1u);
LABEL_203:
        __break(1u);
LABEL_204:
        __break(1u);
LABEL_205:
        __break(1u);
LABEL_206:
        __break(1u);
        goto LABEL_207;
      }
    }
    else
    {
      v21 = 1;
    }
    v161 = v9;
    v22 = swift_isUniquelyReferenced_nonNull_native();
    v163[0] = v2;
    v23 = v15;
    v25 = specialized __RawDictionaryStorage.find<A>(_:)();
    v26 = *(_QWORD *)(v2 + 16);
    v27 = (v24 & 1) == 0;
    v28 = v26 + v27;
    if (__OFADD__(v26, v27))
      goto LABEL_198;
    v29 = v24;
    if (*(_QWORD *)(v2 + 24) >= v28)
      break;
    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v28, v22);
    v30 = v163[0];
    v31 = specialized __RawDictionaryStorage.find<A>(_:)();
    if ((v29 & 1) != (v32 & 1))
      goto LABEL_214;
    v25 = v31;
    if ((v29 & 1) != 0)
    {
LABEL_8:
      *(_QWORD *)(*(_QWORD *)(v30 + 56) + 8 * v25) = v21;
      goto LABEL_9;
    }
LABEL_39:
    *(_QWORD *)(v30 + 8 * (v25 >> 6) + 64) |= 1 << v25;
    v33 = (_QWORD *)(*(_QWORD *)(v30 + 48) + 16 * v25);
    *v33 = v23;
    v33[1] = v16;
    *(_QWORD *)(*(_QWORD *)(v30 + 56) + 8 * v25) = v21;
    v34 = *(_QWORD *)(v30 + 16);
    v35 = __OFADD__(v34, 1);
    v36 = v34 + 1;
    if (v35)
      goto LABEL_200;
    *(_QWORD *)(v30 + 16) = v36;
    swift_bridgeObjectRetain();
LABEL_9:
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    v2 = v30;
    v6 = v161;
  }
  if ((v22 & 1) != 0)
  {
    v30 = v2;
    if ((v24 & 1) != 0)
      goto LABEL_8;
    goto LABEL_39;
  }
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Int>);
  v37 = static _DictionaryStorage.copy(original:)();
  v30 = v37;
  if (!*(_QWORD *)(v2 + 16))
  {
LABEL_72:
    swift_bridgeObjectRelease();
    if ((v29 & 1) != 0)
      goto LABEL_8;
    goto LABEL_39;
  }
  v38 = (char *)(v37 + 64);
  v39 = (char *)(v2 + 64);
  v40 = (unint64_t)((1 << *(_BYTE *)(v30 + 32)) + 63) >> 6;
  v144 = v2 + 64;
  if (v30 != v2 || v38 >= &v39[8 * v40])
    memmove(v38, v39, 8 * v40);
  v41 = 0;
  *(_QWORD *)(v30 + 16) = *(_QWORD *)(v2 + 16);
  v42 = 1 << *(_BYTE *)(v2 + 32);
  if (v42 < 64)
    v43 = ~(-1 << v42);
  else
    v43 = -1;
  v44 = v43 & *(_QWORD *)(v2 + 64);
  v147 = (unint64_t)(v42 + 63) >> 6;
  while (2)
  {
    if (v44)
    {
      v45 = __clz(__rbit64(v44));
      v44 &= v44 - 1;
      v46 = v45 | (v41 << 6);
LABEL_50:
      v47 = 16 * v46;
      v48 = (uint64_t *)(*(_QWORD *)(v2 + 48) + 16 * v46);
      v50 = *v48;
      v49 = v48[1];
      v51 = 8 * v46;
      v52 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + v51);
      v53 = (_QWORD *)(*(_QWORD *)(v30 + 48) + v47);
      *v53 = v50;
      v53[1] = v49;
      *(_QWORD *)(*(_QWORD *)(v30 + 56) + v51) = v52;
      swift_bridgeObjectRetain();
      continue;
    }
    break;
  }
  v54 = v41 + 1;
  if (__OFADD__(v41, 1))
    goto LABEL_208;
  if (v54 >= v147)
    goto LABEL_72;
  v55 = *(_QWORD *)(v144 + 8 * v54);
  ++v41;
  if (v55)
    goto LABEL_71;
  v41 = v54 + 1;
  if (v54 + 1 >= v147)
    goto LABEL_72;
  v55 = *(_QWORD *)(v144 + 8 * v41);
  if (v55)
    goto LABEL_71;
  v41 = v54 + 2;
  if (v54 + 2 >= v147)
    goto LABEL_72;
  v55 = *(_QWORD *)(v144 + 8 * v41);
  if (v55)
    goto LABEL_71;
  v41 = v54 + 3;
  if (v54 + 3 >= v147)
    goto LABEL_72;
  v55 = *(_QWORD *)(v144 + 8 * v41);
  if (v55)
    goto LABEL_71;
  v41 = v54 + 4;
  if (v54 + 4 >= v147)
    goto LABEL_72;
  v55 = *(_QWORD *)(v144 + 8 * v41);
  if (v55)
    goto LABEL_71;
  v41 = v54 + 5;
  if (v54 + 5 >= v147)
    goto LABEL_72;
  v55 = *(_QWORD *)(v144 + 8 * v41);
  if (v55)
  {
LABEL_71:
    v44 = (v55 - 1) & v55;
    v46 = __clz(__rbit64(v55)) + (v41 << 6);
    goto LABEL_50;
  }
  v56 = v54 + 6;
  if (v56 >= v147)
    goto LABEL_72;
  v55 = *(_QWORD *)(v144 + 8 * v56);
  if (v55)
  {
    v41 = v56;
    goto LABEL_71;
  }
  while (1)
  {
    v41 = v56 + 1;
    if (__OFADD__(v56, 1))
      break;
    if (v41 >= v147)
      goto LABEL_72;
    v55 = *(_QWORD *)(v144 + 8 * v41);
    ++v56;
    if (v55)
      goto LABEL_71;
  }
LABEL_211:
  __break(1u);
LABEL_212:
  __break(1u);
LABEL_213:
  __break(1u);
LABEL_214:
  result = KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
  __break(1u);
  return result;
}

uint64_t specialized SQLExpression.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  char v5;

  if (a1 == 0xD000000000000010 && a2 == 0x800000018DCD1200
    || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x79546E7275746572 && a2 == 0xEA00000000006570
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x800000018DCD1220
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x73676E69646E6962 && a2 == 0xE800000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 7106931 && a2 == 0xE300000000000000)
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else
  {
    v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v5 & 1) != 0)
      return 4;
    else
      return 5;
  }
}

uint64_t specialized Binding.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 1701667182 && a2 == 0xE400000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6570795461746164 && a2 == 0xE800000000000000)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t specialized AggregationFunction.AggregationType.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 4675137 && a2 == 0xE300000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x544E554F43 && a2 == 0xE500000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x54535F544E554F43 && a2 == 0xEA00000000005241
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x4F435F50554F5247 && a2 == 0xEC0000005441434ELL
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 5783885 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else if (a1 == 5130573 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 5;
  }
  else if (a1 == 5068115 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 6;
  }
  else if (a1 == 0x4C41544F54 && a2 == 0xE500000000000000)
  {
    swift_bridgeObjectRelease();
    return 7;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 7;
    else
      return 8;
  }
}

uint64_t specialized AggregationFunction.AggregationType.GROUP_CONCATCodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 0x6973736572707865 && a2 == 0xEA00000000006E6FLL;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6F74617261706573 && a2 == 0xE900000000000072)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t specialized AggregationFunction.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 0x7461676572676761 && a2 == 0xEF657079546E6F69;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x79546E7275746572 && a2 == 0xEA00000000006570)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

unint64_t lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError()
{
  unint64_t result;
  uint64_t v1;

  result = lazy protocol witness table cache variable for type SQLExpressionError and conformance SQLExpressionError;
  if (!lazy protocol witness table cache variable for type SQLExpressionError and conformance SQLExpressionError)
  {
    v1 = type metadata accessor for SQLExpressionError();
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLExpressionError, v1);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpressionError and conformance SQLExpressionError);
  }
  return result;
}

uint64_t __swift_deallocate_boxed_opaque_existential_1(uint64_t result)
{
  if ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 24) - 8) + 80) & 0x20000) != 0)
    JUMPOUT(0x193FED860);
  return result;
}

uint64_t sub_18DB2A614()
{
  uint64_t v0;

  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 16);
  return swift_deallocObject();
}

uint64_t sub_18DB2A638()
{
  uint64_t v0;

  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 16);
  return swift_deallocObject();
}

uint64_t sub_18DB2A65C()
{
  uint64_t v0;

  if (*(_QWORD *)(v0 + 40))
    __swift_destroy_boxed_opaque_existential_1Tm(v0 + 16);
  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 56);
  swift_bridgeObjectRelease();
  return swift_deallocObject();
}

uint64_t objectdestroyTm()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return swift_deallocObject();
}

_QWORD *partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  return partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)(a1, a2, a3);
}

{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *result;

  result = buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(a3, a1, v3[2], v3[3], v3[4], v3[5]);
  if (v4)
    *a2 = v4;
  return result;
}

uint64_t sub_18DB2A718()
{
  uint64_t v0;
  uint64_t v1;

  v1 = v0 + 16;
  switch(*(_BYTE *)(v0 + 208))
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
      __swift_destroy_boxed_opaque_existential_1Tm(v1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      goto LABEL_3;
    case 2:
      __swift_destroy_boxed_opaque_existential_1Tm(v1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(_QWORD *)(v0 + 136))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v0 + 112);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
LABEL_3:
        swift_bridgeObjectRelease();
      }
      break;
    default:
      break;
  }
  swift_bridgeObjectRelease();
  return swift_deallocObject();
}

unint64_t lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLParserError and conformance SQLParserError;
  if (!lazy protocol witness table cache variable for type SQLParserError and conformance SQLParserError)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLParserError, &type metadata for SQLParserError);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLParserError and conformance SQLParserError);
  }
  return result;
}

uint64_t destroy for SQLExpressionAggregationFunction(uint64_t a1)
{
  switch(*(_BYTE *)(a1 + 192))
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
      __swift_destroy_boxed_opaque_existential_1Tm(a1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      goto LABEL_3;
    case 2:
      __swift_destroy_boxed_opaque_existential_1Tm(a1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(_QWORD *)(a1 + 120))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 96);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
LABEL_3:
        swift_bridgeObjectRelease();
      }
      break;
    default:
      return swift_bridgeObjectRelease();
  }
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLExpressionAggregationFunction(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v46;
  __int128 v47;
  __int128 v48;

  switch(*(_BYTE *)(a2 + 192))
  {
    case 0:
      v4 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v4;
      (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
      v5 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 48) = v5;
      *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
      v6 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v6;
      v7 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = v7;
      *(_BYTE *)(a1 + 192) = 0;
      goto LABEL_12;
    case 1:
      v14 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v14;
      (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
      v15 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 48) = v15;
      *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
      v16 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v16;
      v17 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = v17;
      v18 = 1;
      goto LABEL_11;
    case 2:
      v19 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v19;
      (**(void (***)(uint64_t, uint64_t))(v19 - 8))(a1, a2);
      v20 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 48) = v20;
      *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
      v21 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v21;
      v22 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = v22;
      v23 = *(_QWORD *)(a2 + 120);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v23)
      {
        v24 = *(_QWORD *)(a2 + 128);
        *(_QWORD *)(a1 + 120) = v23;
        *(_QWORD *)(a1 + 128) = v24;
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v23 - 8))(a1 + 96, a2 + 96, v23);
        v25 = *(_QWORD *)(a2 + 144);
        *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
        *(_QWORD *)(a1 + 144) = v25;
        *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
        v26 = *(_QWORD *)(a2 + 168);
        *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
        *(_QWORD *)(a1 + 168) = v26;
        v27 = *(_QWORD *)(a2 + 184);
        *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
        *(_QWORD *)(a1 + 184) = v27;
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v46 = *(_OWORD *)(a2 + 144);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 144) = v46;
        v47 = *(_OWORD *)(a2 + 176);
        *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
        *(_OWORD *)(a1 + 176) = v47;
        v48 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
        *(_OWORD *)(a1 + 112) = v48;
      }
      *(_BYTE *)(a1 + 192) = 2;
      break;
    case 3:
      v28 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v28;
      (**(void (***)(uint64_t, uint64_t))(v28 - 8))(a1, a2);
      v29 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 48) = v29;
      *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
      v30 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v30;
      v31 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = v31;
      v18 = 3;
      goto LABEL_11;
    case 4:
      v32 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v32;
      (**(void (***)(uint64_t, uint64_t))(v32 - 8))(a1, a2);
      v33 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 48) = v33;
      *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
      v34 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v34;
      v35 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = v35;
      v18 = 4;
      goto LABEL_11;
    case 5:
      v36 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v36;
      (**(void (***)(uint64_t, uint64_t))(v36 - 8))(a1, a2);
      v37 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 48) = v37;
      *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
      v38 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v38;
      v39 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = v39;
      v18 = 5;
      goto LABEL_11;
    case 6:
      v40 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v40;
      (**(void (***)(uint64_t, uint64_t))(v40 - 8))(a1, a2);
      v41 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 48) = v41;
      *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
      v42 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v42;
      v43 = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = v43;
      v18 = 6;
LABEL_11:
      *(_BYTE *)(a1 + 192) = v18;
LABEL_12:
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      break;
    default:
      v8 = *(_OWORD *)(a2 + 176);
      *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
      *(_OWORD *)(a1 + 176) = v8;
      *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
      v9 = *(_OWORD *)(a2 + 112);
      *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
      *(_OWORD *)(a1 + 112) = v9;
      v10 = *(_OWORD *)(a2 + 144);
      *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
      *(_OWORD *)(a1 + 144) = v10;
      v11 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a1 + 48) = v11;
      v12 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 80) = v12;
      v13 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v13;
      break;
  }
  *(_BYTE *)(a1 + 193) = *(_BYTE *)(a2 + 193);
  v44 = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 208) = v44;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionAggregationFunction(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    switch(*(_BYTE *)(a2 + 192))
    {
      case 0:
        v4 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v4;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        *(_BYTE *)(a1 + 192) = 0;
        goto LABEL_13;
      case 1:
        v14 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v14;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 1;
        goto LABEL_12;
      case 2:
        v16 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v16;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v16 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v17 = *(_QWORD *)(a2 + 120);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v17)
        {
          *(_QWORD *)(a1 + 120) = v17;
          *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
          (**(void (***)(uint64_t, uint64_t, uint64_t))(v17 - 8))(a1 + 96, a2 + 96, v17);
          *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
          *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
          *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
          *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
          *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
          *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
          *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
        }
        else
        {
          v23 = *(_OWORD *)(a2 + 112);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(a1 + 112) = v23;
          v24 = *(_OWORD *)(a2 + 128);
          v25 = *(_OWORD *)(a2 + 144);
          v26 = *(_OWORD *)(a2 + 176);
          *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
          *(_OWORD *)(a1 + 176) = v26;
          *(_OWORD *)(a1 + 128) = v24;
          *(_OWORD *)(a1 + 144) = v25;
        }
        *(_BYTE *)(a1 + 192) = 2;
        break;
      case 3:
        v18 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v18;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v18 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 3;
        goto LABEL_12;
      case 4:
        v19 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v19;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v19 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 4;
        goto LABEL_12;
      case 5:
        v20 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v20;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v20 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 5;
        goto LABEL_12;
      case 6:
        v21 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 24) = v21;
        *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v21 - 8))(a1, a2);
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        v15 = 6;
LABEL_12:
        *(_BYTE *)(a1 + 192) = v15;
LABEL_13:
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        break;
      default:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        v5 = *(_OWORD *)(a2 + 16);
        v6 = *(_OWORD *)(a2 + 32);
        v7 = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 64) = v7;
        *(_OWORD *)(a1 + 16) = v5;
        *(_OWORD *)(a1 + 32) = v6;
        v8 = *(_OWORD *)(a2 + 80);
        v9 = *(_OWORD *)(a2 + 96);
        v10 = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 128) = v10;
        *(_OWORD *)(a1 + 80) = v8;
        *(_OWORD *)(a1 + 96) = v9;
        v11 = *(_OWORD *)(a2 + 144);
        v12 = *(_OWORD *)(a2 + 160);
        v13 = *(_OWORD *)(a2 + 176);
        *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
        *(_OWORD *)(a1 + 160) = v12;
        *(_OWORD *)(a1 + 176) = v13;
        *(_OWORD *)(a1 + 144) = v11;
        break;
    }
  }
  *(_BYTE *)(a1 + 193) = *(_BYTE *)(a2 + 193);
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy216_8(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __n128 result;
  __int128 v10;
  __int128 v11;

  v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  v3 = *(_OWORD *)(a2 + 32);
  v4 = *(_OWORD *)(a2 + 48);
  v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  v6 = *(_OWORD *)(a2 + 96);
  v7 = *(_OWORD *)(a2 + 112);
  v8 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = v8;
  *(_OWORD *)(a1 + 96) = v6;
  *(_OWORD *)(a1 + 112) = v7;
  result = *(__n128 *)(a2 + 160);
  v10 = *(_OWORD *)(a2 + 176);
  v11 = *(_OWORD *)(a2 + 192);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_OWORD *)(a1 + 176) = v10;
  *(_OWORD *)(a1 + 192) = v11;
  *(__n128 *)(a1 + 160) = result;
  return result;
}

uint64_t assignWithTake for SQLExpressionAggregationFunction(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    v4 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 176) = v4;
    *(_BYTE *)(a1 + 192) = *(_BYTE *)(a2 + 192);
    v5 = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(a1 + 112) = v5;
    v6 = *(_OWORD *)(a2 + 144);
    *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(a1 + 144) = v6;
    v7 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 48) = v7;
    v8 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 80) = v8;
    v9 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v9;
  }
  *(_BYTE *)(a1 + 193) = *(_BYTE *)(a2 + 193);
  v10 = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 208) = v10;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionAggregationFunction(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 216))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 208);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionAggregationFunction(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 216) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 208) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 216) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

void *type metadata accessor for SQLExpressionAggregationFunction()
{
  return &unk_1E263FA98;
}

uint64_t initializeBufferWithCopyOfBuffer for SQLExpressionNonAggregationFunction(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionNonAggregationFunction(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  return a1;
}

uint64_t assignWithTake for SQLExpressionNonAggregationFunction(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  return a1;
}

void *type metadata accessor for SQLExpressionNonAggregationFunction()
{
  return &unk_1E263FB48;
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

void *type metadata accessor for SQLExpressionConstString()
{
  return &unk_1E263EFA0;
}

uint64_t initializeWithCopy for SQLExpressionConst(uint64_t a1, uint64_t a2)
{
  __int128 v3;

  v3 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 24) = v3;
  (**(void (***)(void))(v3 - 8))();
  return a1;
}

uint64_t *assignWithCopy for SQLExpressionConst(uint64_t *a1, uint64_t *a2)
{
  __swift_assign_boxed_opaque_existential_1(a1, a2);
  return a1;
}

uint64_t assignWithTake for SQLExpressionConst(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  return a1;
}

void *type metadata accessor for SQLExpressionConst()
{
  return &unk_1E263BCC8;
}

uint64_t destroy for SQLExpressionAExpr(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 24))
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 40);
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLExpressionAExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    v5 = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a1 + 24) = v4;
    *(_QWORD *)(a1 + 32) = v5;
    (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
  }
  else
  {
    v6 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v6;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  }
  v7 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 64) = v7;
  (**(void (***)(uint64_t, uint64_t))(v7 - 8))(a1 + 40, a2 + 40);
  v8 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = v8;
  *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionAExpr(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;

  v4 = *((_QWORD *)a2 + 3);
  if (!*(_QWORD *)(a1 + 24))
  {
    if (v4)
    {
      *(_QWORD *)(a1 + 24) = v4;
      *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
      (**(void (***)(uint64_t, __int128 *))(v4 - 8))(a1, a2);
      goto LABEL_8;
    }
LABEL_7:
    v5 = *a2;
    v6 = a2[1];
    *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
    *(_OWORD *)a1 = v5;
    *(_OWORD *)(a1 + 16) = v6;
    goto LABEL_8;
  }
  if (!v4)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    goto LABEL_7;
  }
  __swift_assign_boxed_opaque_existential_1((uint64_t *)a1, (uint64_t *)a2);
LABEL_8:
  __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 40), (uint64_t *)a2 + 5);
  *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
  *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 11);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 96) = *((_BYTE *)a2 + 96);
  return a1;
}

__n128 __swift_memcpy97_8(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __n128 result;
  __int128 v5;
  __int128 v6;

  v2 = *a2;
  v3 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)a1 = v2;
  result = (__n128)a2[3];
  v5 = a2[4];
  v6 = a2[5];
  *(_BYTE *)(a1 + 96) = *((_BYTE *)a2 + 96);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

uint64_t assignWithTake for SQLExpressionAExpr(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  if (*(_QWORD *)(a1 + 24))
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 40);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionAExpr(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 97))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 64);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionAExpr(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 88) = 0;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_BYTE *)(result + 96) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 97) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 64) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 97) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

void *type metadata accessor for SQLExpressionAExpr()
{
  return &unk_1E263BC10;
}

uint64_t destroy for SQLExpressioBoolExpr()
{
  return swift_bridgeObjectRelease();
}

uint64_t initializeBufferWithCopyOfBuffer for SQLExpressioBoolExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v3;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressioBoolExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  return a1;
}

__n128 __swift_memcpy18_8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[1].n128_u16[0] = a2[1].n128_u16[0];
  *a1 = result;
  return result;
}

uint64_t assignWithTake for SQLExpressioBoolExpr(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressioBoolExpr(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *((_BYTE *)a1 + 18))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressioBoolExpr(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_WORD *)(result + 16) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    *(_QWORD *)(result + 8) = 0;
    if (a3 < 0)
      *(_BYTE *)(result + 18) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)result = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 18) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

void *type metadata accessor for SQLExpressioBoolExpr()
{
  return &unk_1E263D498;
}

uint64_t initializeWithCopy for SQLExpressionNullTest(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  v4 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 24) = v4;
  (**(void (***)(void))(v4 - 8))();
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  return a1;
}

uint64_t assignWithCopy for SQLExpressionNullTest(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  __swift_assign_boxed_opaque_existential_1((uint64_t *)a1, (uint64_t *)a2);
  v4 = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = v4;
  *(_BYTE *)(a1 + 49) = *(_BYTE *)(a2 + 49);
  return a1;
}

__n128 __swift_memcpy50_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 32);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for SQLExpressionNullTest(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  v5 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v5;
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionNullTest(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 50))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionNullTest(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 40) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_WORD *)(result + 48) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 50) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 24) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 50) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

void *type metadata accessor for SQLExpressionNullTest()
{
  return &unk_1E263DB58;
}

uint64_t getEnumTagSinglePayload for SQLExpressionConst(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 40))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionConst(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 40) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 24) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 40) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

void *type metadata accessor for SQLExpressionFuncCall()
{
  return &unk_1E263DAA8;
}

void *type metadata accessor for SQLExpressionColumnRef()
{
  return &unk_1E263E7A8;
}

uint64_t initializeBufferWithCopyOfBuffer for SQLExpressionInteger(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = v3;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionInteger(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for SQLExpressionInteger(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionInteger(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 24))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionInteger(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 24) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 8) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 24) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

void *type metadata accessor for SQLExpressionInteger()
{
  return &unk_1E263D550;
}

void *type metadata accessor for SQLExpressionFloat()
{
  return &unk_1E263BD78;
}

void *type metadata accessor for SQLExpressionString()
{
  return &unk_1E263CC50;
}

void *type metadata accessor for SQLExpressionBitString()
{
  return &unk_1E263E6F0;
}

uint64_t destroy for SQLExpressionConstString()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLExpressionConstString(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = v4;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionConstString(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for SQLExpressionConstString(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionConstString(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 40))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionConstString(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 40) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 8) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 40) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

void *type metadata accessor for SQLExpressionNull()
{
  return &unk_1E263B3B0;
}

void specialized RawRepresentable<>._rawHashValue(seed:)(uint64_t a1, char a2)
{
  Hasher.init(_seed:)();
  __asm { BR              X10 }
}

Swift::Int sub_18DB2BFA8()
{
  String.hash(into:)();
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

uint64_t _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5(void (*a1)(__int128 *__return_ptr, uint64_t, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v15;
  __int128 v16[2];
  uint64_t v17;

  v4 = v3;
  v5 = *(_QWORD *)(a3 + 16);
  v6 = MEMORY[0x1E0DEE9D8];
  if (v5)
  {
    v17 = MEMORY[0x1E0DEE9D8];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v5, 0);
    v6 = v17;
    v9 = *(_QWORD *)(type metadata accessor for PgQuery_Node(0) - 8);
    v10 = a3 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    v11 = *(_QWORD *)(v9 + 72);
    while (1)
    {
      a1(v16, v10, &v15);
      if (v4)
        break;
      v4 = 0;
      v17 = v6;
      v13 = *(_QWORD *)(v6 + 16);
      v12 = *(_QWORD *)(v6 + 24);
      if (v13 >= v12 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((_QWORD *)(v12 > 1), v13 + 1, 1);
        v6 = v17;
      }
      *(_QWORD *)(v6 + 16) = v13 + 1;
      outlined init with take of Aggregation(v16, v6 + 40 * v13 + 32);
      v10 += v11;
      if (!--v5)
        return v6;
    }
    swift_release();
  }
  return v6;
}

uint64_t _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF12ResultColumnVsAE_pTg5(void (*a1)(_OWORD *__return_ptr, uint64_t, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v21;
  _OWORD v22[8];
  uint64_t v23;

  v4 = v3;
  v5 = *(_QWORD *)(a3 + 16);
  v6 = MEMORY[0x1E0DEE9D8];
  if (v5)
  {
    v23 = MEMORY[0x1E0DEE9D8];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    v6 = v23;
    v9 = *(_QWORD *)(type metadata accessor for PgQuery_Node(0) - 8);
    v10 = a3 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    v11 = *(_QWORD *)(v9 + 72);
    while (1)
    {
      a1(v22, v10, &v21);
      if (v4)
        break;
      v4 = 0;
      v23 = v6;
      v12 = *(_QWORD *)(v6 + 16);
      if (v12 >= *(_QWORD *)(v6 + 24) >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        v6 = v23;
      }
      *(_QWORD *)(v6 + 16) = v12 + 1;
      v13 = (_OWORD *)(v6 + (v12 << 7));
      v14 = v22[0];
      v15 = v22[1];
      v16 = v22[3];
      v13[4] = v22[2];
      v13[5] = v16;
      v13[2] = v14;
      v13[3] = v15;
      v17 = v22[4];
      v18 = v22[5];
      v19 = v22[7];
      v13[8] = v22[6];
      v13[9] = v19;
      v13[6] = v17;
      v13[7] = v18;
      v10 += v11;
      if (!--v5)
        return v6;
    }
    swift_release();
  }
  return v6;
}

uint64_t _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF13SQLExpressionVsAE_pTg5(void (*a1)(_OWORD *__return_ptr, uint64_t, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v19;
  _OWORD v20[6];
  uint64_t v21;

  v4 = v3;
  v5 = *(_QWORD *)(a3 + 16);
  v6 = MEMORY[0x1E0DEE9D8];
  if (v5)
  {
    v21 = MEMORY[0x1E0DEE9D8];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    v6 = v21;
    v9 = *(_QWORD *)(type metadata accessor for PgQuery_Node(0) - 8);
    v10 = a3 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    v11 = *(_QWORD *)(v9 + 72);
    while (1)
    {
      a1(v20, v10, &v19);
      if (v4)
        break;
      v4 = 0;
      v21 = v6;
      v12 = *(_QWORD *)(v6 + 16);
      if (v12 >= *(_QWORD *)(v6 + 24) >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        v6 = v21;
      }
      *(_QWORD *)(v6 + 16) = v12 + 1;
      v13 = (_OWORD *)(v6 + 96 * v12);
      v14 = v20[1];
      v13[2] = v20[0];
      v13[3] = v14;
      v15 = v20[2];
      v16 = v20[3];
      v17 = v20[5];
      v13[6] = v20[4];
      v13[7] = v17;
      v13[4] = v15;
      v13[5] = v16;
      v10 += v11;
      if (!--v5)
        return v6;
    }
    swift_release();
  }
  return v6;
}

uint64_t specialized Set.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Swift::Int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  BOOL v12;
  uint64_t result;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  BOOL v17;

  if (*(_QWORD *)(a3 + 16))
  {
    Hasher.init(_seed:)();
    String.hash(into:)();
    v6 = Hasher._finalize()();
    v7 = -1 << *(_BYTE *)(a3 + 32);
    v8 = v6 & ~v7;
    v9 = a3 + 56;
    if (((*(_QWORD *)(a3 + 56 + ((v8 >> 3) & 0xFFFFFFFFFFFFF8)) >> v8) & 1) != 0)
    {
      v10 = *(_QWORD *)(a3 + 48);
      v11 = (_QWORD *)(v10 + 16 * v8);
      v12 = *v11 == a1 && v11[1] == a2;
      if (v12 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
        return 1;
      v14 = ~v7;
      v15 = (v8 + 1) & v14;
      if (((*(_QWORD *)(v9 + ((v15 >> 3) & 0xFFFFFFFFFFFFF8)) >> v15) & 1) != 0)
      {
        while (1)
        {
          v16 = (_QWORD *)(v10 + 16 * v15);
          v17 = *v16 == a1 && v16[1] == a2;
          if (v17 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
            break;
          result = 0;
          v15 = (v15 + 1) & v14;
          if (((*(_QWORD *)(v9 + ((v15 >> 3) & 0xFFFFFFFFFFFFF8)) >> v15) & 1) == 0)
            return result;
        }
        return 1;
      }
    }
  }
  return 0;
}

Swift::String __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> SQLTokenInformation.tokenName(location:)(Swift::Int32 location)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t ScanToken;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  Swift::String v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  Swift::String result;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  Swift::Int32 v38;

  v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_ScanToken?);
  MEMORY[0x1E0C80A78](v4);
  v6 = (char *)&v32 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  v8 = *(_QWORD *)(ScanToken - 8);
  v9 = MEMORY[0x1E0C80A78](ScanToken);
  v11 = (_DWORD *)((char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v9);
  v35 = (uint64_t)&v32 - v12;
  v13 = *(_QWORD *)(v1 + 8);
  v14 = *(_QWORD *)(v13 + 16);
  if (v14)
  {
    v32 = ScanToken;
    v33 = v1;
    v34 = v2;
    v15 = v13 + ((*(unsigned __int8 *)(v8 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80));
    v16 = *(_QWORD *)(v8 + 72);
    swift_bridgeObjectRetain();
    while (1)
    {
      outlined init with copy of PgQuery_RawStmt(v15, (uint64_t)v11, type metadata accessor for PgQuery_ScanToken);
      if (*v11 == location)
        break;
      outlined destroy of PgQuery_Alias((uint64_t)v11, type metadata accessor for PgQuery_ScanToken);
      v15 += v16;
      if (!--v14)
      {
        v17 = 1;
        goto LABEL_8;
      }
    }
    outlined init with take of PgQuery_OidList((uint64_t)v11, (uint64_t)v6, type metadata accessor for PgQuery_ScanToken);
    v17 = 0;
LABEL_8:
    v1 = v33;
    ScanToken = v32;
  }
  else
  {
    swift_bridgeObjectRetain();
    v17 = 1;
  }
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 56))(v6, v17, 1, ScanToken);
  swift_bridgeObjectRelease();
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1, ScanToken) == 1)
  {
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v6, &demangling cache variable for type metadata for PgQuery_ScanToken?);
    v18 = (uint64_t *)(v1 + *(int *)(type metadata accessor for SQLTokenInformation(0) + 20));
    v20 = *v18;
    v19 = v18[1];
    v36 = 0;
    v37 = 0xE000000000000000;
    swift_bridgeObjectRetain();
    _StringGuts.grow(_:)(28);
    swift_bridgeObjectRelease();
    v36 = 0xD00000000000001ALL;
    v37 = 0x800000018DCD1550;
    v38 = location;
    v21._countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v21);
    swift_bridgeObjectRelease();
    v22 = v36;
    v23 = (void *)v37;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v24 = v20;
    *(_QWORD *)(v24 + 8) = v19;
    *(_QWORD *)(v24 + 16) = v22;
    *(_QWORD *)(v24 + 24) = v23;
    *(_BYTE *)(v24 + 32) = 0;
    swift_willThrow();
  }
  else
  {
    v25 = v35;
    outlined init with take of PgQuery_OidList((uint64_t)v6, v35, type metadata accessor for PgQuery_ScanToken);
    type metadata accessor for SQLTokenInformation(0);
    v26 = String.index(_:offsetBy:)();
    v27 = String.index(_:offsetBy:)();
    if (v27 >> 14 < v26 >> 14)
    {
      __break(1u);
      goto LABEL_15;
    }
    v29 = String.subscript.getter();
    v22 = MEMORY[0x193FEC5A0](v29);
    v23 = v30;
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v25, type metadata accessor for PgQuery_ScanToken);
  }
  v27 = v22;
  v28 = v23;
LABEL_15:
  result._object = v28;
  result._countAndFlagsBits = v27;
  return result;
}

uint64_t specialized Array.append<A>(contentsOf:)(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  int64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  int64_t v10;

  v2 = *(_QWORD *)(result + 16);
  v3 = *v1;
  v4 = *(_QWORD *)(*v1 + 16);
  v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  v6 = result;
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((_DWORD)result && v5 <= *(_QWORD *)(v3 + 24) >> 1)
  {
    if (*(_QWORD *)(v6 + 16))
      goto LABEL_5;
    goto LABEL_13;
  }
  if (v4 <= v5)
    v10 = v4 + v2;
  else
    v10 = v4;
  result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v10, 1, (char *)v3);
  v3 = result;
  if (!*(_QWORD *)(v6 + 16))
  {
LABEL_13:
    if (!v2)
      goto LABEL_14;
    goto LABEL_16;
  }
LABEL_5:
  if ((*(_QWORD *)(v3 + 24) >> 1) - *(_QWORD *)(v3 + 16) < v2)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  result = swift_arrayInitWithCopy();
  if (!v2)
  {
LABEL_14:
    result = swift_bridgeObjectRelease();
    *v1 = v3;
    return result;
  }
  v7 = *(_QWORD *)(v3 + 16);
  v8 = __OFADD__(v7, v2);
  v9 = v7 + v2;
  if (!v8)
  {
    *(_QWORD *)(v3 + 16) = v9;
    goto LABEL_14;
  }
LABEL_18:
  __break(1u);
  return result;
}

{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  int64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  int64_t v10;

  v2 = *(_QWORD *)(result + 16);
  v3 = *v1;
  v4 = *(_QWORD *)(*v1 + 16);
  v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  v6 = result;
  result = swift_isUniquelyReferenced_nonNull_native();
  if ((_DWORD)result && v5 <= *(_QWORD *)(v3 + 24) >> 1)
  {
    if (*(_QWORD *)(v6 + 16))
      goto LABEL_5;
    goto LABEL_13;
  }
  if (v4 <= v5)
    v10 = v4 + v2;
  else
    v10 = v4;
  result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v10, 1, (char *)v3);
  v3 = result;
  if (!*(_QWORD *)(v6 + 16))
  {
LABEL_13:
    if (!v2)
      goto LABEL_14;
    goto LABEL_16;
  }
LABEL_5:
  if ((*(_QWORD *)(v3 + 24) >> 1) - *(_QWORD *)(v3 + 16) < v2)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  result = swift_arrayInitWithCopy();
  if (!v2)
  {
LABEL_14:
    result = swift_bridgeObjectRelease();
    *v1 = v3;
    return result;
  }
  v7 = *(_QWORD *)(v3 + 16);
  v8 = __OFADD__(v7, v2);
  v9 = v7 + v2;
  if (!v8)
  {
    *(_QWORD *)(v3 + 16) = v9;
    goto LABEL_14;
  }
LABEL_18:
  __break(1u);
  return result;
}

void SQLParserError.description.getter()
{
  __asm { BR              X10 }
}

unint64_t sub_18DB2CA64()
{
  void *v0;
  uint64_t v1;
  Swift::String v2;
  Swift::String v3;

  _StringGuts.grow(_:)(50);
  swift_bridgeObjectRelease();
  v2._countAndFlagsBits = v1;
  v2._object = v0;
  String.append(_:)(v2);
  v3._countAndFlagsBits = 34;
  v3._object = (void *)0xE100000000000000;
  String.append(_:)(v3);
  return 0xD00000000000002FLL;
}

void sub_18DB2CD88()
{
  JUMPOUT(0x18DB2CD70);
}

BiomeSQLParser::SQLDataType_optional __swiftcall SQLDataType.init(rawValue:)(Swift::String rawValue)
{
  char *v1;
  void *object;
  Swift::String v3;
  char *v4;
  unint64_t v5;
  BiomeSQLParser::SQLDataType_optional result;
  char v7;

  object = rawValue._object;
  v3._countAndFlagsBits = rawValue._countAndFlagsBits;
  v4 = v1;
  v3._object = object;
  v5 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&outlined read-only object #0 of SQLDataType.init(rawValue:), v3);
  result.value = swift_bridgeObjectRelease();
  v7 = 8;
  if (v5 < 8)
    v7 = v5;
  *v4 = v7;
  return result;
}

uint64_t SQLDataType.rawValue.getter()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_18DB2CE60 + 4 * byte_18DC2D242[*v0]))(0x72656765746E69, 0xE700000000000000);
}

uint64_t sub_18DB2CE60()
{
  return 0x656C62756F64;
}

uint64_t sub_18DB2CE74()
{
  return 0x676E69727473;
}

uint64_t sub_18DB2CE88()
{
  return 1702125924;
}

uint64_t sub_18DB2CE98()
{
  return 1635017060;
}

uint64_t sub_18DB2CEA8()
{
  return 1852797802;
}

uint64_t sub_18DB2CEB8()
{
  return 1684632949;
}

uint64_t sub_18DB2CEC8()
{
  return 1819047278;
}

BiomeSQLParser::SQLDataType_optional protocol witness for RawRepresentable.init(rawValue:) in conformance SQLDataType(Swift::String *a1)
{
  return SQLDataType.init(rawValue:)(*a1);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SQLDataType()
{
  lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
  return RawRepresentable<>.init(from:)();
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SQLDataType()
{
  lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
  return RawRepresentable<>.encode(to:)();
}

void protocol witness for Hashable.hashValue.getter in conformance SQLDataType()
{
  char *v0;

  specialized RawRepresentable<>._rawHashValue(seed:)(0, *v0);
}

void protocol witness for Hashable.hash(into:) in conformance SQLDataType(uint64_t a1)
{
  char *v1;

  specialized RawRepresentable<>.hash(into:)(a1, *v1);
}

void protocol witness for Hashable._rawHashValue(seed:) in conformance SQLDataType(uint64_t a1)
{
  char *v1;

  specialized RawRepresentable<>._rawHashValue(seed:)(a1, *v1);
}

BiomeSQLParser::SQLRawDataType_optional __swiftcall SQLRawDataType.init(rawValue:)(Swift::String rawValue)
{
  char *v1;
  void *object;
  Swift::String v3;
  char *v4;
  unint64_t v5;
  BiomeSQLParser::SQLRawDataType_optional result;
  char v7;

  object = rawValue._object;
  v3._countAndFlagsBits = rawValue._countAndFlagsBits;
  v4 = v1;
  v3._object = object;
  v5 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&outlined read-only object #0 of SQLRawDataType.init(rawValue:), v3);
  result.value = swift_bridgeObjectRelease();
  v7 = 5;
  if (v5 < 5)
    v7 = v5;
  *v4 = v7;
  return result;
}

void protocol witness for static Equatable.== infix(_:_:) in conformance SQLRawDataType(char *a1)
{
  specialized == infix<A>(_:_:)(*a1);
}

void protocol witness for Hashable.hashValue.getter in conformance SQLRawDataType()
{
  unsigned __int8 *v0;
  uint64_t v1;

  v1 = *v0;
  Hasher.init(_seed:)();
  __asm { BR              X9 }
}

Swift::Int sub_18DB2D058()
{
  String.hash(into:)();
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance SQLRawDataType()
{
  __asm { BR              X10 }
}

uint64_t sub_18DB2D0FC()
{
  String.hash(into:)();
  return swift_bridgeObjectRelease();
}

void protocol witness for Hashable._rawHashValue(seed:) in conformance SQLRawDataType()
{
  unsigned __int8 *v0;
  uint64_t v1;

  v1 = *v0;
  Hasher.init(_seed:)();
  __asm { BR              X9 }
}

Swift::Int sub_18DB2D198()
{
  String.hash(into:)();
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

BiomeSQLParser::SQLRawDataType_optional protocol witness for RawRepresentable.init(rawValue:) in conformance SQLRawDataType(Swift::String *a1)
{
  return SQLRawDataType.init(rawValue:)(*a1);
}

BiomeSQLParser::DatabaseCatalog __swiftcall DatabaseCatalog.init(schemas:)(Swift::OpaquePointer schemas)
{
  _QWORD *v1;
  int64_t v3;
  uint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  _OWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char v19;
  uint64_t v20;
  _BOOL8 v21;
  BOOL v22;
  uint64_t v23;
  char v24;
  char v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BiomeSQLParser::DatabaseCatalog result;
  void *v31;
  id v32;
  Swift::String v33;
  Swift::String v34;
  _QWORD *v35;
  __int128 v36;
  __int128 v37;
  id v38;
  uint64_t v39;
  _QWORD *v40;

  v35 = v1;
  v3 = *((_QWORD *)schemas._rawValue + 2);
  if (v3)
  {
    v39 = MEMORY[0x1E0DEE9D8];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v3, 0);
    v4 = v39;
    v5 = (char *)schemas._rawValue + 40;
    do
    {
      v6 = *((_QWORD *)v5 - 1);
      v36 = *v5;
      v8 = *(_QWORD *)(v39 + 16);
      v7 = *(_QWORD *)(v39 + 24);
      v9 = *(_QWORD *)v5;
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain();
      if (v8 >= v7 >> 1)
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((_QWORD *)(v7 > 1), v8 + 1, 1);
      v5 = (_OWORD *)((char *)v5 + 24);
      *(_QWORD *)(v39 + 16) = v8 + 1;
      v10 = v39 + 40 * v8;
      *(_QWORD *)(v10 + 32) = v6;
      *(_QWORD *)(v10 + 40) = v9;
      *(_QWORD *)(v10 + 48) = v6;
      *(_OWORD *)(v10 + 56) = v36;
      --v3;
    }
    while (v3);
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(v39 + 16))
      goto LABEL_7;
  }
  else
  {
    swift_bridgeObjectRelease();
    v4 = MEMORY[0x1E0DEE9D8];
    if (*(_QWORD *)(MEMORY[0x1E0DEE9D8] + 16))
    {
LABEL_7:
      __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Schema>);
      v11 = (_QWORD *)static _DictionaryStorage.allocate(capacity:)();
      v12 = *(_QWORD *)(v4 + 16);
      goto LABEL_10;
    }
  }
  v12 = 0;
  v11 = (_QWORD *)MEMORY[0x1E0DEE9E0];
LABEL_10:
  v40 = v11;
  swift_bridgeObjectRetain_n();
  if (v12)
  {
    v13 = 0;
    v14 = (_OWORD *)(v4 + 56);
    while (v13 < *(_QWORD *)(v4 + 16))
    {
      v37 = *v14;
      v15 = *((_QWORD *)v14 - 2);
      v16 = *((_QWORD *)v14 - 1);
      v17 = *((_QWORD *)v14 - 3);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (!v15)
        goto LABEL_20;
      v18 = specialized __RawDictionaryStorage.find<A>(_:)();
      v20 = v11[2];
      v21 = (v19 & 1) == 0;
      v22 = __OFADD__(v20, v21);
      v23 = v20 + v21;
      if (v22)
        goto LABEL_22;
      v24 = v19;
      if (v11[3] < v23)
      {
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v23, 1);
        v11 = v40;
        v18 = specialized __RawDictionaryStorage.find<A>(_:)();
        if ((v24 & 1) != (v25 & 1))
          goto LABEL_26;
      }
      if ((v24 & 1) != 0)
        goto LABEL_24;
      v11[(v18 >> 6) + 8] |= 1 << v18;
      v26 = (_QWORD *)(v11[6] + 16 * v18);
      *v26 = v17;
      v26[1] = v15;
      v27 = v11[7] + 24 * v18;
      *(_QWORD *)v27 = v16;
      *(_OWORD *)(v27 + 8) = v37;
      v28 = v11[2];
      v22 = __OFADD__(v28, 1);
      v29 = v28 + 1;
      if (v22)
        goto LABEL_23;
      ++v13;
      v11[2] = v29;
      v14 = (_OWORD *)((char *)v14 + 40);
      if (v12 == v13)
        goto LABEL_20;
    }
    __break(1u);
LABEL_22:
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    v31 = (void *)swift_allocError();
    swift_willThrow();
    v38 = v31;
    v32 = v31;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
    if ((swift_dynamicCast() & 1) == 0)
      goto LABEL_27;
    _StringGuts.grow(_:)(30);
    v33._object = (void *)0x800000018DCC3160;
    v33._countAndFlagsBits = 0xD00000000000001BLL;
    String.append(_:)(v33);
    _print_unlocked<A, B>(_:_:)();
    v34._countAndFlagsBits = 39;
    v34._object = (void *)0xE100000000000000;
    String.append(_:)(v34);
    _assertionFailure(_:_:file:line:flags:)();
    __break(1u);
LABEL_26:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
    __break(1u);
LABEL_27:
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();

    result.schemas._rawValue = (void *)swift_unexpectedError();
    __break(1u);
  }
  else
  {
LABEL_20:
    result.schemas._rawValue = (void *)swift_bridgeObjectRelease_n();
    *v35 = v11;
  }
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance DatabaseCatalog.CodingKeys()
{
  return 0x73616D65686373;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance DatabaseCatalog.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v5;
  uint64_t result;
  char v7;

  if (a1 == 0x73616D65686373 && a2 == 0xE700000000000000)
  {
    result = swift_bridgeObjectRelease();
    v7 = 0;
  }
  else
  {
    v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    result = swift_bridgeObjectRelease();
    v7 = v5 ^ 1;
  }
  *a3 = v7 & 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance DatabaseCatalog.CodingKeys()
{
  lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance DatabaseCatalog.CodingKeys()
{
  lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t DatabaseCatalog.encode(to:)(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  _QWORD v9[2];

  v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<DatabaseCatalog.CodingKeys>);
  v4 = *(_QWORD *)(v3 - 8);
  MEMORY[0x1E0C80A78](v3);
  v6 = (char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *v1;
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v9[1] = v7;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : Schema]);
  lazy protocol witness table accessor for type [String : Schema] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : Schema] and conformance <> [A : B], (uint64_t (*)(void))lazy protocol witness table accessor for type Schema and conformance Schema, MEMORY[0x1E0DEA970], MEMORY[0x1E0DEA0B8]);
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t DatabaseCatalog.init(from:)@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  _QWORD v10[2];

  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedDecodingContainer<DatabaseCatalog.CodingKeys>);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v8 = (char *)v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (!v2)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : Schema]);
    lazy protocol witness table accessor for type [String : Schema] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : Schema] and conformance <> [A : B], (uint64_t (*)(void))lazy protocol witness table accessor for type Schema and conformance Schema, MEMORY[0x1E0DEA9A0], MEMORY[0x1E0DEA0D8]);
    KeyedDecodingContainer.decode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
    *a2 = v10[1];
  }
  return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)a1);
}

uint64_t protocol witness for Decodable.init(from:) in conformance DatabaseCatalog@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  return DatabaseCatalog.init(from:)(a1, a2);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance DatabaseCatalog(_QWORD *a1)
{
  return DatabaseCatalog.encode(to:)(a1);
}

uint64_t static Schema.lookup(rangeVar:catalog:)@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;

  v4 = a1[3];
  v5 = a1[2] & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000) != 0)
    v5 = HIBYTE(v4) & 0xF;
  if (v5)
  {
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v6 = 0xD00000000000003ELL;
    v7 = 0x800000018DCD1810;
    v8 = 1;
  }
  else
  {
    v9 = *a2;
    v10 = a1[4];
    v7 = a1[5];
    v11 = *(_QWORD *)(*a2 + 16);
    swift_bridgeObjectRetain();
    if (v11)
    {
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      v12 = specialized __RawDictionaryStorage.find<A>(_:)();
      if ((v13 & 1) != 0)
      {
        v14 = (uint64_t *)(*(_QWORD *)(v9 + 56) + 24 * v12);
        v16 = *v14;
        v15 = v14[1];
        v17 = v14[2];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRelease();
        result = swift_bridgeObjectRelease_n();
        *a3 = v16;
        a3[1] = v15;
        a3[2] = v17;
        return result;
      }
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v6 = v10;
    v8 = 2;
  }
  *(_QWORD *)(v6 + 16) = 0;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 8) = v7;
  *(_BYTE *)(v6 + 32) = v8;
  return swift_willThrow();
}

uint64_t static Schema.== infix(_:_:)(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;

  v2 = a1[2];
  v3 = a2[2];
  v4 = *a1 == *a2 && a1[1] == a2[1];
  if (v4 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
    return specialized static Dictionary<>.== infix(_:_:)(v2, v3);
  else
    return 0;
}

uint64_t specialized static Dictionary<>.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  unint64_t v7;
  char v8;
  char v9;

  if (a1 == a2)
    return 1;
  if (*(_QWORD *)(a1 + 16) != *(_QWORD *)(a2 + 16))
    return 0;
  v3 = 1 << *(_BYTE *)(a1 + 32);
  v4 = -1;
  if (v3 < 64)
    v4 = ~(-1 << v3);
  if ((v4 & *(_QWORD *)(a1 + 64)) != 0)
    goto LABEL_19;
  if ((unint64_t)(v3 + 63) >> 6 <= 1)
    return 1;
  if (*(_QWORD *)(a1 + 72))
    goto LABEL_19;
  if ((unint64_t)(v3 + 63) >> 6 <= 2)
    return 1;
  if (*(_QWORD *)(a1 + 80))
    goto LABEL_19;
  if ((unint64_t)(v3 + 63) >> 6 <= 3)
    return 1;
  if (*(_QWORD *)(a1 + 88))
    goto LABEL_19;
  if ((unint64_t)(v3 + 63) >> 6 <= 4)
    return 1;
  if (*(_QWORD *)(a1 + 96))
  {
LABEL_19:
    swift_bridgeObjectRetain();
    v7 = specialized __RawDictionaryStorage.find<A>(_:)();
    v9 = v8;
    swift_bridgeObjectRelease();
    if ((v9 & 1) != 0)
      __asm { BR              X9 }
    return 0;
  }
  v5 = 5;
  if ((unint64_t)(v3 + 63) >> 6 > 5)
  {
    if (!*(_QWORD *)(a1 + 104))
    {
      while (1)
      {
        v6 = v5 + 1;
        if (__OFADD__(v5, 1))
        {
          __break(1u);
          JUMPOUT(0x18DB2DED8);
        }
        if (v6 >= (uint64_t)((unint64_t)(v3 + 63) >> 6))
          return 1;
        ++v5;
        if (*(_QWORD *)(a1 + 64 + 8 * v6))
          goto LABEL_19;
      }
    }
    goto LABEL_19;
  }
  return 1;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance Schema.CodingKeys()
{
  _BYTE *v0;

  if (*v0)
    return 0x736E6D756C6F63;
  else
    return 0x6D614E656C626174;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance Schema.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized Schema.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Schema.CodingKeys()
{
  lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Schema.CodingKeys()
{
  lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t Schema.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;

  v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<Schema.CodingKeys>);
  v10 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](v4);
  v6 = (char *)&v8 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = *(_QWORD *)(v1 + 16);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v13 = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v2)
  {
    v11 = v9;
    v12 = 1;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : SQLDataType]);
    lazy protocol witness table accessor for type [String : SQLDataType] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : SQLDataType] and conformance <> [A : B], (uint64_t (*)(void))lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType, MEMORY[0x1E0DEA970], MEMORY[0x1E0DEA0B8]);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v6, v4);
}

uint64_t Schema.init(from:)@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[2];
  char v15;
  char v16;

  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedDecodingContainer<Schema.CodingKeys>);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v8 = (char *)v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (v2)
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)a1);
  v16 = 0;
  v9 = KeyedDecodingContainer.decode(_:forKey:)();
  v11 = v10;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : SQLDataType]);
  v15 = 1;
  lazy protocol witness table accessor for type [String : SQLDataType] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : SQLDataType] and conformance <> [A : B], (uint64_t (*)(void))lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType, MEMORY[0x1E0DEA9A0], MEMORY[0x1E0DEA0D8]);
  swift_bridgeObjectRetain();
  KeyedDecodingContainer.decode<A>(_:forKey:)();
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  v12 = v14[1];
  *a2 = v9;
  a2[1] = v11;
  a2[2] = v12;
  swift_bridgeObjectRetain();
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)a1);
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Schema(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;

  v2 = a1[2];
  v3 = a2[2];
  v4 = *a1 == *a2 && a1[1] == a2[1];
  if (v4 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
    return specialized static Dictionary<>.== infix(_:_:)(v2, v3);
  else
    return 0;
}

uint64_t protocol witness for Decodable.init(from:) in conformance Schema@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  return Schema.init(from:)(a1, a2);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Schema(_QWORD *a1)
{
  return Schema.encode(to:)(a1);
}

uint64_t FromClause.jsonEachExpression.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  return outlined init with copy of PgQuery_Alias?(v1 + 8, a1, &demangling cache variable for type metadata for SQLExpression?);
}

uint64_t FromClause.init(fromClauseNodes:resources:)@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char *v105;
  uint64_t Node;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  char *v119;
  uint64_t v120;
  void (*v121)(void);
  uint64_t v122;
  unsigned int (*v123)(char *, uint64_t, uint64_t);
  uint64_t v124;
  uint64_t (*v125)(uint64_t);
  uint64_t v126;
  uint64_t v128;
  uint64_t v129;
  unsigned int (*v130)(uint64_t, uint64_t, uint64_t);
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  Swift::String v135;
  __int128 v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t *v139;
  uint64_t v140;
  uint64_t v141;
  __int128 *v142;
  __int128 v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t *v151;
  uint64_t v152;
  uint64_t v153;
  void (*v154)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t *v165;
  int EnumCaseMultiPayload;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t *v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t *v184;
  uint64_t v185;
  uint64_t *v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  _QWORD *v200;
  _QWORD *v201;
  uint64_t v202;
  uint64_t v203;
  char v204;
  uint64_t v205;
  _QWORD *v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t *p_RangeFunction;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  _QWORD *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  _QWORD *v231;
  _QWORD *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  _QWORD *v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  _QWORD *v249;
  _QWORD *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  unint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  char v262;
  int64_t inited;
  _QWORD *v264;
  unint64_t v265;
  unint64_t v266;
  char v267;
  unint64_t v268;
  unint64_t v269;
  char v270;
  unint64_t *v271;
  uint64_t v272;
  BOOL v273;
  char *v274;
  char *v275;
  uint64_t v276;
  uint64_t v277;
  _QWORD *v278;
  unint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t v285;
  uint64_t v286;
  char *v287;
  uint64_t v288;
  _QWORD *v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t ColumnRef;
  _QWORD *v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  _QWORD *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t String;
  uint64_t v307;
  uint64_t v308;
  _QWORD *v309;
  uint64_t v310;
  _QWORD *v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t *v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t *v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t *v327;
  uint64_t List;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t *v335;
  char *v336;
  uint64_t RangeFunction;
  __int128 v338;
  uint64_t v339;
  uint64_t v340;
  char *v341;
  char *v342;
  unsigned int (*v343)(uint64_t, uint64_t, uint64_t);
  uint64_t *v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  char v349;
  __int128 v350;
  __int128 v351;
  __int128 v352;
  __int128 v353;
  __int128 v354;
  __int128 v355;
  uint64_t RangeVar;

  v335 = a3;
  v5 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1E0C80A78](v5);
  v288 = (uint64_t)&v276 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  ColumnRef = type metadata accessor for PgQuery_ColumnRef(0);
  v7 = MEMORY[0x1E0C80A78](ColumnRef);
  v289 = (uint64_t *)((char *)&v276 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v7);
  v10 = (char *)&v276 - v9;
  String = type metadata accessor for PgQuery_String(0);
  MEMORY[0x1E0C80A78](String);
  v311 = (uint64_t *)((char *)&v276 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  v324 = type metadata accessor for PgQuery_FuncCall(0);
  v12 = MEMORY[0x1E0C80A78](v324);
  v292 = (uint64_t)&v276 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v12);
  v301 = (uint64_t)&v276 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v308 = (uint64_t)&v276 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v316 = (uint64_t)&v276 - v19;
  MEMORY[0x1E0C80A78](v18);
  v321 = (uint64_t)&v276 - v20;
  v21 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  v22 = MEMORY[0x1E0C80A78](v21);
  v298 = (uint64_t)&v276 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  v24 = MEMORY[0x1E0C80A78](v22);
  v293 = (uint64_t)&v276 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v296 = (uint64_t)&v276 - v27;
  v28 = MEMORY[0x1E0C80A78](v26);
  v305 = (uint64_t)&v276 - v29;
  v30 = MEMORY[0x1E0C80A78](v28);
  v302 = (uint64_t)&v276 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v312 = (uint64_t)&v276 - v33;
  v34 = MEMORY[0x1E0C80A78](v32);
  v318 = (uint64_t)&v276 - v35;
  v36 = MEMORY[0x1E0C80A78](v34);
  v319 = (uint64_t)&v276 - v37;
  MEMORY[0x1E0C80A78](v36);
  v325 = (uint64_t)&v276 - v38;
  List = type metadata accessor for PgQuery_List(0);
  v39 = MEMORY[0x1E0C80A78](List);
  v295 = (uint64_t *)((char *)&v276 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0));
  v41 = MEMORY[0x1E0C80A78](v39);
  v303 = (uint64_t *)((char *)&v276 - v42);
  v43 = MEMORY[0x1E0C80A78](v41);
  v309 = (uint64_t *)((char *)&v276 - v44);
  v45 = MEMORY[0x1E0C80A78](v43);
  v314 = (uint64_t *)((char *)&v276 - v46);
  v47 = MEMORY[0x1E0C80A78](v45);
  v323 = (uint64_t *)((char *)&v276 - v48);
  MEMORY[0x1E0C80A78](v47);
  v327 = (uint64_t *)((char *)&v276 - v49);
  RangeFunction = type metadata accessor for PgQuery_RangeFunction(0);
  v333 = *(_QWORD *)(RangeFunction - 8);
  MEMORY[0x1E0C80A78](RangeFunction);
  v329 = (uint64_t)&v276 - ((v50 + 15) & 0xFFFFFFFFFFFFFFF0);
  v51 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_RangeFunction?);
  v52 = MEMORY[0x1E0C80A78](v51);
  v330 = (uint64_t)&v276 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v52);
  v332 = (uint64_t)&v276 - v54;
  v347 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  v346 = *(_QWORD *)(v347 - 8);
  v55 = MEMORY[0x1E0C80A78](v347);
  v331 = (uint64_t)&v276 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v55);
  v334 = (uint64_t)&v276 - v57;
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  v58 = *(_QWORD *)(RangeVar - 8);
  MEMORY[0x1E0C80A78](RangeVar);
  v339 = (uint64_t)&v276 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0);
  v345 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v60 = MEMORY[0x1E0C80A78](v345);
  v290 = (uint64_t)&v276 - ((v61 + 15) & 0xFFFFFFFFFFFFFFF0);
  v62 = MEMORY[0x1E0C80A78](v60);
  v291 = (uint64_t)&v276 - v63;
  v64 = MEMORY[0x1E0C80A78](v62);
  v297 = (uint64_t)&v276 - v65;
  v66 = MEMORY[0x1E0C80A78](v64);
  v299 = (uint64_t)&v276 - v67;
  v68 = MEMORY[0x1E0C80A78](v66);
  v300 = (uint64_t)&v276 - v69;
  v70 = MEMORY[0x1E0C80A78](v68);
  v304 = (uint64_t)&v276 - v71;
  v72 = MEMORY[0x1E0C80A78](v70);
  v307 = (uint64_t)&v276 - v73;
  v74 = MEMORY[0x1E0C80A78](v72);
  v310 = (uint64_t)&v276 - v75;
  v76 = MEMORY[0x1E0C80A78](v74);
  v313 = (uint64_t)&v276 - v77;
  v78 = MEMORY[0x1E0C80A78](v76);
  v315 = (uint64_t)&v276 - v79;
  v80 = MEMORY[0x1E0C80A78](v78);
  v317 = (uint64_t)&v276 - v81;
  v82 = MEMORY[0x1E0C80A78](v80);
  v320 = (uint64_t)&v276 - v83;
  v84 = MEMORY[0x1E0C80A78](v82);
  v322 = (uint64_t)&v276 - v85;
  v86 = MEMORY[0x1E0C80A78](v84);
  v326 = (uint64_t)&v276 - v87;
  v88 = MEMORY[0x1E0C80A78](v86);
  v336 = (char *)&v276 - v89;
  v90 = MEMORY[0x1E0C80A78](v88);
  v92 = (char *)&v276 - v91;
  v93 = MEMORY[0x1E0C80A78](v90);
  v95 = (char *)&v276 - v94;
  v96 = MEMORY[0x1E0C80A78](v93);
  v98 = (char *)&v276 - v97;
  MEMORY[0x1E0C80A78](v96);
  v100 = (char *)&v276 - v99;
  v101 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_RangeVar?);
  v102 = MEMORY[0x1E0C80A78](v101);
  v340 = (uint64_t)&v276 - ((v103 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v102);
  v105 = (char *)&v276 - v104;
  Node = type metadata accessor for PgQuery_Node(0);
  v107 = *(_QWORD *)(Node - 8);
  v108 = MEMORY[0x1E0C80A78](Node);
  v109 = MEMORY[0x1E0C80A78](v108);
  v110 = MEMORY[0x1E0C80A78](v109);
  v111 = MEMORY[0x1E0C80A78](v110);
  v112 = MEMORY[0x1E0C80A78](v111);
  if (!*(_QWORD *)(a1 + 16))
  {
    swift_bridgeObjectRelease();
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v124 = 0xD00000000000002FLL;
    *(_QWORD *)(v124 + 8) = 0x800000018DCD17E0;
    *(_QWORD *)(v124 + 16) = 0;
    *(_QWORD *)(v124 + 24) = 0;
    *(_BYTE *)(v124 + 32) = 1;
    swift_willThrow();
    v125 = type metadata accessor for PlanResources;
    v126 = (uint64_t)a2;
    return outlined destroy of PgQuery_Alias(v126, v125);
  }
  v284 = *(_QWORD *)(a1 + 16);
  v283 = v113;
  v278 = v10;
  v276 = v117;
  v277 = v116;
  v280 = v115;
  v344 = a2;
  v285 = v107;
  v279 = (*(unsigned __int8 *)(v107 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v107 + 80);
  v118 = v112;
  v281 = a1 + v279;
  v119 = (char *)&v276 - v114;
  outlined init with copy of PgQuery_RawStmt(a1 + v279, (uint64_t)&v276 - v114, type metadata accessor for PgQuery_Node);
  v120 = (uint64_t)v105;
  v287 = (char *)v58;
  v121 = *(void (**)(void))(v58 + 56);
  v343 = (unsigned int (*)(uint64_t, uint64_t, uint64_t))v120;
  v121();
  v282 = v118;
  v122 = *(int *)(v118 + 20);
  v342 = v119;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v119[v122]+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, (uint64_t)v100, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v341 = v100;
  outlined init with copy of PgQuery_Alias?((uint64_t)v100, (uint64_t)v98, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v123 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v346 + 48);
  if (v123(v98, 1, v347) == 1)
  {
    swift_bridgeObjectRelease();
LABEL_11:
    v134 = (uint64_t)v341;
    *(_QWORD *)&v350 = 0;
    *((_QWORD *)&v350 + 1) = 0xE000000000000000;
    _StringGuts.grow(_:)(49);
    swift_bridgeObjectRelease();
    *(_QWORD *)&v350 = 0xD00000000000002FLL;
    *((_QWORD *)&v350 + 1) = 0x800000018DCD1750;
    outlined init with copy of PgQuery_Alias?(v134, (uint64_t)v92, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v135._countAndFlagsBits = String.init<A>(describing:)();
    String.append(_:)(v135);
    swift_bridgeObjectRelease();
    v136 = v350;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_OWORD *)v137 = v136;
    *(_QWORD *)(v137 + 16) = 0;
    *(_QWORD *)(v137 + 24) = 0;
    *(_BYTE *)(v137 + 32) = 1;
    swift_willThrow();
    outlined destroy of PgQuery_Alias((uint64_t)v344, type metadata accessor for PlanResources);
    outlined destroy of (key: String, value: StorableValue)(v134, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v343, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    outlined destroy of PgQuery_Alias((uint64_t)v342, type metadata accessor for PgQuery_Node);
    return outlined destroy of (key: String, value: StorableValue)((uint64_t)v98, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  }
  v286 = a1;
  outlined init with copy of PgQuery_Alias?((uint64_t)v98, (uint64_t)v95, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if (swift_getEnumCaseMultiPayload() != 1)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias((uint64_t)v95, type metadata accessor for PgQuery_Node.OneOf_Node);
    goto LABEL_11;
  }
  v128 = (uint64_t)v343;
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v343, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined init with take of PgQuery_OidList((uint64_t)v95, v128, type metadata accessor for PgQuery_RangeVar);
  v129 = RangeVar;
  ((void (*)(uint64_t, _QWORD, uint64_t, uint64_t))v121)(v128, 0, 1, RangeVar);
  v130 = (unsigned int (*)(uint64_t, uint64_t, uint64_t))v128;
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v98, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v131 = v340;
  outlined init with copy of PgQuery_Alias?(v128, v340, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  if ((*((unsigned int (**)(uint64_t, uint64_t, uint64_t))v287 + 6))(v131, 1, v129) == 1)
  {
    swift_bridgeObjectRelease();
    outlined destroy of (key: String, value: StorableValue)(v131, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v132 = 0xD00000000000001CLL;
    *(_QWORD *)(v132 + 8) = 0x800000018DCD1780;
    *(_QWORD *)(v132 + 16) = 0;
    *(_QWORD *)(v132 + 24) = 0;
    *(_BYTE *)(v132 + 32) = 1;
    swift_willThrow();
    outlined destroy of PgQuery_Alias((uint64_t)v344, type metadata accessor for PlanResources);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v133 = v128;
LABEL_9:
    outlined destroy of (key: String, value: StorableValue)(v133, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    v125 = type metadata accessor for PgQuery_Node;
    v126 = (uint64_t)v342;
    return outlined destroy of PgQuery_Alias(v126, v125);
  }
  v138 = v339;
  outlined init with take of PgQuery_OidList(v131, v339, type metadata accessor for PgQuery_RangeVar);
  v139 = v344;
  v348 = *v344;
  swift_bridgeObjectRetain();
  v140 = v338;
  static Schema.lookup(rangeVar:catalog:)((_QWORD *)v138, &v348, &v350);
  RangeVar = v140;
  if (v140)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias((uint64_t)v139, type metadata accessor for PlanResources);
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v138, type metadata accessor for PgQuery_RangeVar);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of (key: String, value: StorableValue)(v128, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    v141 = (uint64_t)v342;
    return outlined destroy of PgQuery_Alias(v141, type metadata accessor for PgQuery_Node);
  }
  v142 = &v350;
  swift_bridgeObjectRelease();
  v143 = v350;
  v144 = v351;
  v340 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<Schema>);
  v145 = swift_allocObject();
  *(_OWORD *)(v145 + 16) = xmmword_18DC0CE20;
  v345 = v143;
  *(_QWORD *)(v145 + 32) = v143;
  v146 = v286;
  *(_QWORD *)(v145 + 40) = *((_QWORD *)&v143 + 1);
  *(_QWORD *)(v145 + 48) = v144;
  v346 = v144;
  v354 = 0u;
  v355 = 0u;
  v352 = 0u;
  v353 = 0u;
  v350 = 0u;
  v351 = 0u;
  if (*(_QWORD *)(v146 + 16) < v284)
  {
    __break(1u);
    goto LABEL_76;
  }
  v147 = RangeFunction;
  v148 = (uint64_t)v336;
  v149 = v283;
  if (v284 != 2)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias((uint64_t)v344, type metadata accessor for PlanResources);
    outlined destroy of PgQuery_Alias(v138, type metadata accessor for PgQuery_RangeVar);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v130, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    v150 = (uint64_t)v342;
LABEL_20:
    outlined destroy of PgQuery_Alias(v150, type metadata accessor for PgQuery_Node);
    goto LABEL_21;
  }
  v338 = xmmword_18DC0CE20;
  outlined init with copy of PgQuery_RawStmt(v281 + *(_QWORD *)(v285 + 72), v283, type metadata accessor for PgQuery_Node);
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v149 + *(int *)(v282 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v148, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  outlined destroy of PgQuery_Alias(v149, type metadata accessor for PgQuery_Node);
  if (v123((char *)v148, 1, v347) != 1)
  {
    v284 = *((_QWORD *)&v143 + 1);
    v287 = (char *)v145;
    v152 = v148;
    v153 = v334;
    outlined init with take of PgQuery_OidList(v152, v334, type metadata accessor for PgQuery_Node.OneOf_Node);
    v154 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v333 + 56);
    v155 = v332;
    v154(v332, 1, 1, v143);
    v156 = v153;
    v157 = v331;
    outlined init with copy of PgQuery_RawStmt(v156, v331, type metadata accessor for PgQuery_Node.OneOf_Node);
    if (swift_getEnumCaseMultiPayload() != 182)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(_QWORD *)v159 = 0xD000000000000030;
      *(_QWORD *)(v159 + 8) = 0x800000018DCD17A0;
      *(_QWORD *)(v159 + 16) = 0;
      *(_QWORD *)(v159 + 24) = 0;
      *(_BYTE *)(v159 + 32) = 1;
      swift_willThrow();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias((uint64_t)v344, type metadata accessor for PlanResources);
      outlined destroy of (key: String, value: StorableValue)(v155, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
      outlined destroy of PgQuery_Alias(v334, type metadata accessor for PgQuery_Node.OneOf_Node);
      outlined destroy of (key: String, value: StorableValue)((uint64_t)&v350, &demangling cache variable for type metadata for SQLExpression?);
      outlined destroy of PgQuery_Alias(v138, type metadata accessor for PgQuery_RangeVar);
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v130, &demangling cache variable for type metadata for PgQuery_RangeVar?);
      outlined destroy of PgQuery_Alias((uint64_t)v342, type metadata accessor for PgQuery_Node);
      v126 = v157;
      v125 = type metadata accessor for PgQuery_Node.OneOf_Node;
      return outlined destroy of PgQuery_Alias(v126, v125);
    }
    outlined destroy of (key: String, value: StorableValue)(v155, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
    outlined init with take of PgQuery_OidList(v157, v155, type metadata accessor for PgQuery_RangeFunction);
    v154(v155, 0, 1, v147);
    v158 = v330;
    outlined init with copy of PgQuery_Alias?(v155, v330, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v333 + 48))(v158, 1, v147) == 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of (key: String, value: StorableValue)(v158, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
LABEL_60:
      v162 = v334;
      goto LABEL_61;
    }
    v160 = v329;
    outlined init with take of PgQuery_OidList(v158, v329, type metadata accessor for PgQuery_RangeFunction);
    v161 = *(_QWORD *)(v160 + 8);
    v162 = v334;
    if (*(_QWORD *)(v161 + 16) != 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v160, type metadata accessor for PgQuery_RangeFunction);
      swift_bridgeObjectRelease();
LABEL_61:
      v184 = v344;
LABEL_62:
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(_QWORD *)v185 = 0xD000000000000030;
      *(_QWORD *)(v185 + 8) = 0x800000018DCD17A0;
      *(_QWORD *)(v185 + 16) = 0;
      *(_QWORD *)(v185 + 24) = 0;
      *(_BYTE *)(v185 + 32) = 1;
      swift_willThrow();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias((uint64_t)v184, type metadata accessor for PlanResources);
      outlined destroy of (key: String, value: StorableValue)(v155, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
      outlined destroy of PgQuery_Alias(v162, type metadata accessor for PgQuery_Node.OneOf_Node);
      outlined destroy of (key: String, value: StorableValue)((uint64_t)&v350, &demangling cache variable for type metadata for SQLExpression?);
      outlined destroy of PgQuery_Alias(v138, type metadata accessor for PgQuery_RangeVar);
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      v133 = (uint64_t)v130;
      goto LABEL_9;
    }
    v163 = v280;
    outlined init with copy of PgQuery_RawStmt(v161 + v279, v280, type metadata accessor for PgQuery_Node);
    v138 = *(int *)(v282 + 20);
    v164 = v326;
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v163 + v138)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v326, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v123((char *)v164, 1, v347) == 1)
    {
      outlined destroy of (key: String, value: StorableValue)(v164, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      v165 = v327;
    }
    else
    {
      EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
      v165 = v327;
      if (EnumCaseMultiPayload == 225)
      {
        outlined init with take of PgQuery_OidList(v164, (uint64_t)v327, type metadata accessor for PgQuery_List);
        goto LABEL_34;
      }
      outlined destroy of PgQuery_Alias(v164, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    *v165 = MEMORY[0x1E0DEE9D8];
    UnknownStorage.init()();
LABEL_34:
    v167 = *v165;
    swift_bridgeObjectRetain();
    outlined destroy of PgQuery_Alias((uint64_t)v165, type metadata accessor for PgQuery_List);
    v168 = *(_QWORD *)(v167 + 16);
    swift_bridgeObjectRelease();
    if (v168 != 2)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v280, type metadata accessor for PgQuery_Node);
      outlined destroy of PgQuery_Alias(v160, type metadata accessor for PgQuery_RangeFunction);
      swift_bridgeObjectRelease();
LABEL_59:
      v138 = v339;
      goto LABEL_60;
    }
    v169 = v322;
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v280 + v138)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v322, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v123((char *)v169, 1, v347) == 1)
    {
      outlined destroy of (key: String, value: StorableValue)(v169, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      v170 = v323;
    }
    else
    {
      v171 = swift_getEnumCaseMultiPayload();
      v170 = v323;
      if (v171 == 225)
      {
        outlined init with take of PgQuery_OidList(v169, (uint64_t)v323, type metadata accessor for PgQuery_List);
        goto LABEL_42;
      }
      outlined destroy of PgQuery_Alias(v169, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    *v170 = MEMORY[0x1E0DEE9D8];
    UnknownStorage.init()();
LABEL_42:
    v172 = *v170;
    swift_bridgeObjectRetain();
    outlined destroy of PgQuery_Alias((uint64_t)v170, type metadata accessor for PgQuery_List);
    if (*(_QWORD *)(v172 + 16))
    {
      v173 = v325;
      outlined init with copy of PgQuery_RawStmt(v172 + v279, v325, type metadata accessor for PgQuery_Node);
      v174 = v285;
      v142 = *(__int128 **)(v285 + 56);
      v175 = v173;
      v176 = 0;
    }
    else
    {
      v174 = v285;
      v142 = *(__int128 **)(v285 + 56);
      v173 = v325;
      v175 = v325;
      v176 = 1;
    }
    v177 = v282;
    ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v175, v176, 1, v282);
    swift_bridgeObjectRelease();
    v130 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v174 + 48);
    if (v130(v173, 1, v177) == 1)
    {
      outlined destroy of (key: String, value: StorableValue)(v173, &demangling cache variable for type metadata for PgQuery_Node?);
LABEL_58:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v280, type metadata accessor for PgQuery_Node);
      outlined destroy of PgQuery_Alias(v329, type metadata accessor for PgQuery_RangeFunction);
      swift_bridgeObjectRelease();
      v130 = v343;
      goto LABEL_59;
    }
    v178 = v320;
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v173 + *(int *)(v177 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v320, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v123((char *)v178, 1, v347) == 1)
    {
      outlined destroy of (key: String, value: StorableValue)(v178, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    else
    {
      if (swift_getEnumCaseMultiPayload() == 170)
      {
        v179 = v321;
        outlined init with take of PgQuery_OidList(v178, v321, type metadata accessor for PgQuery_FuncCall);
        goto LABEL_55;
      }
      outlined destroy of PgQuery_Alias(v178, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    v179 = v321;
    UnknownStorage.init()();
    v180 = *(int *)(v324 + 20);
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)(v179 + v180) = static PgQuery_FuncCall._StorageClass.defaultInstance;
    swift_retain();
LABEL_55:
    outlined destroy of PgQuery_Alias(v325, type metadata accessor for PgQuery_Node);
    v181 = *(_QWORD *)(*(_QWORD *)(v179 + *(int *)(v324 + 20)) + 16);
    swift_bridgeObjectRetain();
    outlined destroy of PgQuery_Alias(v179, type metadata accessor for PgQuery_FuncCall);
    v182 = *(_QWORD *)(v181 + 16);
    swift_bridgeObjectRelease();
    if (v182 != 1)
      goto LABEL_58;
    v183 = v317;
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v280 + v138)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v317, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v123((char *)v183, 1, v347) == 1)
    {
      outlined destroy of (key: String, value: StorableValue)(v183, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    else
    {
      if (swift_getEnumCaseMultiPayload() == 225)
      {
        v186 = v314;
        outlined init with take of PgQuery_OidList(v317, (uint64_t)v314, type metadata accessor for PgQuery_List);
LABEL_67:
        v187 = *v186;
        swift_bridgeObjectRetain();
        outlined destroy of PgQuery_Alias((uint64_t)v186, type metadata accessor for PgQuery_List);
        if (*(_QWORD *)(v187 + 16))
        {
          v188 = v318;
          outlined init with copy of PgQuery_RawStmt(v187 + v279, v318, type metadata accessor for PgQuery_Node);
          v189 = 0;
        }
        else
        {
          v189 = 1;
          v188 = v318;
        }
        v190 = v282;
        ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v188, v189, 1, v282);
        swift_bridgeObjectRelease();
        if (v130(v188, 1, v190) == 1)
          goto LABEL_85;
        v191 = v315;
        outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v188 + *(int *)(v190 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v315, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        if (v123((char *)v191, 1, v347) == 1)
        {
          outlined destroy of (key: String, value: StorableValue)(v315, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_77:
          UnknownStorage.init()();
          v192 = *(int *)(v324 + 20);
          if (one-time initialization token for defaultInstance != -1)
            swift_once();
          *(_QWORD *)(v316 + v192) = static PgQuery_FuncCall._StorageClass.defaultInstance;
          swift_retain();
LABEL_80:
          outlined destroy of PgQuery_Alias(v318, type metadata accessor for PgQuery_Node);
          v193 = v316;
          v194 = *(_QWORD *)(*(_QWORD *)(v316 + *(int *)(v324 + 20)) + 16);
          swift_bridgeObjectRetain();
          outlined destroy of PgQuery_Alias(v193, type metadata accessor for PgQuery_FuncCall);
          if (*(_QWORD *)(v194 + 16))
          {
            outlined init with copy of PgQuery_RawStmt(v194 + v279, v319, type metadata accessor for PgQuery_Node);
            v195 = 0;
          }
          else
          {
            v195 = 1;
          }
          v196 = v319;
          v197 = v282;
          ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v319, v195, 1, v282);
          swift_bridgeObjectRelease();
          if (v130(v196, 1, v197) == 1)
          {
            v188 = v319;
LABEL_85:
            v198 = v188;
LABEL_86:
            outlined destroy of (key: String, value: StorableValue)(v198, &demangling cache variable for type metadata for PgQuery_Node?);
LABEL_87:
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            outlined destroy of PgQuery_Alias(v280, type metadata accessor for PgQuery_Node);
            outlined destroy of PgQuery_Alias(v329, type metadata accessor for PgQuery_RangeFunction);
            swift_bridgeObjectRelease();
LABEL_88:
            v184 = v344;
            v130 = v343;
            v138 = v339;
            v162 = v334;
            v155 = v332;
            goto LABEL_62;
          }
          v199 = v313;
          outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v319 + *(int *)(v282 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v313, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          if (v123((char *)v199, 1, v347) == 1)
          {
            outlined destroy of (key: String, value: StorableValue)(v313, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          }
          else
          {
            if (swift_getEnumCaseMultiPayload() == 222)
            {
              outlined init with take of PgQuery_OidList(v313, (uint64_t)v311, type metadata accessor for PgQuery_String);
LABEL_95:
              outlined destroy of PgQuery_Alias(v319, type metadata accessor for PgQuery_Node);
              v201 = v311;
              v203 = *v311;
              v202 = v311[1];
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias((uint64_t)v201, type metadata accessor for PgQuery_String);
              if (v203 == 0x6361655F6E6F736ALL && v202 == 0xE900000000000068)
              {
                swift_bridgeObjectRelease();
              }
              else
              {
                v204 = _stringCompareWithSmolCheck(_:_:expecting:)();
                swift_bridgeObjectRelease();
                if ((v204 & 1) == 0)
                  goto LABEL_87;
              }
              v205 = v310;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v280 + v138)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v310, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v205, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v310, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 225)
                {
                  outlined init with take of PgQuery_OidList(v310, (uint64_t)v309, type metadata accessor for PgQuery_List);
                  goto LABEL_105;
                }
                outlined destroy of PgQuery_Alias(v310, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              *v309 = MEMORY[0x1E0DEE9D8];
              UnknownStorage.init()();
LABEL_105:
              v206 = v309;
              v207 = *v309;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias((uint64_t)v206, type metadata accessor for PgQuery_List);
              if (*(_QWORD *)(v207 + 16))
              {
                outlined init with copy of PgQuery_RawStmt(v207 + v279, v312, type metadata accessor for PgQuery_Node);
                v208 = 0;
              }
              else
              {
                v208 = 1;
              }
              v209 = v312;
              v210 = v282;
              ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v312, v208, 1, v282);
              swift_bridgeObjectRelease();
              if (v130(v209, 1, v210) == 1)
              {
                p_RangeFunction = (uint64_t *)&v343;
LABEL_143:
                v198 = *(p_RangeFunction - 32);
                goto LABEL_86;
              }
              v212 = v307;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v312 + *(int *)(v282 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v307, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v212, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v307, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 170)
                {
                  outlined init with take of PgQuery_OidList(v307, v308, type metadata accessor for PgQuery_FuncCall);
                  goto LABEL_118;
                }
                outlined destroy of PgQuery_Alias(v307, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              UnknownStorage.init()();
              v213 = *(int *)(v324 + 20);
              if (one-time initialization token for defaultInstance != -1)
                swift_once();
              *(_QWORD *)(v308 + v213) = static PgQuery_FuncCall._StorageClass.defaultInstance;
              swift_retain();
LABEL_118:
              outlined destroy of PgQuery_Alias(v312, type metadata accessor for PgQuery_Node);
              v214 = v308;
              v215 = *(_QWORD *)(*(_QWORD *)(v308 + *(int *)(v324 + 20)) + 24);
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias(v214, type metadata accessor for PgQuery_FuncCall);
              v216 = *(_QWORD *)(v215 + 16);
              swift_bridgeObjectRelease();
              if (v216 != 1)
                goto LABEL_87;
              v217 = v304;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v280 + v138)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v304, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v217, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v304, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 225)
                {
                  outlined init with take of PgQuery_OidList(v304, (uint64_t)v303, type metadata accessor for PgQuery_List);
                  goto LABEL_125;
                }
                outlined destroy of PgQuery_Alias(v304, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              *v303 = MEMORY[0x1E0DEE9D8];
              UnknownStorage.init()();
LABEL_125:
              v218 = v303;
              v219 = *v303;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias((uint64_t)v218, type metadata accessor for PgQuery_List);
              if (*(_QWORD *)(v219 + 16))
              {
                outlined init with copy of PgQuery_RawStmt(v219 + v279, v305, type metadata accessor for PgQuery_Node);
                v220 = 0;
              }
              else
              {
                v220 = 1;
              }
              v221 = v305;
              v222 = v282;
              ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v305, v220, 1, v282);
              swift_bridgeObjectRelease();
              if (v130(v221, 1, v222) == 1)
                goto LABEL_142;
              v223 = v300;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v305 + *(int *)(v282 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v300, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v223, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v300, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 170)
                {
                  outlined init with take of PgQuery_OidList(v300, v301, type metadata accessor for PgQuery_FuncCall);
                  goto LABEL_137;
                }
                outlined destroy of PgQuery_Alias(v300, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              UnknownStorage.init()();
              v224 = *(int *)(v324 + 20);
              if (one-time initialization token for defaultInstance != -1)
                swift_once();
              *(_QWORD *)(v301 + v224) = static PgQuery_FuncCall._StorageClass.defaultInstance;
              swift_retain();
LABEL_137:
              outlined destroy of PgQuery_Alias(v305, type metadata accessor for PgQuery_Node);
              v225 = v301;
              v226 = *(_QWORD *)(*(_QWORD *)(v301 + *(int *)(v324 + 20)) + 24);
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias(v225, type metadata accessor for PgQuery_FuncCall);
              if (*(_QWORD *)(v226 + 16))
              {
                outlined init with copy of PgQuery_RawStmt(v226 + v279, v302, type metadata accessor for PgQuery_Node);
                v227 = 0;
              }
              else
              {
                v227 = 1;
              }
              v228 = v302;
              v229 = v282;
              ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v302, v227, 1, v282);
              swift_bridgeObjectRelease();
              if (v130(v228, 1, v229) == 1)
              {
                v305 = v302;
LABEL_142:
                p_RangeFunction = &RangeFunction;
                goto LABEL_143;
              }
              v230 = v299;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v302 + *(int *)(v282 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v299, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v230, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v299, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 167)
                {
                  outlined init with take of PgQuery_OidList(v299, (uint64_t)v278, type metadata accessor for PgQuery_ColumnRef);
                  goto LABEL_150;
                }
                outlined destroy of PgQuery_Alias(v299, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              v231 = v278;
              *v278 = MEMORY[0x1E0DEE9D8];
              *((_DWORD *)v231 + 2) = 0;
              UnknownStorage.init()();
LABEL_150:
              outlined destroy of PgQuery_Alias(v302, type metadata accessor for PgQuery_Node);
              v232 = v278;
              v233 = *v278;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias((uint64_t)v232, type metadata accessor for PgQuery_ColumnRef);
              v234 = *(_QWORD *)(v233 + 16);
              swift_bridgeObjectRelease();
              if (v234 != 1)
                goto LABEL_87;
              v235 = v297;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v280 + v138)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v297, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v235, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v297, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 225)
                {
                  outlined init with take of PgQuery_OidList(v297, (uint64_t)v295, type metadata accessor for PgQuery_List);
                  goto LABEL_157;
                }
                outlined destroy of PgQuery_Alias(v297, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              *v295 = MEMORY[0x1E0DEE9D8];
              UnknownStorage.init()();
LABEL_157:
              v236 = v295;
              v237 = *v295;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias((uint64_t)v236, type metadata accessor for PgQuery_List);
              if (*(_QWORD *)(v237 + 16))
              {
                outlined init with copy of PgQuery_RawStmt(v237 + v279, v298, type metadata accessor for PgQuery_Node);
                v238 = 0;
              }
              else
              {
                v238 = 1;
              }
              v239 = v298;
              v240 = v282;
              ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v298, v238, 1, v282);
              swift_bridgeObjectRelease();
              if (v130(v239, 1, v240) == 1)
                goto LABEL_174;
              v241 = v291;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v298 + *(int *)(v282 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v291, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v241, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v291, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 170)
                {
                  outlined init with take of PgQuery_OidList(v291, v292, type metadata accessor for PgQuery_FuncCall);
                  goto LABEL_169;
                }
                outlined destroy of PgQuery_Alias(v291, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              UnknownStorage.init()();
              v242 = *(int *)(v324 + 20);
              if (one-time initialization token for defaultInstance != -1)
                swift_once();
              *(_QWORD *)(v292 + v242) = static PgQuery_FuncCall._StorageClass.defaultInstance;
              swift_retain();
LABEL_169:
              outlined destroy of PgQuery_Alias(v298, type metadata accessor for PgQuery_Node);
              v243 = v292;
              v244 = *(_QWORD *)(*(_QWORD *)(v292 + *(int *)(v324 + 20)) + 24);
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias(v243, type metadata accessor for PgQuery_FuncCall);
              if (*(_QWORD *)(v244 + 16))
              {
                outlined init with copy of PgQuery_RawStmt(v244 + v279, v293, type metadata accessor for PgQuery_Node);
                v245 = 0;
              }
              else
              {
                v245 = 1;
              }
              v246 = v293;
              v247 = v282;
              ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v293, v245, 1, v282);
              swift_bridgeObjectRelease();
              if (v130(v246, 1, v247) == 1)
              {
                v298 = v293;
LABEL_174:
                outlined destroy of (key: String, value: StorableValue)(v298, &demangling cache variable for type metadata for PgQuery_Node?);
                ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v296, 1, 1, v282);
LABEL_175:
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                outlined destroy of PgQuery_Alias(v280, type metadata accessor for PgQuery_Node);
                outlined destroy of PgQuery_Alias(v329, type metadata accessor for PgQuery_RangeFunction);
                swift_bridgeObjectRelease();
                outlined destroy of (key: String, value: StorableValue)(v296, &demangling cache variable for type metadata for PgQuery_Node?);
                goto LABEL_88;
              }
              v248 = v290;
              outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v293 + *(int *)(v282 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v290, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (v123((char *)v248, 1, v347) == 1)
              {
                outlined destroy of (key: String, value: StorableValue)(v290, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 167)
                {
                  outlined init with take of PgQuery_OidList(v290, (uint64_t)v289, type metadata accessor for PgQuery_ColumnRef);
                  goto LABEL_182;
                }
                outlined destroy of PgQuery_Alias(v290, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              v249 = v289;
              *v289 = MEMORY[0x1E0DEE9D8];
              *((_DWORD *)v249 + 2) = 0;
              UnknownStorage.init()();
LABEL_182:
              outlined destroy of PgQuery_Alias(v293, type metadata accessor for PgQuery_Node);
              v250 = v289;
              v251 = *v289;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_Alias((uint64_t)v250, type metadata accessor for PgQuery_ColumnRef);
              if (*(_QWORD *)(v251 + 16))
              {
                outlined init with copy of PgQuery_RawStmt(v251 + v279, v296, type metadata accessor for PgQuery_Node);
                v252 = 0;
              }
              else
              {
                v252 = 1;
              }
              v253 = v296;
              v254 = v282;
              ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v142)(v296, v252, 1, v282);
              swift_bridgeObjectRelease();
              if (v130(v253, 1, v254) == 1)
                goto LABEL_175;
              v255 = v277;
              outlined init with take of PgQuery_OidList(v296, v277, type metadata accessor for PgQuery_Node);
              v256 = v276;
              outlined init with copy of PgQuery_RawStmt(v255, v276, type metadata accessor for PgQuery_Node);
              v257 = swift_allocObject();
              *(_OWORD *)(v257 + 16) = v338;
              v258 = v284;
              *(_QWORD *)(v257 + 32) = v345;
              *(_QWORD *)(v257 + 40) = v258;
              *(_QWORD *)(v257 + 48) = v346;
              v259 = type metadata accessor for PlanResources(0);
              v260 = v288;
              outlined init with copy of PgQuery_RawStmt((uint64_t)v344 + *(int *)(v259 + 20), v288, type metadata accessor for SQLTokenInformation);
              v261 = RangeVar;
              SQLExpression.init(expressionNode:schemas:tokenInformation:)(v256, v257, v260, (uint64_t)&v348);
              RangeVar = v261;
              if (v261)
              {
                swift_bridgeObjectRelease();
                outlined destroy of PgQuery_Alias((uint64_t)v344, type metadata accessor for PlanResources);
                outlined destroy of PgQuery_Alias(v277, type metadata accessor for PgQuery_Node);
                outlined destroy of PgQuery_Alias(v280, type metadata accessor for PgQuery_Node);
                outlined destroy of PgQuery_Alias(v329, type metadata accessor for PgQuery_RangeFunction);
                outlined destroy of (key: String, value: StorableValue)(v332, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
                outlined destroy of PgQuery_Alias(v334, type metadata accessor for PgQuery_Node.OneOf_Node);
                outlined destroy of (key: String, value: StorableValue)((uint64_t)&v350, &demangling cache variable for type metadata for SQLExpression?);
                swift_bridgeObjectRelease();
                outlined destroy of PgQuery_Alias(v339, type metadata accessor for PgQuery_RangeVar);
                outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
                outlined destroy of (key: String, value: StorableValue)((uint64_t)v343, &demangling cache variable for type metadata for PgQuery_RangeVar?);
                v141 = (uint64_t)v342;
                return outlined destroy of PgQuery_Alias(v141, type metadata accessor for PgQuery_Node);
              }
              outlined destroy of (key: String, value: StorableValue)((uint64_t)&v350, &demangling cache variable for type metadata for SQLExpression?);
              outlined init with copy of SQLExpression((uint64_t)&v348, (uint64_t)&v350);
              v262 = v349;
              __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, SQLDataType)>);
              inited = swift_initStackObject();
              *(_OWORD *)(inited + 16) = v338;
              *(_QWORD *)(inited + 32) = 0x65756C6176;
              *(_QWORD *)(inited + 40) = 0xE500000000000000;
              *(_BYTE *)(inited + 48) = v262;
              __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
              v264 = (_QWORD *)static _DictionaryStorage.allocate(capacity:)();
              v265 = *(_QWORD *)(inited + 32);
              v266 = *(_QWORD *)(inited + 40);
              v267 = *(_BYTE *)(inited + 48);
              swift_retain();
              swift_bridgeObjectRetain();
              v268 = specialized __RawDictionaryStorage.find<A>(_:)();
              if ((v270 & 1) != 0)
              {
                __break(1u);
              }
              else
              {
                v264[(v268 >> 6) + 8] |= 1 << v268;
                v271 = (unint64_t *)(v264[6] + 16 * v268);
                *v271 = v265;
                v271[1] = v266;
                *(_BYTE *)(v264[7] + v268) = v267;
                v272 = v264[2];
                v273 = __OFADD__(v272, 1);
                v269 = v272 + 1;
                if (!v273)
                {
                  v264[2] = v269;
                  swift_release();
                  swift_bridgeObjectRelease();
                  v265 = *((_QWORD *)v287 + 2);
                  v269 = *((_QWORD *)v287 + 3);
                  inited = v265 + 1;
                  if (v265 < v269 >> 1)
                  {
LABEL_191:
                    v274 = v287;
                    *((_QWORD *)v287 + 2) = inited;
                    v275 = &v274[24 * v265];
                    v145 = (uint64_t)v274;
                    *((_QWORD *)v275 + 4) = 0x6361655F6E6F736ALL;
                    *((_QWORD *)v275 + 5) = 0xE900000000000068;
                    *((_QWORD *)v275 + 6) = v264;
                    swift_bridgeObjectRelease();
                    outlined destroy of PgQuery_Alias((uint64_t)v344, type metadata accessor for PlanResources);
                    outlined destroy of SQLExpression((uint64_t)&v348);
                    outlined destroy of PgQuery_Alias(v277, type metadata accessor for PgQuery_Node);
                    outlined destroy of PgQuery_Alias(v280, type metadata accessor for PgQuery_Node);
                    outlined destroy of PgQuery_Alias(v329, type metadata accessor for PgQuery_RangeFunction);
                    outlined destroy of (key: String, value: StorableValue)(v332, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
                    outlined destroy of PgQuery_Alias(v334, type metadata accessor for PgQuery_Node.OneOf_Node);
                    outlined destroy of PgQuery_Alias(v339, type metadata accessor for PgQuery_RangeVar);
                    outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
                    outlined destroy of (key: String, value: StorableValue)((uint64_t)v343, &demangling cache variable for type metadata for PgQuery_RangeVar?);
                    v150 = (uint64_t)v342;
                    goto LABEL_20;
                  }
LABEL_194:
                  v287 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v269 > 1), inited, 1, v287);
                  goto LABEL_191;
                }
              }
              __break(1u);
              goto LABEL_194;
            }
            outlined destroy of PgQuery_Alias(v313, type metadata accessor for PgQuery_Node.OneOf_Node);
          }
          v200 = v311;
          *v311 = 0;
          v200[1] = 0xE000000000000000;
          UnknownStorage.init()();
          goto LABEL_95;
        }
        if (swift_getEnumCaseMultiPayload() == 170)
        {
          outlined init with take of PgQuery_OidList(v315, v316, type metadata accessor for PgQuery_FuncCall);
          goto LABEL_80;
        }
LABEL_76:
        outlined destroy of PgQuery_Alias(v315, type metadata accessor for PgQuery_Node.OneOf_Node);
        goto LABEL_77;
      }
      outlined destroy of PgQuery_Alias(v317, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    v186 = v314;
    *v314 = MEMORY[0x1E0DEE9D8];
    UnknownStorage.init()();
    goto LABEL_67;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_Alias((uint64_t)v344, type metadata accessor for PlanResources);
  outlined destroy of PgQuery_Alias(v138, type metadata accessor for PgQuery_RangeVar);
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v341, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v130, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined destroy of PgQuery_Alias((uint64_t)v342, type metadata accessor for PgQuery_Node);
  outlined destroy of (key: String, value: StorableValue)(v148, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_21:
  v151 = v335;
  *v335 = v145;
  return outlined init with take of (key: String, value: StorableValue)((uint64_t)&v350, (uint64_t)(v151 + 1), &demangling cache variable for type metadata for SQLExpression?);
}

uint64_t specialized Collection.dropFirst(_:)(uint64_t result, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (result < 0)
  {
    __break(1u);
  }
  else
  {
    v3 = *(_QWORD *)(a2 + 16);
    if ((uint64_t)v3 >= result)
      v4 = result;
    else
      v4 = *(_QWORD *)(a2 + 16);
    if (result)
      v5 = v4;
    else
      v5 = 0;
    if (v3 >= v5)
    {
      type metadata accessor for PgQuery_ScanToken(0);
      return a2;
    }
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance FromClause.CodingKeys()
{
  _BYTE *v0;

  if (*v0)
    return 0xD000000000000012;
  else
    return 0x73616D65686373;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance FromClause.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized FromClause.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance FromClause.CodingKeys()
{
  lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance FromClause.CodingKeys()
{
  lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t FromClause.encode(to:)(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE v10[8];
  uint64_t v11;

  v3 = v1;
  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<FromClause.CodingKeys>);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v8 = &v10[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v11 = *v3;
  v10[7] = 0;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [Schema]);
  lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](&lazy protocol witness table cache variable for type [Schema] and conformance <A> [A], &demangling cache variable for type metadata for [Schema], (uint64_t (*)(void))lazy protocol witness table accessor for type Schema and conformance Schema);
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v2)
  {
    v10[6] = 1;
    lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance FromClause(_QWORD *a1)
{
  return FromClause.encode(to:)(a1);
}

uint64_t ResultColumn.documentation.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 112);
  swift_bridgeObjectRetain();
  return v1;
}

__n128 ResultColumn.init(expression:alias:documentation:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int128 v6;
  __int128 v7;
  __n128 result;
  __int128 v9;

  v6 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a6 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a6 + 48) = v6;
  v7 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(a6 + 64) = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a6 + 80) = v7;
  result = *(__n128 *)a1;
  v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a6 = *(_OWORD *)a1;
  *(_OWORD *)(a6 + 16) = v9;
  *(_QWORD *)(a6 + 96) = a2;
  *(_QWORD *)(a6 + 104) = a3;
  *(_QWORD *)(a6 + 112) = a4;
  *(_QWORD *)(a6 + 120) = a5;
  return result;
}

uint64_t ResultColumn.init(node:schemas:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v6;
  uint64_t ScanToken;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Node;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t ResTarget;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  int v41;
  unint64_t v42;
  Swift::String v43;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v46;
  uint64_t (*v47)(uint64_t);
  uint64_t v48;
  uint64_t result;
  uint64_t v50;
  int64_t v51;
  int64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  Swift::Int32 *v59;
  Swift::Int32 v60;
  uint64_t v61;
  Swift::String v62;
  Swift::String v63;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  unsigned int *v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  BOOL v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char v94;
  char v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int64_t v123;
  char *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  char *v133;
  uint64_t v134;
  int64_t v135;
  uint64_t v136;
  char *v137;
  uint64_t *v138;
  uint64_t v139;
  char *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t *v143;
  uint64_t v144;
  uint64_t v145;
  int64_t v146;
  uint64_t v147;
  Swift::String v148;
  Swift::String v149;
  uint64_t v150;

  v142 = a2;
  v130 = a4;
  v141 = type metadata accessor for CharacterSet();
  v125 = *(_QWORD *)(v141 - 8);
  MEMORY[0x1E0C80A78](v141);
  v140 = (char *)&v116 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  v132 = *(_QWORD *)(ScanToken - 8);
  v8 = MEMORY[0x1E0C80A78](ScanToken);
  v10 = (char *)&v116 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v8);
  v133 = (char *)&v116 - v11;
  v126 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1E0C80A78](v126);
  v128 = (char *)&v116 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1E0C80A78](v13);
  v131 = (uint64_t)&v116 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  v127 = *(_QWORD *)(Node - 8);
  v16 = MEMORY[0x1E0C80A78](Node);
  v18 = (uint64_t *)((char *)&v116 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v16);
  v129 = (uint64_t)&v116 - v19;
  v20 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Locale?);
  MEMORY[0x1E0C80A78](v20);
  v124 = (char *)&v116 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (offset: Int, element: PgQuery_ScanToken));
  v144 = *(_QWORD *)(v22 - 8);
  v145 = v22;
  MEMORY[0x1E0C80A78](v22);
  v137 = (char *)&v116 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  v24 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (offset: Int, element: PgQuery_ScanToken)?);
  v25 = MEMORY[0x1E0C80A78](v24);
  v143 = (uint64_t *)((char *)&v116 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v25);
  v138 = (uint64_t *)((char *)&v116 - v27);
  v28 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1E0C80A78](v28);
  v30 = (uint64_t)&v116 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  ResTarget = type metadata accessor for PgQuery_ResTarget(0);
  MEMORY[0x1E0C80A78](ResTarget);
  v33 = (uint64_t *)((char *)&v116 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0));
  v139 = Node;
  v34 = *(int *)(Node + 20);
  v35 = a1;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)(a1 + v34)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v36 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v36 - 8) + 48))(v30, 1, v36) == 1)
  {
    swift_bridgeObjectRelease();
    outlined destroy of (key: String, value: StorableValue)(v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    goto LABEL_13;
  }
  if (swift_getEnumCaseMultiPayload() != 175)
  {
LABEL_12:
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v30, type metadata accessor for PgQuery_Node.OneOf_Node);
LABEL_13:
    v148._countAndFlagsBits = 0;
    v148._object = (void *)0xE000000000000000;
    _StringGuts.grow(_:)(36);
    swift_bridgeObjectRelease();
    v148._countAndFlagsBits = 0xD000000000000022;
    v148._object = (void *)0x800000018DCD1720;
    outlined init with copy of PgQuery_RawStmt(v35, (uint64_t)v18, type metadata accessor for PgQuery_Node);
    v43._countAndFlagsBits = String.init<A>(describing:)();
    String.append(_:)(v43);
    swift_bridgeObjectRelease();
    countAndFlagsBits = v148._countAndFlagsBits;
    object = v148._object;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v46 = countAndFlagsBits;
    *(_QWORD *)(v46 + 8) = object;
    *(_QWORD *)(v46 + 16) = 0;
    *(_QWORD *)(v46 + 24) = 0;
    *(_BYTE *)(v46 + 32) = 1;
    swift_willThrow();
    outlined destroy of PgQuery_Alias(v35, type metadata accessor for PgQuery_Node);
    v47 = type metadata accessor for SQLTokenInformation;
    v48 = a3;
    return outlined destroy of PgQuery_Alias(v48, v47);
  }
  outlined init with take of PgQuery_OidList(v30, (uint64_t)v33, type metadata accessor for PgQuery_ResTarget);
  v37 = *(uint64_t *)((char *)v33 + *(int *)(ResTarget + 20));
  v38 = *(_QWORD *)(v37 + 24);
  v39 = *(_QWORD *)(v37 + 16) & 0xFFFFFFFFFFFFLL;
  if ((v38 & 0x2000000000000000) != 0)
    v39 = HIBYTE(v38) & 0xF;
  v120 = *(int *)(ResTarget + 20);
  if (!v39)
  {
    v18 = v130;
    v130[12] = 0;
    v18[13] = 0;
    ResTarget = (uint64_t)v128;
    v65 = v131;
    a1 = v147;
    goto LABEL_31;
  }
  v121 = a1;
  v30 = *(_QWORD *)(a3 + 8);
  v40 = *(_QWORD **)(v30 + 16);
  if (!v40)
  {
LABEL_71:
    __break(1u);
LABEL_72:
    __break(1u);
LABEL_73:
    __break(1u);
    goto LABEL_74;
  }
  v18 = 0;
  v41 = *(_DWORD *)(v37
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  v35 = *(_QWORD *)(v132 + 72);
  v42 = (*(unsigned __int8 *)(v132 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v132 + 80);
  ResTarget = v145;
  while (*(_DWORD *)(v30 + v42) != v41)
  {
    v42 += v35;
    v18 = (_QWORD *)((char *)v18 + 1);
    if (v40 == v18)
    {
      __break(1u);
      goto LABEL_12;
    }
  }
  v117 = (*(unsigned __int8 *)(v132 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v132 + 80);
  v119 = v33;
  v118 = specialized Collection.dropFirst(_:)((uint64_t)v18, v30);
  v122 = v50;
  v52 = v51;
  v135 = v53 >> 1;
  swift_bridgeObjectRetain();
  v134 = 0;
  v123 = v52;
  v146 = v52;
  v33 = v138;
  v136 = a3;
  while (1)
  {
    a1 = v146;
    if (v146 == v135)
    {
      v55 = (uint64_t)v143;
      v54 = v144;
      v30 = v135;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v144 + 56))(v143, 1, 1, ResTarget);
      v146 = v30;
    }
    else
    {
      if (v146 < v123 || v146 >= v135)
      {
        __break(1u);
LABEL_70:
        __break(1u);
        goto LABEL_71;
      }
      v33 = (uint64_t *)a3;
      v30 = v35;
      v56 = v122 + v146 * v35;
      a3 = ResTarget;
      ResTarget = (uint64_t)&v137[*(int *)(ResTarget + 48)];
      v35 = (uint64_t)type metadata accessor for PgQuery_ScanToken;
      outlined init with copy of PgQuery_RawStmt(v56, ResTarget, type metadata accessor for PgQuery_ScanToken);
      v36 = v134 + 1;
      if (__OFADD__(v134, 1))
        goto LABEL_70;
      v146 = a1 + 1;
      v55 = (uint64_t)v143;
      v57 = (uint64_t)v143 + *(int *)(a3 + 48);
      *v143 = v134;
      outlined init with take of PgQuery_OidList(ResTarget, v57, type metadata accessor for PgQuery_ScanToken);
      v58 = v144;
      (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v144 + 56))(v55, 0, 1, a3);
      v134 = v36;
      v54 = v58;
      ResTarget = a3;
      a3 = (uint64_t)v33;
      v33 = v138;
      v35 = v30;
    }
    outlined init with take of (key: String, value: StorableValue)(v55, (uint64_t)v33, &demangling cache variable for type metadata for (offset: Int, element: PgQuery_ScanToken)?);
    if ((*(unsigned int (**)(uint64_t *, uint64_t, uint64_t))(v54 + 48))(v33, 1, ResTarget) == 1)
    {
      swift_unknownObjectRelease();
      swift_bridgeObjectRelease();
      v69 = (uint64_t)v119;
      v70 = *(uint64_t *)((char *)v119 + v120);
      v72 = *(_QWORD *)(v70 + 16);
      v71 = *(_QWORD *)(v70 + 24);
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(_QWORD *)v73 = v72;
      *(_QWORD *)(v73 + 8) = v71;
      *(_QWORD *)(v73 + 16) = 0;
      *(_QWORD *)(v73 + 24) = 0;
      *(_BYTE *)(v73 + 32) = 8;
      swift_bridgeObjectRetain();
      swift_willThrow();
      outlined destroy of PgQuery_Alias(v121, type metadata accessor for PgQuery_Node);
      outlined destroy of PgQuery_Alias(a3, type metadata accessor for SQLTokenInformation);
      v47 = type metadata accessor for PgQuery_ResTarget;
      v48 = v69;
      return outlined destroy of PgQuery_Alias(v48, v47);
    }
    a1 = *v33;
    v59 = (Swift::Int32 *)((char *)v33 + *(int *)(ResTarget + 48));
    v60 = *v59;
    outlined destroy of PgQuery_Alias((uint64_t)v59, type metadata accessor for PgQuery_ScanToken);
    SQLTokenInformation.tokenName(location:)(v60);
    v147 = v61;
    if (v61)
    {
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v121, type metadata accessor for PgQuery_Node);
      swift_unknownObjectRelease();
      outlined destroy of PgQuery_Alias(v136, type metadata accessor for SQLTokenInformation);
      return outlined destroy of PgQuery_Alias((uint64_t)v119, type metadata accessor for PgQuery_ResTarget);
    }
    v62 = String.lowercased()();
    v36 = v62._countAndFlagsBits;
    ResTarget = (uint64_t)v62._object;
    swift_bridgeObjectRelease();
    v63 = String.lowercased()();
    if (v62._countAndFlagsBits == v63._countAndFlagsBits && v62._object == v63._object)
      break;
    v36 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    a3 = v136;
    ResTarget = v145;
    if ((v36 & 1) != 0)
      goto LABEL_45;
  }
  swift_bridgeObjectRelease_n();
  a3 = v136;
LABEL_45:
  v82 = (char *)v18 + a1;
  if (__OFADD__(v18, a1))
    goto LABEL_72;
  v83 = __OFADD__(v82, 1);
  v84 = v82 + 1;
  if (v83)
    goto LABEL_73;
  v85 = *(_QWORD *)(a3 + 8);
  v33 = v119;
  if ((uint64_t)v84 >= *(_QWORD *)(v85 + 16))
  {
    swift_bridgeObjectRelease();
    v87 = *(uint64_t *)((char *)v33 + v120);
    v89 = *(_QWORD *)(v87 + 16);
    v88 = *(_QWORD *)(v87 + 24);
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v90 = v89;
    *(_QWORD *)(v90 + 8) = v88;
    *(_QWORD *)(v90 + 16) = 0;
    *(_QWORD *)(v90 + 24) = 0;
    *(_BYTE *)(v90 + 32) = 8;
    swift_bridgeObjectRetain();
    swift_willThrow();
    outlined destroy of PgQuery_Alias(v121, type metadata accessor for PgQuery_Node);
    swift_unknownObjectRelease();
    v91 = a3;
LABEL_52:
    outlined destroy of PgQuery_Alias(v91, type metadata accessor for SQLTokenInformation);
    v47 = type metadata accessor for PgQuery_ResTarget;
    v48 = (uint64_t)v33;
    return outlined destroy of PgQuery_Alias(v48, v47);
  }
  if (((unint64_t)v84 & 0x8000000000000000) != 0)
  {
    __break(1u);
    goto LABEL_76;
  }
  SQLTokenInformation.tokenName(location:)(*(_DWORD *)(v85 + v117 + (_QWORD)v84 * v35));
  if (v86)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v121, type metadata accessor for PgQuery_Node);
    swift_unknownObjectRelease();
    outlined destroy of PgQuery_Alias(a3, type metadata accessor for SQLTokenInformation);
    return outlined destroy of PgQuery_Alias((uint64_t)v33, type metadata accessor for PgQuery_ResTarget);
  }
  swift_unknownObjectRelease();
  v148 = String.lowercased()();
  v149 = String.lowercased()();
  v92 = type metadata accessor for Locale();
  v93 = (uint64_t)v124;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v92 - 8) + 56))(v124, 1, 1, v92);
  lazy protocol witness table accessor for type String and conformance String();
  StringProtocol.range<A>(of:options:range:locale:)();
  v95 = v94;
  outlined destroy of (key: String, value: StorableValue)(v93, &demangling cache variable for type metadata for Locale?);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  v35 = v121;
  if ((v95 & 1) != 0)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    v111 = *(uint64_t *)((char *)v33 + v120);
    v113 = *(_QWORD *)(v111 + 16);
    v112 = *(_QWORD *)(v111 + 24);
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v114 = v113;
    *(_QWORD *)(v114 + 8) = v112;
    *(_QWORD *)(v114 + 16) = 0;
    *(_QWORD *)(v114 + 24) = 0;
    *(_BYTE *)(v114 + 32) = 8;
    swift_bridgeObjectRetain();
    swift_willThrow();
    outlined destroy of PgQuery_Alias(v35, type metadata accessor for PgQuery_Node);
    v91 = v136;
    goto LABEL_52;
  }
  v96 = String.subscript.getter();
  v98 = v97;
  v100 = v99;
  v102 = v101;
  swift_bridgeObjectRelease();
  v103 = MEMORY[0x193FEC5A0](v96, v98, v100, v102);
  v105 = v104;
  swift_bridgeObjectRelease();
  v106 = v130;
  v130[12] = v103;
  v106[13] = v105;
  v37 = *(uint64_t *)((char *)v33 + v120);
  a3 = v136;
  a1 = 0;
  v18 = v106;
  ResTarget = (uint64_t)v128;
  v65 = v131;
LABEL_31:
  outlined init with copy of PgQuery_Alias?(v37 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, v65, &demangling cache variable for type metadata for PgQuery_Node?);
  v66 = v139;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v127 + 48))(v65, 1, v139) == 1)
  {
    v36 = v129;
    UnknownStorage.init()();
    v30 = *(int *)(v66 + 20);
    if (one-time initialization token for defaultInstance == -1)
    {
LABEL_33:
      *(_QWORD *)(v36 + v30) = static PgQuery_Node._StorageClass.defaultInstance;
      swift_retain();
      outlined destroy of (key: String, value: StorableValue)(v131, &demangling cache variable for type metadata for PgQuery_Node?);
      goto LABEL_35;
    }
LABEL_74:
    swift_once();
    goto LABEL_33;
  }
  v67 = v65;
  v36 = v129;
  outlined init with take of PgQuery_OidList(v67, v129, type metadata accessor for PgQuery_Node);
LABEL_35:
  v68 = v142;
  outlined init with copy of PgQuery_RawStmt(a3, ResTarget, type metadata accessor for SQLTokenInformation);
  SQLExpression.init(expressionNode:schemas:tokenInformation:)(v36, v68, ResTarget, (uint64_t)&v148);
  if (a1)
  {
    outlined destroy of PgQuery_Alias(v35, type metadata accessor for PgQuery_Node);
    outlined destroy of PgQuery_Alias(a3, type metadata accessor for SQLTokenInformation);
    outlined destroy of PgQuery_Alias((uint64_t)v33, type metadata accessor for PgQuery_ResTarget);
    return swift_bridgeObjectRelease();
  }
  else
  {
    outlined init with copy of SQLExpression((uint64_t)&v148, (uint64_t)v18);
    v136 = a3;
    v74 = *(_QWORD *)(a3 + 8);
    v75 = *(_QWORD *)(v74 + 16);
    if (v75)
    {
      v147 = 0;
      v121 = v35;
      v119 = v33;
      v76 = *(_DWORD *)(*(uint64_t *)((char *)v33 + v120)
                      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
      v146 = (*(unsigned __int8 *)(v132 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v132 + 80);
      v77 = v74 + v146;
      v139 = *(_QWORD *)(v132 + 72);
      swift_bridgeObjectRetain();
      v78 = 0;
      v79 = (unsigned int *)v133;
      while (1)
      {
        outlined init with copy of PgQuery_RawStmt(v77, (uint64_t)v79, type metadata accessor for PgQuery_ScanToken);
        v35 = *v79;
        outlined destroy of PgQuery_Alias((uint64_t)v79, type metadata accessor for PgQuery_ScanToken);
        if ((_DWORD)v35 == v76)
          break;
        ++v78;
        v77 += v139;
        if (v75 == v78)
        {
          swift_bridgeObjectRelease();
          v80 = 0;
          v81 = 0;
          a3 = v136;
          v35 = v121;
          v33 = v119;
          v18 = v130;
          goto LABEL_68;
        }
      }
      swift_bridgeObjectRelease();
      v150 = MEMORY[0x1E0DEE9D8];
      a3 = v136;
      v107 = *(_QWORD *)(v136 + 8);
      if (*(_QWORD *)(v107 + 16) < v78)
      {
LABEL_76:
        __break(1u);
      }
      else
      {
        v35 = v121;
        v108 = v139;
        if (v78)
        {
          v109 = v107 + v146;
          v137 = *(char **)(v136 + 8);
          swift_bridgeObjectRetain();
          do
          {
            outlined init with copy of PgQuery_RawStmt(v109 + --v78 * v108, (uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
            if (v10[16] == 1)
            {
              v110 = *((_QWORD *)v10 + 1);
              if ((unint64_t)(v110 - 39) >= 0x152)
                __asm { BR              X8 }
            }
            outlined destroy of PgQuery_Alias((uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
          }
          while (v78);
          swift_bridgeObjectRelease();
        }
      }
      v33 = v119;
      v18 = v130;
      if (*(_QWORD *)(v150 + 16))
      {
        v149._countAndFlagsBits = v150;
        __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
        lazy protocol witness table accessor for type [String] and conformance [A]();
        v80 = BidirectionalCollection<>.joined(separator:)();
        v81 = v115;
        swift_bridgeObjectRelease();
      }
      else
      {
        swift_bridgeObjectRelease();
        v80 = 0;
        v81 = 0;
      }
    }
    else
    {
      v80 = 0;
      v81 = 0;
      a3 = v136;
    }
LABEL_68:
    outlined destroy of PgQuery_Alias(v35, type metadata accessor for PgQuery_Node);
    outlined destroy of SQLExpression((uint64_t)&v148);
    outlined destroy of PgQuery_Alias(a3, type metadata accessor for SQLTokenInformation);
    result = outlined destroy of PgQuery_Alias((uint64_t)v33, type metadata accessor for PgQuery_ResTarget);
    v18[14] = v80;
    v18[15] = v81;
  }
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance ResultColumn.CodingKeys()
{
  _BYTE *v0;
  uint64_t v1;

  v1 = 0x7361696C61;
  if (*v0 != 1)
    v1 = 0x746E656D75636F64;
  if (*v0)
    return v1;
  else
    return 0x6973736572707865;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance ResultColumn.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized ResultColumn.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance ResultColumn.CodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 3;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance ResultColumn.CodingKeys()
{
  lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance ResultColumn.CodingKeys()
{
  lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t ResultColumn.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  _BYTE v8[16];

  v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<ResultColumn.CodingKeys>);
  v4 = *(_QWORD *)(v3 - 8);
  MEMORY[0x1E0C80A78](v3);
  v6 = &v8[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v8[15] = 0;
  lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v1)
  {
    v8[14] = 1;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[13] = 2;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
  }
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance ResultColumn(_QWORD *a1)
{
  return ResultColumn.encode(to:)(a1);
}

uint64_t SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Node;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t result;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  const void *v36;
  const void *v37;
  uint64_t NodeVG_AF12ResultColumnVsAE_pTg5;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  char isUniquelyReferenced_nonNull_native;
  char v46;
  unint64_t v47;
  uint64_t v48;
  _BOOL8 v49;
  char v50;
  unint64_t v51;
  unint64_t v52;
  char v53;
  uint64_t *v54;
  uint64_t v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  unint64_t v60;
  int64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  int64_t v71;
  unint64_t v72;
  int64_t v73;
  char *v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  uint64_t (*v81)(uint64_t, uint64_t, unint64_t);
  int v82;
  uint64_t v83;
  uint64_t v84;
  __int128 *v85;
  uint64_t v86;
  _QWORD *v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  uint64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  Swift::String v97;
  uint64_t v98;
  int v99;
  int v100;
  char *object;
  uint64_t v102;
  uint64_t v103;
  uint64_t NodeVG_AF13SQLExpressionVsAE_pTg5;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  Swift::String v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  _BOOL8 v118;
  unint64_t v119;
  char v120;
  _QWORD *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  char *v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  uint64_t v136;
  _QWORD *v137;
  uint64_t v138;
  unint64_t v139;
  uint64_t v140;
  _QWORD *v141;
  int v142;
  char *v143;
  unint64_t v144;
  unint64_t v145;
  char *v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  uint64_t v157;
  uint64_t v158;
  char *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  char *v168;
  Swift::String v169;
  unint64_t v170;
  uint64_t v171;
  unint64_t v172;
  uint64_t v173;
  unint64_t v174;
  uint64_t v175;
  uint64_t *v176;
  uint64_t v177;
  uint64_t v178;
  Swift::String v179;
  Swift::Int v180;
  uint64_t v181;
  unint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  BOOL v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  BOOL v190;
  unint64_t i;
  unint64_t v192;
  uint64_t v193;
  BOOL v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  int64_t v200;
  uint64_t v201;
  uint64_t v202;
  _QWORD *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t j;
  uint64_t v208;
  uint64_t v209;
  _QWORD *v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  const void *v214;
  int64_t v215;
  uint64_t v216;
  _QWORD *v217;
  uint64_t v218;
  _BYTE *v219;
  char *v220;
  char *v221;
  char *v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  _QWORD *v226;
  char *v227;
  uint64_t v228;
  uint64_t v229;
  char *v230;
  uint64_t v231;
  unint64_t v232;
  char *v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  _OWORD v237[4];
  __int128 v238;
  __int128 v239;
  _BYTE v240[104];
  uint64_t v241;
  _OWORD v242[4];
  __int128 v243;
  __int128 v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  __int128 v250;
  unint64_t v251;
  unint64_t v252;
  const void *v253;

  v253 = (const void *)a2;
  v234 = a3;
  v4 = type metadata accessor for SQLTokenInformation(0);
  v5 = MEMORY[0x1E0C80A78](v4);
  v227 = (char *)&v214 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v5);
  v230 = (char *)&v214 - v7;
  Node = type metadata accessor for PgQuery_Node(0);
  v231 = *(_QWORD *)(Node - 8);
  v232 = Node;
  v9 = MEMORY[0x1E0C80A78](Node);
  v226 = (const void **)((char *)&v214 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v9);
  v229 = (uint64_t)&v214 - v11;
  v12 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  v13 = MEMORY[0x1E0C80A78](v12);
  v228 = (uint64_t)&v214 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v233 = (char *)&v214 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v214 - v18;
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v214 - v20;
  v22 = type metadata accessor for PlanResources(0);
  MEMORY[0x1E0C80A78](v22);
  v24 = (uint64_t *)((char *)&v214 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0));
  v25 = (char *)*(int *)(type metadata accessor for PgQuery_SelectStmt(0) + 20);
  v26 = *(_QWORD *)&v25[a1];
  outlined init with copy of PgQuery_RawStmt((uint64_t)v253, (uint64_t)v24, type metadata accessor for PlanResources);
  v27 = swift_bridgeObjectRetain();
  v28 = v235;
  v29 = FromClause.init(fromClauseNodes:resources:)(v27, v24, (uint64_t *)&v245);
  if (v28)
  {
    outlined destroy of PgQuery_Alias(a1, type metadata accessor for PgQuery_SelectStmt);
    return outlined destroy of PgQuery_Alias((uint64_t)v253, type metadata accessor for PlanResources);
  }
  v219 = v19;
  v220 = v21;
  v222 = v25;
  v218 = v22;
  v225 = a1;
  v31 = v250;
  v32 = v234;
  *(_OWORD *)(v234 + 64) = v249;
  *(_OWORD *)(v32 + 80) = v31;
  *(_QWORD *)(v32 + 96) = v251;
  v33 = v246;
  *(_OWORD *)v32 = v245;
  *(_OWORD *)(v32 + 16) = v33;
  v34 = v248;
  *(_OWORD *)(v32 + 32) = v247;
  *(_OWORD *)(v32 + 48) = v34;
  v35 = *(_QWORD *)(v26
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList);
  v36 = *(const void **)v32;
  MEMORY[0x1E0C80A78](v29);
  v37 = v253;
  *(&v214 - 2) = v36;
  *(&v214 - 1) = v37;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  NodeVG_AF12ResultColumnVsAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF12ResultColumnVsAE_pTg5((void (*)(_OWORD *__return_ptr, uint64_t, uint64_t *))partial apply for closure #1 in SelectCore.init(select:resources:), (uint64_t)(&v214 - 4), v35);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  *(_QWORD *)(v32 + 304) = NodeVG_AF12ResultColumnVsAE_pTg5;
  v39 = *(_QWORD *)(NodeVG_AF12ResultColumnVsAE_pTg5 + 16);
  v221 = 0;
  v217 = 0;
  if (!v39)
  {
    swift_bridgeObjectRetain();
    v42 = MEMORY[0x1E0DEE9E0];
    goto LABEL_58;
  }
  v40 = NodeVG_AF12ResultColumnVsAE_pTg5 + 32;
  v216 = NodeVG_AF12ResultColumnVsAE_pTg5;
  swift_bridgeObjectRetain_n();
  v41 = 0;
  v42 = MEMORY[0x1E0DEE9E0];
  v223 = v40;
  v224 = v39;
  while (2)
  {
    outlined init with copy of ResultColumn(v40 + (v41 << 7), (uint64_t)&v245);
    v43 = v252;
    if (!v252 || *(_QWORD *)(v249 + 16))
      goto LABEL_11;
    v44 = v251;
    LODWORD(v235) = BYTE8(v248);
    swift_bridgeObjectRetain();
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    *(_QWORD *)&v237[0] = v42;
    v47 = specialized __RawDictionaryStorage.find<A>(_:)();
    v48 = *(_QWORD *)(v42 + 16);
    v49 = (v46 & 1) == 0;
    if (__OFADD__(v48, v49))
    {
      __break(1u);
      break;
    }
    v50 = v46;
    if (*(_QWORD *)(v42 + 24) < v48 + v49)
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)();
      v51 = *(_QWORD *)&v237[0];
      v52 = specialized __RawDictionaryStorage.find<A>(_:)();
      if ((v50 & 1) != (v53 & 1))
        goto LABEL_270;
      v47 = v52;
      if ((v50 & 1) != 0)
        goto LABEL_9;
      goto LABEL_21;
    }
    if ((isUniquelyReferenced_nonNull_native & 1) != 0)
    {
      v51 = v42;
      if ((v46 & 1) != 0)
        goto LABEL_9;
      goto LABEL_21;
    }
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
    v58 = static _DictionaryStorage.copy(original:)();
    v51 = v58;
    if (!*(_QWORD *)(v42 + 16))
      goto LABEL_54;
    v59 = (void *)(v58 + 64);
    v60 = (unint64_t)((1 << *(_BYTE *)(v51 + 32)) + 63) >> 6;
    v214 = (const void *)(v42 + 64);
    if (v51 != v42 || (unint64_t)v59 >= v42 + 64 + 8 * v60)
      memmove(v59, v214, 8 * v60);
    v61 = 0;
    *(_QWORD *)(v51 + 16) = *(_QWORD *)(v42 + 16);
    v62 = 1 << *(_BYTE *)(v42 + 32);
    if (v62 < 64)
      v63 = ~(-1 << v62);
    else
      v63 = -1;
    v64 = v63 & *(_QWORD *)(v42 + 64);
    v215 = (unint64_t)(v62 + 63) >> 6;
    while (1)
    {
      if (v64)
      {
        v65 = __clz(__rbit64(v64));
        v64 &= v64 - 1;
        v66 = v65 | (v61 << 6);
        goto LABEL_32;
      }
      v71 = v61 + 1;
      if (__OFADD__(v61, 1))
        goto LABEL_264;
      if (v71 >= v215)
        goto LABEL_54;
      v72 = *((_QWORD *)v214 + v71);
      ++v61;
      if (!v72)
      {
        v61 = v71 + 1;
        if (v71 + 1 >= v215)
          goto LABEL_54;
        v72 = *((_QWORD *)v214 + v61);
        if (!v72)
        {
          v61 = v71 + 2;
          if (v71 + 2 >= v215)
            goto LABEL_54;
          v72 = *((_QWORD *)v214 + v61);
          if (!v72)
          {
            v61 = v71 + 3;
            if (v71 + 3 >= v215)
              goto LABEL_54;
            v72 = *((_QWORD *)v214 + v61);
            if (!v72)
            {
              v61 = v71 + 4;
              if (v71 + 4 >= v215)
                goto LABEL_54;
              v72 = *((_QWORD *)v214 + v61);
              if (!v72)
              {
                v61 = v71 + 5;
                if (v71 + 5 >= v215)
                  goto LABEL_54;
                v72 = *((_QWORD *)v214 + v61);
                if (!v72)
                  break;
              }
            }
          }
        }
      }
LABEL_53:
      v64 = (v72 - 1) & v72;
      v66 = __clz(__rbit64(v72)) + (v61 << 6);
LABEL_32:
      v67 = (uint64_t *)(*(_QWORD *)(v42 + 48) + 16 * v66);
      v69 = *v67;
      v68 = v67[1];
      LOBYTE(v67) = *(_BYTE *)(*(_QWORD *)(v42 + 56) + v66);
      v70 = (_QWORD *)(*(_QWORD *)(v51 + 48) + 16 * v66);
      *v70 = v69;
      v70[1] = v68;
      *(_BYTE *)(*(_QWORD *)(v51 + 56) + v66) = (_BYTE)v67;
      swift_bridgeObjectRetain();
    }
    v73 = v71 + 6;
    if (v73 >= v215)
      goto LABEL_54;
    v72 = *((_QWORD *)v214 + v73);
    if (v72)
    {
      v61 = v73;
      goto LABEL_53;
    }
    while (1)
    {
      v61 = v73 + 1;
      if (__OFADD__(v73, 1))
        goto LABEL_268;
      if (v61 >= v215)
        break;
      v72 = *((_QWORD *)v214 + v61);
      ++v73;
      if (v72)
        goto LABEL_53;
    }
LABEL_54:
    swift_bridgeObjectRelease();
    if ((v50 & 1) != 0)
    {
LABEL_9:
      *(_BYTE *)(*(_QWORD *)(v51 + 56) + v47) = v235;
      goto LABEL_10;
    }
LABEL_21:
    *(_QWORD *)(v51 + 8 * (v47 >> 6) + 64) |= 1 << v47;
    v54 = (uint64_t *)(*(_QWORD *)(v51 + 48) + 16 * v47);
    *v54 = v44;
    v54[1] = v43;
    *(_BYTE *)(*(_QWORD *)(v51 + 56) + v47) = v235;
    v55 = *(_QWORD *)(v51 + 16);
    v56 = __OFADD__(v55, 1);
    v57 = v55 + 1;
    if (!v56)
    {
      *(_QWORD *)(v51 + 16) = v57;
      swift_bridgeObjectRetain();
LABEL_10:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      v42 = v51;
      v40 = v223;
      v39 = v224;
LABEL_11:
      ++v41;
      outlined destroy of ResultColumn((uint64_t)&v245);
      if (v41 != v39)
        continue;
      swift_bridgeObjectRelease();
LABEL_58:
      swift_bridgeObjectRelease();
      v44 = *(_QWORD *)v234;
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      v74 = (char *)v44;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
        goto LABEL_59;
      goto LABEL_181;
    }
    break;
  }
  __break(1u);
  while (2)
  {
    __break(1u);
LABEL_181:
    v74 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v44 + 16) + 1, 1, (char *)v44);
LABEL_59:
    v76 = *((_QWORD *)v74 + 2);
    v75 = *((_QWORD *)v74 + 3);
    if (v76 >= v75 >> 1)
      v74 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v75 > 1), v76 + 1, 1, v74);
    *((_QWORD *)v74 + 2) = v76 + 1;
    v77 = &v74[24 * v76];
    strcpy(v77 + 32, "select_alias");
    v77[45] = 0;
    *((_WORD *)v77 + 23) = -5120;
    *((_QWORD *)v77 + 6) = v42;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    v78 = v225;
    v79 = v222;
    v80 = (uint64_t)v220;
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v222[v225]+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, (uint64_t)v220, &demangling cache variable for type metadata for PgQuery_Node?);
    v42 = v232;
    v81 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v231 + 48);
    v82 = v81(v80, 1, v232);
    outlined destroy of (key: String, value: StorableValue)(v80, &demangling cache variable for type metadata for PgQuery_Node?);
    v224 = (uint64_t)v81;
    if (v82 == 1)
    {
      v83 = v234;
      *(_OWORD *)(v234 + 184) = 0u;
      *(_OWORD *)(v83 + 168) = 0u;
      *(_OWORD *)(v83 + 152) = 0u;
      *(_OWORD *)(v83 + 136) = 0u;
      *(_OWORD *)(v83 + 120) = 0u;
      *(_OWORD *)(v83 + 104) = 0u;
      v84 = v78;
      v85 = &v245;
      v86 = (uint64_t)v253;
      v87 = v217;
      goto LABEL_70;
    }
    v88 = (uint64_t)v219;
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v79[v78]+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, (uint64_t)v219, &demangling cache variable for type metadata for PgQuery_Node?);
    v89 = v81(v88, 1, v42);
    v83 = v234;
    v85 = &v245;
    if (v89 != 1)
    {
      v86 = v229;
      outlined init with take of PgQuery_OidList(v88, v229, type metadata accessor for PgQuery_Node);
      v91 = v221;
      v87 = v217;
      v92 = v218;
      v42 = (unint64_t)v253;
      goto LABEL_67;
    }
    v86 = v229;
    UnknownStorage.init()();
    v90 = *(int *)(v42 + 20);
    v91 = v221;
    v42 = (unint64_t)v253;
    v87 = v217;
    if (one-time initialization token for defaultInstance != -1)
      goto LABEL_255;
    while (2)
    {
      *(_QWORD *)(v86 + v90) = static PgQuery_Node._StorageClass.defaultInstance;
      swift_retain();
      outlined destroy of (key: String, value: StorableValue)((uint64_t)v219, &demangling cache variable for type metadata for PgQuery_Node?);
      v92 = v218;
LABEL_67:
      v93 = (uint64_t)v230;
      outlined init with copy of PgQuery_RawStmt(v42 + *(int *)(v92 + 20), (uint64_t)v230, type metadata accessor for SQLTokenInformation);
      swift_bridgeObjectRetain();
      SQLExpression.init(expressionNode:schemas:tokenInformation:)(v86, (uint64_t)v74, v93, (uint64_t)&v245);
      v84 = v225;
      if (v87)
      {
        outlined destroy of PgQuery_Alias(v225, type metadata accessor for PgQuery_SelectStmt);
        swift_bridgeObjectRelease();
        outlined destroy of PgQuery_Alias(v42, type metadata accessor for PlanResources);
        result = outlined destroy of FromClause(v83);
        goto LABEL_4;
      }
      outlined init with take of (key: String, value: StorableValue)((uint64_t)&v245, v83 + 104, &demangling cache variable for type metadata for SQLExpression?);
      v86 = v42;
LABEL_70:
      v229 = v83 + 104;
      outlined init with copy of PgQuery_Alias?(v83 + 104, (uint64_t)&v245, &demangling cache variable for type metadata for SQLExpression?);
      v91 = v222;
      if (*((_QWORD *)&v246 + 1))
      {
        v94 = v85[3];
        v237[2] = v85[2];
        v237[3] = v94;
        v95 = v85[5];
        v238 = v85[4];
        v239 = v95;
        v96 = v85[1];
        v237[0] = *v85;
        v237[1] = v96;
        v90 = v238;
        if (*(_QWORD *)(v238 + 16))
        {
          swift_bridgeObjectRelease();
          if (*(_QWORD *)(v90 + 16))
          {
            outlined init with copy of AggregationFunction(v90 + 32, (uint64_t)&v245);
            v97 = AggregationFunction.name()();
            outlined destroy of AggregationFunction((uint64_t)&v245);
            lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
            swift_allocError();
            *(Swift::String *)v98 = v97;
            *(_QWORD *)(v98 + 16) = 0;
            *(_QWORD *)(v98 + 24) = 0;
            *(_BYTE *)(v98 + 32) = 5;
            swift_willThrow();
            outlined destroy of PgQuery_Alias(v225, type metadata accessor for PgQuery_SelectStmt);
            outlined destroy of SQLExpression((uint64_t)v237);
            outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
            v99 = 0;
            v100 = 0;
            v91 = v221;
            goto LABEL_79;
          }
LABEL_254:
          __break(1u);
LABEL_255:
          swift_once();
          continue;
        }
        object = (char *)v83;
        v102 = outlined destroy of SQLExpression((uint64_t)v237);
        v84 = v225;
      }
      else
      {
        object = (char *)v83;
        v102 = outlined destroy of (key: String, value: StorableValue)((uint64_t)&v245, &demangling cache variable for type metadata for SQLExpression?);
      }
      break;
    }
    v103 = *(_QWORD *)(*(_QWORD *)&v91[v84]
                     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupClause);
    MEMORY[0x1E0C80A78](v102);
    *(&v214 - 2) = v74;
    *(&v214 - 1) = (const void *)v86;
    swift_bridgeObjectRetain();
    NodeVG_AF13SQLExpressionVsAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF13SQLExpressionVsAE_pTg5((void (*)(_OWORD *__return_ptr, uint64_t, uint64_t *))partial apply for closure #3 in SelectCore.init(select:resources:), (uint64_t)(&v214 - 4), v103);
    if (v87)
    {
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v84, type metadata accessor for PgQuery_SelectStmt);
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
      v99 = 0;
      v100 = 0;
      v91 = v221;
      goto LABEL_78;
    }
    v105 = NodeVG_AF13SQLExpressionVsAE_pTg5;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    v106 = *(_QWORD *)(v105 + 16);
    if (v106)
    {
      v107 = 96;
      v91 = v221;
      v83 = (uint64_t)object;
      v85 = (__int128 *)v233;
      while (1)
      {
        v108 = *(_QWORD *)(v105 + v107);
        if (*(_QWORD *)(v108 + 16))
          break;
        v107 += 96;
        if (!--v106)
          goto LABEL_99;
      }
      swift_bridgeObjectRelease();
      if (!*(_QWORD *)(v108 + 16))
      {
        __break(1u);
        JUMPOUT(0x18DB355FCLL);
      }
      outlined init with copy of AggregationFunction(v108 + 32, (uint64_t)&v245);
      v113 = AggregationFunction.name()();
      outlined destroy of AggregationFunction((uint64_t)&v245);
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(Swift::String *)v114 = v113;
      *(_QWORD *)(v114 + 16) = 0;
      *(_QWORD *)(v114 + 24) = 0;
      *(_BYTE *)(v114 + 32) = 6;
      swift_willThrow();
      outlined destroy of PgQuery_Alias(v225, type metadata accessor for PgQuery_SelectStmt);
      outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
      v99 = 0;
      v100 = 0;
LABEL_79:
      outlined destroy of FromClause(v83);
      result = outlined destroy of (key: String, value: StorableValue)(v229, &demangling cache variable for type metadata for SQLExpression?);
      if (v99)
      {
        result = swift_bridgeObjectRelease();
        if ((v100 & 1) != 0)
LABEL_83:
          result = outlined destroy of (key: String, value: StorableValue)(v83 + 208, &demangling cache variable for type metadata for SQLExpression?);
      }
      else if (v100)
      {
        goto LABEL_83;
      }
LABEL_4:
      if (!v91)
        return swift_bridgeObjectRelease();
      return result;
    }
    swift_bridgeObjectRelease();
    v109 = *((_QWORD *)object + 38);
    v110 = *(_QWORD *)(v109 + 16);
    v91 = v221;
    if (v110)
    {
      v111 = v109 + 32;
      swift_bridgeObjectRetain();
      while (1)
      {
        outlined init with copy of ResultColumn(v111, (uint64_t)&v245);
        v112 = *(_QWORD *)(v249 + 16);
        outlined destroy of ResultColumn((uint64_t)&v245);
        if (v112)
          break;
        v111 += 128;
        if (!--v110)
        {
          swift_bridgeObjectRelease();
          v105 = 0;
          goto LABEL_98;
        }
      }
      swift_bridgeObjectRelease();
      v105 = MEMORY[0x1E0DEE9D8];
    }
    else
    {
      v105 = 0;
    }
LABEL_98:
    v83 = (uint64_t)object;
    v85 = (__int128 *)v233;
LABEL_99:
    v217 = 0;
    *(_QWORD *)(v83 + 200) = v105;
    object = (char *)v83;
    v115 = *(_QWORD *)(v83 + 304);
    v231 = *(_QWORD *)(v115 + 16);
    if (!v231)
    {
      swift_bridgeObjectRetain();
      v90 = MEMORY[0x1E0DEE9E0];
      goto LABEL_149;
    }
    v230 = (char *)(v115 + 32);
    v223 = v115;
    swift_bridgeObjectRetain_n();
    v83 = 0;
    v90 = MEMORY[0x1E0DEE9E0];
LABEL_104:
    outlined init with copy of ResultColumn((uint64_t)&v230[128 * v83], (uint64_t)&v245);
    v87 = (_QWORD *)v252;
    if (!v252)
      goto LABEL_103;
    v91 = (char *)v251;
    LODWORD(v235) = BYTE8(v248);
    swift_bridgeObjectRetain();
    v44 = swift_isUniquelyReferenced_nonNull_native();
    *(_QWORD *)&v237[0] = v90;
    v42 = specialized __RawDictionaryStorage.find<A>(_:)();
    v117 = *(_QWORD *)(v90 + 16);
    v118 = (v116 & 1) == 0;
    if (__OFADD__(v117, v118))
      continue;
    break;
  }
  v86 = v116;
  if (*(_QWORD *)(v90 + 24) < v117 + v118)
  {
    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)();
    v74 = *(char **)&v237[0];
    v119 = specialized __RawDictionaryStorage.find<A>(_:)();
    if ((v86 & 1) != (v120 & 1))
      goto LABEL_270;
    v42 = v119;
    v85 = (__int128 *)v233;
    if ((v86 & 1) != 0)
      goto LABEL_101;
    goto LABEL_112;
  }
  if ((v44 & 1) != 0)
  {
    v74 = (char *)v90;
    v85 = (__int128 *)v233;
    if ((v116 & 1) != 0)
      goto LABEL_101;
    goto LABEL_112;
  }
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
  v124 = static _DictionaryStorage.copy(original:)();
  v74 = (char *)v124;
  if (!*(_QWORD *)(v90 + 16))
    goto LABEL_145;
  v125 = (char *)(v124 + 64);
  v126 = 1 << v74[32];
  v220 = (char *)(v90 + 64);
  v127 = (unint64_t)(v126 + 63) >> 6;
  if (v74 != (char *)v90 || v125 >= &v220[8 * v127])
    memmove(v125, v220, 8 * v127);
  v128 = 0;
  *((_QWORD *)v74 + 2) = *(_QWORD *)(v90 + 16);
  v129 = 1 << *(_BYTE *)(v90 + 32);
  if (v129 < 64)
    v130 = ~(-1 << v129);
  else
    v130 = -1;
  v131 = v130 & *(_QWORD *)(v90 + 64);
  v219 = (_BYTE *)((unint64_t)(v129 + 63) >> 6);
  while (2)
  {
    if (v131)
    {
      v132 = __clz(__rbit64(v131));
      v131 &= v131 - 1;
      v133 = v132 | (v128 << 6);
LABEL_123:
      v134 = (uint64_t *)(*(_QWORD *)(v90 + 48) + 16 * v133);
      v136 = *v134;
      v135 = v134[1];
      LOBYTE(v134) = *(_BYTE *)(*(_QWORD *)(v90 + 56) + v133);
      v137 = (_QWORD *)(*((_QWORD *)v74 + 6) + 16 * v133);
      *v137 = v136;
      v137[1] = v135;
      *(_BYTE *)(*((_QWORD *)v74 + 7) + v133) = (_BYTE)v134;
      swift_bridgeObjectRetain();
      continue;
    }
    break;
  }
  v138 = v128 + 1;
  if (__OFADD__(v128, 1))
    goto LABEL_265;
  if (v138 >= (uint64_t)v219)
    goto LABEL_145;
  v139 = *(_QWORD *)&v220[8 * v138];
  ++v128;
  if (v139)
    goto LABEL_144;
  v128 = v138 + 1;
  if (v138 + 1 >= (uint64_t)v219)
    goto LABEL_145;
  v139 = *(_QWORD *)&v220[8 * v128];
  if (v139)
    goto LABEL_144;
  v128 = v138 + 2;
  if (v138 + 2 >= (uint64_t)v219)
    goto LABEL_145;
  v139 = *(_QWORD *)&v220[8 * v128];
  if (v139)
    goto LABEL_144;
  v128 = v138 + 3;
  if (v138 + 3 >= (uint64_t)v219)
    goto LABEL_145;
  v139 = *(_QWORD *)&v220[8 * v128];
  if (v139)
    goto LABEL_144;
  v128 = v138 + 4;
  if (v138 + 4 >= (uint64_t)v219)
    goto LABEL_145;
  v139 = *(_QWORD *)&v220[8 * v128];
  if (v139)
    goto LABEL_144;
  v128 = v138 + 5;
  if (v138 + 5 >= (uint64_t)v219)
    goto LABEL_145;
  v139 = *(_QWORD *)&v220[8 * v128];
  if (v139)
  {
LABEL_144:
    v131 = (v139 - 1) & v139;
    v133 = __clz(__rbit64(v139)) + (v128 << 6);
    goto LABEL_123;
  }
  v140 = v138 + 6;
  if (v140 >= (uint64_t)v219)
    goto LABEL_145;
  v139 = *(_QWORD *)&v220[8 * v140];
  if (v139)
  {
    v128 = v140;
    goto LABEL_144;
  }
  while (1)
  {
    v128 = v140 + 1;
    if (__OFADD__(v140, 1))
      goto LABEL_269;
    if (v128 >= (uint64_t)v219)
      break;
    v139 = *(_QWORD *)&v220[8 * v128];
    ++v140;
    if (v139)
      goto LABEL_144;
  }
LABEL_145:
  swift_bridgeObjectRelease();
  v85 = (__int128 *)v233;
  if ((v86 & 1) != 0)
  {
LABEL_101:
    *(_BYTE *)(*((_QWORD *)v74 + 7) + v42) = v235;
    goto LABEL_102;
  }
LABEL_112:
  *(_QWORD *)&v74[8 * (v42 >> 6) + 64] |= 1 << v42;
  v121 = (_QWORD *)(*((_QWORD *)v74 + 6) + 16 * v42);
  *v121 = v91;
  v121[1] = v87;
  *(_BYTE *)(*((_QWORD *)v74 + 7) + v42) = v235;
  v122 = *((_QWORD *)v74 + 2);
  v56 = __OFADD__(v122, 1);
  v123 = v122 + 1;
  if (v56)
  {
    __break(1u);
    goto LABEL_254;
  }
  *((_QWORD *)v74 + 2) = v123;
  swift_bridgeObjectRetain();
LABEL_102:
  object = (char *)v234;
  v86 = (uint64_t)v253;
  v91 = v221;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  v90 = (uint64_t)v74;
LABEL_103:
  ++v83;
  outlined destroy of ResultColumn((uint64_t)&v245);
  if (v83 != v231)
    goto LABEL_104;
  swift_bridgeObjectRelease();
LABEL_149:
  swift_bridgeObjectRelease();
  v141 = &unk_1EE082000;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v222[v225]+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__havingClause, (uint64_t)v85, &demangling cache variable for type metadata for PgQuery_Node?);
  v142 = ((uint64_t (*)(__int128 *, uint64_t, unint64_t))v224)(v85, 1, v232);
  outlined destroy of (key: String, value: StorableValue)((uint64_t)v85, &demangling cache variable for type metadata for PgQuery_Node?);
  if (v142 != 1)
  {
    v83 = *(_QWORD *)object;
    swift_bridgeObjectRetain_n();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    v143 = (char *)v83;
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) != 0)
      goto LABEL_152;
    goto LABEL_257;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  v83 = (uint64_t)object;
  *((_OWORD *)object + 17) = 0u;
  *((_OWORD *)object + 18) = 0u;
  *((_OWORD *)object + 15) = 0u;
  *((_OWORD *)object + 16) = 0u;
  *((_OWORD *)object + 13) = 0u;
  *((_OWORD *)object + 14) = 0u;
  v141 = v217;
  v90 = v225;
  while (2)
  {
    outlined init with copy of PgQuery_Alias?(v83 + 208, (uint64_t)&v245, &demangling cache variable for type metadata for SQLExpression?);
    if (*((_QWORD *)&v246 + 1))
    {
      v242[2] = v247;
      v242[3] = v248;
      v243 = v249;
      v244 = v250;
      v242[0] = v245;
      v242[1] = v246;
      if (!*(_QWORD *)(v83 + 200))
      {
        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
        swift_allocError();
        *(_OWORD *)v157 = 0u;
        *(_OWORD *)(v157 + 16) = 0u;
        *(_BYTE *)(v157 + 32) = 9;
        swift_willThrow();
        outlined destroy of PgQuery_Alias(v90, type metadata accessor for PgQuery_SelectStmt);
        outlined destroy of SQLExpression((uint64_t)v242);
        outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
LABEL_173:
        v99 = 1;
        v100 = 1;
        goto LABEL_79;
      }
      v150 = *(_QWORD *)(v83 + 304);
      v151 = MEMORY[0x1E0DEE9E8];
      v236 = MEMORY[0x1E0DEE9E8];
      v152 = specialized Array.count.getter(v150);
      if (v152)
      {
        v153 = v152;
        v217 = v141;
        if (v152 < 1)
          goto LABEL_263;
        v154 = v150 + 32;
        swift_bridgeObjectRetain_n();
        do
        {
          outlined init with copy of ResultColumn(v154, (uint64_t)&v245);
          v155 = v252;
          if (v252)
          {
            v156 = v251;
            if (specialized Array.count.getter(v249))
            {
              swift_bridgeObjectRetain();
              specialized Set._Variant.insert(_:)((unint64_t *)v237, v156, v155);
              swift_bridgeObjectRelease();
            }
          }
          outlined destroy of ResultColumn((uint64_t)&v245);
          v154 += 128;
          --v153;
        }
        while (v153);
        swift_bridgeObjectRelease_n();
        v149 = v236;
        v91 = v221;
        v141 = v217;
        v83 = (uint64_t)object;
      }
      else
      {
        v149 = v151;
      }
      object = (char *)v243;
      v158 = specialized Array.count.getter(v243);
      v90 = v225;
      v223 = v158;
      if (v158)
      {
        v143 = object + 32;
        v219 = v240;
        v235 = v149 + 56;
        swift_bridgeObjectRetain();
        v232 = v149;
        v230 = object;
        v220 = object + 32;
        if (*((_QWORD *)object + 2))
        {
          v224 = 1;
          outlined init with copy of AggregationFunction((uint64_t)(object + 32), (uint64_t)&v245);
          v241 = specialized static Array._allocateUninitialized(_:)(0);
          outlined init with copy of AggregationFunction.AggregationType((uint64_t)&v245, (uint64_t)v237);
          __asm { BR              X9 }
        }
        __break(1u);
LABEL_260:
        __break(1u);
LABEL_261:
        swift_once();
LABEL_156:
        *(_QWORD *)((char *)v141 + v90) = static PgQuery_Node._StorageClass.defaultInstance;
        swift_retain();
        outlined destroy of (key: String, value: StorableValue)(v228, &demangling cache variable for type metadata for PgQuery_Node?);
        v90 = v225;
        goto LABEL_158;
      }
      swift_bridgeObjectRelease();
      outlined destroy of SQLExpression((uint64_t)v242);
    }
    else
    {
      outlined destroy of (key: String, value: StorableValue)((uint64_t)&v245, &demangling cache variable for type metadata for SQLExpression?);
    }
    v143 = *(char **)v83;
    v149 = MEMORY[0x1E0DEE9E8];
    *(_QWORD *)&v237[0] = MEMORY[0x1E0DEE9E8];
    v159 = (char *)specialized Array.count.getter(v143);
    if (!v159)
      goto LABEL_232;
    v220 = v159;
    v224 = (uint64_t)(v143 + 32);
    swift_bridgeObjectRetain_n();
    v160 = 0;
    v230 = v143;
LABEL_185:
    if (__OFADD__(v160, 1))
      goto LABEL_260;
    v161 = v224 + 24 * v160;
    v162 = *(_QWORD *)(v161 + 8);
    v163 = *(_QWORD *)(v161 + 16);
    v222 = (char *)(v160 + 1);
    v223 = v160 + 1;
    v164 = *(_QWORD *)(v163 + 64);
    v226 = (_QWORD *)v162;
    v227 = (char *)(v163 + 64);
    v165 = 1 << *(_BYTE *)(v163 + 32);
    if (v165 < 64)
      v166 = ~(-1 << v165);
    else
      v166 = -1;
    v167 = v166 & v164;
    v228 = (unint64_t)(v165 + 63) >> 6;
    swift_bridgeObjectRetain();
    v231 = v163;
    swift_bridgeObjectRetain_n();
    v168 = 0;
    while (2)
    {
      if (v167)
      {
        v170 = __clz(__rbit64(v167));
        v171 = (v167 - 1) & v167;
        v233 = v168;
        v172 = v170 | ((_QWORD)v168 << 6);
LABEL_205:
        v232 = v171;
        v217 = v141;
        v176 = (uint64_t *)(*(_QWORD *)(v231 + 48) + 16 * v172);
        v177 = v176[1];
        v178 = *(_QWORD *)&v237[0];
        v235 = *v176;
        v179 = String.lowercased()();
        if (*(_QWORD *)(v178 + 16))
        {
          Hasher.init(_seed:)();
          swift_bridgeObjectRetain();
          String.hash(into:)();
          v180 = Hasher._finalize()();
          v181 = -1 << *(_BYTE *)(v178 + 32);
          v182 = v180 & ~v181;
          v183 = v178 + 56;
          if (((*(_QWORD *)(v178 + 56 + ((v182 >> 3) & 0xFFFFFFFFFFFFF8)) >> v182) & 1) != 0)
          {
            v184 = *(_QWORD *)(v178 + 48);
            v185 = v184 + 16 * v182;
            v186 = *(_QWORD *)v185 == v179._countAndFlagsBits && *(void **)(v185 + 8) == v179._object;
            if (v186 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
            {
LABEL_234:
              swift_bridgeObjectRelease();
              lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
              swift_allocError();
              *(_QWORD *)v197 = v235;
              *(_QWORD *)(v197 + 8) = v177;
              *(_QWORD *)(v197 + 16) = 0xD000000000000027;
              *(_QWORD *)(v197 + 24) = 0x800000018DCD1570;
              *(_BYTE *)(v197 + 32) = 7;
              swift_willThrow();
              swift_release();
              swift_bridgeObjectRelease();
              swift_bridgeObjectRelease();
              swift_bridgeObjectRelease();
              swift_bridgeObjectRelease();
              outlined destroy of PgQuery_Alias(v225, type metadata accessor for PgQuery_SelectStmt);
              swift_bridgeObjectRelease();
              outlined destroy of PgQuery_Alias((uint64_t)v253, type metadata accessor for PlanResources);
              v99 = 1;
              v100 = 1;
              v83 = v234;
              v91 = v221;
              goto LABEL_79;
            }
            v187 = ~v181;
            v188 = (v182 + 1) & v187;
            if (((*(_QWORD *)(v183 + ((v188 >> 3) & 0xFFFFFFFFFFFFF8)) >> v188) & 1) != 0)
            {
              v189 = v184 + 16 * v188;
              v190 = *(_QWORD *)v189 == v179._countAndFlagsBits && *(void **)(v189 + 8) == v179._object;
              if (v190 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
                goto LABEL_234;
              for (i = v188 + 1; ; i = v192 + 1)
              {
                v192 = i & v187;
                if (((*(_QWORD *)(v183 + (((i & v187) >> 3) & 0xFFFFFFFFFFFFF8)) >> (i & v187)) & 1) == 0)
                  break;
                v193 = v184 + 16 * v192;
                v194 = *(_QWORD *)v193 == v179._countAndFlagsBits && *(void **)(v193 + 8) == v179._object;
                if (v194 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
                  goto LABEL_234;
              }
            }
          }
        }
        else
        {
          swift_bridgeObjectRetain();
        }
        swift_bridgeObjectRelease();
        v169 = String.lowercased()();
        object = (char *)v169._object;
        swift_bridgeObjectRelease();
        specialized Set._Variant.insert(_:)((unint64_t *)&v245, v169._countAndFlagsBits, (unint64_t)v169._object);
        swift_bridgeObjectRelease();
        v168 = v233;
        v83 = v234;
        v86 = (uint64_t)v253;
        v91 = v221;
        v141 = v217;
        v143 = v230;
        v167 = v232;
        continue;
      }
      break;
    }
    v56 = __OFADD__(v168, 1);
    v173 = (uint64_t)(v168 + 1);
    v90 = v225;
    if (v56)
    {
      __break(1u);
LABEL_257:
      v143 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v83 + 16) + 1, 1, (char *)v83);
LABEL_152:
      v145 = *((_QWORD *)v143 + 2);
      v144 = *((_QWORD *)v143 + 3);
      if (v145 >= v144 >> 1)
        v143 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v144 > 1), v145 + 1, 1, v143);
      *((_QWORD *)v143 + 2) = v145 + 1;
      v146 = &v143[24 * v145];
      strcpy(v146 + 32, "select_alias");
      v146[45] = 0;
      *((_WORD *)v146 + 23) = -5120;
      *((_QWORD *)v146 + 6) = v90;
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      v90 = v225;
      v147 = v228;
      outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v222[v225] + v141[485], v228, &demangling cache variable for type metadata for PgQuery_Node?);
      v148 = v232;
      if (((unsigned int (*)(uint64_t, uint64_t, unint64_t))v224)(v147, 1, v232) == 1)
      {
        v141 = v226;
        UnknownStorage.init()();
        v90 = *(int *)(v148 + 20);
        v91 = v221;
        v83 = (uint64_t)v217;
        v149 = (uint64_t)v227;
        if (one-time initialization token for defaultInstance != -1)
          goto LABEL_261;
        goto LABEL_156;
      }
      v141 = v226;
      outlined init with take of PgQuery_OidList(v147, (uint64_t)v226, type metadata accessor for PgQuery_Node);
      v91 = v221;
      v83 = (uint64_t)v217;
      v149 = (uint64_t)v227;
LABEL_158:
      outlined init with copy of PgQuery_RawStmt(v86 + *(int *)(v218 + 20), v149, type metadata accessor for SQLTokenInformation);
      SQLExpression.init(expressionNode:schemas:tokenInformation:)((uint64_t)v141, (uint64_t)v143, v149, (uint64_t)&v245);
      v141 = (_QWORD *)v83;
      if (!v83)
      {
        v83 = (uint64_t)object;
        outlined init with take of (key: String, value: StorableValue)((uint64_t)&v245, (uint64_t)(object + 208), &demangling cache variable for type metadata for SQLExpression?);
        continue;
      }
      outlined destroy of PgQuery_Alias(v90, type metadata accessor for PgQuery_SelectStmt);
      outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
      v100 = 0;
      v99 = 1;
LABEL_78:
      v83 = (uint64_t)object;
      goto LABEL_79;
    }
    break;
  }
  if (v173 >= v228)
    goto LABEL_230;
  v174 = *(_QWORD *)&v227[8 * v173];
  if (v174)
    goto LABEL_204;
  v175 = v173 + 1;
  if (v173 + 1 >= v228)
    goto LABEL_230;
  v174 = *(_QWORD *)&v227[8 * v175];
  if (v174)
    goto LABEL_203;
  v175 = v173 + 2;
  if (v173 + 2 >= v228)
    goto LABEL_230;
  v174 = *(_QWORD *)&v227[8 * v175];
  if (v174)
    goto LABEL_203;
  v175 = v173 + 3;
  if (v173 + 3 < v228)
  {
    v174 = *(_QWORD *)&v227[8 * v175];
    if (!v174)
    {
      while (1)
      {
        v173 = v175 + 1;
        if (__OFADD__(v175, 1))
          break;
        if (v173 >= v228)
          goto LABEL_230;
        v174 = *(_QWORD *)&v227[8 * v173];
        ++v175;
        if (v174)
          goto LABEL_204;
      }
      __break(1u);
LABEL_263:
      __break(1u);
LABEL_264:
      __break(1u);
LABEL_265:
      __break(1u);
LABEL_266:
      __break(1u);
LABEL_267:
      __break(1u);
LABEL_268:
      __break(1u);
LABEL_269:
      __break(1u);
LABEL_270:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
      __break(1u);
      JUMPOUT(0x18DB35650);
    }
LABEL_203:
    v173 = v175;
LABEL_204:
    v171 = (v174 - 1) & v174;
    v233 = (char *)v173;
    v172 = __clz(__rbit64(v174)) + (v173 << 6);
    goto LABEL_205;
  }
LABEL_230:
  swift_bridgeObjectRelease();
  v149 = v231;
  swift_release();
  swift_bridgeObjectRelease();
  v160 = v223;
  if (v222 != v220)
    goto LABEL_185;
  swift_bridgeObjectRelease_n();
  v149 = *(_QWORD *)&v237[0];
LABEL_232:
  object = (char *)v83;
  v195 = *(_QWORD *)(v83 + 304);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  v196 = specialized Sequence.reduce<A>(into:_:)(MEMORY[0x1E0DEE9E8], v195, v149);
  if (v141)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v90, type metadata accessor for PgQuery_SelectStmt);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
    v99 = 1;
    v100 = 1;
    goto LABEL_78;
  }
  v198 = v196;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  specialized Sequence.forEach(_:)(v195, v198);
  swift_bridgeObjectRelease();
  v235 = v198;
  swift_bridgeObjectRelease();
  v199 = specialized Array.count.getter(v195);
  v217 = 0;
  if (v199)
  {
    v200 = v199;
    *(_QWORD *)&v237[0] = MEMORY[0x1E0DEE9D8];
    swift_bridgeObjectRetain();
    specialized ContiguousArray.reserveCapacity(_:)(v200);
    if (v200 < 0)
      goto LABEL_266;
    v201 = v195 + 32;
    do
    {
      outlined init with copy of ResultColumn(v201, (uint64_t)&v245);
      v202 = v249;
      swift_bridgeObjectRetain();
      outlined destroy of ResultColumn((uint64_t)&v245);
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      v203 = *(_QWORD **)(*(_QWORD *)&v237[0] + 16);
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)(v203);
      v204 = *(_QWORD *)&v237[0];
      *(_QWORD *)(*(_QWORD *)&v237[0] + 16) = (char *)v203 + 1;
      *(_QWORD *)(v204 + 8 * (_QWORD)v203 + 32) = v202;
      v201 += 128;
      --v200;
    }
    while (v200);
    swift_bridgeObjectRelease();
    object = (char *)v234;
    v86 = (uint64_t)v253;
  }
  else
  {
    v204 = specialized static Array._allocateUninitialized(_:)(0);
  }
  *(_QWORD *)&v245 = specialized static Array._allocateUninitialized(_:)(0);
  v205 = specialized Array.count.getter(v204);
  v91 = v221;
  if (v205)
  {
    v206 = v205;
    if (v205 < 1)
      goto LABEL_267;
    swift_bridgeObjectRetain();
    for (j = 0; j != v206; ++j)
    {
      v208 = swift_bridgeObjectRetain();
      specialized Array.append<A>(contentsOf:)(v208);
    }
    swift_bridgeObjectRelease_n();
  }
  else
  {
    swift_bridgeObjectRelease();
  }
  v209 = v245;
  v83 = (uint64_t)object;
  v210 = v217;
  if (*((_QWORD *)object + 29))
    v211 = swift_bridgeObjectRetain();
  else
    v211 = specialized static Array._allocateUninitialized(_:)(0);
  *(_QWORD *)&v245 = v209;
  specialized Array.append<A>(contentsOf:)(v211);
  v212 = v245;
  swift_bridgeObjectRetain();
  v213 = v235;
  swift_bridgeObjectRetain();
  specialized Sequence.forEach(_:)(v212, v149, v213);
  if (v210)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v225, type metadata accessor for PgQuery_SelectStmt);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
    swift_bridgeObjectRelease();
    goto LABEL_173;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_Alias(v225, type metadata accessor for PgQuery_SelectStmt);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_Alias(v86, type metadata accessor for PlanResources);
  return swift_bridgeObjectRelease();
}

uint64_t closure #1 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, _QWORD *a5@<X8>)
{
  uint64_t v5;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t Node;
  uint64_t v15;
  char *v16;
  uint64_t (*v17)(_QWORD);
  uint64_t v18;
  uint64_t result;
  _QWORD v20[2];

  v11 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1E0C80A78](v11);
  v13 = (char *)v20 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  MEMORY[0x1E0C80A78](Node);
  v16 = (char *)v20 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  outlined init with copy of PgQuery_RawStmt(a1, (uint64_t)v16, v17);
  v18 = type metadata accessor for PlanResources(0);
  outlined init with copy of PgQuery_RawStmt(a3 + *(int *)(v18 + 20), (uint64_t)v13, type metadata accessor for SQLTokenInformation);
  swift_bridgeObjectRetain();
  result = ResultColumn.init(node:schemas:tokenInformation:)((uint64_t)v16, a2, (uint64_t)v13, a5);
  if (v5)
    *a4 = v5;
  return result;
}

uint64_t closure #3 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v5;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t Node;
  uint64_t v15;
  char *v16;
  uint64_t (*v17)(_QWORD);
  uint64_t v18;
  uint64_t result;
  _QWORD v20[2];

  v11 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1E0C80A78](v11);
  v13 = (char *)v20 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  MEMORY[0x1E0C80A78](Node);
  v16 = (char *)v20 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  outlined init with copy of PgQuery_RawStmt(a1, (uint64_t)v16, v17);
  v18 = type metadata accessor for PlanResources(0);
  outlined init with copy of PgQuery_RawStmt(a3 + *(int *)(v18 + 20), (uint64_t)v13, type metadata accessor for SQLTokenInformation);
  swift_bridgeObjectRetain();
  result = SQLExpression.init(expressionNode:schemas:tokenInformation:)((uint64_t)v16, a2, (uint64_t)v13, a5);
  if (v5)
    *a4 = v5;
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance SelectCore.CodingKeys()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_18DB358D8 + 4 * byte_18DC2D26B[*v0]))(1836020326, 0xE400000000000000);
}

uint64_t sub_18DB358D8()
{
  return 0x6572656877;
}

uint64_t sub_18DB358EC()
{
  return 0x794270756F7267;
}

uint64_t sub_18DB35904()
{
  return 0x676E69766168;
}

uint64_t sub_18DB35918()
{
  return 0x7463656C6573;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance SelectCore.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized SelectCore.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance SelectCore.CodingKeys()
{
  lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance SelectCore.CodingKeys()
{
  lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t SelectCore.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v10;
  uint64_t v11;

  v3 = v1;
  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<SelectCore.CodingKeys>);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v8 = (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  LOBYTE(v11) = 0;
  lazy protocol witness table accessor for type FromClause and conformance FromClause();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v2)
  {
    LOBYTE(v11) = 1;
    lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    v11 = *(_QWORD *)(v3 + 200);
    HIBYTE(v10) = 2;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [SQLExpression]);
    lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](&lazy protocol witness table cache variable for type [SQLExpression] and conformance <A> [A], &demangling cache variable for type metadata for [SQLExpression], (uint64_t (*)(void))lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression);
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    LOBYTE(v11) = 3;
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    v11 = *(_QWORD *)(v3 + 304);
    HIBYTE(v10) = 4;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [ResultColumn]);
    lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](&lazy protocol witness table cache variable for type [ResultColumn] and conformance <A> [A], &demangling cache variable for type metadata for [ResultColumn], (uint64_t (*)(void))lazy protocol witness table accessor for type ResultColumn and conformance ResultColumn);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SelectCore(_QWORD *a1)
{
  return SelectCore.encode(to:)(a1);
}

void *MaterializedView.init(create:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, Swift::String *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t IntoClause;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  int v32;
  uint64_t v33;
  char *v34;
  uint64_t Alias;
  Swift::Int32 v36;
  Swift::String v37;
  uint64_t v38;
  Swift::String *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t SelectStmt;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  Swift::String *v59;
  uint64_t v60;
  uint64_t Node;
  uint64_t v62;
  uint64_t v63;
  uint64_t RangeVar;
  char *v65;
  _BYTE v66[320];
  uint64_t v67;

  v67 = a2;
  v59 = a3;
  v63 = type metadata accessor for PlanResources(0);
  MEMORY[0x1E0C80A78](v63);
  v58 = (uint64_t)&v51 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1E0C80A78](v5);
  v55 = (char *)&v51 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  SelectStmt = type metadata accessor for PgQuery_SelectStmt(0);
  MEMORY[0x1E0C80A78](SelectStmt);
  v57 = (char *)&v51 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1E0C80A78](v8);
  v60 = (uint64_t)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  v54 = *(_QWORD *)(Node - 8);
  MEMORY[0x1E0C80A78](Node);
  v56 = (uint64_t)&v51 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_RangeVar?);
  MEMORY[0x1E0C80A78](v11);
  v65 = (char *)&v51 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  v62 = *(_QWORD *)(RangeVar - 8);
  MEMORY[0x1E0C80A78](RangeVar);
  v14 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_IntoClause?);
  MEMORY[0x1E0C80A78](v15);
  v17 = (char *)&v51 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  IntoClause = type metadata accessor for PgQuery_IntoClause(0);
  v19 = *(_QWORD *)(IntoClause - 8);
  MEMORY[0x1E0C80A78](IntoClause);
  v21 = (char *)&v51 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1E0C80A78](v22);
  v24 = (char *)&v51 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  v25 = a1;
  v53 = *(int *)(type metadata accessor for PgQuery_CreateTableAsStmt(0) + 20);
  v26 = *(_QWORD *)(a1 + v53);
  if (destructiveProjectEnumData for StorableValue(*(_QWORD *)(v26+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind), *(unsigned __int8 *)(v26+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind+ 8)) != 24)
  {
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v29 = 0xD000000000000039;
    *(_QWORD *)(v29 + 8) = 0x800000018DCD1510;
    *(_QWORD *)(v29 + 16) = 0;
    *(_QWORD *)(v29 + 24) = 0;
    *(_BYTE *)(v29 + 32) = 1;
    swift_willThrow();
    outlined destroy of PgQuery_Alias(v67, type metadata accessor for PlanResources);
    return (void *)outlined destroy of PgQuery_Alias(v25, type metadata accessor for PgQuery_CreateTableAsStmt);
  }
  v51 = v25;
  outlined init with copy of PgQuery_RawStmt(v67 + *(int *)(v63 + 20), (uint64_t)v24, type metadata accessor for SQLTokenInformation);
  outlined init with copy of PgQuery_Alias?(v26+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__into, (uint64_t)v17, &demangling cache variable for type metadata for PgQuery_IntoClause?);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v17, 1, IntoClause) == 1)
  {
    UnknownStorage.init()();
    v27 = *(int *)(IntoClause + 20);
    v28 = (uint64_t)v65;
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)&v21[v27] = static PgQuery_IntoClause._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v17, &demangling cache variable for type metadata for PgQuery_IntoClause?);
  }
  else
  {
    outlined init with take of PgQuery_OidList((uint64_t)v17, (uint64_t)v21, type metadata accessor for PgQuery_IntoClause);
    v28 = (uint64_t)v65;
  }
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v21[*(int *)(IntoClause + 20)]+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rel, v28, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  v31 = RangeVar;
  v32 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v62 + 48))(v28, 1, RangeVar);
  v33 = v51;
  if (v32 == 1)
  {
    *(_QWORD *)v14 = 0;
    *((_QWORD *)v14 + 1) = 0xE000000000000000;
    *((_QWORD *)v14 + 2) = 0;
    *((_QWORD *)v14 + 3) = 0xE000000000000000;
    *((_QWORD *)v14 + 4) = 0;
    *((_QWORD *)v14 + 5) = 0xE000000000000000;
    v14[48] = 0;
    *((_QWORD *)v14 + 7) = 0;
    *((_QWORD *)v14 + 8) = 0xE000000000000000;
    *((_DWORD *)v14 + 18) = 0;
    UnknownStorage.init()();
    v34 = &v14[*(int *)(v31 + 44)];
    Alias = type metadata accessor for PgQuery_Alias(0);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(Alias - 8) + 56))(v34, 1, 1, Alias);
    outlined destroy of (key: String, value: StorableValue)(v28, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  }
  else
  {
    outlined init with take of PgQuery_OidList(v28, (uint64_t)v14, type metadata accessor for PgQuery_RangeVar);
  }
  outlined destroy of PgQuery_Alias((uint64_t)v21, type metadata accessor for PgQuery_IntoClause);
  v36 = *((_DWORD *)v14 + 18);
  outlined destroy of PgQuery_Alias((uint64_t)v14, type metadata accessor for PgQuery_RangeVar);
  v37 = SQLTokenInformation.tokenName(location:)(v36);
  if (v38)
  {
    outlined destroy of PgQuery_Alias(v67, type metadata accessor for PlanResources);
    outlined destroy of PgQuery_Alias(v33, type metadata accessor for PgQuery_CreateTableAsStmt);
    return (void *)outlined destroy of PgQuery_Alias((uint64_t)v24, type metadata accessor for SQLTokenInformation);
  }
  outlined destroy of PgQuery_Alias((uint64_t)v24, type metadata accessor for SQLTokenInformation);
  v39 = v59;
  v40 = v60;
  *v59 = v37;
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v33 + v53)+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query, v40, &demangling cache variable for type metadata for PgQuery_Node?);
  v41 = Node;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v54 + 48))(v40, 1, Node) == 1)
  {
    v42 = v56;
    UnknownStorage.init()();
    v43 = *(int *)(v41 + 20);
    v44 = (uint64_t)v57;
    v45 = (uint64_t)v55;
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)(v42 + v43) = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of (key: String, value: StorableValue)(v60, &demangling cache variable for type metadata for PgQuery_Node?);
    v41 = Node;
  }
  else
  {
    v46 = v40;
    v42 = v56;
    outlined init with take of PgQuery_OidList(v46, v56, type metadata accessor for PgQuery_Node);
    v44 = (uint64_t)v57;
    v45 = (uint64_t)v55;
  }
  outlined init with copy of PgQuery_Alias?(*(_QWORD *)(v42 + *(int *)(v41 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v45, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v47 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v47 - 8) + 48))(v45, 1, v47) == 1)
  {
    outlined destroy of (key: String, value: StorableValue)(v45, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_23:
    UnknownStorage.init()();
    v48 = *(int *)(SelectStmt + 20);
    if (one-time initialization token for defaultInstance != -1)
      swift_once();
    *(_QWORD *)(v44 + v48) = static PgQuery_SelectStmt._StorageClass.defaultInstance;
    swift_retain();
    goto LABEL_26;
  }
  if (swift_getEnumCaseMultiPayload() != 56)
  {
    outlined destroy of PgQuery_Alias(v45, type metadata accessor for PgQuery_Node.OneOf_Node);
    goto LABEL_23;
  }
  outlined init with take of PgQuery_OidList(v45, v44, type metadata accessor for PgQuery_SelectStmt);
LABEL_26:
  v49 = v67;
  outlined destroy of PgQuery_Alias(v42, type metadata accessor for PgQuery_Node);
  v50 = v58;
  outlined init with copy of PgQuery_RawStmt(v49, v58, type metadata accessor for PlanResources);
  SelectCore.init(select:resources:)(v44, v50, (uint64_t)v66);
  outlined destroy of PgQuery_Alias(v49, type metadata accessor for PlanResources);
  outlined destroy of PgQuery_Alias(v33, type metadata accessor for PgQuery_CreateTableAsStmt);
  return memcpy(&v39[1], v66, 0x138uLL);
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance MaterializedView.CodingKeys()
{
  _BYTE *v0;

  if (*v0)
    return 0x7463656C6573;
  else
    return 1701667182;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance MaterializedView.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized MaterializedView.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance MaterializedView.CodingKeys()
{
  lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance MaterializedView.CodingKeys()
{
  lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t MaterializedView.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  _BYTE v8[16];

  v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<MaterializedView.CodingKeys>);
  v4 = *(_QWORD *)(v3 - 8);
  MEMORY[0x1E0C80A78](v3);
  v6 = &v8[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v8[15] = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v1)
  {
    v8[14] = 1;
    lazy protocol witness table accessor for type SelectCore and conformance SelectCore();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(_BYTE *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance MaterializedView(_QWORD *a1)
{
  return MaterializedView.encode(to:)(a1);
}

uint64_t LogicalPlan.plan.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;

  return outlined init with copy of LogicalPlanType(v1, a1);
}

uint64_t LogicalPlan.sql.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 336);
  swift_bridgeObjectRetain();
  return v1;
}

uint64_t LogicalPlan.documentation.getter()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(_QWORD *)(v0 + 352);
  swift_bridgeObjectRetain();
  return v1;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance LogicalPlan.CodingKeys()
{
  unsigned __int8 *v0;

  return ((uint64_t (*)(uint64_t, unint64_t))((char *)sub_18DB36620 + 4 * byte_18DC2D270[*v0]))(7106931, 0xE300000000000000);
}

uint64_t sub_18DB36620()
{
  return 0x746E656D75636F64;
}

unint64_t sub_18DB36644()
{
  return 0xD000000000000010;
}

uint64_t sub_18DB36660()
{
  return 0x6F437463656C6573;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance LogicalPlan.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized LogicalPlan.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance LogicalPlan.CodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 4;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlan.CodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlan.CodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t LogicalPlan.encode(to:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  _QWORD v10[41];
  _BYTE v11[344];
  char v12;

  v3 = v1;
  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlan.CodingKeys>);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v8 = (char *)v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  outlined init with copy of LogicalPlanType(v3, (uint64_t)v11);
  if (v11[328] == 1)
  {
    memcpy(v10, v11, sizeof(v10));
    v12 = 2;
    lazy protocol witness table accessor for type MaterializedView and conformance MaterializedView();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    outlined destroy of MaterializedView(v10);
    if (!v2)
      goto LABEL_7;
  }
  else
  {
    memcpy(v10, v11, 0x138uLL);
    v12 = 3;
    lazy protocol witness table accessor for type SelectCore and conformance SelectCore();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    if (!v2)
    {
      outlined destroy of SelectCore(v10);
LABEL_7:
      v11[0] = 0;
      KeyedEncodingContainer.encode(_:forKey:)();
      v11[0] = 1;
      KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
      return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
    }
    outlined destroy of SelectCore(v10);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance LogicalPlan(_QWORD *a1)
{
  return LogicalPlan.encode(to:)(a1);
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance LogicalPlanType.CodingKeys()
{
  _BYTE *v0;

  if (*v0)
    return 0xD000000000000010;
  else
    return 0x6F437463656C6573;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance LogicalPlanType.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = specialized LogicalPlanType.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlanType.CodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlanType.CodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlanType.MaterializedViewCodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlanType.MaterializedViewCodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance LogicalPlanType.MaterializedViewCodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v5;
  uint64_t result;
  char v7;

  if (a1 == 12383 && a2 == 0xE200000000000000)
  {
    result = swift_bridgeObjectRelease();
    v7 = 0;
  }
  else
  {
    v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    result = swift_bridgeObjectRelease();
    v7 = v5 ^ 1;
  }
  *a3 = v7 & 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlanType.SelectCoreCodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys();
  return CodingKey.description.getter();
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlanType.SelectCoreCodingKeys()
{
  lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys();
  return CodingKey.debugDescription.getter();
}

uint64_t LogicalPlanType.encode(to:)(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[41];
  _BYTE v19[344];
  char v20;

  v2 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlanType.MaterializedViewCodingKeys>);
  v14 = *(_QWORD *)(v2 - 8);
  v15 = v2;
  MEMORY[0x1E0C80A78](v2);
  v4 = (char *)&v13 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlanType.SelectCoreCodingKeys>);
  v13 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](v5);
  v7 = (char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlanType.CodingKeys>);
  v16 = *(_QWORD *)(v8 - 8);
  MEMORY[0x1E0C80A78](v8);
  v10 = (char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  outlined init with copy of LogicalPlanType(v17, (uint64_t)v19);
  if ((v19[328] & 1) != 0)
  {
    memcpy(v18, v19, sizeof(v18));
    v20 = 1;
    lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys();
    KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
    lazy protocol witness table accessor for type MaterializedView and conformance MaterializedView();
    v11 = v15;
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v14 + 8))(v4, v11);
    outlined destroy of MaterializedView(v18);
  }
  else
  {
    memcpy(v18, v19, 0x138uLL);
    v20 = 0;
    lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys();
    KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
    lazy protocol witness table accessor for type SelectCore and conformance SelectCore();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v13 + 8))(v7, v5);
    outlined destroy of SelectCore(v18);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v16 + 8))(v10, v8);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance LogicalPlanType(_QWORD *a1)
{
  return LogicalPlanType.encode(to:)(a1);
}

uint64_t SQLParseResult.plans(with:)(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  int *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n;
  _BYTE v19[16];
  _BYTE *v20;
  _QWORD *v21;

  v3 = type metadata accessor for PlanResources(0);
  MEMORY[0x1E0C80A78](v3);
  v5 = &v19[-((v4 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v6 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1E0C80A78](v6);
  v8 = &v19[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v9 = *a1;
  v10 = (int *)type metadata accessor for SQLParseResult(0);
  outlined init with copy of PgQuery_RawStmt(v1 + v10[5], (uint64_t)v8, type metadata accessor for PgQuery_ScanResult);
  v11 = (uint64_t *)(v1 + v10[7]);
  v12 = *v11;
  v13 = v11[1];
  v14 = &v8[*(int *)(v6 + 20)];
  *v14 = v12;
  v14[1] = v13;
  outlined init with copy of PgQuery_RawStmt((uint64_t)v8, (uint64_t)v5 + *(int *)(v3 + 20), type metadata accessor for SQLTokenInformation);
  *v5 = v9;
  v15 = *(_QWORD *)(v1 + 8);
  v16 = *(_QWORD *)(v1 + v10[6]);
  v20 = v8;
  v21 = v5;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFs12Zip2SequenceVySay14BiomeSQLParser15PgQuery_RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n(v15, v16, (void (*)(_QWORD *__return_ptr, uint64_t, uint64_t, uint64_t))partial apply for closure #1 in SQLParseResult.plans(with:), (uint64_t)v19);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_Alias((uint64_t)v5, type metadata accessor for PlanResources);
  outlined destroy of PgQuery_Alias((uint64_t)v8, type metadata accessor for SQLTokenInformation);
  return RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n;
}

uint64_t closure #1 in SQLParseResult.plans(with:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _QWORD *a6@<X8>)
{
  uint64_t SelectStmt;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t TableAsStmt;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t ScanToken;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t);
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t Node;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t result;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  void *v58;
  char *v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  char *v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int EnumCaseMultiPayload;
  uint64_t v82;
  uint64_t v83;
  uint64_t (*v84)(uint64_t);
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  Swift::String v88;
  uint64_t v89;
  Swift::String v90;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v93;
  _QWORD *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  char *v116;
  char *v117;
  uint64_t v118;
  unint64_t v119;
  char *v120;
  uint64_t v121;
  void (*v122)(char *, uint64_t);
  unint64_t v123;
  char *v124;
  uint64_t v125;
  uint64_t v126;
  Swift::String v127[20];
  char v128;
  uint64_t v129;

  v104 = a5;
  v118 = a4;
  v97 = a6;
  v98 = a3;
  v96 = a2;
  SelectStmt = type metadata accessor for PgQuery_SelectStmt(0);
  v8 = MEMORY[0x1E0C80A78](SelectStmt);
  v103 = (uint64_t)&v96 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v8);
  v117 = (char *)&v96 - v10;
  v11 = type metadata accessor for PlanResources(0);
  v12 = MEMORY[0x1E0C80A78](v11);
  v102 = (uint64_t)&v96 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v101 = (uint64_t)&v96 - v14;
  TableAsStmt = type metadata accessor for PgQuery_CreateTableAsStmt(0);
  v16 = MEMORY[0x1E0C80A78](TableAsStmt);
  v99 = (uint64_t)&v96 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v100 = (unint64_t)&v96 - v18;
  v125 = type metadata accessor for CharacterSet();
  v113 = *(_QWORD *)(v125 - 8);
  MEMORY[0x1E0C80A78](v125);
  v124 = (char *)&v96 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  v21 = *(_QWORD *)(ScanToken - 8);
  v22 = MEMORY[0x1E0C80A78](ScanToken);
  v114 = (char *)&v96 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v25 = (uint64_t (*)(uint64_t))((char *)&v96 - v24);
  v26 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1E0C80A78](v26);
  v28 = (char *)&v96 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  Node = type metadata accessor for PgQuery_Node(0);
  v30 = *(_QWORD *)(Node - 8);
  MEMORY[0x1E0C80A78](Node);
  v32 = (char *)&v96 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
  v107 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v33 = MEMORY[0x1E0C80A78](v107);
  v106 = (uint64_t)&v96 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  v35 = MEMORY[0x1E0C80A78](v33);
  v108 = (uint64_t)&v96 - v36;
  v37 = MEMORY[0x1E0C80A78](v35);
  v116 = (char *)&v96 - v38;
  MEMORY[0x1E0C80A78](v37);
  v115 = (uint64_t)&v96 - v39;
  v40 = *(uint64_t **)(a1 + *(int *)(type metadata accessor for PgQuery_RawStmt(0) + 20));
  outlined init with copy of PgQuery_Alias?((uint64_t)v40+ OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt, (uint64_t)v28, &demangling cache variable for type metadata for PgQuery_Node?);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v30 + 48))(v28, 1, Node) != 1)
  {
    outlined init with take of PgQuery_OidList((uint64_t)v28, (uint64_t)v32, type metadata accessor for PgQuery_Node);
    goto LABEL_5;
  }
  UnknownStorage.init()();
  v41 = *(int *)(Node + 20);
  if (one-time initialization token for defaultInstance != -1)
    goto LABEL_59;
  while (1)
  {
    *(_QWORD *)&v32[v41] = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of (key: String, value: StorableValue)((uint64_t)v28, &demangling cache variable for type metadata for PgQuery_Node?);
LABEL_5:
    outlined init with copy of PgQuery_Alias?(*(_QWORD *)&v32[*(int *)(Node + 20)]+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v115, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of PgQuery_Alias((uint64_t)v32, type metadata accessor for PgQuery_Node);
    v42 = *(_QWORD *)(v118 + 8);
    v43 = *(_QWORD *)(v42 + 16);
    v44 = (uint64_t)v116;
    v28 = v120;
    if (!v43)
    {
      v46 = 0;
      v47 = 0;
      v41 = (unint64_t)v117;
      goto LABEL_41;
    }
    LODWORD(v40) = *(_DWORD *)((char *)v40
                             + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation);
    v45 = v42 + ((*(unsigned __int8 *)(v21 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v21 + 80));
    v121 = *(_QWORD *)(v21 + 72);
    v105 = v42;
    swift_bridgeObjectRetain();
    v21 = 0;
    v112 = v45;
    while (1)
    {
      outlined init with copy of PgQuery_RawStmt(v45, (uint64_t)v25, type metadata accessor for PgQuery_ScanToken);
      Node = *(unsigned int *)v25;
      outlined destroy of PgQuery_Alias((uint64_t)v25, type metadata accessor for PgQuery_ScanToken);
      if ((int)Node >= (int)v40)
        break;
      v45 += v121;
      if (v43 == ++v21)
      {
        swift_bridgeObjectRelease();
        v46 = 0;
        v47 = 0;
        v44 = (uint64_t)v116;
        v41 = (unint64_t)v117;
        goto LABEL_41;
      }
    }
    v48 = v105;
    result = swift_bridgeObjectRelease();
    v129 = MEMORY[0x1E0DEE9D8];
    v50 = *(_QWORD *)(v48 + 16);
    v110 = v50;
    if (v50 < v21)
      break;
    if (v50 == v21)
    {
      v44 = (uint64_t)v116;
      v41 = (unint64_t)v117;
LABEL_38:
      if (*(_QWORD *)(v129 + 16))
      {
        v127[0]._countAndFlagsBits = v129;
        __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
        lazy protocol witness table accessor for type [String] and conformance [A]();
        v46 = BidirectionalCollection<>.joined(separator:)();
        v47 = v79;
        swift_bridgeObjectRelease();
      }
      else
      {
        swift_bridgeObjectRelease();
        v46 = 0;
        v47 = 0;
      }
LABEL_41:
      outlined init with copy of PgQuery_Alias?(v115, v44, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      v80 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v80 - 8) + 48))(v44, 1, v80) == 1)
      {
        swift_bridgeObjectRelease();
LABEL_51:
        v127[0]._countAndFlagsBits = 0;
        v127[0]._object = (void *)0xE000000000000000;
        _StringGuts.grow(_:)(90);
        v88._object = (void *)0x800000018DCD14B0;
        v88._countAndFlagsBits = 0xD000000000000058;
        String.append(_:)(v88);
        v89 = v115;
        outlined init with copy of PgQuery_Alias?(v115, v106, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        v90._countAndFlagsBits = String.init<A>(describing:)();
        String.append(_:)(v90);
        swift_bridgeObjectRelease();
        countAndFlagsBits = v127[0]._countAndFlagsBits;
        object = v127[0]._object;
        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
        swift_allocError();
        *(_QWORD *)v93 = countAndFlagsBits;
        *(_QWORD *)(v93 + 8) = object;
        *(_QWORD *)(v93 + 16) = 0;
        *(_QWORD *)(v93 + 24) = 0;
        *(_BYTE *)(v93 + 32) = 1;
        swift_willThrow();
        v87 = v89;
        goto LABEL_52;
      }
      outlined init with copy of PgQuery_Alias?(v44, v108, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
      if (EnumCaseMultiPayload == 56)
      {
        outlined init with take of PgQuery_OidList(v108, v41, type metadata accessor for PgQuery_SelectStmt);
        v85 = v103;
        outlined init with copy of PgQuery_RawStmt(v41, v103, type metadata accessor for PgQuery_SelectStmt);
        v86 = v102;
        outlined init with copy of PgQuery_RawStmt(v104, v102, type metadata accessor for PlanResources);
        SelectCore.init(select:resources:)(v85, v86, (uint64_t)v127);
        if (v28)
        {
          swift_bridgeObjectRelease();
          v84 = type metadata accessor for PgQuery_SelectStmt;
          goto LABEL_49;
        }
        outlined destroy of PgQuery_Alias(v41, type metadata accessor for PgQuery_SelectStmt);
        outlined destroy of (key: String, value: StorableValue)(v115, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        v128 = 0;
      }
      else
      {
        if (EnumCaseMultiPayload != 90)
        {
          swift_bridgeObjectRelease();
          outlined destroy of PgQuery_Alias(v108, type metadata accessor for PgQuery_Node.OneOf_Node);
          goto LABEL_51;
        }
        v41 = v100;
        outlined init with take of PgQuery_OidList(v108, v100, type metadata accessor for PgQuery_CreateTableAsStmt);
        v82 = v99;
        outlined init with copy of PgQuery_RawStmt(v41, v99, type metadata accessor for PgQuery_CreateTableAsStmt);
        v83 = v101;
        outlined init with copy of PgQuery_RawStmt(v104, v101, type metadata accessor for PlanResources);
        MaterializedView.init(create:resources:)(v82, v83, v127);
        if (v28)
        {
          swift_bridgeObjectRelease();
          v84 = type metadata accessor for PgQuery_CreateTableAsStmt;
LABEL_49:
          outlined destroy of PgQuery_Alias(v41, v84);
          v87 = v115;
LABEL_52:
          outlined destroy of (key: String, value: StorableValue)(v87, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          return outlined destroy of (key: String, value: StorableValue)(v44, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        }
        outlined destroy of PgQuery_Alias(v41, type metadata accessor for PgQuery_CreateTableAsStmt);
        outlined destroy of (key: String, value: StorableValue)(v115, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        v128 = 1;
      }
      v94 = v97;
      outlined init with take of LogicalPlanType(v127, v97);
      v95 = v98;
      v94[42] = v96;
      v94[43] = v95;
      v94[44] = v46;
      v94[45] = v47;
      swift_bridgeObjectRetain();
      return outlined destroy of (key: String, value: StorableValue)(v44, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    v51 = v110;
    if (v110 <= v21)
      v51 = v21;
    v109 = v51;
    swift_bridgeObjectRetain();
    v25 = type metadata accessor for PgQuery_ScanToken;
    v44 = (uint64_t)v116;
    v41 = (unint64_t)v117;
    v32 = v114;
    while (v21 != v109)
    {
      outlined init with copy of PgQuery_RawStmt(v112 + v21 * v121, (uint64_t)v32, type metadata accessor for PgQuery_ScanToken);
      v52 = *((_QWORD *)v32 + 1);
      if (v32[16] != 1 || (unint64_t)(v52 - 37) >= 2)
      {
        outlined destroy of PgQuery_Alias((uint64_t)v32, type metadata accessor for PgQuery_ScanToken);
LABEL_37:
        swift_bridgeObjectRelease();
        goto LABEL_38;
      }
      v119 = v21;
      v40 = (uint64_t *)PgQuery_Token.rawValue.getter(v52, 1);
      v54 = v118 + *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
      v25 = *(uint64_t (**)(uint64_t))v54;
      v21 = *(_QWORD *)(v54 + 8);
      v41 = String.index(_:offsetBy:)();
      if ((unint64_t)String.index(_:offsetBy:)() >> 14 < v41 >> 14)
        goto LABEL_58;
      v55 = String.subscript.getter();
      v56 = MEMORY[0x193FEC5A0](v55);
      v58 = v57;
      swift_bridgeObjectRelease();
      v127[0]._countAndFlagsBits = v56;
      v127[0]._object = v58;
      v59 = v124;
      static CharacterSet.whitespaces.getter();
      v123 = lazy protocol witness table accessor for type String and conformance String();
      v60 = StringProtocol.trimmingCharacters(in:)();
      v62 = v61;
      v122 = *(void (**)(char *, uint64_t))(v113 + 8);
      v122(v59, v125);
      v63 = swift_bridgeObjectRelease();
      v40 = &v96;
      v127[0]._countAndFlagsBits = 10;
      v127[0]._object = (void *)0xE100000000000000;
      MEMORY[0x1E0C80A78](v63);
      *(&v96 - 2) = (uint64_t)v127;
      swift_bridgeObjectRetain();
      v64 = specialized Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(0x7FFFFFFFFFFFFFFFLL, 1, partial apply for specialized closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:), (uint64_t)(&v96 - 4), v60, v62);
      swift_bridgeObjectRelease();
      v65 = *((_QWORD *)v64 + 2);
      if (v65)
      {
        v120 = v28;
        v126 = MEMORY[0x1E0DEE9D8];
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v65, 0);
        v111 = v64;
        v66 = (uint64_t *)(v64 + 56);
        do
        {
          v67 = *(v66 - 3);
          v68 = *(v66 - 2);
          v70 = *(v66 - 1);
          v69 = *v66;
          swift_bridgeObjectRetain();
          if (Substring.distance(from:to:)())
          {
            v127[0]._countAndFlagsBits = MEMORY[0x193FEC5A0](v67, v68, v70, v69);
            v127[0]._object = v71;
            v72 = v124;
            static CharacterSet.whitespaces.getter();
            v73 = StringProtocol.trimmingCharacters(in:)();
            v75 = v74;
            v122(v72, v125);
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
          }
          else
          {
            swift_bridgeObjectRelease();
            v75 = 0xE100000000000000;
            v73 = 10;
          }
          Node = v126;
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(Node + 16) + 1, 1);
            Node = v126;
          }
          v77 = *(_QWORD *)(Node + 16);
          v76 = *(_QWORD *)(Node + 24);
          v40 = (uint64_t *)(v77 + 1);
          if (v77 >= v76 >> 1)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v76 > 1, v77 + 1, 1);
            Node = v126;
          }
          *(_QWORD *)(Node + 16) = v40;
          v78 = Node + 16 * v77;
          *(_QWORD *)(v78 + 32) = v73;
          *(_QWORD *)(v78 + 40) = v75;
          v66 += 4;
          --v65;
        }
        while (v65);
        swift_bridgeObjectRelease();
        v44 = (uint64_t)v116;
        v28 = v120;
      }
      else
      {
        swift_bridgeObjectRelease();
        Node = MEMORY[0x1E0DEE9D8];
      }
      v21 = v119 + 1;
      specialized Array.append<A>(contentsOf:)();
      v32 = v114;
      v25 = type metadata accessor for PgQuery_ScanToken;
      outlined destroy of PgQuery_Alias((uint64_t)v114, type metadata accessor for PgQuery_ScanToken);
      v41 = (unint64_t)v117;
      if (v21 == v110)
        goto LABEL_37;
    }
    __break(1u);
LABEL_58:
    __break(1u);
LABEL_59:
    swift_once();
  }
  __break(1u);
  return result;
}

uint64_t _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFs12Zip2SequenceVySay14BiomeSQLParser15PgQuery_RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n(uint64_t a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t RawStmt;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t *v20;
  unint64_t v21;
  int64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(_QWORD *__return_ptr, uint64_t, uint64_t, uint64_t);
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  int64_t v62;
  uint64_t v63;
  _QWORD v64[47];
  int64_t v65;

  v58 = a3;
  v59 = a4;
  RawStmt = type metadata accessor for PgQuery_RawStmt(0);
  v60 = *(_QWORD *)(RawStmt - 8);
  v7 = MEMORY[0x1E0C80A78](RawStmt);
  v9 = (char *)&v49 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v7);
  v52 = (uint64_t)&v49 - v10;
  v57 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_RawStmt, String));
  v11 = MEMORY[0x1E0C80A78](v57);
  v54 = (uint64_t)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v51 = (uint64_t)&v49 - v14;
  MEMORY[0x1E0C80A78](v13);
  v50 = (uint64_t)&v49 - v15;
  v16 = *(_QWORD *)(a2 + 16);
  v61 = *(_QWORD *)(a1 + 16);
  if (v16 >= v61)
    v17 = v61;
  else
    v17 = v16;
  v65 = MEMORY[0x1E0DEE9D8];
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v17, 0);
  v55 = v16;
  v56 = a1;
  v49 = a2;
  if (v17)
  {
    v53 = v9;
    v62 = v65;
    swift_bridgeObjectRetain();
    result = swift_bridgeObjectRetain();
    v19 = 0;
    v20 = (uint64_t *)(a2 + 40);
    v21 = v61;
    while (v21 != v19)
    {
      v22 = v17;
      v23 = (uint64_t)v53;
      result = outlined init with copy of PgQuery_RawStmt(a1+ ((*(unsigned __int8 *)(v60 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v60 + 80))+ *(_QWORD *)(v60 + 72) * v19, (uint64_t)v53, type metadata accessor for PgQuery_RawStmt);
      if (v16 == v19)
        goto LABEL_36;
      v24 = *(v20 - 1);
      v25 = *v20;
      v26 = (_QWORD *)(v54 + *(int *)(v57 + 48));
      v27 = v23;
      v28 = v54;
      outlined init with take of PgQuery_OidList(v27, v54, type metadata accessor for PgQuery_RawStmt);
      *v26 = v24;
      v26[1] = v25;
      swift_bridgeObjectRetain();
      v29 = v63;
      v58(v64, v28, v24, v25);
      v63 = v29;
      if (v29)
      {
        swift_release();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return outlined destroy of (key: String, value: StorableValue)(v28, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      }
      outlined destroy of (key: String, value: StorableValue)(v28, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      v30 = v62;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v30 + 16) + 1, 1);
        v30 = v65;
      }
      v21 = v61;
      v17 = v22;
      v32 = *(_QWORD *)(v30 + 16);
      v31 = *(_QWORD *)(v30 + 24);
      if (v32 >= v31 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v31 > 1), v32 + 1, 1);
        v21 = v61;
        v30 = v65;
      }
      ++v19;
      *(_QWORD *)(v30 + 16) = v32 + 1;
      v62 = v30;
      result = (uint64_t)memcpy((void *)(v30 + 368 * v32 + 32), v64, 0x170uLL);
      v20 += 2;
      v16 = v55;
      a1 = v56;
      if (v22 == v19)
        goto LABEL_16;
    }
    __break(1u);
LABEL_36:
    __break(1u);
  }
  else
  {
    swift_bridgeObjectRetain();
    result = swift_bridgeObjectRetain();
    v21 = v61;
LABEL_16:
    if (v21 <= v16)
    {
LABEL_33:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return v65;
    }
    if (v17 <= (uint64_t)v16)
      v33 = v16;
    else
      v33 = v17;
    v62 = v33;
    v34 = (uint64_t *)(v49 + 16 * v17 + 40);
    v35 = v57;
    while (v21 != v17)
    {
      result = outlined init with copy of PgQuery_RawStmt(a1+ ((*(unsigned __int8 *)(v60 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v60 + 80))+ *(_QWORD *)(v60 + 72) * v17, v52, type metadata accessor for PgQuery_RawStmt);
      if (v55 == v17)
      {
        outlined destroy of PgQuery_Alias(v52, type metadata accessor for PgQuery_RawStmt);
        goto LABEL_33;
      }
      if (v62 == v17)
        goto LABEL_38;
      v37 = *(v34 - 1);
      v36 = *v34;
      v38 = v51;
      v39 = (_QWORD *)(v51 + *(int *)(v35 + 48));
      outlined init with take of PgQuery_OidList(v52, v51, type metadata accessor for PgQuery_RawStmt);
      *v39 = v37;
      v39[1] = v36;
      v40 = v50;
      outlined init with take of (key: String, value: StorableValue)(v38, v50, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      v41 = (uint64_t *)(v40 + *(int *)(v35 + 48));
      v42 = *v41;
      v43 = v41[1];
      swift_bridgeObjectRetain();
      v44 = v42;
      v45 = v63;
      v58(v64, v40, v44, v43);
      outlined destroy of (key: String, value: StorableValue)(v40, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      v63 = v45;
      if (v45)
      {
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return swift_release();
      }
      v46 = v65;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v46 + 16) + 1, 1);
        v46 = v65;
      }
      v48 = *(_QWORD *)(v46 + 16);
      v47 = *(_QWORD *)(v46 + 24);
      if (v48 >= v47 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v47 > 1), v48 + 1, 1);
        v46 = v65;
      }
      ++v17;
      *(_QWORD *)(v46 + 16) = v48 + 1;
      result = (uint64_t)memcpy((void *)(v46 + 368 * v48 + 32), v64, 0x170uLL);
      v34 += 2;
      v21 = v61;
      a1 = v56;
      if (v61 == v17)
        goto LABEL_33;
    }
  }
  __break(1u);
LABEL_38:
  __break(1u);
  return result;
}

void parse(sql:catalog:)(unint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *deparse_protobuf;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  id v46;
  id v47;
  void *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  int **v61;
  uint64_t v62;
  int *v63;
  int v64;
  int v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _BYTE *v87;
  __int128 v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  char *v104;
  unsigned __int8 *v105;
  _QWORD *v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t ScanResult;
  char *v116;
  char *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  char *v121;
  uint64_t ParseResult;
  unint64_t v123;
  char *v124;
  __int128 v125;
  __int128 v126;
  uint64_t v127;
  uint64_t v128;

  v6 = type metadata accessor for CharacterSet();
  v118 = *(_QWORD *)(v6 - 8);
  v119 = v6;
  MEMORY[0x1E0C80A78](v6);
  v117 = (char *)&v99 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  MEMORY[0x1E0C80A78](ScanResult);
  v116 = (char *)&v99 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = type metadata accessor for BinaryDecodingOptions();
  v10 = MEMORY[0x1E0C80A78](v9);
  v114 = (char *)&v99 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v10);
  v121 = (char *)&v99 - v12;
  ParseResult = type metadata accessor for PgQuery_ParseResult(0);
  MEMORY[0x1E0C80A78](ParseResult);
  v14 = (char *)&v99 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = type metadata accessor for SQLParseResult(0);
  v16 = MEMORY[0x1E0C80A78](v15);
  v18 = (char *)&v99 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v16);
  v21 = (char *)&v99 - v20;
  v113 = *a3;
  v22 = &v18[*(int *)(v19 + 28)];
  *(_QWORD *)v22 = a1;
  *((_QWORD *)v22 + 1) = a2;
  v123 = a1;
  v124 = v22;
  v23 = String.utf8CString.getter() + 32;
  v128 = a2;
  swift_bridgeObjectRetain_n();
  pg_query_parse_protobuf(v23, (uint64_t)&v125);
  v24 = v125;
  v25 = (unsigned __int8 *)*((_QWORD *)&v125 + 1);
  v26 = v126;
  swift_release();
  if (*((_QWORD *)&v26 + 1))
  {
    if (**((_QWORD **)&v26 + 1))
    {
      v27 = String.init(cString:)();
      v29 = v28;
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      v30 = v128;
      *(_QWORD *)v31 = v123;
      *(_QWORD *)(v31 + 8) = v30;
      *(_QWORD *)(v31 + 16) = v27;
      *(_QWORD *)(v31 + 24) = v29;
      *(_BYTE *)(v31 + 32) = 0;
      swift_willThrow();
LABEL_31:
      swift_bridgeObjectRelease();
      return;
    }
    goto LABEL_44;
  }
  v112 = v24;
  v108 = v26;
  v109 = v21;
  v110 = v15;
  v111 = v18;
  if (!v25)
  {
LABEL_45:
    __break(1u);
LABEL_46:
    __break(1u);
LABEL_47:
    __break(1u);
    goto LABEL_48;
  }
  v32 = v112;
  v33 = specialized Data.init(bytes:count:)(v25, v112);
  v35 = v34;
  v127 = 0;
  v125 = 0u;
  v126 = 0u;
  outlined copy of Data._Representation(v33, v34);
  BinaryDecodingOptions.init()();
  lazy protocol witness table accessor for type PgQuery_ScanToken and conformance PgQuery_ScanToken(&lazy protocol witness table cache variable for type PgQuery_ParseResult and conformance PgQuery_ParseResult, type metadata accessor for PgQuery_ParseResult, (uint64_t)&protocol conformance descriptor for PgQuery_ParseResult);
  v36 = v120;
  Message.init(serializedData:extensions:partial:options:)();
  if (v36)
  {
    swift_bridgeObjectRelease();
    outlined consume of Data._Representation(v33, v35);
    goto LABEL_31;
  }
  v37 = (uint64_t)v111;
  outlined init with take of PgQuery_OidList((uint64_t)v14, (uint64_t)v111, type metadata accessor for PgQuery_ParseResult);
  deparse_protobuf = pg_query_deparse_protobuf(v32, v25);
  if (v39)
  {
    if (!*v39)
    {
LABEL_48:
      __break(1u);
      goto LABEL_49;
    }
    v40 = String.init(cString:)();
    v42 = v41;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    v43 = v128;
    *(_QWORD *)v44 = v123;
    *(_QWORD *)(v44 + 8) = v43;
    *(_QWORD *)(v44 + 16) = v40;
    *(_QWORD *)(v44 + 24) = v42;
    *(_BYTE *)(v44 + 32) = 0;
    swift_willThrow();
LABEL_30:
    outlined consume of Data._Representation(v33, v35);
    outlined destroy of PgQuery_Alias(v37, type metadata accessor for PgQuery_ParseResult);
    goto LABEL_31;
  }
  v45 = deparse_protobuf;
  if (!deparse_protobuf)
  {
LABEL_49:
    __break(1u);
    goto LABEL_50;
  }
  v105 = v25;
  v107 = v35;
  v46 = objc_allocWithZone(MEMORY[0x1E0CB3940]);
  v104 = v45;
  v47 = objc_msgSend(v46, sel_initWithCString_encoding_, v45, 4);
  if (!v47)
  {
LABEL_50:
    __break(1u);
    goto LABEL_51;
  }
  v48 = v47;
  v49 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  v51 = v50;

  v52 = String.utf8CString.getter();
  pg_query_split_with_parser((const char *)(v52 + 32), (uint64_t)&v125);
  v106 = (_QWORD *)v125;
  v53 = DWORD2(v125);
  v54 = v126;
  swift_release();
  if (*((_QWORD *)&v54 + 1))
  {
    swift_bridgeObjectRelease();
    if (!**((_QWORD **)&v54 + 1))
    {
LABEL_51:
      __break(1u);
      goto LABEL_52;
    }
    v55 = String.init(cString:)();
    v57 = v56;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    v58 = v128;
    *(_QWORD *)v59 = v123;
    *(_QWORD *)(v59 + 8) = v58;
    *(_QWORD *)(v59 + 16) = v55;
    *(_QWORD *)(v59 + 24) = v57;
    *(_BYTE *)(v59 + 32) = 0;
    swift_willThrow();
    v35 = v107;
    v37 = (uint64_t)v111;
    goto LABEL_30;
  }
  v120 = v49;
  v121 = v51;
  v103 = v54;
  v37 = (uint64_t)v111;
  if (*(_QWORD *)(*((_QWORD *)v111 + 1) + 16) != (int)v53)
  {
    swift_bridgeObjectRelease();
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    v81 = v128;
    *(_QWORD *)v82 = v123;
    *(_QWORD *)(v82 + 8) = v81;
    *(_QWORD *)(v82 + 16) = 0xD000000000000042;
    *(_QWORD *)(v82 + 24) = 0x800000018DCD1440;
    *(_BYTE *)(v82 + 32) = 0;
    swift_willThrow();
    v35 = v107;
    goto LABEL_30;
  }
  if ((v53 & 0x80000000) != 0)
  {
LABEL_43:
    __break(1u);
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  v101 = 0;
  v100 = 0;
  v102 = v33;
  v60 = v106;
  v99 = v53;
  if ((_DWORD)v53)
  {
    ParseResult = MEMORY[0x1E0DEE9D8];
    v61 = (int **)v106;
    v62 = v53;
    while (v60)
    {
      v63 = *v61;
      if (!*v61)
        goto LABEL_47;
      v64 = v63[1];
      v65 = *v63;
      v66 = String.index(_:offsetBy:)();
      if (__OFADD__(v65, v64))
      {
        __break(1u);
LABEL_42:
        __break(1u);
        goto LABEL_43;
      }
      if ((unint64_t)String.index(_:offsetBy:)() >> 14 < v66 >> 14)
        goto LABEL_42;
      v67 = String.subscript.getter();
      v68 = MEMORY[0x193FEC5A0](v67);
      v70 = v69;
      swift_bridgeObjectRelease();
      *(_QWORD *)&v125 = v68;
      *((_QWORD *)&v125 + 1) = v70;
      v71 = v117;
      static CharacterSet.whitespacesAndNewlines.getter();
      lazy protocol witness table accessor for type String and conformance String();
      v72 = StringProtocol.trimmingCharacters(in:)();
      v74 = v73;
      (*(void (**)(char *, uint64_t))(v118 + 8))(v71, v119);
      swift_bridgeObjectRelease();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(ParseResult + 16) + 1, 1, ParseResult);
        ParseResult = v79;
      }
      v76 = *(_QWORD *)(ParseResult + 16);
      v75 = *(_QWORD *)(ParseResult + 24);
      if (v76 >= v75 >> 1)
      {
        specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v75 > 1, v76 + 1, 1, ParseResult);
        ParseResult = v80;
      }
      v77 = ParseResult;
      *(_QWORD *)(ParseResult + 16) = v76 + 1;
      v78 = v77 + 16 * v76;
      *(_QWORD *)(v78 + 32) = v72;
      *(_QWORD *)(v78 + 40) = v74;
      ++v61;
      if (!--v62)
        goto LABEL_33;
    }
    goto LABEL_46;
  }
  ParseResult = MEMORY[0x1E0DEE9D8];
LABEL_33:
  swift_bridgeObjectRelease();
  v83 = (uint64_t)v111;
  *(_QWORD *)&v111[*(int *)(v110 + 24)] = ParseResult;
  v84 = v128;
  v85 = String.utf8CString.getter() + 32;
  swift_bridgeObjectRetain();
  pg_query_scan(v85);
  v86 = v125;
  v87 = (_BYTE *)*((_QWORD *)&v125 + 1);
  v88 = v126;
  swift_release();
  if (*((_QWORD *)&v88 + 1))
  {
    if (!**((_QWORD **)&v88 + 1))
    {
LABEL_52:
      __break(1u);
      goto LABEL_53;
    }
    swift_bridgeObjectRelease();
    v89 = String.init(cString:)();
    v91 = v90;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_QWORD *)v92 = v123;
    *(_QWORD *)(v92 + 8) = v84;
    *(_QWORD *)(v92 + 16) = v89;
    *(_QWORD *)(v92 + 24) = v91;
    *(_BYTE *)(v92 + 32) = 0;
    swift_willThrow();
    outlined consume of Data._Representation(v102, v107);
LABEL_39:
    outlined destroy of PgQuery_Alias(v83, type metadata accessor for PgQuery_ParseResult);
    swift_bridgeObjectRelease();
    goto LABEL_31;
  }
  v123 = v88;
  swift_bridgeObjectRelease();
  if (v87)
  {
    swift_bridgeObjectRelease();
    v93 = specialized Data.init(bytes:count:)(v87, v86);
    v95 = v94;
    v127 = 0;
    v125 = 0u;
    v126 = 0u;
    outlined copy of Data._Representation(v93, v94);
    BinaryDecodingOptions.init()();
    lazy protocol witness table accessor for type PgQuery_ScanToken and conformance PgQuery_ScanToken(&lazy protocol witness table cache variable for type PgQuery_ScanResult and conformance PgQuery_ScanResult, type metadata accessor for PgQuery_ScanResult, (uint64_t)&protocol conformance descriptor for PgQuery_ScanResult);
    v96 = (uint64_t)v116;
    v97 = v101;
    Message.init(serializedData:extensions:partial:options:)();
    if (!v97)
    {
      outlined init with take of PgQuery_OidList(v96, v83 + *(int *)(v110 + 20), type metadata accessor for PgQuery_ScanResult);
      LODWORD(v125) = v86;
      *((_QWORD *)&v125 + 1) = v87;
      v126 = v123;
      pg_query_free_scan_result((uint64_t)&v125);
      *(_QWORD *)&v125 = v60;
      DWORD2(v125) = v99;
      v126 = v103;
      pg_query_free_split_result((uint64_t)&v125);
      pg_query_free_deparse_result(v104, v100);
      LODWORD(v125) = v112;
      *((_QWORD *)&v125 + 1) = v105;
      v126 = v108;
      pg_query_free_protobuf_parse_result((uint64_t)&v125);
      outlined consume of Data._Representation(v102, v107);
      outlined consume of Data._Representation(v93, v95);
      v98 = (uint64_t)v109;
      outlined init with take of PgQuery_OidList(v83, (uint64_t)v109, type metadata accessor for SQLParseResult);
      *(_QWORD *)&v125 = v113;
      SQLParseResult.plans(with:)((uint64_t *)&v125);
      outlined destroy of PgQuery_Alias(v98, type metadata accessor for SQLParseResult);
      return;
    }
    outlined consume of Data._Representation(v102, v107);
    outlined consume of Data._Representation(v93, v95);
    goto LABEL_39;
  }
LABEL_53:
  __break(1u);
}

_QWORD *specialized ContiguousArray.reserveCapacity(_:)(int64_t a1)
{
  uint64_t *v1;
  uint64_t v3;
  _QWORD *result;
  int64_t v5;

  v3 = *v1;
  result = (_QWORD *)swift_isUniquelyReferenced_nonNull_native();
  *v1 = v3;
  if (!(_DWORD)result || a1 > *(_QWORD *)(v3 + 24) >> 1)
  {
    if (*(_QWORD *)(v3 + 16) <= a1)
      v5 = a1;
    else
      v5 = *(_QWORD *)(v3 + 16);
    return specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(result, v5, 0);
  }
  return result;
}

uint64_t specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(uint64_t a1, char a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t result;
  int64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  int64_t v21;
  _QWORD *v22;
  unint64_t v23;
  int64_t v24;
  char v25;
  unint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  int64_t v35;
  uint64_t v36;
  char v37;

  v3 = v2;
  v5 = *v2;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Int>);
  v37 = a2;
  v6 = static _DictionaryStorage.resize(original:capacity:move:)();
  v7 = v6;
  if (!*(_QWORD *)(v5 + 16))
    goto LABEL_40;
  v8 = 1 << *(_BYTE *)(v5 + 32);
  v36 = v5 + 64;
  if (v8 < 64)
    v9 = ~(-1 << v8);
  else
    v9 = -1;
  v10 = v9 & *(_QWORD *)(v5 + 64);
  v34 = v2;
  v35 = (unint64_t)(v8 + 63) >> 6;
  v11 = v6 + 64;
  result = swift_retain();
  v13 = 0;
  while (1)
  {
    if (v10)
    {
      v19 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      v20 = v19 | (v13 << 6);
      goto LABEL_31;
    }
    v21 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v21 >= v35)
      break;
    v22 = (_QWORD *)(v5 + 64);
    v23 = *(_QWORD *)(v36 + 8 * v21);
    ++v13;
    if (!v23)
    {
      v13 = v21 + 1;
      if (v21 + 1 >= v35)
        goto LABEL_33;
      v23 = *(_QWORD *)(v36 + 8 * v13);
      if (!v23)
      {
        v24 = v21 + 2;
        if (v24 >= v35)
        {
LABEL_33:
          swift_release();
          v3 = v34;
          if ((v37 & 1) == 0)
            goto LABEL_40;
          goto LABEL_36;
        }
        v23 = *(_QWORD *)(v36 + 8 * v24);
        if (!v23)
        {
          while (1)
          {
            v13 = v24 + 1;
            if (__OFADD__(v24, 1))
              goto LABEL_42;
            if (v13 >= v35)
              goto LABEL_33;
            v23 = *(_QWORD *)(v36 + 8 * v13);
            ++v24;
            if (v23)
              goto LABEL_30;
          }
        }
        v13 = v24;
      }
    }
LABEL_30:
    v10 = (v23 - 1) & v23;
    v20 = __clz(__rbit64(v23)) + (v13 << 6);
LABEL_31:
    v29 = (uint64_t *)(*(_QWORD *)(v5 + 48) + 16 * v20);
    v31 = *v29;
    v30 = v29[1];
    v32 = *(_QWORD *)(*(_QWORD *)(v5 + 56) + 8 * v20);
    if ((v37 & 1) == 0)
      swift_bridgeObjectRetain();
    Hasher.init(_seed:)();
    String.hash(into:)();
    result = Hasher._finalize()();
    v14 = -1 << *(_BYTE *)(v7 + 32);
    v15 = result & ~v14;
    v16 = v15 >> 6;
    if (((-1 << v15) & ~*(_QWORD *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      v17 = __clz(__rbit64((-1 << v15) & ~*(_QWORD *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      v25 = 0;
      v26 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        v27 = v16 == v26;
        if (v16 == v26)
          v16 = 0;
        v25 |= v27;
        v28 = *(_QWORD *)(v11 + 8 * v16);
      }
      while (v28 == -1);
      v17 = __clz(__rbit64(~v28)) + (v16 << 6);
    }
    *(_QWORD *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    v18 = (_QWORD *)(*(_QWORD *)(v7 + 48) + 16 * v17);
    *v18 = v31;
    v18[1] = v30;
    *(_QWORD *)(*(_QWORD *)(v7 + 56) + 8 * v17) = v32;
    ++*(_QWORD *)(v7 + 16);
  }
  swift_release();
  v3 = v34;
  v22 = (_QWORD *)(v5 + 64);
  if ((v37 & 1) == 0)
    goto LABEL_40;
LABEL_36:
  v33 = 1 << *(_BYTE *)(v5 + 32);
  if (v33 >= 64)
    bzero(v22, ((unint64_t)(v33 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  else
    *v22 = -1 << v33;
  *(_QWORD *)(v5 + 16) = 0;
LABEL_40:
  result = swift_release();
  *v3 = v7;
  return result;
}

{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t result;
  int64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int64_t v22;
  _QWORD *v23;
  unint64_t v24;
  int64_t v25;
  char v26;
  unint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  int64_t v37;
  uint64_t v38;
  char v39;
  __int128 v40;

  v3 = v2;
  v5 = *v2;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Schema>);
  v39 = a2;
  v6 = static _DictionaryStorage.resize(original:capacity:move:)();
  v7 = v6;
  if (!*(_QWORD *)(v5 + 16))
    goto LABEL_40;
  v8 = 1 << *(_BYTE *)(v5 + 32);
  v38 = v5 + 64;
  if (v8 < 64)
    v9 = ~(-1 << v8);
  else
    v9 = -1;
  v10 = v9 & *(_QWORD *)(v5 + 64);
  v36 = v2;
  v37 = (unint64_t)(v8 + 63) >> 6;
  v11 = v6 + 64;
  result = swift_retain();
  v13 = 0;
  while (1)
  {
    if (v10)
    {
      v20 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      v21 = v20 | (v13 << 6);
      goto LABEL_31;
    }
    v22 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v22 >= v37)
      break;
    v23 = (_QWORD *)(v5 + 64);
    v24 = *(_QWORD *)(v38 + 8 * v22);
    ++v13;
    if (!v24)
    {
      v13 = v22 + 1;
      if (v22 + 1 >= v37)
        goto LABEL_33;
      v24 = *(_QWORD *)(v38 + 8 * v13);
      if (!v24)
      {
        v25 = v22 + 2;
        if (v25 >= v37)
        {
LABEL_33:
          swift_release();
          v3 = v36;
          if ((v39 & 1) == 0)
            goto LABEL_40;
          goto LABEL_36;
        }
        v24 = *(_QWORD *)(v38 + 8 * v25);
        if (!v24)
        {
          while (1)
          {
            v13 = v25 + 1;
            if (__OFADD__(v25, 1))
              goto LABEL_42;
            if (v13 >= v37)
              goto LABEL_33;
            v24 = *(_QWORD *)(v38 + 8 * v13);
            ++v25;
            if (v24)
              goto LABEL_30;
          }
        }
        v13 = v25;
      }
    }
LABEL_30:
    v10 = (v24 - 1) & v24;
    v21 = __clz(__rbit64(v24)) + (v13 << 6);
LABEL_31:
    v30 = (uint64_t *)(*(_QWORD *)(v5 + 48) + 16 * v21);
    v32 = *v30;
    v31 = v30[1];
    v33 = *(_QWORD *)(v5 + 56) + 24 * v21;
    v34 = *(_QWORD *)v33;
    v40 = *(_OWORD *)(v33 + 8);
    if ((v39 & 1) == 0)
    {
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    Hasher.init(_seed:)();
    String.hash(into:)();
    result = Hasher._finalize()();
    v14 = -1 << *(_BYTE *)(v7 + 32);
    v15 = result & ~v14;
    v16 = v15 >> 6;
    if (((-1 << v15) & ~*(_QWORD *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      v17 = __clz(__rbit64((-1 << v15) & ~*(_QWORD *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      v26 = 0;
      v27 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v27 && (v26 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        v28 = v16 == v27;
        if (v16 == v27)
          v16 = 0;
        v26 |= v28;
        v29 = *(_QWORD *)(v11 + 8 * v16);
      }
      while (v29 == -1);
      v17 = __clz(__rbit64(~v29)) + (v16 << 6);
    }
    *(_QWORD *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    v18 = (_QWORD *)(*(_QWORD *)(v7 + 48) + 16 * v17);
    *v18 = v32;
    v18[1] = v31;
    v19 = *(_QWORD *)(v7 + 56) + 24 * v17;
    *(_QWORD *)v19 = v34;
    *(_OWORD *)(v19 + 8) = v40;
    ++*(_QWORD *)(v7 + 16);
  }
  swift_release();
  v3 = v36;
  v23 = (_QWORD *)(v5 + 64);
  if ((v39 & 1) == 0)
    goto LABEL_40;
LABEL_36:
  v35 = 1 << *(_BYTE *)(v5 + 32);
  if (v35 >= 64)
    bzero(v23, ((unint64_t)(v35 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  else
    *v23 = -1 << v35;
  *(_QWORD *)(v5 + 16) = 0;
LABEL_40:
  result = swift_release();
  *v3 = v7;
  return result;
}

_QWORD *specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)(_QWORD *result)
{
  uint64_t v1;
  unint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)v1 + 24);
  if ((uint64_t)result + 1 > (uint64_t)(v2 >> 1))
    return specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((_QWORD *)(v2 > 1), (int64_t)result + 1, 1);
  return result;
}

_QWORD *specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(_QWORD *a1, int64_t a2, char a3)
{
  _QWORD **v3;
  _QWORD *result;

  result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *v3 = result;
  return result;
}

{
  _QWORD **v3;
  _QWORD *result;

  result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *v3 = result;
  return result;
}

{
  _QWORD **v3;
  _QWORD *result;

  result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *v3 = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for DatabaseCatalog.CodingKeys, &unk_1E263A4A8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for DatabaseCatalog.CodingKeys, &unk_1E263A4A8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for DatabaseCatalog.CodingKeys, &unk_1E263A4A8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for DatabaseCatalog.CodingKeys, &unk_1E263A4A8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Schema and conformance Schema()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Schema and conformance Schema;
  if (!lazy protocol witness table cache variable for type Schema and conformance Schema)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Schema, &type metadata for Schema);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema and conformance Schema);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Schema and conformance Schema;
  if (!lazy protocol witness table cache variable for type Schema and conformance Schema)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Schema, &type metadata for Schema);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema and conformance Schema);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Schema.CodingKeys, &unk_1E263FBD0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Schema.CodingKeys, &unk_1E263FBD0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    result = MEMORY[0x193FED7A0]("}̡TԴ\r", &unk_1E263FBD0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for Schema.CodingKeys, &unk_1E263FBD0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for FromClause.CodingKeys, &unk_1E26372D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for FromClause.CodingKeys, &unk_1E26372D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for FromClause.CodingKeys, &unk_1E26372D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for FromClause.CodingKeys, &unk_1E26372D0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for ResultColumn.CodingKeys, &unk_1E26381B8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for ResultColumn.CodingKeys, &unk_1E26381B8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for ResultColumn.CodingKeys, &unk_1E26381B8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for ResultColumn.CodingKeys, &unk_1E26381B8);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SelectCore.CodingKeys, &unk_1E26373E0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SelectCore.CodingKeys, &unk_1E26373E0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SelectCore.CodingKeys, &unk_1E26373E0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SelectCore.CodingKeys, &unk_1E26373E0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type FromClause and conformance FromClause()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type FromClause and conformance FromClause;
  if (!lazy protocol witness table cache variable for type FromClause and conformance FromClause)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for FromClause, &type metadata for FromClause);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause and conformance FromClause);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type ResultColumn and conformance ResultColumn()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type ResultColumn and conformance ResultColumn;
  if (!lazy protocol witness table cache variable for type ResultColumn and conformance ResultColumn)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for ResultColumn, &type metadata for ResultColumn);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn and conformance ResultColumn);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for MaterializedView.CodingKeys, &unk_1E263AB20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for MaterializedView.CodingKeys, &unk_1E263AB20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for MaterializedView.CodingKeys, &unk_1E263AB20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for MaterializedView.CodingKeys, &unk_1E263AB20);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SelectCore and conformance SelectCore()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SelectCore and conformance SelectCore;
  if (!lazy protocol witness table cache variable for type SelectCore and conformance SelectCore)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SelectCore, &type metadata for SelectCore);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore and conformance SelectCore);
  }
  return result;
}

uint64_t outlined init with copy of LogicalPlanType(uint64_t a1, uint64_t a2)
{
  initializeWithCopy for LogicalPlanType(a2, a1);
  return a2;
}

unint64_t lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlan.CodingKeys, &type metadata for LogicalPlan.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlan.CodingKeys, &type metadata for LogicalPlan.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlan.CodingKeys, &type metadata for LogicalPlan.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlan.CodingKeys, &type metadata for LogicalPlan.CodingKeys);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

_QWORD *outlined destroy of SelectCore(_QWORD *a1)
{
  destroy for SelectCore(a1);
  return a1;
}

unint64_t lazy protocol witness table accessor for type MaterializedView and conformance MaterializedView()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type MaterializedView and conformance MaterializedView;
  if (!lazy protocol witness table cache variable for type MaterializedView and conformance MaterializedView)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for MaterializedView, &type metadata for MaterializedView);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView and conformance MaterializedView);
  }
  return result;
}

_QWORD *outlined destroy of MaterializedView(_QWORD *a1)
{
  destroy for MaterializedView(a1);
  return a1;
}

unint64_t lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.CodingKeys, &unk_1E263A560);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.CodingKeys, &unk_1E263A560);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.CodingKeys, &unk_1E263A560);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    result = MEMORY[0x193FED7A0]("\rơTԭ\r", &unk_1E263A560);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.MaterializedViewCodingKeys, &unk_1E263A680);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.MaterializedViewCodingKeys, &unk_1E263A680);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.MaterializedViewCodingKeys, &unk_1E263A680);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.MaterializedViewCodingKeys, &unk_1E263A680);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.SelectCoreCodingKeys, &unk_1E263A5F0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.SelectCoreCodingKeys, &unk_1E263A5F0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    result = MEMORY[0x193FED7A0]("uǡTخ\r", &unk_1E263A5F0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for LogicalPlanType.SelectCoreCodingKeys, &unk_1E263A5F0);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

uint64_t type metadata accessor for SQLParseResult(uint64_t a1)
{
  return type metadata accessor for PgQuery_Node._StorageClass(a1, (uint64_t *)&type metadata singleton initialization cache for SQLParseResult);
}

char *specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(char *result, int64_t a2, char a3, char *a4)
{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<String>);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v12 = v11 - 32;
    if (v11 < 32)
      v12 = v11 - 17;
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * (v12 >> 4);
  }
  else
  {
    v10 = (char *)MEMORY[0x1E0DEE9D8];
  }
  v13 = v10 + 32;
  v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8])
      memmove(v13, v14, 16 * v8);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<SQLDataType>);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    v10 = (char *)MEMORY[0x1E0DEE9D8];
  }
  v12 = v10 + 32;
  v13 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v12 >= &v13[v8])
      memmove(v12, v13, v8);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    memcpy(v12, v13, v8);
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<ResultColumn>);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v12 = v11 - 32;
    if (v11 < 32)
      v12 = v11 + 95;
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * (v12 >> 7);
  }
  else
  {
    v10 = (char *)MEMORY[0x1E0DEE9D8];
  }
  v13 = v10 + 32;
  v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v13 >= &v14[128 * v8])
      memmove(v13, v14, v8 << 7);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = *((_QWORD *)a4 + 3);
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = *((_QWORD *)a4 + 2);
  if (v7 <= v8)
    v9 = *((_QWORD *)a4 + 2);
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<LogicalPlan>);
    v10 = (char *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    *((_QWORD *)v10 + 2) = v8;
    *((_QWORD *)v10 + 3) = 2 * ((uint64_t)(v11 - 32) / 368);
  }
  else
  {
    v10 = (char *)MEMORY[0x1E0DEE9D8];
  }
  v12 = v10 + 32;
  v13 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v12 >= &v13[368 * v8])
      memmove(v12, v13, 368 * v8);
    *((_QWORD *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

_QWORD *specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(_QWORD *result, int64_t a2, char a3, _QWORD *a4)
{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  size_t v11;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = a4[3];
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = a4[2];
  if (v7 <= v8)
    v9 = a4[2];
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<SQLExpressionNode>);
    v10 = (_QWORD *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v10[2] = v8;
    v10[3] = 2 * ((uint64_t)(v11 - 32) / 40);
  }
  else
  {
    v10 = (_QWORD *)MEMORY[0x1E0DEE9D8];
  }
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v10 + 4 >= &a4[5 * v8 + 4])
      memmove(v10 + 4, a4 + 4, 40 * v8);
    a4[2] = 0;
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for SQLExpressionNode);
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  size_t v11;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = a4[3];
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = a4[2];
  if (v7 <= v8)
    v9 = a4[2];
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Schema)>);
    v10 = (_QWORD *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v10[2] = v8;
    v10[3] = 2 * ((uint64_t)(v11 - 32) / 40);
  }
  else
  {
    v10 = (_QWORD *)MEMORY[0x1E0DEE9D8];
  }
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v10 + 4 >= &a4[5 * v8 + 4])
      memmove(v10 + 4, a4 + 4, 40 * v8);
    a4[2] = 0;
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for (String, Schema));
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int64_t v11;
  uint64_t v12;

  v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    v6 = a4[3];
    v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2)
        v7 = a2;
    }
  }
  else
  {
    v7 = a2;
  }
  v8 = a4[2];
  if (v7 <= v8)
    v9 = a4[2];
  else
    v9 = v7;
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<[AggregationFunction]>);
    v10 = (_QWORD *)swift_allocObject();
    v11 = _swift_stdlib_malloc_size(v10);
    v12 = v11 - 32;
    if (v11 < 32)
      v12 = v11 - 25;
    v10[2] = v8;
    v10[3] = 2 * (v12 >> 3);
  }
  else
  {
    v10 = (_QWORD *)MEMORY[0x1E0DEE9D8];
  }
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v10 + 4 >= &a4[v8 + 4])
      memmove(v10 + 4, a4 + 4, 8 * v8);
    a4[2] = 0;
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for [AggregationFunction]);
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

char *specialized Array._makeUniqueAndReserveCapacityIfNotUnique()()
{
  char **v0;
  char *v1;
  char *result;

  v1 = *v0;
  result = (char *)swift_isUniquelyReferenced_nonNull_native();
  *v0 = v1;
  if (!(_DWORD)result)
  {
    result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(result, *((_QWORD *)v1 + 2) + 1, 1, v1);
    *v0 = result;
  }
  return result;
}

char *specialized Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(uint64_t a1, char a2, uint64_t (*a3)(_QWORD *), uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  unint64_t v44;
  _QWORD v46[4];

  v46[3] = a4;
  if (a1 < 0)
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
  v11 = a5;
  v14 = swift_allocObject();
  *(_QWORD *)(v14 + 16) = MEMORY[0x1E0DEE9D8];
  v43 = swift_allocObject();
  *(_QWORD *)(v43 + 16) = 15;
  v15 = HIBYTE(a6) & 0xF;
  if (!a1 || ((a6 & 0x2000000000000000) != 0 ? (v16 = HIBYTE(a6) & 0xF) : (v16 = v11 & 0xFFFFFFFFFFFFLL), !v16))
  {
    if ((a6 & 0x2000000000000000) == 0)
      v15 = v11 & 0xFFFFFFFFFFFFLL;
    v30 = 7;
    if (((a6 >> 60) & ((v11 & 0x800000000000000) == 0)) != 0)
      v30 = 11;
    specialized appendSubsequence #1 <A>(end:) in Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(v30 | (v15 << 16), v43, a2 & 1, v14);
    swift_bridgeObjectRelease();
    v10 = *(char **)(v14 + 16);
    swift_bridgeObjectRetain();
    swift_release();
    goto LABEL_38;
  }
  v38 = a1;
  v39 = v14;
  v44 = 4 * v16;
  v10 = (char *)MEMORY[0x1E0DEE9D8];
  v9 = 15;
  v8 = 15;
  v17 = 15;
  while (1)
  {
    v46[0] = String.subscript.getter();
    v46[1] = v18;
    v19 = a3(v46);
    if (v7)
    {
      swift_release();
      swift_release();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return v10;
    }
    v6 = v19;
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      break;
    v9 = String.index(after:)();
LABEL_9:
    if (v44 == v9 >> 14)
      goto LABEL_29;
  }
  if (v17 >> 14 == v9 >> 14 && (a2 & 1) != 0)
  {
    v9 = String.index(after:)();
    *(_QWORD *)(v43 + 16) = v9;
    v8 = v9;
    v17 = v9;
    goto LABEL_9;
  }
  if (v9 >> 14 < v17 >> 14)
  {
    __break(1u);
    goto LABEL_41;
  }
  v20 = String.subscript.getter();
  v40 = v21;
  v41 = v20;
  v23 = v22;
  v25 = v24;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((_QWORD *)v10 + 2) + 1, 1, v10);
  v27 = *((_QWORD *)v10 + 2);
  v26 = *((_QWORD *)v10 + 3);
  v6 = v27 + 1;
  if (v27 >= v26 >> 1)
    v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v26 > 1), v27 + 1, 1, v10);
  *((_QWORD *)v10 + 2) = v6;
  v28 = &v10[32 * v27];
  *((_QWORD *)v28 + 4) = v41;
  *((_QWORD *)v28 + 5) = v23;
  *((_QWORD *)v28 + 6) = v25;
  *((_QWORD *)v28 + 7) = v40;
  *(_QWORD *)(v39 + 16) = v10;
  v29 = String.index(after:)();
  v9 = v29;
  *(_QWORD *)(v43 + 16) = v29;
  v8 = v29;
  if (*((_QWORD *)v10 + 2) != v38)
  {
    v17 = v29;
    goto LABEL_9;
  }
  v17 = v29;
LABEL_29:
  if (v44 == v17 >> 14 && (a2 & 1) != 0)
  {
    swift_bridgeObjectRelease();
    goto LABEL_37;
  }
  if (v44 >= v8 >> 14)
  {
    v6 = String.subscript.getter();
    v8 = v31;
    v9 = v32;
    v11 = v33;
    swift_bridgeObjectRelease();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      goto LABEL_43;
    goto LABEL_34;
  }
LABEL_42:
  __break(1u);
LABEL_43:
  v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((_QWORD *)v10 + 2) + 1, 1, v10);
LABEL_34:
  v35 = *((_QWORD *)v10 + 2);
  v34 = *((_QWORD *)v10 + 3);
  if (v35 >= v34 >> 1)
    v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v34 > 1), v35 + 1, 1, v10);
  *((_QWORD *)v10 + 2) = v35 + 1;
  v36 = &v10[32 * v35];
  *((_QWORD *)v36 + 4) = v6;
  *((_QWORD *)v36 + 5) = v8;
  *((_QWORD *)v36 + 6) = v9;
  *((_QWORD *)v36 + 7) = v11;
  *(_QWORD *)(v39 + 16) = v10;
LABEL_37:
  swift_bridgeObjectRetain();
  swift_release();
LABEL_38:
  swift_release();
  return v10;
}

uint64_t specialized appendSubsequence #1 <A>(end:) in Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(unint64_t a1, uint64_t a2, unsigned __int8 a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char isUniquelyReferenced_nonNull_native;
  unint64_t v16;
  unint64_t v17;
  char *v18;

  v10 = *(_QWORD *)(a2 + 16) >> 14;
  v11 = (v10 == a1 >> 14) & a3;
  if (v11 == 1)
    return v11 ^ 1u;
  if (a1 >> 14 < v10)
  {
    __break(1u);
    goto LABEL_9;
  }
  v4 = a4;
  v5 = String.subscript.getter();
  v6 = v12;
  v7 = v13;
  v8 = v14;
  v9 = *(char **)(v4 + 16);
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *(_QWORD *)(v4 + 16) = v9;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
LABEL_9:
    v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((_QWORD *)v9 + 2) + 1, 1, v9);
    *(_QWORD *)(v4 + 16) = v9;
  }
  v17 = *((_QWORD *)v9 + 2);
  v16 = *((_QWORD *)v9 + 3);
  if (v17 >= v16 >> 1)
  {
    v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v16 > 1), v17 + 1, 1, v9);
    *(_QWORD *)(v4 + 16) = v9;
  }
  *((_QWORD *)v9 + 2) = v17 + 1;
  v18 = &v9[32 * v17];
  *((_QWORD *)v18 + 4) = v5;
  *((_QWORD *)v18 + 5) = v6;
  *((_QWORD *)v18 + 6) = v7;
  *((_QWORD *)v18 + 7) = v8;
  return v11 ^ 1u;
}

uint64_t specialized Sequence.reduce<A>(into:_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  Swift::String v10;
  Swift::String v11;
  char v12;
  Swift::String v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;

  v18 = result;
  v3 = *(_QWORD *)(a2 + 16);
  if (!v3)
    return result;
  swift_bridgeObjectRetain();
  for (i = (uint64_t *)(a2 + 136); ; i += 16)
  {
    v7 = *i;
    if (*i)
      break;
LABEL_3:
    if (!--v3)
    {
      swift_bridgeObjectRelease();
      return v18;
    }
  }
  v8 = *(i - 1);
  v9 = v18;
  v10 = String.lowercased()();
  swift_bridgeObjectRetain();
  LOBYTE(v9) = specialized Set.contains(_:)(v10._countAndFlagsBits, (uint64_t)v10._object, v9);
  swift_bridgeObjectRelease();
  if ((v9 & 1) != 0)
  {
    v14 = 0x800000018DCD16F0;
    v15 = 0xD000000000000021;
    goto LABEL_11;
  }
  v11 = String.lowercased()();
  v12 = specialized Set.contains(_:)(v11._countAndFlagsBits, (uint64_t)v11._object, a3);
  swift_bridgeObjectRelease();
  if ((v12 & 1) == 0)
  {
    v13 = String.lowercased()();
    swift_bridgeObjectRelease();
    specialized Set._Variant.insert(_:)(&v17, v13._countAndFlagsBits, (unint64_t)v13._object);
    swift_bridgeObjectRelease();
    goto LABEL_3;
  }
  v15 = 0xD000000000000043;
  v14 = 0x800000018DCD16A0;
LABEL_11:
  lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
  swift_allocError();
  *(_QWORD *)v16 = v8;
  *(_QWORD *)(v16 + 8) = v7;
  *(_QWORD *)(v16 + 16) = v15;
  *(_QWORD *)(v16 + 24) = v14;
  *(_BYTE *)(v16 + 32) = 7;
  swift_willThrow();
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t specialized Schema.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 0x6D614E656C626174 && a2 == 0xE900000000000065;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x736E6D756C6F63 && a2 == 0xE700000000000000)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t specialized FromClause.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 0x73616D65686373 && a2 == 0xE700000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x800000018DCD1490)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

unint64_t specialized Array.replaceSubrange<A>(_:with:)(unint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t isUniquelyReferenced_nonNull_native;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;

  if ((result & 0x8000000000000000) != 0)
  {
    __break(1u);
    goto LABEL_23;
  }
  v5 = *v3;
  v6 = *(_QWORD *)(*v3 + 16);
  if (v6 < a2)
  {
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }
  v7 = result;
  v8 = a2 - result;
  if (__OFSUB__(a2, result))
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  v9 = *(_QWORD *)(a3 + 16);
  v10 = v9 - v8;
  if (__OFSUB__(v9, v8))
  {
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }
  v11 = v6 + v10;
  if (__OFADD__(v6, v10))
  {
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
LABEL_28:
    __break(1u);
    return result;
  }
  isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  if (!(_DWORD)isUniquelyReferenced_nonNull_native || v11 > *(_QWORD *)(v5 + 24) >> 1)
  {
    if (v6 <= v11)
      v13 = v6 + v10;
    else
      v13 = v6;
    specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(isUniquelyReferenced_nonNull_native, v13, 1, v5);
    v5 = v14;
  }
  v15 = v5 + 32 + 16 * v7;
  result = swift_arrayDestroy();
  if (!v10)
    goto LABEL_19;
  v16 = *(_QWORD *)(v5 + 16);
  v17 = __OFSUB__(v16, a2);
  v18 = v16 - a2;
  if (v17)
    goto LABEL_27;
  result = v15 + 16 * v9;
  v19 = (const void *)(v5 + 32 + 16 * a2);
  if ((const void *)result != v19 || result >= (unint64_t)v19 + 16 * v18)
    result = (unint64_t)memmove((void *)result, v19, 16 * v18);
  v20 = *(_QWORD *)(v5 + 16);
  v17 = __OFADD__(v20, v10);
  v21 = v20 + v10;
  if (v17)
    goto LABEL_28;
  *(_QWORD *)(v5 + 16) = v21;
LABEL_19:
  if (v9)
    result = swift_arrayInitWithCopy();
  *v3 = v5;
  return result;
}

uint64_t specialized ResultColumn.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 0x6973736572707865 && a2 == 0xEA00000000006E6FLL;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x7361696C61 && a2 == 0xE500000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x746E656D75636F64 && a2 == 0xED00006E6F697461)
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 2;
    else
      return 3;
  }
}

uint64_t specialized Sequence.forEach(_:)(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  Swift::String v8;
  uint64_t v9;
  Swift::Int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t i;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE v26[80];
  uint64_t v27;

  v2 = *(_QWORD *)(result + 16);
  if (v2)
  {
    v3 = a2;
    v4 = result + 32;
    v27 = a2 + 56;
    swift_bridgeObjectRetain();
    v5 = 0;
    v24 = v4;
    v25 = v2;
    do
    {
      v6 = (_QWORD *)(v4 + (v5 << 7));
      v7 = v6[13];
      outlined init with copy of ResultColumn((uint64_t)v6, (uint64_t)v26);
      if (!v7)
      {
        v8 = String.lowercased()();
        v9 = v3;
        if (*(_QWORD *)(v3 + 16))
        {
          Hasher.init(_seed:)();
          String.hash(into:)();
          v10 = Hasher._finalize()();
          v11 = -1 << *(_BYTE *)(v3 + 32);
          v12 = v10 & ~v11;
          if (((*(_QWORD *)(v27 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8)) >> v12) & 1) != 0)
          {
            v13 = *(_QWORD *)(v9 + 48);
            v14 = v13 + 16 * v12;
            v15 = *(_QWORD *)v14 == v8._countAndFlagsBits && *(void **)(v14 + 8) == v8._object;
            if (v15 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
            {
LABEL_21:
              swift_bridgeObjectRelease();
              outlined destroy of ResultColumn((uint64_t)v26);
              v21 = v6[10];
              v22 = v6[11];
              lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
              swift_allocError();
              *(_QWORD *)v23 = v21;
              *(_QWORD *)(v23 + 8) = v22;
              *(_QWORD *)(v23 + 16) = 0xD00000000000003DLL;
              *(_QWORD *)(v23 + 24) = 0x800000018DCD1660;
              *(_BYTE *)(v23 + 32) = 7;
              swift_bridgeObjectRetain();
              swift_willThrow();
              return swift_bridgeObjectRelease();
            }
            v16 = ~v11;
            for (i = v12 + 1; ; i = v18 + 1)
            {
              v18 = i & v16;
              if (((*(_QWORD *)(v27 + (((i & v16) >> 3) & 0xFFFFFFFFFFFFF8)) >> (i & v16)) & 1) == 0)
                break;
              v19 = v13 + 16 * v18;
              v20 = *(_QWORD *)v19 == v8._countAndFlagsBits && *(void **)(v19 + 8) == v8._object;
              if (v20 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
                goto LABEL_21;
            }
          }
        }
        swift_bridgeObjectRelease();
        v3 = v9;
        v4 = v24;
        v2 = v25;
      }
      ++v5;
      outlined destroy of ResultColumn((uint64_t)v26);
    }
    while (v5 != v2);
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t specialized Sequence.forEach(_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  Swift::String v7;
  Swift::String v8;
  char v9;
  Swift::String v10;
  char v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;

  v3 = *(_QWORD *)(result + 16);
  if (v3)
  {
    v6 = result + 32;
    swift_bridgeObjectRetain();
    while (1)
    {
      v7 = AggregationFunction.name()();
      v8 = String.lowercased()();
      v9 = specialized Set.contains(_:)(v8._countAndFlagsBits, (uint64_t)v8._object, a2);
      swift_bridgeObjectRelease();
      if ((v9 & 1) != 0)
      {
        v12 = 0xD000000000000051;
        v13 = 0x800000018DCD1600;
        goto LABEL_9;
      }
      v10 = String.lowercased()();
      v11 = specialized Set.contains(_:)(v10._countAndFlagsBits, (uint64_t)v10._object, a3);
      swift_bridgeObjectRelease();
      if ((v11 & 1) != 0)
        break;
      swift_bridgeObjectRelease();
      v6 += 200;
      if (!--v3)
        return swift_bridgeObjectRelease();
    }
    v13 = 0x800000018DCD15A0;
    v12 = 0xD000000000000050;
LABEL_9:
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(Swift::String *)v14 = v7;
    *(_QWORD *)(v14 + 16) = v12;
    *(_QWORD *)(v14 + 24) = v13;
    *(_BYTE *)(v14 + 32) = 7;
    swift_willThrow();
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t specialized SelectCore.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 1836020326 && a2 == 0xE400000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6572656877 && a2 == 0xE500000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x794270756F7267 && a2 == 0xE700000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x676E69766168 && a2 == 0xE600000000000000
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 0x7463656C6573 && a2 == 0xE600000000000000)
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 4;
    else
      return 5;
  }
}

uint64_t specialized MaterializedView.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 1701667182 && a2 == 0xE400000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x7463656C6573 && a2 == 0xE600000000000000)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t specialized LogicalPlan.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 7106931 && a2 == 0xE300000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x746E656D75636F64 && a2 == 0xED00006E6F697461
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x800000018DCC39A0
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x6F437463656C6573 && a2 == 0xEA00000000006572)
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 3;
    else
      return 4;
  }
}

uint64_t specialized LogicalPlanType.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  char v6;

  v2 = a1 == 0x6F437463656C6573 && a2 == 0xEA00000000006572;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x800000018DCC39A0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if ((v6 & 1) != 0)
      return 1;
    else
      return 2;
  }
}

uint64_t specialized Data.InlineData.init(_:)(_BYTE *__src, _BYTE *a2)
{
  unint64_t v2;
  _BYTE __dst[14];
  char v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (__src)
    v2 = a2 - __src;
  else
    v2 = 0;
  if ((v2 & 0x8000000000000000) != 0)
  {
    __break(1u);
LABEL_11:
    __break(1u);
  }
  if (v2 > 0xFF)
    goto LABEL_11;
  memset(__dst, 0, sizeof(__dst));
  v5 = v2;
  if (__src && a2 != __src)
    memcpy(__dst, __src, a2 - __src);
  return *(_QWORD *)__dst;
}

uint64_t specialized Data.init(bytes:count:)(_BYTE *__src, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  if (a2 <= 14)
    return specialized Data.InlineData.init(_:)(__src, &__src[a2]);
  type metadata accessor for __DataStorage();
  swift_allocObject();
  __DataStorage.init(bytes:length:)();
  if ((unint64_t)a2 < 0x7FFFFFFF)
    return a2 << 32;
  type metadata accessor for Data.RangeReference();
  result = swift_allocObject();
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = a2;
  return result;
}

unint64_t lazy protocol witness table accessor for type SQLRawDataType and conformance SQLRawDataType()
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type SQLRawDataType and conformance SQLRawDataType;
  if (!lazy protocol witness table cache variable for type SQLRawDataType and conformance SQLRawDataType)
  {
    result = MEMORY[0x193FED7A0](&protocol conformance descriptor for SQLRawDataType, &type metadata for SQLRawDataType);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLRawDataType and conformance SQLRawDataType);
  }
  return result;
}

uint64_t outlined copy of SQLParserError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  uint64_t result;

  if (a5 <= 8u)
  {
    if (((1 << a5) & 0x16E) == 0)
      swift_bridgeObjectRetain();
    return swift_bridgeObjectRetain();
  }
  return result;
}

uint64_t destroy for SQLParserError(uint64_t a1)
{
  return outlined consume of SQLParserError(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_BYTE *)(a1 + 32));
}

uint64_t outlined consume of SQLParserError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  uint64_t result;

  if (a5 <= 8u)
  {
    if (((1 << a5) & 0x16E) == 0)
      swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t initializeWithCopy for SQLParserError(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;

  v3 = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_BYTE *)(a2 + 32);
  outlined copy of SQLParserError(*(_QWORD *)a2, v4, v5, v6, v7);
  *(_QWORD *)a1 = v3;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 24) = v6;
  *(_BYTE *)(a1 + 32) = v7;
  return a1;
}

uint64_t assignWithCopy for SQLParserError(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;

  v3 = *(_QWORD *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_BYTE *)(a2 + 32);
  outlined copy of SQLParserError(*(_QWORD *)a2, v4, v5, v6, v7);
  v8 = *(_QWORD *)a1;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)a1 = v3;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 24) = v6;
  v12 = *(_BYTE *)(a1 + 32);
  *(_BYTE *)(a1 + 32) = v7;
  outlined consume of SQLParserError(v8, v9, v10, v11, v12);
  return a1;
}

uint64_t assignWithTake for SQLParserError(uint64_t a1, uint64_t a2)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  unsigned __int8 v9;

  v3 = *(_BYTE *)(a2 + 32);
  v4 = *(_QWORD *)a1;
  v6 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v8;
  v9 = *(_BYTE *)(a1 + 32);
  *(_BYTE *)(a1 + 32) = v3;
  outlined consume of SQLParserError(v4, v6, v5, v7, v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLParserError(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xF7 && *(_BYTE *)(a1 + 33))
    return (*(_DWORD *)a1 + 247);
  v3 = *(unsigned __int8 *)(a1 + 32);
  if (v3 <= 9)
    v4 = -1;
  else
    v4 = v3 ^ 0xFF;
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLParserError(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xF6)
  {
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_BYTE *)(result + 32) = 0;
    *(_QWORD *)result = a2 - 247;
    *(_QWORD *)(result + 8) = 0;
    if (a3 >= 0xF7)
      *(_BYTE *)(result + 33) = 1;
  }
  else
  {
    if (a3 >= 0xF7)
      *(_BYTE *)(result + 33) = 0;
    if (a2)
      *(_BYTE *)(result + 32) = -(char)a2;
  }
  return result;
}

uint64_t getEnumTag for SQLParserError(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 32) <= 8u)
    return *(unsigned __int8 *)(a1 + 32);
  else
    return (*(_DWORD *)a1 + 9);
}

uint64_t destructiveInjectEnumTag for SQLParserError(uint64_t result, unsigned int a2)
{
  if (a2 >= 9)
  {
    *(_QWORD *)result = a2 - 9;
    *(_QWORD *)(result + 8) = 0;
    LOBYTE(a2) = 9;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
  }
  *(_BYTE *)(result + 32) = a2;
  return result;
}

ValueMetadata *type metadata accessor for SQLParserError()
{
  return &type metadata for SQLParserError;
}

ValueMetadata *type metadata accessor for DatabaseCatalog()
{
  return &type metadata for DatabaseCatalog;
}

_QWORD *assignWithCopy for Schema(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[2] = a2[2];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for Schema(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = *(_QWORD *)a2;
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithCopy for FromClause(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v4 = (_OWORD *)(a1 + 8);
  v5 = (_OWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 32);
  if (*(_QWORD *)(a1 + 32))
  {
    if (v6)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 8), (uint64_t *)(a2 + 8));
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 8);
      v7 = *(_OWORD *)(a2 + 24);
      *v4 = *v5;
      *(_OWORD *)(a1 + 24) = v7;
      v8 = *(_OWORD *)(a2 + 88);
      v10 = *(_OWORD *)(a2 + 40);
      v9 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = v8;
      *(_OWORD *)(a1 + 40) = v10;
      *(_OWORD *)(a1 + 56) = v9;
    }
  }
  else if (v6)
  {
    *(_QWORD *)(a1 + 32) = v6;
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
    (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1 + 8, a2 + 8);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v11 = *(_OWORD *)(a2 + 24);
    *v4 = *v5;
    *(_OWORD *)(a1 + 24) = v11;
    v12 = *(_OWORD *)(a2 + 40);
    v13 = *(_OWORD *)(a2 + 56);
    v14 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = v14;
    *(_OWORD *)(a1 + 40) = v12;
    *(_OWORD *)(a1 + 56) = v13;
  }
  return a1;
}

__n128 __swift_memcpy104_8(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __n128 result;
  __int128 v5;
  __int128 v6;

  v2 = *a2;
  v3 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)a1 = v2;
  result = (__n128)a2[3];
  v5 = a2[4];
  v6 = a2[5];
  *(_QWORD *)(a1 + 96) = *((_QWORD *)a2 + 12);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

uint64_t assignWithTake for FromClause(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _OWORD *v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v4 = (_OWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  swift_bridgeObjectRelease();
  v5 = (_OWORD *)(a1 + 8);
  if (!*(_QWORD *)(a1 + 32))
    goto LABEL_5;
  if (!*(_QWORD *)(a2 + 32))
  {
    outlined destroy of SQLExpression(a1 + 8);
LABEL_5:
    v9 = v4[3];
    *(_OWORD *)(a1 + 40) = v4[2];
    *(_OWORD *)(a1 + 56) = v9;
    v10 = v4[5];
    *(_OWORD *)(a1 + 72) = v4[4];
    *(_OWORD *)(a1 + 88) = v10;
    v11 = v4[1];
    *v5 = *v4;
    *(_OWORD *)(a1 + 24) = v11;
    return a1;
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
  v6 = v4[1];
  *v5 = *v4;
  *(_OWORD *)(a1 + 24) = v6;
  *(_QWORD *)(a1 + 40) = *((_QWORD *)v4 + 4);
  v7 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v7;
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  swift_bridgeObjectRelease();
  v8 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 96) = v8;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for FromClause(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *((_BYTE *)a1 + 104))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for FromClause(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 104) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)result = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 104) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

uint64_t assignWithCopy for ResultColumn(uint64_t a1, uint64_t a2)
{
  __swift_assign_boxed_opaque_existential_1((uint64_t *)a1, (uint64_t *)a2);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for ResultColumn(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  swift_bridgeObjectRelease();
  v5 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = v5;
  swift_bridgeObjectRelease();
  v6 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 104) = v6;
  swift_bridgeObjectRelease();
  v7 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = v7;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for ResultColumn(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 128))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for ResultColumn(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 120) = 0;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 128) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 24) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 128) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

uint64_t assignWithCopy for SelectCore(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _OWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD *v26;
  _OWORD *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v4 = (_OWORD *)(a1 + 8);
  v5 = (_OWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 32);
  if (*(_QWORD *)(a1 + 32))
  {
    if (v6)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 8), (uint64_t *)(a2 + 8));
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 8);
      v7 = *(_OWORD *)(a2 + 24);
      *v4 = *v5;
      *(_OWORD *)(a1 + 24) = v7;
      v8 = *(_OWORD *)(a2 + 88);
      v10 = *(_OWORD *)(a2 + 40);
      v9 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = v8;
      *(_OWORD *)(a1 + 40) = v10;
      *(_OWORD *)(a1 + 56) = v9;
    }
  }
  else if (v6)
  {
    *(_QWORD *)(a1 + 32) = v6;
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
    (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1 + 8, a2 + 8);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v11 = *(_OWORD *)(a2 + 24);
    *v4 = *v5;
    *(_OWORD *)(a1 + 24) = v11;
    v12 = *(_OWORD *)(a2 + 40);
    v13 = *(_OWORD *)(a2 + 56);
    v14 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = v14;
    *(_OWORD *)(a1 + 40) = v12;
    *(_OWORD *)(a1 + 56) = v13;
  }
  v15 = (_OWORD *)(a1 + 104);
  v16 = (_OWORD *)(a2 + 104);
  v17 = *(_QWORD *)(a2 + 128);
  if (*(_QWORD *)(a1 + 128))
  {
    if (v17)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 104), (uint64_t *)(a2 + 104));
      *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
      *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
      *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
      *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 104);
      v18 = *(_OWORD *)(a2 + 120);
      *v15 = *v16;
      *(_OWORD *)(a1 + 120) = v18;
      v19 = *(_OWORD *)(a2 + 184);
      v21 = *(_OWORD *)(a2 + 136);
      v20 = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 184) = v19;
      *(_OWORD *)(a1 + 136) = v21;
      *(_OWORD *)(a1 + 152) = v20;
    }
  }
  else if (v17)
  {
    *(_QWORD *)(a1 + 128) = v17;
    *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
    (**(void (***)(uint64_t, uint64_t))(v17 - 8))(a1 + 104, a2 + 104);
    *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
    *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
    *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
    *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
    *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
    *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v22 = *(_OWORD *)(a2 + 120);
    *v15 = *v16;
    *(_OWORD *)(a1 + 120) = v22;
    v23 = *(_OWORD *)(a2 + 136);
    v24 = *(_OWORD *)(a2 + 152);
    v25 = *(_OWORD *)(a2 + 184);
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    *(_OWORD *)(a1 + 184) = v25;
    *(_OWORD *)(a1 + 136) = v23;
    *(_OWORD *)(a1 + 152) = v24;
  }
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v26 = (_OWORD *)(a1 + 208);
  v27 = (_OWORD *)(a2 + 208);
  v28 = *(_QWORD *)(a2 + 232);
  if (*(_QWORD *)(a1 + 232))
  {
    if (v28)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 208), (uint64_t *)(a2 + 208));
      *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
      *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 280) = *(_QWORD *)(a2 + 280);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
      *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 208);
      v29 = *(_OWORD *)(a2 + 224);
      *v26 = *v27;
      *(_OWORD *)(a1 + 224) = v29;
      v30 = *(_OWORD *)(a2 + 288);
      v32 = *(_OWORD *)(a2 + 240);
      v31 = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 288) = v30;
      *(_OWORD *)(a1 + 240) = v32;
      *(_OWORD *)(a1 + 256) = v31;
    }
  }
  else if (v28)
  {
    *(_QWORD *)(a1 + 232) = v28;
    *(_QWORD *)(a1 + 240) = *(_QWORD *)(a2 + 240);
    (**(void (***)(uint64_t, uint64_t))(v28 - 8))(a1 + 208, a2 + 208);
    *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
    *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
    *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
    *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
    *(_QWORD *)(a1 + 280) = *(_QWORD *)(a2 + 280);
    *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
    *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v33 = *(_OWORD *)(a2 + 224);
    *v26 = *v27;
    *(_OWORD *)(a1 + 224) = v33;
    v34 = *(_OWORD *)(a2 + 240);
    v35 = *(_OWORD *)(a2 + 256);
    v36 = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 288) = v36;
    *(_OWORD *)(a1 + 240) = v34;
    *(_OWORD *)(a1 + 256) = v35;
  }
  *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for SelectCore(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _OWORD *v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _OWORD *v12;
  _OWORD *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _OWORD *v20;
  _OWORD *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  v4 = a2 + 8;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  swift_bridgeObjectRelease();
  v5 = (_OWORD *)(a1 + 8);
  if (*(_QWORD *)(a1 + 32))
  {
    if (*(_QWORD *)(a2 + 32))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
      v6 = *(_OWORD *)(v4 + 16);
      *v5 = *(_OWORD *)v4;
      *(_OWORD *)(a1 + 24) = v6;
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(v4 + 32);
      v7 = *(_QWORD *)(a2 + 56);
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 56) = v7;
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      swift_bridgeObjectRelease();
      v8 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 96) = v8;
      swift_bridgeObjectRelease();
      goto LABEL_6;
    }
    outlined destroy of SQLExpression(a1 + 8);
  }
  v9 = *(_OWORD *)(v4 + 48);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(v4 + 32);
  *(_OWORD *)(a1 + 56) = v9;
  v10 = *(_OWORD *)(v4 + 80);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(v4 + 64);
  *(_OWORD *)(a1 + 88) = v10;
  v11 = *(_OWORD *)(v4 + 16);
  *v5 = *(_OWORD *)v4;
  *(_OWORD *)(a1 + 24) = v11;
LABEL_6:
  v12 = (_OWORD *)(a1 + 104);
  v13 = (_OWORD *)(a2 + 104);
  if (*(_QWORD *)(a1 + 128))
  {
    if (*(_QWORD *)(a2 + 128))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
      v14 = *(_OWORD *)(a2 + 120);
      *v12 = *v13;
      *(_OWORD *)(a1 + 120) = v14;
      *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
      v15 = *(_QWORD *)(a2 + 152);
      *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
      *(_QWORD *)(a1 + 152) = v15;
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
      *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
      swift_bridgeObjectRelease();
      v16 = *(_QWORD *)(a2 + 192);
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
      *(_QWORD *)(a1 + 192) = v16;
      swift_bridgeObjectRelease();
      goto LABEL_11;
    }
    outlined destroy of SQLExpression(a1 + 104);
  }
  v17 = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 152) = v17;
  v18 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 184) = v18;
  v19 = *(_OWORD *)(a2 + 120);
  *v12 = *v13;
  *(_OWORD *)(a1 + 120) = v19;
LABEL_11:
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  swift_bridgeObjectRelease();
  v20 = (_OWORD *)(a1 + 208);
  v21 = (_OWORD *)(a2 + 208);
  if (!*(_QWORD *)(a1 + 232))
  {
LABEL_15:
    v25 = *(_OWORD *)(a2 + 256);
    *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
    *(_OWORD *)(a1 + 256) = v25;
    v26 = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 288) = v26;
    v27 = *(_OWORD *)(a2 + 224);
    *v20 = *v21;
    *(_OWORD *)(a1 + 224) = v27;
    goto LABEL_16;
  }
  if (!*(_QWORD *)(a2 + 232))
  {
    outlined destroy of SQLExpression(a1 + 208);
    goto LABEL_15;
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
  v22 = *(_OWORD *)(a2 + 224);
  *v20 = *v21;
  *(_OWORD *)(a1 + 224) = v22;
  *(_QWORD *)(a1 + 240) = *(_QWORD *)(a2 + 240);
  v23 = *(_QWORD *)(a2 + 256);
  *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
  *(_QWORD *)(a1 + 256) = v23;
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
  *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 280) = *(_QWORD *)(a2 + 280);
  swift_bridgeObjectRelease();
  v24 = *(_QWORD *)(a2 + 296);
  *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
  *(_QWORD *)(a1 + 296) = v24;
  swift_bridgeObjectRelease();
LABEL_16:
  *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SelectCore(uint64_t *a1, int a2)
{
  uint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *((_BYTE *)a1 + 312))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SelectCore(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 312) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)result = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 312) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

uint64_t assignWithCopy for MaterializedView(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _OWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD *v26;
  _OWORD *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v4 = (_OWORD *)(a1 + 24);
  v5 = (_OWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 48);
  if (*(_QWORD *)(a1 + 48))
  {
    if (v6)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 24), (uint64_t *)(a2 + 24));
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
      *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 24);
      v7 = *(_OWORD *)(a2 + 40);
      *v4 = *v5;
      *(_OWORD *)(a1 + 40) = v7;
      v8 = *(_OWORD *)(a2 + 104);
      v10 = *(_OWORD *)(a2 + 56);
      v9 = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 104) = v8;
      *(_OWORD *)(a1 + 56) = v10;
      *(_OWORD *)(a1 + 72) = v9;
    }
  }
  else if (v6)
  {
    *(_QWORD *)(a1 + 48) = v6;
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1 + 24, a2 + 24);
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
    *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v11 = *(_OWORD *)(a2 + 40);
    *v4 = *v5;
    *(_OWORD *)(a1 + 40) = v11;
    v12 = *(_OWORD *)(a2 + 56);
    v13 = *(_OWORD *)(a2 + 72);
    v14 = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 104) = v14;
    *(_OWORD *)(a1 + 56) = v12;
    *(_OWORD *)(a1 + 72) = v13;
  }
  v15 = (_OWORD *)(a1 + 120);
  v16 = (_OWORD *)(a2 + 120);
  v17 = *(_QWORD *)(a2 + 144);
  if (*(_QWORD *)(a1 + 144))
  {
    if (v17)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 120), (uint64_t *)(a2 + 120));
      *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
      *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
      *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 120);
      v18 = *(_OWORD *)(a2 + 136);
      *v15 = *v16;
      *(_OWORD *)(a1 + 136) = v18;
      v19 = *(_OWORD *)(a2 + 200);
      v21 = *(_OWORD *)(a2 + 152);
      v20 = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 200) = v19;
      *(_OWORD *)(a1 + 152) = v21;
      *(_OWORD *)(a1 + 168) = v20;
    }
  }
  else if (v17)
  {
    *(_QWORD *)(a1 + 144) = v17;
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
    (**(void (***)(uint64_t, uint64_t))(v17 - 8))(a1 + 120, a2 + 120);
    *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
    *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
    *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
    *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
    *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
    *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
    *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v22 = *(_OWORD *)(a2 + 136);
    *v15 = *v16;
    *(_OWORD *)(a1 + 136) = v22;
    v23 = *(_OWORD *)(a2 + 152);
    v24 = *(_OWORD *)(a2 + 168);
    v25 = *(_OWORD *)(a2 + 200);
    *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
    *(_OWORD *)(a1 + 200) = v25;
    *(_OWORD *)(a1 + 152) = v23;
    *(_OWORD *)(a1 + 168) = v24;
  }
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v26 = (_OWORD *)(a1 + 224);
  v27 = (_OWORD *)(a2 + 224);
  v28 = *(_QWORD *)(a2 + 248);
  if (*(_QWORD *)(a1 + 248))
  {
    if (v28)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 224), (uint64_t *)(a2 + 224));
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 + 280);
      *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
      *(_QWORD *)(a1 + 312) = *(_QWORD *)(a2 + 312);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 224);
      v29 = *(_OWORD *)(a2 + 240);
      *v26 = *v27;
      *(_OWORD *)(a1 + 240) = v29;
      v30 = *(_OWORD *)(a2 + 304);
      v32 = *(_OWORD *)(a2 + 256);
      v31 = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 304) = v30;
      *(_OWORD *)(a1 + 256) = v32;
      *(_OWORD *)(a1 + 272) = v31;
    }
  }
  else if (v28)
  {
    *(_QWORD *)(a1 + 248) = v28;
    *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
    (**(void (***)(uint64_t, uint64_t))(v28 - 8))(a1 + 224, a2 + 224);
    *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
    *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
    *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 + 280);
    *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
    *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
    *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
    *(_QWORD *)(a1 + 312) = *(_QWORD *)(a2 + 312);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v33 = *(_OWORD *)(a2 + 240);
    *v26 = *v27;
    *(_OWORD *)(a1 + 240) = v33;
    v34 = *(_OWORD *)(a2 + 256);
    v35 = *(_OWORD *)(a2 + 272);
    v36 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 304) = v36;
    *(_OWORD *)(a1 + 256) = v34;
    *(_OWORD *)(a1 + 272) = v35;
  }
  *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for MaterializedView(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _OWORD *v5;
  _OWORD *v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _OWORD *v13;
  _OWORD *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _OWORD *v21;
  _OWORD *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  swift_bridgeObjectRelease();
  v5 = (_OWORD *)(a1 + 24);
  v6 = (_OWORD *)(a2 + 24);
  if (*(_QWORD *)(a1 + 48))
  {
    if (*(_QWORD *)(a2 + 48))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
      v7 = *(_OWORD *)(a2 + 40);
      *v5 = *v6;
      *(_OWORD *)(a1 + 40) = v7;
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
      v8 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v8;
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
      swift_bridgeObjectRelease();
      v9 = *(_QWORD *)(a2 + 112);
      *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
      *(_QWORD *)(a1 + 112) = v9;
      swift_bridgeObjectRelease();
      goto LABEL_6;
    }
    outlined destroy of SQLExpression(a1 + 24);
  }
  v10 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = v10;
  v11 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 104) = v11;
  v12 = *(_OWORD *)(a2 + 40);
  *v5 = *v6;
  *(_OWORD *)(a1 + 40) = v12;
LABEL_6:
  v13 = (_OWORD *)(a1 + 120);
  v14 = (_OWORD *)(a2 + 120);
  if (*(_QWORD *)(a1 + 144))
  {
    if (*(_QWORD *)(a2 + 144))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
      v15 = *(_OWORD *)(a2 + 136);
      *v13 = *v14;
      *(_OWORD *)(a1 + 136) = v15;
      *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
      v16 = *(_QWORD *)(a2 + 168);
      *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
      *(_QWORD *)(a1 + 168) = v16;
      swift_bridgeObjectRelease();
      *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
      swift_bridgeObjectRelease();
      *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
      swift_bridgeObjectRelease();
      v17 = *(_QWORD *)(a2 + 208);
      *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
      *(_QWORD *)(a1 + 208) = v17;
      swift_bridgeObjectRelease();
      goto LABEL_11;
    }
    outlined destroy of SQLExpression(a1 + 120);
  }
  v18 = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 168) = v18;
  v19 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 200) = v19;
  v20 = *(_OWORD *)(a2 + 136);
  *v13 = *v14;
  *(_OWORD *)(a1 + 136) = v20;
LABEL_11:
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
  swift_bridgeObjectRelease();
  v21 = (_OWORD *)(a1 + 224);
  v22 = (_OWORD *)(a2 + 224);
  if (!*(_QWORD *)(a1 + 248))
  {
LABEL_15:
    v26 = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
    *(_OWORD *)(a1 + 272) = v26;
    v27 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 304) = v27;
    v28 = *(_OWORD *)(a2 + 240);
    *v21 = *v22;
    *(_OWORD *)(a1 + 240) = v28;
    goto LABEL_16;
  }
  if (!*(_QWORD *)(a2 + 248))
  {
    outlined destroy of SQLExpression(a1 + 224);
    goto LABEL_15;
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
  v23 = *(_OWORD *)(a2 + 240);
  *v21 = *v22;
  *(_OWORD *)(a1 + 240) = v23;
  *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
  v24 = *(_QWORD *)(a2 + 272);
  *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
  *(_QWORD *)(a1 + 272) = v24;
  swift_bridgeObjectRelease();
  *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 + 280);
  *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
  swift_bridgeObjectRelease();
  v25 = *(_QWORD *)(a2 + 312);
  *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
  *(_QWORD *)(a1 + 312) = v25;
  swift_bridgeObjectRelease();
LABEL_16:
  *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t storeEnumTagSinglePayload for MaterializedView(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 328) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 8) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 328) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

uint64_t destroy for LogicalPlan(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 328) & 1) != 0)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 48))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(_QWORD *)(a1 + 144))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 248))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 32))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(_QWORD *)(a1 + 128))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 232))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for LogicalPlan(uint64_t a1, uint64_t a2)
{
  char v4;
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _OWORD *v22;
  _OWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _OWORD *v32;
  _OWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;

  v4 = *(_BYTE *)(a2 + 328);
  if ((v4 & 1) != 0)
  {
    v5 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    v6 = (_OWORD *)(a2 + 24);
    v7 = *(_QWORD *)(a2 + 48);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    if (v7)
    {
      v8 = *(_QWORD *)(a2 + 56);
      *(_QWORD *)(a1 + 48) = v7;
      *(_QWORD *)(a1 + 56) = v8;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v7 - 8))(a1 + 24, a2 + 24, v7);
      v9 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v9;
      *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
      v10 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 96) = v10;
      v11 = *(_QWORD *)(a2 + 112);
      *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
      *(_QWORD *)(a1 + 112) = v11;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v19 = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = v19;
      v20 = *(_OWORD *)(a2 + 104);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 104) = v20;
      v21 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a1 + 24) = *v6;
      *(_OWORD *)(a1 + 40) = v21;
    }
    v22 = (_OWORD *)(a1 + 120);
    v23 = (_OWORD *)(a2 + 120);
    v24 = *(_QWORD *)(a2 + 144);
    if (v24)
    {
      v25 = *(_QWORD *)(a2 + 152);
      *(_QWORD *)(a1 + 144) = v24;
      *(_QWORD *)(a1 + 152) = v25;
      (**(void (***)(_OWORD *, _OWORD *))(v24 - 8))(v22, v23);
      v26 = *(_QWORD *)(a2 + 168);
      *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
      *(_QWORD *)(a1 + 168) = v26;
      *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
      v27 = *(_QWORD *)(a2 + 192);
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
      *(_QWORD *)(a1 + 192) = v27;
      v28 = *(_QWORD *)(a2 + 208);
      *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
      *(_QWORD *)(a1 + 208) = v28;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v39 = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 168) = v39;
      v40 = *(_OWORD *)(a2 + 200);
      *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 200) = v40;
      v41 = *(_OWORD *)(a2 + 136);
      *v22 = *v23;
      *(_OWORD *)(a1 + 136) = v41;
    }
    *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
    v42 = *(_QWORD *)(a2 + 248);
    swift_bridgeObjectRetain();
    if (v42)
    {
      v43 = *(_QWORD *)(a2 + 256);
      *(_QWORD *)(a1 + 248) = v42;
      *(_QWORD *)(a1 + 256) = v43;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v42 - 8))(a1 + 224, a2 + 224, v42);
      v44 = *(_QWORD *)(a2 + 272);
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
      *(_QWORD *)(a1 + 272) = v44;
      *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 + 280);
      v45 = *(_QWORD *)(a2 + 296);
      *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
      *(_QWORD *)(a1 + 296) = v45;
      v46 = *(_QWORD *)(a2 + 312);
      *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
      *(_QWORD *)(a1 + 312) = v46;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v55 = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 272) = v55;
      v56 = *(_OWORD *)(a2 + 304);
      *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 304) = v56;
      v57 = *(_OWORD *)(a2 + 240);
      *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
      *(_OWORD *)(a1 + 240) = v57;
    }
    *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
  }
  else
  {
    *(_QWORD *)a1 = *(_QWORD *)a2;
    v12 = (_OWORD *)(a1 + 8);
    v13 = (_OWORD *)(a2 + 8);
    v14 = *(_QWORD *)(a2 + 32);
    swift_bridgeObjectRetain();
    if (v14)
    {
      v15 = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 32) = v14;
      *(_QWORD *)(a1 + 40) = v15;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v14 - 8))(a1 + 8, a2 + 8, v14);
      v16 = *(_QWORD *)(a2 + 56);
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a1 + 56) = v16;
      *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
      v17 = *(_QWORD *)(a2 + 80);
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 80) = v17;
      v18 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 96) = v18;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v29 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a1 + 56) = v29;
      v30 = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = v30;
      v31 = *(_OWORD *)(a2 + 24);
      *v12 = *v13;
      *(_OWORD *)(a1 + 24) = v31;
    }
    v32 = (_OWORD *)(a1 + 104);
    v33 = (_OWORD *)(a2 + 104);
    v34 = *(_QWORD *)(a2 + 128);
    if (v34)
    {
      v35 = *(_QWORD *)(a2 + 136);
      *(_QWORD *)(a1 + 128) = v34;
      *(_QWORD *)(a1 + 136) = v35;
      (**(void (***)(_OWORD *, _OWORD *))(v34 - 8))(v32, v33);
      v36 = *(_QWORD *)(a2 + 152);
      *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
      *(_QWORD *)(a1 + 152) = v36;
      *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
      v37 = *(_QWORD *)(a2 + 176);
      *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
      *(_QWORD *)(a1 + 176) = v37;
      v38 = *(_QWORD *)(a2 + 192);
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
      *(_QWORD *)(a1 + 192) = v38;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v47 = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
      *(_OWORD *)(a1 + 152) = v47;
      v48 = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 184) = v48;
      v49 = *(_OWORD *)(a2 + 120);
      *v32 = *v33;
      *(_OWORD *)(a1 + 120) = v49;
    }
    *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
    v50 = *(_QWORD *)(a2 + 232);
    swift_bridgeObjectRetain();
    if (v50)
    {
      v51 = *(_QWORD *)(a2 + 240);
      *(_QWORD *)(a1 + 232) = v50;
      *(_QWORD *)(a1 + 240) = v51;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v50 - 8))(a1 + 208, a2 + 208, v50);
      v52 = *(_QWORD *)(a2 + 256);
      *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
      *(_QWORD *)(a1 + 256) = v52;
      *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
      v53 = *(_QWORD *)(a2 + 280);
      *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
      *(_QWORD *)(a1 + 280) = v53;
      v54 = *(_QWORD *)(a2 + 296);
      *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
      *(_QWORD *)(a1 + 296) = v54;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v58 = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
      *(_OWORD *)(a1 + 256) = v58;
      v59 = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 288) = v59;
      v60 = *(_OWORD *)(a2 + 224);
      *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
      *(_OWORD *)(a1 + 224) = v60;
    }
    *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
  }
  *(_BYTE *)(a1 + 328) = v4;
  swift_bridgeObjectRetain();
  v61 = *(_QWORD *)(a2 + 344);
  *(_QWORD *)(a1 + 336) = *(_QWORD *)(a2 + 336);
  *(_QWORD *)(a1 + 344) = v61;
  v62 = *(_QWORD *)(a2 + 352);
  v63 = *(_QWORD *)(a2 + 360);
  *(_QWORD *)(a1 + 352) = v62;
  *(_QWORD *)(a1 + 360) = v63;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for LogicalPlan(uint64_t a1, uint64_t a2)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _OWORD *v11;
  _OWORD *v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _OWORD *v18;
  _OWORD *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;

  if (a1 != a2)
  {
    outlined destroy of LogicalPlanType(a1);
    v4 = *(_BYTE *)(a2 + 328);
    if ((v4 & 1) != 0)
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      v5 = *(_QWORD *)(a2 + 48);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v5)
      {
        *(_QWORD *)(a1 + 48) = v5;
        *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v5 - 8))(a1 + 24, a2 + 24, v5);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
        *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
        *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v7 = *(_OWORD *)(a2 + 40);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 40) = v7;
        v8 = *(_OWORD *)(a2 + 56);
        v9 = *(_OWORD *)(a2 + 72);
        v10 = *(_OWORD *)(a2 + 104);
        *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 104) = v10;
        *(_OWORD *)(a1 + 56) = v8;
        *(_OWORD *)(a1 + 72) = v9;
      }
      v11 = (_OWORD *)(a1 + 120);
      v12 = (_OWORD *)(a2 + 120);
      v13 = *(_QWORD *)(a2 + 144);
      if (v13)
      {
        *(_QWORD *)(a1 + 144) = v13;
        *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
        (**(void (***)(_OWORD *, _OWORD *))(v13 - 8))(v11, v12);
        *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
        *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
        *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
        *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
        *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
        *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
        *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v21 = *(_OWORD *)(a2 + 136);
        *v11 = *v12;
        *(_OWORD *)(a1 + 136) = v21;
        v22 = *(_OWORD *)(a2 + 152);
        v23 = *(_OWORD *)(a2 + 168);
        v24 = *(_OWORD *)(a2 + 200);
        *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 200) = v24;
        *(_OWORD *)(a1 + 152) = v22;
        *(_OWORD *)(a1 + 168) = v23;
      }
      *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
      v25 = *(_QWORD *)(a2 + 248);
      swift_bridgeObjectRetain();
      if (v25)
      {
        *(_QWORD *)(a1 + 248) = v25;
        *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v25 - 8))(a1 + 224, a2 + 224, v25);
        *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
        *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
        *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 + 280);
        *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
        *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
        *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
        *(_QWORD *)(a1 + 312) = *(_QWORD *)(a2 + 312);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v31 = *(_OWORD *)(a2 + 240);
        *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 240) = v31;
        v32 = *(_OWORD *)(a2 + 256);
        v33 = *(_OWORD *)(a2 + 272);
        v34 = *(_OWORD *)(a2 + 304);
        *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 304) = v34;
        *(_OWORD *)(a1 + 256) = v32;
        *(_OWORD *)(a1 + 272) = v33;
      }
      *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
    }
    else
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v6 = *(_QWORD *)(a2 + 32);
      swift_bridgeObjectRetain();
      if (v6)
      {
        *(_QWORD *)(a1 + 32) = v6;
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v6 - 8))(a1 + 8, a2 + 8, v6);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
        *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v14 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a1 + 24) = v14;
        v15 = *(_OWORD *)(a2 + 40);
        v16 = *(_OWORD *)(a2 + 56);
        v17 = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(a1 + 88) = v17;
        *(_OWORD *)(a1 + 40) = v15;
        *(_OWORD *)(a1 + 56) = v16;
      }
      v18 = (_OWORD *)(a1 + 104);
      v19 = (_OWORD *)(a2 + 104);
      v20 = *(_QWORD *)(a2 + 128);
      if (v20)
      {
        *(_QWORD *)(a1 + 128) = v20;
        *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
        (**(void (***)(_OWORD *, _OWORD *))(v20 - 8))(v18, v19);
        *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
        *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
        *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
        *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
        *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
        *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
        *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v26 = *(_OWORD *)(a2 + 120);
        *v18 = *v19;
        *(_OWORD *)(a1 + 120) = v26;
        v27 = *(_OWORD *)(a2 + 136);
        v28 = *(_OWORD *)(a2 + 152);
        v29 = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
        *(_OWORD *)(a1 + 184) = v29;
        *(_OWORD *)(a1 + 136) = v27;
        *(_OWORD *)(a1 + 152) = v28;
      }
      *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
      v30 = *(_QWORD *)(a2 + 232);
      swift_bridgeObjectRetain();
      if (v30)
      {
        *(_QWORD *)(a1 + 232) = v30;
        *(_QWORD *)(a1 + 240) = *(_QWORD *)(a2 + 240);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v30 - 8))(a1 + 208, a2 + 208, v30);
        *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
        *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
        *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
        *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
        *(_QWORD *)(a1 + 280) = *(_QWORD *)(a2 + 280);
        *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
        *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v35 = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
        *(_OWORD *)(a1 + 224) = v35;
        v36 = *(_OWORD *)(a2 + 240);
        v37 = *(_OWORD *)(a2 + 256);
        v38 = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
        *(_OWORD *)(a1 + 288) = v38;
        *(_OWORD *)(a1 + 240) = v36;
        *(_OWORD *)(a1 + 256) = v37;
      }
      *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
    }
    *(_BYTE *)(a1 + 328) = v4;
    swift_bridgeObjectRetain();
  }
  *(_QWORD *)(a1 + 336) = *(_QWORD *)(a2 + 336);
  *(_QWORD *)(a1 + 344) = *(_QWORD *)(a2 + 344);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_QWORD *)(a1 + 352) = *(_QWORD *)(a2 + 352);
  *(_QWORD *)(a1 + 360) = *(_QWORD *)(a2 + 360);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t outlined destroy of LogicalPlanType(uint64_t a1)
{
  destroy for LogicalPlanType(a1);
  return a1;
}

void *__swift_memcpy368_8(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x170uLL);
}

_QWORD *assignWithTake for LogicalPlan(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;

  if (a1 != a2)
  {
    outlined destroy of LogicalPlanType((uint64_t)a1);
    memcpy(a1, a2, 0x149uLL);
  }
  v4 = a2[43];
  a1[42] = a2[42];
  a1[43] = v4;
  swift_bridgeObjectRelease();
  v5 = a2[45];
  a1[44] = a2[44];
  a1[45] = v5;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for LogicalPlan(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 368))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 344);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for LogicalPlan(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 360) = 0;
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 344) = 0u;
    *(_OWORD *)(result + 328) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 368) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 344) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 368) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for LogicalPlan()
{
  return &type metadata for LogicalPlan;
}

uint64_t destroy for LogicalPlanType(uint64_t a1)
{
  unsigned int v2;

  v2 = *(unsigned __int8 *)(a1 + 328);
  if (v2 >= 2)
    v2 = *(_DWORD *)a1 + 2;
  if (v2 == 1)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 48))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(_QWORD *)(a1 + 144))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 248))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 32))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(_QWORD *)(a1 + 128))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(_QWORD *)(a1 + 232))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for LogicalPlanType(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD *v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _OWORD *v22;
  _OWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _OWORD *v32;
  _OWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  char v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;

  v4 = *(unsigned __int8 *)(a2 + 328);
  if (v4 >= 2)
  {
    if (*(_DWORD *)a2 == -1)
      goto LABEL_3;
  }
  else if (v4 == 1)
  {
LABEL_3:
    v5 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    v6 = (_OWORD *)(a2 + 24);
    v7 = *(_QWORD *)(a2 + 48);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    if (v7)
    {
      v8 = *(_QWORD *)(a2 + 56);
      *(_QWORD *)(a1 + 48) = v7;
      *(_QWORD *)(a1 + 56) = v8;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v7 - 8))(a1 + 24, a2 + 24, v7);
      v9 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(a1 + 72) = v9;
      *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
      v10 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
      *(_QWORD *)(a1 + 96) = v10;
      v11 = *(_QWORD *)(a2 + 112);
      *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
      *(_QWORD *)(a1 + 112) = v11;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v19 = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = v19;
      v20 = *(_OWORD *)(a2 + 104);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 104) = v20;
      v21 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a1 + 24) = *v6;
      *(_OWORD *)(a1 + 40) = v21;
    }
    v22 = (_OWORD *)(a1 + 120);
    v23 = (_OWORD *)(a2 + 120);
    v24 = *(_QWORD *)(a2 + 144);
    if (v24)
    {
      v25 = *(_QWORD *)(a2 + 152);
      *(_QWORD *)(a1 + 144) = v24;
      *(_QWORD *)(a1 + 152) = v25;
      (**(void (***)(_OWORD *, _OWORD *))(v24 - 8))(v22, v23);
      v26 = *(_QWORD *)(a2 + 168);
      *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
      *(_QWORD *)(a1 + 168) = v26;
      *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
      v27 = *(_QWORD *)(a2 + 192);
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
      *(_QWORD *)(a1 + 192) = v27;
      v28 = *(_QWORD *)(a2 + 208);
      *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
      *(_QWORD *)(a1 + 208) = v28;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v39 = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 168) = v39;
      v40 = *(_OWORD *)(a2 + 200);
      *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 200) = v40;
      v41 = *(_OWORD *)(a2 + 136);
      *v22 = *v23;
      *(_OWORD *)(a1 + 136) = v41;
    }
    *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
    v42 = *(_QWORD *)(a2 + 248);
    swift_bridgeObjectRetain();
    if (v42)
    {
      v43 = *(_QWORD *)(a2 + 256);
      *(_QWORD *)(a1 + 248) = v42;
      *(_QWORD *)(a1 + 256) = v43;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v42 - 8))(a1 + 224, a2 + 224, v42);
      v44 = *(_QWORD *)(a2 + 272);
      *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
      *(_QWORD *)(a1 + 272) = v44;
      *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 + 280);
      v45 = *(_QWORD *)(a2 + 296);
      *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
      *(_QWORD *)(a1 + 296) = v45;
      v46 = *(_QWORD *)(a2 + 312);
      *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
      *(_QWORD *)(a1 + 312) = v46;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      v55 = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 272) = v55;
      v56 = *(_OWORD *)(a2 + 304);
      *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 304) = v56;
      v57 = *(_OWORD *)(a2 + 240);
      *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
      *(_OWORD *)(a1 + 240) = v57;
    }
    *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
    v58 = 1;
    goto LABEL_24;
  }
  *(_QWORD *)a1 = *(_QWORD *)a2;
  v12 = (_OWORD *)(a1 + 8);
  v13 = (_OWORD *)(a2 + 8);
  v14 = *(_QWORD *)(a2 + 32);
  swift_bridgeObjectRetain();
  if (v14)
  {
    v15 = *(_QWORD *)(a2 + 40);
    *(_QWORD *)(a1 + 32) = v14;
    *(_QWORD *)(a1 + 40) = v15;
    (**(void (***)(uint64_t, uint64_t, uint64_t))(v14 - 8))(a1 + 8, a2 + 8, v14);
    v16 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
    *(_QWORD *)(a1 + 56) = v16;
    *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
    v17 = *(_QWORD *)(a2 + 80);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_QWORD *)(a1 + 80) = v17;
    v18 = *(_QWORD *)(a2 + 96);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
    *(_QWORD *)(a1 + 96) = v18;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v29 = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a1 + 56) = v29;
    v30 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = v30;
    v31 = *(_OWORD *)(a2 + 24);
    *v12 = *v13;
    *(_OWORD *)(a1 + 24) = v31;
  }
  v32 = (_OWORD *)(a1 + 104);
  v33 = (_OWORD *)(a2 + 104);
  v34 = *(_QWORD *)(a2 + 128);
  if (v34)
  {
    v35 = *(_QWORD *)(a2 + 136);
    *(_QWORD *)(a1 + 128) = v34;
    *(_QWORD *)(a1 + 136) = v35;
    (**(void (***)(_OWORD *, _OWORD *))(v34 - 8))(v32, v33);
    v36 = *(_QWORD *)(a2 + 152);
    *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
    *(_QWORD *)(a1 + 152) = v36;
    *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
    v37 = *(_QWORD *)(a2 + 176);
    *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
    *(_QWORD *)(a1 + 176) = v37;
    v38 = *(_QWORD *)(a2 + 192);
    *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
    *(_QWORD *)(a1 + 192) = v38;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v47 = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a1 + 152) = v47;
    v48 = *(_OWORD *)(a2 + 184);
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    *(_OWORD *)(a1 + 184) = v48;
    v49 = *(_OWORD *)(a2 + 120);
    *v32 = *v33;
    *(_OWORD *)(a1 + 120) = v49;
  }
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  v50 = *(_QWORD *)(a2 + 232);
  swift_bridgeObjectRetain();
  if (v50)
  {
    v51 = *(_QWORD *)(a2 + 240);
    *(_QWORD *)(a1 + 232) = v50;
    *(_QWORD *)(a1 + 240) = v51;
    (**(void (***)(uint64_t, uint64_t, uint64_t))(v50 - 8))(a1 + 208, a2 + 208, v50);
    v52 = *(_QWORD *)(a2 + 256);
    *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
    *(_QWORD *)(a1 + 256) = v52;
    *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
    v53 = *(_QWORD *)(a2 + 280);
    *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
    *(_QWORD *)(a1 + 280) = v53;
    v54 = *(_QWORD *)(a2 + 296);
    *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
    *(_QWORD *)(a1 + 296) = v54;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    v59 = *(_OWORD *)(a2 + 256);
    *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
    *(_OWORD *)(a1 + 256) = v59;
    v60 = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 288) = v60;
    v61 = *(_OWORD *)(a2 + 224);
    *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
    *(_OWORD *)(a1 + 224) = v61;
  }
  v58 = 0;
  *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
LABEL_24:
  *(_BYTE *)(a1 + 328) = v58;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for LogicalPlanType(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _OWORD *v12;
  _OWORD *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _OWORD *v19;
  _OWORD *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  char v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;

  if (a1 != a2)
  {
    v4 = *(unsigned __int8 *)(a1 + 328);
    if (v4 >= 2)
      v4 = *(_DWORD *)a1 + 2;
    if (v4 == 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(_QWORD *)(a1 + 48))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*(_QWORD *)(a1 + 144))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*(_QWORD *)(a1 + 248))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    else
    {
      swift_bridgeObjectRelease();
      if (*(_QWORD *)(a1 + 32))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*(_QWORD *)(a1 + 128))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*(_QWORD *)(a1 + 232))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    swift_bridgeObjectRelease();
    v5 = *(unsigned __int8 *)(a2 + 328);
    if (v5 >= 2)
      v5 = *(_DWORD *)a2 + 2;
    if (v5 == 1)
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      v6 = *(_QWORD *)(a2 + 48);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v6)
      {
        *(_QWORD *)(a1 + 48) = v6;
        *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v6 - 8))(a1 + 24, a2 + 24, v6);
        *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
        *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
        *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v8 = *(_OWORD *)(a2 + 40);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 40) = v8;
        v9 = *(_OWORD *)(a2 + 56);
        v10 = *(_OWORD *)(a2 + 72);
        v11 = *(_OWORD *)(a2 + 104);
        *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 104) = v11;
        *(_OWORD *)(a1 + 56) = v9;
        *(_OWORD *)(a1 + 72) = v10;
      }
      v12 = (_OWORD *)(a1 + 120);
      v13 = (_OWORD *)(a2 + 120);
      v14 = *(_QWORD *)(a2 + 144);
      if (v14)
      {
        *(_QWORD *)(a1 + 144) = v14;
        *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
        (**(void (***)(_OWORD *, _OWORD *))(v14 - 8))(v12, v13);
        *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
        *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
        *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
        *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
        *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
        *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
        *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v22 = *(_OWORD *)(a2 + 136);
        *v12 = *v13;
        *(_OWORD *)(a1 + 136) = v22;
        v23 = *(_OWORD *)(a2 + 152);
        v24 = *(_OWORD *)(a2 + 168);
        v25 = *(_OWORD *)(a2 + 200);
        *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 200) = v25;
        *(_OWORD *)(a1 + 152) = v23;
        *(_OWORD *)(a1 + 168) = v24;
      }
      *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
      v26 = *(_QWORD *)(a2 + 248);
      swift_bridgeObjectRetain();
      if (v26)
      {
        *(_QWORD *)(a1 + 248) = v26;
        *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v26 - 8))(a1 + 224, a2 + 224, v26);
        *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
        *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
        *(_BYTE *)(a1 + 280) = *(_BYTE *)(a2 + 280);
        *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
        *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
        *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
        *(_QWORD *)(a1 + 312) = *(_QWORD *)(a2 + 312);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v32 = *(_OWORD *)(a2 + 240);
        *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 240) = v32;
        v33 = *(_OWORD *)(a2 + 256);
        v34 = *(_OWORD *)(a2 + 272);
        v35 = *(_OWORD *)(a2 + 304);
        *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 304) = v35;
        *(_OWORD *)(a1 + 256) = v33;
        *(_OWORD *)(a1 + 272) = v34;
      }
      *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
      v36 = 1;
    }
    else
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v7 = *(_QWORD *)(a2 + 32);
      swift_bridgeObjectRetain();
      if (v7)
      {
        *(_QWORD *)(a1 + 32) = v7;
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v7 - 8))(a1 + 8, a2 + 8, v7);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
        *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
        *(_BYTE *)(a1 + 64) = *(_BYTE *)(a2 + 64);
        *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
        *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
        *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
        *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v15 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a1 + 24) = v15;
        v16 = *(_OWORD *)(a2 + 40);
        v17 = *(_OWORD *)(a2 + 56);
        v18 = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(a1 + 88) = v18;
        *(_OWORD *)(a1 + 40) = v16;
        *(_OWORD *)(a1 + 56) = v17;
      }
      v19 = (_OWORD *)(a1 + 104);
      v20 = (_OWORD *)(a2 + 104);
      v21 = *(_QWORD *)(a2 + 128);
      if (v21)
      {
        *(_QWORD *)(a1 + 128) = v21;
        *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
        (**(void (***)(_OWORD *, _OWORD *))(v21 - 8))(v19, v20);
        *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
        *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
        *(_BYTE *)(a1 + 160) = *(_BYTE *)(a2 + 160);
        *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
        *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
        *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
        *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v27 = *(_OWORD *)(a2 + 120);
        *v19 = *v20;
        *(_OWORD *)(a1 + 120) = v27;
        v28 = *(_OWORD *)(a2 + 136);
        v29 = *(_OWORD *)(a2 + 152);
        v30 = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
        *(_OWORD *)(a1 + 184) = v30;
        *(_OWORD *)(a1 + 136) = v28;
        *(_OWORD *)(a1 + 152) = v29;
      }
      *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
      v31 = *(_QWORD *)(a2 + 232);
      swift_bridgeObjectRetain();
      if (v31)
      {
        *(_QWORD *)(a1 + 232) = v31;
        *(_QWORD *)(a1 + 240) = *(_QWORD *)(a2 + 240);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v31 - 8))(a1 + 208, a2 + 208, v31);
        *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
        *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
        *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
        *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
        *(_QWORD *)(a1 + 280) = *(_QWORD *)(a2 + 280);
        *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
        *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        v37 = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
        *(_OWORD *)(a1 + 224) = v37;
        v38 = *(_OWORD *)(a2 + 240);
        v39 = *(_OWORD *)(a2 + 256);
        v40 = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
        *(_OWORD *)(a1 + 288) = v40;
        *(_OWORD *)(a1 + 240) = v38;
        *(_OWORD *)(a1 + 256) = v39;
      }
      v36 = 0;
      *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
    }
    *(_BYTE *)(a1 + 328) = v36;
    swift_bridgeObjectRetain();
  }
  return a1;
}

void *__swift_memcpy329_8(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x149uLL);
}

unsigned __int8 *assignWithTake for LogicalPlanType(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v4;
  unsigned int v5;
  char v6;

  if (a1 != a2)
  {
    v4 = a1[328];
    if (v4 >= 2)
      v4 = *(_DWORD *)a1 + 2;
    if (v4 == 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*((_QWORD *)a1 + 6))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 24));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*((_QWORD *)a1 + 18))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 120));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*((_QWORD *)a1 + 31))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 224));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    else
    {
      swift_bridgeObjectRelease();
      if (*((_QWORD *)a1 + 4))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 8));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*((_QWORD *)a1 + 16))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 104));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*((_QWORD *)a1 + 29))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 208));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    swift_bridgeObjectRelease();
    v5 = a2[328];
    if (v5 >= 2)
      v5 = *(_DWORD *)a2 + 2;
    if (v5 == 1)
    {
      memcpy(a1, a2, 0x148uLL);
      v6 = 1;
    }
    else
    {
      memcpy(a1, a2, 0x138uLL);
      v6 = 0;
    }
    a1[328] = v6;
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for LogicalPlanType(uint64_t a1, unsigned int a2)
{
  unsigned int v3;

  if (!a2)
    return 0;
  if (a2 >= 0xFF && *(_BYTE *)(a1 + 329))
    return (*(_DWORD *)a1 + 255);
  v3 = *(unsigned __int8 *)(a1 + 328);
  if (v3 >= 2)
    return (v3 ^ 0xFF) + 1;
  else
    return 0;
}

uint64_t storeEnumTagSinglePayload for LogicalPlanType(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_OWORD *)(result + 288) = 0u;
    *(_OWORD *)(result + 304) = 0u;
    *(_OWORD *)(result + 256) = 0u;
    *(_OWORD *)(result + 272) = 0u;
    *(_OWORD *)(result + 224) = 0u;
    *(_OWORD *)(result + 240) = 0u;
    *(_OWORD *)(result + 192) = 0u;
    *(_OWORD *)(result + 208) = 0u;
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 313) = 0u;
    *(_DWORD *)result = a2 - 255;
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 329) = 1;
  }
  else
  {
    if (a3 >= 0xFF)
      *(_BYTE *)(result + 329) = 0;
    if (a2)
      *(_BYTE *)(result + 328) = -(char)a2;
  }
  return result;
}

uint64_t getEnumTag for LogicalPlanType(uint64_t a1)
{
  uint64_t result;

  result = *(unsigned __int8 *)(a1 + 328);
  if (result >= 2)
    return (*(_DWORD *)a1 + 2);
  return result;
}

uint64_t destructiveInjectEnumTag for LogicalPlanType(uint64_t result, unsigned int a2)
{
  if (a2 > 1)
  {
    *(_QWORD *)(result + 320) = 0;
    *(_OWORD *)(result + 288) = 0u;
    *(_OWORD *)(result + 304) = 0u;
    *(_OWORD *)(result + 256) = 0u;
    *(_OWORD *)(result + 272) = 0u;
    *(_OWORD *)(result + 224) = 0u;
    *(_OWORD *)(result + 240) = 0u;
    *(_OWORD *)(result + 192) = 0u;
    *(_OWORD *)(result + 208) = 0u;
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)result = a2 - 2;
    LOBYTE(a2) = 2;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  *(_BYTE *)(result + 328) = a2;
  return result;
}

ValueMetadata *type metadata accessor for LogicalPlanType()
{
  return &type metadata for LogicalPlanType;
}

uint64_t *initializeBufferWithCopyOfBuffer for SQLParseResult(uint64_t *a1, uint64_t *a2, int *a3)
{
  uint64_t *v4;
  int v5;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  void (*v11)(char *, char *, uint64_t);
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  v4 = a1;
  v5 = *(_DWORD *)(*((_QWORD *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    v22 = *a2;
    *v4 = *a2;
    v4 = (uint64_t *)(v22 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    a1[1] = a2[1];
    v7 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
    v8 = (char *)v4 + v7;
    v9 = (char *)a2 + v7;
    v10 = type metadata accessor for UnknownStorage();
    v11 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v10 - 8) + 16);
    swift_bridgeObjectRetain();
    v11(v8, v9, v10);
    v12 = a3[5];
    v13 = (char *)v4 + v12;
    v14 = (char *)a2 + v12;
    *(_DWORD *)v13 = *(_DWORD *)((char *)a2 + v12);
    *((_QWORD *)v13 + 1) = *(uint64_t *)((char *)a2 + v12 + 8);
    v15 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
    v16 = &v13[v15];
    v17 = &v14[v15];
    swift_bridgeObjectRetain();
    v11(v16, v17, v10);
    v18 = a3[7];
    *(uint64_t *)((char *)v4 + a3[6]) = *(uint64_t *)((char *)a2 + a3[6]);
    v19 = (uint64_t *)((char *)v4 + v18);
    v20 = (uint64_t *)((char *)a2 + v18);
    v21 = v20[1];
    *v19 = *v20;
    v19[1] = v21;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  return v4;
}

uint64_t destroy for SQLParseResult(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  uint64_t v7;
  uint64_t ScanResult;

  swift_bridgeObjectRelease();
  v4 = a1 + *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  v5 = type metadata accessor for UnknownStorage();
  v6 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 8);
  v6(v4, v5);
  v7 = a1 + *(int *)(a2 + 20);
  swift_bridgeObjectRelease();
  ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v6(v7 + *(int *)(ScanResult + 24), v5);
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 16);
  swift_bridgeObjectRetain();
  v10(v7, v8, v9);
  v11 = a3[5];
  v12 = a1 + v11;
  v13 = a2 + v11;
  *(_DWORD *)v12 = *(_DWORD *)(a2 + v11);
  *(_QWORD *)(v12 + 8) = *(_QWORD *)(a2 + v11 + 8);
  v14 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v15 = v12 + v14;
  v16 = v13 + v14;
  swift_bridgeObjectRetain();
  v10(v15, v16, v9);
  v17 = a3[7];
  *(_QWORD *)(a1 + a3[6]) = *(_QWORD *)(a2 + a3[6]);
  v18 = (_QWORD *)(a1 + v17);
  v19 = (_QWORD *)(a2 + v17);
  v20 = v19[1];
  *v18 = *v19;
  v18[1] = v20;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t ScanResult;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 24);
  v10(v7, v8, v9);
  v11 = a3[5];
  v12 = a1 + v11;
  v13 = a2 + v11;
  *(_DWORD *)v12 = *(_DWORD *)(a2 + v11);
  *(_QWORD *)(v12 + 8) = *(_QWORD *)(a2 + v11 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v10(v12 + *(int *)(ScanResult + 24), v13 + *(int *)(ScanResult + 24), v9);
  *(_QWORD *)(a1 + a3[6]) = *(_QWORD *)(a2 + a3[6]);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v15 = a3[7];
  v16 = (_QWORD *)(a1 + v15);
  v17 = (_QWORD *)(a2 + v15);
  *v16 = *v17;
  v16[1] = v17[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t initializeWithTake for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t ScanResult;
  uint64_t v15;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 32);
  v10(v7, v8, v9);
  v11 = a3[5];
  v12 = a1 + v11;
  v13 = a2 + v11;
  *(_DWORD *)v12 = *(_DWORD *)(a2 + v11);
  *(_QWORD *)(v12 + 8) = *(_QWORD *)(a2 + v11 + 8);
  ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v10(v12 + *(int *)(ScanResult + 24), v13 + *(int *)(ScanResult + 24), v9);
  v15 = a3[7];
  *(_QWORD *)(a1 + a3[6]) = *(_QWORD *)(a2 + a3[6]);
  *(_OWORD *)(a1 + v15) = *(_OWORD *)(a2 + v15);
  return a1;
}

uint64_t assignWithTake for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t ScanResult;
  uint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 40);
  v10(v7, v8, v9);
  v11 = a3[5];
  v12 = a1 + v11;
  v13 = a2 + v11;
  *(_DWORD *)v12 = *(_DWORD *)(a2 + v11);
  *(_QWORD *)(v12 + 8) = *(_QWORD *)(a2 + v11 + 8);
  swift_bridgeObjectRelease();
  ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v10(v12 + *(int *)(ScanResult + 24), v13 + *(int *)(ScanResult + 24), v9);
  *(_QWORD *)(a1 + a3[6]) = *(_QWORD *)(a2 + a3[6]);
  swift_bridgeObjectRelease();
  v15 = a3[7];
  v16 = (_QWORD *)(a1 + v15);
  v17 = (uint64_t *)(a2 + v15);
  v19 = *v17;
  v18 = v17[1];
  *v16 = v19;
  v16[1] = v18;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLParseResult()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t sub_18DB3F234(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ParseResult;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t ScanResult;
  uint64_t v12;
  unint64_t v14;

  ParseResult = type metadata accessor for PgQuery_ParseResult(0);
  v7 = *(_QWORD *)(ParseResult - 8);
  if (*(_DWORD *)(v7 + 84) == (_DWORD)a2)
  {
    v8 = ParseResult;
    v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    v10 = a1;
    return v9(v10, a2, v8);
  }
  ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v12 = *(_QWORD *)(ScanResult - 8);
  if (*(_DWORD *)(v12 + 84) == (_DWORD)a2)
  {
    v8 = ScanResult;
    v10 = a1 + *(int *)(a3 + 20);
    v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 48);
    return v9(v10, a2, v8);
  }
  v14 = *(_QWORD *)(a1 + *(int *)(a3 + 24));
  if (v14 >= 0xFFFFFFFF)
    LODWORD(v14) = -1;
  return (v14 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLParseResult()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

uint64_t sub_18DB3F2E8(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t ParseResult;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t result;
  uint64_t v14;

  ParseResult = type metadata accessor for PgQuery_ParseResult(0);
  v9 = *(_QWORD *)(ParseResult - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    v10 = ParseResult;
    v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
    v12 = a1;
    return v11(v12, a2, a2, v10);
  }
  result = type metadata accessor for PgQuery_ScanResult(0);
  v14 = *(_QWORD *)(result - 8);
  if (*(_DWORD *)(v14 + 84) == a3)
  {
    v10 = result;
    v12 = a1 + *(int *)(a4 + 20);
    v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 56);
    return v11(v12, a2, a2, v10);
  }
  *(_QWORD *)(a1 + *(int *)(a4 + 24)) = (a2 - 1);
  return result;
}

uint64_t type metadata completion function for SQLParseResult()
{
  uint64_t result;
  unint64_t v1;
  unint64_t v2;

  result = type metadata accessor for PgQuery_ParseResult(319);
  if (v1 <= 0x3F)
  {
    result = type metadata accessor for PgQuery_ScanResult(319);
    if (v2 <= 0x3F)
    {
      swift_initStructMetadata();
      return 0;
    }
  }
  return result;
}

void *type metadata accessor for LogicalPlanType.CodingKeys()
{
  return &unk_1E263A560;
}

void *type metadata accessor for LogicalPlanType.SelectCoreCodingKeys()
{
  return &unk_1E263A5F0;
}

void *type metadata accessor for LogicalPlanType.MaterializedViewCodingKeys()
{
  return &unk_1E263A680;
}

uint64_t getEnumTagSinglePayload for LogicalPlan.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFD)
    goto LABEL_17;
  if (a2 + 3 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 3) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 3;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 3;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 3;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 4;
  v8 = v6 - 4;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for LogicalPlan.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 3 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 3) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFD)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFC)
    return ((uint64_t (*)(void))((char *)&loc_18DB3F53C + 4 * byte_18DC2D283[v4]))();
  *a1 = a2 + 3;
  return ((uint64_t (*)(void))((char *)sub_18DB3F570 + 4 * byte_18DC2D27E[v4]))();
}

uint64_t sub_18DB3F570(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F578(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB3F580);
  return result;
}

uint64_t sub_18DB3F58C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB3F594);
  *(_BYTE *)result = a2 + 3;
  return result;
}

uint64_t sub_18DB3F598(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F5A0(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for LogicalPlan.CodingKeys()
{
  return &type metadata for LogicalPlan.CodingKeys;
}

void *type metadata accessor for MaterializedView.CodingKeys()
{
  return &unk_1E263AB20;
}

uint64_t storeEnumTagSinglePayload for SQLRawDataType(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 4 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 4) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFC)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFB)
    return ((uint64_t (*)(void))((char *)&loc_18DB3F618 + 4 * byte_18DC2D28D[v4]))();
  *a1 = a2 + 4;
  return ((uint64_t (*)(void))((char *)sub_18DB3F64C + 4 * byte_18DC2D288[v4]))();
}

uint64_t sub_18DB3F64C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F654(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB3F65CLL);
  return result;
}

uint64_t sub_18DB3F668(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB3F670);
  *(_BYTE *)result = a2 + 4;
  return result;
}

uint64_t sub_18DB3F674(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F67C(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

void *type metadata accessor for SelectCore.CodingKeys()
{
  return &unk_1E26373E0;
}

uint64_t getEnumTagSinglePayload for ResultColumn.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFE)
    goto LABEL_17;
  if (a2 + 2 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 2) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 2;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 2;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 2;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 3;
  v8 = v6 - 3;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for ResultColumn.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 2 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 2) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFE)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFD)
    return ((uint64_t (*)(void))((char *)&loc_18DB3F774 + 4 * byte_18DC2D297[v4]))();
  *a1 = a2 + 2;
  return ((uint64_t (*)(void))((char *)sub_18DB3F7A8 + 4 * byte_18DC2D292[v4]))();
}

uint64_t sub_18DB3F7A8(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F7B0(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB3F7B8);
  return result;
}

uint64_t sub_18DB3F7C4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB3F7CCLL);
  *(_BYTE *)result = a2 + 2;
  return result;
}

uint64_t sub_18DB3F7D0(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F7D8(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

void *type metadata accessor for ResultColumn.CodingKeys()
{
  return &unk_1E26381B8;
}

void *type metadata accessor for FromClause.CodingKeys()
{
  return &unk_1E26372D0;
}

uint64_t storeEnumTagSinglePayload for LogicalPlanType.CodingKeys(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 1 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFF)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFE)
    return ((uint64_t (*)(void))((char *)&loc_18DB3F850 + 4 * byte_18DC2D2A1[v4]))();
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_18DB3F884 + 4 * byte_18DC2D29C[v4]))();
}

uint64_t sub_18DB3F884(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F88C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x18DB3F894);
  return result;
}

uint64_t sub_18DB3F8A0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x18DB3F8A8);
  *(_BYTE *)result = a2 + 1;
  return result;
}

uint64_t sub_18DB3F8AC(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_18DB3F8B4(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

void *type metadata accessor for Schema.CodingKeys()
{
  return &unk_1E263FBD0;
}

uint64_t storeEnumTagSinglePayload for LogicalPlanType.SelectCoreCodingKeys(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t v4;

  if ((a3 + 1) >= 0x10000)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) < 0x100)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3)
    v4 = v4;
  else
    v4 = 0;
  if (a2)
    return ((uint64_t (*)(void))((char *)sub_18DB3F910 + 4 * byte_18DC2D2A6[v4]))();
  else
    return ((uint64_t (*)(void))((char *)sub_18DB3F930 + 4 * byte_18DC2D2AB[v4]))();
}

_BYTE *sub_18DB3F910(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

_BYTE *sub_18DB3F930(_BYTE *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_18DB3F938(_DWORD *result, int a2)
{
  *result = a2;
  return result;
}

_WORD *sub_18DB3F940(_WORD *result, __int16 a2)
{
  *result = a2;
  return result;
}

_WORD *sub_18DB3F948(_WORD *result)
{
  *result = 0;
  return result;
}

_DWORD *sub_18DB3F950(_DWORD *result)
{
  *result = 0;
  return result;
}

void *type metadata accessor for DatabaseCatalog.CodingKeys()
{
  return &unk_1E263A4A8;
}

uint64_t type metadata accessor for PlanResources(uint64_t a1)
{
  return type metadata accessor for PgQuery_Node._StorageClass(a1, (uint64_t *)&type metadata singleton initialization cache for PlanResources);
}

uint64_t type metadata accessor for SQLTokenInformation(uint64_t a1)
{
  return type metadata accessor for PgQuery_Node._StorageClass(a1, (uint64_t *)&type metadata singleton initialization cache for SQLTokenInformation);
}

uint64_t partial apply for closure #1 in SQLParseResult.plans(with:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t v4;

  return closure #1 in SQLParseResult.plans(with:)(a1, a2, a3, *(_QWORD *)(v4 + 16), *(_QWORD *)(v4 + 24), a4);
}

void *outlined init with take of LogicalPlanType(void *__src, void *__dst)
{
  return memcpy(__dst, __src, 0x149uLL);
}

uint64_t partial apply for specialized closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(_QWORD *a1)
{
  return partial apply for specialized closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(a1) & 1;
}

{
  uint64_t v1;
  _QWORD *v2;

  v2 = *(_QWORD **)(v1 + 16);
  if (*a1 == *v2 && a1[1] == v2[1])
    return 1;
  else
    return _stringCompareWithSmolCheck(_:_:expecting:)() & 1;
}

uint64_t sub_18DB4028C()
{
  swift_bridgeObjectRelease();
  return swift_deallocObject();
}

uint64_t sub_18DB402B0()
{
  return swift_deallocObject();
}

uint64_t partial apply for closure #1 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  return closure #1 in SelectCore.init(select:resources:)(a1, *(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24), a2, a3);
}

uint64_t outlined destroy of FromClause(uint64_t a1)
{
  destroy for FromClause(a1);
  return a1;
}

uint64_t partial apply for closure #3 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;

  return closure #3 in SelectCore.init(select:resources:)(a1, *(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24), a2, a3);
}

uint64_t *initializeBufferWithCopyOfBuffer for SQLTokenInformation(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v4;
  int v5;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  void (*v11)(char *, char *, uint64_t);
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;

  v4 = a1;
  v5 = *(_DWORD *)(*(_QWORD *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    v16 = *a2;
    *v4 = *a2;
    v4 = (uint64_t *)(v16 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    a1[1] = a2[1];
    v7 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
    v8 = (char *)v4 + v7;
    v9 = (char *)a2 + v7;
    v10 = type metadata accessor for UnknownStorage();
    v11 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v10 - 8) + 16);
    swift_bridgeObjectRetain();
    v11(v8, v9, v10);
    v12 = *(int *)(a3 + 20);
    v13 = (uint64_t *)((char *)v4 + v12);
    v14 = (uint64_t *)((char *)a2 + v12);
    v15 = v14[1];
    *v13 = *v14;
    v13[1] = v15;
    swift_bridgeObjectRetain();
  }
  return v4;
}

uint64_t destroy for SQLTokenInformation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  swift_bridgeObjectRelease();
  v2 = a1 + *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v3 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v3 - 8) + 8))(v2, v3);
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 16);
  swift_bridgeObjectRetain();
  v10(v7, v8, v9);
  v11 = *(int *)(a3 + 20);
  v12 = (_QWORD *)(a1 + v11);
  v13 = (_QWORD *)(a2 + v11);
  v14 = v13[1];
  *v12 = *v13;
  v12[1] = v14;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 24))(v7, v8, v9);
  v10 = *(int *)(a3 + 20);
  v11 = (_QWORD *)(a1 + v10);
  v12 = (_QWORD *)(a2 + v10);
  *v11 = *v12;
  v11[1] = v12[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t initializeWithTake for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 32))(v7, v8, v9);
  *(_OWORD *)(a1 + *(int *)(a3 + 20)) = *(_OWORD *)(a2 + *(int *)(a3 + 20));
  return a1;
}

uint64_t assignWithTake for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v7 = a1 + v6;
  v8 = a2 + v6;
  v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 40))(v7, v8, v9);
  v10 = *(int *)(a3 + 20);
  v11 = (_QWORD *)(a1 + v10);
  v12 = (uint64_t *)(a2 + v10);
  v14 = *v12;
  v13 = v12[1];
  *v11 = v14;
  v11[1] = v13;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLTokenInformation()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t sub_18DB40748(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ScanResult;
  uint64_t v7;
  unint64_t v9;

  ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v7 = *(_QWORD *)(ScanResult - 8);
  if (*(_DWORD *)(v7 + 84) == (_DWORD)a2)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(a1, a2, ScanResult);
  v9 = *(_QWORD *)(a1 + *(int *)(a3 + 20) + 8);
  if (v9 >= 0xFFFFFFFF)
    LODWORD(v9) = -1;
  return (v9 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLTokenInformation()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

uint64_t sub_18DB407D4(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;

  result = type metadata accessor for PgQuery_ScanResult(0);
  v9 = *(_QWORD *)(result - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56))(a1, a2, a2, result);
  *(_QWORD *)(a1 + *(int *)(a4 + 20) + 8) = (a2 - 1);
  return result;
}

uint64_t type metadata completion function for SQLTokenInformation()
{
  uint64_t result;
  unint64_t v1;

  result = type metadata accessor for PgQuery_ScanResult(319);
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t *initializeBufferWithCopyOfBuffer for PlanResources(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  void (*v13)(char *, char *, uint64_t);
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v3 = *(_DWORD *)(*(_QWORD *)(a3 - 8) + 80);
  v4 = *a2;
  *a1 = *a2;
  if ((v3 & 0x20000) != 0)
  {
    v5 = (uint64_t *)(v4 + ((v3 + 16) & ~(unint64_t)v3));
    swift_retain();
  }
  else
  {
    v5 = a1;
    v6 = *(int *)(a3 + 20);
    v7 = (char *)a1 + v6;
    v8 = (char *)a2 + v6;
    *(_DWORD *)v7 = *(_DWORD *)((char *)a2 + v6);
    *((_QWORD *)v7 + 1) = *(uint64_t *)((char *)a2 + v6 + 8);
    v9 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
    v10 = &v7[v9];
    v11 = &v8[v9];
    v12 = type metadata accessor for UnknownStorage();
    v13 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v12 - 8) + 16);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    v13(v10, v11, v12);
    v14 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
    v15 = &v7[v14];
    v16 = &v8[v14];
    v17 = *((_QWORD *)v16 + 1);
    *(_QWORD *)v15 = *(_QWORD *)v16;
    *((_QWORD *)v15 + 1) = v17;
    swift_bridgeObjectRetain();
  }
  return v5;
}

uint64_t destroy for PlanResources(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  swift_bridgeObjectRelease();
  v4 = a1 + *(int *)(a2 + 20);
  swift_bridgeObjectRelease();
  v5 = v4 + *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v6 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 8))(v5, v6);
  type metadata accessor for SQLTokenInformation(0);
  return swift_bridgeObjectRelease();
}

_QWORD *initializeWithCopy for PlanResources(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  void (*v11)(char *, char *, uint64_t);
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;

  *a1 = *a2;
  v4 = *(int *)(a3 + 20);
  v5 = (char *)a1 + v4;
  v6 = (char *)a2 + v4;
  *(_DWORD *)v5 = *(_DWORD *)((char *)a2 + v4);
  *((_QWORD *)v5 + 1) = *(_QWORD *)((char *)a2 + v4 + 8);
  v7 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v8 = &v5[v7];
  v9 = &v6[v7];
  v10 = type metadata accessor for UnknownStorage();
  v11 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v10 - 8) + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  v11(v8, v9, v10);
  v12 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
  v13 = &v5[v12];
  v14 = &v6[v12];
  v15 = *((_QWORD *)v14 + 1);
  *(_QWORD *)v13 = *(_QWORD *)v14;
  *((_QWORD *)v13 + 1) = v15;
  swift_bridgeObjectRetain();
  return a1;
}

_QWORD *assignWithCopy for PlanResources(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;

  *a1 = *a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v6 = *(int *)(a3 + 20);
  v7 = (char *)a1 + v6;
  v8 = (char *)a2 + v6;
  *(_DWORD *)v7 = *(_DWORD *)((char *)a2 + v6);
  *((_QWORD *)v7 + 1) = *(_QWORD *)((char *)a2 + v6 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v9 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v10 = &v7[v9];
  v11 = &v8[v9];
  v12 = type metadata accessor for UnknownStorage();
  (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v12 - 8) + 24))(v10, v11, v12);
  v13 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
  v14 = &v7[v13];
  v15 = &v8[v13];
  *(_QWORD *)v14 = *(_QWORD *)v15;
  *((_QWORD *)v14 + 1) = *((_QWORD *)v15 + 1);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

_QWORD *initializeWithTake for PlanResources(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;

  *a1 = *a2;
  v4 = *(int *)(a3 + 20);
  v5 = (char *)a1 + v4;
  v6 = (char *)a2 + v4;
  *(_DWORD *)v5 = *(_DWORD *)((char *)a2 + v4);
  *((_QWORD *)v5 + 1) = *(_QWORD *)((char *)a2 + v4 + 8);
  v7 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v8 = &v5[v7];
  v9 = &v6[v7];
  v10 = type metadata accessor for UnknownStorage();
  (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v10 - 8) + 32))(v8, v9, v10);
  v11 = type metadata accessor for SQLTokenInformation(0);
  *(_OWORD *)&v5[*(int *)(v11 + 20)] = *(_OWORD *)&v6[*(int *)(v11 + 20)];
  return a1;
}

_QWORD *assignWithTake for PlanResources(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;

  *a1 = *a2;
  swift_bridgeObjectRelease();
  v6 = *(int *)(a3 + 20);
  v7 = (char *)a1 + v6;
  v8 = (char *)a2 + v6;
  *(_DWORD *)v7 = *(_DWORD *)((char *)a2 + v6);
  *((_QWORD *)v7 + 1) = *(_QWORD *)((char *)a2 + v6 + 8);
  swift_bridgeObjectRelease();
  v9 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  v10 = &v7[v9];
  v11 = &v8[v9];
  v12 = type metadata accessor for UnknownStorage();
  (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v12 - 8) + 40))(v10, v11, v12);
  v13 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
  v14 = &v7[v13];
  v15 = &v8[v13];
  v17 = *(_QWORD *)v15;
  v16 = *((_QWORD *)v15 + 1);
  *(_QWORD *)v14 = v17;
  *((_QWORD *)v14 + 1) = v16;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for PlanResources()
{
  return swift_getEnumTagSinglePayloadGeneric();
}

uint64_t sub_18DB40D48(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v8;

  if ((_DWORD)a2 == 0x7FFFFFFF)
  {
    v4 = *(_QWORD *)a1;
    if (*(_QWORD *)a1 >= 0xFFFFFFFFuLL)
      LODWORD(v4) = -1;
    return (v4 + 1);
  }
  else
  {
    v8 = type metadata accessor for SQLTokenInformation(0);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 48))(&a1[*(int *)(a3 + 20)], a2, v8);
  }
}

uint64_t storeEnumTagSinglePayload for PlanResources()
{
  return swift_storeEnumTagSinglePayloadGeneric();
}

char *sub_18DB40DD0(char *result, uint64_t a2, int a3, uint64_t a4)
{
  char *v5;
  uint64_t v7;

  v5 = result;
  if (a3 == 0x7FFFFFFF)
  {
    *(_QWORD *)result = (a2 - 1);
  }
  else
  {
    v7 = type metadata accessor for SQLTokenInformation(0);
    return (char *)(*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 56))(&v5[*(int *)(a4 + 20)], a2, a2, v7);
  }
  return result;
}

uint64_t type metadata completion function for PlanResources()
{
  uint64_t result;
  unint64_t v1;

  result = type metadata accessor for SQLTokenInformation(319);
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

_DWORD *pg_query_init()
{
  _DWORD *result;
  const void **v1;
  pthread_key_t v2;

  result = (_DWORD *)pg_query_initialized();
  if (!*result)
  {
    *result = 1;
    MemoryContextInit();
    SetDatabaseEncoding(6u);
    pthread_key_create((pthread_key_t *)&pg_query_thread_exit_key, (void (__cdecl *)(void *))pg_query_thread_exit);
    v1 = (const void **)TopMemoryContext();
    return (_DWORD *)pthread_setspecific(v2, *v1);
  }
  return result;
}

_QWORD *pg_query_thread_exit(_QWORD *a1)
{
  _QWORD *result;

  MemoryContextDeleteChildren((uint64_t)a1);
  AllocSetDeleteFreeList((uint64_t)a1);
  (*(void (**)(_QWORD *))(a1[2] + 32))(a1);
  free(a1);
  *(_QWORD *)TopMemoryContext() = 0;
  *(_QWORD *)CurrentMemoryContext() = 0;
  result = (_QWORD *)ErrorContext();
  *result = 0;
  return result;
}

_QWORD *pg_query_free_top_memory_context(_QWORD *a1)
{
  double v2;
  _QWORD *result;

  MemoryContextDeleteChildren((uint64_t)a1);
  AllocSetDeleteFreeList((uint64_t)a1);
  (*(void (**)(_QWORD *))(a1[2] + 32))(a1);
  free(a1);
  *(_QWORD *)TopMemoryContext() = 0;
  *(_QWORD *)CurrentMemoryContext(v2) = 0;
  result = (_QWORD *)ErrorContext();
  *result = 0;
  return result;
}

_QWORD *pg_query_exit()
{
  uint64_t *v0;
  _QWORD *v1;
  double v2;
  _QWORD *result;

  v0 = (uint64_t *)TopMemoryContext();
  v1 = (_QWORD *)*v0;
  MemoryContextDeleteChildren(*v0);
  AllocSetDeleteFreeList((uint64_t)v1);
  (*(void (**)(_QWORD *))(v1[2] + 32))(v1);
  free(v1);
  *v0 = 0;
  *(_QWORD *)CurrentMemoryContext(v2) = 0;
  result = (_QWORD *)ErrorContext();
  *result = 0;
  return result;
}

uint64_t pg_query_enter_memory_context()
{
  _DWORD *initialized;
  const void **v1;
  pthread_key_t v2;
  _QWORD *v3;
  uint64_t v4;

  initialized = (_DWORD *)pg_query_initialized();
  if (*initialized)
  {
    v1 = (const void **)TopMemoryContext();
  }
  else
  {
    *initialized = 1;
    MemoryContextInit();
    SetDatabaseEncoding(6u);
    pthread_key_create((pthread_key_t *)&pg_query_thread_exit_key, (void (__cdecl *)(void *))pg_query_thread_exit);
    v1 = (const void **)TopMemoryContext();
    pthread_setspecific(v2, *v1);
  }
  AllocSetContextCreateInternal((uint64_t)*v1, "pg_query", 0, 0x2000uLL, 0x800000);
  v3 = (_QWORD *)CurrentMemoryContext();
  *v3 = v4;
  return v4;
}

uint64_t pg_query_exit_memory_context()
{
  _QWORD *v0;
  uint64_t v1;
  _QWORD *v2;

  TopMemoryContext();
  v0 = (_QWORD *)CurrentMemoryContext();
  *v0 = v1;
  return MemoryContextDelete(v2);
}

void pg_query_free_error(uint64_t a1)
{
  void *v2;

  free(*(void **)a1);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  v2 = *(void **)(a1 + 32);
  if (v2)
    free(v2);
  free((void *)a1);
}

char *pg_query_deparse_protobuf(unsigned int a1, unsigned __int8 *a2)
{
  uint64_t enter_memory_context;
  int **v5;
  int *v6;
  int **v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  char *v13;
  uint64_t protobuf_to_nodes;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  BOOL v26;
  char *v27;
  char *v28;
  const char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  BOOL v45;
  char *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  BOOL v61;
  char **v62;
  char *v63;
  char *v64;
  char *v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  BOOL v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  BOOL v93;
  char *v94;
  char *v95;
  uint64_t v96;
  char *v97;
  const char *v98;
  uint64_t v99;
  char *v100;
  char *v101;
  uint64_t v102;
  char *v103;
  char *v104;
  char *v105;
  char *v106;
  size_t v107;
  _BYTE *v108;
  char *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  BOOL v116;
  char *v117;
  unsigned int v118;
  int *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  char *v128;
  char *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  uint64_t v136;
  char *v137;
  int v138;
  char v139;
  uint64_t v140;
  char *v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  char *v147;
  uint64_t v148;
  BOOL v149;
  char *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  BOOL v157;
  char *v158;
  char *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  BOOL v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  char *v171;
  char *v172;
  unsigned __int8 v173;
  unsigned __int8 *v174;
  unsigned __int8 *v175;
  int *v176;
  int v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  char *v186;
  char *v187;
  char *v188;
  char *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  char *v196;
  uint64_t v197;
  BOOL v198;
  int v199;
  char *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  char *v208;
  uint64_t v209;
  BOOL v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  uint64_t v216;
  BOOL v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  char *v222;
  uint64_t v223;
  BOOL v224;
  char *v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  char *v230;
  uint64_t v231;
  BOOL v232;
  char *v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  char *v240;
  char *v241;
  unsigned __int8 v242;
  unsigned __int8 *v243;
  unsigned __int8 *v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  char **v251;
  int v252;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  BOOL v261;
  uint64_t v262;
  int v263;
  uint64_t v264;
  uint64_t v265;
  const char *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  char *v272;
  uint64_t v273;
  BOOL v274;
  uint64_t v275;
  char *v276;
  int v277;
  int v278;
  char *v279;
  int v280;
  int v281;
  int v282;
  char *v283;
  char *v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  char *v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  BOOL v298;
  unsigned int v299;
  unsigned int v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  unsigned int v306;
  unsigned int v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  char *v312;
  uint64_t v313;
  BOOL v314;
  uint64_t v315;
  int v316;
  uint64_t v317;
  char *v318;
  uint64_t v319;
  const char *v320;
  char *v321;
  char *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  BOOL v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  BOOL v333;
  uint64_t v334;
  char *v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  const char *v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  char *v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  char *v351;
  uint64_t v352;
  BOOL v353;
  char *v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  char *v360;
  uint64_t v361;
  char *v362;
  char *v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  BOOL v369;
  char *v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  char *v375;
  uint64_t v376;
  BOOL v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  BOOL v382;
  _BYTE *v383;
  char *v384;
  uint64_t v385;
  char *v386;
  char *v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  char *v392;
  uint64_t v393;
  BOOL v394;
  char *v395;
  char *v396;
  char *v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  BOOL v404;
  char *v405;
  uint64_t v406;
  char *v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  char *v411;
  char *v412;
  uint64_t v413;
  unsigned int v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  BOOL v420;
  uint64_t v421;
  char *v422;
  uint64_t v423;
  char *v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  BOOL v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  char *v436;
  uint64_t v437;
  BOOL v438;
  char *v439;
  uint64_t v440;
  uint64_t v441;
  char *v442;
  uint64_t v443;
  char *v444;
  size_t v445;
  char *v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  char *v451;
  uint64_t v452;
  BOOL v453;
  char *v454;
  uint64_t v455;
  uint64_t v456;
  char *v457;
  uint64_t v458;
  const char *v459;
  char *v460;
  size_t v461;
  uint64_t v462;
  char *v463;
  uint64_t v464;
  char *v465;
  char *v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  char *v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  char *v486;
  uint64_t v487;
  BOOL v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  char *v493;
  uint64_t v494;
  BOOL v495;
  char *v496;
  int v497;
  char *v498;
  char *v499;
  int v500;
  char *v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  char *v506;
  uint64_t v507;
  BOOL v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  BOOL v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  BOOL v534;
  uint64_t *v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  char *v547;
  BOOL v548;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  char v556;
  uint64_t v557;
  char *v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  char *v563;
  BOOL v564;
  uint64_t v565;
  char *v566;
  char *v567;
  uint64_t v568;
  uint64_t v569;
  uint64_t v570;
  uint64_t v571;
  uint64_t v572;
  BOOL v573;
  char *v574;
  char *v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  char *v580;
  uint64_t v581;
  BOOL v582;
  unsigned int v583;
  unsigned int v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  char *v589;
  uint64_t v590;
  BOOL v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  char *v596;
  uint64_t v597;
  BOOL v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  uint64_t v602;
  char *v603;
  uint64_t v604;
  BOOL v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t v608;
  uint64_t v609;
  char *v610;
  uint64_t v611;
  BOOL v612;
  char *v613;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  BOOL v618;
  uint64_t *v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  BOOL v624;
  char *v625;
  uint64_t v626;
  uint64_t v627;
  char *v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  char *v632;
  uint64_t v633;
  const char *v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  char *v640;
  char *i;
  int v642;
  char v643;
  uint64_t v644;
  uint64_t v645;
  unint64_t v646;
  char *v647;
  size_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  BOOL v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  char *v659;
  uint64_t v660;
  BOOL v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  char *v669;
  BOOL v670;
  int v671;
  char *v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  char *v678;
  uint64_t v679;
  BOOL v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  char *v685;
  uint64_t v686;
  BOOL v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  char *v692;
  uint64_t v693;
  BOOL v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  char *v699;
  uint64_t v700;
  BOOL v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  char *v706;
  uint64_t v707;
  BOOL v708;
  uint64_t v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  char *v713;
  uint64_t v714;
  BOOL v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  char *v720;
  uint64_t v721;
  BOOL v722;
  char *v723;
  char *v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  char *v731;
  uint64_t v732;
  char *v733;
  char *v734;
  char *v735;
  uint64_t v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  char *v742;
  char *v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  int v751;
  const char *v752;
  char *v753;
  uint64_t v754;
  uint64_t v755;
  char *v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  char *v762;
  uint64_t v763;
  BOOL v764;
  uint64_t v765;
  uint64_t v766;
  uint64_t v767;
  uint64_t v768;
  char *v769;
  uint64_t v770;
  BOOL v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  char *v776;
  uint64_t v777;
  BOOL v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  BOOL v783;
  int *v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  uint64_t v790;
  int v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t v795;
  uint64_t v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  const char *v801;
  uint64_t v802;
  uint64_t v803;
  char v804;
  char *v805;
  char *v806;
  uint64_t v807;
  char *v808;
  uint64_t v809;
  _BYTE *v810;
  char v811;
  char v812;
  char v813;
  char *v814;
  char v815;
  _BYTE *v816;
  char *v817;
  char v818;
  char v819;
  uint64_t v820;
  char *v821;
  int *v822;
  uint64_t v823;
  uint64_t v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t v827;
  const char *v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  _DWORD *v835;
  int v836;
  char *v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  _DWORD *v845;
  BOOL v846;
  char *v847;
  uint64_t v848;
  char *v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  char *v854;
  uint64_t v855;
  BOOL v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  char *v861;
  uint64_t v862;
  BOOL v863;
  uint64_t v864;
  int v865;
  char *v866;
  uint64_t v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  uint64_t v871;
  uint64_t v872;
  uint64_t v873;
  uint64_t v874;
  uint64_t v875;
  uint64_t v876;
  uint64_t v877;
  uint64_t v878;
  uint64_t v879;
  uint64_t v880;
  char *v881;
  uint64_t v882;
  uint64_t v883;
  uint64_t v884;
  BOOL v885;
  uint64_t v886;
  uint64_t v887;
  BOOL v888;
  char *v889;
  char *v890;
  char *v891;
  char *v892;
  char *v893;
  uint64_t v894;
  uint64_t v895;
  uint64_t v896;
  uint64_t v897;
  BOOL v898;
  uint64_t v899;
  char *v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  uint64_t v904;
  uint64_t v905;
  BOOL v906;
  char *v907;
  uint64_t v908;
  int v909;
  uint64_t *v910;
  unint64_t v911;
  uint64_t v912;
  char *v913;
  uint64_t v914;
  BOOL v915;
  uint64_t v916;
  uint64_t v917;
  uint64_t v918;
  uint64_t v919;
  uint64_t v920;
  BOOL v921;
  uint64_t v922;
  int v923;
  uint64_t *v924;
  unint64_t v925;
  uint64_t v926;
  char *v927;
  uint64_t v928;
  BOOL v929;
  uint64_t v930;
  uint64_t v931;
  int v932;
  uint64_t *v933;
  unint64_t v934;
  uint64_t v935;
  char *v936;
  uint64_t v937;
  BOOL v938;
  uint64_t v939;
  uint64_t v940;
  uint64_t v941;
  uint64_t v942;
  char *v943;
  uint64_t v944;
  BOOL v945;
  char *v946;
  char *v947;
  uint64_t v948;
  uint64_t v949;
  uint64_t v950;
  uint64_t v951;
  char *v952;
  uint64_t v953;
  BOOL v954;
  char *v955;
  uint64_t v956;
  uint64_t v957;
  uint64_t v958;
  uint64_t v959;
  uint64_t v960;
  uint64_t v961;
  uint64_t v962;
  uint64_t v963;
  uint64_t v964;
  char *v965;
  uint64_t v966;
  BOOL v967;
  uint64_t v968;
  uint64_t v969;
  uint64_t v970;
  uint64_t v971;
  char *v972;
  uint64_t v973;
  BOOL v974;
  uint64_t v975;
  uint64_t v976;
  uint64_t v977;
  uint64_t v978;
  char *v979;
  uint64_t v980;
  BOOL v981;
  char *v982;
  uint64_t v983;
  uint64_t v984;
  uint64_t v985;
  uint64_t v986;
  char *v987;
  uint64_t v988;
  BOOL v989;
  uint64_t v990;
  uint64_t v991;
  uint64_t v992;
  uint64_t v993;
  uint64_t v994;
  char *v995;
  uint64_t v996;
  BOOL v997;
  uint64_t v998;
  uint64_t v999;
  uint64_t v1000;
  uint64_t v1001;
  char *v1002;
  uint64_t v1003;
  BOOL v1004;
  uint64_t v1005;
  uint64_t v1006;
  uint64_t v1007;
  uint64_t v1008;
  char *v1009;
  uint64_t v1010;
  BOOL v1011;
  uint64_t v1012;
  char *v1013;
  char *v1014;
  uint64_t v1015;
  int v1016;
  uint64_t *v1017;
  unint64_t v1018;
  uint64_t v1019;
  char *v1020;
  uint64_t v1021;
  BOOL v1022;
  int v1023;
  uint64_t *v1024;
  unint64_t v1025;
  uint64_t v1026;
  char *v1027;
  uint64_t v1028;
  BOOL v1029;
  char *v1030;
  uint64_t v1031;
  uint64_t v1032;
  uint64_t v1033;
  uint64_t v1034;
  char *v1035;
  uint64_t v1036;
  BOOL v1037;
  uint64_t v1038;
  uint64_t v1039;
  uint64_t v1040;
  uint64_t v1041;
  char *v1042;
  uint64_t v1043;
  BOOL v1044;
  uint64_t v1045;
  uint64_t v1046;
  uint64_t v1047;
  uint64_t v1048;
  char *v1049;
  uint64_t v1050;
  BOOL v1051;
  uint64_t v1052;
  uint64_t v1053;
  uint64_t v1054;
  uint64_t v1055;
  char *v1056;
  uint64_t v1057;
  BOOL v1058;
  uint64_t v1059;
  uint64_t v1060;
  uint64_t v1061;
  uint64_t v1062;
  char *v1063;
  uint64_t v1064;
  BOOL v1065;
  uint64_t v1066;
  uint64_t v1067;
  uint64_t v1068;
  uint64_t v1069;
  char *v1070;
  uint64_t v1071;
  BOOL v1072;
  uint64_t v1073;
  uint64_t v1074;
  uint64_t v1075;
  uint64_t v1076;
  char *v1077;
  uint64_t v1078;
  BOOL v1079;
  uint64_t v1080;
  uint64_t v1081;
  uint64_t v1082;
  uint64_t v1083;
  char *v1084;
  uint64_t v1085;
  BOOL v1086;
  char *v1087;
  uint64_t v1088;
  uint64_t v1089;
  uint64_t v1090;
  uint64_t v1091;
  char *v1092;
  uint64_t v1093;
  BOOL v1094;
  uint64_t v1095;
  uint64_t v1096;
  uint64_t v1097;
  uint64_t v1098;
  uint64_t v1099;
  uint64_t v1100;
  uint64_t v1101;
  uint64_t v1102;
  int v1103;
  uint64_t *v1104;
  unint64_t v1105;
  uint64_t v1106;
  char *v1107;
  uint64_t v1108;
  BOOL v1109;
  int v1110;
  uint64_t *v1111;
  unint64_t v1112;
  uint64_t v1113;
  char *v1114;
  uint64_t v1115;
  BOOL v1116;
  uint64_t v1117;
  char *v1118;
  uint64_t v1119;
  uint64_t v1120;
  uint64_t v1121;
  uint64_t v1122;
  char *v1123;
  uint64_t v1124;
  BOOL v1125;
  uint64_t v1126;
  uint64_t v1127;
  uint64_t v1128;
  uint64_t v1129;
  char *v1130;
  uint64_t v1131;
  BOOL v1132;
  uint64_t v1133;
  uint64_t v1134;
  uint64_t v1135;
  uint64_t v1136;
  char *v1137;
  uint64_t v1138;
  BOOL v1139;
  uint64_t v1140;
  uint64_t v1141;
  uint64_t v1142;
  uint64_t v1143;
  char *v1144;
  uint64_t v1145;
  BOOL v1146;
  char *v1147;
  uint64_t v1148;
  uint64_t v1149;
  uint64_t v1150;
  uint64_t v1151;
  uint64_t v1152;
  uint64_t v1153;
  BOOL v1154;
  uint64_t v1155;
  uint64_t v1156;
  uint64_t v1157;
  uint64_t v1158;
  uint64_t v1159;
  BOOL v1160;
  uint64_t v1161;
  char *v1162;
  uint64_t v1163;
  uint64_t v1164;
  uint64_t v1165;
  uint64_t v1166;
  char *v1167;
  uint64_t v1168;
  BOOL v1169;
  uint64_t v1170;
  _BYTE *v1171;
  char *v1172;
  char *v1173;
  uint64_t v1174;
  int v1175;
  uint64_t *v1176;
  unint64_t v1177;
  uint64_t v1178;
  char *v1179;
  uint64_t v1180;
  BOOL v1181;
  char *v1182;
  char *v1183;
  uint64_t v1184;
  uint64_t v1185;
  uint64_t v1186;
  uint64_t v1187;
  char *v1188;
  uint64_t v1189;
  BOOL v1190;
  char *v1191;
  int v1192;
  char *v1193;
  int v1194;
  uint64_t *v1195;
  uint64_t v1196;
  uint64_t v1197;
  uint64_t v1198;
  uint64_t v1199;
  uint64_t *v1200;
  uint64_t v1201;
  char *v1202;
  uint64_t v1203;
  uint64_t v1204;
  int v1205;
  uint64_t v1206;
  uint64_t v1207;
  uint64_t v1208;
  uint64_t v1209;
  char *v1210;
  uint64_t v1211;
  BOOL v1212;
  uint64_t v1213;
  uint64_t v1214;
  char *v1215;
  uint64_t v1216;
  char *v1217;
  char *result;
  uint64_t v1219;
  uint64_t v1220;
  uint64_t v1221;
  uint64_t v1222;
  int v1223;
  uint64_t v1224;
  int v1225;
  uint64_t v1226;
  _QWORD *v1227;
  uint64_t v1228;
  int **v1229;
  int *v1230;
  char *__s1;
  uint64_t v1232;
  uint64_t v1233;
  int v1234[50];
  uint64_t v1235;

  v1235 = *MEMORY[0x1E0C80C00];
  __s1 = 0;
  v1232 = 0;
  v1233 = 0;
  enter_memory_context = pg_query_enter_memory_context();
  v5 = (int **)PG_exception_stack();
  v6 = *v5;
  v7 = v5;
  v8 = (_QWORD *)error_context_stack();
  v9 = *v8;
  v10 = v8;
  memset(v1234, 0, 196);
  if (!sigsetjmp(v1234, 0))
  {
    v1227 = v10;
    v1228 = v9;
    v1230 = v6;
    v1229 = v7;
    *v7 = v1234;
    protobuf_to_nodes = pg_query_protobuf_to_nodes(a1, a2);
    initStringInfo((uint64_t)&__s1);
    if (!protobuf_to_nodes || *(int *)(protobuf_to_nodes + 4) < 1)
    {
LABEL_2107:
      v13 = strdup(__s1);
      v6 = v1230;
      v9 = v1228;
      v7 = v1229;
      v10 = v1227;
      goto LABEL_2108;
    }
    v15 = protobuf_to_nodes;
    v16 = 0;
    v1226 = protobuf_to_nodes;
    while (2)
    {
      v17 = *(_QWORD *)(v15 + 16) + 8 * (int)v16;
      v18 = *(_QWORD *)(*(_QWORD *)v17 + 8);
      if (!v18)
        pg_query_deparse_protobuf_cold_1();
      v19 = *(_QWORD *)(*(_QWORD *)v17 + 8);
      switch(*(_DWORD *)v18)
      {
        case 0xE9:
          deparseInsertStmt(&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0xEA:
          deparseDeleteStmt(&__s1, *(uint64_t **)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0xEB:
          deparseUpdateStmt(&__s1, *(uint64_t **)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0xEC:
          deparseSelectStmt(&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0xED:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          v278 = 0;
          v279 = "TABLE ";
          v280 = 0;
          v281 = 0;
          v282 = 0;
          switch(*(_DWORD *)(v18 + 24))
          {
            case 0x12:
              v279 = "FOREIGN TABLE ";
              goto LABEL_1315;
            case 0x13:
            case 0x15:
            case 0x16:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x30:
              goto LABEL_1317;
            case 0x14:
              v279 = "INDEX ";
              goto LABEL_1315;
            case 0x17:
              v279 = "MATERIALIZED VIEW ";
              goto LABEL_1315;
            case 0x23:
              v279 = "SEQUENCE ";
              goto LABEL_1315;
            case 0x27:
              goto LABEL_1316;
            case 0x2F:
              v281 = 9;
              v280 = 1;
              v279 = "TYPE ";
              goto LABEL_1316;
            case 0x31:
              v279 = "VIEW ";
LABEL_1315:
              v281 = 0;
              v280 = 0;
LABEL_1316:
              v278 = v281;
              v791 = v280;
              appendStringInfoString((uint64_t)&__s1, v279);
              v282 = v791;
LABEL_1317:
              v1223 = v282;
              if (*(_BYTE *)(v19 + 28))
                goto LABEL_1318;
              goto LABEL_1319;
            default:
              v1223 = 0;
              if (!*(_BYTE *)(v18 + 28))
                goto LABEL_1319;
LABEL_1318:
              appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
LABEL_1319:
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v19 + 8), v278);
              appendStringInfoChar((uint64_t)&__s1, 32);
              v798 = *(_QWORD *)(v19 + 16);
              if (!v798)
                goto LABEL_2103;
              v799 = *(_QWORD *)(v19 + 16);
              if (*(int *)(v798 + 4) < 1)
                goto LABEL_2103;
              v800 = 0;
              v1222 = *(_QWORD *)(v19 + 16);
              break;
          }
LABEL_1323:
          v801 = 0;
          v1220 = *(_QWORD *)(v799 + 16) + 8 * v800;
          v1221 = v800;
          v802 = *(_QWORD *)v1220;
          v803 = *(_QWORD *)v1220;
          v804 = 1;
          v805 = "DROP EXPRESSION";
          switch(*(_DWORD *)(*(_QWORD *)v1220 + 4))
          {
            case 0:
              if (v1223)
                v806 = "ADD ATTRIBUTE ";
              else
                v806 = "ADD COLUMN ";
              goto LABEL_1387;
            case 3:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v804 = 0;
              if (*(_QWORD *)(v803 + 32))
                v801 = "SET DEFAULT";
              else
                v801 = "DROP DEFAULT";
              goto LABEL_1389;
            case 5:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v804 = 0;
              v801 = "DROP NOT NULL";
              goto LABEL_1389;
            case 6:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v804 = 0;
              v801 = "SET NOT NULL";
              goto LABEL_1389;
            case 7:
              goto LABEL_1379;
            case 9:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v804 = 0;
              v801 = "SET STATISTICS";
              goto LABEL_1389;
            case 0xA:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v804 = 0;
              v801 = "SET";
              goto LABEL_1389;
            case 0xB:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v804 = 0;
              v801 = "RESET";
              goto LABEL_1389;
            case 0xC:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v804 = 0;
              v801 = "SET STORAGE";
              goto LABEL_1389;
            case 0xD:
              if (v1223)
                v806 = "DROP ATTRIBUTE ";
              else
                v806 = "DROP ";
              goto LABEL_1387;
            case 0xF:
              v806 = "ADD INDEX ";
              goto LABEL_1387;
            case 0x11:
              v806 = "ADD ";
              goto LABEL_1387;
            case 0x15:
            case 0x41:
              v806 = "ALTER ";
              goto LABEL_1387;
            case 0x16:
              v806 = "VALIDATE CONSTRAINT ";
              goto LABEL_1387;
            case 0x19:
              v806 = "DROP CONSTRAINT ";
              goto LABEL_1387;
            case 0x1C:
              if (v1223)
                v808 = "ALTER ATTRIBUTE ";
              else
                v808 = "ALTER COLUMN ";
              appendStringInfoString((uint64_t)&__s1, v808);
              v804 = 0;
              v801 = "TYPE";
              goto LABEL_1389;
            case 0x1D:
              v806 = "ALTER COLUMN ";
              goto LABEL_1387;
            case 0x1E:
              appendStringInfoString((uint64_t)&__s1, "OWNER TO ");
              v807 = *(_QWORD *)(v803 + 24);
              switch(*(_DWORD *)(v807 + 4))
              {
                case 0:
                  v806 = quote_identifier(*(_BYTE **)(v807 + 8));
                  goto LABEL_1387;
                case 1:
                  v806 = "CURRENT_USER";
                  goto LABEL_1387;
                case 2:
                  v806 = "SESSION_USER";
                  goto LABEL_1387;
                case 3:
                  v806 = "public";
                  goto LABEL_1387;
                default:
                  goto LABEL_1388;
              }
              goto LABEL_1388;
            case 0x1F:
              v806 = "CLUSTER ON ";
              goto LABEL_1387;
            case 0x20:
              v806 = "SET WITHOUT CLUSTER ";
              goto LABEL_1387;
            case 0x21:
              v806 = "SET LOGGED ";
              goto LABEL_1387;
            case 0x22:
              v806 = "SET UNLOGGED ";
              goto LABEL_1387;
            case 0x23:
              v806 = "SET WITHOUT OIDS ";
              goto LABEL_1387;
            case 0x24:
              v806 = "SET TABLESPACE ";
              goto LABEL_1387;
            case 0x25:
              v806 = "SET ";
              goto LABEL_1387;
            case 0x26:
              v806 = "RESET ";
              goto LABEL_1387;
            case 0x28:
            case 0x2C:
              v806 = "ENABLE TRIGGER ";
              goto LABEL_1387;
            case 0x29:
              v806 = "ENABLE ALWAYS TRIGGER ";
              goto LABEL_1387;
            case 0x2A:
              v806 = "ENABLE REPLICA TRIGGER ";
              goto LABEL_1387;
            case 0x2B:
              v806 = "DISABLE TRIGGER ";
              goto LABEL_1387;
            case 0x2D:
              v806 = "DISABLE TRIGGER ALL ";
              goto LABEL_1387;
            case 0x2E:
              v806 = "ENABLE TRIGGER USER ";
              goto LABEL_1387;
            case 0x2F:
              v806 = "DISABLE TRIGGER USER ";
              goto LABEL_1387;
            case 0x30:
              v806 = "ENABLE RULE ";
              goto LABEL_1387;
            case 0x31:
              v806 = "ENABLE ALWAYS RULE ";
              goto LABEL_1387;
            case 0x32:
              v806 = "ENABLE REPLICA RULE ";
              goto LABEL_1387;
            case 0x33:
              v806 = "DISABLE RULE ";
              goto LABEL_1387;
            case 0x34:
              v806 = "INHERIT ";
              goto LABEL_1387;
            case 0x35:
              v806 = "NO INHERIT ";
              goto LABEL_1387;
            case 0x36:
              v806 = "OF ";
              goto LABEL_1387;
            case 0x37:
              v806 = "NOT OF ";
              goto LABEL_1387;
            case 0x38:
              v806 = "REPLICA IDENTITY ";
              goto LABEL_1387;
            case 0x39:
              v806 = "ENABLE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3A:
              v806 = "DISABLE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3B:
              v806 = "FORCE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3C:
              v806 = "NO FORCE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3E:
              v806 = "ATTACH PARTITION ";
              goto LABEL_1387;
            case 0x3F:
              v806 = "DETACH PARTITION ";
LABEL_1387:
              appendStringInfoString((uint64_t)&__s1, v806);
LABEL_1388:
              v801 = 0;
              v804 = 1;
              goto LABEL_1389;
            case 0x40:
              appendStringInfoString((uint64_t)&__s1, "ALTER ");
              v804 = 0;
              v801 = "ADD";
              goto LABEL_1389;
            case 0x42:
              v805 = "DROP IDENTITY";
LABEL_1379:
              v809 = v17;
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v810 = (_BYTE *)(v802 + 44);
              v811 = 0;
              v812 = 0;
              goto LABEL_1396;
            default:
LABEL_1389:
              v805 = (char *)v801;
              v813 = v804;
              if (*(_BYTE *)(v803 + 44))
              {
                v809 = v17;
                if (*(_DWORD *)(v803 + 4))
                  v814 = "IF EXISTS ";
                else
                  v814 = "IF NOT EXISTS ";
                appendStringInfoString((uint64_t)&__s1, v814);
              }
              else
              {
                v809 = v17;
              }
              v812 = 1;
              v810 = (_BYTE *)(v803 + 44);
              v811 = v813;
LABEL_1396:
              v815 = v812;
              v816 = *(_BYTE **)(v803 + 8);
              if (v816)
              {
                v817 = quote_identifier(v816);
                appendStringInfoString((uint64_t)&__s1, v817);
                appendStringInfoChar((uint64_t)&__s1, 32);
              }
              if (*(__int16 *)(v803 + 16) >= 1)
                appendStringInfo((uint64_t)&__s1, "%d ", v792, v793, v794, v795, v796, v797, *(unsigned __int16 *)(v803 + 16));
              if ((v811 & 1) != 0)
              {
                if (*v810)
                  v818 = v815;
                else
                  v818 = 1;
                if ((v818 & 1) == 0)
LABEL_1405:
                  appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              }
              else
              {
                appendStringInfoString((uint64_t)&__s1, v805);
                appendStringInfoChar((uint64_t)&__s1, 32);
                if (*v810)
                  v819 = v815;
                else
                  v819 = 1;
                if ((v819 & 1) == 0)
                  goto LABEL_1405;
              }
              switch(*(_DWORD *)(v803 + 4))
              {
                case 0:
                case 0x1C:
                  deparseColumnDef((uint64_t)&__s1, *(_QWORD **)(v803 + 32));
                  goto LABEL_1448;
                case 3:
                  v822 = *(int **)(v803 + 32);
                  if (!v822)
                    goto LABEL_1449;
                  deparseExpr(&__s1, v822, v792, v793, v794, v795, v796, v797);
                  goto LABEL_1448;
                case 9:
                  appendStringInfo((uint64_t)&__s1, "%d", v792, v793, v794, v795, v796, v797, *(unsigned int *)(*(_QWORD *)(v803 + 32) + 8));
                  goto LABEL_1448;
                case 0xA:
                case 0xB:
                case 0x25:
                case 0x26:
                  deparseRelOptions(&__s1, *(_QWORD *)(v803 + 32));
                  goto LABEL_1448;
                case 0xC:
                  v821 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v803 + 32) + 8));
LABEL_1422:
                  appendStringInfoString((uint64_t)&__s1, v821);
                  goto LABEL_1448;
                case 0x11:
                case 0x15:
                case 0x40:
                  deparseConstraint(&__s1, *(_QWORD *)(v803 + 32));
                  goto LABEL_1448;
                case 0x1D:
                case 0x3D:
                  deparseAlterGenericOptions((uint64_t)&__s1, *(_QWORD *)(v803 + 32));
                  goto LABEL_1448;
                case 0x34:
                case 0x35:
                  deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v803 + 32), 0);
                  goto LABEL_1448;
                case 0x36:
                  deparseTypeName(&__s1, *(_QWORD *)(v803 + 32));
                  goto LABEL_1448;
                case 0x38:
                  switch(*(_BYTE *)(*(_QWORD *)(v803 + 32) + 4))
                  {
                    case 'd':
                      v821 = "DEFAULT ";
                      goto LABEL_1422;
                    case 'f':
                      v821 = "FULL ";
                      goto LABEL_1422;
                    case 'i':
                      v840 = *(_QWORD *)(v803 + 32);
                      appendStringInfoString((uint64_t)&__s1, "USING INDEX ");
                      v821 = quote_identifier(*(_BYTE **)(v840 + 8));
                      goto LABEL_1422;
                    case 'n':
                      v821 = "NOTHING ";
                      goto LABEL_1422;
                    default:
                      goto LABEL_1448;
                  }
                  goto LABEL_1448;
                case 0x3E:
                case 0x3F:
                  v820 = *(_QWORD *)(v803 + 32);
                  deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v820 + 8), 0);
                  if (*(_QWORD *)(v820 + 16))
                  {
                    appendStringInfoChar((uint64_t)&__s1, 32);
                    deparsePartitionBoundSpec(&__s1, *(_QWORD *)(v820 + 16));
                  }
                  goto LABEL_1448;
                case 0x41:
                  v823 = *(_QWORD *)(v803 + 32);
                  if (!v823 || *(int *)(v823 + 4) < 1)
                    goto LABEL_1448;
                  v824 = 0;
                  v825 = 8;
                  break;
                default:
                  goto LABEL_1449;
              }
              break;
          }
          while (1)
          {
            v826 = *(_QWORD *)(v823 + 16);
            v827 = *(_QWORD *)(v826 + 8 * v824);
            v828 = *(const char **)(v827 + 16);
            if (!strcmp(v828, "restart"))
            {
              if (*(_QWORD *)(v827 + 24))
              {
                appendStringInfoString((uint64_t)&__s1, "RESTART ");
                v835 = *(_DWORD **)(v827 + 24);
                if (*v835 != 222)
                {
                  if (*v835 == 221)
                    appendStringInfo((uint64_t)&__s1, "%d", v829, v830, v831, v832, v833, v834, v835[2]);
                  goto LABEL_1444;
                }
                v837 = (char *)*((_QWORD *)v835 + 1);
              }
              else
              {
                v837 = "RESTART";
              }
            }
            else
            {
              if (strcmp(v828, "generated"))
              {
                appendStringInfoString((uint64_t)&__s1, "SET ");
                deparseSeqOptElem(&__s1, v827);
                goto LABEL_1444;
              }
              appendStringInfoString((uint64_t)&__s1, "SET GENERATED ");
              v836 = *(_DWORD *)(*(_QWORD *)(v827 + 24) + 8);
              if (v836 == 100)
              {
                v837 = "BY DEFAULT";
              }
              else
              {
                if (v836 != 97)
                  goto LABEL_1444;
                v837 = "ALWAYS";
              }
            }
            appendStringInfoString((uint64_t)&__s1, v837);
LABEL_1444:
            v838 = *(int *)(v823 + 4);
            if (v826 + v825 && v826 + v825 < (unint64_t)(*(_QWORD *)(v823 + 16) + 8 * *(int *)(v823 + 4)))
            {
              appendStringInfoChar((uint64_t)&__s1, 32);
              v838 = *(int *)(v823 + 4);
            }
            ++v824;
            v825 += 8;
            if (v824 >= v838)
            {
LABEL_1448:
              appendStringInfoChar((uint64_t)&__s1, 32);
              v799 = v1222;
LABEL_1449:
              if (*(_DWORD *)(v803 + 40) == 1)
                appendStringInfoString((uint64_t)&__s1, "CASCADE ");
              v839 = (v1232 - 1);
              v15 = v1226;
              v17 = v809;
              if ((int)v1232 >= 1 && __s1[v839] == 32)
              {
                LODWORD(v1232) = v1232 - 1;
                __s1[v839] = 0;
              }
              if (v1220 != -8
                && v1220 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                                + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4)))
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
              v800 = v1221 + 1;
              if (v1221 + 1 < *(int *)(v799 + 4))
                goto LABEL_1323;
              goto LABEL_2103;
            }
          }
        case 0xEF:
          appendStringInfoString((uint64_t)&__s1, "ALTER DOMAIN ");
          v218 = *(_QWORD *)(v18 + 8);
          if (v218 && *(int *)(v218 + 4) >= 1)
          {
            v219 = 8;
            v220 = 0;
            do
            {
              v221 = *(_QWORD *)(v218 + 16);
              v222 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v221 + 8 * v220) + 8));
              appendStringInfoString((uint64_t)&__s1, v222);
              v223 = *(int *)(v218 + 4);
              if (v221 + v219)
                v224 = v221 + v219 >= (unint64_t)(*(_QWORD *)(v218 + 16) + 8 * v223);
              else
                v224 = 1;
              if (!v224)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v223 = *(int *)(v218 + 4);
              }
              ++v220;
              v219 += 8;
            }
            while (v220 < v223);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          switch(*(_BYTE *)(v19 + 4))
          {
            case 'C':
              appendStringInfoString((uint64_t)&__s1, "ADD ");
              deparseConstraint(&__s1, *(_QWORD *)(v19 + 24));
              goto LABEL_2103;
            case 'N':
              v27 = "DROP NOT NULL";
              goto LABEL_2102;
            case 'O':
              v27 = "SET NOT NULL";
              goto LABEL_2102;
            case 'T':
              if (*(_QWORD *)(v19 + 24))
              {
                appendStringInfoString((uint64_t)&__s1, "SET DEFAULT ");
                deparseExpr(&__s1, *(int **)(v19 + 24), v725, v726, v727, v728, v729, v730);
                goto LABEL_2103;
              }
              v27 = "DROP DEFAULT";
              break;
            case 'V':
              v158 = "VALIDATE CONSTRAINT ";
              goto LABEL_1018;
            case 'X':
              appendStringInfoString((uint64_t)&__s1, "DROP CONSTRAINT ");
              if (*(_BYTE *)(v19 + 36))
                appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              v731 = quote_identifier(*(_BYTE **)(v19 + 16));
              appendStringInfoString((uint64_t)&__s1, v731);
              if (*(_DWORD *)(v19 + 32) != 1)
                goto LABEL_2103;
              v27 = " CASCADE";
              goto LABEL_2102;
            default:
              goto LABEL_2103;
          }
          goto LABEL_2102;
        case 0xF1:
          deparseGrantStmt((uint64_t)&__s1, v18);
          goto LABEL_2103;
        case 0xF2:
          if (*(_BYTE *)(v18 + 24))
            v159 = "GRANT ";
          else
            v159 = "REVOKE ";
          appendStringInfoString((uint64_t)&__s1, v159);
          v160 = *(_QWORD *)(v18 + 8);
          if (v160 && *(int *)(v160 + 4) >= 1)
          {
            v161 = 8;
            v162 = 0;
            do
            {
              v163 = *(_QWORD *)(v160 + 16);
              deparseAccessPriv((uint64_t)&__s1, *(_QWORD *)(v163 + 8 * v162));
              if (v163 + v161)
                v164 = v163 + v161 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 8) + 16)
                                                       + 8 * *(int *)(*(_QWORD *)(v19 + 8) + 4));
              else
                v164 = 1;
              if (!v164)
                appendStringInfoChar((uint64_t)&__s1, 44);
              appendStringInfoChar((uint64_t)&__s1, 32);
              ++v162;
              v161 += 8;
            }
            while (v162 < *(int *)(v160 + 4));
          }
          if (*(_BYTE *)(v19 + 24))
            v189 = "TO ";
          else
            v189 = "FROM ";
          appendStringInfoString((uint64_t)&__s1, v189);
          deparseRoleList(&__s1, *(_QWORD *)(v19 + 16));
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_BYTE *)(v19 + 25))
            appendStringInfoString((uint64_t)&__s1, "WITH ADMIN OPTION ");
          goto LABEL_2090;
        case 0xF3:
          appendStringInfoString((uint64_t)&__s1, "ALTER DEFAULT PRIVILEGES ");
          v262 = *(_QWORD *)(v18 + 8);
          if (!v262 || *(int *)(v262 + 4) < 1)
            goto LABEL_423;
          v263 = *(_DWORD *)(v262 + 4);
          v264 = 0;
          while (1)
          {
            v265 = *(_QWORD *)(*(_QWORD *)(v262 + 16) + 8 * v264);
            v266 = *(const char **)(v265 + 16);
            if (!strcmp(v266, "schemas"))
            {
              v267 = v17;
              appendStringInfoString((uint64_t)&__s1, "IN SCHEMA ");
              v268 = *(_QWORD *)(v265 + 24);
              if (v268 && *(int *)(v268 + 4) >= 1)
              {
                v269 = 8;
                v270 = 0;
                do
                {
                  v271 = *(_QWORD *)(v268 + 16);
                  v272 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v271 + 8 * v270) + 8));
                  appendStringInfoString((uint64_t)&__s1, v272);
                  v273 = *(int *)(v268 + 4);
                  if (v271 + v269)
                    v274 = v271 + v269 >= (unint64_t)(*(_QWORD *)(v268 + 16) + 8 * v273);
                  else
                    v274 = 1;
                  if (!v274)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v273 = *(int *)(v268 + 4);
                  }
                  ++v270;
                  v269 += 8;
                }
                while (v270 < v273);
              }
            }
            else
            {
              if (strcmp(v266, "roles"))
                goto LABEL_400;
              v267 = v17;
              appendStringInfoString((uint64_t)&__s1, "FOR ROLE ");
              deparseRoleList(&__s1, *(_QWORD *)(v265 + 24));
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
            v263 = *(_DWORD *)(v262 + 4);
            v17 = v267;
LABEL_400:
            if (++v264 >= v263)
            {
LABEL_423:
              deparseGrantStmt((uint64_t)&__s1, *(_QWORD *)(v19 + 16));
              v15 = v1226;
              goto LABEL_2103;
            }
          }
        case 0xF4:
          appendStringInfoString((uint64_t)&__s1, "CLOSE ");
          v108 = *(_BYTE **)(v18 + 8);
          if (!v108)
            goto LABEL_341;
          goto LABEL_1816;
        case 0xF5:
          appendStringInfoString((uint64_t)&__s1, "CLUSTER ");
          if ((*(_BYTE *)(v18 + 24) & 2) != 0)
            appendStringInfoString((uint64_t)&__s1, "VERBOSE ");
          v275 = *(_QWORD *)(v18 + 8);
          if (v275)
          {
            deparseRangeVar((uint64_t)&__s1, v275, 0);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (!*(_QWORD *)(v18 + 16))
            goto LABEL_2090;
          appendStringInfoString((uint64_t)&__s1, "USING ");
          v276 = quote_identifier(*(_BYTE **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v276);
          goto LABEL_1308;
        case 0xF6:
          appendStringInfoString((uint64_t)&__s1, "COPY ");
          v190 = *(_QWORD *)(v18 + 8);
          if (v190)
          {
            deparseRangeVar((uint64_t)&__s1, v190, 0);
            v191 = *(_QWORD *)(v18 + 24);
            if (v191 && *(int *)(v191 + 4) >= 1)
            {
              appendStringInfoChar((uint64_t)&__s1, 40);
              v192 = *(_QWORD *)(v18 + 24);
              if (v192 && *(int *)(v192 + 4) >= 1)
              {
                v193 = 8;
                v194 = 0;
                do
                {
                  v195 = *(_QWORD *)(v192 + 16);
                  v196 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v195 + 8 * v194) + 8));
                  appendStringInfoString((uint64_t)&__s1, v196);
                  v197 = *(int *)(v192 + 4);
                  if (v195 + v193)
                    v198 = v195 + v193 >= (unint64_t)(*(_QWORD *)(v192 + 16) + 8 * v197);
                  else
                    v198 = 1;
                  if (!v198)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v197 = *(int *)(v192 + 4);
                  }
                  ++v194;
                  v193 += 8;
                }
                while (v194 < v197);
              }
              appendStringInfoChar((uint64_t)&__s1, 41);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(_QWORD *)(v19 + 16))
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            v619 = *(uint64_t **)(v19 + 16);
            switch(*(_DWORD *)v619)
            {
              case 0xE9:
                deparseInsertStmt(&__s1, (uint64_t)v619);
                break;
              case 0xEA:
                deparseDeleteStmt(&__s1, v619);
                break;
              case 0xEB:
                deparseUpdateStmt(&__s1, v619);
                break;
              case 0xEC:
                deparseSelectStmt(&__s1, (uint64_t)v619);
                break;
              default:
                break;
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (*(_BYTE *)(v19 + 32))
            v733 = "FROM ";
          else
            v733 = "TO ";
          appendStringInfoString((uint64_t)&__s1, v733);
          if (*(_BYTE *)(v19 + 33))
            appendStringInfoString((uint64_t)&__s1, "PROGRAM ");
          v734 = *(char **)(v19 + 40);
          if (v734)
          {
            deparseStringLiteral((uint64_t)&__s1, v734);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          else
          {
            if (*(_BYTE *)(v19 + 32))
              v735 = "STDIN ";
            else
              v735 = "STDOUT ";
            appendStringInfoString((uint64_t)&__s1, v735);
          }
          v736 = *(_QWORD *)(v19 + 48);
          if (!v736 || *(int *)(v736 + 4) < 1)
            goto LABEL_1306;
          v737 = v17;
          appendStringInfoString((uint64_t)&__s1, "WITH (");
          v738 = *(_QWORD *)(v19 + 48);
          if (!v738 || *(int *)(v738 + 4) < 1)
            goto LABEL_1305;
          v739 = 0;
          while (1)
          {
            v740 = *(_QWORD *)(v738 + 16) + 8 * v739;
            v741 = *(_QWORD *)v740;
            v742 = *(char **)(*(_QWORD *)v740 + 16);
            if (!strcmp(v742, "format"))
            {
              appendStringInfoString((uint64_t)&__s1, "FORMAT ");
              v752 = *(const char **)(*(_QWORD *)(v741 + 24) + 8);
              if (!strcmp(v752, "binary"))
              {
                v753 = "BINARY";
              }
              else
              {
                if (strcmp(v752, "csv"))
                  goto LABEL_1260;
                v753 = "CSV";
              }
              goto LABEL_1256;
            }
            if (!strcmp(v742, "freeze") && ((v754 = *(_QWORD *)(v741 + 24)) == 0 || *(_DWORD *)(v754 + 8) == 1))
            {
              appendStringInfoString((uint64_t)&__s1, "FREEZE");
              v755 = *(_QWORD *)(v741 + 24);
              if (v755)
                goto LABEL_1254;
            }
            else
            {
              if (!strcmp(v742, "delimiter"))
              {
                v756 = "DELIMITER ";
LABEL_1259:
                appendStringInfoString((uint64_t)&__s1, v756);
                deparseStringLiteral((uint64_t)&__s1, *(char **)(*(_QWORD *)(v741 + 24) + 8));
                goto LABEL_1260;
              }
              if (!strcmp(v742, "null"))
              {
                v756 = "NULL ";
                goto LABEL_1259;
              }
              if (!strcmp(v742, "header"))
              {
                v757 = *(_QWORD *)(v741 + 24);
                if (!v757 || *(_DWORD *)(v757 + 8) == 1)
                {
                  appendStringInfoString((uint64_t)&__s1, "HEADER");
                  v755 = *(_QWORD *)(v741 + 24);
                  if (!v755)
                    goto LABEL_1260;
LABEL_1254:
                  if (*(_DWORD *)(v755 + 8) != 1)
                    goto LABEL_1260;
                  v753 = " 1";
LABEL_1256:
                  appendStringInfoString((uint64_t)&__s1, v753);
                  goto LABEL_1260;
                }
              }
              if (!strcmp(v742, "quote"))
              {
                v756 = "QUOTE ";
                goto LABEL_1259;
              }
              if (!strcmp(v742, "escape"))
              {
                v756 = "ESCAPE ";
                goto LABEL_1259;
              }
              if (!strcmp(v742, "force_quote"))
              {
                appendStringInfoString((uint64_t)&__s1, "FORCE_QUOTE ");
                v751 = **(_DWORD **)(v741 + 24);
                if (v751 != 226)
                {
LABEL_1264:
                  if (v751 == 351)
                    appendStringInfoChar((uint64_t)&__s1, 42);
                  goto LABEL_1260;
                }
                appendStringInfoChar((uint64_t)&__s1, 40);
                v772 = *(_QWORD *)(v741 + 24);
                if (v772 && *(int *)(v772 + 4) >= 1)
                {
                  v773 = 8;
                  v774 = 0;
                  do
                  {
                    v775 = *(_QWORD *)(v772 + 16);
                    v776 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v775 + 8 * v774) + 8));
                    appendStringInfoString((uint64_t)&__s1, v776);
                    v777 = *(int *)(v772 + 4);
                    if (v775 + v773)
                      v778 = v775 + v773 >= (unint64_t)(*(_QWORD *)(v772 + 16) + 8 * v777);
                    else
                      v778 = 1;
                    if (!v778)
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                      v777 = *(int *)(v772 + 4);
                    }
                    ++v774;
                    v773 += 8;
                  }
                  while (v774 < v777);
                }
              }
              else if (!strcmp(v742, "force_not_null"))
              {
                appendStringInfoString((uint64_t)&__s1, "FORCE_NOT_NULL (");
                v758 = *(_QWORD *)(v741 + 24);
                if (v758 && *(int *)(v758 + 4) >= 1)
                {
                  v759 = 8;
                  v760 = 0;
                  do
                  {
                    v761 = *(_QWORD *)(v758 + 16);
                    v762 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v761 + 8 * v760) + 8));
                    appendStringInfoString((uint64_t)&__s1, v762);
                    v763 = *(int *)(v758 + 4);
                    if (v761 + v759)
                      v764 = v761 + v759 >= (unint64_t)(*(_QWORD *)(v758 + 16) + 8 * v763);
                    else
                      v764 = 1;
                    if (!v764)
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                      v763 = *(int *)(v758 + 4);
                    }
                    ++v760;
                    v759 += 8;
                  }
                  while (v760 < v763);
                }
              }
              else
              {
                if (strcmp(v742, "force_null"))
                {
                  if (!strcmp(v742, "encoding"))
                  {
                    appendStringInfoString((uint64_t)&__s1, "ENCODING ");
                    deparseStringLiteral((uint64_t)&__s1, *(char **)(*(_QWORD *)(v741 + 24) + 8));
                  }
                  else
                  {
                    v743 = quote_identifier(v742);
                    appendStringInfoString((uint64_t)&__s1, v743);
                    if (*(_QWORD *)(v741 + 24))
                    {
                      appendStringInfoChar((uint64_t)&__s1, 32);
                      v750 = *(_QWORD *)(v741 + 24);
                      if (v750)
                      {
                        v751 = *(_DWORD *)v750 - 221;
                        switch(*(_DWORD *)v750)
                        {
                          case 0xDD:
                            appendStringInfo((uint64_t)&__s1, "%d", v744, v745, v746, v747, v748, v749, *(unsigned int *)(v750 + 8));
                            break;
                          case 0xDE:
                            v753 = *(char **)(v750 + 8);
                            goto LABEL_1256;
                          case 0xDF:
                            deparseOptBooleanOrString(&__s1, *(char **)(v750 + 8));
                            break;
                          case 0xE0:
                          case 0xE1:
                            goto LABEL_1260;
                          case 0xE2:
                            appendStringInfoChar((uint64_t)&__s1, 40);
                            if (*(int *)(v750 + 4) >= 1)
                            {
                              v779 = 8;
                              v780 = 0;
                              do
                              {
                                v781 = *(_QWORD *)(v750 + 16);
                                deparseOptBooleanOrString(&__s1, *(char **)(*(_QWORD *)(v781 + 8 * v780) + 8));
                                v782 = *(int *)(v750 + 4);
                                if (v781 + v779)
                                  v783 = v781 + v779 >= (unint64_t)(*(_QWORD *)(v750 + 16) + 8 * v782);
                                else
                                  v783 = 1;
                                if (!v783)
                                {
                                  appendStringInfoString((uint64_t)&__s1, ", ");
                                  v782 = *(int *)(v750 + 4);
                                }
                                ++v780;
                                v779 += 8;
                              }
                              while (v780 < v782);
                            }
                            goto LABEL_1304;
                          default:
                            goto LABEL_1264;
                        }
                      }
                    }
                  }
                  goto LABEL_1260;
                }
                appendStringInfoString((uint64_t)&__s1, "FORCE_NULL (");
                v765 = *(_QWORD *)(v741 + 24);
                if (v765 && *(int *)(v765 + 4) >= 1)
                {
                  v766 = 8;
                  v767 = 0;
                  do
                  {
                    v768 = *(_QWORD *)(v765 + 16);
                    v769 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v768 + 8 * v767) + 8));
                    appendStringInfoString((uint64_t)&__s1, v769);
                    v770 = *(int *)(v765 + 4);
                    if (v768 + v766)
                      v771 = v768 + v766 >= (unint64_t)(*(_QWORD *)(v765 + 16) + 8 * v770);
                    else
                      v771 = 1;
                    if (!v771)
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                      v770 = *(int *)(v765 + 4);
                    }
                    ++v767;
                    v766 += 8;
                  }
                  while (v767 < v770);
                }
              }
LABEL_1304:
              appendStringInfoChar((uint64_t)&__s1, 41);
            }
LABEL_1260:
            if (v740 != -8
              && v740 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 48) + 16)
                                             + 8 * *(int *)(*(_QWORD *)(v19 + 48) + 4)))
            {
              appendStringInfoString((uint64_t)&__s1, ", ");
            }
            if (++v739 >= *(int *)(v738 + 4))
            {
LABEL_1305:
              appendStringInfoString((uint64_t)&__s1, ") ");
              v15 = v1226;
              v17 = v737;
LABEL_1306:
              v784 = *(int **)(v19 + 56);
              if (v784)
              {
                appendStringInfoString((uint64_t)&__s1, "WHERE ");
                deparseExpr(&__s1, v784, v785, v786, v787, v788, v789, v790);
LABEL_1308:
                v556 = 32;
LABEL_1309:
                appendStringInfoChar((uint64_t)&__s1, v556);
              }
              goto LABEL_2090;
            }
          }
        case 0xF7:
          deparseCreateStmt(&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8), 0);
          goto LABEL_2103;
        case 0xF8:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(_BYTE *)(v18 + 41))
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          v283 = "AGGREGATE ";
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              goto LABEL_1502;
            case 7:
              v283 = "COLLATION ";
              goto LABEL_1502;
            case 0x19:
              v283 = "OPERATOR ";
              goto LABEL_1502;
            case 0x2B:
              v283 = "TEXT SEARCH CONFIGURATION ";
              goto LABEL_1502;
            case 0x2C:
              v283 = "TEXT SEARCH DICTIONARY ";
              goto LABEL_1502;
            case 0x2D:
              v283 = "TEXT SEARCH PARSER ";
              goto LABEL_1502;
            case 0x2E:
              v283 = "TEXT SEARCH TEMPLATE ";
              goto LABEL_1502;
            case 0x2F:
              v283 = "TYPE ";
LABEL_1502:
              appendStringInfoString((uint64_t)&__s1, v283);
              break;
            default:
              break;
          }
          if (*(_BYTE *)(v18 + 40))
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              v857 = *(_QWORD *)(v18 + 16);
              if (v857 && *(int *)(v857 + 4) >= 1)
              {
                v858 = 8;
                v859 = 0;
                do
                {
                  v860 = *(_QWORD *)(v857 + 16);
                  v861 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v860 + 8 * v859) + 8));
                  appendStringInfoString((uint64_t)&__s1, v861);
                  v862 = *(int *)(v857 + 4);
                  if (v860 + v858)
                    v863 = v860 + v858 >= (unint64_t)(*(_QWORD *)(v857 + 16) + 8 * v862);
                  else
                    v863 = 1;
                  if (!v863)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v862 = *(int *)(v857 + 4);
                  }
                  ++v859;
                  v858 += 8;
                }
                while (v859 < v862);
              }
              goto LABEL_2054;
            case 7:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
              v850 = *(_QWORD *)(v18 + 16);
              if (v850 && *(int *)(v850 + 4) >= 1)
              {
                v851 = 8;
                v852 = 0;
                do
                {
                  v853 = *(_QWORD *)(v850 + 16);
                  v854 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v853 + 8 * v852) + 8));
                  appendStringInfoString((uint64_t)&__s1, v854);
                  v855 = *(int *)(v850 + 4);
                  if (v853 + v851)
                    v856 = v853 + v851 >= (unint64_t)(*(_QWORD *)(v850 + 16) + 8 * v855);
                  else
                    v856 = 1;
                  if (!v856)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v855 = *(int *)(v850 + 4);
                  }
                  ++v852;
                  v851 += 8;
                }
                while (v852 < v855);
              }
              goto LABEL_2054;
            case 0x19:
              v864 = *(_QWORD *)(v18 + 16);
              if (!v864)
                goto LABEL_2054;
              v865 = *(_DWORD *)(v864 + 4);
              if (v865 == 1)
              {
                v867 = *(_QWORD *)(v864 + 16);
              }
              else
              {
                if (v865 != 2)
                  goto LABEL_2054;
                v866 = quote_identifier(*(_BYTE **)(**(_QWORD **)(v864 + 16) + 8));
                appendStringInfoString((uint64_t)&__s1, v866);
                appendStringInfoChar((uint64_t)&__s1, 46);
                v867 = *(_QWORD *)(v864 + 16) + 8 * (*(_DWORD *)(v864 + 4) - 1);
              }
              appendStringInfoString((uint64_t)&__s1, *(char **)(*(_QWORD *)v867 + 8));
LABEL_2054:
              appendStringInfoChar((uint64_t)&__s1, 32);
              if (!*(_BYTE *)(v19 + 8))
              {
                v1194 = *(_DWORD *)(v19 + 4);
                if (v1194 != 1)
                  goto LABEL_2072;
                v1195 = *(uint64_t **)(*(_QWORD *)(v19 + 24) + 16);
                v1196 = *v1195;
                v1197 = *(unsigned int *)(v1195[1] + 8);
                appendStringInfoChar((uint64_t)&__s1, 40);
                if (v1196)
                {
                  v1198 = v1197;
                  LODWORD(v1199) = *(_DWORD *)(v1196 + 4);
                  if ((int)v1199 >= 1)
                  {
                    v1200 = *(uint64_t **)(v1196 + 16);
                    if (!(_DWORD)v1198)
                      appendStringInfoString((uint64_t)&__s1, "ORDER BY ");
                    deparseFunctionParameter(&__s1, *v1200);
                    LODWORD(v1199) = *(_DWORD *)(v1196 + 4);
                    if ((int)v1199 >= 2)
                    {
                      v1201 = 1;
                      do
                      {
                        v1203 = *(_QWORD *)(v1196 + 16);
                        if (v1198 == v1201)
                        {
                          appendStringInfoChar((uint64_t)&__s1, 32);
                          v1202 = "ORDER BY ";
                        }
                        else
                        {
                          v1202 = ", ";
                        }
                        appendStringInfoString((uint64_t)&__s1, v1202);
                        deparseFunctionParameter(&__s1, *(_QWORD *)(v1203 + 8 * v1201++));
                        v1199 = *(int *)(v1196 + 4);
                      }
                      while (v1201 < v1199);
                      v15 = v1226;
                    }
                  }
                  if ((_DWORD)v1198 == (_DWORD)v1199)
                  {
                    appendStringInfoString((uint64_t)&__s1, " ORDER BY ");
                    deparseFunctionParameter(&__s1, *(_QWORD *)(*(_QWORD *)(v1196 + 16) + 8 * (*(_DWORD *)(v1196 + 4) - 1)));
                  }
                }
                else
                {
                  appendStringInfoChar((uint64_t)&__s1, 42);
                }
                appendStringInfoChar((uint64_t)&__s1, 41);
                appendStringInfoChar((uint64_t)&__s1, 32);
              }
              v1194 = *(_DWORD *)(v19 + 4);
LABEL_2072:
              v1204 = *(_QWORD *)(v19 + 32);
              if (v1194 == 7)
              {
                if (!v1204)
                  goto LABEL_2090;
                v1205 = *(_DWORD *)(v1204 + 4);
                if (v1205 == 1)
                {
                  if (!strcmp(*(const char **)(**(_QWORD **)(v1204 + 16) + 16), "from"))
                  {
                    appendStringInfoString((uint64_t)&__s1, "FROM ");
                    v1206 = *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v19 + 32) + 16) + 24);
                    if (v1206 && *(int *)(v1206 + 4) >= 1)
                    {
                      v1207 = 8;
                      v1208 = 0;
                      do
                      {
                        v1209 = *(_QWORD *)(v1206 + 16);
                        v1210 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1209 + 8 * v1208) + 8));
                        appendStringInfoString((uint64_t)&__s1, v1210);
                        v1211 = *(int *)(v1206 + 4);
                        if (v1209 + v1207)
                          v1212 = v1209 + v1207 >= (unint64_t)(*(_QWORD *)(v1206 + 16) + 8 * v1211);
                        else
                          v1212 = 1;
                        if (!v1212)
                        {
                          appendStringInfoChar((uint64_t)&__s1, 46);
                          v1211 = *(int *)(v1206 + 4);
                        }
                        ++v1208;
                        v1207 += 8;
                      }
                      while (v1208 < v1211);
                    }
                    goto LABEL_2090;
                  }
                  goto LABEL_2088;
                }
              }
              else
              {
                if (!v1204)
                  goto LABEL_2090;
                v1205 = *(_DWORD *)(v1204 + 4);
              }
              if (v1205 < 1)
                goto LABEL_2090;
LABEL_2088:
              v565 = v1204;
LABEL_2089:
              deparseDefinition(&__s1, v565);
LABEL_2090:
              v355 = (v1232 - 1);
              if ((int)v1232 < 1)
                goto LABEL_2103;
LABEL_2091:
              if (__s1[v355] == 32)
              {
                LODWORD(v1232) = v355;
                __s1[v355] = 0;
              }
              goto LABEL_2103;
            default:
              goto LABEL_2054;
          }
        case 0xF9:
          appendStringInfoString((uint64_t)&__s1, "DROP ");
          v300 = *(_DWORD *)(v18 + 16);
          if (v300 <= 0x31 && ((0x2FEAF3FBFD1A3uLL >> v300) & 1) != 0)
            appendStringInfoString((uint64_t)&__s1, (&off_1E264A918)[v300]);
          if (*(_BYTE *)(v18 + 25))
            appendStringInfoString((uint64_t)&__s1, "CONCURRENTLY ");
          if (*(_BYTE *)(v18 + 24))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          switch(*(_DWORD *)(v18 + 16))
          {
            case 0:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x11:
            case 0x1D:
            case 0x22:
              v655 = *(_QWORD *)(v18 + 8);
              if (v655 && *(int *)(v655 + 4) >= 1)
              {
                v656 = 8;
                v657 = 0;
                do
                {
                  v658 = *(_QWORD *)(v655 + 16);
                  v659 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v658 + 8 * v657) + 8));
                  appendStringInfoString((uint64_t)&__s1, v659);
                  v660 = *(int *)(v655 + 4);
                  if (v658 + v656)
                    v661 = v658 + v656 >= (unint64_t)(*(_QWORD *)(v655 + 16) + 8 * v660);
                  else
                    v661 = 1;
                  if (!v661)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v660 = *(int *)(v655 + 4);
                  }
                  ++v657;
                  v656 += 8;
                }
                while (v657 < v660);
              }
              goto LABEL_462;
            case 1:
              v1150 = *(_QWORD *)(v18 + 8);
              if (v1150 && *(int *)(v1150 + 4) >= 1)
              {
                v1151 = 8;
                v1152 = 0;
                do
                {
                  v1153 = *(_QWORD *)(v1150 + 16);
                  deparseAggregateWithArgtypes(&__s1, *(_QWORD *)(v1153 + 8 * v1152));
                  if (v1153 + v1151)
                    v1154 = v1153 + v1151 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 8) + 16)
                                                              + 8 * *(int *)(*(_QWORD *)(v19 + 8) + 4));
                  else
                    v1154 = 1;
                  if (!v1154)
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  ++v1152;
                  v1151 += 8;
                }
                while (v1152 < *(int *)(v1150 + 4));
              }
              goto LABEL_462;
            case 5:
              v1155 = **(_QWORD **)(*(_QWORD *)(v18 + 8) + 16);
              appendStringInfoChar((uint64_t)&__s1, 40);
              deparseTypeName(&__s1, **(_QWORD **)(v1155 + 16));
              appendStringInfoString((uint64_t)&__s1, " AS ");
              deparseTypeName(&__s1, *(_QWORD *)(*(_QWORD *)(v1155 + 16) + 8));
              appendStringInfoChar((uint64_t)&__s1, 41);
              goto LABEL_462;
            case 7:
            case 8:
            case 0x12:
            case 0x14:
            case 0x17:
            case 0x23:
            case 0x25:
            case 0x27:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x31:
              deparseAnyNameList((uint64_t)&__s1, *(_QWORD *)(v18 + 8));
              goto LABEL_462;
            case 0xC:
            case 0x2F:
              v917 = *(_QWORD *)(v18 + 8);
              if (v917 && *(int *)(v917 + 4) >= 1)
              {
                v918 = 8;
                v919 = 0;
                do
                {
                  v920 = *(_QWORD *)(v917 + 16);
                  deparseTypeName(&__s1, *(_QWORD *)(v920 + 8 * v919));
                  if (v920 + v918)
                    v921 = v920 + v918 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 8) + 16)
                                                           + 8 * *(int *)(*(_QWORD *)(v19 + 8) + 4));
                  else
                    v921 = 1;
                  if (!v921)
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  ++v919;
                  v918 += 8;
                }
                while (v919 < *(int *)(v917 + 4));
              }
              goto LABEL_462;
            case 0x13:
            case 0x1C:
            case 0x20:
              v894 = *(_QWORD *)(v18 + 8);
              if (v894 && *(int *)(v894 + 4) >= 1)
              {
                v895 = 8;
                v896 = 0;
                do
                {
                  v897 = *(_QWORD *)(v894 + 16);
                  deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v897 + 8 * v896));
                  if (v897 + v895)
                    v898 = v897 + v895 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 8) + 16)
                                                           + 8 * *(int *)(*(_QWORD *)(v19 + 8) + 4));
                  else
                    v898 = 1;
                  if (!v898)
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  ++v896;
                  v895 += 8;
                }
                while (v896 < *(int *)(v894 + 4));
              }
              goto LABEL_462;
            case 0x15:
              deparseStringLiteral((uint64_t)&__s1, *(char **)(**(_QWORD **)(*(_QWORD *)(v18 + 8) + 16) + 8));
              goto LABEL_462;
            case 0x18:
            case 0x1A:
              v922 = **(_QWORD **)(*(_QWORD *)(v18 + 8) + 16);
              if (!v922)
                goto LABEL_2111;
              if (*(int *)(v922 + 4) >= 2)
              {
                v923 = 1;
                do
                {
                  v924 = (uint64_t *)(*(_QWORD *)(v922 + 16) + 8 * v923);
                  v926 = *v924;
                  v925 = (unint64_t)(v924 + 1);
                  v927 = quote_identifier(*(_BYTE **)(v926 + 8));
                  appendStringInfoString((uint64_t)&__s1, v927);
                  v928 = *(int *)(v922 + 4);
                  if (v925)
                    v929 = v925 >= *(_QWORD *)(v922 + 16) + 8 * v928;
                  else
                    v929 = 1;
                  if (!v929)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v928) = *(_DWORD *)(v922 + 4);
                  }
                  ++v923;
                }
                while ((int)v928 > v923);
              }
              appendStringInfoString((uint64_t)&__s1, " USING ");
              v930 = **(_QWORD **)(v922 + 16);
LABEL_1959:
              v1162 = quote_identifier(*(_BYTE **)(v930 + 8));
              appendStringInfoString((uint64_t)&__s1, v1162);
LABEL_462:
              appendStringInfoChar((uint64_t)&__s1, 32);
              break;
            case 0x19:
              v1156 = *(_QWORD *)(v18 + 8);
              if (v1156 && *(int *)(v1156 + 4) >= 1)
              {
                v1157 = 8;
                v1158 = 0;
                do
                {
                  v1159 = *(_QWORD *)(v1156 + 16);
                  deparseOperatorWithArgtypes(&__s1, *(_QWORD *)(v1159 + 8 * v1158));
                  if (v1159 + v1157)
                    v1160 = v1159 + v1157 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 8) + 16)
                                                              + 8 * *(int *)(*(_QWORD *)(v19 + 8) + 4));
                  else
                    v1160 = 1;
                  if (!v1160)
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  ++v1158;
                  v1157 += 8;
                }
                while (v1158 < *(int *)(v1156 + 4));
              }
              goto LABEL_462;
            case 0x1B:
            case 0x21:
            case 0x2A:
              v899 = **(_QWORD **)(*(_QWORD *)(v18 + 8) + 16);
              v900 = quote_identifier(*(_BYTE **)(*(_QWORD *)(*(_QWORD *)(v899 + 16) + 8 * (*(_DWORD *)(v899 + 4) - 1))
                                                + 8));
              appendStringInfoString((uint64_t)&__s1, v900);
              appendStringInfoString((uint64_t)&__s1, " ON ");
              v901 = *(unsigned int *)(v899 + 4);
              if ((int)v901 >= 1)
              {
                v902 = 8;
                v903 = 0;
                do
                {
                  v904 = v901;
                  v905 = *(_QWORD *)(v899 + 16);
                  if (v905 + v902)
                    v906 = v905 + v902 >= (unint64_t)(v905 + 8 * (int)v904);
                  else
                    v906 = 1;
                  if (!v906)
                  {
                    v907 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v905 + 8 * v903) + 8));
                    appendStringInfoString((uint64_t)&__s1, v907);
                    v904 = *(unsigned int *)(v899 + 4);
                    if (v903 < *(_DWORD *)(v899 + 4) - 2)
                    {
                      appendStringInfoChar((uint64_t)&__s1, 46);
                      v904 = *(unsigned int *)(v899 + 4);
                    }
                  }
                  v901 = v904;
                  v885 = v903 + 1 < (int)v904;
                  v902 += 8;
                  ++v903;
                }
                while (v885);
              }
              goto LABEL_462;
            case 0x29:
              v1161 = **(_QWORD **)(*(_QWORD *)(v18 + 8) + 16);
              appendStringInfoString((uint64_t)&__s1, "FOR ");
              deparseTypeName(&__s1, **(_QWORD **)(v1161 + 16));
              appendStringInfoString((uint64_t)&__s1, " LANGUAGE ");
              v930 = *(_QWORD *)(*(_QWORD *)(v1161 + 16) + 8);
              goto LABEL_1959;
            default:
              goto LABEL_526;
          }
          goto LABEL_526;
        case 0xFA:
          appendStringInfoString((uint64_t)&__s1, "TRUNCATE ");
          v328 = *(_QWORD *)(v18 + 8);
          if (v328 && *(int *)(v328 + 4) >= 1)
          {
            v329 = 8;
            v330 = 0;
            do
            {
              v331 = *(_QWORD *)(v328 + 16);
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v331 + 8 * v330), 0);
              v332 = *(int *)(v328 + 4);
              if (v331 + v329)
                v333 = v331 + v329 >= (unint64_t)(*(_QWORD *)(v328 + 16) + 8 * v332);
              else
                v333 = 1;
              if (!v333)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                v332 = *(int *)(v328 + 4);
              }
              ++v330;
              v329 += 8;
            }
            while (v330 < v332);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_BYTE *)(v19 + 16))
            appendStringInfoString((uint64_t)&__s1, "RESTART IDENTITY ");
LABEL_526:
          if (*(_DWORD *)(v19 + 20) == 1)
            goto LABEL_2027;
          goto LABEL_2090;
        case 0xFB:
          appendStringInfoString((uint64_t)&__s1, "COMMENT ON ");
          v306 = *(_DWORD *)(v18 + 4);
          v307 = v306;
          if (v306 <= 0x31 && ((0x2FFFFBFFFF3E3uLL >> v306) & 1) != 0)
          {
            appendStringInfoString((uint64_t)&__s1, (&off_1E264A750)[v306]);
            v307 = *(_DWORD *)(v18 + 4);
          }
          switch(v307)
          {
            case 0u:
            case 9u:
            case 0xEu:
            case 0xFu:
            case 0x10u:
            case 0x11u:
            case 0x15u:
            case 0x1Du:
            case 0x1Fu:
            case 0x22u:
            case 0x24u:
            case 0x28u:
              v613 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v18 + 8) + 8));
              appendStringInfoString((uint64_t)&__s1, v613);
              goto LABEL_2100;
            case 1u:
              deparseAggregateWithArgtypes(&__s1, *(_QWORD *)(v18 + 8));
              goto LABEL_2100;
            case 5u:
              v1213 = *(_QWORD *)(v18 + 8);
              appendStringInfoChar((uint64_t)&__s1, 40);
              deparseTypeName(&__s1, **(_QWORD **)(v1213 + 16));
              appendStringInfoString((uint64_t)&__s1, " AS ");
              deparseTypeName(&__s1, *(_QWORD *)(*(_QWORD *)(v1213 + 16) + 8));
              appendStringInfoChar((uint64_t)&__s1, 41);
              goto LABEL_2100;
            case 6u:
            case 7u:
            case 8u:
            case 0x12u:
            case 0x14u:
            case 0x17u:
            case 0x23u:
            case 0x25u:
            case 0x27u:
            case 0x2Bu:
            case 0x2Cu:
            case 0x2Du:
            case 0x2Eu:
            case 0x31u:
              v308 = *(_QWORD *)(v18 + 8);
              if (v308 && *(int *)(v308 + 4) >= 1)
              {
                v309 = 8;
                v310 = 0;
                do
                {
                  v311 = *(_QWORD *)(v308 + 16);
                  v312 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v311 + 8 * v310) + 8));
                  appendStringInfoString((uint64_t)&__s1, v312);
                  v313 = *(int *)(v308 + 4);
                  if (v311 + v309)
                    v314 = v311 + v309 >= (unint64_t)(*(_QWORD *)(v308 + 16) + 8 * v313);
                  else
                    v314 = 1;
                  if (!v314)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v313 = *(int *)(v308 + 4);
                  }
                  ++v310;
                  v309 += 8;
                }
                while (v310 < v313);
              }
              goto LABEL_2100;
            case 0xCu:
            case 0x2Fu:
              deparseTypeName(&__s1, *(_QWORD *)(v18 + 8));
              goto LABEL_2100;
            case 0xDu:
              v1216 = *(_QWORD *)(v18 + 8);
              v1217 = quote_identifier(*(_BYTE **)(*(_QWORD *)(*(_QWORD *)(v1216 + 16)
                                                             + 8 * (*(_DWORD *)(v1216 + 4) - 1))
                                                 + 8));
              appendStringInfoString((uint64_t)&__s1, v1217);
              appendStringInfoString((uint64_t)&__s1, " ON DOMAIN ");
              deparseTypeName(&__s1, **(_QWORD **)(v1216 + 16));
              goto LABEL_2100;
            case 0x13u:
            case 0x1Cu:
            case 0x20u:
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 8));
              goto LABEL_2100;
            case 0x16u:
              deparseValue(&__s1, *(_QWORD *)(v18 + 8), 0, v301, v302, v303, v304, v305);
              goto LABEL_2100;
            case 0x18u:
            case 0x1Au:
              v931 = *(_QWORD *)(v18 + 8);
              if (!v931)
                goto LABEL_2111;
              if (*(int *)(v931 + 4) >= 2)
              {
                v932 = 1;
                do
                {
                  v933 = (uint64_t *)(*(_QWORD *)(v931 + 16) + 8 * v932);
                  v935 = *v933;
                  v934 = (unint64_t)(v933 + 1);
                  v936 = quote_identifier(*(_BYTE **)(v935 + 8));
                  appendStringInfoString((uint64_t)&__s1, v936);
                  v937 = *(int *)(v931 + 4);
                  if (v934)
                    v938 = v934 >= *(_QWORD *)(v931 + 16) + 8 * v937;
                  else
                    v938 = 1;
                  if (!v938)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v937) = *(_DWORD *)(v931 + 4);
                  }
                  ++v932;
                }
                while ((int)v937 > v932);
              }
              appendStringInfoString((uint64_t)&__s1, " USING ");
              v990 = **(_QWORD **)(v931 + 16);
LABEL_2096:
              v1215 = quote_identifier(*(_BYTE **)(v990 + 8));
              appendStringInfoString((uint64_t)&__s1, v1215);
LABEL_2100:
              appendStringInfoString((uint64_t)&__s1, " IS ");
              v362 = *(char **)(v19 + 16);
              if (!v362)
                goto LABEL_2101;
              goto LABEL_1697;
            case 0x19u:
              deparseOperatorWithArgtypes(&__s1, *(_QWORD *)(v18 + 8));
              goto LABEL_2100;
            case 0x1Bu:
            case 0x21u:
            case 0x26u:
            case 0x2Au:
              v880 = *(_QWORD *)(v18 + 8);
              v881 = quote_identifier(*(_BYTE **)(*(_QWORD *)(*(_QWORD *)(v880 + 16) + 8 * (*(_DWORD *)(v880 + 4) - 1))
                                                + 8));
              appendStringInfoString((uint64_t)&__s1, v881);
              appendStringInfoString((uint64_t)&__s1, " ON ");
              v882 = *(unsigned int *)(v880 + 4);
              if ((int)v882 >= 1)
              {
                v883 = 8;
                v884 = 0;
                do
                {
                  v886 = v882;
                  v887 = *(_QWORD *)(v880 + 16);
                  if (v887 + v883)
                    v888 = v887 + v883 >= (unint64_t)(v887 + 8 * (int)v886);
                  else
                    v888 = 1;
                  if (!v888)
                  {
                    v889 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v887 + 8 * v884) + 8));
                    appendStringInfoString((uint64_t)&__s1, v889);
                    v886 = *(unsigned int *)(v880 + 4);
                    if (v884 < *(_DWORD *)(v880 + 4) - 2)
                    {
                      appendStringInfoChar((uint64_t)&__s1, 46);
                      v886 = *(unsigned int *)(v880 + 4);
                    }
                  }
                  v882 = v886;
                  v885 = v884 + 1 < (int)v886;
                  v883 += 8;
                  ++v884;
                }
                while (v885);
              }
              goto LABEL_2100;
            case 0x29u:
              v1214 = *(_QWORD *)(v18 + 8);
              appendStringInfoString((uint64_t)&__s1, "FOR ");
              deparseTypeName(&__s1, **(_QWORD **)(v1214 + 16));
              appendStringInfoString((uint64_t)&__s1, " LANGUAGE ");
              v990 = *(_QWORD *)(*(_QWORD *)(v1214 + 16) + 8);
              goto LABEL_2096;
            default:
              goto LABEL_2100;
          }
        case 0xFC:
          if (*(_BYTE *)(v18 + 24))
            v284 = "MOVE ";
          else
            v284 = "FETCH ";
          appendStringInfoString((uint64_t)&__s1, v284);
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0:
              v291 = *(_QWORD *)(v18 + 8);
              if (v291 == 1)
                goto LABEL_1598;
              if (v291 == 0x7FFFFFFFFFFFFFFFLL)
              {
                v292 = "ALL ";
                goto LABEL_1596;
              }
              appendStringInfo((uint64_t)&__s1, "FORWARD %ld ", v285, v286, v287, v288, v289, v290, *(_QWORD *)(v19 + 8));
              goto LABEL_1598;
            case 1:
              v626 = *(_QWORD *)(v18 + 8);
              if (v626 == 0x7FFFFFFFFFFFFFFFLL)
              {
                v292 = "BACKWARD ALL ";
                goto LABEL_1596;
              }
              if (v626 == 1)
              {
                v292 = "PRIOR ";
                goto LABEL_1596;
              }
              appendStringInfo((uint64_t)&__s1, "BACKWARD %ld ", v285, v286, v287, v288, v289, v290, *(_QWORD *)(v19 + 8));
              goto LABEL_1598;
            case 2:
              v627 = *(_QWORD *)(v18 + 8);
              if (v627 == -1)
              {
                v292 = "LAST ";
              }
              else
              {
                if (v627 != 1)
                {
                  appendStringInfo((uint64_t)&__s1, "ABSOLUTE %ld ", v285, v286, v287, v288, v289, v290, *(_QWORD *)(v19 + 8));
LABEL_1598:
                  v27 = *(char **)(v18 + 16);
                  goto LABEL_2102;
                }
                v292 = "FIRST ";
              }
LABEL_1596:
              appendStringInfoString((uint64_t)&__s1, v292);
              v27 = *(char **)(v18 + 16);
              goto LABEL_2102;
            case 3:
              appendStringInfo((uint64_t)&__s1, "RELATIVE %ld ", v285, v286, v287, v288, v289, v290, *(_QWORD *)(v18 + 8));
              goto LABEL_1598;
            default:
              goto LABEL_1598;
          }
        case 0xFD:
          deparseIndexStmt(&__s1, v18);
          goto LABEL_2103;
        case 0xFE:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(_BYTE *)(v18 + 5))
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          if (*(_BYTE *)(v18 + 4))
            v225 = "PROCEDURE ";
          else
            v225 = "FUNCTION ";
          appendStringInfoString((uint64_t)&__s1, v225);
          v226 = *(_QWORD *)(v18 + 8);
          if (v226 && *(int *)(v226 + 4) >= 1)
          {
            v227 = 8;
            v228 = 0;
            do
            {
              v229 = *(_QWORD *)(v226 + 16);
              v230 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v229 + 8 * v228) + 8));
              appendStringInfoString((uint64_t)&__s1, v230);
              v231 = *(int *)(v226 + 4);
              if (v229 + v227)
                v232 = v229 + v227 >= (unint64_t)(*(_QWORD *)(v226 + 16) + 8 * v231);
              else
                v232 = 1;
              if (!v232)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v231 = *(int *)(v226 + 4);
              }
              ++v228;
              v227 += 8;
            }
            while (v228 < v231);
          }
          appendStringInfoChar((uint64_t)&__s1, 40);
          v254 = *(_QWORD *)(v19 + 16);
          if (v254 && *(int *)(v254 + 4) >= 1)
          {
            v255 = 8;
            v256 = 0;
            v257 = 0;
            do
            {
              v259 = *(_QWORD *)(v254 + 16);
              v260 = *(_QWORD *)(v259 + 8 * v256);
              if (*(_DWORD *)(v260 + 24) == 116)
              {
                v258 = 1;
              }
              else
              {
                deparseFunctionParameter(&__s1, v260);
                if (v259 + v255)
                  v261 = v259 + v255 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                                         + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4));
                else
                  v261 = 1;
                if (!v261 && *(_DWORD *)(*(_QWORD *)(v259 + 8 * v256 + 8) + 24) != 116)
                  appendStringInfoString((uint64_t)&__s1, ", ");
                v258 = v257;
              }
              ++v256;
              v255 += 8;
              v257 = v258;
            }
            while (v256 < *(int *)(v254 + 4));
            appendStringInfoString((uint64_t)&__s1, ") ");
            if ((v258 & 1) != 0)
            {
              appendStringInfoString((uint64_t)&__s1, "RETURNS TABLE (");
              v550 = *(_QWORD *)(v19 + 16);
              if (v550 && *(int *)(v550 + 4) >= 1)
              {
                v551 = 8;
                v552 = 0;
                do
                {
                  v553 = *(_QWORD *)(v550 + 16);
                  v554 = *(_QWORD *)(v553 + 8 * v552);
                  if (*(_DWORD *)(v554 + 24) == 116)
                  {
                    deparseFunctionParameter(&__s1, v554);
                    if (v553 + v551
                      && v553 + v551 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                                        + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4)))
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                    }
                  }
                  ++v552;
                  v551 += 8;
                }
                while (v552 < *(int *)(v550 + 4));
              }
              appendStringInfoString((uint64_t)&__s1, ") ");
              goto LABEL_1025;
            }
          }
          else
          {
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (*(_QWORD *)(v19 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "RETURNS ");
            deparseTypeName(&__s1, *(_QWORD *)(v19 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
LABEL_1025:
          v629 = *(_QWORD *)(v19 + 32);
          if (!v629 || *(int *)(v629 + 4) < 1)
            goto LABEL_1481;
          v630 = *(_QWORD *)(v19 + 32);
          v631 = 0;
          v1219 = v630;
          while (1)
          {
            v633 = *(_QWORD *)(*(_QWORD *)(v630 + 16) + 8 * v631);
            v634 = *(const char **)(v633 + 16);
            v635 = v16;
            if (!strcmp(v634, "as"))
            {
              v636 = v17;
              appendStringInfoString((uint64_t)&__s1, "AS ");
              v637 = *(_QWORD *)(v633 + 24);
              if (v637 && *(int *)(v637 + 4) >= 1)
              {
                v638 = 0;
                do
                {
                  v639 = *(_QWORD *)(v637 + 16) + 8 * v638;
                  v640 = *(char **)(*(_QWORD *)v639 + 8);
                  if (strstr(v640, "$$"))
                  {
                    if (strchr(v640, 92))
                      appendStringInfoChar((uint64_t)&__s1, 69);
                    appendStringInfoChar((uint64_t)&__s1, 39);
                    for (i = v640; ; ++i)
                    {
                      v642 = *i;
                      v643 = *i;
                      if (v642 == 39 || v642 == 92)
                      {
                        appendStringInfoChar((uint64_t)&__s1, v642);
                      }
                      else if (!*i)
                      {
                        appendStringInfoChar((uint64_t)&__s1, 39);
                        v644 = *(int *)(v637 + 4);
                        v645 = v644;
                        v646 = v639 + 8;
                        if (v639 == -8)
                          goto LABEL_1039;
                        goto LABEL_1052;
                      }
                      appendStringInfoChar((uint64_t)&__s1, v643);
                    }
                  }
                  appendStringInfoString((uint64_t)&__s1, "$$");
                  appendStringInfoString((uint64_t)&__s1, v640);
                  appendStringInfoString((uint64_t)&__s1, "$$");
                  v644 = *(int *)(v637 + 4);
                  v645 = v644;
                  v646 = v639 + 8;
                  if (v639 == -8)
                    goto LABEL_1039;
LABEL_1052:
                  if (v646 < *(_QWORD *)(v637 + 16) + 8 * v644)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v645 = *(int *)(v637 + 4);
                  }
LABEL_1039:
                  ++v638;
                }
                while (v638 < v645);
              }
              goto LABEL_1030;
            }
            v636 = v17;
            if (!strcmp(v634, "language"))
            {
              appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
              v647 = *(char **)(*(_QWORD *)(v633 + 24) + 8);
              v648 = strlen(v647);
              if (v648)
              {
                if (v648 >= 0x40)
                {
                  deparseStringLiteral((uint64_t)&__s1, v647);
                  goto LABEL_1030;
                }
                v632 = quote_identifier(v647);
              }
              else
              {
                v632 = "''";
              }
            }
            else
            {
              if (!strcmp(v634, "transform"))
              {
                v649 = *(_QWORD *)(v633 + 24);
                appendStringInfoString((uint64_t)&__s1, "TRANSFORM ");
                if (v649 && *(int *)(v649 + 4) >= 1)
                {
                  v650 = 8;
                  v651 = 0;
                  do
                  {
                    v652 = *(_QWORD *)(v649 + 16);
                    appendStringInfoString((uint64_t)&__s1, "FOR TYPE ");
                    deparseTypeName(&__s1, *(_QWORD *)(v652 + 8 * v651));
                    v653 = *(int *)(v649 + 4);
                    if (v652 + v650)
                      v654 = v652 + v650 >= (unint64_t)(*(_QWORD *)(v649 + 16) + 8 * v653);
                    else
                      v654 = 1;
                    if (!v654)
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                      v653 = *(int *)(v649 + 4);
                    }
                    ++v651;
                    v650 += 8;
                  }
                  while (v651 < v653);
                }
                goto LABEL_1030;
              }
              if (strcmp(v634, "window"))
              {
                deparseCommonFuncOptItem(&__s1, v633);
                goto LABEL_1030;
              }
              v632 = "WINDOW";
            }
            appendStringInfoString((uint64_t)&__s1, v632);
LABEL_1030:
            appendStringInfoChar((uint64_t)&__s1, 32);
            ++v631;
            v630 = v1219;
            v17 = v636;
            v16 = v635;
            if (v631 >= *(int *)(v1219 + 4))
              goto LABEL_1481;
          }
        case 0xFF:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          v199 = *(_DWORD *)(v18 + 4);
          switch(v199)
          {
            case 19:
              v200 = "FUNCTION ";
              break;
            case 32:
              v200 = "ROUTINE ";
              break;
            case 28:
              v200 = "PROCEDURE ";
              break;
            default:
              goto LABEL_965;
          }
          appendStringInfoString((uint64_t)&__s1, v200);
LABEL_965:
          deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          v614 = *(_QWORD *)(v18 + 16);
          if (v614 && *(int *)(v614 + 4) >= 1)
          {
            v615 = 8;
            v616 = 0;
            do
            {
              v617 = *(_QWORD *)(v614 + 16);
              deparseCommonFuncOptItem(&__s1, *(_QWORD *)(v617 + 8 * v616));
              if (v617 + v615)
                v618 = v617 + v615 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                                       + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4));
              else
                v618 = 1;
              if (!v618)
                appendStringInfoChar((uint64_t)&__s1, 32);
              ++v616;
              v615 += 8;
            }
            while (v616 < *(int *)(v614 + 4));
          }
          goto LABEL_2103;
        case 0x100:
          appendStringInfoString((uint64_t)&__s1, "DO ");
          v315 = *(_QWORD *)(v18 + 8);
          if (!v315 || *(int *)(v315 + 4) < 1)
            goto LABEL_1481;
          v316 = *(_DWORD *)(v315 + 4);
          v317 = 0;
          while (1)
          {
            v319 = *(_QWORD *)(*(_QWORD *)(v315 + 16) + 8 * v317);
            v320 = *(const char **)(v319 + 16);
            if (!strcmp(v320, "language"))
            {
              appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
              v318 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v319 + 24) + 8));
            }
            else
            {
              if (strcmp(v320, "as"))
                goto LABEL_481;
              v321 = *(char **)(*(_QWORD *)(v319 + 24) + 8);
              v322 = "$$";
              if (strstr(v321, "$$"))
                v322 = "$outer$";
              appendStringInfoString((uint64_t)&__s1, v322);
              appendStringInfoString((uint64_t)&__s1, v321);
              v318 = v322;
            }
            appendStringInfoString((uint64_t)&__s1, v318);
            appendStringInfoChar((uint64_t)&__s1, 32);
            v316 = *(_DWORD *)(v315 + 4);
LABEL_481:
            if (++v317 >= v316)
            {
LABEL_1481:
              v355 = (v1232 - 1);
              v15 = v1226;
              if ((int)v1232 < 1)
                goto LABEL_2103;
              goto LABEL_2091;
            }
          }
        case 0x101:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          v395 = "AGGREGATE ";
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              goto LABEL_1992;
            case 4:
            case 0x2F:
              v395 = "TYPE ";
              goto LABEL_1992;
            case 6:
              v395 = "TABLE ";
              switch(*(_DWORD *)(v18 + 8))
              {
                case 0x12:
                  goto LABEL_1963;
                case 0x17:
                  goto LABEL_1964;
                case 0x27:
                  goto LABEL_1992;
                case 0x31:
                  goto LABEL_1965;
                default:
                  goto LABEL_1993;
              }
              break;
            case 7:
              v395 = "COLLATION ";
              goto LABEL_1992;
            case 8:
              v395 = "CONVERSION ";
              goto LABEL_1992;
            case 9:
              v395 = "DATABASE ";
              goto LABEL_1992;
            case 0xC:
            case 0xD:
              v395 = "DOMAIN ";
              goto LABEL_1992;
            case 0xE:
              v395 = "EVENT TRIGGER ";
              goto LABEL_1992;
            case 0x10:
              v395 = "FOREIGN DATA WRAPPER ";
              goto LABEL_1992;
            case 0x11:
              v395 = "SERVER ";
              goto LABEL_1992;
            case 0x12:
LABEL_1963:
              v395 = "FOREIGN TABLE ";
              goto LABEL_1992;
            case 0x13:
              v395 = "FUNCTION ";
              goto LABEL_1992;
            case 0x14:
              v395 = "INDEX ";
              goto LABEL_1992;
            case 0x15:
              v395 = "LANGUAGE ";
              goto LABEL_1992;
            case 0x17:
LABEL_1964:
              v395 = "MATERIALIZED VIEW ";
              goto LABEL_1992;
            case 0x18:
              v395 = "OPERATOR CLASS ";
              goto LABEL_1992;
            case 0x1A:
              v395 = "OPERATOR FAMILY ";
              goto LABEL_1992;
            case 0x1B:
              v395 = "POLICY ";
              goto LABEL_1992;
            case 0x1C:
              v395 = "PROCEDURE ";
              goto LABEL_1992;
            case 0x1D:
              v395 = "PUBLICATION ";
              goto LABEL_1992;
            case 0x1F:
              v395 = "ROLE ";
              goto LABEL_1992;
            case 0x20:
              v395 = "ROUTINE ";
              goto LABEL_1992;
            case 0x21:
              v395 = "RULE ";
              goto LABEL_1992;
            case 0x22:
              v395 = "SCHEMA ";
              goto LABEL_1992;
            case 0x23:
              v395 = "SEQUENCE ";
              goto LABEL_1992;
            case 0x24:
              v395 = "SUBSCRIPTION ";
              goto LABEL_1992;
            case 0x25:
              v395 = "STATISTICS ";
              goto LABEL_1992;
            case 0x26:
            case 0x27:
              v395 = "TABLE ";
              goto LABEL_1992;
            case 0x28:
              v395 = "TABLESPACE ";
              goto LABEL_1992;
            case 0x2A:
              v395 = "TRIGGER ";
              goto LABEL_1992;
            case 0x2B:
              v395 = "TEXT SEARCH CONFIGURATION ";
              goto LABEL_1992;
            case 0x2C:
              v395 = "TEXT SEARCH DICTIONARY ";
              goto LABEL_1992;
            case 0x2D:
              v395 = "TEXT SEARCH PARSER ";
              goto LABEL_1992;
            case 0x2E:
              v395 = "TEXT SEARCH TEMPLATE ";
              goto LABEL_1992;
            case 0x31:
LABEL_1965:
              v395 = "VIEW ";
LABEL_1992:
              appendStringInfoString((uint64_t)&__s1, v395);
              break;
            default:
              break;
          }
LABEL_1993:
          if (*(_BYTE *)(v18 + 52))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              deparseAggregateWithArgtypes(&__s1, *(_QWORD *)(v18 + 24));
              goto LABEL_2025;
            case 4:
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 16), 9);
              v1183 = " RENAME ATTRIBUTE ";
              goto LABEL_2041;
            case 6:
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 16), 0);
              v1183 = " RENAME COLUMN ";
              goto LABEL_2041;
            case 7:
            case 8:
            case 0xC:
            case 0x25:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
              v1163 = *(_QWORD *)(v18 + 24);
              if (v1163 && *(int *)(v1163 + 4) >= 1)
              {
                v1164 = 8;
                v1165 = 0;
                do
                {
                  v1166 = *(_QWORD *)(v1163 + 16);
                  v1167 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1166 + 8 * v1165) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1167);
                  v1168 = *(int *)(v1163 + 4);
                  if (v1166 + v1164)
                    v1169 = v1166 + v1164 >= (unint64_t)(*(_QWORD *)(v1163 + 16) + 8 * v1168);
                  else
                    v1169 = 1;
                  if (!v1169)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1168 = *(int *)(v1163 + 4);
                  }
                  ++v1165;
                  v1164 += 8;
                }
                while (v1165 < v1168);
              }
              goto LABEL_2025;
            case 9:
            case 0x1F:
            case 0x22:
            case 0x28:
              v1171 = *(_BYTE **)(v18 + 32);
              goto LABEL_2009;
            case 0xD:
              v1184 = *(_QWORD *)(v18 + 24);
              if (v1184 && *(int *)(v1184 + 4) >= 1)
              {
                v1185 = 8;
                v1186 = 0;
                do
                {
                  v1187 = *(_QWORD *)(v1184 + 16);
                  v1188 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1187 + 8 * v1186) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1188);
                  v1189 = *(int *)(v1184 + 4);
                  if (v1187 + v1185)
                    v1190 = v1187 + v1185 >= (unint64_t)(*(_QWORD *)(v1184 + 16) + 8 * v1189);
                  else
                    v1190 = 1;
                  if (!v1190)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1189 = *(int *)(v1184 + 4);
                  }
                  ++v1186;
                  v1185 += 8;
                }
                while (v1186 < v1189);
              }
              v1183 = " RENAME CONSTRAINT ";
              goto LABEL_2041;
            case 0xE:
            case 0x10:
            case 0x11:
            case 0x15:
            case 0x1D:
            case 0x24:
              v1171 = *(_BYTE **)(*(_QWORD *)(v18 + 24) + 8);
LABEL_2009:
              v1172 = quote_identifier(v1171);
              goto LABEL_2010;
            case 0x12:
            case 0x14:
            case 0x17:
            case 0x23:
            case 0x27:
            case 0x31:
              v1170 = *(_QWORD *)(v18 + 16);
              goto LABEL_2012;
            case 0x13:
            case 0x1C:
            case 0x20:
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 24));
              goto LABEL_2025;
            case 0x18:
            case 0x1A:
              v1174 = *(_QWORD *)(v18 + 24);
              if (!v1174)
                goto LABEL_2111;
              if (*(int *)(v1174 + 4) >= 2)
              {
                v1175 = 1;
                do
                {
                  v1176 = (uint64_t *)(*(_QWORD *)(v1174 + 16) + 8 * v1175);
                  v1178 = *v1176;
                  v1177 = (unint64_t)(v1176 + 1);
                  v1179 = quote_identifier(*(_BYTE **)(v1178 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1179);
                  v1180 = *(int *)(v1174 + 4);
                  if (v1177)
                    v1181 = v1177 >= *(_QWORD *)(v1174 + 16) + 8 * v1180;
                  else
                    v1181 = 1;
                  if (!v1181)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1180) = *(_DWORD *)(v1174 + 4);
                  }
                  ++v1175;
                }
                while ((int)v1180 > v1175);
              }
              appendStringInfoString((uint64_t)&__s1, " USING ");
              v1172 = quote_identifier(*(_BYTE **)(**(_QWORD **)(v1174 + 16) + 8));
LABEL_2010:
              appendStringInfoString((uint64_t)&__s1, v1172);
              goto LABEL_2025;
            case 0x1B:
            case 0x21:
            case 0x2A:
              v1173 = quote_identifier(*(_BYTE **)(v18 + 32));
              appendStringInfoString((uint64_t)&__s1, v1173);
              appendStringInfoString((uint64_t)&__s1, " ON ");
              v1170 = *(_QWORD *)(v18 + 16);
LABEL_2012:
              deparseRangeVar((uint64_t)&__s1, v1170, 0);
LABEL_2025:
              appendStringInfoString((uint64_t)&__s1, " RENAME ");
              break;
            case 0x26:
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 16), 0);
              v1183 = " RENAME CONSTRAINT ";
LABEL_2041:
              appendStringInfoString((uint64_t)&__s1, v1183);
              v1191 = quote_identifier(*(_BYTE **)(v19 + 32));
              appendStringInfoString((uint64_t)&__s1, v1191);
              appendStringInfoChar((uint64_t)&__s1, 32);
              break;
            default:
              break;
          }
          appendStringInfoString((uint64_t)&__s1, "TO ");
          v1182 = quote_identifier(*(_BYTE **)(v19 + 40));
          appendStringInfoString((uint64_t)&__s1, v1182);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_DWORD *)(v19 + 48) == 1)
            goto LABEL_2027;
          goto LABEL_2090;
        case 0x102:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(_BYTE *)(v18 + 48))
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          appendStringInfoString((uint64_t)&__s1, "RULE ");
          v117 = quote_identifier(*(_BYTE **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v117);
          appendStringInfoString((uint64_t)&__s1, " AS ON ");
          v118 = *(_DWORD *)(v18 + 32) - 1;
          if (v118 <= 3)
            appendStringInfoString((uint64_t)&__s1, (&off_1E264AB10)[v118]);
          appendStringInfoString((uint64_t)&__s1, "TO ");
          deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 8), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v119 = *(int **)(v18 + 24);
          if (v119)
          {
            appendStringInfoString((uint64_t)&__s1, "WHERE ");
            deparseExpr(&__s1, v119, v120, v121, v122, v123, v124, v125);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "DO ");
          if (*(_BYTE *)(v18 + 36))
            appendStringInfoString((uint64_t)&__s1, "INSTEAD ");
          v126 = *(_QWORD *)(v18 + 40);
          if (!v126)
            goto LABEL_180;
          v127 = *(_DWORD *)(v126 + 4);
          if (v127 == 1)
          {
            deparseRuleActionStmt(&__s1, **(_QWORD **)(v126 + 16));
          }
          else
          {
            if (!v127)
            {
LABEL_180:
              v27 = "NOTHING";
              goto LABEL_2102;
            }
            appendStringInfoChar((uint64_t)&__s1, 40);
            v620 = *(_QWORD *)(v18 + 40);
            if (v620 && *(int *)(v620 + 4) >= 1)
            {
              v621 = 8;
              v622 = 0;
              do
              {
                v623 = *(_QWORD *)(v620 + 16);
                deparseRuleActionStmt(&__s1, *(_QWORD *)(v623 + 8 * v622));
                if (v623 + v621)
                  v624 = v623 + v621 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 40) + 16)
                                                         + 8 * *(int *)(*(_QWORD *)(v19 + 40) + 4));
                else
                  v624 = 1;
                if (!v624)
                  appendStringInfoString((uint64_t)&__s1, "; ");
                ++v622;
                v621 += 8;
              }
              while (v622 < *(int *)(v620 + 4));
            }
LABEL_996:
            appendStringInfoChar((uint64_t)&__s1, 41);
          }
          goto LABEL_2103;
        case 0x103:
          appendStringInfoString((uint64_t)&__s1, "NOTIFY ");
          v387 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v387);
          if (!*(_QWORD *)(v18 + 16))
            goto LABEL_2103;
          appendStringInfoString((uint64_t)&__s1, ", ");
          v362 = *(char **)(v18 + 16);
          goto LABEL_1697;
        case 0x104:
          appendStringInfoString((uint64_t)&__s1, "LISTEN ");
          v108 = *(_BYTE **)(v18 + 8);
          goto LABEL_1816;
        case 0x105:
          appendStringInfoString((uint64_t)&__s1, "UNLISTEN ");
          v108 = *(_BYTE **)(v18 + 8);
          if (v108)
            goto LABEL_1816;
          v27 = "*";
          goto LABEL_2102;
        case 0x106:
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0:
              v396 = "BEGIN ";
              goto LABEL_1547;
            case 1:
              v396 = "START TRANSACTION ";
LABEL_1547:
              appendStringInfoString((uint64_t)&__s1, v396);
              deparseTransactionModeList((uint64_t)&__s1, *(_QWORD *)(v18 + 8));
              goto LABEL_2090;
            case 2:
              v890 = "COMMIT ";
              goto LABEL_1550;
            case 3:
              v890 = "ROLLBACK ";
LABEL_1550:
              appendStringInfoString((uint64_t)&__s1, v890);
              if (*(_BYTE *)(v18 + 32))
                appendStringInfoString((uint64_t)&__s1, "AND CHAIN ");
              goto LABEL_2090;
            case 4:
              v891 = "SAVEPOINT ";
              goto LABEL_1556;
            case 5:
              v891 = "RELEASE ";
              goto LABEL_1556;
            case 6:
              appendStringInfoString((uint64_t)&__s1, "ROLLBACK ");
              v891 = "TO SAVEPOINT ";
LABEL_1556:
              appendStringInfoString((uint64_t)&__s1, v891);
              v892 = quote_identifier(*(_BYTE **)(v18 + 16));
              appendStringInfoString((uint64_t)&__s1, v892);
              goto LABEL_2090;
            case 7:
              v893 = "PREPARE TRANSACTION ";
              goto LABEL_1560;
            case 8:
              v893 = "COMMIT PREPARED ";
              goto LABEL_1560;
            case 9:
              v893 = "ROLLBACK PREPARED ";
LABEL_1560:
              appendStringInfoString((uint64_t)&__s1, v893);
              deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
              break;
            default:
              goto LABEL_2090;
          }
          goto LABEL_2090;
        case 0x107:
          deparseViewStmt(&__s1, v18);
          goto LABEL_2103;
        case 0x108:
          appendStringInfoString((uint64_t)&__s1, "LOAD ");
          v362 = *(char **)(v18 + 8);
          goto LABEL_1697;
        case 0x109:
          appendStringInfoString((uint64_t)&__s1, "CREATE DOMAIN ");
          v347 = *(_QWORD *)(v18 + 8);
          if (v347 && *(int *)(v347 + 4) >= 1)
          {
            v348 = 8;
            v349 = 0;
            do
            {
              v350 = *(_QWORD *)(v347 + 16);
              v351 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v350 + 8 * v349) + 8));
              appendStringInfoString((uint64_t)&__s1, v351);
              v352 = *(int *)(v347 + 4);
              if (v350 + v348)
                v353 = v350 + v348 >= (unint64_t)(*(_QWORD *)(v347 + 16) + 8 * v352);
              else
                v353 = 1;
              if (!v353)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v352 = *(int *)(v347 + 4);
              }
              ++v349;
              v348 += 8;
            }
            while (v349 < v352);
          }
          appendStringInfoString((uint64_t)&__s1, " AS ");
          deparseTypeName(&__s1, *(_QWORD *)(v19 + 16));
          appendStringInfoChar((uint64_t)&__s1, 32);
          v356 = *(_QWORD *)(v19 + 24);
          if (v356)
          {
            deparseCollateClause((uint64_t)&__s1, v356);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          v357 = *(_QWORD *)(v19 + 32);
          if (v357 && *(int *)(v357 + 4) >= 1)
          {
            v358 = 0;
            do
            {
              v359 = v358;
              deparseConstraint(&__s1, *(_QWORD *)(*(_QWORD *)(v357 + 16) + 8 * v358));
              appendStringInfoChar((uint64_t)&__s1, 32);
              v358 = v359 + 1;
            }
            while (v359 + 1 < *(int *)(v357 + 4));
          }
          goto LABEL_2090;
        case 0x10A:
          appendStringInfoString((uint64_t)&__s1, "CREATE DATABASE ");
          v354 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v354);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreatedbOptList((unint64_t)&__s1, *(_QWORD *)(v18 + 16));
          v355 = (v1232 - 1);
          if ((int)v1232 < 1)
            goto LABEL_2103;
          goto LABEL_2091;
        case 0x10B:
          appendStringInfoString((uint64_t)&__s1, "DROP DATABASE ");
          if (*(_BYTE *)(v18 + 16))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          v363 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v363);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v364 = *(_QWORD *)(v18 + 24);
          if (!v364 || *(int *)(v364 + 4) < 1)
            goto LABEL_2090;
          appendStringInfoChar((uint64_t)&__s1, 40);
          v365 = *(_QWORD *)(v18 + 24);
          if (v365 && *(int *)(v365 + 4) >= 1)
          {
            v366 = 8;
            v367 = 0;
            do
            {
              v368 = *(_QWORD *)(v365 + 16);
              if (!strcmp(*(const char **)(*(_QWORD *)(v368 + 8 * v367) + 16), "force"))
                appendStringInfoString((uint64_t)&__s1, "FORCE");
              if (v368 + v366)
                v369 = v368 + v366 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 16)
                                                       + 8 * *(int *)(*(_QWORD *)(v19 + 24) + 4));
              else
                v369 = 1;
              if (!v369)
                appendStringInfoString((uint64_t)&__s1, ", ");
              ++v367;
              v366 += 8;
            }
            while (v367 < *(int *)(v365 + 4));
          }
          v556 = 41;
          goto LABEL_1309;
        case 0x10C:
          if (*(_BYTE *)(v18 + 24))
            v233 = "VACUUM ";
          else
            v233 = "ANALYZE ";
          appendStringInfoString((uint64_t)&__s1, v233);
          v234 = *(_QWORD *)(v18 + 8);
          if (v234 && *(int *)(v234 + 4) >= 1)
          {
            v235 = v17;
            appendStringInfoChar((uint64_t)&__s1, 40);
            v236 = *(_QWORD *)(v18 + 8);
            if (v236 && *(int *)(v236 + 4) >= 1)
            {
              v237 = 0;
              do
              {
                v238 = *(_QWORD *)(v236 + 16) + 8 * v237;
                v239 = *(_QWORD *)v238;
                v240 = (char *)pstrdup(*(const char **)(*(_QWORD *)v238 + 16));
                v241 = v240;
                if (*v240)
                {
                  v242 = *v240;
                  v243 = (unsigned __int8 *)(v240 + 1);
                  do
                  {
                    v244 = v243;
                    *(v243 - 1) = pg_toupper(v242);
                    v242 = *v244;
                    v243 = v244 + 1;
                  }
                  while (*v244);
                }
                appendStringInfoString((uint64_t)&__s1, v241);
                pfree((uint64_t)v241);
                if (*(_QWORD *)(v239 + 24))
                {
                  appendStringInfoChar((uint64_t)&__s1, 32);
                  v251 = *(char ***)(v239 + 24);
                  v252 = *(_DWORD *)v251;
                  if (*(_DWORD *)v251 == 223)
                  {
                    deparseOptBooleanOrString(&__s1, v251[1]);
                  }
                  else if (v252 == 222)
                  {
                    appendStringInfoString((uint64_t)&__s1, v251[1]);
                  }
                  else if (v252 == 221)
                  {
                    appendStringInfo((uint64_t)&__s1, "%d", v245, v246, v247, v248, v249, v250, *((unsigned int *)v251 + 2));
                  }
                }
                if (v238 != -8
                  && v238 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 8) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(v19 + 8) + 4)))
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                }
                ++v237;
              }
              while (v237 < *(int *)(v236 + 4));
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
            v17 = v235;
          }
          v536 = *(_QWORD *)(v19 + 16);
          if (v536 && *(int *)(v536 + 4) >= 1)
          {
            v537 = 0;
            v1224 = v19;
            do
            {
              v538 = *(_QWORD *)(v536 + 16) + 8 * v537;
              v539 = *(_QWORD *)v538;
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(*(_QWORD *)v538 + 8), 0);
              v540 = *(_QWORD *)(v539 + 24);
              if (v540 && *(int *)(v540 + 4) >= 1)
              {
                v541 = v16;
                v542 = v17;
                appendStringInfoChar((uint64_t)&__s1, 40);
                v543 = *(_QWORD *)(v539 + 24);
                if (v543 && *(int *)(v543 + 4) >= 1)
                {
                  v544 = 8;
                  v545 = 0;
                  do
                  {
                    v546 = *(_QWORD *)(v543 + 16);
                    v547 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v546 + 8 * v545) + 8));
                    appendStringInfoString((uint64_t)&__s1, v547);
                    if (v546 + v544)
                      v548 = v546 + v544 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v539 + 24) + 16)
                                                             + 8 * *(int *)(*(_QWORD *)(v539 + 24) + 4));
                    else
                      v548 = 1;
                    if (!v548)
                      appendStringInfoString((uint64_t)&__s1, ", ");
                    ++v545;
                    v544 += 8;
                  }
                  while (v545 < *(int *)(v543 + 4));
                }
                appendStringInfoChar((uint64_t)&__s1, 41);
                v17 = v542;
                v16 = v541;
                v19 = v1224;
              }
              if (v538 != -8
                && v538 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                               + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4)))
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
              ++v537;
            }
            while (v537 < *(int *)(v536 + 4));
          }
          goto LABEL_1481;
        case 0x10D:
          appendStringInfoString((uint64_t)&__s1, "EXPLAIN ");
          v165 = *(_QWORD *)(v18 + 16);
          if (v165 && *(int *)(v165 + 4) >= 1)
          {
            v166 = v17;
            appendStringInfoChar((uint64_t)&__s1, 40);
            v167 = *(_QWORD *)(v18 + 16);
            if (v167 && *(int *)(v167 + 4) >= 1)
            {
              v168 = 0;
              do
              {
                v169 = *(_QWORD *)(v167 + 16) + 8 * v168;
                v170 = *(_QWORD *)v169;
                v171 = (char *)pstrdup(*(const char **)(*(_QWORD *)v169 + 16));
                v172 = v171;
                if (*v171)
                {
                  v173 = *v171;
                  v174 = (unsigned __int8 *)(v171 + 1);
                  do
                  {
                    v175 = v174;
                    *(v174 - 1) = pg_toupper(v173);
                    v173 = *v175;
                    v174 = v175 + 1;
                  }
                  while (*v175);
                }
                appendStringInfoString((uint64_t)&__s1, v172);
                pfree((uint64_t)v172);
                v176 = *(int **)(v170 + 24);
                if (v176)
                {
                  v177 = *v176;
                  if (v177 == 223)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 32);
                    deparseOptBooleanOrString(&__s1, *(char **)(*(_QWORD *)(v170 + 24) + 8));
                  }
                  else if ((v177 - 221) <= 1)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 32);
                    v184 = *(_QWORD *)(v170 + 24);
                    if (*(_DWORD *)v184 == 222)
                    {
                      appendStringInfoString((uint64_t)&__s1, *(char **)(v184 + 8));
                    }
                    else if (*(_DWORD *)v184 == 221)
                    {
                      appendStringInfo((uint64_t)&__s1, "%d", v178, v179, v180, v181, v182, v183, *(unsigned int *)(v184 + 8));
                    }
                  }
                }
                if (v169 != -8
                  && v169 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4)))
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                }
                ++v168;
              }
              while (v168 < *(int *)(v167 + 4));
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
            v15 = v1226;
            v17 = v166;
          }
          v535 = *(uint64_t **)(v19 + 8);
          switch(*(_DWORD *)v535)
          {
            case 0xE9:
              goto LABEL_814;
            case 0xEA:
              goto LABEL_958;
            case 0xEB:
              goto LABEL_959;
            case 0xEC:
              goto LABEL_960;
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
            case 0x100:
            case 0x101:
            case 0x102:
            case 0x103:
            case 0x104:
            case 0x105:
            case 0x106:
            case 0x107:
            case 0x108:
            case 0x109:
            case 0x10A:
            case 0x10B:
            case 0x10C:
            case 0x10D:
            case 0x10F:
            case 0x110:
            case 0x111:
            case 0x112:
            case 0x113:
            case 0x114:
            case 0x115:
            case 0x116:
            case 0x117:
            case 0x118:
            case 0x119:
            case 0x11A:
            case 0x11B:
            case 0x11C:
            case 0x11D:
            case 0x11E:
            case 0x11F:
            case 0x120:
            case 0x121:
            case 0x122:
            case 0x123:
            case 0x124:
            case 0x125:
            case 0x126:
            case 0x128:
              goto LABEL_2103;
            case 0x10E:
              deparseCreateTableAsStmt(&__s1, (uint64_t)v535);
              break;
            case 0x127:
              deparseExecuteStmt(&__s1, (uint64_t)v535);
              break;
            case 0x129:
              deparseDeclareCursorStmt(&__s1, (uint64_t)v535);
              break;
            default:
              if (*(_DWORD *)v535 == 563)
                deparseRefreshMatViewStmt((uint64_t)&__s1, (uint64_t)v535);
              break;
          }
          goto LABEL_2103;
        case 0x10E:
          deparseCreateTableAsStmt(&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0x10F:
          deparseCreateSeqStmt(&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0x110:
          appendStringInfoString((uint64_t)&__s1, "ALTER SEQUENCE ");
          if (*(_BYTE *)(v18 + 25))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 8), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v201 = *(_QWORD *)(v18 + 16);
          if (v201 && *(int *)(v201 + 4) >= 1)
          {
            v202 = 0;
            do
            {
              v203 = v202;
              deparseSeqOptElem(&__s1, *(_QWORD *)(*(_QWORD *)(v201 + 16) + 8 * v202));
              appendStringInfoChar((uint64_t)&__s1, 32);
              v202 = v203 + 1;
            }
            while (v203 + 1 < *(int *)(v201 + 4));
          }
          goto LABEL_2090;
        case 0x111:
          deparseVariableSetStmt((uint64_t)&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0x112:
          appendStringInfoString((uint64_t)&__s1, "SHOW ");
          v98 = *(const char **)(v18 + 8);
          if (!strcmp(v98, "timezone"))
          {
            v27 = "TIME ZONE";
          }
          else if (!strcmp(v98, "transaction_isolation"))
          {
            v27 = "TRANSACTION ISOLATION LEVEL";
          }
          else if (!strcmp(v98, "session_authorization"))
          {
            v27 = "SESSION AUTHORIZATION";
          }
          else if (!strcmp(v98, "all"))
          {
            v27 = "SESSION ALL";
          }
          else
          {
            v27 = (char *)v98;
          }
          goto LABEL_2102;
        case 0x113:
          appendStringInfoString((uint64_t)&__s1, "DISCARD ");
          v408 = *(int *)(v18 + 4);
          if (v408 > 3)
            goto LABEL_2103;
          v27 = (&off_1E264A8F8)[v408];
          goto LABEL_2102;
        case 0x114:
          deparseCreateTrigStmt(&__s1, v18);
          goto LABEL_2103;
        case 0x115:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(_BYTE *)(v18 + 4))
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          if (*(_BYTE *)(v18 + 40))
            appendStringInfoString((uint64_t)&__s1, "TRUSTED ");
          appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
          v106 = *(char **)(v18 + 8);
          v107 = strlen(v106);
          if (v107)
          {
            if (v107 >= 0x40)
            {
              deparseStringLiteral((uint64_t)&__s1, v106);
              goto LABEL_927;
            }
            v566 = quote_identifier(v106);
          }
          else
          {
            v566 = "''";
          }
          appendStringInfoString((uint64_t)&__s1, v566);
LABEL_927:
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "HANDLER ");
          v592 = *(_QWORD *)(v18 + 16);
          if (v592 && *(int *)(v592 + 4) >= 1)
          {
            v593 = 8;
            v594 = 0;
            do
            {
              v595 = *(_QWORD *)(v592 + 16);
              v596 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v595 + 8 * v594) + 8));
              appendStringInfoString((uint64_t)&__s1, v596);
              v597 = *(int *)(v592 + 4);
              if (v595 + v593)
                v598 = v595 + v593 >= (unint64_t)(*(_QWORD *)(v592 + 16) + 8 * v597);
              else
                v598 = 1;
              if (!v598)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v597 = *(int *)(v592 + 4);
              }
              ++v594;
              v593 += 8;
            }
            while (v594 < v597);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_QWORD *)(v19 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "INLINE ");
            v599 = *(_QWORD *)(v19 + 24);
            if (v599 && *(int *)(v599 + 4) >= 1)
            {
              v600 = 8;
              v601 = 0;
              do
              {
                v602 = *(_QWORD *)(v599 + 16);
                v603 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v602 + 8 * v601) + 8));
                appendStringInfoString((uint64_t)&__s1, v603);
                v604 = *(int *)(v599 + 4);
                if (v602 + v600)
                  v605 = v602 + v600 >= (unint64_t)(*(_QWORD *)(v599 + 16) + 8 * v604);
                else
                  v605 = 1;
                if (!v605)
                {
                  appendStringInfoChar((uint64_t)&__s1, 46);
                  v604 = *(int *)(v599 + 4);
                }
                ++v601;
                v600 += 8;
              }
              while (v601 < v604);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (!*(_QWORD *)(v19 + 32))
            goto LABEL_2090;
          appendStringInfoString((uint64_t)&__s1, "VALIDATOR ");
          v606 = *(_QWORD *)(v19 + 32);
          if (v606 && *(int *)(v606 + 4) >= 1)
          {
            v607 = 8;
            v608 = 0;
            do
            {
              v609 = *(_QWORD *)(v606 + 16);
              v610 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v609 + 8 * v608) + 8));
              appendStringInfoString((uint64_t)&__s1, v610);
              v611 = *(int *)(v606 + 4);
              if (v609 + v607)
                v612 = v609 + v607 >= (unint64_t)(*(_QWORD *)(v606 + 16) + 8 * v611);
              else
                v612 = 1;
              if (!v612)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v611 = *(int *)(v606 + 4);
              }
              ++v608;
              v607 += 8;
            }
            while (v608 < v611);
          }
          v556 = 32;
          goto LABEL_1309;
        case 0x116:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          v334 = *(int *)(v18 + 4);
          if (v334 <= 2)
            appendStringInfoString((uint64_t)&__s1, (&off_1E264A8E0)[v334]);
          v335 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v335);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(_QWORD *)(v18 + 16))
            goto LABEL_2090;
          appendStringInfoString((uint64_t)&__s1, "WITH ");
          v336 = *(_QWORD *)(v18 + 16);
          if (!v336 || *(int *)(v336 + 4) < 1)
            goto LABEL_2090;
          v337 = 0;
          while (1)
          {
            v338 = *(_QWORD *)(*(_QWORD *)(v336 + 16) + 8 * v337);
            v339 = *(const char **)(v338 + 16);
            if (!strcmp(v339, "sysid"))
            {
              appendStringInfo((uint64_t)&__s1, "SYSID %d", v340, v341, v342, v343, v344, v345, *(unsigned int *)(*(_QWORD *)(v338 + 24) + 8));
            }
            else
            {
              if (!strcmp(v339, "adminmembers"))
              {
                v346 = "ADMIN ";
LABEL_523:
                appendStringInfoString((uint64_t)&__s1, v346);
                deparseRoleList(&__s1, *(_QWORD *)(v338 + 24));
                goto LABEL_514;
              }
              if (!strcmp(v339, "rolemembers"))
              {
                v346 = "ROLE ";
                goto LABEL_523;
              }
              if (!strcmp(v339, "addroleto"))
              {
                v346 = "IN ROLE ";
                goto LABEL_523;
              }
              deparseAlterRoleElem((uint64_t)&__s1, v338);
            }
LABEL_514:
            appendStringInfoChar((uint64_t)&__s1, 32);
            if (++v337 >= *(int *)(v336 + 4))
              goto LABEL_2090;
          }
        case 0x117:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          v409 = *(_QWORD *)(v18 + 16);
          if (!v409
            || *(_DWORD *)(v409 + 4) != 1
            || strcmp(*(const char **)(**(_QWORD **)(v409 + 16) + 16), "rolemembers"))
          {
            appendStringInfoString((uint64_t)&__s1, "ROLE ");
            v410 = *(_QWORD *)(v18 + 8);
            switch(*(_DWORD *)(v410 + 4))
            {
              case 0:
                v411 = quote_identifier(*(_BYTE **)(v410 + 8));
                goto LABEL_1080;
              case 1:
                v411 = "CURRENT_USER";
                goto LABEL_1080;
              case 2:
                v411 = "SESSION_USER";
                goto LABEL_1080;
              case 3:
                v411 = "public";
LABEL_1080:
                appendStringInfoString((uint64_t)&__s1, v411);
                break;
              default:
                break;
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
            appendStringInfoString((uint64_t)&__s1, "WITH ");
            v662 = *(_QWORD *)(v18 + 16);
            if (v662 && *(int *)(v662 + 4) >= 1)
            {
              v663 = 0;
              do
              {
                v664 = v663;
                deparseAlterRoleElem((uint64_t)&__s1, *(_QWORD *)(*(_QWORD *)(v662 + 16) + 8 * v663));
                appendStringInfoChar((uint64_t)&__s1, 32);
                v663 = v664 + 1;
              }
              while (v664 + 1 < *(int *)(v662 + 4));
            }
            goto LABEL_2090;
          }
          appendStringInfoString((uint64_t)&__s1, "GROUP ");
          v848 = *(_QWORD *)(v18 + 8);
          switch(*(_DWORD *)(v848 + 4))
          {
            case 0:
              v849 = quote_identifier(*(_BYTE **)(v848 + 8));
              goto LABEL_2045;
            case 1:
              v849 = "CURRENT_USER";
              goto LABEL_2045;
            case 2:
              v849 = "SESSION_USER";
              goto LABEL_2045;
            case 3:
              v849 = "public";
LABEL_2045:
              appendStringInfoString((uint64_t)&__s1, v849);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          v1192 = *(_DWORD *)(v18 + 24);
          if (v1192 == 1)
          {
            v1193 = "ADD USER ";
          }
          else
          {
            if (v1192 != -1)
            {
LABEL_2051:
              deparseRoleList(&__s1, *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v18 + 16) + 16) + 24));
              goto LABEL_2090;
            }
            v1193 = "DROP USER ";
          }
          appendStringInfoString((uint64_t)&__s1, v1193);
          goto LABEL_2051;
        case 0x118:
          appendStringInfoString((uint64_t)&__s1, "DROP ROLE ");
          if (*(_BYTE *)(v18 + 16))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          deparseRoleList(&__s1, *(_QWORD *)(v18 + 8));
          goto LABEL_2103;
        case 0x119:
          appendStringInfoString((uint64_t)&__s1, "LOCK TABLE ");
          v293 = *(_QWORD *)(v18 + 8);
          if (v293 && *(int *)(v293 + 4) >= 1)
          {
            v294 = 8;
            v295 = 0;
            do
            {
              v296 = *(_QWORD *)(v293 + 16);
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v296 + 8 * v295), 0);
              v297 = *(int *)(v293 + 4);
              if (v296 + v294)
                v298 = v296 + v294 >= (unint64_t)(*(_QWORD *)(v293 + 16) + 8 * v297);
              else
                v298 = 1;
              if (!v298)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                v297 = *(int *)(v293 + 4);
              }
              ++v295;
              v294 += 8;
            }
            while (v295 < v297);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_DWORD *)(v19 + 16) != 8)
          {
            appendStringInfoString((uint64_t)&__s1, "IN ");
            v299 = *(_DWORD *)(v19 + 16) - 1;
            if (v299 <= 7)
              appendStringInfoString((uint64_t)&__s1, (&off_1E264AAA8)[v299]);
            appendStringInfoString((uint64_t)&__s1, "MODE ");
          }
          if (*(_BYTE *)(v19 + 20))
            appendStringInfoString((uint64_t)&__s1, "NOWAIT ");
          goto LABEL_2090;
        case 0x11A:
          appendStringInfoString((uint64_t)&__s1, "SET CONSTRAINTS ");
          v399 = *(_QWORD *)(v18 + 8);
          if (v399 && *(int *)(v399 + 4) >= 1)
          {
            v400 = 8;
            v401 = 0;
            do
            {
              v402 = *(_QWORD *)(v399 + 16);
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v402 + 8 * v401), 0);
              v403 = *(int *)(v399 + 4);
              if (v402 + v400)
                v404 = v402 + v400 >= (unint64_t)(*(_QWORD *)(v399 + 16) + 8 * v403);
              else
                v404 = 1;
              if (!v404)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                v403 = *(int *)(v399 + 4);
              }
              ++v401;
              v400 += 8;
            }
            while (v401 < v403);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          else
          {
            appendStringInfoString((uint64_t)&__s1, "ALL ");
          }
          if (*(_BYTE *)(v19 + 16))
            v27 = "DEFERRED";
          else
            v27 = "IMMEDIATE";
          goto LABEL_2102;
        case 0x11B:
          appendStringInfoString((uint64_t)&__s1, "REINDEX ");
          if ((*(_BYTE *)(v18 + 24) & 1) != 0)
          {
            appendStringInfoString((uint64_t)&__s1, "(VERBOSE) ");
            v423 = *(int *)(v18 + 4);
            if (v423 <= 4)
            {
LABEL_660:
              appendStringInfoString((uint64_t)&__s1, (&off_1E264AAE8)[v423]);
              if (!*(_BYTE *)(v18 + 28))
                goto LABEL_789;
              goto LABEL_788;
            }
          }
          else
          {
            v423 = *(int *)(v18 + 4);
            if (v423 <= 4)
              goto LABEL_660;
          }
          if (!*(_BYTE *)(v18 + 28))
            goto LABEL_789;
LABEL_788:
          appendStringInfoString((uint64_t)&__s1, "CONCURRENTLY ");
LABEL_789:
          v510 = *(_QWORD *)(v18 + 8);
          if (v510)
          {
            deparseRangeVar((uint64_t)&__s1, v510, 0);
            goto LABEL_2103;
          }
          v108 = *(_BYTE **)(v18 + 16);
          if (v108)
          {
LABEL_1816:
            v27 = quote_identifier(v108);
LABEL_2102:
            appendStringInfoString((uint64_t)&__s1, v27);
          }
LABEL_2103:
          if (v17 != -8 && v17 + 8 < (unint64_t)(*(_QWORD *)(v15 + 16) + 8 * *(int *)(v15 + 4)))
            appendStringInfoString((uint64_t)&__s1, "; ");
          v16 = (v16 + 1);
          if ((int)v16 >= *(_DWORD *)(v15 + 4))
            goto LABEL_2107;
          continue;
        case 0x11C:
          v27 = "CHECKPOINT";
          goto LABEL_2102;
        case 0x11D:
          appendStringInfoString((uint64_t)&__s1, "CREATE SCHEMA ");
          if (*(_BYTE *)(v18 + 32))
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          v383 = *(_BYTE **)(v18 + 8);
          if (v383)
          {
            v384 = quote_identifier(v383);
            appendStringInfoString((uint64_t)&__s1, v384);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(_QWORD *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "AUTHORIZATION ");
            v385 = *(_QWORD *)(v18 + 16);
            switch(*(_DWORD *)(v385 + 4))
            {
              case 0:
                v386 = quote_identifier(*(_BYTE **)(v385 + 8));
                goto LABEL_1463;
              case 1:
                v386 = "CURRENT_USER";
                goto LABEL_1463;
              case 2:
                v386 = "SESSION_USER";
                goto LABEL_1463;
              case 3:
                v386 = "public";
LABEL_1463:
                appendStringInfoString((uint64_t)&__s1, v386);
                break;
              default:
                break;
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          v841 = *(_QWORD *)(v18 + 24);
          if (v841 && *(int *)(v841 + 4) >= 1)
          {
            v842 = 8;
            v843 = 0;
            do
            {
              v844 = *(_QWORD *)(v841 + 16);
              v845 = *(_DWORD **)(v844 + 8 * v843);
              switch(*v845)
              {
                case 0xF1:
                  deparseGrantStmt((uint64_t)&__s1, (uint64_t)v845);
                  break;
                case 0xF7:
                  deparseCreateStmt(&__s1, (uint64_t)v845, 0);
                  break;
                case 0xFD:
                  deparseIndexStmt(&__s1, (uint64_t)v845);
                  break;
                case 0x107:
                  deparseViewStmt(&__s1, (uint64_t)v845);
                  break;
                case 0x10F:
                  deparseCreateSeqStmt(&__s1, (uint64_t)v845);
                  break;
                case 0x114:
                  deparseCreateTrigStmt(&__s1, (uint64_t)v845);
                  break;
                default:
                  break;
              }
              if (v844 + v842)
                v846 = v844 + v842 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 16)
                                                       + 8 * *(int *)(*(_QWORD *)(v19 + 24) + 4));
              else
                v846 = 1;
              if (!v846)
                appendStringInfoChar((uint64_t)&__s1, 32);
              ++v843;
              v842 += 8;
            }
            while (v843 < *(int *)(v841 + 4));
          }
          goto LABEL_1481;
        case 0x11E:
          appendStringInfoString((uint64_t)&__s1, "ALTER DATABASE ");
          v370 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v370);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreatedbOptList((unint64_t)&__s1, *(_QWORD *)(v18 + 16));
          goto LABEL_2090;
        case 0x11F:
          appendStringInfoString((uint64_t)&__s1, "ALTER DATABASE ");
          v360 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v360);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v361 = *(_QWORD *)(v18 + 16);
          goto LABEL_1490;
        case 0x120:
          appendStringInfoString((uint64_t)&__s1, "ALTER ROLE ");
          v421 = *(_QWORD *)(v18 + 8);
          if (v421)
          {
            switch(*(_DWORD *)(v421 + 4))
            {
              case 0:
                v422 = quote_identifier(*(_BYTE **)(v421 + 8));
                goto LABEL_1486;
              case 1:
                v422 = "CURRENT_USER";
                goto LABEL_1486;
              case 2:
                v422 = "SESSION_USER";
                goto LABEL_1486;
              case 3:
                v422 = "public";
                goto LABEL_1486;
              default:
                break;
            }
          }
          else
          {
            v422 = "ALL";
LABEL_1486:
            appendStringInfoString((uint64_t)&__s1, v422);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_QWORD *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "IN DATABASE ");
            v847 = quote_identifier(*(_BYTE **)(v18 + 16));
            appendStringInfoString((uint64_t)&__s1, v847);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          v361 = *(_QWORD *)(v18 + 24);
          goto LABEL_1490;
        case 0x121:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(_BYTE *)(v18 + 40))
            appendStringInfoString((uint64_t)&__s1, "DEFAULT ");
          appendStringInfoString((uint64_t)&__s1, "CONVERSION ");
          v204 = *(_QWORD *)(v18 + 8);
          if (v204 && *(int *)(v204 + 4) >= 1)
          {
            v205 = 8;
            v206 = 0;
            do
            {
              v207 = *(_QWORD *)(v204 + 16);
              v208 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v207 + 8 * v206) + 8));
              appendStringInfoString((uint64_t)&__s1, v208);
              v209 = *(int *)(v204 + 4);
              if (v207 + v205)
                v210 = v207 + v205 >= (unint64_t)(*(_QWORD *)(v204 + 16) + 8 * v209);
              else
                v210 = 1;
              if (!v210)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v209 = *(int *)(v204 + 4);
              }
              ++v206;
              v205 += 8;
            }
            while (v206 < v209);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "FOR ");
          deparseStringLiteral((uint64_t)&__s1, *(char **)(v19 + 16));
          appendStringInfoString((uint64_t)&__s1, " TO ");
          deparseStringLiteral((uint64_t)&__s1, *(char **)(v19 + 24));
          appendStringInfoString((uint64_t)&__s1, "FROM ");
          v211 = *(_QWORD *)(v19 + 32);
          if (v211 && *(int *)(v211 + 4) >= 1)
          {
            v212 = 8;
            v213 = 0;
            do
            {
              v214 = *(_QWORD *)(v211 + 16);
              v215 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v214 + 8 * v213) + 8));
              appendStringInfoString((uint64_t)&__s1, v215);
              v216 = *(int *)(v211 + 4);
              if (v214 + v212)
                v217 = v214 + v212 >= (unint64_t)(*(_QWORD *)(v211 + 16) + 8 * v216);
              else
                v217 = 1;
              if (!v217)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v216 = *(int *)(v211 + 4);
              }
              ++v213;
              v212 += 8;
            }
            while (v213 < v216);
          }
          goto LABEL_2103;
        case 0x122:
          appendStringInfoString((uint64_t)&__s1, "CREATE CAST (");
          deparseTypeName(&__s1, *(_QWORD *)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, " AS ");
          deparseTypeName(&__s1, *(_QWORD *)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, ") ");
          if (*(_QWORD *)(v18 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "WITH FUNCTION ");
            deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
            v277 = *(_DWORD *)(v18 + 32);
            if (v277)
            {
LABEL_421:
              if (v277 != 1)
                goto LABEL_2103;
              v27 = "AS ASSIGNMENT";
              goto LABEL_2102;
            }
          }
          else
          {
            if (*(_BYTE *)(v18 + 36))
              v567 = "WITH INOUT ";
            else
              v567 = "WITHOUT FUNCTION ";
            appendStringInfoString((uint64_t)&__s1, v567);
            v277 = *(_DWORD *)(v18 + 32);
            if (v277)
              goto LABEL_421;
          }
          v27 = "AS IMPLICIT";
          goto LABEL_2102;
        case 0x123:
          appendStringInfoString((uint64_t)&__s1, "CREATE OPERATOR CLASS ");
          v432 = *(_QWORD *)(v18 + 8);
          if (v432 && *(int *)(v432 + 4) >= 1)
          {
            v433 = 8;
            v434 = 0;
            do
            {
              v435 = *(_QWORD *)(v432 + 16);
              v436 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v435 + 8 * v434) + 8));
              appendStringInfoString((uint64_t)&__s1, v436);
              v437 = *(int *)(v432 + 4);
              if (v435 + v433)
                v438 = v435 + v433 >= (unint64_t)(*(_QWORD *)(v432 + 16) + 8 * v437);
              else
                v438 = 1;
              if (!v438)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v437 = *(int *)(v432 + 4);
              }
              ++v434;
              v433 += 8;
            }
            while (v434 < v437);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_BYTE *)(v19 + 48))
            appendStringInfoString((uint64_t)&__s1, "DEFAULT ");
          appendStringInfoString((uint64_t)&__s1, "FOR TYPE ");
          deparseTypeName(&__s1, *(_QWORD *)(v19 + 32));
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "USING ");
          v446 = quote_identifier(*(_BYTE **)(v19 + 24));
          appendStringInfoString((uint64_t)&__s1, v446);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_QWORD *)(v19 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "FAMILY ");
            v447 = *(_QWORD *)(v19 + 16);
            if (v447 && *(int *)(v447 + 4) >= 1)
            {
              v448 = 8;
              v449 = 0;
              do
              {
                v450 = *(_QWORD *)(v447 + 16);
                v451 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v450 + 8 * v449) + 8));
                appendStringInfoString((uint64_t)&__s1, v451);
                v452 = *(int *)(v447 + 4);
                if (v450 + v448)
                  v453 = v450 + v448 >= (unint64_t)(*(_QWORD *)(v447 + 16) + 8 * v452);
                else
                  v453 = 1;
                if (!v453)
                {
                  appendStringInfoChar((uint64_t)&__s1, 46);
                  v452 = *(int *)(v447 + 4);
                }
                ++v449;
                v448 += 8;
              }
              while (v449 < v452);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "AS ");
          v96 = *(_QWORD *)(v19 + 40);
          goto LABEL_778;
        case 0x124:
          appendStringInfoString((uint64_t)&__s1, "CREATE OPERATOR FAMILY ");
          v143 = *(_QWORD *)(v18 + 8);
          if (v143 && *(int *)(v143 + 4) >= 1)
          {
            v144 = 8;
            v145 = 0;
            do
            {
              v146 = *(_QWORD *)(v143 + 16);
              v147 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v146 + 8 * v145) + 8));
              appendStringInfoString((uint64_t)&__s1, v147);
              v148 = *(int *)(v143 + 4);
              if (v146 + v144)
                v149 = v146 + v144 >= (unint64_t)(*(_QWORD *)(v143 + 16) + 8 * v148);
              else
                v149 = 1;
              if (!v149)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v148 = *(int *)(v143 + 4);
              }
              ++v145;
              v144 += 8;
            }
            while (v145 < v148);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          v158 = "USING ";
          goto LABEL_1018;
        case 0x125:
          appendStringInfoString((uint64_t)&__s1, "ALTER OPERATOR FAMILY ");
          v87 = *(_QWORD *)(v18 + 8);
          if (v87 && *(int *)(v87 + 4) >= 1)
          {
            v88 = 8;
            v89 = 0;
            do
            {
              v90 = *(_QWORD *)(v87 + 16);
              v91 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v90 + 8 * v89) + 8));
              appendStringInfoString((uint64_t)&__s1, v91);
              v92 = *(int *)(v87 + 4);
              if (v90 + v88)
                v93 = v90 + v88 >= (unint64_t)(*(_QWORD *)(v87 + 16) + 8 * v92);
              else
                v93 = 1;
              if (!v93)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v92 = *(int *)(v87 + 4);
              }
              ++v89;
              v88 += 8;
            }
            while (v89 < v92);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "USING ");
          v94 = quote_identifier(*(_BYTE **)(v19 + 16));
          appendStringInfoString((uint64_t)&__s1, v94);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_BYTE *)(v19 + 24))
            v95 = "DROP ";
          else
            v95 = "ADD ";
          appendStringInfoString((uint64_t)&__s1, v95);
          v96 = *(_QWORD *)(v19 + 32);
LABEL_778:
          deparseOpclassItemList((unint64_t)&__s1, v96);
          goto LABEL_2103;
        case 0x126:
          appendStringInfoString((uint64_t)&__s1, "PREPARE ");
          v150 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v150);
          v151 = *(_QWORD *)(v18 + 16);
          if (v151 && *(int *)(v151 + 4) >= 1)
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            v152 = *(_QWORD *)(v18 + 16);
            if (v152 && *(int *)(v152 + 4) >= 1)
            {
              v153 = 8;
              v154 = 0;
              do
              {
                v155 = *(_QWORD *)(v152 + 16);
                deparseTypeName(&__s1, *(_QWORD *)(v155 + 8 * v154));
                v156 = *(int *)(v152 + 4);
                if (v155 + v153)
                  v157 = v155 + v153 >= (unint64_t)(*(_QWORD *)(v152 + 16) + 8 * v156);
                else
                  v157 = 1;
                if (!v157)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  v156 = *(int *)(v152 + 4);
                }
                ++v154;
                v153 += 8;
              }
              while (v154 < v156);
            }
            appendStringInfoChar((uint64_t)&__s1, 41);
          }
          appendStringInfoString((uint64_t)&__s1, " AS ");
          v535 = *(uint64_t **)(v19 + 24);
          switch(*(_DWORD *)v535)
          {
            case 0xE9:
LABEL_814:
              deparseInsertStmt(&__s1, (uint64_t)v535);
              break;
            case 0xEA:
LABEL_958:
              deparseDeleteStmt(&__s1, v535);
              break;
            case 0xEB:
LABEL_959:
              deparseUpdateStmt(&__s1, v535);
              break;
            case 0xEC:
LABEL_960:
              deparseSelectStmt(&__s1, (uint64_t)v535);
              break;
            default:
              goto LABEL_2103;
          }
          goto LABEL_2103;
        case 0x127:
          deparseExecuteStmt(&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0x128:
          appendStringInfoString((uint64_t)&__s1, "DEALLOCATE ");
          v108 = *(_BYTE **)(v18 + 8);
          if (v108)
            goto LABEL_1816;
LABEL_341:
          v27 = "ALL";
          goto LABEL_2102;
        case 0x129:
          deparseDeclareCursorStmt(&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0x12A:
          appendStringInfoString((uint64_t)&__s1, "CREATE TABLESPACE ");
          v101 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v101);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_QWORD *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "OWNER ");
            v102 = *(_QWORD *)(v18 + 16);
            switch(*(_DWORD *)(v102 + 4))
            {
              case 0:
                v103 = quote_identifier(*(_BYTE **)(v102 + 8));
                goto LABEL_1200;
              case 1:
                v103 = "CURRENT_USER";
                goto LABEL_1200;
              case 2:
                v103 = "SESSION_USER";
                goto LABEL_1200;
              case 3:
                v103 = "public";
LABEL_1200:
                appendStringInfoString((uint64_t)&__s1, v103);
                break;
              default:
                break;
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "LOCATION ");
          deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
          appendStringInfoChar((uint64_t)&__s1, 32);
          v732 = *(_QWORD *)(v18 + 32);
          if (!v732 || *(int *)(v732 + 4) < 1)
            goto LABEL_2090;
          appendStringInfoString((uint64_t)&__s1, "WITH ");
          deparseRelOptions(&__s1, v732);
          goto LABEL_1308;
        case 0x12B:
          v97 = "DROP TABLESPACE ";
          goto LABEL_628;
        case 0x12C:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0x13:
              v109 = "FUNCTION ";
              goto LABEL_1181;
            case 0x14:
              v723 = "INDEX ";
              goto LABEL_1179;
            case 0x17:
              v723 = "MATERIALIZED VIEW ";
              goto LABEL_1179;
            case 0x1C:
              v109 = "PROCEDURE ";
              goto LABEL_1181;
            case 0x20:
              v109 = "ROUTINE ";
LABEL_1181:
              appendStringInfoString((uint64_t)&__s1, v109);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 16));
              break;
            case 0x2A:
              appendStringInfoString((uint64_t)&__s1, "TRIGGER ");
              v724 = quote_identifier(*(_BYTE **)(**(_QWORD **)(*(_QWORD *)(v18 + 16) + 16) + 8));
              appendStringInfoString((uint64_t)&__s1, v724);
              v723 = " ON ";
LABEL_1179:
              appendStringInfoString((uint64_t)&__s1, v723);
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 8), 0);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_BYTE *)(v18 + 32))
            appendStringInfoString((uint64_t)&__s1, "NO ");
          appendStringInfoString((uint64_t)&__s1, "DEPENDS ON EXTENSION ");
          v108 = *(_BYTE **)(*(_QWORD *)(v18 + 24) + 8);
          goto LABEL_1816;
        case 0x12D:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              appendStringInfoString((uint64_t)&__s1, "AGGREGATE ");
              deparseAggregateWithArgtypes(&__s1, *(_QWORD *)(v18 + 16));
              break;
            case 7:
              appendStringInfoString((uint64_t)&__s1, "COLLATION ");
              v991 = *(_QWORD *)(v18 + 16);
              if (v991 && *(int *)(v991 + 4) >= 1)
              {
                v992 = 8;
                v993 = 0;
                do
                {
                  v994 = *(_QWORD *)(v991 + 16);
                  v995 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v994 + 8 * v993) + 8));
                  appendStringInfoString((uint64_t)&__s1, v995);
                  v996 = *(int *)(v991 + 4);
                  if (v994 + v992)
                    v997 = v994 + v992 >= (unint64_t)(*(_QWORD *)(v991 + 16) + 8 * v996);
                  else
                    v997 = 1;
                  if (!v997)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v996 = *(int *)(v991 + 4);
                  }
                  ++v993;
                  v992 += 8;
                }
                while (v993 < v996);
              }
              break;
            case 8:
              appendStringInfoString((uint64_t)&__s1, "CONVERSION ");
              v998 = *(_QWORD *)(v18 + 16);
              if (v998 && *(int *)(v998 + 4) >= 1)
              {
                v999 = 8;
                v1000 = 0;
                do
                {
                  v1001 = *(_QWORD *)(v998 + 16);
                  v1002 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1001 + 8 * v1000) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1002);
                  v1003 = *(int *)(v998 + 4);
                  if (v1001 + v999)
                    v1004 = v1001 + v999 >= (unint64_t)(*(_QWORD *)(v998 + 16) + 8 * v1003);
                  else
                    v1004 = 1;
                  if (!v1004)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1003 = *(int *)(v998 + 4);
                  }
                  ++v1000;
                  v999 += 8;
                }
                while (v1000 < v1003);
              }
              break;
            case 0xC:
              appendStringInfoString((uint64_t)&__s1, "DOMAIN ");
              v1005 = *(_QWORD *)(v18 + 16);
              if (v1005 && *(int *)(v1005 + 4) >= 1)
              {
                v1006 = 8;
                v1007 = 0;
                do
                {
                  v1008 = *(_QWORD *)(v1005 + 16);
                  v1009 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1008 + 8 * v1007) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1009);
                  v1010 = *(int *)(v1005 + 4);
                  if (v1008 + v1006)
                    v1011 = v1008 + v1006 >= (unint64_t)(*(_QWORD *)(v1005 + 16) + 8 * v1010);
                  else
                    v1011 = 1;
                  if (!v1011)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1010 = *(int *)(v1005 + 4);
                  }
                  ++v1007;
                  v1006 += 8;
                }
                while (v1007 < v1010);
              }
              break;
            case 0xF:
              appendStringInfoString((uint64_t)&__s1, "EXTENSION ");
              v1012 = *(_QWORD *)(v18 + 16);
              goto LABEL_1760;
            case 0x12:
              v1013 = "FOREIGN TABLE ";
              goto LABEL_1812;
            case 0x13:
              v1014 = "FUNCTION ";
              goto LABEL_1763;
            case 0x17:
              v1013 = "MATERIALIZED VIEW ";
              goto LABEL_1812;
            case 0x18:
              v1015 = *(_QWORD *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR CLASS ");
              if (!v1015)
                goto LABEL_2111;
              if (*(int *)(v1015 + 4) >= 2)
              {
                v1016 = 1;
                do
                {
                  v1017 = (uint64_t *)(*(_QWORD *)(v1015 + 16) + 8 * v1016);
                  v1019 = *v1017;
                  v1018 = (unint64_t)(v1017 + 1);
                  v1020 = quote_identifier(*(_BYTE **)(v1019 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1020);
                  v1021 = *(int *)(v1015 + 4);
                  if (v1018)
                    v1022 = v1018 >= *(_QWORD *)(v1015 + 16) + 8 * v1021;
                  else
                    v1022 = 1;
                  if (!v1022)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1021) = *(_DWORD *)(v1015 + 4);
                  }
                  ++v1016;
                }
                while ((int)v1021 > v1016);
              }
              goto LABEL_1759;
            case 0x19:
              appendStringInfoString((uint64_t)&__s1, "OPERATOR ");
              deparseOperatorWithArgtypes(&__s1, *(_QWORD *)(v18 + 16));
              break;
            case 0x1A:
              v1015 = *(_QWORD *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR FAMILY ");
              if (!v1015)
                goto LABEL_2111;
              if (*(int *)(v1015 + 4) >= 2)
              {
                v1023 = 1;
                do
                {
                  v1024 = (uint64_t *)(*(_QWORD *)(v1015 + 16) + 8 * v1023);
                  v1026 = *v1024;
                  v1025 = (unint64_t)(v1024 + 1);
                  v1027 = quote_identifier(*(_BYTE **)(v1026 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1027);
                  v1028 = *(int *)(v1015 + 4);
                  if (v1025)
                    v1029 = v1025 >= *(_QWORD *)(v1015 + 16) + 8 * v1028;
                  else
                    v1029 = 1;
                  if (!v1029)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1028) = *(_DWORD *)(v1015 + 4);
                  }
                  ++v1023;
                }
                while ((int)v1028 > v1023);
              }
LABEL_1759:
              appendStringInfoString((uint64_t)&__s1, " USING ");
              v1012 = **(_QWORD **)(v1015 + 16);
LABEL_1760:
              v1030 = quote_identifier(*(_BYTE **)(v1012 + 8));
              appendStringInfoString((uint64_t)&__s1, v1030);
              break;
            case 0x1C:
              v1014 = "PROCEDURE ";
              goto LABEL_1763;
            case 0x20:
              v1014 = "ROUTINE ";
LABEL_1763:
              appendStringInfoString((uint64_t)&__s1, v1014);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 16));
              break;
            case 0x23:
              v1013 = "SEQUENCE ";
              goto LABEL_1812;
            case 0x25:
              appendStringInfoString((uint64_t)&__s1, "STATISTICS ");
              v1031 = *(_QWORD *)(v18 + 16);
              if (v1031 && *(int *)(v1031 + 4) >= 1)
              {
                v1032 = 8;
                v1033 = 0;
                do
                {
                  v1034 = *(_QWORD *)(v1031 + 16);
                  v1035 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1034 + 8 * v1033) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1035);
                  v1036 = *(int *)(v1031 + 4);
                  if (v1034 + v1032)
                    v1037 = v1034 + v1032 >= (unint64_t)(*(_QWORD *)(v1031 + 16) + 8 * v1036);
                  else
                    v1037 = 1;
                  if (!v1037)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1036 = *(int *)(v1031 + 4);
                  }
                  ++v1033;
                  v1032 += 8;
                }
                while (v1033 < v1036);
              }
              break;
            case 0x27:
              v1013 = "TABLE ";
              goto LABEL_1812;
            case 0x2B:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH CONFIGURATION ");
              v1038 = *(_QWORD *)(v18 + 16);
              if (v1038 && *(int *)(v1038 + 4) >= 1)
              {
                v1039 = 8;
                v1040 = 0;
                do
                {
                  v1041 = *(_QWORD *)(v1038 + 16);
                  v1042 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1041 + 8 * v1040) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1042);
                  v1043 = *(int *)(v1038 + 4);
                  if (v1041 + v1039)
                    v1044 = v1041 + v1039 >= (unint64_t)(*(_QWORD *)(v1038 + 16) + 8 * v1043);
                  else
                    v1044 = 1;
                  if (!v1044)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1043 = *(int *)(v1038 + 4);
                  }
                  ++v1040;
                  v1039 += 8;
                }
                while (v1040 < v1043);
              }
              break;
            case 0x2C:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH DICTIONARY ");
              v1045 = *(_QWORD *)(v18 + 16);
              if (v1045 && *(int *)(v1045 + 4) >= 1)
              {
                v1046 = 8;
                v1047 = 0;
                do
                {
                  v1048 = *(_QWORD *)(v1045 + 16);
                  v1049 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1048 + 8 * v1047) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1049);
                  v1050 = *(int *)(v1045 + 4);
                  if (v1048 + v1046)
                    v1051 = v1048 + v1046 >= (unint64_t)(*(_QWORD *)(v1045 + 16) + 8 * v1050);
                  else
                    v1051 = 1;
                  if (!v1051)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1050 = *(int *)(v1045 + 4);
                  }
                  ++v1047;
                  v1046 += 8;
                }
                while (v1047 < v1050);
              }
              break;
            case 0x2D:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH PARSER ");
              v1052 = *(_QWORD *)(v18 + 16);
              if (v1052 && *(int *)(v1052 + 4) >= 1)
              {
                v1053 = 8;
                v1054 = 0;
                do
                {
                  v1055 = *(_QWORD *)(v1052 + 16);
                  v1056 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1055 + 8 * v1054) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1056);
                  v1057 = *(int *)(v1052 + 4);
                  if (v1055 + v1053)
                    v1058 = v1055 + v1053 >= (unint64_t)(*(_QWORD *)(v1052 + 16) + 8 * v1057);
                  else
                    v1058 = 1;
                  if (!v1058)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1057 = *(int *)(v1052 + 4);
                  }
                  ++v1054;
                  v1053 += 8;
                }
                while (v1054 < v1057);
              }
              break;
            case 0x2E:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH TEMPLATE ");
              v1059 = *(_QWORD *)(v18 + 16);
              if (v1059 && *(int *)(v1059 + 4) >= 1)
              {
                v1060 = 8;
                v1061 = 0;
                do
                {
                  v1062 = *(_QWORD *)(v1059 + 16);
                  v1063 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1062 + 8 * v1061) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1063);
                  v1064 = *(int *)(v1059 + 4);
                  if (v1062 + v1060)
                    v1065 = v1062 + v1060 >= (unint64_t)(*(_QWORD *)(v1059 + 16) + 8 * v1064);
                  else
                    v1065 = 1;
                  if (!v1065)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1064 = *(int *)(v1059 + 4);
                  }
                  ++v1061;
                  v1060 += 8;
                }
                while (v1061 < v1064);
              }
              break;
            case 0x2F:
              appendStringInfoString((uint64_t)&__s1, "TYPE ");
              v1066 = *(_QWORD *)(v18 + 16);
              if (v1066 && *(int *)(v1066 + 4) >= 1)
              {
                v1067 = 8;
                v1068 = 0;
                do
                {
                  v1069 = *(_QWORD *)(v1066 + 16);
                  v1070 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1069 + 8 * v1068) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1070);
                  v1071 = *(int *)(v1066 + 4);
                  if (v1069 + v1067)
                    v1072 = v1069 + v1067 >= (unint64_t)(*(_QWORD *)(v1066 + 16) + 8 * v1071);
                  else
                    v1072 = 1;
                  if (!v1072)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1071 = *(int *)(v1066 + 4);
                  }
                  ++v1068;
                  v1067 += 8;
                }
                while (v1068 < v1071);
              }
              break;
            case 0x31:
              v1013 = "VIEW ";
LABEL_1812:
              appendStringInfoString((uint64_t)&__s1, v1013);
              if (*(_BYTE *)(v18 + 32))
                appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 8), 0);
              break;
            default:
              break;
          }
          appendStringInfoString((uint64_t)&__s1, " SET SCHEMA ");
          v108 = *(_BYTE **)(v19 + 24);
          goto LABEL_1816;
        case 0x12E:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              appendStringInfoString((uint64_t)&__s1, "AGGREGATE ");
              deparseAggregateWithArgtypes(&__s1, *(_QWORD *)(v18 + 16));
              goto LABEL_1928;
            case 7:
              appendStringInfoString((uint64_t)&__s1, "COLLATION ");
              v1073 = *(_QWORD *)(v18 + 16);
              if (v1073 && *(int *)(v1073 + 4) >= 1)
              {
                v1074 = 8;
                v1075 = 0;
                do
                {
                  v1076 = *(_QWORD *)(v1073 + 16);
                  v1077 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1076 + 8 * v1075) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1077);
                  v1078 = *(int *)(v1073 + 4);
                  if (v1076 + v1074)
                    v1079 = v1076 + v1074 >= (unint64_t)(*(_QWORD *)(v1073 + 16) + 8 * v1078);
                  else
                    v1079 = 1;
                  if (!v1079)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1078 = *(int *)(v1073 + 4);
                  }
                  ++v1075;
                  v1074 += 8;
                }
                while (v1075 < v1078);
              }
              goto LABEL_1928;
            case 8:
              appendStringInfoString((uint64_t)&__s1, "CONVERSION ");
              v1080 = *(_QWORD *)(v18 + 16);
              if (v1080 && *(int *)(v1080 + 4) >= 1)
              {
                v1081 = 8;
                v1082 = 0;
                do
                {
                  v1083 = *(_QWORD *)(v1080 + 16);
                  v1084 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1083 + 8 * v1082) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1084);
                  v1085 = *(int *)(v1080 + 4);
                  if (v1083 + v1081)
                    v1086 = v1083 + v1081 >= (unint64_t)(*(_QWORD *)(v1080 + 16) + 8 * v1085);
                  else
                    v1086 = 1;
                  if (!v1086)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1085 = *(int *)(v1080 + 4);
                  }
                  ++v1082;
                  v1081 += 8;
                }
                while (v1082 < v1085);
              }
              goto LABEL_1928;
            case 9:
              v1087 = "DATABASE ";
              goto LABEL_1925;
            case 0xC:
              appendStringInfoString((uint64_t)&__s1, "DOMAIN ");
              v1088 = *(_QWORD *)(v18 + 16);
              if (v1088 && *(int *)(v1088 + 4) >= 1)
              {
                v1089 = 8;
                v1090 = 0;
                do
                {
                  v1091 = *(_QWORD *)(v1088 + 16);
                  v1092 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1091 + 8 * v1090) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1092);
                  v1093 = *(int *)(v1088 + 4);
                  if (v1091 + v1089)
                    v1094 = v1091 + v1089 >= (unint64_t)(*(_QWORD *)(v1088 + 16) + 8 * v1093);
                  else
                    v1094 = 1;
                  if (!v1094)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1093 = *(int *)(v1088 + 4);
                  }
                  ++v1090;
                  v1089 += 8;
                }
                while (v1090 < v1093);
              }
              goto LABEL_1928;
            case 0xE:
              v1087 = "EVENT TRIGGER ";
              goto LABEL_1925;
            case 0x10:
              v1087 = "FOREIGN DATA WRAPPER ";
              goto LABEL_1925;
            case 0x11:
              v1087 = "SERVER ";
              goto LABEL_1925;
            case 0x13:
              v1118 = "FUNCTION ";
              goto LABEL_1922;
            case 0x15:
              v1087 = "LANGUAGE ";
              goto LABEL_1925;
            case 0x16:
              appendStringInfoString((uint64_t)&__s1, "LARGE OBJECT ");
              v1101 = *(_QWORD *)(v18 + 16);
              if (*(_DWORD *)v1101 == 222)
              {
                v1147 = *(char **)(v1101 + 8);
LABEL_1927:
                appendStringInfoString((uint64_t)&__s1, v1147);
              }
              else if (*(_DWORD *)v1101 == 221)
              {
                appendStringInfo((uint64_t)&__s1, "%d", v1095, v1096, v1097, v1098, v1099, v1100, *(unsigned int *)(v1101 + 8));
              }
LABEL_1928:
              appendStringInfoString((uint64_t)&__s1, " OWNER TO ");
              v54 = *(_QWORD *)(v19 + 24);
              switch(*(_DWORD *)(v54 + 4))
              {
                case 0:
                  goto LABEL_1929;
                case 1:
                  goto LABEL_1932;
                case 2:
                  goto LABEL_1931;
                case 3:
                  goto LABEL_1933;
                default:
                  goto LABEL_2103;
              }
            case 0x18:
              v1102 = *(_QWORD *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR CLASS ");
              if (!v1102)
                goto LABEL_2111;
              if (*(int *)(v1102 + 4) >= 2)
              {
                v1103 = 1;
                do
                {
                  v1104 = (uint64_t *)(*(_QWORD *)(v1102 + 16) + 8 * v1103);
                  v1106 = *v1104;
                  v1105 = (unint64_t)(v1104 + 1);
                  v1107 = quote_identifier(*(_BYTE **)(v1106 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1107);
                  v1108 = *(int *)(v1102 + 4);
                  if (v1105)
                    v1109 = v1105 >= *(_QWORD *)(v1102 + 16) + 8 * v1108;
                  else
                    v1109 = 1;
                  if (!v1109)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1108) = *(_DWORD *)(v1102 + 4);
                  }
                  ++v1103;
                }
                while ((int)v1108 > v1103);
              }
              goto LABEL_1880;
            case 0x19:
              appendStringInfoString((uint64_t)&__s1, "OPERATOR ");
              deparseOperatorWithArgtypes(&__s1, *(_QWORD *)(v18 + 16));
              goto LABEL_1928;
            case 0x1A:
              v1102 = *(_QWORD *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR FAMILY ");
              if (!v1102)
                goto LABEL_2111;
              if (*(int *)(v1102 + 4) >= 2)
              {
                v1110 = 1;
                do
                {
                  v1111 = (uint64_t *)(*(_QWORD *)(v1102 + 16) + 8 * v1110);
                  v1113 = *v1111;
                  v1112 = (unint64_t)(v1111 + 1);
                  v1114 = quote_identifier(*(_BYTE **)(v1113 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1114);
                  v1115 = *(int *)(v1102 + 4);
                  if (v1112)
                    v1116 = v1112 >= *(_QWORD *)(v1102 + 16) + 8 * v1115;
                  else
                    v1116 = 1;
                  if (!v1116)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1115) = *(_DWORD *)(v1102 + 4);
                  }
                  ++v1110;
                }
                while ((int)v1115 > v1110);
              }
LABEL_1880:
              appendStringInfoString((uint64_t)&__s1, " USING ");
              v1117 = **(_QWORD **)(v1102 + 16);
              goto LABEL_1926;
            case 0x1C:
              v1118 = "PROCEDURE ";
              goto LABEL_1922;
            case 0x1D:
              v1087 = "PUBLICATION ";
              goto LABEL_1925;
            case 0x20:
              v1118 = "ROUTINE ";
LABEL_1922:
              appendStringInfoString((uint64_t)&__s1, v1118);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 16));
              goto LABEL_1928;
            case 0x22:
              v1087 = "SCHEMA ";
              goto LABEL_1925;
            case 0x24:
              v1087 = "SUBSCRIPTION ";
              goto LABEL_1925;
            case 0x25:
              appendStringInfoString((uint64_t)&__s1, "STATISTICS ");
              v1119 = *(_QWORD *)(v18 + 16);
              if (v1119 && *(int *)(v1119 + 4) >= 1)
              {
                v1120 = 8;
                v1121 = 0;
                do
                {
                  v1122 = *(_QWORD *)(v1119 + 16);
                  v1123 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1122 + 8 * v1121) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1123);
                  v1124 = *(int *)(v1119 + 4);
                  if (v1122 + v1120)
                    v1125 = v1122 + v1120 >= (unint64_t)(*(_QWORD *)(v1119 + 16) + 8 * v1124);
                  else
                    v1125 = 1;
                  if (!v1125)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1124 = *(int *)(v1119 + 4);
                  }
                  ++v1121;
                  v1120 += 8;
                }
                while (v1121 < v1124);
              }
              goto LABEL_1928;
            case 0x28:
              v1087 = "TABLESPACE ";
LABEL_1925:
              appendStringInfoString((uint64_t)&__s1, v1087);
              v1117 = *(_QWORD *)(v18 + 16);
LABEL_1926:
              v1147 = quote_identifier(*(_BYTE **)(v1117 + 8));
              goto LABEL_1927;
            case 0x2B:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH CONFIGURATION ");
              v1126 = *(_QWORD *)(v18 + 16);
              if (v1126 && *(int *)(v1126 + 4) >= 1)
              {
                v1127 = 8;
                v1128 = 0;
                do
                {
                  v1129 = *(_QWORD *)(v1126 + 16);
                  v1130 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1129 + 8 * v1128) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1130);
                  v1131 = *(int *)(v1126 + 4);
                  if (v1129 + v1127)
                    v1132 = v1129 + v1127 >= (unint64_t)(*(_QWORD *)(v1126 + 16) + 8 * v1131);
                  else
                    v1132 = 1;
                  if (!v1132)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1131 = *(int *)(v1126 + 4);
                  }
                  ++v1128;
                  v1127 += 8;
                }
                while (v1128 < v1131);
              }
              goto LABEL_1928;
            case 0x2C:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH DICTIONARY ");
              v1133 = *(_QWORD *)(v18 + 16);
              if (v1133 && *(int *)(v1133 + 4) >= 1)
              {
                v1134 = 8;
                v1135 = 0;
                do
                {
                  v1136 = *(_QWORD *)(v1133 + 16);
                  v1137 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1136 + 8 * v1135) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1137);
                  v1138 = *(int *)(v1133 + 4);
                  if (v1136 + v1134)
                    v1139 = v1136 + v1134 >= (unint64_t)(*(_QWORD *)(v1133 + 16) + 8 * v1138);
                  else
                    v1139 = 1;
                  if (!v1139)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1138 = *(int *)(v1133 + 4);
                  }
                  ++v1135;
                  v1134 += 8;
                }
                while (v1135 < v1138);
              }
              goto LABEL_1928;
            case 0x2F:
              appendStringInfoString((uint64_t)&__s1, "TYPE ");
              v1140 = *(_QWORD *)(v18 + 16);
              if (v1140 && *(int *)(v1140 + 4) >= 1)
              {
                v1141 = 8;
                v1142 = 0;
                do
                {
                  v1143 = *(_QWORD *)(v1140 + 16);
                  v1144 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v1143 + 8 * v1142) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1144);
                  v1145 = *(int *)(v1140 + 4);
                  if (v1143 + v1141)
                    v1146 = v1143 + v1141 >= (unint64_t)(*(_QWORD *)(v1140 + 16) + 8 * v1145);
                  else
                    v1146 = 1;
                  if (!v1146)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v1145 = *(int *)(v1140 + 4);
                  }
                  ++v1142;
                  v1141 += 8;
                }
                while (v1142 < v1145);
              }
              goto LABEL_1928;
            default:
              goto LABEL_1928;
          }
          goto LABEL_2103;
        case 0x12F:
          appendStringInfoString((uint64_t)&__s1, "ALTER OPERATOR ");
          deparseOperatorWithArgtypes(&__s1, *(_QWORD *)(v18 + 8));
          goto LABEL_626;
        case 0x130:
          appendStringInfoString((uint64_t)&__s1, "ALTER TYPE ");
          v67 = *(_QWORD *)(v18 + 8);
          if (v67 && *(int *)(v67 + 4) >= 1)
          {
            v68 = 8;
            v69 = 0;
            do
            {
              v70 = *(_QWORD *)(v67 + 16);
              v71 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v70 + 8 * v69) + 8));
              appendStringInfoString((uint64_t)&__s1, v71);
              v72 = *(int *)(v67 + 4);
              if (v70 + v68)
                v73 = v70 + v68 >= (unint64_t)(*(_QWORD *)(v67 + 16) + 8 * v72);
              else
                v73 = 1;
              if (!v73)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v72 = *(int *)(v67 + 4);
              }
              ++v69;
              v68 += 8;
            }
            while (v69 < v72);
          }
LABEL_626:
          appendStringInfoString((uint64_t)&__s1, " SET (");
          deparseOperatorDefList(&__s1, *(_QWORD *)(v19 + 16));
          appendStringInfoChar((uint64_t)&__s1, 41);
          goto LABEL_2103;
        case 0x131:
          appendStringInfoString((uint64_t)&__s1, "DROP OWNED BY ");
          deparseRoleList(&__s1, *(_QWORD *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_DWORD *)(v18 + 16) == 1)
LABEL_2027:
            appendStringInfoString((uint64_t)&__s1, "CASCADE ");
          goto LABEL_2090;
        case 0x132:
          appendStringInfoString((uint64_t)&__s1, "REASSIGN OWNED BY ");
          deparseRoleList(&__s1, *(_QWORD *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "TO ");
          v54 = *(_QWORD *)(v18 + 16);
          switch(*(_DWORD *)(v54 + 4))
          {
            case 0:
              goto LABEL_1929;
            case 1:
LABEL_1932:
              v27 = "CURRENT_USER";
              goto LABEL_2102;
            case 2:
LABEL_1931:
              v27 = "SESSION_USER";
              goto LABEL_2102;
            case 3:
LABEL_1933:
              v27 = "public";
              goto LABEL_2102;
            default:
              goto LABEL_2103;
          }
          goto LABEL_2103;
        case 0x133:
          appendStringInfoString((uint64_t)&__s1, "CREATE TYPE ");
          deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 8), 8);
          appendStringInfoString((uint64_t)&__s1, " AS (");
          v323 = *(_QWORD *)(v18 + 16);
          if (v323 && *(int *)(v323 + 4) >= 1)
          {
            v324 = 8;
            v325 = 0;
            do
            {
              v326 = *(_QWORD *)(v323 + 16);
              deparseColumnDef((uint64_t)&__s1, *(_QWORD **)(v326 + 8 * v325));
              if (v326 + v324)
                v327 = v326 + v324 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                                       + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4));
              else
                v327 = 1;
              if (!v327)
                appendStringInfoString((uint64_t)&__s1, ", ");
              ++v325;
              v324 += 8;
            }
            while (v325 < *(int *)(v323 + 4));
          }
          goto LABEL_996;
        case 0x134:
          appendStringInfoString((uint64_t)&__s1, "CREATE TYPE ");
          v371 = *(_QWORD *)(v18 + 8);
          if (v371 && *(int *)(v371 + 4) >= 1)
          {
            v372 = 8;
            v373 = 0;
            do
            {
              v374 = *(_QWORD *)(v371 + 16);
              v375 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v374 + 8 * v373) + 8));
              appendStringInfoString((uint64_t)&__s1, v375);
              v376 = *(int *)(v371 + 4);
              if (v374 + v372)
                v377 = v374 + v372 >= (unint64_t)(*(_QWORD *)(v371 + 16) + 8 * v376);
              else
                v377 = 1;
              if (!v377)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v376 = *(int *)(v371 + 4);
              }
              ++v373;
              v372 += 8;
            }
            while (v373 < v376);
          }
          appendStringInfoString((uint64_t)&__s1, " AS ENUM (");
          v378 = *(_QWORD *)(v19 + 16);
          if (v378 && *(int *)(v378 + 4) >= 1)
          {
            v379 = 8;
            v380 = 0;
            do
            {
              v381 = *(_QWORD *)(v378 + 16);
              deparseStringLiteral((uint64_t)&__s1, *(char **)(*(_QWORD *)(v381 + 8 * v380) + 8));
              if (v381 + v379)
                v382 = v381 + v379 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 16) + 16)
                                                       + 8 * *(int *)(*(_QWORD *)(v19 + 16) + 4));
              else
                v382 = 1;
              if (!v382)
                appendStringInfoString((uint64_t)&__s1, ", ");
              ++v380;
              v379 += 8;
            }
            while (v380 < *(int *)(v378 + 4));
          }
          goto LABEL_996;
        case 0x135:
          appendStringInfoString((uint64_t)&__s1, "CREATE TYPE ");
          v388 = *(_QWORD *)(v18 + 8);
          if (v388 && *(int *)(v388 + 4) >= 1)
          {
            v389 = 8;
            v390 = 0;
            do
            {
              v391 = *(_QWORD *)(v388 + 16);
              v392 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v391 + 8 * v390) + 8));
              appendStringInfoString((uint64_t)&__s1, v392);
              v393 = *(int *)(v388 + 4);
              if (v391 + v389)
                v394 = v391 + v389 >= (unint64_t)(*(_QWORD *)(v388 + 16) + 8 * v393);
              else
                v394 = 1;
              if (!v394)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v393 = *(int *)(v388 + 4);
              }
              ++v390;
              v389 += 8;
            }
            while (v390 < v393);
          }
          appendStringInfoString((uint64_t)&__s1, " AS RANGE ");
          deparseDefinition(&__s1, *(_QWORD *)(v19 + 16));
          goto LABEL_2103;
        case 0x136:
          appendStringInfoString((uint64_t)&__s1, "ALTER TYPE ");
          v55 = *(_QWORD *)(v18 + 8);
          if (v55 && *(int *)(v55 + 4) >= 1)
          {
            v56 = 8;
            v57 = 0;
            do
            {
              v58 = *(_QWORD *)(v55 + 16);
              v59 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v58 + 8 * v57) + 8));
              appendStringInfoString((uint64_t)&__s1, v59);
              v60 = *(int *)(v55 + 4);
              if (v58 + v56)
                v61 = v58 + v56 >= (unint64_t)(*(_QWORD *)(v55 + 16) + 8 * v60);
              else
                v61 = 1;
              if (!v61)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v60 = *(int *)(v55 + 4);
              }
              ++v57;
              v56 += 8;
            }
            while (v57 < v60);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_QWORD *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "RENAME VALUE ");
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 16));
            appendStringInfoString((uint64_t)&__s1, " TO ");
            v62 = (char **)(v18 + 24);
            v15 = v1226;
          }
          else
          {
            appendStringInfoString((uint64_t)&__s1, "ADD VALUE ");
            if (*(_BYTE *)(v18 + 41))
              appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
            v15 = v1226;
            if (!*(_QWORD *)(v18 + 32))
              goto LABEL_2090;
            if (*(_BYTE *)(v18 + 40))
              v558 = "AFTER ";
            else
              v558 = "BEFORE ";
            appendStringInfoString((uint64_t)&__s1, v558);
            v62 = (char **)(v18 + 32);
          }
          deparseStringLiteral((uint64_t)&__s1, *v62);
          goto LABEL_2090;
        case 0x137:
          appendStringInfoString((uint64_t)&__s1, "ALTER TEXT SEARCH DICTIONARY ");
          v110 = *(_QWORD *)(v18 + 8);
          if (v110 && *(int *)(v110 + 4) >= 1)
          {
            v111 = 8;
            v112 = 0;
            do
            {
              v113 = *(_QWORD *)(v110 + 16);
              v114 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v113 + 8 * v112) + 8));
              appendStringInfoString((uint64_t)&__s1, v114);
              v115 = *(int *)(v110 + 4);
              if (v113 + v111)
                v116 = v113 + v111 >= (unint64_t)(*(_QWORD *)(v110 + 16) + 8 * v115);
              else
                v116 = 1;
              if (!v116)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v115 = *(int *)(v110 + 4);
              }
              ++v112;
              v111 += 8;
            }
            while (v112 < v115);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          goto LABEL_168;
        case 0x138:
          appendStringInfoString((uint64_t)&__s1, "ALTER TEXT SEARCH CONFIGURATION ");
          v482 = *(_QWORD *)(v18 + 8);
          if (v482 && *(int *)(v482 + 4) >= 1)
          {
            v483 = 8;
            v484 = 0;
            do
            {
              v485 = *(_QWORD *)(v482 + 16);
              v486 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v485 + 8 * v484) + 8));
              appendStringInfoString((uint64_t)&__s1, v486);
              v487 = *(int *)(v482 + 4);
              if (v485 + v483)
                v488 = v485 + v483 >= (unint64_t)(*(_QWORD *)(v482 + 16) + 8 * v487);
              else
                v488 = 1;
              if (!v488)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v487 = *(int *)(v482 + 4);
              }
              ++v484;
              v483 += 8;
            }
            while (v484 < v487);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          switch(*(_DWORD *)(v19 + 4))
          {
            case 0:
              appendStringInfoString((uint64_t)&__s1, "ADD MAPPING FOR ");
              v489 = *(_QWORD *)(v19 + 16);
              if (v489 && *(int *)(v489 + 4) >= 1)
              {
                v490 = 8;
                v491 = 0;
                do
                {
                  v492 = *(_QWORD *)(v489 + 16);
                  v493 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v492 + 8 * v491) + 8));
                  appendStringInfoString((uint64_t)&__s1, v493);
                  v494 = *(int *)(v489 + 4);
                  if (v492 + v490)
                    v495 = v492 + v490 >= (unint64_t)(*(_QWORD *)(v489 + 16) + 8 * v494);
                  else
                    v495 = 1;
                  if (!v495)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v494 = *(int *)(v489 + 4);
                  }
                  ++v491;
                  v490 += 8;
                }
                while (v491 < v494);
              }
              goto LABEL_1126;
            case 1:
              appendStringInfoString((uint64_t)&__s1, "ALTER MAPPING FOR ");
              v681 = *(_QWORD *)(v19 + 16);
              if (v681 && *(int *)(v681 + 4) >= 1)
              {
                v682 = 8;
                v683 = 0;
                do
                {
                  v684 = *(_QWORD *)(v681 + 16);
                  v685 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v684 + 8 * v683) + 8));
                  appendStringInfoString((uint64_t)&__s1, v685);
                  v686 = *(int *)(v681 + 4);
                  if (v684 + v682)
                    v687 = v684 + v682 >= (unint64_t)(*(_QWORD *)(v681 + 16) + 8 * v686);
                  else
                    v687 = 1;
                  if (!v687)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v686 = *(int *)(v681 + 4);
                  }
                  ++v683;
                  v682 += 8;
                }
                while (v683 < v686);
              }
LABEL_1126:
              appendStringInfoString((uint64_t)&__s1, " WITH ");
              deparseAnyNameList((uint64_t)&__s1, *(_QWORD *)(v19 + 24));
              break;
            case 2:
              appendStringInfoString((uint64_t)&__s1, "ALTER MAPPING REPLACE ");
              v688 = **(_QWORD **)(*(_QWORD *)(v19 + 24) + 16);
              if (v688 && *(int *)(v688 + 4) >= 1)
              {
                v689 = 8;
                v690 = 0;
                do
                {
                  v691 = *(_QWORD *)(v688 + 16);
                  v692 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v691 + 8 * v690) + 8));
                  appendStringInfoString((uint64_t)&__s1, v692);
                  v693 = *(int *)(v688 + 4);
                  if (v691 + v689)
                    v694 = v691 + v689 >= (unint64_t)(*(_QWORD *)(v688 + 16) + 8 * v693);
                  else
                    v694 = 1;
                  if (!v694)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v693 = *(int *)(v688 + 4);
                  }
                  ++v690;
                  v689 += 8;
                }
                while (v690 < v693);
              }
              appendStringInfoString((uint64_t)&__s1, " WITH ");
              v702 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 16) + 8);
              if (v702 && *(int *)(v702 + 4) >= 1)
              {
                v703 = 8;
                v704 = 0;
                do
                {
                  v705 = *(_QWORD *)(v702 + 16);
                  v706 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v705 + 8 * v704) + 8));
                  appendStringInfoString((uint64_t)&__s1, v706);
                  v707 = *(int *)(v702 + 4);
                  if (v705 + v703)
                    v708 = v705 + v703 >= (unint64_t)(*(_QWORD *)(v702 + 16) + 8 * v707);
                  else
                    v708 = 1;
                  if (!v708)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v707 = *(int *)(v702 + 4);
                  }
                  ++v704;
                  v703 += 8;
                }
                while (v704 < v707);
              }
              break;
            case 3:
              appendStringInfoString((uint64_t)&__s1, "ALTER MAPPING FOR ");
              v695 = *(_QWORD *)(v19 + 16);
              if (v695 && *(int *)(v695 + 4) >= 1)
              {
                v696 = 8;
                v697 = 0;
                do
                {
                  v698 = *(_QWORD *)(v695 + 16);
                  v699 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v698 + 8 * v697) + 8));
                  appendStringInfoString((uint64_t)&__s1, v699);
                  v700 = *(int *)(v695 + 4);
                  if (v698 + v696)
                    v701 = v698 + v696 >= (unint64_t)(*(_QWORD *)(v695 + 16) + 8 * v700);
                  else
                    v701 = 1;
                  if (!v701)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v700 = *(int *)(v695 + 4);
                  }
                  ++v697;
                  v696 += 8;
                }
                while (v697 < v700);
              }
              appendStringInfoString((uint64_t)&__s1, " REPLACE ");
              v709 = **(_QWORD **)(*(_QWORD *)(v19 + 24) + 16);
              if (v709 && *(int *)(v709 + 4) >= 1)
              {
                v710 = 8;
                v711 = 0;
                do
                {
                  v712 = *(_QWORD *)(v709 + 16);
                  v713 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v712 + 8 * v711) + 8));
                  appendStringInfoString((uint64_t)&__s1, v713);
                  v714 = *(int *)(v709 + 4);
                  if (v712 + v710)
                    v715 = v712 + v710 >= (unint64_t)(*(_QWORD *)(v709 + 16) + 8 * v714);
                  else
                    v715 = 1;
                  if (!v715)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v714 = *(int *)(v709 + 4);
                  }
                  ++v711;
                  v710 += 8;
                }
                while (v711 < v714);
              }
              appendStringInfoString((uint64_t)&__s1, " WITH ");
              v716 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 16) + 8);
              if (v716 && *(int *)(v716 + 4) >= 1)
              {
                v717 = 8;
                v718 = 0;
                do
                {
                  v719 = *(_QWORD *)(v716 + 16);
                  v720 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v719 + 8 * v718) + 8));
                  appendStringInfoString((uint64_t)&__s1, v720);
                  v721 = *(int *)(v716 + 4);
                  if (v719 + v717)
                    v722 = v719 + v717 >= (unint64_t)(*(_QWORD *)(v716 + 16) + 8 * v721);
                  else
                    v722 = 1;
                  if (!v722)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v721 = *(int *)(v716 + 4);
                  }
                  ++v718;
                  v717 += 8;
                }
                while (v718 < v721);
              }
              break;
            case 4:
              appendStringInfoString((uint64_t)&__s1, "DROP MAPPING ");
              if (*(_BYTE *)(v19 + 34))
                appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              appendStringInfoString((uint64_t)&__s1, "FOR ");
              v674 = *(_QWORD *)(v19 + 16);
              if (v674 && *(int *)(v674 + 4) >= 1)
              {
                v675 = 8;
                v676 = 0;
                do
                {
                  v677 = *(_QWORD *)(v674 + 16);
                  v678 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v677 + 8 * v676) + 8));
                  appendStringInfoString((uint64_t)&__s1, v678);
                  v679 = *(int *)(v674 + 4);
                  if (v677 + v675)
                    v680 = v677 + v675 >= (unint64_t)(*(_QWORD *)(v674 + 16) + 8 * v679);
                  else
                    v680 = 1;
                  if (!v680)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v679 = *(int *)(v674 + 4);
                  }
                  ++v676;
                  v675 += 8;
                }
                while (v676 < v679);
              }
              break;
            default:
              goto LABEL_2103;
          }
          goto LABEL_2103;
        case 0x139:
          appendStringInfoString((uint64_t)&__s1, "CREATE FOREIGN DATA WRAPPER ");
          v397 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v397);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v398 = *(_QWORD *)(v18 + 16);
          if (v398 && *(int *)(v398 + 4) >= 1)
          {
            deparseFdwOptions((uint64_t)&__s1, v398);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          deparseCreateGenericOptions(&__s1, *(_QWORD *)(v18 + 24));
          v355 = (v1232 - 1);
          if ((int)v1232 < 1)
            goto LABEL_2103;
          goto LABEL_2091;
        case 0x13A:
          appendStringInfoString((uint64_t)&__s1, "ALTER FOREIGN DATA WRAPPER ");
          v480 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v480);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v481 = *(_QWORD *)(v18 + 16);
          if (!v481 || *(int *)(v481 + 4) < 1)
            goto LABEL_983;
          deparseFdwOptions((uint64_t)&__s1, v481);
          goto LABEL_982;
        case 0x13B:
          appendStringInfoString((uint64_t)&__s1, "CREATE SERVER ");
          if (*(_BYTE *)(v18 + 40))
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          v65 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v65);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_QWORD *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "TYPE ");
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 16));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(_QWORD *)(v18 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "VERSION ");
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "FOREIGN DATA WRAPPER ");
          v66 = quote_identifier(*(_BYTE **)(v18 + 32));
          appendStringInfoString((uint64_t)&__s1, v66);
          goto LABEL_897;
        case 0x13C:
          appendStringInfoString((uint64_t)&__s1, "ALTER SERVER ");
          v104 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v104);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(_BYTE *)(v18 + 32))
            goto LABEL_983;
          appendStringInfoString((uint64_t)&__s1, "VERSION ");
          v105 = *(char **)(v18 + 16);
          if (v105)
            deparseStringLiteral((uint64_t)&__s1, v105);
          else
            appendStringInfoString((uint64_t)&__s1, "NULL");
LABEL_982:
          appendStringInfoChar((uint64_t)&__s1, 32);
LABEL_983:
          v406 = *(_QWORD *)(v18 + 24);
          if (v406)
          {
LABEL_984:
            if (*(int *)(v406 + 4) >= 1)
              deparseAlterGenericOptions((uint64_t)&__s1, v406);
          }
          goto LABEL_2090;
        case 0x13D:
          appendStringInfoString((uint64_t)&__s1, "CREATE USER MAPPING ");
          if (*(_BYTE *)(v18 + 24))
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          appendStringInfoString((uint64_t)&__s1, "FOR ");
          v99 = *(_QWORD *)(v18 + 8);
          switch(*(_DWORD *)(v99 + 4))
          {
            case 0:
              v100 = quote_identifier(*(_BYTE **)(v99 + 8));
              goto LABEL_1003;
            case 1:
              v100 = "CURRENT_USER";
              goto LABEL_1003;
            case 2:
              v100 = "SESSION_USER";
              goto LABEL_1003;
            case 3:
              v100 = "public";
LABEL_1003:
              appendStringInfoString((uint64_t)&__s1, v100);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "SERVER ");
          v625 = quote_identifier(*(_BYTE **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v625);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreateGenericOptions(&__s1, *(_QWORD *)(v18 + 32));
          v355 = (v1232 - 1);
          if ((int)v1232 < 1)
            goto LABEL_2103;
          goto LABEL_2091;
        case 0x13E:
          appendStringInfoString((uint64_t)&__s1, "ALTER USER MAPPING FOR ");
          v464 = *(_QWORD *)(v18 + 8);
          switch(*(_DWORD *)(v464 + 4))
          {
            case 0:
              v465 = quote_identifier(*(_BYTE **)(v464 + 8));
              goto LABEL_1022;
            case 1:
              v465 = "CURRENT_USER";
              goto LABEL_1022;
            case 2:
              v465 = "SESSION_USER";
              goto LABEL_1022;
            case 3:
              v465 = "public";
LABEL_1022:
              appendStringInfoString((uint64_t)&__s1, v465);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "SERVER ");
          v628 = quote_identifier(*(_BYTE **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v628);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseAlterGenericOptions((uint64_t)&__s1, *(_QWORD *)(v18 + 24));
          goto LABEL_2090;
        case 0x13F:
          appendStringInfoString((uint64_t)&__s1, "DROP USER MAPPING ");
          if (*(_BYTE *)(v18 + 24))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          appendStringInfoString((uint64_t)&__s1, "FOR ");
          v462 = *(_QWORD *)(v18 + 8);
          switch(*(_DWORD *)(v462 + 4))
          {
            case 0:
              v463 = quote_identifier(*(_BYTE **)(v462 + 8));
              goto LABEL_1016;
            case 1:
              v463 = "CURRENT_USER";
              goto LABEL_1016;
            case 2:
              v463 = "SESSION_USER";
              goto LABEL_1016;
            case 3:
              v463 = "public";
LABEL_1016:
              appendStringInfoString((uint64_t)&__s1, v463);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          v158 = "SERVER ";
LABEL_1018:
          appendStringInfoString((uint64_t)&__s1, v158);
          v108 = *(_BYTE **)(v19 + 16);
          goto LABEL_1816;
        case 0x140:
          appendStringInfoString((uint64_t)&__s1, "ALTER TABLESPACE ");
          v186 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v186);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_BYTE *)(v18 + 24))
            v187 = "RESET ";
          else
            v187 = "SET ";
          appendStringInfoString((uint64_t)&__s1, v187);
          deparseRelOptions(&__s1, *(_QWORD *)(v18 + 16));
          goto LABEL_2103;
        case 0x142:
          appendStringInfoString((uint64_t)&__s1, "SECURITY LABEL ");
          if (*(_QWORD *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "FOR ");
            v188 = quote_identifier(*(_BYTE **)(v18 + 16));
            appendStringInfoString((uint64_t)&__s1, v188);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "ON ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              appendStringInfoString((uint64_t)&__s1, "AGGREGATE ");
              deparseAggregateWithArgtypes(&__s1, *(_QWORD *)(v18 + 8));
              break;
            case 6:
              appendStringInfoString((uint64_t)&__s1, "COLUMN ");
              v939 = *(_QWORD *)(v18 + 8);
              if (v939 && *(int *)(v939 + 4) >= 1)
              {
                v940 = 8;
                v941 = 0;
                do
                {
                  v942 = *(_QWORD *)(v939 + 16);
                  v943 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v942 + 8 * v941) + 8));
                  appendStringInfoString((uint64_t)&__s1, v943);
                  v944 = *(int *)(v939 + 4);
                  if (v942 + v940)
                    v945 = v942 + v940 >= (unint64_t)(*(_QWORD *)(v939 + 16) + 8 * v944);
                  else
                    v945 = 1;
                  if (!v945)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v944 = *(int *)(v939 + 4);
                  }
                  ++v941;
                  v940 += 8;
                }
                while (v941 < v944);
              }
              break;
            case 9:
              v946 = "DATABASE ";
              goto LABEL_1693;
            case 0xC:
              v947 = "DOMAIN ";
              goto LABEL_1695;
            case 0xE:
              v946 = "EVENT TRIGGER ";
              goto LABEL_1693;
            case 0x12:
              appendStringInfoString((uint64_t)&__s1, "FOREIGN TABLE ");
              v948 = *(_QWORD *)(v18 + 8);
              if (v948 && *(int *)(v948 + 4) >= 1)
              {
                v949 = 8;
                v950 = 0;
                do
                {
                  v951 = *(_QWORD *)(v948 + 16);
                  v952 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v951 + 8 * v950) + 8));
                  appendStringInfoString((uint64_t)&__s1, v952);
                  v953 = *(int *)(v948 + 4);
                  if (v951 + v949)
                    v954 = v951 + v949 >= (unint64_t)(*(_QWORD *)(v948 + 16) + 8 * v953);
                  else
                    v954 = 1;
                  if (!v954)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v953 = *(int *)(v948 + 4);
                  }
                  ++v950;
                  v949 += 8;
                }
                while (v950 < v953);
              }
              break;
            case 0x13:
              v955 = "FUNCTION ";
              goto LABEL_1671;
            case 0x15:
              v946 = "LANGUAGE ";
              goto LABEL_1693;
            case 0x16:
              appendStringInfoString((uint64_t)&__s1, "LARGE OBJECT ");
              deparseValue(&__s1, *(_QWORD *)(v18 + 8), 11, v956, v957, v958, v959, v960);
              break;
            case 0x17:
              appendStringInfoString((uint64_t)&__s1, "MATERIALIZED VIEW ");
              v961 = *(_QWORD *)(v18 + 8);
              if (v961 && *(int *)(v961 + 4) >= 1)
              {
                v962 = 8;
                v963 = 0;
                do
                {
                  v964 = *(_QWORD *)(v961 + 16);
                  v965 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v964 + 8 * v963) + 8));
                  appendStringInfoString((uint64_t)&__s1, v965);
                  v966 = *(int *)(v961 + 4);
                  if (v964 + v962)
                    v967 = v964 + v962 >= (unint64_t)(*(_QWORD *)(v961 + 16) + 8 * v966);
                  else
                    v967 = 1;
                  if (!v967)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v966 = *(int *)(v961 + 4);
                  }
                  ++v963;
                  v962 += 8;
                }
                while (v963 < v966);
              }
              break;
            case 0x1C:
              v955 = "PROCEDURE ";
              goto LABEL_1671;
            case 0x1D:
              v946 = "PUBLICATION ";
              goto LABEL_1693;
            case 0x1F:
              v946 = "ROLE ";
              goto LABEL_1693;
            case 0x20:
              v955 = "ROUTINE ";
LABEL_1671:
              appendStringInfoString((uint64_t)&__s1, v955);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 8));
              break;
            case 0x22:
              v946 = "SCHEMA ";
              goto LABEL_1693;
            case 0x23:
              appendStringInfoString((uint64_t)&__s1, "SEQUENCE ");
              v968 = *(_QWORD *)(v18 + 8);
              if (v968 && *(int *)(v968 + 4) >= 1)
              {
                v969 = 8;
                v970 = 0;
                do
                {
                  v971 = *(_QWORD *)(v968 + 16);
                  v972 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v971 + 8 * v970) + 8));
                  appendStringInfoString((uint64_t)&__s1, v972);
                  v973 = *(int *)(v968 + 4);
                  if (v971 + v969)
                    v974 = v971 + v969 >= (unint64_t)(*(_QWORD *)(v968 + 16) + 8 * v973);
                  else
                    v974 = 1;
                  if (!v974)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v973 = *(int *)(v968 + 4);
                  }
                  ++v970;
                  v969 += 8;
                }
                while (v970 < v973);
              }
              break;
            case 0x24:
              v946 = "SUBSCRIPTION ";
              goto LABEL_1693;
            case 0x27:
              appendStringInfoString((uint64_t)&__s1, "TABLE ");
              v975 = *(_QWORD *)(v18 + 8);
              if (v975 && *(int *)(v975 + 4) >= 1)
              {
                v976 = 8;
                v977 = 0;
                do
                {
                  v978 = *(_QWORD *)(v975 + 16);
                  v979 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v978 + 8 * v977) + 8));
                  appendStringInfoString((uint64_t)&__s1, v979);
                  v980 = *(int *)(v975 + 4);
                  if (v978 + v976)
                    v981 = v978 + v976 >= (unint64_t)(*(_QWORD *)(v975 + 16) + 8 * v980);
                  else
                    v981 = 1;
                  if (!v981)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v980 = *(int *)(v975 + 4);
                  }
                  ++v977;
                  v976 += 8;
                }
                while (v977 < v980);
              }
              break;
            case 0x28:
              v946 = "TABLESPACE ";
LABEL_1693:
              appendStringInfoString((uint64_t)&__s1, v946);
              v982 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v18 + 8) + 8));
              appendStringInfoString((uint64_t)&__s1, v982);
              break;
            case 0x2F:
              v947 = "TYPE ";
LABEL_1695:
              appendStringInfoString((uint64_t)&__s1, v947);
              deparseTypeName(&__s1, *(_QWORD *)(v18 + 8));
              break;
            case 0x31:
              appendStringInfoString((uint64_t)&__s1, "VIEW ");
              v983 = *(_QWORD *)(v18 + 8);
              if (v983 && *(int *)(v983 + 4) >= 1)
              {
                v984 = 8;
                v985 = 0;
                do
                {
                  v986 = *(_QWORD *)(v983 + 16);
                  v987 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v986 + 8 * v985) + 8));
                  appendStringInfoString((uint64_t)&__s1, v987);
                  v988 = *(int *)(v983 + 4);
                  if (v986 + v984)
                    v989 = v986 + v984 >= (unint64_t)(*(_QWORD *)(v983 + 16) + 8 * v988);
                  else
                    v989 = 1;
                  if (!v989)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v988 = *(int *)(v983 + 4);
                  }
                  ++v985;
                  v984 += 8;
                }
                while (v985 < v988);
              }
              break;
            default:
              break;
          }
          appendStringInfoString((uint64_t)&__s1, " IS ");
          v362 = *(char **)(v19 + 24);
          if (v362)
          {
LABEL_1697:
            deparseStringLiteral((uint64_t)&__s1, v362);
            goto LABEL_2103;
          }
LABEL_2101:
          v27 = "NULL";
          goto LABEL_2102;
        case 0x143:
          deparseCreateStmt(&__s1, v18, 1);
          appendStringInfoString((uint64_t)&__s1, " SERVER ");
          v405 = quote_identifier(*(_BYTE **)(v18 + 104));
          appendStringInfoString((uint64_t)&__s1, v405);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v406 = *(_QWORD *)(v18 + 112);
          if (!v406)
            goto LABEL_2090;
          goto LABEL_984;
        case 0x144:
          appendStringInfoString((uint64_t)&__s1, "IMPORT FOREIGN SCHEMA ");
          appendStringInfoString((uint64_t)&__s1, *(char **)(v18 + 16));
          appendStringInfoChar((uint64_t)&__s1, 32);
          v47 = *(_DWORD *)(v18 + 32);
          if (v47 == 2)
          {
            appendStringInfoString((uint64_t)&__s1, "EXCEPT (");
            v568 = *(_QWORD *)(v18 + 40);
            if (v568 && *(int *)(v568 + 4) >= 1)
            {
              v569 = 8;
              v570 = 0;
              do
              {
                v571 = *(_QWORD *)(v568 + 16);
                deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v571 + 8 * v570), 0);
                v572 = *(int *)(v568 + 4);
                if (v571 + v569)
                  v573 = v571 + v569 >= (unint64_t)(*(_QWORD *)(v568 + 16) + 8 * v572);
                else
                  v573 = 1;
                if (!v573)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  v572 = *(int *)(v568 + 4);
                }
                ++v570;
                v569 += 8;
              }
              while (v570 < v572);
            }
          }
          else
          {
            if (v47 != 1)
              goto LABEL_896;
            appendStringInfoString((uint64_t)&__s1, "LIMIT TO (");
            v48 = *(_QWORD *)(v18 + 40);
            if (v48 && *(int *)(v48 + 4) >= 1)
            {
              v49 = 8;
              v50 = 0;
              do
              {
                v51 = *(_QWORD *)(v48 + 16);
                deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v51 + 8 * v50), 0);
                v52 = *(int *)(v48 + 4);
                if (v51 + v49)
                  v53 = v51 + v49 >= (unint64_t)(*(_QWORD *)(v48 + 16) + 8 * v52);
                else
                  v53 = 1;
                if (!v53)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  v52 = *(int *)(v48 + 4);
                }
                ++v50;
                v49 += 8;
              }
              while (v50 < v52);
            }
          }
          appendStringInfoString((uint64_t)&__s1, ") ");
LABEL_896:
          appendStringInfoString((uint64_t)&__s1, "FROM SERVER ");
          v574 = quote_identifier(*(_BYTE **)(v19 + 8));
          appendStringInfoString((uint64_t)&__s1, v574);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "INTO ");
          v575 = quote_identifier(*(_BYTE **)(v19 + 24));
          appendStringInfoString((uint64_t)&__s1, v575);
LABEL_897:
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreateGenericOptions(&__s1, *(_QWORD *)(v19 + 48));
          v355 = (v1232 - 1);
          if ((int)v1232 < 1)
            goto LABEL_2103;
          goto LABEL_2091;
        case 0x145:
          appendStringInfoString((uint64_t)&__s1, "CREATE EXTENSION ");
          if (*(_BYTE *)(v18 + 16))
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          v454 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v454);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v455 = *(_QWORD *)(v18 + 24);
          if (!v455 || *(int *)(v455 + 4) < 1)
            goto LABEL_2090;
          v456 = 0;
          while (1)
          {
            v458 = *(_QWORD *)(*(_QWORD *)(v455 + 16) + 8 * v456);
            v459 = *(const char **)(v458 + 16);
            if (!strcmp(v459, "schema"))
            {
              appendStringInfoString((uint64_t)&__s1, "SCHEMA ");
              v457 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v458 + 24) + 8));
            }
            else if (!strcmp(v459, "new_version"))
            {
              appendStringInfoString((uint64_t)&__s1, "VERSION ");
              v460 = *(char **)(*(_QWORD *)(v458 + 24) + 8);
              v461 = strlen(v460);
              if (v461)
              {
                if (v461 >= 0x40)
                {
                  deparseStringLiteral((uint64_t)&__s1, v460);
                  goto LABEL_714;
                }
                v457 = quote_identifier(v460);
              }
              else
              {
                v457 = "''";
              }
            }
            else
            {
              if (strcmp(v459, "cascade"))
                goto LABEL_714;
              v457 = "CASCADE";
            }
            appendStringInfoString((uint64_t)&__s1, v457);
LABEL_714:
            appendStringInfoChar((uint64_t)&__s1, 32);
            if (++v456 >= *(int *)(v455 + 4))
              goto LABEL_2090;
          }
        case 0x146:
          appendStringInfoString((uint64_t)&__s1, "ALTER EXTENSION ");
          v439 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v439);
          appendStringInfoString((uint64_t)&__s1, " UPDATE ");
          v440 = *(_QWORD *)(v18 + 16);
          if (!v440 || *(int *)(v440 + 4) < 1)
            goto LABEL_2090;
          v441 = 0;
          break;
        case 0x147:
          appendStringInfoString((uint64_t)&__s1, "ALTER EXTENSION ");
          v499 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v499);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v500 = *(_DWORD *)(v18 + 16);
          if (v500 == 1)
          {
            v501 = "ADD ";
          }
          else
          {
            if (v500 != -1)
              goto LABEL_912;
            v501 = "DROP ";
          }
          appendStringInfoString((uint64_t)&__s1, v501);
LABEL_912:
          v583 = *(_DWORD *)(v18 + 20);
          v584 = v583;
          if (v583 <= 0x31 && ((0x2FA8D17AF51A3uLL >> v583) & 1) != 0)
          {
            appendStringInfoString((uint64_t)&__s1, (&off_1E264A5A8)[v583]);
            v584 = *(_DWORD *)(v18 + 20);
          }
          switch(v584)
          {
            case 0u:
            case 0xEu:
            case 0x10u:
            case 0x11u:
            case 0x15u:
            case 0x22u:
              v54 = *(_QWORD *)(v18 + 24);
LABEL_1929:
              v108 = *(_BYTE **)(v54 + 8);
              goto LABEL_1816;
            case 1u:
              deparseAggregateWithArgtypes(&__s1, *(_QWORD *)(v18 + 24));
              goto LABEL_2103;
            case 5u:
              v1148 = *(_QWORD *)(v18 + 24);
              appendStringInfoChar((uint64_t)&__s1, 40);
              deparseTypeName(&__s1, **(_QWORD **)(v1148 + 16));
              appendStringInfoString((uint64_t)&__s1, " AS ");
              deparseTypeName(&__s1, *(_QWORD *)(*(_QWORD *)(v1148 + 16) + 8));
              appendStringInfoChar((uint64_t)&__s1, 41);
              goto LABEL_2103;
            case 7u:
            case 8u:
            case 0x12u:
            case 0x17u:
            case 0x23u:
            case 0x27u:
            case 0x2Bu:
            case 0x2Cu:
            case 0x2Du:
            case 0x2Eu:
            case 0x31u:
              v585 = *(_QWORD *)(v18 + 24);
              if (v585 && *(int *)(v585 + 4) >= 1)
              {
                v586 = 8;
                v587 = 0;
                do
                {
                  v588 = *(_QWORD *)(v585 + 16);
                  v589 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v588 + 8 * v587) + 8));
                  appendStringInfoString((uint64_t)&__s1, v589);
                  v590 = *(int *)(v585 + 4);
                  if (v588 + v586)
                    v591 = v588 + v586 >= (unint64_t)(*(_QWORD *)(v585 + 16) + 8 * v590);
                  else
                    v591 = 1;
                  if (!v591)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v590 = *(int *)(v585 + 4);
                  }
                  ++v587;
                  v586 += 8;
                }
                while (v587 < v590);
              }
              goto LABEL_2103;
            case 0xCu:
            case 0x2Fu:
              deparseTypeName(&__s1, *(_QWORD *)(v18 + 24));
              goto LABEL_2103;
            case 0x13u:
            case 0x1Cu:
            case 0x20u:
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 24));
              goto LABEL_2103;
            case 0x18u:
            case 0x1Au:
              v908 = *(_QWORD *)(v18 + 24);
              if (v908)
              {
                if (*(int *)(v908 + 4) >= 2)
                {
                  v909 = 1;
                  do
                  {
                    v910 = (uint64_t *)(*(_QWORD *)(v908 + 16) + 8 * v909);
                    v912 = *v910;
                    v911 = (unint64_t)(v910 + 1);
                    v913 = quote_identifier(*(_BYTE **)(v912 + 8));
                    appendStringInfoString((uint64_t)&__s1, v913);
                    v914 = *(int *)(v908 + 4);
                    if (v911)
                      v915 = v911 >= *(_QWORD *)(v908 + 16) + 8 * v914;
                    else
                      v915 = 1;
                    if (!v915)
                    {
                      appendStringInfoChar((uint64_t)&__s1, 46);
                      LODWORD(v914) = *(_DWORD *)(v908 + 4);
                    }
                    ++v909;
                  }
                  while ((int)v914 > v909);
                }
                appendStringInfoString((uint64_t)&__s1, " USING ");
                v916 = **(_QWORD **)(v908 + 16);
LABEL_1938:
                v27 = quote_identifier(*(_BYTE **)(v916 + 8));
                goto LABEL_2102;
              }
LABEL_2111:
              result = (char *)appendStringInfoString((uint64_t)&__s1, " USING ");
              __break(1u);
              break;
            case 0x19u:
              deparseOperatorWithArgtypes(&__s1, *(_QWORD *)(v18 + 24));
              goto LABEL_2103;
            case 0x29u:
              v1149 = *(_QWORD *)(v18 + 24);
              appendStringInfoString((uint64_t)&__s1, "FOR ");
              deparseTypeName(&__s1, **(_QWORD **)(v1149 + 16));
              appendStringInfoString((uint64_t)&__s1, " LANGUAGE ");
              v916 = *(_QWORD *)(*(_QWORD *)(v1149 + 16) + 8);
              goto LABEL_1938;
            default:
              goto LABEL_2103;
          }
          return result;
        case 0x148:
          appendStringInfoString((uint64_t)&__s1, "CREATE EVENT TRIGGER ");
          v128 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v128);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "ON ");
          v129 = quote_identifier(*(_BYTE **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v129);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(_QWORD *)(v18 + 24))
            goto LABEL_766;
          v1225 = v16;
          v16 = v17;
          appendStringInfoString((uint64_t)&__s1, "WHEN ");
          v130 = *(_QWORD *)(v18 + 24);
          if (!v130 || *(int *)(v130 + 4) < 1)
            goto LABEL_765;
          v131 = 0;
          while (1)
          {
            v132 = *(_QWORD *)(v130 + 16) + 8 * v131;
            v133 = *(_QWORD *)(*(_QWORD *)v132 + 24);
            v134 = quote_identifier(*(_BYTE **)(*(_QWORD *)v132 + 16));
            appendStringInfoString((uint64_t)&__s1, v134);
            appendStringInfoString((uint64_t)&__s1, " IN (");
            if (v133)
            {
              if (*(int *)(v133 + 4) >= 1)
                break;
            }
LABEL_201:
            appendStringInfoChar((uint64_t)&__s1, 41);
            if (v132 != -8
              && v132 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 16)
                                             + 8 * *(int *)(*(_QWORD *)(v19 + 24) + 4)))
            {
              appendStringInfoString((uint64_t)&__s1, " AND ");
            }
            if (++v131 >= *(int *)(v130 + 4))
            {
LABEL_765:
              appendStringInfoChar((uint64_t)&__s1, 32);
              v15 = v1226;
              v17 = v16;
              LODWORD(v16) = v1225;
LABEL_766:
              appendStringInfoString((uint64_t)&__s1, "EXECUTE FUNCTION ");
              v502 = *(_QWORD *)(v19 + 32);
              if (v502 && *(int *)(v502 + 4) >= 1)
              {
                v503 = 8;
                v504 = 0;
                do
                {
                  v505 = *(_QWORD *)(v502 + 16);
                  v506 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v505 + 8 * v504) + 8));
                  appendStringInfoString((uint64_t)&__s1, v506);
                  v507 = *(int *)(v502 + 4);
                  if (v505 + v503)
                    v508 = v505 + v503 >= (unint64_t)(*(_QWORD *)(v502 + 16) + 8 * v507);
                  else
                    v508 = 1;
                  if (!v508)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    v507 = *(int *)(v502 + 4);
                  }
                  ++v504;
                  v503 += 8;
                }
                while (v504 < v507);
              }
              v27 = "()";
              goto LABEL_2102;
            }
          }
          v135 = 0;
LABEL_190:
          v136 = *(_QWORD *)(v133 + 16) + 8 * v135;
          v137 = *(char **)(*(_QWORD *)v136 + 8);
          if (strchr(v137, 92))
            appendStringInfoChar((uint64_t)&__s1, 69);
          appendStringInfoChar((uint64_t)&__s1, 39);
          while (1)
          {
            v138 = *v137;
            v139 = *v137;
            if (v138 == 39 || v138 == 92)
            {
              appendStringInfoChar((uint64_t)&__s1, v138);
            }
            else if (!*v137)
            {
              appendStringInfoChar((uint64_t)&__s1, 39);
              v140 = *(int *)(v133 + 4);
              if (v136 != -8 && v136 + 8 < (unint64_t)(*(_QWORD *)(v133 + 16) + 8 * *(int *)(v133 + 4)))
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                v140 = *(int *)(v133 + 4);
              }
              if (++v135 >= v140)
                goto LABEL_201;
              goto LABEL_190;
            }
            appendStringInfoChar((uint64_t)&__s1, v139);
            ++v137;
          }
        case 0x149:
          appendStringInfoString((uint64_t)&__s1, "ALTER EVENT TRIGGER ");
          v46 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v46);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v27 = "ENABLE";
          switch(*(_BYTE *)(v18 + 16))
          {
            case 'A':
              v27 = "ENABLE ALWAYS";
              goto LABEL_2102;
            case 'D':
              v27 = "DISABLE";
              goto LABEL_2102;
            case 'O':
              goto LABEL_2102;
            case 'R':
              v27 = "ENABLE REPLICA";
              goto LABEL_2102;
            default:
              goto LABEL_2103;
          }
          goto LABEL_2103;
        case 0x14A:
          deparseRefreshMatViewStmt((uint64_t)&__s1, *(_QWORD *)(*(_QWORD *)v17 + 8));
          goto LABEL_2103;
        case 0x14C:
          appendStringInfoString((uint64_t)&__s1, "ALTER SYSTEM ");
          v361 = *(_QWORD *)(v18 + 8);
LABEL_1490:
          deparseVariableSetStmt((uint64_t)&__s1, v361);
          goto LABEL_2103;
        case 0x14D:
          appendStringInfoString((uint64_t)&__s1, "CREATE POLICY ");
          v28 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v28);
          appendStringInfoString((uint64_t)&__s1, " ON ");
          deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 16), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(_BYTE *)(v18 + 32))
            appendStringInfoString((uint64_t)&__s1, "AS RESTRICTIVE ");
          v29 = *(const char **)(v18 + 24);
          if (!strcmp(v29, "all"))
            goto LABEL_1531;
          if (!strcmp(v29, "select"))
          {
            v30 = "FOR SELECT ";
          }
          else if (!strcmp(v29, "insert"))
          {
            v30 = "FOR INSERT ";
          }
          else if (!strcmp(v29, "update"))
          {
            v30 = "FOR UPDATE ";
          }
          else
          {
            if (strcmp(v29, "delete"))
              goto LABEL_1531;
            v30 = "FOR DELETE ";
          }
          appendStringInfoString((uint64_t)&__s1, v30);
LABEL_1531:
          appendStringInfoString((uint64_t)&__s1, "TO ");
          deparseRoleList(&__s1, *(_QWORD *)(v18 + 40));
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_QWORD *)(v18 + 48))
          {
            appendStringInfoString((uint64_t)&__s1, "USING (");
            deparseExpr(&__s1, *(int **)(v18 + 48), v868, v869, v870, v871, v872, v873);
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (!*(_QWORD *)(v18 + 56))
            goto LABEL_2103;
          appendStringInfoString((uint64_t)&__s1, "WITH CHECK (");
          deparseExpr(&__s1, *(int **)(v18 + 56), v874, v875, v876, v877, v878, v879);
          v27 = ") ";
          goto LABEL_2102;
        case 0x14E:
          appendStringInfoString((uint64_t)&__s1, "ALTER POLICY ");
          v466 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v466);
          appendStringInfoString((uint64_t)&__s1, " ON ");
          deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v18 + 16), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v467 = *(_QWORD *)(v18 + 24);
          if (v467 && *(int *)(v467 + 4) >= 1)
          {
            appendStringInfoString((uint64_t)&__s1, "TO ");
            deparseRoleList(&__s1, *(_QWORD *)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(_QWORD *)(v18 + 32))
          {
            appendStringInfoString((uint64_t)&__s1, "USING (");
            deparseExpr(&__s1, *(int **)(v18 + 32), v468, v469, v470, v471, v472, v473);
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (!*(_QWORD *)(v18 + 40))
            goto LABEL_2103;
          appendStringInfoString((uint64_t)&__s1, "WITH CHECK (");
          deparseExpr(&__s1, *(int **)(v18 + 40), v474, v475, v476, v477, v478, v479);
          v27 = ") ";
          goto LABEL_2102;
        case 0x14F:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(_BYTE *)(v18 + 4))
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          appendStringInfoString((uint64_t)&__s1, "TRANSFORM FOR ");
          deparseTypeName(&__s1, *(_QWORD *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
          v142 = quote_identifier(*(_BYTE **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v142);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoChar((uint64_t)&__s1, 40);
          if (*(_QWORD *)(v18 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "FROM SQL WITH FUNCTION ");
            deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 24));
            if (*(_QWORD *)(v18 + 24))
            {
              if (*(_QWORD *)(v18 + 32))
                appendStringInfoString((uint64_t)&__s1, ", ");
            }
          }
          if (*(_QWORD *)(v18 + 32))
          {
            appendStringInfoString((uint64_t)&__s1, "TO SQL WITH FUNCTION ");
            deparseFunctionWithArgtypes((uint64_t)&__s1, *(_QWORD *)(v18 + 32));
          }
          goto LABEL_996;
        case 0x150:
          appendStringInfoString((uint64_t)&__s1, "CREATE ACCESS METHOD ");
          v496 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v496);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "TYPE ");
          v497 = *(char *)(v18 + 24);
          if (v497 == 105)
          {
            v498 = "INDEX ";
          }
          else
          {
            if (v497 != 116)
              goto LABEL_901;
            v498 = "TABLE ";
          }
          appendStringInfoString((uint64_t)&__s1, v498);
LABEL_901:
          appendStringInfoString((uint64_t)&__s1, "HANDLER ");
          v576 = *(_QWORD *)(v18 + 16);
          if (v576 && *(int *)(v576 + 4) >= 1)
          {
            v577 = 8;
            v578 = 0;
            do
            {
              v579 = *(_QWORD *)(v576 + 16);
              v580 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v579 + 8 * v578) + 8));
              appendStringInfoString((uint64_t)&__s1, v580);
              v581 = *(int *)(v576 + 4);
              if (v579 + v577)
                v582 = v579 + v577 >= (unint64_t)(*(_QWORD *)(v576 + 16) + 8 * v581);
              else
                v582 = 1;
              if (!v582)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v581 = *(int *)(v576 + 4);
              }
              ++v578;
              v577 += 8;
            }
            while (v578 < v581);
          }
          goto LABEL_2103;
        case 0x151:
          appendStringInfoString((uint64_t)&__s1, "CREATE PUBLICATION ");
          v424 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v424);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v425 = *(_QWORD *)(v18 + 24);
          if (v425 && *(int *)(v425 + 4) >= 1)
          {
            appendStringInfoString((uint64_t)&__s1, "FOR TABLE ");
            v426 = *(_QWORD *)(v18 + 24);
            if (v426 && *(int *)(v426 + 4) >= 1)
            {
              v427 = 8;
              v428 = 0;
              do
              {
                v429 = *(_QWORD *)(v426 + 16);
                deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v429 + 8 * v428), 0);
                v430 = *(int *)(v426 + 4);
                if (v429 + v427)
                  v431 = v429 + v427 >= (unint64_t)(*(_QWORD *)(v426 + 16) + 8 * v430);
                else
                  v431 = 1;
                if (!v431)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  v430 = *(int *)(v426 + 4);
                }
                ++v428;
                v427 += 8;
              }
              while (v428 < v430);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          else if (*(_BYTE *)(v18 + 32))
          {
            appendStringInfoString((uint64_t)&__s1, "FOR ALL TABLES ");
          }
          v557 = *(_QWORD *)(v19 + 16);
          if (!v557)
            goto LABEL_2090;
          goto LABEL_877;
        case 0x152:
          appendStringInfoString((uint64_t)&__s1, "ALTER PUBLICATION ");
          v412 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v412);
          appendStringInfoChar((uint64_t)&__s1, 32);
          v413 = *(_QWORD *)(v18 + 24);
          if (v413 && *(int *)(v413 + 4) >= 1)
          {
            v414 = *(_DWORD *)(v18 + 36) - 1;
            if (v414 > 2
              || (appendStringInfoString((uint64_t)&__s1, (&off_1E264A738)[v414]), (v413 = *(_QWORD *)(v18 + 24)) != 0))
            {
              v415 = v413;
              if (*(int *)(v413 + 4) >= 1)
              {
                v416 = 8;
                v417 = 0;
                do
                {
                  v418 = *(_QWORD *)(v415 + 16);
                  deparseRangeVar((uint64_t)&__s1, *(_QWORD *)(v418 + 8 * v417), 0);
                  v419 = *(int *)(v415 + 4);
                  if (v418 + v416)
                    v420 = v418 + v416 >= (unint64_t)(*(_QWORD *)(v415 + 16) + 8 * v419);
                  else
                    v420 = 1;
                  if (!v420)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    v419 = *(int *)(v415 + 4);
                  }
                  ++v417;
                  v416 += 8;
                }
                while (v417 < v419);
              }
            }
          }
          else
          {
            v509 = *(_QWORD *)(v18 + 16);
            if (v509 && *(int *)(v509 + 4) >= 1)
            {
              appendStringInfoString((uint64_t)&__s1, "SET ");
LABEL_168:
              deparseDefinition(&__s1, *(_QWORD *)(v19 + 16));
            }
          }
          goto LABEL_2103;
        case 0x153:
          appendStringInfoString((uint64_t)&__s1, "CREATE SUBSCRIPTION ");
          v63 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v63);
          appendStringInfoString((uint64_t)&__s1, " CONNECTION ");
          v64 = *(char **)(v18 + 16);
          if (v64)
            deparseStringLiteral((uint64_t)&__s1, v64);
          else
            appendStringInfoString((uint64_t)&__s1, "''");
          appendStringInfoString((uint64_t)&__s1, " PUBLICATION ");
          v559 = *(_QWORD *)(v18 + 24);
          if (v559 && *(int *)(v559 + 4) >= 1)
          {
            v560 = 8;
            v561 = 0;
            do
            {
              v562 = *(_QWORD *)(v559 + 16);
              v563 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v562 + 8 * v561) + 8));
              appendStringInfoString((uint64_t)&__s1, v563);
              if (v562 + v560)
                v564 = v562 + v560 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 16)
                                                       + 8 * *(int *)(*(_QWORD *)(v19 + 24) + 4));
              else
                v564 = 1;
              if (!v564)
                appendStringInfoString((uint64_t)&__s1, ", ");
              ++v561;
              v560 += 8;
            }
            while (v561 < *(int *)(v559 + 4));
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          v557 = *(_QWORD *)(v19 + 32);
          if (!v557)
            goto LABEL_2090;
LABEL_877:
          if (*(int *)(v557 + 4) < 1)
            goto LABEL_2090;
          appendStringInfoString((uint64_t)&__s1, "WITH ");
          v565 = v557;
          goto LABEL_2089;
        case 0x154:
          appendStringInfoString((uint64_t)&__s1, "ALTER SUBSCRIPTION ");
          v407 = quote_identifier(*(_BYTE **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v407);
          appendStringInfoChar((uint64_t)&__s1, 32);
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0:
              appendStringInfoString((uint64_t)&__s1, "SET ");
              deparseDefinition(&__s1, *(_QWORD *)(v18 + 32));
              goto LABEL_2090;
            case 1:
              appendStringInfoString((uint64_t)&__s1, "CONNECTION ");
              deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 16));
              goto LABEL_1308;
            case 2:
              appendStringInfoString((uint64_t)&__s1, "SET PUBLICATION ");
              v665 = *(_QWORD *)(v18 + 24);
              if (v665 && *(int *)(v665 + 4) >= 1)
              {
                v666 = 8;
                v667 = 0;
                do
                {
                  v668 = *(_QWORD *)(v665 + 16);
                  v669 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v668 + 8 * v667) + 8));
                  appendStringInfoString((uint64_t)&__s1, v669);
                  if (v668 + v666)
                    v670 = v668 + v666 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 16)
                                                           + 8 * *(int *)(*(_QWORD *)(v19 + 24) + 4));
                  else
                    v670 = 1;
                  if (!v670)
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  ++v667;
                  v666 += 8;
                }
                while (v667 < *(int *)(v665 + 4));
              }
              appendStringInfoChar((uint64_t)&__s1, 32);
              goto LABEL_1103;
            case 3:
              appendStringInfoString((uint64_t)&__s1, "REFRESH PUBLICATION ");
LABEL_1103:
              v673 = *(_QWORD *)(v19 + 32);
              if (v673 && *(int *)(v673 + 4) >= 1)
              {
                appendStringInfoString((uint64_t)&__s1, "WITH ");
                deparseDefinition(&__s1, v673);
              }
              goto LABEL_2090;
            case 4:
              v671 = *(_DWORD *)(*(_QWORD *)(**(_QWORD **)(*(_QWORD *)(v18 + 32) + 16) + 24) + 8);
              if (v671)
              {
                if (v671 != 1)
                  goto LABEL_2090;
                v672 = " ENABLE ";
              }
              else
              {
                v672 = " DISABLE ";
              }
              appendStringInfoString((uint64_t)&__s1, v672);
              break;
            default:
              goto LABEL_2090;
          }
          goto LABEL_2090;
        case 0x155:
          v97 = "DROP SUBSCRIPTION ";
LABEL_628:
          appendStringInfoString((uint64_t)&__s1, v97);
          if (*(_BYTE *)(v18 + 16))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          v27 = *(char **)(v18 + 8);
          goto LABEL_2102;
        case 0x156:
          appendStringInfoString((uint64_t)&__s1, "CREATE STATISTICS ");
          if (*(_BYTE *)(v18 + 48))
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          v31 = *(_QWORD *)(v18 + 8);
          if (v31 && *(int *)(v31 + 4) >= 1)
          {
            v32 = 8;
            v33 = 0;
            do
            {
              v34 = *(_QWORD *)(v31 + 16);
              v35 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v34 + 8 * v33) + 8));
              appendStringInfoString((uint64_t)&__s1, v35);
              v36 = *(int *)(v31 + 4);
              if (v34 + v32)
                v37 = v34 + v32 >= (unint64_t)(*(_QWORD *)(v31 + 16) + 8 * v36);
              else
                v37 = 1;
              if (!v37)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v36 = *(int *)(v31 + 4);
              }
              ++v33;
              v32 += 8;
            }
            while (v33 < v36);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          v38 = *(_QWORD *)(v19 + 16);
          if (v38 && *(int *)(v38 + 4) >= 1)
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            v39 = *(_QWORD *)(v19 + 16);
            if (v39 && *(int *)(v39 + 4) >= 1)
            {
              v40 = 8;
              v41 = 0;
              do
              {
                v42 = *(_QWORD *)(v39 + 16);
                v43 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v42 + 8 * v41) + 8));
                appendStringInfoString((uint64_t)&__s1, v43);
                v44 = *(int *)(v39 + 4);
                if (v42 + v40)
                  v45 = v42 + v40 >= (unint64_t)(*(_QWORD *)(v39 + 16) + 8 * v44);
                else
                  v45 = 1;
                if (!v45)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  v44 = *(int *)(v39 + 4);
                }
                ++v41;
                v40 += 8;
              }
              while (v41 < v44);
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          appendStringInfoString((uint64_t)&__s1, "ON ");
          v517 = *(_QWORD *)(v19 + 24);
          if (v517 && *(int *)(v517 + 4) >= 1)
          {
            v518 = 8;
            v519 = 0;
            do
            {
              v520 = *(_QWORD *)(v517 + 16);
              deparseExpr(&__s1, *(int **)(v520 + 8 * v519), v511, v512, v513, v514, v515, v516);
              v521 = *(int *)(v517 + 4);
              if (v520 + v518)
                v522 = v520 + v518 >= (unint64_t)(*(_QWORD *)(v517 + 16) + 8 * v521);
              else
                v522 = 1;
              if (!v522)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                v521 = *(int *)(v517 + 4);
              }
              ++v519;
              v518 += 8;
            }
            while (v519 < v521);
          }
          appendStringInfoString((uint64_t)&__s1, " FROM ");
          v529 = *(_QWORD *)(v19 + 32);
          if (v529 && *(int *)(v529 + 4) >= 1)
          {
            v530 = 8;
            v531 = 0;
            do
            {
              v532 = *(_QWORD *)(v529 + 16);
              deparseTableRef(&__s1, *(_QWORD *)(v532 + 8 * v531), v523, v524, v525, v526, v527, v528);
              v533 = *(int *)(v529 + 4);
              if (v532 + v530)
                v534 = v532 + v530 >= (unint64_t)(*(_QWORD *)(v529 + 16) + 8 * v533);
              else
                v534 = 1;
              if (!v534)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                v533 = *(int *)(v529 + 4);
              }
              ++v531;
              v530 += 8;
            }
            while (v531 < v533);
          }
          goto LABEL_2103;
        case 0x157:
          appendStringInfoString((uint64_t)&__s1, "ALTER COLLATION ");
          v20 = *(_QWORD *)(v18 + 8);
          if (v20 && *(int *)(v20 + 4) >= 1)
          {
            v21 = 8;
            v22 = 0;
            do
            {
              v23 = *(_QWORD *)(v20 + 16);
              v24 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v23 + 8 * v22) + 8));
              appendStringInfoString((uint64_t)&__s1, v24);
              v25 = *(int *)(v20 + 4);
              if (v23 + v21)
                v26 = v23 + v21 >= (unint64_t)(*(_QWORD *)(v20 + 16) + 8 * v25);
              else
                v26 = 1;
              if (!v26)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v25 = *(int *)(v20 + 4);
              }
              ++v22;
              v21 += 8;
            }
            while (v22 < v25);
          }
          v27 = " REFRESH VERSION";
          goto LABEL_2102;
        case 0x158:
          appendStringInfoString((uint64_t)&__s1, "CALL ");
          deparseFuncCall((uint64_t)&__s1, *(_QWORD *)(v18 + 8));
          goto LABEL_2103;
        case 0x159:
          appendStringInfoString((uint64_t)&__s1, "ALTER STATISTICS ");
          if (*(_BYTE *)(v18 + 20))
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          v74 = *(_QWORD *)(v18 + 8);
          if (v74 && *(int *)(v74 + 4) >= 1)
          {
            v75 = 8;
            v76 = 0;
            do
            {
              v77 = *(_QWORD *)(v74 + 16);
              v78 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v77 + 8 * v76) + 8));
              appendStringInfoString((uint64_t)&__s1, v78);
              v79 = *(int *)(v74 + 4);
              if (v77 + v75)
                v80 = v77 + v75 >= (unint64_t)(*(_QWORD *)(v74 + 16) + 8 * v79);
              else
                v80 = 1;
              if (!v80)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                v79 = *(int *)(v74 + 4);
              }
              ++v76;
              v75 += 8;
            }
            while (v76 < v79);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfo((uint64_t)&__s1, "SET STATISTICS %d", v81, v82, v83, v84, v85, v86, *(unsigned int *)(v19 + 16));
          goto LABEL_2103;
        default:
          pg_query_deparse_protobuf_cold_2((_DWORD *)v18);
      }
      break;
    }
    while (1)
    {
      v443 = *(_QWORD *)(*(_QWORD *)(v440 + 16) + 8 * v441);
      if (!strcmp(*(const char **)(v443 + 16), "new_version"))
      {
        appendStringInfoString((uint64_t)&__s1, "TO ");
        v444 = *(char **)(*(_QWORD *)(v443 + 24) + 8);
        v445 = strlen(v444);
        if (v445)
        {
          if (v445 >= 0x40)
          {
            deparseStringLiteral((uint64_t)&__s1, v444);
            goto LABEL_689;
          }
          v442 = quote_identifier(v444);
        }
        else
        {
          v442 = "''";
        }
        appendStringInfoString((uint64_t)&__s1, v442);
      }
LABEL_689:
      appendStringInfoChar((uint64_t)&__s1, 32);
      if (++v441 >= *(int *)(v440 + 4))
        goto LABEL_2090;
    }
  }
  *v7 = v6;
  *v10 = v9;
  *(_QWORD *)CurrentMemoryContext() = enter_memory_context;
  v11 = CopyErrorData();
  v12 = malloc_type_malloc(0x28uLL, 0x1010040E871EB1AuLL);
  *v12 = strdup(*(const char **)(v11 + 64));
  v12[2] = strdup(*(const char **)(v11 + 16));
  v12[1] = strdup(*(const char **)(v11 + 32));
  v12[4] = 0;
  *((_DWORD *)v12 + 6) = *(_DWORD *)(v11 + 24);
  *((_DWORD *)v12 + 7) = *(_DWORD *)(v11 + 160);
  FlushErrorState();
  v13 = 0;
LABEL_2108:
  *v7 = v6;
  *v10 = v9;
  pg_query_exit_memory_context();
  return v13;
}

void pg_query_free_deparse_result(void *a1, uint64_t a2)
{
  if (a2)
    pg_query_free_error(a2);
  free(a1);
}

uint64_t deparseCreateTableAsStmt(_DWORD *a1, uint64_t a2)
{
  int v4;
  char *v5;
  int v6;
  char *v7;
  _DWORD *v8;
  uint64_t result;
  int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;

  appendStringInfoString((uint64_t)a1, "CREATE ");
  v4 = *(char *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8) + 33);
  if (v4 == 117)
  {
    v5 = "UNLOGGED ";
  }
  else
  {
    if (v4 != 116)
      goto LABEL_6;
    v5 = "TEMPORARY ";
  }
  appendStringInfoString((uint64_t)a1, v5);
LABEL_6:
  v6 = *(_DWORD *)(a2 + 24);
  if (v6 == 39)
  {
    v7 = "TABLE ";
  }
  else
  {
    if (v6 != 23)
      goto LABEL_11;
    v7 = "MATERIALIZED VIEW ";
  }
  appendStringInfoString((uint64_t)a1, v7);
LABEL_11:
  if (*(_BYTE *)(a2 + 29))
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  deparseIntoClause(a1, *(_QWORD *)(a2 + 16));
  appendStringInfoChar((uint64_t)a1, 32);
  appendStringInfoString((uint64_t)a1, "AS ");
  v8 = *(_DWORD **)(a2 + 8);
  if (*v8 != 295)
  {
    deparseSelectStmt(a1, (uint64_t)v8);
    result = appendStringInfoChar((uint64_t)a1, 32);
    if (!*(_BYTE *)(*(_QWORD *)(a2 + 16) + 64))
      goto LABEL_18;
    goto LABEL_17;
  }
  deparseExecuteStmt(a1, (uint64_t)v8);
  result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(_BYTE *)(*(_QWORD *)(a2 + 16) + 64))
LABEL_17:
    result = (uint64_t)appendStringInfoString((uint64_t)a1, "WITH NO DATA ");
LABEL_18:
  v10 = a1[2];
  v11 = __OFSUB__(v10, 1);
  v12 = (v10 - 1);
  if ((int)v12 < 0 == v11)
  {
    v13 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v12) == 32)
    {
      a1[2] = v12;
      *(_BYTE *)(v13 + v12) = 0;
    }
  }
  return result;
}

uint64_t deparseCreateSeqStmt(_DWORD *a1, uint64_t a2)
{
  int v4;
  char *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;

  appendStringInfoString((uint64_t)a1, "CREATE ");
  v4 = *(char *)(*(_QWORD *)(a2 + 8) + 33);
  if (v4 == 117)
  {
    v5 = "UNLOGGED ";
  }
  else
  {
    if (v4 != 116)
      goto LABEL_6;
    v5 = "TEMPORARY ";
  }
  appendStringInfoString((uint64_t)a1, v5);
LABEL_6:
  appendStringInfoString((uint64_t)a1, "SEQUENCE ");
  if (*(_BYTE *)(a2 + 29))
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), 0);
  result = appendStringInfoChar((uint64_t)a1, 32);
  v7 = *(_QWORD *)(a2 + 16);
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    v8 = 0;
    do
    {
      deparseSeqOptElem(a1, *(_QWORD *)(*(_QWORD *)(v7 + 16) + 8 * v8));
      result = appendStringInfoChar((uint64_t)a1, 32);
      ++v8;
    }
    while (v8 < *(int *)(v7 + 4));
  }
  v9 = a1[2];
  v10 = __OFSUB__(v9, 1);
  v11 = (v9 - 1);
  if ((int)v11 < 0 == v10)
  {
    v12 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v11) == 32)
    {
      a1[2] = v11;
      *(_BYTE *)(v12 + v11) = 0;
    }
  }
  return result;
}

uint64_t deparseCreateStmt(_DWORD *a1, uint64_t a2, int a3)
{
  int v6;
  char *v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  int v16;
  char *v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  BOOL v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  unsigned int v50;
  char *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  BOOL v60;

  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (a3)
    appendStringInfoString((uint64_t)a1, "FOREIGN ");
  v6 = *(char *)(*(_QWORD *)(a2 + 8) + 33);
  if (v6 == 117)
  {
    v7 = "UNLOGGED ";
  }
  else
  {
    if (v6 != 116)
      goto LABEL_8;
    v7 = "TEMPORARY ";
  }
  appendStringInfoString((uint64_t)a1, v7);
LABEL_8:
  appendStringInfoString((uint64_t)a1, "TABLE ");
  if (*(_BYTE *)(a2 + 96))
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), 0);
  result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfoString((uint64_t)a1, "OF ");
    deparseTypeName(a1, *(_QWORD *)(a2 + 48));
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfoString((uint64_t)a1, "PARTITION OF ");
    deparseRangeVar((uint64_t)a1, **(_QWORD **)(*(_QWORD *)(a2 + 24) + 16), 0);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v9 = *(_QWORD *)(a2 + 16);
  if (v9 && *(int *)(v9 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    v10 = *(_QWORD *)(a2 + 16);
    if (v10)
    {
      if (*(int *)(v10 + 4) >= 1)
      {
        v11 = 0;
        v12 = 8;
        while (1)
        {
          v13 = *(_QWORD *)(v10 + 16);
          v14 = *(int **)(v13 + 8 * v11);
          v15 = *v14;
          if (*v14 != 381)
          {
            if (v15 == 369)
            {
              deparseConstraint(a1, *(_QWORD *)(v13 + 8 * v11));
            }
            else if (v15 == 367)
            {
              deparseColumnDef((uint64_t)a1, *(_QWORD **)(v13 + 8 * v11));
            }
            goto LABEL_47;
          }
          appendStringInfoString((uint64_t)a1, "LIKE ");
          deparseRangeVar((uint64_t)a1, *((_QWORD *)v14 + 1), 0);
          appendStringInfoChar((uint64_t)a1, 32);
          v16 = v14[4];
          v17 = "INCLUDING ALL ";
          if (v16 == 0x7FFFFFFF)
            goto LABEL_44;
          if ((v16 & 1) != 0)
          {
            appendStringInfoString((uint64_t)a1, "INCLUDING COMMENTS ");
            v16 = v14[4];
            if ((v16 & 2) == 0)
            {
LABEL_27:
              if ((v16 & 4) == 0)
                goto LABEL_28;
              goto LABEL_39;
            }
          }
          else if ((v16 & 2) == 0)
          {
            goto LABEL_27;
          }
          appendStringInfoString((uint64_t)a1, "INCLUDING CONSTRAINTS ");
          v16 = v14[4];
          if ((v16 & 4) == 0)
          {
LABEL_28:
            if ((v16 & 0x10) == 0)
              goto LABEL_29;
            goto LABEL_40;
          }
LABEL_39:
          appendStringInfoString((uint64_t)a1, "INCLUDING DEFAULTS ");
          v16 = v14[4];
          if ((v16 & 0x10) == 0)
          {
LABEL_29:
            if ((v16 & 8) == 0)
              goto LABEL_30;
            goto LABEL_41;
          }
LABEL_40:
          appendStringInfoString((uint64_t)a1, "INCLUDING IDENTITY ");
          v16 = v14[4];
          if ((v16 & 8) == 0)
          {
LABEL_30:
            if ((v16 & 0x20) == 0)
              goto LABEL_31;
            goto LABEL_42;
          }
LABEL_41:
          appendStringInfoString((uint64_t)a1, "INCLUDING GENERATED ");
          v16 = v14[4];
          if ((v16 & 0x20) == 0)
          {
LABEL_31:
            if ((v16 & 0x40) == 0)
              goto LABEL_32;
            goto LABEL_43;
          }
LABEL_42:
          appendStringInfoString((uint64_t)a1, "INCLUDING INDEXES ");
          v16 = v14[4];
          if ((v16 & 0x40) == 0)
          {
LABEL_32:
            v17 = "INCLUDING STORAGE ";
            if ((v16 & 0x80) == 0)
              goto LABEL_33;
            goto LABEL_44;
          }
LABEL_43:
          appendStringInfoString((uint64_t)a1, "INCLUDING STATISTICS ");
          v17 = "INCLUDING STORAGE ";
          if ((v14[4] & 0x80) == 0)
          {
LABEL_33:
            v18 = a1[2];
            v19 = __OFSUB__(v18, 1);
            v20 = (v18 - 1);
            if ((int)v20 < 0 == v19)
              goto LABEL_45;
            goto LABEL_47;
          }
LABEL_44:
          appendStringInfoString((uint64_t)a1, v17);
          v21 = a1[2];
          v19 = __OFSUB__(v21, 1);
          v20 = (v21 - 1);
          if ((int)v20 < 0 == v19)
          {
LABEL_45:
            v22 = *(_QWORD *)a1;
            if (*(_BYTE *)(*(_QWORD *)a1 + v20) == 32)
            {
              a1[2] = v20;
              *(_BYTE *)(v22 + v20) = 0;
            }
          }
LABEL_47:
          if (v13 + v12)
            v23 = v13 + v12 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                                + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
          else
            v23 = 1;
          if (!v23)
            appendStringInfoString((uint64_t)a1, ", ");
          ++v11;
          v12 += 8;
          if (v11 >= *(int *)(v10 + 4))
            goto LABEL_56;
        }
      }
      result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
      v24 = *(_QWORD *)(a2 + 32);
      if (!v24)
        goto LABEL_97;
LABEL_57:
      deparsePartitionBoundSpec(a1, v24);
      result = appendStringInfoChar((uint64_t)a1, 32);
      goto LABEL_58;
    }
LABEL_56:
    result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
    v24 = *(_QWORD *)(a2 + 32);
    if (v24)
      goto LABEL_57;
  }
  else
  {
    v24 = *(_QWORD *)(a2 + 32);
    if (v24)
      goto LABEL_57;
    if (!*(_QWORD *)(a2 + 48))
    {
      result = (uint64_t)appendStringInfoString((uint64_t)a1, "() ");
      v24 = *(_QWORD *)(a2 + 32);
      if (v24)
        goto LABEL_57;
    }
  }
LABEL_97:
  v55 = *(_QWORD *)(a2 + 24);
  if (v55 && *(int *)(v55 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "INHERITS (");
    if (*(int *)(v55 + 4) >= 1)
    {
      v56 = 0;
      v57 = 8;
      do
      {
        v58 = *(_QWORD *)(v55 + 16);
        deparseRangeVar((uint64_t)a1, *(_QWORD *)(v58 + 8 * v56), 0);
        v59 = *(int *)(v55 + 4);
        if (v58 + v57)
          v60 = v58 + v57 >= (unint64_t)(*(_QWORD *)(v55 + 16) + 8 * v59);
        else
          v60 = 1;
        if (!v60)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v59 = *(int *)(v55 + 4);
        }
        ++v56;
        v57 += 8;
      }
      while (v56 < v59);
    }
    result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
  }
LABEL_58:
  v25 = *(_QWORD *)(a2 + 40);
  if (v25)
  {
    appendStringInfoString((uint64_t)a1, "PARTITION BY ");
    appendStringInfoString((uint64_t)a1, *(char **)(v25 + 8));
    appendStringInfoChar((uint64_t)a1, 40);
    v26 = *(_QWORD *)(v25 + 16);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      v27 = 0;
      do
      {
        v28 = *(_QWORD *)(v26 + 16) + 8 * v27;
        v29 = *(_QWORD *)v28;
        v30 = *(_BYTE **)(*(_QWORD *)v28 + 8);
        if (v30)
        {
          v31 = quote_identifier(v30);
          appendStringInfoString((uint64_t)a1, v31);
          appendStringInfoChar((uint64_t)a1, 32);
        }
        else if (*(_QWORD *)(v29 + 16))
        {
          appendStringInfoChar((uint64_t)a1, 40);
          deparseExpr(a1, *(int **)(v29 + 16), v32, v33, v34, v35, v36, v37);
          appendStringInfoString((uint64_t)a1, ") ");
        }
        deparseOptCollate((uint64_t)a1, *(_QWORD *)(v29 + 24));
        v38 = *(_QWORD *)(v29 + 32);
        if (v38 && *(int *)(v38 + 4) >= 1)
        {
          v39 = 0;
          v40 = 8;
          do
          {
            v41 = *(_QWORD *)(v38 + 16);
            v42 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v41 + 8 * v39) + 8));
            appendStringInfoString((uint64_t)a1, v42);
            v43 = *(int *)(v38 + 4);
            if (v41 + v40)
              v44 = v41 + v40 >= (unint64_t)(*(_QWORD *)(v38 + 16) + 8 * v43);
            else
              v44 = 1;
            if (!v44)
            {
              appendStringInfoChar((uint64_t)a1, 46);
              v43 = *(int *)(v38 + 4);
            }
            ++v39;
            v40 += 8;
          }
          while (v39 < v43);
        }
        v45 = a1[2];
        v19 = __OFSUB__(v45, 1);
        v46 = (v45 - 1);
        if ((int)v46 < 0 == v19)
        {
          v47 = *(_QWORD *)a1;
          if (*(_BYTE *)(*(_QWORD *)a1 + v46) == 32)
          {
            a1[2] = v46;
            *(_BYTE *)(v47 + v46) = 0;
          }
        }
        if (v28 != -8
          && v28 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v25 + 16) + 16)
                                        + 8 * *(int *)(*(_QWORD *)(v25 + 16) + 4)))
        {
          appendStringInfoString((uint64_t)a1, ", ");
        }
        ++v27;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    appendStringInfoChar((uint64_t)a1, 41);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(_QWORD *)(a2 + 88))
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    v48 = quote_identifier(*(_BYTE **)(a2 + 88));
    result = (uint64_t)appendStringInfoString((uint64_t)a1, v48);
  }
  v49 = *(_QWORD *)(a2 + 64);
  if (v49 && *(int *)(v49 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v49);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v50 = *(_DWORD *)(a2 + 72) - 1;
  if (v50 <= 2)
    result = (uint64_t)appendStringInfoString((uint64_t)a1, (&off_1E264ABF8)[v50]);
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfoString((uint64_t)a1, "TABLESPACE ");
    v51 = quote_identifier(*(_BYTE **)(a2 + 80));
    result = (uint64_t)appendStringInfoString((uint64_t)a1, v51);
  }
  v52 = a1[2];
  v19 = __OFSUB__(v52, 1);
  v53 = (v52 - 1);
  if ((int)v53 < 0 == v19)
  {
    v54 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v53) == 32)
    {
      a1[2] = v53;
      *(_BYTE *)(v54 + v53) = 0;
    }
  }
  return result;
}

uint64_t deparseCreateTrigStmt(void *a1, uint64_t a2)
{
  char *v4;
  int v5;
  char *v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  BOOL v40;

  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (*(_BYTE *)(a2 + 64))
    appendStringInfoString((uint64_t)a1, "CONSTRAINT ");
  appendStringInfoString((uint64_t)a1, "TRIGGER ");
  v4 = quote_identifier(*(_BYTE **)(a2 + 8));
  appendStringInfoString((uint64_t)a1, v4);
  appendStringInfoChar((uint64_t)a1, 32);
  v5 = *(__int16 *)(a2 + 42);
  if (v5 == 64)
  {
    v6 = "INSTEAD OF ";
  }
  else if (v5 == 2)
  {
    v6 = "BEFORE ";
  }
  else
  {
    if (*(_WORD *)(a2 + 42))
      goto LABEL_10;
    v6 = "AFTER ";
  }
  appendStringInfoString((uint64_t)a1, v6);
LABEL_10:
  v7 = *(_WORD *)(a2 + 44);
  if ((v7 & 4) == 0)
  {
    if ((v7 & 8) == 0)
    {
      if ((v7 & 0x10) == 0)
      {
        LOBYTE(v8) = 1;
        goto LABEL_32;
      }
      goto LABEL_19;
    }
    goto LABEL_16;
  }
  appendStringInfoString((uint64_t)a1, "INSERT ");
  v9 = *(_WORD *)(a2 + 44);
  if ((v9 & 8) != 0)
  {
    appendStringInfoString((uint64_t)a1, "OR ");
LABEL_16:
    appendStringInfoString((uint64_t)a1, "DELETE ");
    v9 = *(_WORD *)(a2 + 44);
  }
  if ((v9 & 0x10) == 0)
    goto LABEL_31;
  appendStringInfoString((uint64_t)a1, "OR ");
LABEL_19:
  appendStringInfoString((uint64_t)a1, "UPDATE ");
  v8 = *(_QWORD *)(a2 + 48);
  if (!v8)
    goto LABEL_32;
  if (*(int *)(v8 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "OF ");
    v10 = *(_QWORD *)(a2 + 48);
    if (v10 && *(int *)(v10 + 4) >= 1)
    {
      v11 = 0;
      v12 = 8;
      do
      {
        v13 = *(_QWORD *)(v10 + 16);
        v14 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v13 + 8 * v11) + 8));
        appendStringInfoString((uint64_t)a1, v14);
        v15 = *(int *)(v10 + 4);
        if (v13 + v12)
          v16 = v13 + v12 >= (unint64_t)(*(_QWORD *)(v10 + 16) + 8 * v15);
        else
          v16 = 1;
        if (!v16)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v15 = *(int *)(v10 + 4);
        }
        ++v11;
        v12 += 8;
      }
      while (v11 < v15);
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
LABEL_31:
  LOBYTE(v8) = 0;
LABEL_32:
  if ((*(_WORD *)(a2 + 44) & 0x20) != 0)
  {
    if ((v8 & 1) == 0)
      appendStringInfoString((uint64_t)a1, "OR ");
    appendStringInfoString((uint64_t)a1, "TRUNCATE ");
  }
  appendStringInfoString((uint64_t)a1, "ON ");
  deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 16), 0);
  appendStringInfoChar((uint64_t)a1, 32);
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfoString((uint64_t)a1, "REFERENCING ");
    v17 = *(_QWORD *)(a2 + 72);
    if (v17)
    {
      if (*(int *)(v17 + 4) >= 1)
      {
        v18 = 0;
        do
        {
          v19 = *(_QWORD *)(*(_QWORD *)(v17 + 16) + 8 * v18);
          if (*(_BYTE *)(v19 + 16))
            v20 = "NEW ";
          else
            v20 = "OLD ";
          appendStringInfoString((uint64_t)a1, v20);
          if (*(_BYTE *)(v19 + 17))
            v21 = "TABLE ";
          else
            v21 = "ROW ";
          appendStringInfoString((uint64_t)a1, v21);
          v22 = quote_identifier(*(_BYTE **)(v19 + 8));
          appendStringInfoString((uint64_t)a1, v22);
          appendStringInfoChar((uint64_t)a1, 32);
          ++v18;
        }
        while (v18 < *(int *)(v17 + 4));
      }
    }
  }
  if (*(_QWORD *)(a2 + 88))
  {
    appendStringInfoString((uint64_t)a1, "FROM ");
    deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 88), 0);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(_BYTE *)(a2 + 80))
    appendStringInfoString((uint64_t)a1, "DEFERRABLE ");
  if (*(_BYTE *)(a2 + 81))
    appendStringInfoString((uint64_t)a1, "INITIALLY DEFERRED ");
  if (*(_BYTE *)(a2 + 40))
    appendStringInfoString((uint64_t)a1, "FOR EACH ROW ");
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfoString((uint64_t)a1, "WHEN (");
    deparseExpr(a1, *(int **)(a2 + 56), v23, v24, v25, v26, v27, v28);
    appendStringInfoString((uint64_t)a1, ") ");
  }
  appendStringInfoString((uint64_t)a1, "EXECUTE FUNCTION ");
  v29 = *(_QWORD *)(a2 + 24);
  if (v29 && *(int *)(v29 + 4) >= 1)
  {
    v30 = 0;
    v31 = 8;
    do
    {
      v32 = *(_QWORD *)(v29 + 16);
      v33 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v32 + 8 * v30) + 8));
      appendStringInfoString((uint64_t)a1, v33);
      v34 = *(int *)(v29 + 4);
      if (v32 + v31)
        v35 = v32 + v31 >= (unint64_t)(*(_QWORD *)(v29 + 16) + 8 * v34);
      else
        v35 = 1;
      if (!v35)
      {
        appendStringInfoChar((uint64_t)a1, 46);
        v34 = *(int *)(v29 + 4);
      }
      ++v30;
      v31 += 8;
    }
    while (v30 < v34);
  }
  appendStringInfoChar((uint64_t)a1, 40);
  v36 = *(_QWORD *)(a2 + 32);
  if (v36 && *(int *)(v36 + 4) >= 1)
  {
    v37 = 0;
    v38 = 8;
    do
    {
      v39 = *(_QWORD *)(v36 + 16);
      deparseStringLiteral((uint64_t)a1, *(char **)(*(_QWORD *)(v39 + 8 * v37) + 8));
      if (v39 + v38)
        v40 = v39 + v38 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                            + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
      else
        v40 = 1;
      if (!v40)
        appendStringInfoString((uint64_t)a1, ", ");
      ++v37;
      v38 += 8;
    }
    while (v37 < *(int *)(v36 + 4));
  }
  return appendStringInfoChar((uint64_t)a1, 41);
}

uint64_t deparseDeclareCursorStmt(_DWORD *a1, uint64_t a2)
{
  char *v4;
  int v5;

  appendStringInfoString((uint64_t)a1, "DECLARE ");
  v4 = quote_identifier(*(_BYTE **)(a2 + 8));
  appendStringInfoString((uint64_t)a1, v4);
  appendStringInfoChar((uint64_t)a1, 32);
  v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 1) != 0)
  {
    appendStringInfoString((uint64_t)a1, "BINARY ");
    v5 = *(_DWORD *)(a2 + 16);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  appendStringInfoString((uint64_t)a1, "SCROLL ");
  v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0)
      goto LABEL_5;
LABEL_11:
    appendStringInfoString((uint64_t)a1, "INSENSITIVE ");
    appendStringInfoString((uint64_t)a1, "CURSOR ");
    if ((*(_BYTE *)(a2 + 16) & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_10:
  appendStringInfoString((uint64_t)a1, "NO SCROLL ");
  if ((*(_DWORD *)(a2 + 16) & 8) != 0)
    goto LABEL_11;
LABEL_5:
  appendStringInfoString((uint64_t)a1, "CURSOR ");
  if ((*(_BYTE *)(a2 + 16) & 0x10) != 0)
LABEL_6:
    appendStringInfoString((uint64_t)a1, "WITH HOLD ");
LABEL_7:
  appendStringInfoString((uint64_t)a1, "FOR ");
  return deparseSelectStmt(a1, *(_QWORD *)(a2 + 24));
}

uint64_t deparseDeleteStmt(_DWORD *a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;

  if (a2[5])
  {
    deparseWithClause(a1);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "DELETE FROM ");
  deparseRangeVar((uint64_t)a1, a2[1], 0);
  result = appendStringInfoChar((uint64_t)a1, 32);
  if (a2[2])
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    v11 = a2[2];
    if (v11 && *(int *)(v11 + 4) >= 1)
    {
      v12 = 0;
      v13 = 8;
      do
      {
        v14 = *(_QWORD *)(v11 + 16);
        deparseTableRef(a1, *(_QWORD *)(v14 + 8 * v12), v5, v6, v7, v8, v9, v10);
        v15 = *(int *)(v11 + 4);
        if (v14 + v13)
          v16 = v14 + v13 >= (unint64_t)(*(_QWORD *)(v11 + 16) + 8 * v15);
        else
          v16 = 1;
        if (!v16)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v15 = *(int *)(v11 + 4);
        }
        ++v12;
        v13 += 8;
      }
      while (v12 < v15);
    }
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v17 = a2[3];
  if (v17)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v17);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v18 = a2[4];
  if (v18 && *(int *)(v18 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "RETURNING ");
    result = deparseTargetList((uint64_t)a1, a2[4]);
  }
  v19 = a1[2];
  v20 = __OFSUB__(v19, 1);
  v21 = (v19 - 1);
  if ((int)v21 < 0 == v20)
  {
    v22 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v21) == 32)
    {
      a1[2] = v21;
      *(_BYTE *)(v22 + v21) = 0;
    }
  }
  return result;
}

void *deparseExecuteStmt(void *a1, uint64_t a2)
{
  char *v4;
  void *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  appendStringInfoString((uint64_t)a1, "EXECUTE ");
  v4 = quote_identifier(*(_BYTE **)(a2 + 8));
  result = appendStringInfoString((uint64_t)a1, v4);
  v6 = *(_QWORD *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    v13 = *(_QWORD *)(a2 + 16);
    if (v13 && *(int *)(v13 + 4) >= 1)
    {
      v14 = 0;
      v15 = 8;
      do
      {
        v16 = *(_QWORD *)(v13 + 16);
        deparseExpr(a1, *(int **)(v16 + 8 * v14), v7, v8, v9, v10, v11, v12);
        v17 = *(int *)(v13 + 4);
        if (v16 + v15)
          v18 = v16 + v15 >= (unint64_t)(*(_QWORD *)(v13 + 16) + 8 * v17);
        else
          v18 = 1;
        if (!v18)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v17 = *(int *)(v13 + 4);
        }
        ++v14;
        v15 += 8;
      }
      while (v14 < v17);
    }
    return (void *)appendStringInfoChar((uint64_t)a1, 41);
  }
  return result;
}

uint64_t deparseGrantStmt(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  BOOL v25;
  char *v26;
  uint64_t result;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  BOOL v35;
  int v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  BOOL v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  BOOL v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  BOOL v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  BOOL v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  BOOL v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  BOOL v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  BOOL v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  uint64_t v114;
  BOOL v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  BOOL v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  BOOL v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  char *v129;
  uint64_t v130;
  BOOL v131;

  if (*(_BYTE *)(a2 + 4))
    v4 = "GRANT ";
  else
    v4 = "REVOKE ";
  appendStringInfoString(a1, v4);
  if (!*(_BYTE *)(a2 + 4) && *(_BYTE *)(a2 + 40))
    appendStringInfoString(a1, "GRANT OPTION FOR ");
  v5 = *(_QWORD *)(a2 + 24);
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    v6 = 0;
    v7 = 8;
    do
    {
      v8 = *(_QWORD *)(v5 + 16);
      deparseAccessPriv(a1, *(_QWORD *)(v8 + 8 * v6));
      if (v8 + v7)
        v9 = v8 + v7 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                         + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
      else
        v9 = 1;
      if (!v9)
        appendStringInfoString(a1, ", ");
      ++v6;
      v7 += 8;
    }
    while (v6 < *(int *)(v5 + 4));
    appendStringInfoChar(a1, 32);
  }
  else
  {
    appendStringInfoString(a1, "ALL ");
  }
  appendStringInfoString(a1, "ON ");
  v11 = *(_DWORD *)(a2 + 8);
  v10 = *(_DWORD *)(a2 + 12);
  if (v11 == 2)
  {
    switch(v10)
    {
      case 19:
        v15 = "FUNCTIONS";
        goto LABEL_47;
      case 34:
        v15 = "SCHEMAS";
        goto LABEL_47;
      case 35:
        v15 = "SEQUENCES";
        goto LABEL_47;
      case 39:
        v15 = "TABLES";
        goto LABEL_47;
      case 47:
        v15 = "TYPES";
LABEL_47:
        appendStringInfoString(a1, v15);
        break;
      default:
        break;
    }
  }
  else
  {
    v12 = *(_QWORD *)(a2 + 16);
    if (v11 == 1)
    {
      switch(v10)
      {
        case 19:
          appendStringInfoString(a1, "ALL FUNCTIONS IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v16 = 0;
            v17 = 8;
            do
            {
              v18 = *(_QWORD *)(v12 + 16);
              v19 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v18 + 8 * v16) + 8));
              appendStringInfoString(a1, v19);
              v20 = *(int *)(v12 + 4);
              if (v18 + v17)
                v21 = v18 + v17 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v20);
              else
                v21 = 1;
              if (!v21)
              {
                appendStringInfoString(a1, ", ");
                v20 = *(int *)(v12 + 4);
              }
              ++v16;
              v17 += 8;
            }
            while (v16 < v20);
          }
          break;
        case 28:
          appendStringInfoString(a1, "ALL PROCEDURES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v40 = 0;
            v41 = 8;
            do
            {
              v42 = *(_QWORD *)(v12 + 16);
              v43 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v42 + 8 * v40) + 8));
              appendStringInfoString(a1, v43);
              v44 = *(int *)(v12 + 4);
              if (v42 + v41)
                v45 = v42 + v41 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v44);
              else
                v45 = 1;
              if (!v45)
              {
                appendStringInfoString(a1, ", ");
                v44 = *(int *)(v12 + 4);
              }
              ++v40;
              v41 += 8;
            }
            while (v40 < v44);
          }
          break;
        case 32:
          appendStringInfoString(a1, "ALL ROUTINES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v46 = 0;
            v47 = 8;
            do
            {
              v48 = *(_QWORD *)(v12 + 16);
              v49 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v48 + 8 * v46) + 8));
              appendStringInfoString(a1, v49);
              v50 = *(int *)(v12 + 4);
              if (v48 + v47)
                v51 = v48 + v47 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v50);
              else
                v51 = 1;
              if (!v51)
              {
                appendStringInfoString(a1, ", ");
                v50 = *(int *)(v12 + 4);
              }
              ++v46;
              v47 += 8;
            }
            while (v46 < v50);
          }
          break;
        case 35:
          appendStringInfoString(a1, "ALL SEQUENCES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v52 = 0;
            v53 = 8;
            do
            {
              v54 = *(_QWORD *)(v12 + 16);
              v55 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v54 + 8 * v52) + 8));
              appendStringInfoString(a1, v55);
              v56 = *(int *)(v12 + 4);
              if (v54 + v53)
                v57 = v54 + v53 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v56);
              else
                v57 = 1;
              if (!v57)
              {
                appendStringInfoString(a1, ", ");
                v56 = *(int *)(v12 + 4);
              }
              ++v52;
              v53 += 8;
            }
            while (v52 < v56);
          }
          break;
        case 39:
          appendStringInfoString(a1, "ALL TABLES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v58 = 0;
            v59 = 8;
            do
            {
              v60 = *(_QWORD *)(v12 + 16);
              v61 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v60 + 8 * v58) + 8));
              appendStringInfoString(a1, v61);
              v62 = *(int *)(v12 + 4);
              if (v60 + v59)
                v63 = v60 + v59 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v62);
              else
                v63 = 1;
              if (!v63)
              {
                appendStringInfoString(a1, ", ");
                v62 = *(int *)(v12 + 4);
              }
              ++v58;
              v59 += 8;
            }
            while (v58 < v62);
          }
          break;
        default:
          break;
      }
    }
    else if (!v11)
    {
      switch(v10)
      {
        case 9:
          appendStringInfoString(a1, "DATABASE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v13 = 0;
            v14 = 8;
            do
            {
              v22 = *(_QWORD *)(v12 + 16);
              v23 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v22 + 8 * v13) + 8));
              appendStringInfoString(a1, v23);
              v24 = *(int *)(v12 + 4);
              if (v22 + v14)
                v25 = v22 + v14 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v24);
              else
                v25 = 1;
              if (!v25)
              {
                appendStringInfoString(a1, ", ");
                v24 = *(int *)(v12 + 4);
              }
              ++v13;
              v14 += 8;
            }
            while (v13 < v24);
          }
          break;
        case 12:
          v64 = "DOMAIN ";
          goto LABEL_216;
        case 16:
          appendStringInfoString(a1, "FOREIGN DATA WRAPPER ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v65 = 0;
            v66 = 8;
            do
            {
              v67 = *(_QWORD *)(v12 + 16);
              v68 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v67 + 8 * v65) + 8));
              appendStringInfoString(a1, v68);
              v69 = *(int *)(v12 + 4);
              if (v67 + v66)
                v70 = v67 + v66 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v69);
              else
                v70 = 1;
              if (!v70)
              {
                appendStringInfoString(a1, ", ");
                v69 = *(int *)(v12 + 4);
              }
              ++v65;
              v66 += 8;
            }
            while (v65 < v69);
          }
          break;
        case 17:
          appendStringInfoString(a1, "FOREIGN SERVER ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v71 = 0;
            v72 = 8;
            do
            {
              v73 = *(_QWORD *)(v12 + 16);
              v74 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v73 + 8 * v71) + 8));
              appendStringInfoString(a1, v74);
              v75 = *(int *)(v12 + 4);
              if (v73 + v72)
                v76 = v73 + v72 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v75);
              else
                v76 = 1;
              if (!v76)
              {
                appendStringInfoString(a1, ", ");
                v75 = *(int *)(v12 + 4);
              }
              ++v71;
              v72 += 8;
            }
            while (v71 < v75);
          }
          break;
        case 19:
          appendStringInfoString(a1, "FUNCTION ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v77 = 0;
            v78 = 8;
            do
            {
              v79 = *(_QWORD *)(v12 + 16);
              deparseFunctionWithArgtypes(a1, *(_QWORD *)(v79 + 8 * v77));
              v80 = *(int *)(v12 + 4);
              if (v79 + v78)
                v81 = v79 + v78 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v80);
              else
                v81 = 1;
              if (!v81)
              {
                appendStringInfoString(a1, ", ");
                v80 = *(int *)(v12 + 4);
              }
              ++v77;
              v78 += 8;
            }
            while (v77 < v80);
          }
          break;
        case 21:
          appendStringInfoString(a1, "LANGUAGE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v82 = 0;
            v83 = 8;
            do
            {
              v84 = *(_QWORD *)(v12 + 16);
              v85 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v84 + 8 * v82) + 8));
              appendStringInfoString(a1, v85);
              v86 = *(int *)(v12 + 4);
              if (v84 + v83)
                v87 = v84 + v83 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v86);
              else
                v87 = 1;
              if (!v87)
              {
                appendStringInfoString(a1, ", ");
                v86 = *(int *)(v12 + 4);
              }
              ++v82;
              v83 += 8;
            }
            while (v82 < v86);
          }
          break;
        case 22:
          appendStringInfoString(a1, "LARGE OBJECT ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v94 = 0;
            v95 = 8;
            do
            {
              v96 = *(_QWORD *)(v12 + 16);
              v97 = *(_QWORD *)(v96 + 8 * v94);
              if (*(_DWORD *)v97 == 222)
              {
                appendStringInfoString(a1, *(char **)(v97 + 8));
              }
              else if (*(_DWORD *)v97 == 221)
              {
                appendStringInfo(a1, "%d", v88, v89, v90, v91, v92, v93, *(unsigned int *)(v97 + 8));
              }
              v98 = *(int *)(v12 + 4);
              if (v96 + v95)
                v99 = v96 + v95 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v98);
              else
                v99 = 1;
              if (!v99)
              {
                appendStringInfoString(a1, ", ");
                v98 = *(int *)(v12 + 4);
              }
              ++v94;
              v95 += 8;
            }
            while (v94 < v98);
          }
          break;
        case 28:
          appendStringInfoString(a1, "PROCEDURE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v100 = 0;
            v101 = 8;
            do
            {
              v102 = *(_QWORD *)(v12 + 16);
              deparseFunctionWithArgtypes(a1, *(_QWORD *)(v102 + 8 * v100));
              v103 = *(int *)(v12 + 4);
              if (v102 + v101)
                v104 = v102 + v101 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v103);
              else
                v104 = 1;
              if (!v104)
              {
                appendStringInfoString(a1, ", ");
                v103 = *(int *)(v12 + 4);
              }
              ++v100;
              v101 += 8;
            }
            while (v100 < v103);
          }
          break;
        case 32:
          appendStringInfoString(a1, "ROUTINE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v105 = 0;
            v106 = 8;
            do
            {
              v107 = *(_QWORD *)(v12 + 16);
              deparseFunctionWithArgtypes(a1, *(_QWORD *)(v107 + 8 * v105));
              v108 = *(int *)(v12 + 4);
              if (v107 + v106)
                v109 = v107 + v106 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v108);
              else
                v109 = 1;
              if (!v109)
              {
                appendStringInfoString(a1, ", ");
                v108 = *(int *)(v12 + 4);
              }
              ++v105;
              v106 += 8;
            }
            while (v105 < v108);
          }
          break;
        case 34:
          appendStringInfoString(a1, "SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v110 = 0;
            v111 = 8;
            do
            {
              v112 = *(_QWORD *)(v12 + 16);
              v113 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v112 + 8 * v110) + 8));
              appendStringInfoString(a1, v113);
              v114 = *(int *)(v12 + 4);
              if (v112 + v111)
                v115 = v112 + v111 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v114);
              else
                v115 = 1;
              if (!v115)
              {
                appendStringInfoString(a1, ", ");
                v114 = *(int *)(v12 + 4);
              }
              ++v110;
              v111 += 8;
            }
            while (v110 < v114);
          }
          break;
        case 35:
          appendStringInfoString(a1, "SEQUENCE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v116 = 0;
            v117 = 8;
            do
            {
              v118 = *(_QWORD *)(v12 + 16);
              deparseRangeVar(a1, *(_QWORD *)(v118 + 8 * v116), 0);
              v119 = *(int *)(v12 + 4);
              if (v118 + v117)
                v120 = v118 + v117 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v119);
              else
                v120 = 1;
              if (!v120)
              {
                appendStringInfoString(a1, ", ");
                v119 = *(int *)(v12 + 4);
              }
              ++v116;
              v117 += 8;
            }
            while (v116 < v119);
          }
          break;
        case 39:
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v121 = 0;
            v122 = 8;
            do
            {
              v123 = *(_QWORD *)(v12 + 16);
              deparseRangeVar(a1, *(_QWORD *)(v123 + 8 * v121), 0);
              v124 = *(int *)(v12 + 4);
              if (v123 + v122)
                v125 = v123 + v122 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v124);
              else
                v125 = 1;
              if (!v125)
              {
                appendStringInfoString(a1, ", ");
                v124 = *(int *)(v12 + 4);
              }
              ++v121;
              v122 += 8;
            }
            while (v121 < v124);
          }
          break;
        case 40:
          appendStringInfoString(a1, "TABLESPACE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            v126 = 0;
            v127 = 8;
            do
            {
              v128 = *(_QWORD *)(v12 + 16);
              v129 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v128 + 8 * v126) + 8));
              appendStringInfoString(a1, v129);
              v130 = *(int *)(v12 + 4);
              if (v128 + v127)
                v131 = v128 + v127 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v130);
              else
                v131 = 1;
              if (!v131)
              {
                appendStringInfoString(a1, ", ");
                v130 = *(int *)(v12 + 4);
              }
              ++v126;
              v127 += 8;
            }
            while (v126 < v130);
          }
          break;
        case 47:
          v64 = "TYPE ";
LABEL_216:
          appendStringInfoString(a1, v64);
          deparseAnyNameList(a1, v12);
          break;
        default:
          break;
      }
    }
  }
  appendStringInfoChar(a1, 32);
  if (*(_BYTE *)(a2 + 4))
    v26 = "TO ";
  else
    v26 = "FROM ";
  result = (uint64_t)appendStringInfoString(a1, v26);
  v28 = *(_QWORD *)(a2 + 32);
  if (v28 && *(int *)(v28 + 4) >= 1)
  {
    v29 = 0;
    v30 = 8;
    do
    {
      v31 = *(_QWORD *)(v28 + 16);
      v32 = *(_QWORD *)(v31 + 8 * v29);
      switch(*(_DWORD *)(v32 + 4))
      {
        case 0:
          v33 = quote_identifier(*(_BYTE **)(v32 + 8));
          v34 = a1;
          goto LABEL_60;
        case 1:
          v34 = a1;
          v33 = "CURRENT_USER";
          goto LABEL_60;
        case 2:
          v34 = a1;
          v33 = "SESSION_USER";
          goto LABEL_60;
        case 3:
          v34 = a1;
          v33 = "public";
LABEL_60:
          appendStringInfoString(v34, v33);
          break;
        default:
          break;
      }
      if (v31 + v30)
        v35 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                            + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
      else
        v35 = 1;
      if (!v35)
        appendStringInfoChar(a1, 44);
      result = appendStringInfoChar(a1, 32);
      ++v29;
      v30 += 8;
    }
    while (v29 < *(int *)(v28 + 4));
  }
  if (*(_BYTE *)(a2 + 4) && *(_BYTE *)(a2 + 40))
    result = (uint64_t)appendStringInfoString(a1, "WITH GRANT OPTION ");
  if (*(_DWORD *)(a2 + 44) == 1)
    result = (uint64_t)appendStringInfoString(a1, "CASCADE ");
  v36 = *(_DWORD *)(a1 + 8);
  v37 = __OFSUB__(v36, 1);
  v38 = (v36 - 1);
  if ((int)v38 < 0 == v37)
  {
    v39 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v38) == 32)
    {
      *(_DWORD *)(a1 + 8) = v38;
      *(_BYTE *)(v39 + v38) = 0;
    }
  }
  return result;
}

uint64_t deparseIndexStmt(_DWORD *a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  char *v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;

  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (*(_BYTE *)(a2 + 104))
    appendStringInfoString((uint64_t)a1, "UNIQUE ");
  appendStringInfoString((uint64_t)a1, "INDEX ");
  if (*(_BYTE *)(a2 + 110))
    appendStringInfoString((uint64_t)a1, "CONCURRENTLY ");
  if (*(_BYTE *)(a2 + 111))
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  v4 = *(char **)(a2 + 8);
  if (v4)
  {
    appendStringInfoString((uint64_t)a1, v4);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "ON ");
  deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 16), 0);
  appendStringInfoChar((uint64_t)a1, 32);
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    v5 = quote_identifier(*(_BYTE **)(a2 + 24));
    appendStringInfoString((uint64_t)a1, v5);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoChar((uint64_t)a1, 40);
  v12 = *(_QWORD *)(a2 + 40);
  if (v12 && *(int *)(v12 + 4) >= 1)
  {
    v13 = 0;
    v14 = 8;
    do
    {
      v15 = *(_QWORD *)(v12 + 16);
      deparseIndexElem(a1, *(_QWORD *)(v15 + 8 * v13), v6, v7, v8, v9, v10, v11);
      if (v15 + v14)
        v16 = v15 + v14 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                            + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
      else
        v16 = 1;
      if (!v16)
        appendStringInfoString((uint64_t)a1, ", ");
      ++v13;
      v14 += 8;
    }
    while (v13 < *(int *)(v12 + 4));
  }
  result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
  v18 = *(_QWORD *)(a2 + 48);
  if (v18 && *(int *)(v18 + 4) > 0)
  {
    appendStringInfoString((uint64_t)a1, "INCLUDE (");
    v25 = *(_QWORD *)(a2 + 48);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        deparseIndexElem(a1, *(_QWORD *)(v28 + 8 * v26), v19, v20, v21, v22, v23, v24);
        if (v28 + v27)
          v29 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v29 = 1;
        if (!v29)
          appendStringInfoString((uint64_t)a1, ", ");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
  }
  v30 = *(_QWORD *)(a2 + 56);
  if (v30 && *(int *)(v30 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v30);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfoString((uint64_t)a1, "TABLESPACE ");
    v31 = quote_identifier(*(_BYTE **)(a2 + 32));
    appendStringInfoString((uint64_t)a1, v31);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v32 = *(int **)(a2 + 64);
  if (v32)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v32, v33, v34, v35, v36, v37, v38);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v39 = a1[2];
  v40 = __OFSUB__(v39, 1);
  v41 = (v39 - 1);
  if ((int)v41 < 0 == v40)
  {
    v42 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v41) == 32)
    {
      a1[2] = v41;
      *(_BYTE *)(v42 + v41) = 0;
    }
  }
  return result;
}

uint64_t deparseInsertStmt(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  char *v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  char *v31;
  uint64_t v32;
  int v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;

  if (*(_QWORD *)(a2 + 48))
  {
    deparseWithClause(a1);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "INSERT INTO ");
  deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), 1);
  appendStringInfoChar((uint64_t)a1, 32);
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    v5 = *(_QWORD *)(a2 + 16);
    if (v5 && *(int *)(v5 + 4) >= 1)
    {
      v6 = 0;
      v7 = 8;
      do
      {
        v8 = *(_QWORD *)(v5 + 16);
        v9 = *(_QWORD *)(v8 + 8 * v6);
        v10 = quote_identifier(*(_BYTE **)(v9 + 8));
        appendStringInfoString((uint64_t)a1, v10);
        deparseOptIndirection((uint64_t)a1, *(_QWORD *)(v9 + 16), 0);
        v11 = *(int *)(v5 + 4);
        if (v8 + v7)
          v12 = v8 + v7 >= (unint64_t)(*(_QWORD *)(v5 + 16) + 8 * v11);
        else
          v12 = 1;
        if (!v12)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v11 = *(int *)(v5 + 4);
        }
        ++v6;
        v7 += 8;
      }
      while (v6 < v11);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  v13 = *(_DWORD *)(a2 + 56);
  if (v13 == 1)
  {
    v14 = "OVERRIDING USER VALUE ";
  }
  else
  {
    if (v13 != 2)
      goto LABEL_20;
    v14 = "OVERRIDING SYSTEM VALUE ";
  }
  appendStringInfoString((uint64_t)a1, v14);
LABEL_20:
  v15 = *(_QWORD *)(a2 + 24);
  if (v15)
  {
    deparseSelectStmt(a1, v15);
    result = appendStringInfoChar((uint64_t)a1, 32);
    v17 = *(_QWORD *)(a2 + 32);
    if (!v17)
      goto LABEL_59;
  }
  else
  {
    result = (uint64_t)appendStringInfoString((uint64_t)a1, "DEFAULT VALUES ");
    v17 = *(_QWORD *)(a2 + 32);
    if (!v17)
      goto LABEL_59;
  }
  appendStringInfoString((uint64_t)a1, "ON CONFLICT ");
  v18 = *(_QWORD *)(v17 + 8);
  if (v18)
  {
    v19 = *(_QWORD *)(v18 + 8);
    if (v19 && *(int *)(v19 + 4) >= 1)
    {
      appendStringInfoChar((uint64_t)a1, 40);
      v26 = *(_QWORD *)(v18 + 8);
      if (v26 && *(int *)(v26 + 4) >= 1)
      {
        v27 = 0;
        v28 = 8;
        do
        {
          v29 = *(_QWORD *)(v26 + 16);
          deparseIndexElem(a1, *(_QWORD *)(v29 + 8 * v27), v20, v21, v22, v23, v24, v25);
          if (v29 + v28)
            v30 = v29 + v28 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v18 + 8) + 16)
                                                + 8 * *(int *)(*(_QWORD *)(v18 + 8) + 4));
          else
            v30 = 1;
          if (!v30)
            appendStringInfoString((uint64_t)a1, ", ");
          ++v27;
          v28 += 8;
        }
        while (v27 < *(int *)(v26 + 4));
      }
      appendStringInfoString((uint64_t)a1, ") ");
    }
    if (*(_QWORD *)(v18 + 24))
    {
      appendStringInfoString((uint64_t)a1, "ON CONSTRAINT ");
      v31 = quote_identifier(*(_BYTE **)(v18 + 24));
      appendStringInfoString((uint64_t)a1, v31);
      appendStringInfoChar((uint64_t)a1, 32);
    }
    v32 = *(_QWORD *)(v18 + 16);
    if (v32)
    {
      appendStringInfoString((uint64_t)a1, "WHERE ");
      deparseExpr(a1, v32);
      appendStringInfoChar((uint64_t)a1, 32);
    }
    v33 = a1[2];
    v34 = __OFSUB__(v33, 1);
    v35 = (v33 - 1);
    if ((int)v35 < 0 == v34)
    {
      v36 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v35) == 32)
      {
        a1[2] = v35;
        *(_BYTE *)(v36 + v35) = 0;
      }
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
  v37 = *(_DWORD *)(v17 + 4);
  if (v37 == 1)
  {
    v38 = "DO NOTHING ";
  }
  else
  {
    if (v37 != 2)
      goto LABEL_50;
    v38 = "DO UPDATE ";
  }
  appendStringInfoString((uint64_t)a1, v38);
LABEL_50:
  v39 = *(_QWORD *)(v17 + 16);
  if (v39 && *(int *)(v39 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "SET ");
    deparseSetClauseList((uint64_t)a1, *(_QWORD *)(v17 + 16));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  v40 = *(_QWORD *)(v17 + 24);
  if (v40)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v40);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  v41 = a1[2];
  v34 = __OFSUB__(v41, 1);
  v42 = (v41 - 1);
  if ((int)v42 < 0 == v34)
  {
    v43 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v42) == 32)
    {
      a1[2] = v42;
      *(_BYTE *)(v43 + v42) = 0;
    }
  }
  result = appendStringInfoChar((uint64_t)a1, 32);
LABEL_59:
  v44 = *(_QWORD *)(a2 + 40);
  if (v44 && *(int *)(v44 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "RETURNING ");
    result = deparseTargetList((uint64_t)a1, *(_QWORD *)(a2 + 40));
  }
  v45 = a1[2];
  v34 = __OFSUB__(v45, 1);
  v46 = (v45 - 1);
  if ((int)v46 < 0 == v34)
  {
    v47 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v46) == 32)
    {
      a1[2] = v46;
      *(_BYTE *)(v47 + v46) = 0;
    }
  }
  return result;
}

uint64_t deparseRefreshMatViewStmt(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;

  appendStringInfoString(a1, "REFRESH MATERIALIZED VIEW ");
  if (*(_BYTE *)(a2 + 4))
    appendStringInfoString(a1, "CONCURRENTLY ");
  deparseRangeVar(a1, *(_QWORD *)(a2 + 8), 0);
  result = appendStringInfoChar(a1, 32);
  if (*(_BYTE *)(a2 + 5))
    result = (uint64_t)appendStringInfoString(a1, "WITH NO DATA ");
  v5 = *(_DWORD *)(a1 + 8);
  v6 = __OFSUB__(v5, 1);
  v7 = (v5 - 1);
  if ((int)v7 < 0 == v6)
  {
    v8 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v7) == 32)
    {
      *(_DWORD *)(a1 + 8) = v7;
      *(_BYTE *)(v8 + v7) = 0;
    }
  }
  return result;
}

uint64_t deparseSelectStmt(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t result;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  _DWORD *v81;
  uint64_t v82;
  BOOL v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  BOOL v89;
  char *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  BOOL v103;
  int v104;
  char *v105;
  int v106;
  BOOL v107;
  uint64_t v108;
  uint64_t v109;
  int v111;
  uint64_t v112;
  uint64_t v113;

  v2 = a2;
  v4 = *(_QWORD *)(a2 + 120);
  if (v4)
  {
    deparseWithClause(a1, v4);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  v5 = *(_DWORD *)(v2 + 128);
  if ((v5 - 1) < 3)
  {
    v6 = *(_QWORD *)(v2 + 136);
    v7 = *(_QWORD *)(v6 + 80);
    if (v7 && *(int *)(v7 + 4) > 0
      || *(_QWORD *)(v6 + 88)
      || *(_QWORD *)(v6 + 96)
      || (v30 = *(_QWORD *)(v6 + 112)) != 0 && *(int *)(v30 + 4) > 0
      || *(_QWORD *)(v6 + 120))
    {
      v8 = 1;
      v9 = *(_QWORD *)(v2 + 144);
      v10 = *(_QWORD *)(v9 + 80);
      if (!v10)
        goto LABEL_10;
    }
    else
    {
      v8 = *(_DWORD *)(v6 + 128) != 0;
      v9 = *(_QWORD *)(v2 + 144);
      v10 = *(_QWORD *)(v9 + 80);
      if (!v10)
      {
LABEL_10:
        if (!*(_QWORD *)(v9 + 88) && !*(_QWORD *)(v9 + 96))
        {
          v31 = *(_QWORD *)(v9 + 112);
          if ((!v31 || *(int *)(v31 + 4) <= 0) && !*(_QWORD *)(v9 + 120))
          {
            v11 = *(_DWORD *)(v9 + 128) != 0;
            v12 = (uint64_t)a1;
            if (!v8)
            {
LABEL_57:
              deparseSelectStmt(v12, v6);
              v13 = *(_DWORD *)(v2 + 128) - 1;
              if (v13 > 2)
              {
LABEL_59:
                if (*(_BYTE *)(v2 + 132))
                  appendStringInfoString((uint64_t)a1, "ALL ");
                if (v11)
                {
                  appendStringInfoChar((uint64_t)a1, 40);
                  deparseSelectStmt(a1, *(_QWORD *)(v2 + 144));
                  appendStringInfoChar((uint64_t)a1, 41);
                }
                else
                {
                  deparseSelectStmt(a1, *(_QWORD *)(v2 + 144));
                }
LABEL_64:
                appendStringInfoChar((uint64_t)a1, 32);
                goto LABEL_65;
              }
LABEL_58:
              appendStringInfoString((uint64_t)a1, (&off_1E264AB30)[v13]);
              goto LABEL_59;
            }
LABEL_13:
            appendStringInfoChar(v12, 40);
            deparseSelectStmt(a1, *(_QWORD *)(v2 + 136));
            appendStringInfoChar((uint64_t)a1, 41);
            v13 = *(_DWORD *)(v2 + 128) - 1;
            if (v13 > 2)
              goto LABEL_59;
            goto LABEL_58;
          }
        }
LABEL_12:
        v11 = 1;
        v12 = (uint64_t)a1;
        if (!v8)
          goto LABEL_57;
        goto LABEL_13;
      }
    }
    if (*(int *)(v10 + 4) > 0)
      goto LABEL_12;
    goto LABEL_10;
  }
  if (v5)
    goto LABEL_65;
  v14 = *(_QWORD *)(v2 + 72);
  if (v14 && *(int *)(v14 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "VALUES ");
    v15 = *(_QWORD *)(v2 + 72);
    if (v15 && *(int *)(v15 + 4) >= 1)
    {
      v16 = 0;
      do
      {
        v17 = (uint64_t *)(*(_QWORD *)(v15 + 16) + 8 * v16);
        appendStringInfoChar((uint64_t)a1, 40);
        v18 = *v17;
        if (*v17 && *(int *)(v18 + 4) >= 1)
        {
          v19 = 0;
          v20 = 8;
          do
          {
            v21 = *(_QWORD *)(v18 + 16);
            deparseExpr(a1, *(_QWORD *)(v21 + 8 * v19));
            v22 = *(int *)(v18 + 4);
            if (v21 + v20)
              v23 = v21 + v20 >= (unint64_t)(*(_QWORD *)(v18 + 16) + 8 * v22);
            else
              v23 = 1;
            if (!v23)
            {
              appendStringInfoString((uint64_t)a1, ", ");
              v22 = *(int *)(v18 + 4);
            }
            ++v19;
            v20 += 8;
          }
          while (v19 < v22);
        }
        appendStringInfoChar((uint64_t)a1, 41);
        if (v17 != (uint64_t *)-8
          && (unint64_t)(v17 + 1) < *(_QWORD *)(*(_QWORD *)(v2 + 72) + 16)
                                         + 8 * *(int *)(*(_QWORD *)(v2 + 72) + 4))
        {
          appendStringInfoString((uint64_t)a1, ", ");
        }
        ++v16;
      }
      while (v16 < *(int *)(v15 + 4));
    }
    goto LABEL_64;
  }
  appendStringInfoString((uint64_t)a1, "SELECT ");
  v25 = *(_QWORD *)(v2 + 24);
  if (v25 && *(int *)(v25 + 4) >= 1)
  {
    if (*(_QWORD *)(v2 + 8))
    {
      appendStringInfoString((uint64_t)a1, "DISTINCT ");
      v26 = *(_QWORD *)(v2 + 8);
      if (v26)
      {
        if (*(int *)(v26 + 4) >= 1 && **(_QWORD **)(v26 + 16))
        {
          appendStringInfoString((uint64_t)a1, "ON (");
          deparseExprList(a1, *(_QWORD *)(v2 + 8));
          appendStringInfoString((uint64_t)a1, ") ");
        }
      }
    }
    deparseTargetList((uint64_t)a1, *(_QWORD *)(v2 + 24));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(_QWORD *)(v2 + 16))
  {
    appendStringInfoString((uint64_t)a1, "INTO ");
    v27 = *(_QWORD *)(v2 + 16);
    v28 = *(char *)(*(_QWORD *)(v27 + 8) + 33);
    if (v28 == 117)
    {
      v29 = "UNLOGGED ";
    }
    else
    {
      if (v28 != 116)
      {
LABEL_120:
        deparseIntoClause(a1, v27);
        appendStringInfoChar((uint64_t)a1, 32);
        goto LABEL_121;
      }
      v29 = "TEMPORARY ";
    }
    appendStringInfoString((uint64_t)a1, v29);
    v27 = *(_QWORD *)(v2 + 16);
    goto LABEL_120;
  }
LABEL_121:
  v63 = *(_QWORD *)(v2 + 32);
  if (v63 && *(int *)(v63 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "FROM ");
    if (*(int *)(v63 + 4) >= 1)
    {
      v70 = 0;
      v71 = 8;
      do
      {
        v72 = *(_QWORD *)(v63 + 16);
        deparseTableRef(a1, *(_QWORD *)(v72 + 8 * v70), v64, v65, v66, v67, v68, v69);
        v73 = *(int *)(v63 + 4);
        if (v72 + v71)
          v74 = v72 + v71 >= (unint64_t)(*(_QWORD *)(v63 + 16) + 8 * v73);
        else
          v74 = 1;
        if (!v74)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v73 = *(int *)(v63 + 4);
        }
        ++v70;
        v71 += 8;
      }
      while (v70 < v73);
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
  v75 = *(_QWORD *)(v2 + 40);
  if (v75)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v75);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  v76 = *(_QWORD *)(v2 + 48);
  if (v76 && *(int *)(v76 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "GROUP BY ");
    v77 = *(_QWORD *)(v2 + 48);
    if (v77 && *(int *)(v77 + 4) >= 1)
    {
      v78 = 0;
      v79 = 8;
      do
      {
        v80 = *(_QWORD *)(v77 + 16);
        v81 = *(_DWORD **)(v80 + 8 * v78);
        if (*v81 == 376)
          deparseGroupingSet(a1, (uint64_t)v81);
        else
          deparseExpr(a1, v81);
        v82 = *(int *)(v77 + 4);
        if (v80 + v79)
          v83 = v80 + v79 >= (unint64_t)(*(_QWORD *)(v77 + 16) + 8 * v82);
        else
          v83 = 1;
        if (!v83)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v82 = *(int *)(v77 + 4);
        }
        ++v78;
        v79 += 8;
      }
      while (v78 < v82);
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(_QWORD *)(v2 + 56))
  {
    appendStringInfoString((uint64_t)a1, "HAVING ");
    deparseExpr(a1, *(_QWORD *)(v2 + 56));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(_QWORD *)(v2 + 64))
  {
    appendStringInfoString((uint64_t)a1, "WINDOW ");
    v84 = *(_QWORD *)(v2 + 64);
    if (v84 && *(int *)(v84 + 4) >= 1)
    {
      v85 = 0;
      v86 = 8;
      do
      {
        v87 = *(_QWORD *)(v84 + 16);
        v88 = *(_QWORD *)(v87 + 8 * v85);
        appendStringInfoString((uint64_t)a1, *(char **)(v88 + 8));
        appendStringInfoString((uint64_t)a1, " AS ");
        deparseWindowDef((uint64_t)a1, v88);
        if (v87 + v86)
          v89 = v87 + v86 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(v2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(v2 + 64) + 4));
        else
          v89 = 1;
        if (!v89)
          appendStringInfoString((uint64_t)a1, ", ");
        ++v85;
        v86 += 8;
      }
      while (v85 < *(int *)(v84 + 4));
    }
    goto LABEL_64;
  }
LABEL_65:
  result = deparseOptSortClause((uint64_t)a1, *(_QWORD *)(v2 + 80));
  if (!*(_QWORD *)(v2 + 96))
    goto LABEL_166;
  v39 = *(_DWORD *)(v2 + 104);
  if (v39 == 1)
  {
    v40 = "LIMIT ";
    goto LABEL_70;
  }
  if (v39 == 2)
  {
    v40 = "FETCH FIRST ";
LABEL_70:
    appendStringInfoString((uint64_t)a1, v40);
  }
  v41 = *(_QWORD *)(v2 + 96);
  switch(*(_DWORD *)v41)
  {
    case 0x15A:
      appendStringInfoChar((uint64_t)a1, 40);
      deparseAExpr(a1, v41);
LABEL_115:
      appendStringInfoChar((uint64_t)a1, 41);
      break;
    case 0x15B:
      v48 = **(_QWORD **)(*(_QWORD *)(v41 + 8) + 16);
      if (*(_DWORD *)v48 == 223)
      {
        v90 = quote_identifier(*(_BYTE **)(v48 + 8));
        appendStringInfoString((uint64_t)a1, v90);
      }
      else if (*(_DWORD *)v48 == 351)
      {
        appendStringInfoChar((uint64_t)a1, 42);
      }
      deparseOptIndirection((uint64_t)a1, *(_QWORD *)(v41 + 8), 1);
      break;
    case 0x15C:
      if (*(_DWORD *)(v41 + 4))
        appendStringInfo((uint64_t)a1, "$%d", v33, v34, v35, v36, v37, v38, *(unsigned int *)(v41 + 4));
      else
        appendStringInfoChar((uint64_t)a1, 63);
      break;
    case 0x15D:
      v50 = *(_DWORD *)(v41 + 8);
      v49 = v41 + 8;
      if (v50 == 225)
        appendStringInfoString((uint64_t)a1, "ALL");
      else
        deparseValue(a1, v49, 11, v34, v35, v36, v37, v38);
      break;
    case 0x15E:
      deparseFuncCall((uint64_t)a1, *(_QWORD *)(v2 + 96));
      break;
    case 0x15F:
    case 0x160:
    case 0x163:
    case 0x164:
LABEL_203:
      deparseSelectStmt_cold_1(*(_DWORD **)(v2 + 96));
    case 0x161:
      deparseAIndirection((uint64_t)a1, *(_QWORD *)(v2 + 96));
      break;
    case 0x162:
      appendStringInfoString((uint64_t)a1, "ARRAY[");
      v51 = *(_QWORD *)(v41 + 8);
      if (v51 && *(int *)(v51 + 4) >= 1)
      {
        v52 = 0;
        v53 = 8;
        do
        {
          v54 = *(_QWORD *)(v51 + 16);
          deparseExpr(a1, *(_QWORD *)(v54 + 8 * v52));
          v55 = *(int *)(v51 + 4);
          if (v54 + v53)
            v56 = v54 + v53 >= (unint64_t)(*(_QWORD *)(v51 + 16) + 8 * v55);
          else
            v56 = 1;
          if (!v56)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            v55 = *(int *)(v51 + 4);
          }
          ++v52;
          v53 += 8;
        }
        while (v52 < v55);
      }
      appendStringInfoChar((uint64_t)a1, 93);
      break;
    case 0x165:
      deparseTypeCast(a1, *(_QWORD *)(v2 + 96));
      break;
    default:
      switch(*(_DWORD *)v41)
      {
        case 0x6E:
          appendStringInfoString((uint64_t)a1, "GROUPING(");
          v42 = *(_QWORD *)(v41 + 8);
          if (v42 && *(int *)(v42 + 4) >= 1)
          {
            v43 = 0;
            v44 = 8;
            do
            {
              v45 = *(_QWORD *)(v42 + 16);
              deparseExpr(a1, *(_QWORD *)(v45 + 8 * v43));
              v46 = *(int *)(v42 + 4);
              if (v45 + v44)
                v47 = v45 + v44 >= (unint64_t)(*(_QWORD *)(v42 + 16) + 8 * v46);
              else
                v47 = 1;
              if (!v47)
              {
                appendStringInfoString((uint64_t)a1, ", ");
                v46 = *(int *)(v42 + 4);
              }
              ++v43;
              v44 += 8;
            }
            while (v43 < v46);
          }
          goto LABEL_115;
        case 0x78:
          deparseSubLink(a1, *(_QWORD *)(v2 + 96));
          goto LABEL_164;
        case 0x82:
          deparseCaseExpr((uint64_t)a1, *(_QWORD **)(v2 + 96));
          goto LABEL_164;
        case 0x86:
          if (!*(_DWORD *)(v41 + 20))
            appendStringInfoString((uint64_t)a1, "ROW");
          appendStringInfoString((uint64_t)a1, "(");
          v57 = *(_QWORD *)(v41 + 8);
          if (v57 && *(int *)(v57 + 4) >= 1)
          {
            v58 = 0;
            v59 = 8;
            do
            {
              v60 = *(_QWORD *)(v57 + 16);
              deparseExpr(a1, *(_QWORD *)(v60 + 8 * v58));
              v61 = *(int *)(v57 + 4);
              if (v60 + v59)
                v62 = v60 + v59 >= (unint64_t)(*(_QWORD *)(v57 + 16) + 8 * v61);
              else
                v62 = 1;
              if (!v62)
              {
                appendStringInfoString((uint64_t)a1, ", ");
                v61 = *(int *)(v57 + 4);
              }
              ++v58;
              v59 += 8;
            }
            while (v58 < v61);
          }
          goto LABEL_115;
        default:
          goto LABEL_203;
      }
  }
LABEL_164:
  result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(_DWORD *)(v2 + 104) == 2)
    result = (uint64_t)appendStringInfoString((uint64_t)a1, "ROWS WITH TIES ");
LABEL_166:
  if (*(_QWORD *)(v2 + 88))
  {
    appendStringInfoString((uint64_t)a1, "OFFSET ");
    deparseExpr(a1, *(_QWORD *)(v2 + 88));
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v91 = *(_QWORD *)(v2 + 112);
  if (v91 && *(int *)(v91 + 4) >= 1)
  {
    v92 = 0;
    while (1)
    {
      v93 = v2;
      v94 = *(_QWORD *)(v91 + 16) + 8 * v92;
      v95 = *(_QWORD *)v94;
      v96 = *(_DWORD *)(*(_QWORD *)v94 + 16) - 1;
      if (v96 <= 3)
        appendStringInfoString((uint64_t)a1, (&off_1E264AB48)[v96]);
      v97 = *(_QWORD *)(v95 + 8);
      if (v97)
      {
        if (*(int *)(v97 + 4) >= 1)
        {
          appendStringInfoString((uint64_t)a1, "OF ");
          v98 = *(_QWORD *)(v95 + 8);
          if (v98)
          {
            if (*(int *)(v98 + 4) >= 1)
            {
              v99 = 0;
              v100 = 8;
              do
              {
                v101 = *(_QWORD *)(v98 + 16);
                deparseRangeVar((uint64_t)a1, *(_QWORD *)(v101 + 8 * v99), 0);
                v102 = *(int *)(v98 + 4);
                if (v101 + v100)
                  v103 = v101 + v100 >= (unint64_t)(*(_QWORD *)(v98 + 16) + 8 * v102);
                else
                  v103 = 1;
                if (!v103)
                {
                  appendStringInfoString((uint64_t)a1, ", ");
                  v102 = *(int *)(v98 + 4);
                }
                ++v99;
                v100 += 8;
              }
              while (v99 < v102);
            }
          }
        }
      }
      v104 = *(_DWORD *)(v95 + 20);
      if (v104 == 2)
      {
        v105 = "NOWAIT";
        v2 = v93;
      }
      else
      {
        v2 = v93;
        if (v104 != 1)
          goto LABEL_190;
        v105 = "SKIP LOCKED";
      }
      appendStringInfoString((uint64_t)a1, v105);
LABEL_190:
      v106 = a1[2];
      v107 = __OFSUB__(v106, 1);
      v108 = (v106 - 1);
      if ((int)v108 < 0 == v107)
      {
        v109 = *(_QWORD *)a1;
        if (*(_BYTE *)(*(_QWORD *)a1 + v108) == 32)
        {
          a1[2] = v108;
          *(_BYTE *)(v109 + v108) = 0;
        }
      }
      if (v94 != -8
        && v94 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v2 + 112) + 16)
                                      + 8 * *(int *)(*(_QWORD *)(v2 + 112) + 4)))
      {
        appendStringInfoString((uint64_t)a1, " ");
      }
      if (++v92 >= *(int *)(v91 + 4))
      {
        result = appendStringInfoChar((uint64_t)a1, 32);
        break;
      }
    }
  }
  v111 = a1[2];
  v107 = __OFSUB__(v111, 1);
  v112 = (v111 - 1);
  if ((int)v112 < 0 == v107)
  {
    v113 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v112) == 32)
    {
      a1[2] = v112;
      *(_BYTE *)(v113 + v112) = 0;
    }
  }
  return result;
}

uint64_t deparseUpdateStmt(_DWORD *a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;

  if (a2[6])
  {
    deparseWithClause(a1);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "UPDATE ");
  deparseRangeVar((uint64_t)a1, a2[1], 0);
  result = appendStringInfoChar((uint64_t)a1, 32);
  v5 = a2[2];
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "SET ");
    deparseSetClauseList((uint64_t)a1, a2[2]);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v6 = a2[4];
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "FROM ");
    if (*(int *)(v6 + 4) >= 1)
    {
      v13 = 0;
      v14 = 8;
      do
      {
        v15 = *(_QWORD *)(v6 + 16);
        deparseTableRef(a1, *(_QWORD *)(v15 + 8 * v13), v7, v8, v9, v10, v11, v12);
        v16 = *(int *)(v6 + 4);
        if (v15 + v14)
          v17 = v15 + v14 >= (unint64_t)(*(_QWORD *)(v6 + 16) + 8 * v16);
        else
          v17 = 1;
        if (!v17)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v16 = *(int *)(v6 + 4);
        }
        ++v13;
        v14 += 8;
      }
      while (v13 < v16);
    }
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v18 = a2[3];
  if (v18)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v18);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v19 = a2[5];
  if (v19 && *(int *)(v19 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "RETURNING ");
    result = deparseTargetList((uint64_t)a1, a2[5]);
  }
  v20 = a1[2];
  v21 = __OFSUB__(v20, 1);
  v22 = (v20 - 1);
  if ((int)v22 < 0 == v21)
  {
    v23 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v22) == 32)
    {
      a1[2] = v22;
      *(_BYTE *)(v23 + v22) = 0;
    }
  }
  return result;
}

uint64_t deparseVariableSetStmt(uint64_t result, uint64_t a2)
{
  void *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  int v17;
  uint64_t v18;
  BOOL v19;
  char *v20;
  char *v21;
  char *v22;
  const char *v23;
  char *v24;

  v3 = (void *)result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      appendStringInfoString(result, "SET ");
      if (*(_BYTE *)(a2 + 24))
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      v4 = quote_identifier(*(_BYTE **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v4);
      result = (uint64_t)appendStringInfoString((uint64_t)v3, " TO ");
      v11 = *(_QWORD *)(a2 + 16);
      if (v11 && *(int *)(v11 + 4) >= 1)
      {
        v12 = 0;
        v13 = 8;
        do
        {
          v14 = *(_QWORD *)(v11 + 16);
          v15 = *(_QWORD *)(v14 + 8 * v12);
          if (*(_DWORD *)v15 == 349)
          {
            v17 = *(_DWORD *)(v15 + 8);
            switch(v17)
            {
              case 223:
                result = (uint64_t)deparseOptBooleanOrString(v3, *(char **)(v15 + 16));
                break;
              case 222:
                result = (uint64_t)appendStringInfoString((uint64_t)v3, *(char **)(v15 + 16));
                break;
              case 221:
                result = appendStringInfo((uint64_t)v3, "%d", v5, v6, v7, v8, v9, v10, *(unsigned int *)(v15 + 16));
                break;
            }
          }
          else if (*(_DWORD *)v15 == 348)
          {
            v16 = *(unsigned int *)(v15 + 4);
            if ((_DWORD)v16)
              result = appendStringInfo((uint64_t)v3, "$%d", v5, v6, v7, v8, v9, v10, v16);
            else
              result = appendStringInfoChar((uint64_t)v3, 63);
          }
          v18 = *(int *)(v11 + 4);
          if (v14 + v13)
            v19 = v14 + v13 >= (unint64_t)(*(_QWORD *)(v11 + 16) + 8 * v18);
          else
            v19 = 1;
          if (!v19)
          {
            result = (uint64_t)appendStringInfoString((uint64_t)v3, ", ");
            v18 = *(int *)(v11 + 4);
          }
          ++v12;
          v13 += 8;
        }
        while (v12 < v18);
      }
      return result;
    case 1:
      appendStringInfoString(result, "SET ");
      if (*(_BYTE *)(a2 + 24))
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      v20 = quote_identifier(*(_BYTE **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v20);
      v21 = " TO DEFAULT";
      return (uint64_t)appendStringInfoString((uint64_t)v3, v21);
    case 2:
      appendStringInfoString(result, "SET ");
      if (*(_BYTE *)(a2 + 24))
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      v22 = quote_identifier(*(_BYTE **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v22);
      v21 = " FROM CURRENT";
      return (uint64_t)appendStringInfoString((uint64_t)v3, v21);
    case 3:
      appendStringInfoString(result, "SET ");
      if (*(_BYTE *)(a2 + 24))
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      v23 = *(const char **)(a2 + 8);
      if (!strcmp(v23, "TRANSACTION"))
      {
        v24 = "TRANSACTION ";
LABEL_41:
        appendStringInfoString((uint64_t)v3, v24);
        return deparseTransactionModeList((uint64_t)v3, *(_QWORD *)(a2 + 16));
      }
      if (!strcmp(v23, "SESSION CHARACTERISTICS"))
      {
        v24 = "SESSION CHARACTERISTICS AS TRANSACTION ";
        goto LABEL_41;
      }
      result = strcmp(v23, "TRANSACTION SNAPSHOT");
      if (!(_DWORD)result)
      {
        appendStringInfoString((uint64_t)v3, "TRANSACTION SNAPSHOT ");
        return deparseStringLiteral((uint64_t)v3, *(char **)(**(_QWORD **)(*(_QWORD *)(a2 + 16) + 16) + 16));
      }
      return result;
    case 4:
      appendStringInfoString(result, "RESET ");
      v21 = quote_identifier(*(_BYTE **)(a2 + 8));
      return (uint64_t)appendStringInfoString((uint64_t)v3, v21);
    case 5:
      v21 = "RESET ALL";
      return (uint64_t)appendStringInfoString((uint64_t)v3, v21);
    default:
      return result;
  }
}

uint64_t deparseViewStmt(_DWORD *a1, uint64_t a2)
{
  int v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t result;
  int v16;
  char *v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;

  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (*(_BYTE *)(a2 + 32))
    appendStringInfoString((uint64_t)a1, "OR REPLACE ");
  v4 = *(char *)(*(_QWORD *)(a2 + 8) + 33);
  if (v4 == 117)
  {
    v5 = "UNLOGGED ";
    goto LABEL_7;
  }
  if (v4 == 116)
  {
    v5 = "TEMPORARY ";
LABEL_7:
    appendStringInfoString((uint64_t)a1, v5);
  }
  appendStringInfoString((uint64_t)a1, "VIEW ");
  deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), 0);
  appendStringInfoChar((uint64_t)a1, 32);
  v6 = *(_QWORD *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    v7 = *(_QWORD *)(a2 + 16);
    if (v7 && *(int *)(v7 + 4) >= 1)
    {
      v8 = 0;
      v9 = 8;
      do
      {
        v10 = *(_QWORD *)(v7 + 16);
        v11 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v10 + 8 * v8) + 8));
        appendStringInfoString((uint64_t)a1, v11);
        v12 = *(int *)(v7 + 4);
        if (v10 + v9)
          v13 = v10 + v9 >= (unint64_t)(*(_QWORD *)(v7 + 16) + 8 * v12);
        else
          v13 = 1;
        if (!v13)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v12 = *(int *)(v7 + 4);
        }
        ++v8;
        v9 += 8;
      }
      while (v8 < v12);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  v14 = *(_QWORD *)(a2 + 40);
  if (v14 && *(int *)(v14 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v14);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "AS ");
  deparseSelectStmt(a1, *(_QWORD *)(a2 + 24));
  result = appendStringInfoChar((uint64_t)a1, 32);
  v16 = *(_DWORD *)(a2 + 48);
  if (v16 == 1)
  {
    v17 = "WITH LOCAL CHECK OPTION ";
  }
  else
  {
    if (v16 != 2)
      goto LABEL_28;
    v17 = "WITH CHECK OPTION ";
  }
  result = (uint64_t)appendStringInfoString((uint64_t)a1, v17);
LABEL_28:
  v18 = a1[2];
  v19 = __OFSUB__(v18, 1);
  v20 = (v18 - 1);
  if ((int)v20 < 0 == v19)
  {
    v21 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v20) == 32)
    {
      a1[2] = v20;
      *(_BYTE *)(v21 + v20) = 0;
    }
  }
  return result;
}

uint64_t deparseAnyName(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  BOOL v9;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v6 + 8 * v4) + 8));
      result = (uint64_t)appendStringInfoString(v3, v7);
      v8 = *(int *)(a2 + 4);
      if (v6 + v5)
        v9 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v8);
      else
        v9 = 1;
      if (!v9)
      {
        result = appendStringInfoChar(v3, 46);
        v8 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v8);
  }
  return result;
}

unint64_t deparseCreatedbOptList(unint64_t result, uint64_t a2)
{
  void *v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  _BYTE *v8;
  char *v9;
  unsigned __int8 v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = (void *)result;
    for (i = 0; i < *(int *)(a2 + 4); ++i)
    {
      v5 = *(_QWORD *)(a2 + 16) + 8 * i;
      v6 = *(_QWORD *)v5;
      v7 = *(const char **)(*(_QWORD *)v5 + 16);
      if (!strcmp(v7, "connection_limit"))
      {
        appendStringInfoString((uint64_t)v3, "CONNECTION LIMIT");
        result = appendStringInfoChar((uint64_t)v3, 32);
        v19 = *(_QWORD *)(v6 + 24);
        if (!v19)
          goto LABEL_15;
      }
      else
      {
        v8 = pstrdup(v7);
        v9 = v8;
        v10 = *v8;
        if (*v8)
        {
          v11 = v8 + 1;
          do
          {
            *(v11 - 1) = pg_toupper(v10);
            v12 = *v11++;
            v10 = v12;
          }
          while (v12);
        }
        appendStringInfoString((uint64_t)v3, v9);
        pfree((uint64_t)v9);
        result = appendStringInfoChar((uint64_t)v3, 32);
        v19 = *(_QWORD *)(v6 + 24);
        if (!v19)
        {
LABEL_15:
          result = (unint64_t)appendStringInfoString((uint64_t)v3, "DEFAULT");
LABEL_16:
          v20 = v5 + 8;
          if (v5 != -8)
            goto LABEL_17;
          continue;
        }
      }
      if (*(_DWORD *)v19 != 223)
      {
        if (*(_DWORD *)v19 == 221)
        {
          result = appendStringInfo((uint64_t)v3, "%d", v13, v14, v15, v16, v17, v18, *(unsigned int *)(v19 + 8));
          v20 = v5 + 8;
          if (v5 != -8)
            goto LABEL_17;
          continue;
        }
        goto LABEL_16;
      }
      result = (unint64_t)deparseOptBooleanOrString(v3, *(char **)(v19 + 8));
      v20 = v5 + 8;
      if (v5 != -8)
      {
LABEL_17:
        if (v20 < *(_QWORD *)(a2 + 16) + 8 * *(int *)(a2 + 4))
          result = appendStringInfoChar((uint64_t)v3, 32);
      }
    }
  }
  return result;
}

void *deparseOptBooleanOrString(void *result, char *__s1)
{
  uint64_t v3;
  size_t v4;
  char *v5;

  if (__s1)
  {
    v3 = (uint64_t)result;
    if (!strcmp(__s1, "true"))
    {
      return appendStringInfoString(v3, "TRUE");
    }
    else if (!strcmp(__s1, "false"))
    {
      return appendStringInfoString(v3, "FALSE");
    }
    else if (!strcmp(__s1, "on"))
    {
      return appendStringInfoString(v3, "ON");
    }
    else if (!strcmp(__s1, "off"))
    {
      return appendStringInfoString(v3, "OFF");
    }
    else
    {
      v4 = strlen(__s1);
      if (v4)
      {
        if (v4 < 0x40)
        {
          v5 = quote_identifier(__s1);
          return appendStringInfoString(v3, v5);
        }
        else
        {
          return (void *)deparseStringLiteral(v3, __s1);
        }
      }
      else
      {
        return appendStringInfoString(v3, "''");
      }
    }
  }
  return result;
}

uint64_t deparseStringLiteral(uint64_t a1, char *__s)
{
  char *v2;
  int v4;
  char v5;

  v2 = __s;
  if (strchr(__s, 92))
    appendStringInfoChar(a1, 69);
  appendStringInfoChar(a1, 39);
  while (1)
  {
    v4 = *v2;
    v5 = *v2;
    if (v4 == 39 || v4 == 92)
    {
      appendStringInfoChar(a1, v4);
      goto LABEL_5;
    }
    if (!*v2)
      return appendStringInfoChar(a1, 39);
LABEL_5:
    appendStringInfoChar(a1, v5);
    ++v2;
  }
}

void *deparseRoleList(void *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = (uint64_t)result;
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v6 + 8 * v4);
      switch(*(_DWORD *)(v7 + 4))
      {
        case 0:
          v8 = quote_identifier(*(_BYTE **)(v7 + 8));
          v9 = v3;
          goto LABEL_10;
        case 1:
          v9 = v3;
          v8 = "CURRENT_USER";
          goto LABEL_10;
        case 2:
          v9 = v3;
          v8 = "SESSION_USER";
          goto LABEL_10;
        case 3:
          v9 = v3;
          v8 = "public";
LABEL_10:
          result = appendStringInfoString(v9, v8);
          break;
        default:
          break;
      }
      v10 = *(int *)(a2 + 4);
      if (v6 + v5)
        v11 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v10);
      else
        v11 = 1;
      if (!v11)
      {
        result = appendStringInfoString(v3, ", ");
        v10 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v10);
  }
  return result;
}

void *deparseExpr(void *result, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void *v9;
  int v10;
  unsigned int v11;
  int v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  int v39;
  char *v40;
  uint64_t v41;
  int v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  int v51;
  char *v52;
  uint64_t v53;
  char v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  BOOL v66;
  char *v67;

  v8 = (uint64_t)a2;
  v9 = result;
  v10 = *a2;
  v11 = *a2 - 110;
  while (2)
  {
    switch(v11)
    {
      case 0u:
        appendStringInfoString((uint64_t)v9, "GROUPING(");
        v21 = *(_QWORD *)(v8 + 8);
        if (v21 && *(int *)(v21 + 4) >= 1)
        {
          v22 = 0;
          v23 = 8;
          do
          {
            v24 = *(_QWORD *)(v21 + 16);
            deparseExpr(v9, *(_QWORD *)(v24 + 8 * v22));
            v25 = *(int *)(v21 + 4);
            if (v24 + v23)
              v26 = v24 + v23 >= (unint64_t)(*(_QWORD *)(v21 + 16) + 8 * v25);
            else
              v26 = 1;
            if (!v26)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v25 = *(int *)(v21 + 4);
            }
            ++v22;
            v23 += 8;
          }
          while (v22 < v25);
        }
        goto LABEL_124;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x19u:
      case 0x20u:
      case 0x21u:
LABEL_138:
        deparseExpr_cold_1((_DWORD *)v8);
      case 9u:
        v12 = *(_DWORD *)(v8 + 4);
        if (v12 != 2)
        {
          if (v12 == 1)
          {
            v55 = *(_QWORD *)(v8 + 8);
            if (v55 && *(int *)(v55 + 4) >= 1)
            {
              v56 = 0;
              v57 = 0;
              do
              {
                v58 = *(_QWORD *)(v55 + 16);
                v59 = *(_DWORD **)(v58 + v56);
                if (*v59 == 119 && v59[1] <= 1u)
                {
                  appendStringInfoChar((uint64_t)v9, 40);
                  deparseExpr(v9, *(_QWORD *)(v58 + v56));
                  result = (void *)appendStringInfoChar((uint64_t)v9, 41);
                }
                else
                {
                  result = (void *)deparseExpr(v9, v59);
                }
                if (v58 + v56 != -8
                  && v58 + v56 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 16)
                                                      + 8 * *(int *)(*(_QWORD *)(v8 + 8) + 4)))
                {
                  result = appendStringInfoString((uint64_t)v9, " OR ");
                }
                ++v57;
                v56 += 8;
              }
              while (v57 < *(int *)(v55 + 4));
            }
          }
          else if (!v12)
          {
            v15 = *(_QWORD *)(v8 + 8);
            if (v15)
            {
              if (*(int *)(v15 + 4) >= 1)
              {
                v16 = 0;
                v17 = 0;
                do
                {
                  v18 = *(_QWORD *)(v15 + 16);
                  v19 = *(_DWORD **)(v18 + v16);
                  if (*v19 == 119 && v19[1] <= 1u)
                  {
                    appendStringInfoChar((uint64_t)v9, 40);
                    deparseExpr(v9, *(_QWORD *)(v18 + v16));
                    result = (void *)appendStringInfoChar((uint64_t)v9, 41);
                  }
                  else
                  {
                    result = (void *)deparseExpr(v9, v19);
                  }
                  if (v18 + v16 != -8
                    && v18 + v16 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 16)
                                                        + 8 * *(int *)(*(_QWORD *)(v8 + 8) + 4)))
                  {
                    result = appendStringInfoString((uint64_t)v9, " AND ");
                  }
                  ++v17;
                  v16 += 8;
                }
                while (v17 < *(int *)(v15 + 4));
              }
            }
          }
          return result;
        }
        v13 = **(_DWORD ***)(*(_QWORD *)(v8 + 8) + 16);
        if (*v13 != 119)
        {
          result = appendStringInfoString((uint64_t)v9, "NOT ");
LABEL_9:
          v8 = **(_QWORD **)(*(_QWORD *)(v8 + 8) + 16);
          v10 = *(_DWORD *)v8;
          v11 = *(_DWORD *)v8 - 110;
          if (v11 > 0x23)
          {
LABEL_10:
            switch(v10)
            {
              case 346:
                return (void *)deparseAExpr((uint64_t)v9, v8);
              case 347:
                v44 = **(_QWORD **)(*(_QWORD *)(v8 + 8) + 16);
                if (*(_DWORD *)v44 == 223)
                {
                  v67 = quote_identifier(*(_BYTE **)(v44 + 8));
                  appendStringInfoString((uint64_t)v9, v67);
                }
                else if (*(_DWORD *)v44 == 351)
                {
                  appendStringInfoChar((uint64_t)v9, 42);
                }
                return (void *)deparseOptIndirection((uint64_t)v9, *(_QWORD *)(v8 + 8), 1);
              case 348:
                if (*(_DWORD *)(v8 + 4))
                  return (void *)appendStringInfo((uint64_t)v9, "$%d", a3, a4, a5, a6, a7, a8, *(unsigned int *)(v8 + 4));
                v53 = (uint64_t)v9;
                v54 = 63;
                return (void *)appendStringInfoChar(v53, v54);
              case 349:
                return deparseValue(v9, v8 + 8, 11, a4, a5, a6, a7, a8);
              case 350:
                return (void *)deparseFuncCall((uint64_t)v9, v8);
              case 353:
                return (void *)deparseAIndirection((uint64_t)v9, v8);
              case 354:
                appendStringInfoString((uint64_t)v9, "ARRAY[");
                v45 = *(_QWORD *)(v8 + 8);
                if (v45 && *(int *)(v45 + 4) >= 1)
                {
                  v46 = 0;
                  v47 = 8;
                  do
                  {
                    v48 = *(_QWORD *)(v45 + 16);
                    deparseExpr(v9, *(_QWORD *)(v48 + 8 * v46));
                    v49 = *(int *)(v45 + 4);
                    if (v48 + v47)
                      v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(v45 + 16) + 8 * v49);
                    else
                      v50 = 1;
                    if (!v50)
                    {
                      appendStringInfoString((uint64_t)v9, ", ");
                      v49 = *(int *)(v45 + 4);
                    }
                    ++v46;
                    v47 += 8;
                  }
                  while (v46 < v49);
                }
                v53 = (uint64_t)v9;
                v54 = 93;
                return (void *)appendStringInfoChar(v53, v54);
              case 357:
                return deparseTypeCast(v9, v8);
              case 358:
                return (void *)deparseCollateClause((uint64_t)v9, v8);
              case 385:
                appendStringInfoString((uint64_t)v9, "xmlserialize(");
                v51 = *(_DWORD *)(v8 + 4);
                if (v51)
                {
                  if (v51 != 1)
                    goto LABEL_131;
                  v52 = "content ";
                }
                else
                {
                  v52 = "document ";
                }
                appendStringInfoString((uint64_t)v9, v52);
LABEL_131:
                deparseExpr(v9, *(_QWORD *)(v8 + 8));
                appendStringInfoString((uint64_t)v9, " AS ");
                deparseTypeName(v9, *(_QWORD *)(v8 + 16));
                v43 = ")";
                break;
              default:
                goto LABEL_138;
            }
            return appendStringInfoString((uint64_t)v9, v43);
          }
          continue;
        }
        v14 = v13[1];
        if (v14)
        {
          result = appendStringInfoString((uint64_t)v9, "NOT ");
          if (v14 == 1)
            goto LABEL_111;
          goto LABEL_9;
        }
        appendStringInfoString((uint64_t)v9, "NOT ");
LABEL_111:
        appendStringInfoChar((uint64_t)v9, 40);
        deparseExpr(v9, **(_QWORD **)(*(_QWORD *)(v8 + 8) + 16));
LABEL_124:
        v53 = (uint64_t)v9;
        v54 = 41;
        return (void *)appendStringInfoChar(v53, v54);
      case 0xAu:
        return (void *)deparseSubLink((uint64_t)v9, v8);
      case 0x14u:
        return deparseCaseExpr((uint64_t)v9, (_QWORD *)v8);
      case 0x18u:
        if (!*(_DWORD *)(v8 + 20))
          appendStringInfoString((uint64_t)v9, "ROW");
        appendStringInfoString((uint64_t)v9, "(");
        v27 = *(_QWORD *)(v8 + 8);
        if (v27 && *(int *)(v27 + 4) >= 1)
        {
          v28 = 0;
          v29 = 8;
          do
          {
            v30 = *(_QWORD *)(v27 + 16);
            deparseExpr(v9, *(_QWORD *)(v30 + 8 * v28));
            v31 = *(int *)(v27 + 4);
            if (v30 + v29)
              v32 = v30 + v29 >= (unint64_t)(*(_QWORD *)(v27 + 16) + 8 * v31);
            else
              v32 = 1;
            if (!v32)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v31 = *(int *)(v27 + 4);
            }
            ++v28;
            v29 += 8;
          }
          while (v28 < v31);
        }
        goto LABEL_124;
      case 0x1Au:
        appendStringInfoString((uint64_t)v9, "COALESCE(");
        v33 = *(_QWORD *)(v8 + 16);
        if (v33 && *(int *)(v33 + 4) >= 1)
        {
          v34 = 0;
          v35 = 8;
          do
          {
            v36 = *(_QWORD *)(v33 + 16);
            deparseExpr(v9, *(_QWORD *)(v36 + 8 * v34));
            v37 = *(int *)(v33 + 4);
            if (v36 + v35)
              v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(v33 + 16) + 8 * v37);
            else
              v38 = 1;
            if (!v38)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v37 = *(int *)(v33 + 4);
            }
            ++v34;
            v35 += 8;
          }
          while (v34 < v37);
        }
        goto LABEL_124;
      case 0x1Bu:
        v39 = *(_DWORD *)(v8 + 16);
        if (v39)
        {
          if (v39 != 1)
            goto LABEL_115;
          v40 = "LEAST(";
        }
        else
        {
          v40 = "GREATEST(";
        }
        appendStringInfoString((uint64_t)v9, v40);
LABEL_115:
        v61 = *(_QWORD *)(v8 + 24);
        if (v61 && *(int *)(v61 + 4) >= 1)
        {
          v62 = 0;
          v63 = 8;
          do
          {
            v64 = *(_QWORD *)(v61 + 16);
            deparseExpr(v9, *(_QWORD *)(v64 + 8 * v62));
            v65 = *(int *)(v61 + 4);
            if (v64 + v63)
              v66 = v64 + v63 >= (unint64_t)(*(_QWORD *)(v61 + 16) + 8 * v65);
            else
              v66 = 1;
            if (!v66)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v65 = *(int *)(v61 + 4);
            }
            ++v62;
            v63 += 8;
          }
          while (v62 < v65);
        }
        goto LABEL_124;
      case 0x1Cu:
        v41 = *(int *)(v8 + 4);
        if (v41 <= 0xE)
          result = appendStringInfoString((uint64_t)v9, (&off_1E264AB80)[v41]);
        if (*(_DWORD *)(v8 + 12) != -1)
          return (void *)appendStringInfo((uint64_t)v9, "(%d)", a3, a4, a5, a6, a7, a8, *(unsigned int *)(v8 + 12));
        return result;
      case 0x1Du:
        return deparseXmlExpr(v9, v8);
      case 0x1Eu:
        result = (void *)deparseExpr(v9, *(_QWORD *)(v8 + 8));
        v42 = *(_DWORD *)(v8 + 16);
        if (v42 == 1)
        {
          v43 = " IS NOT NULL";
        }
        else
        {
          if (v42)
            return result;
          v43 = " IS NULL";
        }
        return appendStringInfoString((uint64_t)v9, v43);
      case 0x1Fu:
        result = (void *)deparseExpr(v9, *(_QWORD *)(v8 + 8));
        switch(*(_DWORD *)(v8 + 16))
        {
          case 0:
            v43 = " IS TRUE";
            return appendStringInfoString((uint64_t)v9, v43);
          case 1:
            v43 = " IS NOT TRUE";
            return appendStringInfoString((uint64_t)v9, v43);
          case 2:
            v43 = " IS FALSE";
            return appendStringInfoString((uint64_t)v9, v43);
          case 3:
            v43 = " IS NOT FALSE";
            return appendStringInfoString((uint64_t)v9, v43);
          case 4:
            v43 = " IS UNKNOWN";
            return appendStringInfoString((uint64_t)v9, v43);
          case 5:
            v43 = " IS NOT UNKNOWN";
            return appendStringInfoString((uint64_t)v9, v43);
          default:
            return result;
        }
        return result;
      case 0x22u:
        v43 = "DEFAULT";
        return appendStringInfoString((uint64_t)v9, v43);
      case 0x23u:
        appendStringInfoString((uint64_t)v9, "CURRENT OF ");
        v43 = quote_identifier(*(_BYTE **)(v8 + 8));
        return appendStringInfoString((uint64_t)v9, v43);
      default:
        goto LABEL_10;
    }
  }
}

_BYTE *deparseConstraint(_DWORD *a1, uint64_t a2)
{
  char *v4;
  int v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  char *v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  BOOL v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  BOOL v59;
  _BYTE *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _BYTE *result;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  BOOL v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfoString((uint64_t)a1, "CONSTRAINT ");
    appendStringInfoString((uint64_t)a1, *(char **)(a2 + 8));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      v4 = "NULL ";
      goto LABEL_41;
    case 1:
      v4 = "NOT NULL ";
      goto LABEL_41;
    case 2:
      appendStringInfoString((uint64_t)a1, "DEFAULT ");
      deparseExpr(a1, *(_QWORD *)(a2 + 32));
      goto LABEL_42;
    case 3:
      appendStringInfoString((uint64_t)a1, "GENERATED ");
      v5 = *(char *)(a2 + 48);
      if (v5 == 97)
      {
        v6 = "ALWAYS ";
      }
      else
      {
        if (v5 != 100)
          goto LABEL_121;
        v6 = "BY DEFAULT ";
      }
      appendStringInfoString((uint64_t)a1, v6);
LABEL_121:
      appendStringInfoString((uint64_t)a1, "AS IDENTITY ");
      v80 = *(_QWORD *)(a2 + 80);
      if (v80 && *(int *)(v80 + 4) >= 1)
      {
        appendStringInfoChar((uint64_t)a1, 40);
        if (*(int *)(v80 + 4) >= 1)
        {
          v81 = 0;
          do
          {
            deparseSeqOptElem(a1, *(_QWORD *)(*(_QWORD *)(v80 + 16) + 8 * v81));
            appendStringInfoChar((uint64_t)a1, 32);
            ++v81;
          }
          while (v81 < *(int *)(v80 + 4));
        }
        appendStringInfoChar((uint64_t)a1, 41);
      }
      goto LABEL_42;
    case 4:
      appendStringInfoString((uint64_t)a1, "GENERATED ALWAYS AS (");
      deparseExpr(a1, *(_QWORD *)(a2 + 32));
      v4 = ") STORED ";
      goto LABEL_41;
    case 5:
      appendStringInfoString((uint64_t)a1, "CHECK (");
      v7 = *(_QWORD *)(a2 + 32);
      goto LABEL_40;
    case 6:
      v4 = "PRIMARY KEY ";
      goto LABEL_41;
    case 7:
      v4 = "UNIQUE ";
      goto LABEL_41;
    case 8:
      appendStringInfoString((uint64_t)a1, "EXCLUDE ");
      if (strcmp(*(const char **)(a2 + 112), "btree"))
      {
        appendStringInfoString((uint64_t)a1, "USING ");
        v8 = quote_identifier(*(_BYTE **)(a2 + 112));
        appendStringInfoString((uint64_t)a1, v8);
        appendStringInfoChar((uint64_t)a1, 32);
      }
      appendStringInfoChar((uint64_t)a1, 40);
      v15 = *(_QWORD *)(a2 + 72);
      if (!v15 || *(int *)(v15 + 4) < 1)
        goto LABEL_38;
      v16 = 0;
      v17 = 8;
      break;
    case 9:
      v25 = *(_QWORD *)(a2 + 136);
      if (!v25 || *(int *)(v25 + 4) < 1)
        goto LABEL_42;
      v4 = "FOREIGN KEY ";
      goto LABEL_41;
    case 0xA:
      v4 = "DEFERRABLE ";
      goto LABEL_41;
    case 0xB:
      v4 = "NOT DEFERRABLE ";
      goto LABEL_41;
    case 0xC:
      v4 = "INITIALLY DEFERRED ";
      goto LABEL_41;
    case 0xD:
      v4 = "INITIALLY IMMEDIATE ";
      goto LABEL_41;
    default:
      goto LABEL_42;
  }
  do
  {
    v18 = *(_QWORD *)(v15 + 16);
    v19 = *(_QWORD *)(v18 + 8 * v16);
    deparseIndexElem(a1, **(_QWORD **)(v19 + 16), v9, v10, v11, v12, v13, v14);
    appendStringInfoString((uint64_t)a1, " WITH ");
    v20 = *(_QWORD *)(*(_QWORD *)(v19 + 16) + 8);
    if (!v20)
      goto LABEL_26;
    v21 = *(_DWORD *)(v20 + 4);
    if (v21 == 1)
    {
      v23 = *(_QWORD *)(v20 + 16);
    }
    else
    {
      if (v21 != 2)
        goto LABEL_26;
      v22 = quote_identifier(*(_BYTE **)(**(_QWORD **)(v20 + 16) + 8));
      appendStringInfoString((uint64_t)a1, v22);
      appendStringInfoChar((uint64_t)a1, 46);
      v23 = *(_QWORD *)(v20 + 16) + 8 * (*(_DWORD *)(v20 + 4) - 1);
    }
    appendStringInfoString((uint64_t)a1, *(char **)(*(_QWORD *)v23 + 8));
LABEL_26:
    if (v18 + v17)
      v24 = v18 + v17 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                          + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
    else
      v24 = 1;
    if (!v24)
      appendStringInfoString((uint64_t)a1, ", ");
    ++v16;
    v17 += 8;
  }
  while (v16 < *(int *)(v15 + 4));
LABEL_38:
  appendStringInfoString((uint64_t)a1, ") ");
  if (*(_QWORD *)(a2 + 120))
  {
    appendStringInfoString((uint64_t)a1, "WHERE (");
    v7 = *(_QWORD *)(a2 + 120);
LABEL_40:
    deparseExpr(a1, v7);
    v4 = ") ";
LABEL_41:
    appendStringInfoString((uint64_t)a1, v4);
  }
LABEL_42:
  v26 = *(_QWORD *)(a2 + 56);
  if (v26 && *(int *)(v26 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    v27 = *(_QWORD *)(a2 + 56);
    if (v27 && *(int *)(v27 + 4) >= 1)
    {
      v28 = 0;
      v29 = 8;
      do
      {
        v30 = *(_QWORD *)(v27 + 16);
        v31 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v30 + 8 * v28) + 8));
        appendStringInfoString((uint64_t)a1, v31);
        v32 = *(int *)(v27 + 4);
        if (v30 + v29)
          v33 = v30 + v29 >= (unint64_t)(*(_QWORD *)(v27 + 16) + 8 * v32);
        else
          v33 = 1;
        if (!v33)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v32 = *(int *)(v27 + 4);
        }
        ++v28;
        v29 += 8;
      }
      while (v28 < v32);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  v34 = *(_QWORD *)(a2 + 136);
  if (v34 && *(int *)(v34 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    v35 = *(_QWORD *)(a2 + 136);
    if (v35 && *(int *)(v35 + 4) >= 1)
    {
      v36 = 0;
      v37 = 8;
      do
      {
        v38 = *(_QWORD *)(v35 + 16);
        v39 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v38 + 8 * v36) + 8));
        appendStringInfoString((uint64_t)a1, v39);
        v40 = *(int *)(v35 + 4);
        if (v38 + v37)
          v41 = v38 + v37 >= (unint64_t)(*(_QWORD *)(v35 + 16) + 8 * v40);
        else
          v41 = 1;
        if (!v41)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v40 = *(int *)(v35 + 4);
        }
        ++v36;
        v37 += 8;
      }
      while (v36 < v40);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  if (*(_QWORD *)(a2 + 128))
  {
    appendStringInfoString((uint64_t)a1, "REFERENCES ");
    deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 128), 0);
    appendStringInfoChar((uint64_t)a1, 32);
    v42 = *(_QWORD *)(a2 + 144);
    if (v42)
    {
      if (*(int *)(v42 + 4) >= 1)
      {
        appendStringInfoChar((uint64_t)a1, 40);
        v43 = *(_QWORD *)(a2 + 144);
        if (v43 && *(int *)(v43 + 4) >= 1)
        {
          v44 = 0;
          v45 = 8;
          do
          {
            v46 = *(_QWORD *)(v43 + 16);
            v47 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v46 + 8 * v44) + 8));
            appendStringInfoString((uint64_t)a1, v47);
            v48 = *(int *)(v43 + 4);
            if (v46 + v45)
              v49 = v46 + v45 >= (unint64_t)(*(_QWORD *)(v43 + 16) + 8 * v48);
            else
              v49 = 1;
            if (!v49)
            {
              appendStringInfoString((uint64_t)a1, ", ");
              v48 = *(int *)(v43 + 4);
            }
            ++v44;
            v45 += 8;
          }
          while (v44 < v48);
        }
        appendStringInfoString((uint64_t)a1, ") ");
      }
    }
  }
  if (*(_BYTE *)(a2 + 152) == 102)
    appendStringInfoString((uint64_t)a1, "MATCH FULL ");
  v50 = "ON UPDATE RESTRICT ";
  switch(*(_BYTE *)(a2 + 153))
  {
    case 'c':
      v50 = "ON UPDATE CASCADE ";
      goto LABEL_85;
    case 'd':
      v50 = "ON UPDATE SET DEFAULT ";
      goto LABEL_85;
    case 'n':
      v50 = "ON UPDATE SET NULL ";
      goto LABEL_85;
    case 'r':
LABEL_85:
      appendStringInfoString((uint64_t)a1, v50);
      break;
    default:
      break;
  }
  v51 = "ON DELETE RESTRICT ";
  switch(*(_BYTE *)(a2 + 154))
  {
    case 'c':
      v51 = "ON DELETE CASCADE ";
      goto LABEL_90;
    case 'd':
      v51 = "ON DELETE SET DEFAULT ";
      goto LABEL_90;
    case 'n':
      v51 = "ON DELETE SET NULL ";
      goto LABEL_90;
    case 'r':
LABEL_90:
      appendStringInfoString((uint64_t)a1, v51);
      break;
    default:
      break;
  }
  v52 = *(_QWORD *)(a2 + 64);
  if (v52 && *(int *)(v52 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "INCLUDE (");
    v53 = *(_QWORD *)(a2 + 64);
    if (v53 && *(int *)(v53 + 4) >= 1)
    {
      v54 = 0;
      v55 = 8;
      do
      {
        v56 = *(_QWORD *)(v53 + 16);
        v57 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v56 + 8 * v54) + 8));
        appendStringInfoString((uint64_t)a1, v57);
        v58 = *(int *)(v53 + 4);
        if (v56 + v55)
          v59 = v56 + v55 >= (unint64_t)(*(_QWORD *)(v53 + 16) + 8 * v58);
        else
          v59 = 1;
        if (!v59)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v58 = *(int *)(v53 + 4);
        }
        ++v54;
        v55 += 8;
      }
      while (v54 < v58);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  v60 = *(_BYTE **)(a2 + 88);
  if (v60)
  {
    v61 = quote_identifier(v60);
    appendStringInfo((uint64_t)a1, "USING INDEX %s ", v62, v63, v64, v65, v66, v67, (size_t)v61);
  }
  result = *(_BYTE **)(a2 + 96);
  if (result)
  {
    v69 = quote_identifier(result);
    result = (_BYTE *)appendStringInfo((uint64_t)a1, "USING INDEX TABLESPACE %s ", v70, v71, v72, v73, v74, v75, (size_t)v69);
  }
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfoString((uint64_t)a1, "DEFERRABLE ");
  if (*(_BYTE *)(a2 + 17))
    result = appendStringInfoString((uint64_t)a1, "INITIALLY DEFERRED ");
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfoString((uint64_t)a1, "NO INHERIT ");
  if (*(_BYTE *)(a2 + 172))
    result = appendStringInfoString((uint64_t)a1, "NOT VALID ");
  v76 = a1[2];
  v77 = __OFSUB__(v76, 1);
  v78 = (v76 - 1);
  if ((int)v78 < 0 == v77)
  {
    v79 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v78) == 32)
    {
      a1[2] = v78;
      *(_BYTE *)(v79 + v78) = 0;
    }
  }
  return result;
}

uint64_t deparseFuncCall(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  int v36;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(_DWORD *)(v4 + 4);
    if (v5 == 2)
    {
      v6 = *(_QWORD **)(v4 + 16);
      if (!strcmp(*(const char **)(*v6 + 8), "pg_catalog") && !strcmp(*(const char **)(v6[1] + 8), "overlay"))
      {
        v7 = *(_QWORD *)(a2 + 16);
        if (v7)
        {
          if (*(_DWORD *)(v7 + 4) == 4)
          {
            appendStringInfoString(a1, "OVERLAY(");
            deparseExpr(a1, **(_QWORD **)(*(_QWORD *)(a2 + 16) + 16));
            appendStringInfoString(a1, " PLACING ");
            deparseExpr(a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8));
            appendStringInfoString(a1, " FROM ");
            deparseExpr(a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 16));
            appendStringInfoString(a1, " FOR ");
            deparseExpr(a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 24));
            return appendStringInfoChar(a1, 41);
          }
        }
      }
    }
    else if (v5 < 1)
    {
      goto LABEL_16;
    }
    v9 = 0;
    v10 = 8;
    do
    {
      v11 = *(_QWORD *)(v4 + 16);
      v12 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v11 + 8 * v9) + 8));
      appendStringInfoString(a1, v12);
      v13 = *(int *)(v4 + 4);
      if (v11 + v10)
        v14 = v11 + v10 >= (unint64_t)(*(_QWORD *)(v4 + 16) + 8 * v13);
      else
        v14 = 1;
      if (!v14)
      {
        appendStringInfoChar(a1, 46);
        v13 = *(int *)(v4 + 4);
      }
      ++v9;
      v10 += 8;
    }
    while (v9 < v13);
  }
LABEL_16:
  appendStringInfoChar(a1, 40);
  if (*(_BYTE *)(a2 + 42))
    appendStringInfoString(a1, "DISTINCT ");
  if (*(_BYTE *)(a2 + 41))
  {
    appendStringInfoChar(a1, 42);
  }
  else
  {
    v27 = *(_QWORD *)(a2 + 16);
    if (v27 && *(int *)(v27 + 4) >= 1)
    {
      v28 = 0;
      v29 = 8;
      do
      {
        v30 = *(_QWORD *)(v27 + 16);
        if (*(_BYTE *)(a2 + 43))
        {
          if (!(v30 + v29)
            || v30 + v29 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                             + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4)))
          {
            appendStringInfoString(a1, "VARIADIC ");
          }
        }
        v32 = *(_QWORD *)(v30 + 8 * v28);
        if (*(_DWORD *)v32 == 114)
        {
          appendStringInfoString(a1, *(char **)(v32 + 16));
          appendStringInfoString(a1, " := ");
          v33 = *(_QWORD *)(v32 + 8);
          v34 = a1;
        }
        else
        {
          v34 = a1;
          v33 = *(_QWORD *)(v30 + 8 * v28);
        }
        deparseExpr(v34, v33);
        if (v30 + v29)
          v35 = v30 + v29 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v35 = 1;
        if (!v35)
          appendStringInfoString(a1, ", ");
        ++v28;
        v29 += 8;
      }
      while (v28 < *(int *)(v27 + 4));
    }
  }
  appendStringInfoChar(a1, 32);
  v15 = *(_QWORD *)(a2 + 24);
  if (v15 && !*(_BYTE *)(a2 + 40))
    deparseOptSortClause(a1, v15);
  v16 = *(_DWORD *)(a1 + 8);
  v17 = __OFSUB__(v16, 1);
  v18 = (v16 - 1);
  if ((int)v18 < 0 == v17)
  {
    v19 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v18) == 32)
    {
      *(_DWORD *)(a1 + 8) = v18;
      *(_BYTE *)(v19 + v18) = 0;
    }
  }
  result = (uint64_t)appendStringInfoString(a1, ") ");
  if (*(_QWORD *)(a2 + 24) && *(_BYTE *)(a2 + 40))
  {
    appendStringInfoString(a1, "WITHIN GROUP (");
    deparseOptSortClause(a1, *(_QWORD *)(a2 + 24));
    v20 = *(_DWORD *)(a1 + 8);
    v17 = __OFSUB__(v20, 1);
    v21 = (v20 - 1);
    if ((int)v21 < 0 == v17)
    {
      v22 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v21) == 32)
      {
        *(_DWORD *)(a1 + 8) = v21;
        *(_BYTE *)(v22 + v21) = 0;
      }
    }
    result = (uint64_t)appendStringInfoString(a1, ") ");
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfoString(a1, "FILTER (WHERE ");
    deparseExpr(a1, *(_QWORD *)(a2 + 32));
    result = (uint64_t)appendStringInfoString(a1, ") ");
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfoString(a1, "OVER ");
    v23 = *(_QWORD *)(a2 + 48);
    if (!*(_QWORD *)(v23 + 8))
    {
      result = deparseWindowDef(a1, v23);
      v36 = *(_DWORD *)(a1 + 8);
      v17 = __OFSUB__(v36, 1);
      v25 = (v36 - 1);
      if ((int)v25 < 0 != v17)
        return result;
      goto LABEL_38;
    }
    result = (uint64_t)appendStringInfoString(a1, *(char **)(v23 + 8));
  }
  v24 = *(_DWORD *)(a1 + 8);
  v17 = __OFSUB__(v24, 1);
  v25 = (v24 - 1);
  if ((int)v25 < 0 != v17)
    return result;
LABEL_38:
  v26 = *(_QWORD *)a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + v25) == 32)
  {
    *(_DWORD *)(a1 + 8) = v25;
    *(_BYTE *)(v26 + v25) = 0;
  }
  return result;
}

void *deparseXmlExpr(void *result, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;

  v3 = result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      appendStringInfoString((uint64_t)result, "xmlconcat(");
      v4 = *(_QWORD *)(a2 + 32);
      if (v4 && *(int *)(v4 + 4) >= 1)
      {
        v5 = 0;
        v6 = 8;
        do
        {
          v7 = *(_QWORD *)(v4 + 16);
          deparseExpr(v3, *(_QWORD *)(v7 + 8 * v5));
          v8 = *(int *)(v4 + 4);
          if (v7 + v6)
            v9 = v7 + v6 >= (unint64_t)(*(_QWORD *)(v4 + 16) + 8 * v8);
          else
            v9 = 1;
          if (!v9)
          {
            appendStringInfoString((uint64_t)v3, ", ");
            v8 = *(int *)(v4 + 4);
          }
          ++v5;
          v6 += 8;
        }
        while (v5 < v8);
      }
      return (void *)appendStringInfoChar((uint64_t)v3, 41);
    case 1:
      appendStringInfoString((uint64_t)result, "xmlelement(name ");
      v10 = quote_identifier(*(_BYTE **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v10);
      if (*(_QWORD *)(a2 + 16))
      {
        appendStringInfoString((uint64_t)v3, ", xmlattributes(");
        deparseXmlAttributeList(v3, *(_QWORD *)(a2 + 16));
        appendStringInfoString((uint64_t)v3, ")");
      }
      if (*(_QWORD *)(a2 + 32))
      {
        appendStringInfoString((uint64_t)v3, ", ");
        v11 = *(_QWORD *)(a2 + 32);
        if (v11)
        {
          if (*(int *)(v11 + 4) >= 1)
          {
            v12 = 0;
            v13 = 8;
            do
            {
              v14 = *(_QWORD *)(v11 + 16);
              deparseExpr(v3, *(_QWORD *)(v14 + 8 * v12));
              v15 = *(int *)(v11 + 4);
              if (v14 + v13)
                v16 = v14 + v13 >= (unint64_t)(*(_QWORD *)(v11 + 16) + 8 * v15);
              else
                v16 = 1;
              if (!v16)
              {
                appendStringInfoString((uint64_t)v3, ", ");
                v15 = *(int *)(v11 + 4);
              }
              ++v12;
              v13 += 8;
            }
            while (v12 < v15);
          }
        }
      }
      return appendStringInfoString((uint64_t)v3, ")");
    case 2:
      appendStringInfoString((uint64_t)result, "xmlforest(");
      deparseXmlAttributeList(v3, *(_QWORD *)(a2 + 16));
      return (void *)appendStringInfoChar((uint64_t)v3, 41);
    case 3:
      appendStringInfoString((uint64_t)result, "xmlparse(");
      v17 = *(_DWORD *)(a2 + 40);
      if (v17)
      {
        if (v17 != 1)
          goto LABEL_38;
        v18 = "content ";
      }
      else
      {
        v18 = "document ";
      }
      appendStringInfoString((uint64_t)v3, v18);
LABEL_38:
      deparseExpr(v3, **(_QWORD **)(*(_QWORD *)(a2 + 32) + 16));
      if (strcmp(*(const char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8) + 8) + 16), "t"))
      {
        return (void *)appendStringInfoChar((uint64_t)v3, 41);
      }
      v22 = " PRESERVE WHITESPACE";
      goto LABEL_40;
    case 4:
      appendStringInfoString((uint64_t)result, "xmlpi(name ");
      v19 = quote_identifier(*(_BYTE **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v19);
      if (*(_QWORD *)(a2 + 32))
      {
        appendStringInfoString((uint64_t)v3, ", ");
        deparseExpr(v3, **(_QWORD **)(*(_QWORD *)(a2 + 32) + 16));
      }
      return (void *)appendStringInfoChar((uint64_t)v3, 41);
    case 5:
      appendStringInfoString((uint64_t)result, "xmlroot(");
      deparseExpr(v3, **(_QWORD **)(*(_QWORD *)(a2 + 32) + 16));
      appendStringInfoString((uint64_t)v3, ", version ");
      v20 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8);
      if (*(_DWORD *)(v20 + 8) == 225)
      {
        appendStringInfoString((uint64_t)v3, "NO VALUE");
        v21 = *(int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 16) + 16);
        if (v21 > 2)
          return (void *)appendStringInfoChar((uint64_t)v3, 41);
      }
      else
      {
        deparseExpr(v3, v20);
        v21 = *(int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 16) + 16);
        if (v21 > 2)
          return (void *)appendStringInfoChar((uint64_t)v3, 41);
      }
      v22 = (&off_1E264AB68)[v21];
LABEL_40:
      appendStringInfoString((uint64_t)v3, v22);
      return (void *)appendStringInfoChar((uint64_t)v3, 41);
    case 7:
      deparseExpr(result, **(_QWORD **)(*(_QWORD *)(a2 + 32) + 16));
      return appendStringInfoString((uint64_t)v3, " IS DOCUMENT");
    default:
      return result;
  }
}

void *deparseTypeCast(void *a1, uint64_t a2)
{
  _DWORD *v4;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  const char *v9;
  const char *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = *(_DWORD **)(a2 + 8);
  if (*v4 != 349)
  {
    if (*v4 == 346)
    {
      appendStringInfoString((uint64_t)a1, "CAST(");
      deparseExpr(a1, *(_QWORD *)(a2 + 8));
      appendStringInfoString((uint64_t)a1, " AS ");
      deparseTypeName(a1, *(_QWORD *)(a2 + 16));
      return (void *)appendStringInfoChar((uint64_t)a1, 41);
    }
    goto LABEL_16;
  }
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(v6 + 8);
  if (!v7)
    goto LABEL_13;
  if (*(_DWORD *)(v7 + 4) != 2)
    goto LABEL_13;
  v8 = *(_QWORD **)(v7 + 16);
  if (strcmp(*(const char **)(*v8 + 8), "pg_catalog"))
    goto LABEL_13;
  v9 = *(const char **)(v8[1] + 8);
  if (!strcmp(v9, "bpchar") && !*(_QWORD *)(v6 + 24))
  {
    appendStringInfoString((uint64_t)a1, "char ");
    return deparseValue(a1, (uint64_t)(v4 + 2), 11, v12, v13, v14, v15, v16);
  }
  if (strcmp(v9, "BOOL") || v4[2] != 223)
  {
LABEL_13:
    v11 = v4[2];
    if (v11 == 222 || v11 == 221 && (v4[4] & 0x80000000) != 0)
    {
      appendStringInfoChar((uint64_t)a1, 40);
      deparseExpr(a1, *(_QWORD *)(a2 + 8));
      appendStringInfoChar((uint64_t)a1, 41);
      goto LABEL_18;
    }
LABEL_16:
    deparseExpr(a1, v4);
LABEL_18:
    appendStringInfoString((uint64_t)a1, "::");
    return deparseTypeName(a1, *(_QWORD *)(a2 + 16));
  }
  v10 = (const char *)*((_QWORD *)v4 + 2);
  if (!strcmp(v10, "t"))
    return appendStringInfoString((uint64_t)a1, "true");
  if (strcmp(v10, "f"))
    goto LABEL_13;
  return appendStringInfoString((uint64_t)a1, "false");
}

uint64_t deparseAExpr(uint64_t result, uint64_t a2)
{
  void *v3;
  _DWORD *v4;
  _BOOL4 v5;
  int v6;
  int *v7;
  int v8;
  _BOOL4 v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  char *v17;
  char *v18;
  const char *v19;
  char *v20;
  const char *v21;
  char *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v3 = (void *)result;
  v4 = *(_DWORD **)(a2 + 16);
  if (!v4)
  {
    v6 = 0;
    v7 = *(int **)(a2 + 24);
    if (v7)
      goto LABEL_8;
LABEL_16:
    v10 = 0;
    v11 = *(_DWORD *)(a2 + 4);
LABEL_17:
    switch(v11)
    {
      case 0u:
        if (v4)
        {
          if (v6)
          {
            appendStringInfoChar(result, 40);
            deparseExpr(v3, *(_QWORD *)(a2 + 16));
            appendStringInfoChar((uint64_t)v3, 41);
          }
          else
          {
            deparseExpr(result, v4);
          }
          appendStringInfoChar((uint64_t)v3, 32);
        }
        result = (uint64_t)deparseQualOp((uint64_t)v3, *(_QWORD *)(a2 + 8));
        if (*(_QWORD *)(a2 + 24))
        {
          appendStringInfoChar((uint64_t)v3, 32);
          if (!v10)
            goto LABEL_81;
          goto LABEL_92;
        }
        return result;
      case 1u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        deparseSubqueryOp((uint64_t)v3, *(_QWORD *)(a2 + 8));
        v17 = " ANY(";
        goto LABEL_37;
      case 2u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        deparseSubqueryOp((uint64_t)v3, *(_QWORD *)(a2 + 8));
        v17 = " ALL(";
        goto LABEL_37;
      case 3u:
        if (v6)
        {
          appendStringInfoChar(result, 40);
          deparseExpr(v3, *(_QWORD *)(a2 + 16));
          appendStringInfoChar((uint64_t)v3, 41);
          appendStringInfoString((uint64_t)v3, " IS DISTINCT FROM ");
          if (!v10)
            goto LABEL_81;
        }
        else
        {
          deparseExpr(result, v4);
          appendStringInfoString((uint64_t)v3, " IS DISTINCT FROM ");
          if (!v10)
            goto LABEL_81;
        }
LABEL_92:
        appendStringInfoChar((uint64_t)v3, 40);
LABEL_93:
        deparseExpr(v3, *(_QWORD *)(a2 + 24));
        return appendStringInfoChar((uint64_t)v3, 41);
      case 4u:
        deparseExpr(result, v4);
        v18 = " IS NOT DISTINCT FROM ";
        goto LABEL_80;
      case 5u:
        appendStringInfoString(result, "NULLIF(");
        deparseExpr(v3, *(_QWORD *)(a2 + 16));
        v17 = ", ";
LABEL_37:
        appendStringInfoString((uint64_t)v3, v17);
        goto LABEL_93;
      case 6u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        v19 = *(const char **)(**(_QWORD **)(*(_QWORD *)(a2 + 8) + 16) + 8);
        if (!strcmp(v19, "="))
        {
          v20 = "IS OF ";
        }
        else
        {
          if (strcmp(v19, "<>"))
            goto LABEL_57;
          v20 = "IS NOT OF ";
        }
        appendStringInfoString((uint64_t)v3, v20);
LABEL_57:
        appendStringInfoChar((uint64_t)v3, 40);
        v27 = *(_QWORD *)(a2 + 24);
        if (v27 && *(int *)(v27 + 4) >= 1)
        {
          v28 = 0;
          v29 = 8;
          do
          {
            v30 = *(_QWORD *)(v27 + 16);
            deparseTypeName(v3, *(_QWORD *)(v30 + 8 * v28));
            v31 = *(int *)(v27 + 4);
            if (v30 + v29)
              v32 = v30 + v29 >= (unint64_t)(*(_QWORD *)(v27 + 16) + 8 * v31);
            else
              v32 = 1;
            if (!v32)
            {
              appendStringInfoString((uint64_t)v3, ", ");
              v31 = *(int *)(v27 + 4);
            }
            ++v28;
            v29 += 8;
          }
          while (v28 < v31);
        }
        return appendStringInfoChar((uint64_t)v3, 41);
      case 7u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        v21 = *(const char **)(**(_QWORD **)(*(_QWORD *)(a2 + 8) + 16) + 8);
        if (!strcmp(v21, "="))
        {
          v22 = "IN ";
        }
        else
        {
          if (strcmp(v21, "<>"))
            goto LABEL_68;
          v22 = "NOT IN ";
        }
        appendStringInfoString((uint64_t)v3, v22);
LABEL_68:
        appendStringInfoChar((uint64_t)v3, 40);
        v33 = *(_QWORD *)(a2 + 24);
        if (*(_DWORD *)v33 == 120)
        {
          deparseSubLink((uint64_t)v3, v33);
        }
        else if (*(int *)(v33 + 4) >= 1)
        {
          v34 = 0;
          v35 = 8;
          do
          {
            v36 = *(_QWORD *)(v33 + 16);
            deparseExpr(v3, *(_QWORD *)(v36 + 8 * v34));
            v37 = *(int *)(v33 + 4);
            if (v36 + v35)
              v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(v33 + 16) + 8 * v37);
            else
              v38 = 1;
            if (!v38)
            {
              appendStringInfoString((uint64_t)v3, ", ");
              v37 = *(int *)(v33 + 4);
            }
            ++v34;
            v35 += 8;
          }
          while (v34 < v37);
        }
        return appendStringInfoChar((uint64_t)v3, 41);
      case 8u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        v23 = *(const char **)(**(_QWORD **)(*(_QWORD *)(a2 + 8) + 16) + 8);
        if (!strcmp(v23, "~~"))
        {
          v18 = "LIKE ";
        }
        else
        {
          if (strcmp(v23, "!~~"))
            goto LABEL_81;
          v18 = "NOT LIKE ";
        }
        goto LABEL_80;
      case 9u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        v24 = *(const char **)(**(_QWORD **)(*(_QWORD *)(a2 + 8) + 16) + 8);
        if (!strcmp(v24, "~~*"))
        {
          v18 = "ILIKE ";
        }
        else
        {
          if (strcmp(v24, "!~~*"))
            goto LABEL_81;
          v18 = "NOT ILIKE ";
        }
LABEL_80:
        appendStringInfoString((uint64_t)v3, v18);
LABEL_81:
        v39 = *(_QWORD *)(a2 + 24);
        goto LABEL_82;
      case 0xAu:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        v25 = *(const char **)(**(_QWORD **)(*(_QWORD *)(a2 + 8) + 16) + 8);
        if (!strcmp(v25, "~"))
        {
          v26 = "SIMILAR TO ";
        }
        else
        {
          if (strcmp(v25, "!~"))
            goto LABEL_85;
          v26 = "NOT SIMILAR TO ";
        }
        appendStringInfoString((uint64_t)v3, v26);
LABEL_85:
        v40 = *(_QWORD *)(a2 + 24);
        result = deparseExpr(v3, **(_QWORD **)(*(_QWORD *)(v40 + 16) + 16));
        v41 = *(_QWORD *)(v40 + 16);
        if (v41 && *(_DWORD *)(v41 + 4) == 2)
        {
          appendStringInfoString((uint64_t)v3, " ESCAPE ");
          v39 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v40 + 16) + 16) + 8);
LABEL_82:
          result = deparseExpr(v3, v39);
        }
        break;
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        appendStringInfoString((uint64_t)v3, *(char **)(**(_QWORD **)(*(_QWORD *)(a2 + 8) + 16) + 8));
        result = appendStringInfoChar((uint64_t)v3, 32);
        v12 = *(_QWORD *)(a2 + 24);
        if (v12 && *(int *)(v12 + 4) >= 1)
        {
          v13 = 0;
          v14 = 8;
          do
          {
            v15 = *(_QWORD *)(v12 + 16);
            result = deparseExpr(v3, *(_QWORD *)(v15 + 8 * v13));
            if (v15 + v14)
              v16 = v15 + v14 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                                  + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
            else
              v16 = 1;
            if (!v16)
              result = (uint64_t)appendStringInfoString((uint64_t)v3, " AND ");
            ++v13;
            v14 += 8;
          }
          while (v13 < *(int *)(v12 + 4));
        }
        return result;
      default:
        return result;
    }
    return result;
  }
  v5 = *v4 == 346;
  if (*v4 == 140)
    v5 = 1;
  v6 = *v4 == 119 || v5;
  v7 = *(int **)(a2 + 24);
  if (!v7)
    goto LABEL_16;
LABEL_8:
  v8 = *v7;
  v9 = v8 == 346;
  if (v8 == 140)
    v9 = 1;
  v10 = v8 == 119 || v9;
  v11 = *(_DWORD *)(a2 + 4);
  if (v11 <= 0xE)
    goto LABEL_17;
  return result;
}

void *deparseCaseExpr(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  appendStringInfoString(a1, "CASE ");
  v4 = a2[2];
  if (v4)
  {
    deparseExpr(a1, v4);
    appendStringInfoChar(a1, 32);
  }
  v5 = a2[3];
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    v6 = 0;
    do
    {
      v7 = *(_QWORD *)(*(_QWORD *)(v5 + 16) + 8 * v6);
      appendStringInfoString(a1, "WHEN ");
      deparseExpr(a1, *(_QWORD *)(v7 + 8));
      appendStringInfoString(a1, " THEN ");
      deparseExpr(a1, *(_QWORD *)(v7 + 16));
      appendStringInfoChar(a1, 32);
      ++v6;
    }
    while (v6 < *(int *)(v5 + 4));
  }
  if (a2[4])
  {
    appendStringInfoString(a1, "ELSE ");
    deparseExpr(a1, a2[4]);
    appendStringInfoChar(a1, 32);
  }
  return appendStringInfoString(a1, "END");
}

uint64_t deparseSubLink(uint64_t result, uint64_t a2)
{
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  char *v6;

  v3 = (_DWORD *)result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      v4 = "EXISTS (";
      goto LABEL_9;
    case 1:
      deparseExpr(result, *(_QWORD *)(a2 + 16));
      appendStringInfoChar((uint64_t)v3, 32);
      deparseSubqueryOp((uint64_t)v3, *(_QWORD *)(a2 + 24));
      v4 = " ALL (";
      goto LABEL_9;
    case 2:
      deparseExpr(result, *(_QWORD *)(a2 + 16));
      v5 = *(_QWORD *)(a2 + 24);
      if (v5 && *(int *)(v5 + 4) >= 1)
      {
        appendStringInfoChar((uint64_t)v3, 32);
        deparseSubqueryOp((uint64_t)v3, *(_QWORD *)(a2 + 24));
        v6 = " ANY ";
      }
      else
      {
        v6 = " IN ";
      }
      appendStringInfoString((uint64_t)v3, v6);
      appendStringInfoChar((uint64_t)v3, 40);
      goto LABEL_12;
    case 4:
      v4 = "(";
      goto LABEL_9;
    case 6:
      v4 = "ARRAY(";
LABEL_9:
      appendStringInfoString((uint64_t)v3, v4);
LABEL_12:
      deparseSelectStmt(v3, *(_QWORD *)(a2 + 32));
      result = appendStringInfoChar((uint64_t)v3, 41);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t deparseAIndirection(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  unsigned int v5;

  v4 = *(_DWORD **)(a2 + 8);
  v5 = *v4 - 346;
  if (v5 > 0xB)
    goto LABEL_8;
  if (((1 << v5) & 0x891) == 0)
  {
    if (*v4 == 347)
    {
      if (***(_DWORD ***)(*(_QWORD *)(a2 + 16) + 16) != 352)
        goto LABEL_3;
LABEL_9:
      deparseExpr(a1, v4);
      return deparseOptIndirection(a1, *(_QWORD *)(a2 + 16), 0);
    }
LABEL_8:
    if (*v4 == 134)
      goto LABEL_3;
    goto LABEL_9;
  }
LABEL_3:
  appendStringInfoChar(a1, 40);
  deparseExpr(a1, *(_QWORD *)(a2 + 8));
  appendStringInfoChar(a1, 41);
  return deparseOptIndirection(a1, *(_QWORD *)(a2 + 16), 0);
}

uint64_t deparseCollateClause(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  BOOL v12;

  v4 = *(_DWORD **)(a2 + 8);
  if (v4)
  {
    if (*v4 == 346)
    {
      appendStringInfoChar(a1, 40);
      deparseExpr(a1, *(_QWORD *)(a2 + 8));
      appendStringInfoChar(a1, 41);
    }
    else
    {
      deparseExpr(a1, v4);
    }
    appendStringInfoChar(a1, 32);
  }
  result = (uint64_t)appendStringInfoString(a1, "COLLATE ");
  v6 = *(_QWORD *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    v7 = 0;
    v8 = 8;
    do
    {
      v9 = *(_QWORD *)(v6 + 16);
      v10 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v9 + 8 * v7) + 8));
      result = (uint64_t)appendStringInfoString(a1, v10);
      v11 = *(int *)(v6 + 4);
      if (v9 + v8)
        v12 = v9 + v8 >= (unint64_t)(*(_QWORD *)(v6 + 16) + 8 * v11);
      else
        v12 = 1;
      if (!v12)
      {
        result = appendStringInfoChar(a1, 46);
        v11 = *(int *)(v6 + 4);
      }
      ++v7;
      v8 += 8;
    }
    while (v7 < v11);
  }
  return result;
}

uint64_t deparseOptSortClause(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  char *v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    appendStringInfoString(result, "ORDER BY ");
    if (*(int *)(a2 + 4) >= 1)
    {
      v4 = 0;
      v5 = 8;
      do
      {
        v6 = *(_QWORD *)(a2 + 16);
        v7 = *(_QWORD *)(v6 + 8 * v4);
        deparseExpr(v3, *(_QWORD *)(v7 + 8));
        appendStringInfoChar(v3, 32);
        v8 = *(_DWORD *)(v7 + 16);
        switch(v8)
        {
          case 3:
            appendStringInfoString(v3, "USING ");
            deparseQualOp(v3, *(_QWORD *)(v7 + 24));
            v9 = *(_DWORD *)(v7 + 20);
            if (v9 == 1)
            {
LABEL_16:
              v10 = "NULLS FIRST ";
              goto LABEL_17;
            }
            break;
          case 2:
            appendStringInfoString(v3, "DESC ");
            break;
          case 1:
            appendStringInfoString(v3, "ASC ");
            v9 = *(_DWORD *)(v7 + 20);
            if (v9 == 1)
              goto LABEL_16;
            break;
          default:
            v9 = *(_DWORD *)(v7 + 20);
            if (v9 == 1)
              goto LABEL_16;
            break;
        }
        if (v9 != 2)
          goto LABEL_18;
        v10 = "NULLS LAST ";
LABEL_17:
        appendStringInfoString(v3, v10);
LABEL_18:
        v11 = *(_DWORD *)(v3 + 8);
        v12 = __OFSUB__(v11, 1);
        v13 = (v11 - 1);
        if ((int)v13 < 0 == v12)
        {
          v14 = *(_QWORD *)v3;
          if (*(_BYTE *)(*(_QWORD *)v3 + v13) == 32)
          {
            *(_DWORD *)(v3 + 8) = v13;
            *(_BYTE *)(v14 + v13) = 0;
          }
        }
        v15 = *(int *)(a2 + 4);
        if (v6 + v5)
        {
          if (v6 + v5 < (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v15))
          {
            appendStringInfoString(v3, ", ");
            v15 = *(int *)(a2 + 4);
          }
        }
        ++v4;
        v5 += 8;
      }
      while (v4 < v15);
    }
    return appendStringInfoChar(v3, 32);
  }
  return result;
}

uint64_t deparseWindowDef(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  int v14;
  char *v15;
  int v16;
  char *v17;
  int v18;
  char *v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;

  appendStringInfoChar(a1, 40);
  v4 = *(_BYTE **)(a2 + 16);
  if (v4)
  {
    v5 = quote_identifier(v4);
    appendStringInfoString(a1, v5);
    appendStringInfoChar(a1, 32);
  }
  v6 = *(_QWORD *)(a2 + 24);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoString(a1, "PARTITION BY ");
    v7 = *(_QWORD *)(a2 + 24);
    if (v7 && *(int *)(v7 + 4) >= 1)
    {
      v8 = 0;
      v9 = 8;
      do
      {
        v10 = *(_QWORD *)(v7 + 16);
        deparseExpr(a1, *(_QWORD *)(v10 + 8 * v8));
        v11 = *(int *)(v7 + 4);
        if (v10 + v9)
          v12 = v10 + v9 >= (unint64_t)(*(_QWORD *)(v7 + 16) + 8 * v11);
        else
          v12 = 1;
        if (!v12)
        {
          appendStringInfoString(a1, ", ");
          v11 = *(int *)(v7 + 4);
        }
        ++v8;
        v9 += 8;
      }
      while (v8 < v11);
    }
    appendStringInfoChar(a1, 32);
  }
  deparseOptSortClause(a1, *(_QWORD *)(a2 + 32));
  v13 = *(_DWORD *)(a2 + 40);
  if ((v13 & 1) == 0)
    goto LABEL_56;
  if ((v13 & 2) != 0)
  {
    appendStringInfoString(a1, "RANGE ");
    v14 = *(_DWORD *)(a2 + 40);
    if ((v14 & 0x10) != 0)
      goto LABEL_31;
    goto LABEL_20;
  }
  if ((v13 & 4) != 0)
  {
    appendStringInfoString(a1, "ROWS ");
    v14 = *(_DWORD *)(a2 + 40);
    if ((v14 & 0x10) != 0)
      goto LABEL_31;
LABEL_20:
    if ((v14 & 0x20) == 0)
      goto LABEL_21;
LABEL_32:
    v15 = "UNBOUNDED PRECEDING ";
LABEL_33:
    appendStringInfoString(a1, v15);
    goto LABEL_34;
  }
  if ((v13 & 8) != 0)
  {
    appendStringInfoString(a1, "GROUPS ");
    v14 = *(_DWORD *)(a2 + 40);
    if ((v14 & 0x10) != 0)
      goto LABEL_31;
    goto LABEL_20;
  }
  v14 = *(_DWORD *)(a2 + 40);
  if ((v14 & 0x10) == 0)
    goto LABEL_20;
LABEL_31:
  appendStringInfoString(a1, "BETWEEN ");
  v14 = *(_DWORD *)(a2 + 40);
  if ((v14 & 0x20) != 0)
    goto LABEL_32;
LABEL_21:
  if ((v14 & 0x80) != 0)
    goto LABEL_34;
  if ((v14 & 0x200) != 0)
  {
    v15 = "CURRENT ROW ";
    goto LABEL_33;
  }
  if ((v14 & 0x800) != 0)
  {
    v15 = " PRECEDING ";
    goto LABEL_44;
  }
  if ((v14 & 0x2000) != 0)
  {
    v15 = " FOLLOWING ";
LABEL_44:
    deparseExpr(a1, *(_QWORD *)(a2 + 48));
    goto LABEL_33;
  }
LABEL_34:
  if ((*(_BYTE *)(a2 + 40) & 0x10) == 0)
    goto LABEL_49;
  appendStringInfoString(a1, "AND ");
  v16 = *(_DWORD *)(a2 + 40);
  if ((v16 & 0x40) != 0)
    goto LABEL_49;
  if ((v16 & 0x100) != 0)
  {
    v17 = "UNBOUNDED FOLLOWING ";
LABEL_48:
    appendStringInfoString(a1, v17);
    goto LABEL_49;
  }
  if ((v16 & 0x400) != 0)
  {
    v17 = "CURRENT ROW ";
    goto LABEL_48;
  }
  if ((v16 & 0x1000) != 0)
  {
    v17 = " PRECEDING ";
    goto LABEL_47;
  }
  if ((v16 & 0x4000) != 0)
  {
    v17 = " FOLLOWING ";
LABEL_47:
    deparseExpr(a1, *(_QWORD *)(a2 + 56));
    goto LABEL_48;
  }
LABEL_49:
  v18 = *(_DWORD *)(a2 + 40);
  if ((v18 & 0x8000) != 0)
  {
    v19 = "EXCLUDE CURRENT ROW ";
    goto LABEL_55;
  }
  if ((v18 & 0x10000) != 0)
  {
    v19 = "EXCLUDE GROUP ";
    goto LABEL_55;
  }
  if ((v18 & 0x20000) != 0)
  {
    v19 = "EXCLUDE TIES ";
LABEL_55:
    appendStringInfoString(a1, v19);
  }
LABEL_56:
  v20 = *(_DWORD *)(a1 + 8);
  v21 = __OFSUB__(v20, 1);
  v22 = (v20 - 1);
  if ((int)v22 < 0 == v21)
  {
    v23 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v22) == 32)
    {
      *(_DWORD *)(a1 + 8) = v22;
      *(_BYTE *)(v23 + v22) = 0;
    }
  }
  return appendStringInfoChar(a1, 41);
}

void *deparseQualOp(uint64_t a1, uint64_t a2)
{
  char *v4;
  int v5;
  char *v6;
  uint64_t v7;
  char *v8;

  if (!a2)
  {
    v8 = "OPERATOR(";
    goto LABEL_12;
  }
  if (*(_DWORD *)(a2 + 4) != 1 || (v4 = *(char **)(**(_QWORD **)(a2 + 16) + 8), !isOp(v4)))
  {
    appendStringInfoString(a1, "OPERATOR(");
    v5 = *(_DWORD *)(a2 + 4);
    if (v5 == 1)
    {
      v7 = *(_QWORD *)(a2 + 16);
    }
    else
    {
      if (v5 != 2)
        return appendStringInfoString(a1, ")");
      v6 = quote_identifier(*(_BYTE **)(**(_QWORD **)(a2 + 16) + 8));
      appendStringInfoString(a1, v6);
      appendStringInfoChar(a1, 46);
      v7 = *(_QWORD *)(a2 + 16) + 8 * (*(_DWORD *)(a2 + 4) - 1);
    }
    v8 = *(char **)(*(_QWORD *)v7 + 8);
LABEL_12:
    appendStringInfoString(a1, v8);
    return appendStringInfoString(a1, ")");
  }
  return appendStringInfoString(a1, v4);
}

uint64_t isOp(_BYTE *a1)
{
  int v1;
  unsigned __int8 *v2;
  uint64_t result;
  int v4;

  v1 = *a1;
  if (!*a1)
    return 1;
  v2 = a1 + 1;
  while (2)
  {
    result = 0;
    switch(v1)
    {
      case '!':
      case '#':
      case '%':
      case '&':
      case '*':
      case '+':
      case '-':
      case '/':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case '^':
      case '|':
      case '~':
        v4 = *v2++;
        v1 = v4;
        if (!v4)
          return 1;
        continue;
      default:
        return result;
    }
  }
  return result;
}

void *deparseExprList(void *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = (uint64_t)result;
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      result = (void *)deparseExpr(v3, *(_QWORD *)(v6 + 8 * v4));
      v7 = *(int *)(a2 + 4);
      if (v6 + v5)
        v8 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v7);
      else
        v8 = 1;
      if (!v8)
      {
        result = appendStringInfoString(v3, ", ");
        v7 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v7);
  }
  return result;
}

void *deparseXmlAttributeList(void *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  BOOL v10;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = (uint64_t)result;
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v6 + 8 * v4);
      result = (void *)deparseExpr(v3, *(_QWORD *)(v7 + 24));
      if (*(_QWORD *)(v7 + 8))
      {
        appendStringInfoString(v3, " AS ");
        v8 = quote_identifier(*(_BYTE **)(v7 + 8));
        result = appendStringInfoString(v3, v8);
      }
      v9 = *(int *)(a2 + 4);
      if (v6 + v5)
        v10 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v9);
      else
        v10 = 1;
      if (!v10)
      {
        result = appendStringInfoString(v3, ", ");
        v9 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v9);
  }
  return result;
}

void *deparseTypeName(void *result, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  int v5;
  _QWORD *v6;
  const char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  BOOL v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  char *v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  size_t v79;

  v3 = result;
  if (*(_BYTE *)(a2 + 20))
    result = appendStringInfoString((uint64_t)result, "SETOF ");
  v4 = *(_QWORD *)(a2 + 8);
  if (!v4)
    goto LABEL_40;
  v5 = *(_DWORD *)(v4 + 4);
  if (v5 != 2)
  {
    if (v5 < 1)
    {
LABEL_40:
      v16 = 0;
      goto LABEL_41;
    }
LABEL_23:
    v10 = 0;
    v11 = 8;
    do
    {
      v12 = *(_QWORD *)(v4 + 16);
      v13 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v12 + 8 * v10) + 8));
      result = appendStringInfoString((uint64_t)v3, v13);
      v14 = *(int *)(v4 + 4);
      if (v12 + v11)
        v15 = v12 + v11 >= (unint64_t)(*(_QWORD *)(v4 + 16) + 8 * v14);
      else
        v15 = 1;
      if (!v15)
      {
        result = (void *)appendStringInfoChar((uint64_t)v3, 46);
        v14 = *(int *)(v4 + 4);
      }
      ++v10;
      v11 += 8;
    }
    while (v10 < v14);
    goto LABEL_40;
  }
  v6 = *(_QWORD **)(v4 + 16);
  if (strcmp(*(const char **)(*v6 + 8), "pg_catalog"))
    goto LABEL_23;
  v7 = *(const char **)(v6[1] + 8);
  if (!strcmp(v7, "bpchar"))
  {
    v9 = "char";
LABEL_38:
    v8 = (uint64_t)v3;
    goto LABEL_39;
  }
  if (!strcmp(v7, "varchar"))
  {
    v9 = "varchar";
    goto LABEL_38;
  }
  if (!strcmp(v7, "numeric"))
  {
    v9 = "numeric";
    goto LABEL_38;
  }
  if (!strcmp(v7, "BOOL"))
  {
    v9 = "BOOLean";
    goto LABEL_38;
  }
  if (!strcmp(v7, "int2"))
  {
    v9 = "smallint";
    goto LABEL_38;
  }
  if (!strcmp(v7, "int4"))
  {
    v9 = "int";
    goto LABEL_38;
  }
  if (!strcmp(v7, "int8"))
  {
    v9 = "bigint";
    goto LABEL_38;
  }
  if (!strcmp(v7, "real") || !strcmp(v7, "float4"))
  {
    v9 = "real";
    goto LABEL_38;
  }
  if (!strcmp(v7, "float8"))
  {
    v9 = "double precision";
    goto LABEL_38;
  }
  if (!strcmp(v7, "time"))
  {
    v9 = "time";
    goto LABEL_38;
  }
  if (!strcmp(v7, "timetz"))
  {
    appendStringInfoString((uint64_t)v3, "time ");
    v44 = *(_QWORD *)(a2 + 24);
    if (!v44 || *(int *)(v44 + 4) < 1)
      goto LABEL_103;
    appendStringInfoChar((uint64_t)v3, 40);
    v51 = *(_QWORD *)(a2 + 24);
    if (v51 && *(int *)(v51 + 4) >= 1)
    {
      v52 = 0;
      v53 = 8;
      do
      {
        v54 = *(_QWORD *)(v51 + 16);
        appendStringInfo((uint64_t)v3, "%d", v45, v46, v47, v48, v49, v50, *(unsigned int *)(*(_QWORD *)(v54 + 8 * v52) + 16));
        if (v54 + v53)
          v55 = v54 + v53 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v55 = 1;
        if (!v55)
          appendStringInfoString((uint64_t)v3, ", ");
        ++v52;
        v53 += 8;
      }
      while (v52 < *(int *)(v51 + 4));
    }
    goto LABEL_102;
  }
  if (!strcmp(v7, "timestamp"))
  {
    v9 = "timestamp";
    goto LABEL_38;
  }
  if (!strcmp(v7, "timestamptz"))
  {
    appendStringInfoString((uint64_t)v3, "timestamp ");
    v56 = *(_QWORD *)(a2 + 24);
    if (!v56 || *(int *)(v56 + 4) < 1)
      goto LABEL_103;
    appendStringInfoChar((uint64_t)v3, 40);
    v63 = *(_QWORD *)(a2 + 24);
    if (v63 && *(int *)(v63 + 4) >= 1)
    {
      v64 = 0;
      v65 = 8;
      do
      {
        v66 = *(_QWORD *)(v63 + 16);
        appendStringInfo((uint64_t)v3, "%d", v57, v58, v59, v60, v61, v62, *(unsigned int *)(*(_QWORD *)(v66 + 8 * v64) + 16));
        if (v66 + v65)
          v67 = v66 + v65 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v67 = 1;
        if (!v67)
          appendStringInfoString((uint64_t)v3, ", ");
        ++v64;
        v65 += 8;
      }
      while (v64 < *(int *)(v63 + 4));
    }
LABEL_102:
    appendStringInfoString((uint64_t)v3, ") ");
LABEL_103:
    result = appendStringInfoString((uint64_t)v3, "with time zone");
    v16 = 1;
    goto LABEL_41;
  }
  if (strcmp(v7, "interval"))
  {
LABEL_21:
    appendStringInfoString((uint64_t)v3, "pg_catalog.");
    v8 = (uint64_t)v3;
    v9 = (char *)v7;
LABEL_39:
    result = appendStringInfoString(v8, v9);
    goto LABEL_40;
  }
  v68 = *(_QWORD *)(a2 + 24);
  if (!v68 || (v69 = *(_DWORD *)(v68 + 4)) == 0)
  {
    v9 = "interval";
    goto LABEL_38;
  }
  if (v69 < 1)
    goto LABEL_21;
  v70 = *(_DWORD *)(**(_QWORD **)(v68 + 16) + 16);
  result = appendStringInfoString((uint64_t)v3, "interval");
  if (v70 > 3071)
  {
    if (v70 > 6143)
    {
      switch(v70)
      {
        case 6144:
          v77 = " minute to second";
          goto LABEL_133;
        case 7168:
          v77 = " hour to second";
          goto LABEL_133;
        case 7176:
          v77 = " day to second";
          goto LABEL_133;
      }
    }
    else
    {
      switch(v70)
      {
        case 3072:
          v77 = " hour to minute";
          goto LABEL_133;
        case 3080:
          v77 = " day to minute";
          goto LABEL_133;
        case 4096:
          v77 = " second";
LABEL_133:
          result = appendStringInfoString((uint64_t)v3, v77);
          break;
      }
    }
  }
  else
  {
    if (v70 <= 1023)
    {
      v77 = " year";
      switch(v70)
      {
        case 2:
          v77 = " month";
          goto LABEL_133;
        case 4:
          goto LABEL_133;
        case 6:
          v77 = " year to month";
          goto LABEL_133;
        case 8:
          v77 = " day";
          goto LABEL_133;
        default:
          goto LABEL_134;
      }
      goto LABEL_134;
    }
    switch(v70)
    {
      case 1024:
        v77 = " hour";
        goto LABEL_133;
      case 1032:
        v77 = " day to hour";
        goto LABEL_133;
      case 2048:
        v77 = " minute";
        goto LABEL_133;
    }
  }
LABEL_134:
  v78 = *(_QWORD *)(a2 + 24);
  if (v78
    && *(_DWORD *)(v78 + 4) == 2
    && (v79 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v78 + 16) + 8) + 16), (_DWORD)v79 != 0xFFFF))
  {
    result = (void *)appendStringInfo((uint64_t)v3, "(%d)", v71, v72, v73, v74, v75, v76, v79);
    v16 = 1;
  }
  else
  {
    v16 = 1;
  }
LABEL_41:
  v17 = *(_QWORD *)(a2 + 24);
  if (v17)
  {
    if (*(int *)(v17 + 4) < 1)
      v16 = 1;
    if ((v16 & 1) == 0)
    {
      appendStringInfoChar((uint64_t)v3, 40);
      v24 = *(_QWORD *)(a2 + 24);
      if (v24 && *(int *)(v24 + 4) >= 1)
      {
        v25 = 0;
        v26 = 8;
        do
        {
          v27 = *(_QWORD *)(v24 + 16);
          v28 = *(int **)(v27 + 8 * v25);
          v29 = *v28;
          if (*v28 == 347)
          {
            v30 = **(_QWORD **)(*((_QWORD *)v28 + 1) + 16);
            if (*(_DWORD *)v30 == 223)
            {
              v31 = quote_identifier(*(_BYTE **)(v30 + 8));
              appendStringInfoString((uint64_t)v3, v31);
            }
            else if (*(_DWORD *)v30 == 351)
            {
              appendStringInfoChar((uint64_t)v3, 42);
            }
            deparseOptIndirection((uint64_t)v3, *((_QWORD *)v28 + 1), 1);
          }
          else if (v29 == 348)
          {
            if (v28[1])
              appendStringInfo((uint64_t)v3, "$%d", v18, v19, v20, v21, v22, v23, v28[1]);
            else
              appendStringInfoChar((uint64_t)v3, 63);
          }
          else if (v29 == 349)
          {
            deparseValue(v3, (uint64_t)(v28 + 2), 11, v19, v20, v21, v22, v23);
          }
          if (v27 + v26)
            v32 = v27 + v26 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                                + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
          else
            v32 = 1;
          if (!v32)
            appendStringInfoString((uint64_t)v3, ", ");
          ++v25;
          v26 += 8;
        }
        while (v25 < *(int *)(v24 + 4));
      }
      result = (void *)appendStringInfoChar((uint64_t)v3, 41);
    }
  }
  v33 = *(_QWORD *)(a2 + 40);
  if (v33 && *(int *)(v33 + 4) >= 1)
  {
    v34 = 0;
    do
    {
      v35 = *(_QWORD *)(v33 + 16);
      appendStringInfoChar((uint64_t)v3, 91);
      v42 = *(_DWORD **)(v35 + 8 * v34);
      if (*v42 == 221)
      {
        v43 = v42[2];
        if ((_DWORD)v43 != -1)
          appendStringInfo((uint64_t)v3, "%d", v36, v37, v38, v39, v40, v41, v43);
      }
      result = (void *)appendStringInfoChar((uint64_t)v3, 93);
      ++v34;
    }
    while (v34 < *(int *)(v33 + 4));
  }
  if (*(_BYTE *)(a2 + 21))
    return appendStringInfoString((uint64_t)v3, "%type");
  return result;
}

void *deparseValue(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  char *v10;
  int v11;
  char v12;

  v9 = result;
  switch(*(_DWORD *)a2)
  {
    case 0xDD:
      return (void *)appendStringInfo((uint64_t)result, "%d", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
    case 0xDE:
      goto LABEL_7;
    case 0xDF:
      if ((_DWORD)a3 == 11)
        return (void *)deparseStringLiteral((uint64_t)result, *(char **)(a2 + 8));
      if ((_DWORD)a3 == 10)
      {
        v10 = quote_identifier(*(_BYTE **)(a2 + 8));
        result = v9;
      }
      else
      {
LABEL_7:
        v10 = *(char **)(a2 + 8);
      }
      return appendStringInfoString((uint64_t)result, v10);
    case 0xE0:
      v11 = **(unsigned __int8 **)(a2 + 8);
      if (v11 == 98)
      {
        v12 = 98;
      }
      else
      {
        if (v11 != 120)
          return result;
        v12 = 120;
      }
      appendStringInfoChar((uint64_t)result, v12);
      return (void *)deparseStringLiteral((uint64_t)v9, (char *)(*(_QWORD *)(a2 + 8) + 1));
    case 0xE1:
      v10 = "NULL";
      return appendStringInfoString((uint64_t)result, v10);
    default:
      deparseValue_cold_1((_DWORD *)a2);
  }
}

void *deparseNumericOnly(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 222)
    return appendStringInfoString((uint64_t)result, *(char **)(a2 + 8));
  if (*(_DWORD *)a2 == 221)
    return (void *)appendStringInfo((uint64_t)result, "%d", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  return result;
}

uint64_t deparseOptIndirection(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4;
  int i;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  int *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  if (a2 && *(_DWORD *)(a2 + 4) > a3)
  {
    v4 = result;
    for (i = a3; *(_DWORD *)(a2 + 4) > i; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = *(int **)(v8 + 8 * i);
      v10 = *v9;
      if (*v9 == 352)
      {
        appendStringInfoChar(v4, 91);
        v11 = *((_QWORD *)v9 + 1);
        if (v11)
          deparseExpr(v4, v11);
        if (*((_BYTE *)v9 + 4))
          appendStringInfoChar(v4, 58);
        v12 = *((_QWORD *)v9 + 2);
        if (v12)
          deparseExpr(v4, v12);
        result = appendStringInfoChar(v4, 93);
        continue;
      }
      if (v10 == 351)
      {
        v6 = v4;
        v7 = ".*";
      }
      else
      {
        if (v10 != 223)
          continue;
        appendStringInfoChar(v4, 46);
        v7 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v8 + 8 * i) + 8));
        v6 = v4;
      }
      result = (uint64_t)appendStringInfoString(v6, v7);
    }
  }
  return result;
}

void *deparseSubqueryOp(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  int v6;
  char *v7;
  uint64_t v8;

  if (!a2)
  {
    v5 = "OPERATOR(";
    goto LABEL_17;
  }
  if (*(_DWORD *)(a2 + 4) != 1)
    goto LABEL_11;
  v4 = *(char **)(**(_QWORD **)(a2 + 16) + 8);
  if (!strcmp(v4, "~~"))
    return appendStringInfoString(a1, "LIKE");
  if (!strcmp(v4, "!~~"))
    return appendStringInfoString(a1, "NOT LIKE");
  if (!strcmp(v4, "~~*"))
    return appendStringInfoString(a1, "ILIKE");
  if (!strcmp(v4, "!~~*"))
    return appendStringInfoString(a1, "NOT ILIKE");
  if (!isOp(v4))
  {
LABEL_11:
    appendStringInfoString(a1, "OPERATOR(");
    v6 = *(_DWORD *)(a2 + 4);
    if (v6 == 1)
    {
      v8 = *(_QWORD *)(a2 + 16);
    }
    else
    {
      if (v6 != 2)
        return appendStringInfoString(a1, ")");
      v7 = quote_identifier(*(_BYTE **)(**(_QWORD **)(a2 + 16) + 8));
      appendStringInfoString(a1, v7);
      appendStringInfoChar(a1, 46);
      v8 = *(_QWORD *)(a2 + 16) + 8 * (*(_DWORD *)(a2 + 4) - 1);
    }
    v5 = *(char **)(*(_QWORD *)v8 + 8);
LABEL_17:
    appendStringInfoString(a1, v5);
    return appendStringInfoString(a1, ")");
  }
  return appendStringInfoString(a1, v4);
}

uint64_t deparseIndexElem(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v10;
  char *v11;
  uint64_t result;
  uint64_t v13;
  _DWORD *v14;
  unsigned int v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  int v26;
  char *v27;
  int v28;
  char *v29;
  int v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;

  v10 = *(_BYTE **)(a2 + 8);
  if (v10)
  {
    v11 = quote_identifier(v10);
    appendStringInfoString((uint64_t)a1, v11);
    appendStringInfoChar((uint64_t)a1, 32);
    result = deparseOptCollate((uint64_t)a1, *(_QWORD *)(a2 + 32));
    v13 = *(_QWORD *)(a2 + 40);
    if (!v13)
      goto LABEL_24;
  }
  else
  {
    v14 = *(_DWORD **)(a2 + 16);
    if (v14)
    {
      if ((*v14 - 136) >= 4)
      {
        v15 = *v14 - 350;
        v16 = v15 > 0x23;
        v17 = (1 << v15) & 0x800000081;
        if (v16 || v17 == 0)
        {
          appendStringInfoChar((uint64_t)a1, 40);
          deparseExpr(a1, *(_QWORD *)(a2 + 16));
          appendStringInfoString((uint64_t)a1, ") ");
          result = deparseOptCollate((uint64_t)a1, *(_QWORD *)(a2 + 32));
          v13 = *(_QWORD *)(a2 + 40);
          if (!v13)
            goto LABEL_24;
          goto LABEL_12;
        }
      }
      deparseFuncExprWindowless(a1, (uint64_t)v14, a3, a4, a5, a6, a7, a8);
    }
    result = deparseOptCollate((uint64_t)a1, *(_QWORD *)(a2 + 32));
    v13 = *(_QWORD *)(a2 + 40);
    if (!v13)
      goto LABEL_24;
  }
LABEL_12:
  if (*(int *)(v13 + 4) >= 1)
  {
    v19 = 0;
    v20 = 8;
    do
    {
      v21 = *(_QWORD *)(v13 + 16);
      v22 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v21 + 8 * v19) + 8));
      appendStringInfoString((uint64_t)a1, v22);
      v23 = *(int *)(v13 + 4);
      if (v21 + v20)
        v24 = v21 + v20 >= (unint64_t)(*(_QWORD *)(v13 + 16) + 8 * v23);
      else
        v24 = 1;
      if (!v24)
      {
        appendStringInfoChar((uint64_t)a1, 46);
        v23 = *(int *)(v13 + 4);
      }
      ++v19;
      v20 += 8;
    }
    while (v19 < v23);
    v25 = *(_QWORD *)(a2 + 48);
    if (v25 && *(int *)(v25 + 4) >= 1)
      deparseRelOptions(a1, v25);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
LABEL_24:
  v26 = *(_DWORD *)(a2 + 56);
  if (v26 == 1)
  {
    v27 = "ASC ";
  }
  else
  {
    if (v26 != 2)
      goto LABEL_29;
    v27 = "DESC ";
  }
  result = (uint64_t)appendStringInfoString((uint64_t)a1, v27);
LABEL_29:
  v28 = *(_DWORD *)(a2 + 60);
  if (v28 == 1)
  {
    v29 = "NULLS FIRST ";
  }
  else
  {
    if (v28 != 2)
      goto LABEL_34;
    v29 = "NULLS LAST ";
  }
  result = (uint64_t)appendStringInfoString((uint64_t)a1, v29);
LABEL_34:
  v30 = a1[2];
  v31 = __OFSUB__(v30, 1);
  v32 = (v30 - 1);
  if ((int)v32 < 0 == v31)
  {
    v33 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v32) == 32)
    {
      a1[2] = v32;
      *(_BYTE *)(v33 + v32) = 0;
    }
  }
  return result;
}

uint64_t deparseRangeVar(uint64_t a1, uint64_t a2, int a3)
{
  _BYTE *v7;
  char *v8;
  _BYTE *v9;
  char *v10;
  char *v11;
  uint64_t result;
  uint64_t v13;
  int v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;

  if ((a3 - 10) <= 0xFFFFFFFD && *(_BYTE *)(a2 + 32) == 0)
    appendStringInfoString(a1, "ONLY ");
  v7 = *(_BYTE **)(a2 + 8);
  if (v7)
  {
    v8 = quote_identifier(v7);
    appendStringInfoString(a1, v8);
    appendStringInfoChar(a1, 46);
  }
  v9 = *(_BYTE **)(a2 + 16);
  if (v9)
  {
    v10 = quote_identifier(v9);
    appendStringInfoString(a1, v10);
    appendStringInfoChar(a1, 46);
  }
  v11 = quote_identifier(*(_BYTE **)(a2 + 24));
  appendStringInfoString(a1, v11);
  result = appendStringInfoChar(a1, 32);
  v13 = *(_QWORD *)(a2 + 40);
  if (v13)
  {
    if (a3 == 1)
    {
      appendStringInfoString(a1, "AS ");
      v13 = *(_QWORD *)(a2 + 40);
    }
    deparseAlias(a1, v13);
    result = appendStringInfoChar(a1, 32);
  }
  v14 = *(_DWORD *)(a1 + 8);
  v15 = __OFSUB__(v14, 1);
  v16 = (v14 - 1);
  if ((int)v16 < 0 == v15)
  {
    v17 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v16) == 32)
    {
      *(_DWORD *)(a1 + 8) = v16;
      *(_BYTE *)(v17 + v16) = 0;
    }
  }
  return result;
}

unint64_t deparseSeqOptElem(void *a1, uint64_t a2)
{
  const char *v4;
  unint64_t result;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int v14;
  int v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v4 = *(const char **)(a2 + 16);
  if (!strcmp(v4, "as"))
  {
    appendStringInfoString((uint64_t)a1, "AS ");
    return (unint64_t)deparseTypeName(a1, *(_QWORD *)(a2 + 24));
  }
  if (!strcmp(v4, "cache"))
  {
    result = (unint64_t)appendStringInfoString((uint64_t)a1, "CACHE ");
    v13 = *(int **)(a2 + 24);
    v14 = *v13;
    if (*v13 != 222)
      goto LABEL_23;
    goto LABEL_29;
  }
  if (!strcmp(v4, "cycle"))
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v15)
    {
      v16 = "NO CYCLE";
      return (unint64_t)appendStringInfoString((uint64_t)a1, v16);
    }
    if (v15 == 1)
    {
      v16 = "CYCLE";
      return (unint64_t)appendStringInfoString((uint64_t)a1, v16);
    }
  }
  if (!strcmp(v4, "increment"))
  {
    result = (unint64_t)appendStringInfoString((uint64_t)a1, "INCREMENT ");
    v13 = *(int **)(a2 + 24);
    v14 = *v13;
    if (*v13 != 222)
      goto LABEL_23;
LABEL_29:
    v16 = (char *)*((_QWORD *)v13 + 1);
    return (unint64_t)appendStringInfoString((uint64_t)a1, v16);
  }
  if (!strcmp(v4, "maxvalue"))
  {
    if (!*(_QWORD *)(a2 + 24))
    {
      v16 = "NO MAXVALUE";
      return (unint64_t)appendStringInfoString((uint64_t)a1, v16);
    }
    result = (unint64_t)appendStringInfoString((uint64_t)a1, "MAXVALUE ");
    v13 = *(int **)(a2 + 24);
    v14 = *v13;
    if (*v13 == 222)
      goto LABEL_29;
    goto LABEL_23;
  }
  if (!strcmp(v4, "minvalue"))
  {
    if (!*(_QWORD *)(a2 + 24))
    {
      v16 = "NO MINVALUE";
      return (unint64_t)appendStringInfoString((uint64_t)a1, v16);
    }
    result = (unint64_t)appendStringInfoString((uint64_t)a1, "MINVALUE ");
    v13 = *(int **)(a2 + 24);
    v14 = *v13;
    if (*v13 == 222)
      goto LABEL_29;
LABEL_23:
    if (v14 == 221)
      return appendStringInfo((uint64_t)a1, "%d", v7, v8, v9, v10, v11, v12, v13[2]);
    return result;
  }
  if (!strcmp(v4, "owned_by"))
  {
    result = (unint64_t)appendStringInfoString((uint64_t)a1, "OWNED BY ");
    v17 = *(_QWORD *)(a2 + 24);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v20 + 8 * v18) + 8));
        result = (unint64_t)appendStringInfoString((uint64_t)a1, v21);
        v22 = *(int *)(v17 + 4);
        if (v20 + v19)
          v23 = v20 + v19 >= (unint64_t)(*(_QWORD *)(v17 + 16) + 8 * v22);
        else
          v23 = 1;
        if (!v23)
        {
          result = appendStringInfoChar((uint64_t)a1, 46);
          v22 = *(int *)(v17 + 4);
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < v22);
    }
  }
  else
  {
    if (!strcmp(v4, "sequence_name"))
    {
      appendStringInfoString((uint64_t)a1, "SEQUENCE NAME ");
      return deparseAnyName((uint64_t)a1, *(_QWORD *)(a2 + 24));
    }
    if (!strcmp(v4, "start"))
    {
      v6 = "START ";
      goto LABEL_44;
    }
    result = strcmp(v4, "restart");
    if (!(_DWORD)result)
    {
      if (*(_QWORD *)(a2 + 24))
      {
        v6 = "RESTART ";
LABEL_44:
        appendStringInfoString((uint64_t)a1, v6);
        return (unint64_t)deparseNumericOnly(a1, *(_QWORD *)(a2 + 24), v24, v25, v26, v27, v28, v29);
      }
      v16 = "RESTART";
      return (unint64_t)appendStringInfoString((uint64_t)a1, v16);
    }
  }
  return result;
}

void *deparseFuncExprWindowless(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  char *v19;
  int v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;

  v9 = result;
  v10 = *(_DWORD *)a2;
  if (*(int *)a2 <= 349)
  {
    switch(v10)
    {
      case 136:
        appendStringInfoString((uint64_t)result, "COALESCE(");
        v11 = *(_QWORD *)(a2 + 16);
        if (v11 && *(int *)(v11 + 4) >= 1)
        {
          v12 = 0;
          v13 = 8;
          do
          {
            v14 = *(_QWORD *)(v11 + 16);
            deparseExpr(v9, *(_QWORD *)(v14 + 8 * v12));
            v15 = *(int *)(v11 + 4);
            if (v14 + v13)
              v16 = v14 + v13 >= (unint64_t)(*(_QWORD *)(v11 + 16) + 8 * v15);
            else
              v16 = 1;
            if (!v16)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v15 = *(int *)(v11 + 4);
            }
            ++v12;
            v13 += 8;
          }
          while (v12 < v15);
        }
        goto LABEL_43;
      case 137:
        v20 = *(_DWORD *)(a2 + 16);
        if (v20)
        {
          if (v20 != 1)
            goto LABEL_34;
          v21 = "LEAST(";
        }
        else
        {
          v21 = "GREATEST(";
        }
        appendStringInfoString((uint64_t)result, v21);
LABEL_34:
        v22 = *(_QWORD *)(a2 + 24);
        if (v22 && *(int *)(v22 + 4) >= 1)
        {
          v23 = 0;
          v24 = 8;
          do
          {
            v25 = *(_QWORD *)(v22 + 16);
            deparseExpr(v9, *(_QWORD *)(v25 + 8 * v23));
            v26 = *(int *)(v22 + 4);
            if (v25 + v24)
              v27 = v25 + v24 >= (unint64_t)(*(_QWORD *)(v22 + 16) + 8 * v26);
            else
              v27 = 1;
            if (!v27)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v26 = *(int *)(v22 + 4);
            }
            ++v23;
            v24 += 8;
          }
          while (v23 < v26);
        }
LABEL_43:
        result = (void *)appendStringInfoChar((uint64_t)v9, 41);
        break;
      case 138:
        v17 = *(int *)(a2 + 4);
        if (v17 <= 0xE)
          result = appendStringInfoString((uint64_t)result, (&off_1E264AB80)[v17]);
        if (*(_DWORD *)(a2 + 12) != -1)
          return (void *)appendStringInfo((uint64_t)v9, "(%d)", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
        return result;
      case 139:
        return deparseXmlExpr(result, a2);
      default:
        return result;
    }
    return result;
  }
  switch(v10)
  {
    case 385:
      appendStringInfoString((uint64_t)result, "xmlserialize(");
      v18 = *(_DWORD *)(a2 + 4);
      if (v18)
      {
        if (v18 != 1)
        {
LABEL_31:
          deparseExpr(v9, *(_QWORD *)(a2 + 8));
          appendStringInfoString((uint64_t)v9, " AS ");
          deparseTypeName(v9, *(_QWORD *)(a2 + 16));
          return appendStringInfoString((uint64_t)v9, ")");
        }
        v19 = "content ";
      }
      else
      {
        v19 = "document ";
      }
      appendStringInfoString((uint64_t)v9, v19);
      goto LABEL_31;
    case 357:
      return deparseTypeCast(result, a2);
    case 350:
      return (void *)deparseFuncCall((uint64_t)result, a2);
  }
  return result;
}

uint64_t deparseOptCollate(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  BOOL v9;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    appendStringInfoString(result, "COLLATE ");
    if (*(int *)(a2 + 4) >= 1)
    {
      v4 = 0;
      v5 = 8;
      do
      {
        v6 = *(_QWORD *)(a2 + 16);
        v7 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v6 + 8 * v4) + 8));
        appendStringInfoString(v3, v7);
        v8 = *(int *)(a2 + 4);
        if (v6 + v5)
          v9 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v8);
        else
          v9 = 1;
        if (!v9)
        {
          appendStringInfoChar(v3, 46);
          v8 = *(int *)(a2 + 4);
        }
        ++v4;
        v5 += 8;
      }
      while (v4 < v8);
    }
    return appendStringInfoChar(v3, 32);
  }
  return result;
}

uint64_t deparseRelOptions(void *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _BYTE *v13;
  char *v14;
  _BYTE *v15;
  char *v16;
  uint64_t v17;
  BOOL v18;

  appendStringInfoChar((uint64_t)a1, 40);
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v9 = 0;
    v10 = 8;
    do
    {
      v11 = *(_QWORD *)(a2 + 16);
      v12 = *(_QWORD **)(v11 + 8 * v9);
      v13 = (_BYTE *)v12[1];
      if (v13)
      {
        v14 = quote_identifier(v13);
        appendStringInfoString((uint64_t)a1, v14);
        appendStringInfoChar((uint64_t)a1, 46);
      }
      v15 = (_BYTE *)v12[2];
      if (v15)
      {
        v16 = quote_identifier(v15);
        appendStringInfoString((uint64_t)a1, v16);
        if (v12[2])
        {
          if (v12[3])
            appendStringInfoChar((uint64_t)a1, 61);
        }
      }
      v17 = v12[3];
      if (v17)
        deparseDefArg(a1, v17, 0, v4, v5, v6, v7, v8);
      if (v11 + v10)
        v18 = v11 + v10 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * *(int *)(a2 + 4));
      else
        v18 = 1;
      if (!v18)
        appendStringInfoString((uint64_t)a1, ", ");
      ++v9;
      v10 += 8;
    }
    while (v9 < *(int *)(a2 + 4));
  }
  return appendStringInfoChar((uint64_t)a1, 41);
}

void *deparseDefArg(void *result, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  int v10;
  char *v11;
  int v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  int v17;
  char *v18;
  uint64_t v19;
  char *v20;

  v9 = result;
  v10 = *(_DWORD *)a2;
  if (*(int *)a2 <= 225)
  {
    if ((v10 - 221) < 2)
      return deparseValue(result, a2, 0, a4, a5, a6, a7, a8);
    if (v10 == 223)
    {
      v11 = *(char **)(a2 + 8);
      if ((a3 & 1) != 0 || strcmp(v11, "none"))
      {
        v12 = ScanKeywordLookup(v11, (uint64_t)&ScanKeywords);
        v13 = *v11;
        if (*v11)
        {
          v14 = (unsigned __int8 *)(v11 + 1);
          while ((v13 - 97) < 0x1A || v13 == 95 || (v13 - 48) <= 9)
          {
            v15 = *v14++;
            v13 = v15;
            if (!v15)
              goto LABEL_23;
          }
          return (void *)deparseStringLiteral((uint64_t)v9, v11);
        }
LABEL_23:
        if (v12 < 0 || ScanKeywordCategories[v12] != 3)
          return (void *)deparseStringLiteral((uint64_t)v9, v11);
        result = v9;
        v20 = v11;
        return appendStringInfoString((uint64_t)result, v20);
      }
      return appendStringInfoString((uint64_t)v9, "NONE");
    }
    return result;
  }
  if (v10 != 226)
  {
    if (v10 == 366)
      return deparseTypeName(result, a2);
    return result;
  }
  v16 = *(_DWORD *)(a2 + 4);
  if (v16 == 1)
  {
    v20 = *(char **)(**(_QWORD **)(a2 + 16) + 8);
    return appendStringInfoString((uint64_t)result, v20);
  }
  if (v16 == 2)
  {
    appendStringInfoString((uint64_t)result, "OPERATOR(");
    v17 = *(_DWORD *)(a2 + 4);
    if (v17 == 1)
    {
      v19 = *(_QWORD *)(a2 + 16);
    }
    else
    {
      if (v17 != 2)
        return (void *)appendStringInfoChar((uint64_t)v9, 41);
      v18 = quote_identifier(*(_BYTE **)(**(_QWORD **)(a2 + 16) + 8));
      appendStringInfoString((uint64_t)v9, v18);
      appendStringInfoChar((uint64_t)v9, 46);
      v19 = *(_QWORD *)(a2 + 16) + 8 * (*(_DWORD *)(a2 + 4) - 1);
    }
    appendStringInfoString((uint64_t)v9, *(char **)(*(_QWORD *)v19 + 8));
    return (void *)appendStringInfoChar((uint64_t)v9, 41);
  }
  return result;
}

void *deparseAlias(uint64_t a1, uint64_t a2)
{
  char *v4;
  void *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  BOOL v13;

  v4 = quote_identifier(*(_BYTE **)(a2 + 8));
  result = appendStringInfoString(a1, v4);
  v6 = *(_QWORD *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoChar(a1, 40);
    v7 = *(_QWORD *)(a2 + 16);
    if (v7 && *(int *)(v7 + 4) >= 1)
    {
      v8 = 0;
      v9 = 8;
      do
      {
        v10 = *(_QWORD *)(v7 + 16);
        v11 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v10 + 8 * v8) + 8));
        appendStringInfoString(a1, v11);
        v12 = *(int *)(v7 + 4);
        if (v10 + v9)
          v13 = v10 + v9 >= (unint64_t)(*(_QWORD *)(v7 + 16) + 8 * v12);
        else
          v13 = 1;
        if (!v13)
        {
          appendStringInfoString(a1, ", ");
          v12 = *(int *)(v7 + 4);
        }
        ++v8;
        v9 += 8;
      }
      while (v8 < v12);
    }
    return (void *)appendStringInfoChar(a1, 41);
  }
  return result;
}

uint64_t deparseAggregateWithArgtypes(void *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    v5 = 0;
    v6 = 8;
    do
    {
      v7 = *(_QWORD *)(v4 + 16);
      v8 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v7 + 8 * v5) + 8));
      appendStringInfoString((uint64_t)a1, v8);
      v9 = *(int *)(v4 + 4);
      if (v7 + v6)
        v10 = v7 + v6 >= (unint64_t)(*(_QWORD *)(v4 + 16) + 8 * v9);
      else
        v10 = 1;
      if (!v10)
      {
        appendStringInfoChar((uint64_t)a1, 46);
        v9 = *(int *)(v4 + 4);
      }
      ++v5;
      v6 += 8;
    }
    while (v5 < v9);
  }
  appendStringInfoChar((uint64_t)a1, 40);
  v11 = *(_QWORD *)(a2 + 16);
  if (v11)
  {
    if (*(int *)(v11 + 4) >= 1)
    {
      v12 = 0;
      v13 = 8;
      do
      {
        v14 = *(_QWORD *)(v11 + 16);
        deparseTypeName(a1, *(_QWORD *)(v14 + 8 * v12));
        if (v14 + v13)
          v15 = v14 + v13 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v15 = 1;
        if (!v15)
          appendStringInfoString((uint64_t)a1, ", ");
        ++v12;
        v13 += 8;
      }
      while (v12 < *(int *)(v11 + 4));
    }
  }
  else
  {
    appendStringInfoChar((uint64_t)a1, 42);
  }
  return appendStringInfoChar((uint64_t)a1, 41);
}

uint64_t deparseFunctionWithArgtypes(uint64_t result, uint64_t a2)
{
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  BOOL v16;

  v3 = (_DWORD *)result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    v5 = 0;
    v6 = 8;
    do
    {
      v7 = *(_QWORD *)(v4 + 16);
      v8 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v7 + 8 * v5) + 8));
      result = (uint64_t)appendStringInfoString((uint64_t)v3, v8);
      v9 = *(int *)(v4 + 4);
      if (v7 + v6)
        v10 = v7 + v6 >= (unint64_t)(*(_QWORD *)(v4 + 16) + 8 * v9);
      else
        v10 = 1;
      if (!v10)
      {
        result = appendStringInfoChar((uint64_t)v3, 46);
        v9 = *(int *)(v4 + 4);
      }
      ++v5;
      v6 += 8;
    }
    while (v5 < v9);
  }
  if (!*(_BYTE *)(a2 + 24))
  {
    appendStringInfoChar((uint64_t)v3, 40);
    v11 = *(_QWORD *)(a2 + 16);
    if (v11 && *(int *)(v11 + 4) >= 1)
    {
      v12 = 0;
      v13 = 8;
      do
      {
        v14 = *(_QWORD *)(v11 + 16);
        v15 = *(_DWORD **)(v14 + 8 * v12);
        if (*v15 == 366)
          deparseTypeName(v3, (uint64_t)v15);
        else
          deparseFunctionParameter(v3, (uint64_t)v15);
        if (v14 + v13)
          v16 = v14 + v13 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v16 = 1;
        if (!v16)
          appendStringInfoString((uint64_t)v3, ", ");
        ++v12;
        v13 += 8;
      }
      while (v12 < *(int *)(v11 + 4));
    }
    return appendStringInfoChar((uint64_t)v3, 41);
  }
  return result;
}

uint64_t deparseOperatorWithArgtypes(void *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(a2 + 8);
  if (!v4)
    goto LABEL_7;
  v5 = *(_DWORD *)(v4 + 4);
  if (v5 == 1)
  {
    v7 = *(_QWORD *)(v4 + 16);
  }
  else
  {
    if (v5 != 2)
      goto LABEL_7;
    v6 = quote_identifier(*(_BYTE **)(**(_QWORD **)(v4 + 16) + 8));
    appendStringInfoString((uint64_t)a1, v6);
    appendStringInfoChar((uint64_t)a1, 46);
    v7 = *(_QWORD *)(v4 + 16) + 8 * (*(_DWORD *)(v4 + 4) - 1);
  }
  appendStringInfoString((uint64_t)a1, *(char **)(*(_QWORD *)v7 + 8));
LABEL_7:
  appendStringInfoChar((uint64_t)a1, 40);
  v8 = **(_QWORD **)(*(_QWORD *)(a2 + 16) + 16);
  if (v8)
    deparseTypeName(a1, v8);
  else
    appendStringInfoString((uint64_t)a1, "NONE");
  appendStringInfoString((uint64_t)a1, ", ");
  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8);
  if (v9)
    deparseTypeName(a1, v9);
  else
    appendStringInfoString((uint64_t)a1, "NONE");
  return appendStringInfoChar((uint64_t)a1, 41);
}

uint64_t deparseFunctionParameter(_DWORD *a1, uint64_t a2)
{
  int v4;
  char *v5;
  char *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_DWORD *)(a2 + 24);
  switch(v4)
  {
    case 'v':
      v5 = "VARIADIC ";
      break;
    case 'o':
      v5 = "OUT ";
      break;
    case 'b':
      v5 = "INOUT ";
      break;
    default:
      goto LABEL_8;
  }
  appendStringInfoString((uint64_t)a1, v5);
LABEL_8:
  v6 = *(char **)(a2 + 8);
  if (v6)
  {
    appendStringInfoString((uint64_t)a1, v6);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  deparseTypeName(a1, *(_QWORD *)(a2 + 16));
  result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfoString((uint64_t)a1, "= ");
    result = (uint64_t)deparseExpr(a1, *(int **)(a2 + 32), v8, v9, v10, v11, v12, v13);
  }
  v14 = a1[2];
  v15 = __OFSUB__(v14, 1);
  v16 = (v14 - 1);
  if ((int)v16 < 0 == v15)
  {
    v17 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v16) == 32)
    {
      a1[2] = v16;
      *(_BYTE *)(v17 + v16) = 0;
    }
  }
  return result;
}

uint64_t deparseFdwOptions(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  BOOL v21;
  char *v22;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    v4 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(a2 + 16) + 8 * v4;
      v6 = *(_QWORD *)v5;
      v7 = *(const char **)(*(_QWORD *)v5 + 16);
      if (!strcmp(v7, "handler"))
        break;
      result = strcmp(v7, "validator");
      if (!(_DWORD)result)
      {
        if (*(_QWORD *)(v6 + 24))
        {
          result = (uint64_t)appendStringInfoString(v3, "VALIDATOR ");
          v8 = *(_QWORD *)(v6 + 24);
          if (v8 && *(int *)(v8 + 4) >= 1)
          {
            v9 = 0;
            v10 = 8;
            do
            {
              v11 = *(_QWORD *)(v8 + 16);
              v12 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v11 + 8 * v9) + 8));
              result = (uint64_t)appendStringInfoString(v3, v12);
              v13 = *(int *)(v8 + 4);
              if (v11 + v10)
                v14 = v11 + v10 >= (unint64_t)(*(_QWORD *)(v8 + 16) + 8 * v13);
              else
                v14 = 1;
              if (!v14)
              {
                result = appendStringInfoChar(v3, 46);
                v13 = *(int *)(v8 + 4);
              }
              ++v9;
              v10 += 8;
            }
            while (v9 < v13);
          }
          goto LABEL_30;
        }
        v22 = "NO VALIDATOR ";
        goto LABEL_29;
      }
LABEL_30:
      if (v5 != -8 && v5 + 8 < (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * *(int *)(a2 + 4)))
        result = appendStringInfoChar(v3, 32);
      if (++v4 >= *(int *)(a2 + 4))
        return result;
    }
    if (*(_QWORD *)(v6 + 24))
    {
      result = (uint64_t)appendStringInfoString(v3, "HANDLER ");
      v15 = *(_QWORD *)(v6 + 24);
      if (v15 && *(int *)(v15 + 4) >= 1)
      {
        v16 = 0;
        v17 = 8;
        do
        {
          v18 = *(_QWORD *)(v15 + 16);
          v19 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v18 + 8 * v16) + 8));
          result = (uint64_t)appendStringInfoString(v3, v19);
          v20 = *(int *)(v15 + 4);
          if (v18 + v17)
            v21 = v18 + v17 >= (unint64_t)(*(_QWORD *)(v15 + 16) + 8 * v20);
          else
            v21 = 1;
          if (!v21)
          {
            result = appendStringInfoChar(v3, 46);
            v20 = *(int *)(v15 + 4);
          }
          ++v16;
          v17 += 8;
        }
        while (v16 < v20);
      }
      goto LABEL_30;
    }
    v22 = "NO HANDLER ";
LABEL_29:
    result = (uint64_t)appendStringInfoString(v3, v22);
    goto LABEL_30;
  }
  return result;
}

void *deparseAlterGenericOptions(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  BOOL v12;

  appendStringInfoString(a1, "OPTIONS (");
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v6 + 8 * v4);
      switch(*(_DWORD *)(v7 + 32))
      {
        case 0:
          goto LABEL_9;
        case 1:
          v8 = a1;
          v9 = "SET ";
          goto LABEL_8;
        case 2:
          v8 = a1;
          v9 = "ADD ";
LABEL_8:
          appendStringInfoString(v8, v9);
LABEL_9:
          v10 = quote_identifier(*(_BYTE **)(v7 + 16));
          appendStringInfoString(a1, v10);
          appendStringInfoChar(a1, 32);
          deparseStringLiteral(a1, *(char **)(*(_QWORD *)(v7 + 24) + 8));
          break;
        case 3:
          appendStringInfoString(a1, "DROP ");
          v11 = quote_identifier(*(_BYTE **)(v7 + 16));
          appendStringInfoString(a1, v11);
          break;
        default:
          break;
      }
      if (v6 + v5)
        v12 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * *(int *)(a2 + 4));
      else
        v12 = 1;
      if (!v12)
        appendStringInfoString(a1, ", ");
      ++v4;
      v5 += 8;
    }
    while (v4 < *(int *)(a2 + 4));
  }
  return appendStringInfoString(a1, ") ");
}

uint64_t deparseCommonFuncOptItem(void *a1, uint64_t a2)
{
  const char *v4;
  _DWORD *v5;
  uint64_t result;
  int v7;
  const char *v8;
  int v9;
  int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  BOOL v24;

  v4 = *(const char **)(a2 + 16);
  if (!strcmp(v4, "strict"))
  {
    v7 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v7)
      return (uint64_t)appendStringInfoString((uint64_t)a1, "CALLED ON NULL INPUT");
    if (v7 == 1)
      return (uint64_t)appendStringInfoString((uint64_t)a1, "RETURNS NULL ON NULL INPUT");
  }
  if (!strcmp(v4, "volatility"))
  {
    v8 = *(const char **)(*(_QWORD *)(a2 + 24) + 8);
    if (!strcmp(v8, "immutable"))
      return (uint64_t)appendStringInfoString((uint64_t)a1, "IMMUTABLE");
    if (!strcmp(v8, "stable"))
      return (uint64_t)appendStringInfoString((uint64_t)a1, "STABLE");
    if (!strcmp(v8, "volatile"))
      return (uint64_t)appendStringInfoString((uint64_t)a1, "VOLATILE");
  }
  if (!strcmp(v4, "security"))
  {
    v9 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v9)
      return (uint64_t)appendStringInfoString((uint64_t)a1, "SECURITY INVOKER");
    if (v9 == 1)
      return (uint64_t)appendStringInfoString((uint64_t)a1, "SECURITY DEFINER");
  }
  if (!strcmp(v4, "leakproof"))
  {
    v10 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v10)
      return (uint64_t)appendStringInfoString((uint64_t)a1, "NOT LEAKPROOF");
    if (v10 == 1)
      return (uint64_t)appendStringInfoString((uint64_t)a1, "LEAKPROOF");
  }
  if (!strcmp(v4, "cost"))
  {
    v11 = "COST ";
LABEL_28:
    appendStringInfoString((uint64_t)a1, v11);
    return (uint64_t)deparseValue(a1, *(_QWORD *)(a2 + 24), 0, v12, v13, v14, v15, v16);
  }
  if (!strcmp(v4, "rows"))
  {
    v11 = "ROWS ";
    goto LABEL_28;
  }
  if (!strcmp(v4, "support"))
  {
    result = (uint64_t)appendStringInfoString((uint64_t)a1, "SUPPORT ");
    v18 = *(_QWORD *)(a2 + 24);
    if (v18 && *(int *)(v18 + 4) >= 1)
    {
      v19 = 0;
      v20 = 8;
      do
      {
        v21 = *(_QWORD *)(v18 + 16);
        v22 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v21 + 8 * v19) + 8));
        result = (uint64_t)appendStringInfoString((uint64_t)a1, v22);
        v23 = *(int *)(v18 + 4);
        if (v21 + v20)
          v24 = v21 + v20 >= (unint64_t)(*(_QWORD *)(v18 + 16) + 8 * v23);
        else
          v24 = 1;
        if (!v24)
        {
          result = appendStringInfoChar((uint64_t)a1, 46);
          v23 = *(int *)(v18 + 4);
        }
        ++v19;
        v20 += 8;
      }
      while (v19 < v23);
    }
  }
  else if (!strcmp(v4, "set") && (v5 = *(_DWORD **)(a2 + 24), *v5 == 273))
  {
    return deparseVariableSetStmt((uint64_t)a1, (uint64_t)v5);
  }
  else
  {
    result = strcmp(v4, "parallel");
    if (!(_DWORD)result)
    {
      appendStringInfoString((uint64_t)a1, "PARALLEL ");
      v17 = quote_identifier(*(_BYTE **)(*(_QWORD *)(a2 + 24) + 8));
      return (uint64_t)appendStringInfoString((uint64_t)a1, v17);
    }
  }
  return result;
}

void *deparseOperatorDefList(void *result, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v6 + 8 * v4);
      v8 = quote_identifier(*(_BYTE **)(v7 + 16));
      appendStringInfoString((uint64_t)v3, v8);
      appendStringInfoString((uint64_t)v3, " = ");
      v14 = *(_QWORD *)(v7 + 24);
      if (v14)
      {
        result = deparseDefArg(v3, v14, 1, v9, v10, v11, v12, v13);
        v15 = *(int *)(a2 + 4);
        v16 = v6 + v5;
        if (v6 + v5)
          goto LABEL_9;
      }
      else
      {
        result = appendStringInfoString((uint64_t)v3, "NONE");
        v15 = *(int *)(a2 + 4);
        v16 = v6 + v5;
        if (v6 + v5)
        {
LABEL_9:
          if (v16 < *(_QWORD *)(a2 + 16) + 8 * v15)
          {
            result = appendStringInfoString((uint64_t)v3, ", ");
            v15 = *(int *)(a2 + 4);
          }
        }
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v15);
  }
  return result;
}

uint64_t deparseColumnDef(uint64_t result, _QWORD *a2)
{
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;

  v3 = (_DWORD *)result;
  v4 = (char *)a2[1];
  if (v4)
  {
    appendStringInfoString(result, v4);
    result = appendStringInfoChar((uint64_t)v3, 32);
  }
  v5 = a2[2];
  if (v5)
  {
    deparseTypeName(v3, v5);
    result = appendStringInfoChar((uint64_t)v3, 32);
  }
  if (a2[4])
  {
    appendStringInfoString((uint64_t)v3, "USING ");
    deparseExpr(v3, a2[4]);
    result = appendStringInfoChar((uint64_t)v3, 32);
  }
  v6 = a2[12];
  if (v6)
  {
    deparseCreateGenericOptions(v3, v6);
    result = appendStringInfoChar((uint64_t)v3, 32);
  }
  v7 = a2[11];
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    v8 = 0;
    do
    {
      deparseConstraint(v3, *(_QWORD *)(*(_QWORD *)(v7 + 16) + 8 * v8));
      result = appendStringInfoChar((uint64_t)v3, 32);
      ++v8;
    }
    while (v8 < *(int *)(v7 + 4));
  }
  v9 = a2[9];
  if (v9)
    result = deparseCollateClause((uint64_t)v3, v9);
  v10 = v3[2];
  v11 = __OFSUB__(v10, 1);
  v12 = (v10 - 1);
  if ((int)v12 < 0 == v11)
  {
    v13 = *(_QWORD *)v3;
    if (*(_BYTE *)(*(_QWORD *)v3 + v12) == 32)
    {
      v3[2] = v12;
      *(_BYTE *)(v13 + v12) = 0;
    }
  }
  return result;
}

void *deparsePartitionBoundSpec(void *a1, uint64_t a2)
{
  void *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;

  if (*(_BYTE *)(a2 + 5))
    return appendStringInfoString((uint64_t)a1, "DEFAULT");
  result = appendStringInfoString((uint64_t)a1, "FOR VALUES ");
  v11 = *(char *)(a2 + 4);
  switch(v11)
  {
    case 'r':
      appendStringInfoString((uint64_t)a1, "FROM (");
      v18 = *(_QWORD *)(a2 + 24);
      if (v18 && *(int *)(v18 + 4) >= 1)
      {
        v19 = 0;
        v20 = 8;
        do
        {
          v21 = *(_QWORD *)(v18 + 16);
          deparseExpr(a1, *(int **)(v21 + 8 * v19), v12, v13, v14, v15, v16, v17);
          v22 = *(int *)(v18 + 4);
          if (v21 + v20)
            v23 = v21 + v20 >= (unint64_t)(*(_QWORD *)(v18 + 16) + 8 * v22);
          else
            v23 = 1;
          if (!v23)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            v22 = *(int *)(v18 + 4);
          }
          ++v19;
          v20 += 8;
        }
        while (v19 < v22);
      }
      appendStringInfoString((uint64_t)a1, ") TO (");
      v42 = *(_QWORD *)(a2 + 32);
      if (v42 && *(int *)(v42 + 4) >= 1)
      {
        v43 = 0;
        v44 = 8;
        do
        {
          v45 = *(_QWORD *)(v42 + 16);
          deparseExpr(a1, *(int **)(v45 + 8 * v43), v36, v37, v38, v39, v40, v41);
          v46 = *(int *)(v42 + 4);
          if (v45 + v44)
            v47 = v45 + v44 >= (unint64_t)(*(_QWORD *)(v42 + 16) + 8 * v46);
          else
            v47 = 1;
          if (!v47)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            v46 = *(int *)(v42 + 4);
          }
          ++v43;
          v44 += 8;
        }
        while (v43 < v46);
      }
      return (void *)appendStringInfoChar((uint64_t)a1, 41);
    case 'l':
      appendStringInfoString((uint64_t)a1, "IN (");
      v30 = *(_QWORD *)(a2 + 16);
      if (v30 && *(int *)(v30 + 4) >= 1)
      {
        v31 = 0;
        v32 = 8;
        do
        {
          v33 = *(_QWORD *)(v30 + 16);
          deparseExpr(a1, *(int **)(v33 + 8 * v31), v24, v25, v26, v27, v28, v29);
          v34 = *(int *)(v30 + 4);
          if (v33 + v32)
            v35 = v33 + v32 >= (unint64_t)(*(_QWORD *)(v30 + 16) + 8 * v34);
          else
            v35 = 1;
          if (!v35)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            v34 = *(int *)(v30 + 4);
          }
          ++v31;
          v32 += 8;
        }
        while (v31 < v34);
      }
      return (void *)appendStringInfoChar((uint64_t)a1, 41);
    case 'h':
      return (void *)appendStringInfo((uint64_t)a1, "WITH (MODULUS %d, REMAINDER %d)", v5, v6, v7, v8, v9, v10, *(unsigned int *)(a2 + 8));
  }
  return result;
}

void *deparseCreateGenericOptions(void *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  BOOL v10;

  if (a2)
  {
    v3 = (uint64_t)result;
    appendStringInfoString((uint64_t)result, "OPTIONS (");
    if (*(int *)(a2 + 4) >= 1)
    {
      v4 = 0;
      v5 = 8;
      do
      {
        v6 = *(_QWORD *)(a2 + 16);
        v7 = *(_QWORD *)(v6 + 8 * v4);
        v8 = quote_identifier(*(_BYTE **)(v7 + 16));
        appendStringInfoString(v3, v8);
        appendStringInfoChar(v3, 32);
        deparseStringLiteral(v3, *(char **)(*(_QWORD *)(v7 + 24) + 8));
        v9 = *(int *)(a2 + 4);
        if (v6 + v5)
          v10 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v9);
        else
          v10 = 1;
        if (!v10)
        {
          appendStringInfoString(v3, ", ");
          v9 = *(int *)(a2 + 4);
        }
        ++v4;
        v5 += 8;
      }
      while (v4 < v9);
    }
    return appendStringInfoString(v3, ") ");
  }
  return result;
}

uint64_t deparseDefinition(void *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;

  appendStringInfoChar((uint64_t)a1, 40);
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v6 + 8 * v4);
      v8 = quote_identifier(*(_BYTE **)(v7 + 16));
      appendStringInfoString((uint64_t)a1, v8);
      if (*(_QWORD *)(v7 + 24))
      {
        appendStringInfoString((uint64_t)a1, " = ");
        deparseDefArg(a1, *(_QWORD *)(v7 + 24), 0, v9, v10, v11, v12, v13);
      }
      v14 = *(int *)(a2 + 4);
      if (v6 + v5)
        v15 = v6 + v5 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v14);
      else
        v15 = 1;
      if (!v15)
      {
        appendStringInfoString((uint64_t)a1, ", ");
        v14 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v14);
  }
  return appendStringInfoChar((uint64_t)a1, 41);
}

unint64_t deparseAlterRoleElem(uint64_t a1, uint64_t a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t result;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;

  v4 = *(const char **)(a2 + 16);
  if (!strcmp(v4, "password"))
  {
    result = (unint64_t)appendStringInfoString(a1, "PASSWORD ");
    v19 = *(_QWORD *)(a2 + 24);
    if (!v19)
      return (unint64_t)appendStringInfoString(a1, "NULL");
    if (*(_DWORD *)v19 != 223)
    {
      if (*(_DWORD *)v19 == 348)
      {
        v20 = *(unsigned int *)(v19 + 4);
        if ((_DWORD)v20)
          return appendStringInfo(a1, "$%d", v13, v14, v15, v16, v17, v18, v20);
        else
          return appendStringInfoChar(a1, 63);
      }
      return result;
    }
    return deparseStringLiteral(a1, *(char **)(v19 + 8));
  }
  if (!strcmp(v4, "connectionlimit"))
    return appendStringInfo(a1, "CONNECTION LIMIT %d", v5, v6, v7, v8, v9, v10, *(unsigned int *)(*(_QWORD *)(a2 + 24) + 8));
  if (!strcmp(v4, "validUntil"))
  {
    appendStringInfoString(a1, "VALID UNTIL ");
    v19 = *(_QWORD *)(a2 + 24);
    return deparseStringLiteral(a1, *(char **)(v19 + 8));
  }
  if (!strcmp(v4, "superuser"))
  {
    v21 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v21)
      return (unint64_t)appendStringInfoString(a1, "NOSUPERUSER");
    if (v21 == 1)
      return (unint64_t)appendStringInfoString(a1, "SUPERUSER");
  }
  if (!strcmp(v4, "createrole"))
  {
    v22 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v22)
      return (unint64_t)appendStringInfoString(a1, "NOCREATEROLE");
    if (v22 == 1)
      return (unint64_t)appendStringInfoString(a1, "CREATEROLE");
  }
  if (!strcmp(v4, "isreplication"))
  {
    v23 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v23)
      return (unint64_t)appendStringInfoString(a1, "NOREPLICATION");
    if (v23 == 1)
      return (unint64_t)appendStringInfoString(a1, "REPLICATION");
  }
  if (!strcmp(v4, "createdb"))
  {
    v24 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v24)
      return (unint64_t)appendStringInfoString(a1, "NOCREATEDB");
    if (v24 == 1)
      return (unint64_t)appendStringInfoString(a1, "CREATEDB");
  }
  if (!strcmp(v4, "canlogin"))
  {
    v25 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v25)
      return (unint64_t)appendStringInfoString(a1, "NOLOGIN");
    if (v25 == 1)
      return (unint64_t)appendStringInfoString(a1, "LOGIN");
  }
  if (!strcmp(v4, "bypassrls"))
  {
    v26 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (!v26)
      return (unint64_t)appendStringInfoString(a1, "NOBYPASSRLS");
    if (v26 == 1)
      return (unint64_t)appendStringInfoString(a1, "BYPASSRLS");
  }
  result = strcmp(v4, "inherit");
  if (!(_DWORD)result)
  {
    v12 = *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8);
    if (v12)
    {
      if (v12 == 1)
        return (unint64_t)appendStringInfoString(a1, "INHERIT");
    }
    else
    {
      return (unint64_t)appendStringInfoString(a1, "NOINHERIT");
    }
  }
  return result;
}

uint64_t deparseAnyNameList(uint64_t result, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;

  if (a2)
  {
    v3 = *(_DWORD *)(a2 + 4);
    if (v3 >= 1)
    {
      v4 = result;
      for (i = 0; i < v3; ++i)
      {
        while (1)
        {
          v6 = *(_QWORD *)(a2 + 16);
          v7 = (uint64_t *)(v6 + 8 * i);
          v8 = *v7;
          if (*v7 && *(int *)(v8 + 4) >= 1)
          {
            v9 = 0;
            v10 = 8;
            do
            {
              v11 = *(_QWORD *)(v8 + 16);
              v12 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v11 + 8 * v9) + 8));
              result = (uint64_t)appendStringInfoString(v4, v12);
              v13 = *(int *)(v8 + 4);
              if (v11 + v10)
                v14 = v11 + v10 >= (unint64_t)(*(_QWORD *)(v8 + 16) + 8 * v13);
              else
                v14 = 1;
              if (!v14)
              {
                result = appendStringInfoChar(v4, 46);
                v13 = *(int *)(v8 + 4);
              }
              ++v9;
              v10 += 8;
            }
            while (v9 < v13);
            v3 = *(_DWORD *)(a2 + 4);
            v6 = *(_QWORD *)(a2 + 16);
          }
          v15 = v6 + 8 * v3;
          if (v7 == (uint64_t *)-8 || (unint64_t)(v7 + 1) >= v15)
            break;
          result = (uint64_t)appendStringInfoString(v4, ", ");
          v3 = *(_DWORD *)(a2 + 4);
          if (++i >= v3)
            return result;
        }
      }
    }
  }
  return result;
}

uint64_t deparseIntoClause(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t result;
  char *v13;
  uint64_t v14;
  unsigned int v15;
  char *v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;

  deparseRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), 0);
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    v5 = *(_QWORD *)(a2 + 16);
    if (v5 && *(int *)(v5 + 4) >= 1)
    {
      v6 = 0;
      v7 = 8;
      do
      {
        v8 = *(_QWORD *)(v5 + 16);
        v9 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v8 + 8 * v6) + 8));
        appendStringInfoString((uint64_t)a1, v9);
        v10 = *(int *)(v5 + 4);
        if (v8 + v7)
          v11 = v8 + v7 >= (unint64_t)(*(_QWORD *)(v5 + 16) + 8 * v10);
        else
          v11 = 1;
        if (!v11)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          v10 = *(int *)(v5 + 4);
        }
        ++v6;
        v7 += 8;
      }
      while (v6 < v10);
    }
    appendStringInfoChar((uint64_t)a1, 41);
  }
  result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    v13 = quote_identifier(*(_BYTE **)(a2 + 24));
    appendStringInfoString((uint64_t)a1, v13);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v14 = *(_QWORD *)(a2 + 32);
  if (v14 && *(int *)(v14 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v14);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v15 = *(_DWORD *)(a2 + 40) - 1;
  if (v15 <= 2)
    result = (uint64_t)appendStringInfoString((uint64_t)a1, (&off_1E264ABF8)[v15]);
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfoString((uint64_t)a1, "TABLESPACE ");
    v16 = quote_identifier(*(_BYTE **)(a2 + 48));
    appendStringInfoString((uint64_t)a1, v16);
    result = appendStringInfoChar((uint64_t)a1, 32);
  }
  v17 = a1[2];
  v18 = __OFSUB__(v17, 1);
  v19 = (v17 - 1);
  if ((int)v19 < 0 == v18)
  {
    v20 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v19) == 32)
    {
      a1[2] = v19;
      *(_BYTE *)(v20 + v19) = 0;
    }
  }
  return result;
}

unint64_t deparseOpclassItemList(unint64_t result, uint64_t a2)
{
  _DWORD *v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  BOOL v44;
  int v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = (_DWORD *)result;
    for (i = 0; i < *(int *)(a2 + 4); ++i)
    {
      v5 = *(_QWORD *)(a2 + 16) + 8 * i;
      v6 = *(_QWORD *)v5;
      v7 = *(_DWORD *)(*(_QWORD *)v5 + 4);
      switch(v7)
      {
        case 3:
          appendStringInfoString((uint64_t)v3, "STORAGE ");
          result = (unint64_t)deparseTypeName(v3, *(_QWORD *)(v6 + 40));
          break;
        case 2:
          appendStringInfoString((uint64_t)v3, "FUNCTION ");
          result = appendStringInfo((uint64_t)v3, "%d ", v15, v16, v17, v18, v19, v20, *(unsigned int *)(v6 + 16));
          if (*(_QWORD *)(v6 + 32))
          {
            appendStringInfoChar((uint64_t)v3, 40);
            v21 = *(_QWORD *)(v6 + 32);
            if (v21 && *(int *)(v21 + 4) >= 1)
            {
              v22 = 0;
              v23 = 8;
              do
              {
                v24 = *(_QWORD *)(v21 + 16);
                deparseTypeName(v3, *(_QWORD *)(v24 + 8 * v22));
                v25 = *(int *)(v21 + 4);
                if (v24 + v23)
                  v26 = v24 + v23 >= (unint64_t)(*(_QWORD *)(v21 + 16) + 8 * v25);
                else
                  v26 = 1;
                if (!v26)
                {
                  appendStringInfoString((uint64_t)v3, ", ");
                  v25 = *(int *)(v21 + 4);
                }
                ++v22;
                v23 += 8;
              }
              while (v22 < v25);
            }
            result = (unint64_t)appendStringInfoString((uint64_t)v3, ") ");
          }
          v27 = *(_QWORD *)(v6 + 8);
          if (v27)
            result = deparseFunctionWithArgtypes((uint64_t)v3, v27);
          goto LABEL_53;
        case 1:
          appendStringInfoString((uint64_t)v3, "OPERATOR ");
          result = appendStringInfo((uint64_t)v3, "%d ", v8, v9, v10, v11, v12, v13, *(unsigned int *)(v6 + 16));
          v14 = *(_QWORD *)(v6 + 8);
          if (v14)
          {
            if (*(_QWORD *)(v14 + 16))
            {
              deparseOperatorWithArgtypes(v3, v14);
              goto LABEL_31;
            }
            v28 = *(_QWORD *)(v14 + 8);
            if (v28)
            {
              v29 = *(_DWORD *)(v28 + 4);
              if (v29 == 1)
              {
                v31 = *(_QWORD *)(v28 + 16);
LABEL_30:
                appendStringInfoString((uint64_t)v3, *(char **)(*(_QWORD *)v31 + 8));
              }
              else if (v29 == 2)
              {
                v30 = quote_identifier(*(_BYTE **)(**(_QWORD **)(v28 + 16) + 8));
                appendStringInfoString((uint64_t)v3, v30);
                appendStringInfoChar((uint64_t)v3, 46);
                v31 = *(_QWORD *)(v28 + 16) + 8 * (*(_DWORD *)(v28 + 4) - 1);
                goto LABEL_30;
              }
            }
LABEL_31:
            result = appendStringInfoChar((uint64_t)v3, 32);
          }
          if (*(_QWORD *)(v6 + 24))
          {
            result = (unint64_t)appendStringInfoString((uint64_t)v3, "FOR ORDER BY ");
            v32 = *(_QWORD *)(v6 + 24);
            if (v32)
            {
              if (*(int *)(v32 + 4) >= 1)
              {
                v33 = 0;
                v34 = 8;
                do
                {
                  v35 = *(_QWORD *)(v32 + 16);
                  v36 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v35 + 8 * v33) + 8));
                  result = (unint64_t)appendStringInfoString((uint64_t)v3, v36);
                  v37 = *(int *)(v32 + 4);
                  if (v35 + v34)
                    v38 = v35 + v34 >= (unint64_t)(*(_QWORD *)(v32 + 16) + 8 * v37);
                  else
                    v38 = 1;
                  if (!v38)
                  {
                    result = appendStringInfoChar((uint64_t)v3, 46);
                    v37 = *(int *)(v32 + 4);
                  }
                  ++v33;
                  v34 += 8;
                }
                while (v33 < v37);
              }
            }
          }
          if (*(_QWORD *)(v6 + 32))
          {
            appendStringInfoChar((uint64_t)v3, 40);
            v39 = *(_QWORD *)(v6 + 32);
            if (v39 && *(int *)(v39 + 4) >= 1)
            {
              v40 = 0;
              v41 = 8;
              do
              {
                v42 = *(_QWORD *)(v39 + 16);
                deparseTypeName(v3, *(_QWORD *)(v42 + 8 * v40));
                v43 = *(int *)(v39 + 4);
                if (v42 + v41)
                  v44 = v42 + v41 >= (unint64_t)(*(_QWORD *)(v39 + 16) + 8 * v43);
                else
                  v44 = 1;
                if (!v44)
                {
                  appendStringInfoString((uint64_t)v3, ", ");
                  v43 = *(int *)(v39 + 4);
                }
                ++v40;
                v41 += 8;
              }
              while (v40 < v43);
            }
            result = appendStringInfoChar((uint64_t)v3, 41);
          }
LABEL_53:
          v45 = v3[2];
          v46 = __OFSUB__(v45, 1);
          v47 = (v45 - 1);
          if ((int)v47 < 0 == v46)
          {
            v48 = *(_QWORD *)v3;
            if (*(_BYTE *)(*(_QWORD *)v3 + v47) == 32)
            {
              v3[2] = v47;
              *(_BYTE *)(v48 + v47) = 0;
            }
          }
          break;
      }
      if (v5 != -8 && v5 + 8 < (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * *(int *)(a2 + 4)))
        result = (unint64_t)appendStringInfoString((uint64_t)v3, ", ");
    }
  }
  return result;
}

_DWORD *deparseTableRef(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  _BOOL4 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  char *v65;
  int v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  BOOL v80;
  int v81;
  uint64_t v82;
  uint64_t v83;

  v9 = result;
  v10 = *(_DWORD *)a2;
  switch(*(_DWORD *)a2)
  {
    case 0x169:
      if (*(_BYTE *)(a2 + 4))
        appendStringInfoString((uint64_t)result, "LATERAL ");
      appendStringInfoChar((uint64_t)v9, 40);
      deparseSelectStmt(v9, *(_QWORD *)(a2 + 8));
      result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 41);
      if (*(_QWORD *)(a2 + 16))
      {
        appendStringInfoChar((uint64_t)v9, 32);
        return deparseAlias((uint64_t)v9, *(_QWORD *)(a2 + 16));
      }
      return result;
    case 0x16A:
      if (*(_BYTE *)(a2 + 4))
        appendStringInfoString((uint64_t)result, "LATERAL ");
      if (*(_BYTE *)(a2 + 6))
      {
        appendStringInfoString((uint64_t)v9, "ROWS FROM ");
        appendStringInfoChar((uint64_t)v9, 40);
        v17 = *(_QWORD *)(a2 + 8);
        if (v17 && *(int *)(v17 + 4) >= 1)
        {
          v18 = 0;
          do
          {
            v19 = *(_QWORD *)(v17 + 16) + 8 * v18;
            v20 = *(_QWORD *)v19;
            deparseFuncExprWindowless(v9, **(_QWORD **)(*(_QWORD *)v19 + 16), v11, v12, v13, v14, v15, v16);
            appendStringInfoChar((uint64_t)v9, 32);
            v21 = *(_QWORD *)(*(_QWORD *)(v20 + 16) + 8);
            if (v21 && *(int *)(v21 + 4) >= 1)
            {
              appendStringInfoString((uint64_t)v9, "AS (");
              if (*(int *)(v21 + 4) >= 1)
              {
                v22 = 0;
                v23 = 8;
                do
                {
                  v24 = *(_QWORD *)(v21 + 16);
                  deparseColumnDef((uint64_t)v9, *(_QWORD **)(v24 + 8 * v22));
                  v25 = *(int *)(v21 + 4);
                  if (v24 + v23)
                    v26 = v24 + v23 >= (unint64_t)(*(_QWORD *)(v21 + 16) + 8 * v25);
                  else
                    v26 = 1;
                  if (!v26)
                  {
                    appendStringInfoString((uint64_t)v9, ", ");
                    v25 = *(int *)(v21 + 4);
                  }
                  ++v22;
                  v23 += 8;
                }
                while (v22 < v25);
              }
              appendStringInfoChar((uint64_t)v9, 41);
            }
            if (v19 != -8
              && v19 + 8 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                            + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4)))
            {
              appendStringInfoString((uint64_t)v9, ", ");
            }
            ++v18;
          }
          while (v18 < *(int *)(v17 + 4));
        }
        appendStringInfoChar((uint64_t)v9, 41);
        result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(_BYTE *)(a2 + 5))
          goto LABEL_73;
      }
      else
      {
        deparseFuncExprWindowless(v9, **(_QWORD **)(**(_QWORD **)(*(_QWORD *)(a2 + 8) + 16) + 16), a3, a4, a5, a6, a7, a8);
        result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(_BYTE *)(a2 + 5))
          goto LABEL_73;
      }
      result = appendStringInfoString((uint64_t)v9, "WITH ORDINALITY ");
LABEL_73:
      v52 = *(_QWORD *)(a2 + 16);
      if (v52)
      {
        deparseAlias((uint64_t)v9, v52);
        result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
      }
      v53 = *(_QWORD *)(a2 + 24);
      if (v53 && *(int *)(v53 + 4) >= 1)
      {
        if (!*(_QWORD *)(a2 + 16))
          appendStringInfoString((uint64_t)v9, "AS ");
        appendStringInfoChar((uint64_t)v9, 40);
        v54 = *(_QWORD *)(a2 + 24);
        if (v54 && *(int *)(v54 + 4) >= 1)
        {
          v55 = 0;
          v56 = 8;
          do
          {
            v57 = *(_QWORD *)(v54 + 16);
            deparseColumnDef((uint64_t)v9, *(_QWORD **)(v57 + 8 * v55));
            if (v57 + v56)
              v58 = v57 + v56 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                                  + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
            else
              v58 = 1;
            if (!v58)
              appendStringInfoString((uint64_t)v9, ", ");
            ++v55;
            v56 += 8;
          }
          while (v55 < *(int *)(v54 + 4));
        }
        result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 41);
      }
      goto LABEL_145;
    case 0x16B:
      deparseRangeVar((uint64_t)result, *(_QWORD *)(a2 + 8), 0);
      appendStringInfoString((uint64_t)v9, " TABLESAMPLE ");
      v28 = *(_QWORD *)(a2 + 16);
      if (v28 && *(int *)(v28 + 4) >= 1)
      {
        v29 = 0;
        v30 = 8;
        do
        {
          v31 = *(_QWORD *)(v28 + 16);
          v32 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v31 + 8 * v29) + 8));
          appendStringInfoString((uint64_t)v9, v32);
          v33 = *(int *)(v28 + 4);
          if (v31 + v30)
            v34 = v31 + v30 >= (unint64_t)(*(_QWORD *)(v28 + 16) + 8 * v33);
          else
            v34 = 1;
          if (!v34)
          {
            appendStringInfoChar((uint64_t)v9, 46);
            v33 = *(int *)(v28 + 4);
          }
          ++v29;
          v30 += 8;
        }
        while (v29 < v33);
      }
      appendStringInfoChar((uint64_t)v9, 40);
      v46 = *(_QWORD *)(a2 + 24);
      if (v46 && *(int *)(v46 + 4) >= 1)
      {
        v47 = 0;
        v48 = 8;
        do
        {
          v49 = *(_QWORD *)(v46 + 16);
          deparseExpr(v9, *(_QWORD *)(v49 + 8 * v47));
          v50 = *(int *)(v46 + 4);
          if (v49 + v48)
            v51 = v49 + v48 >= (unint64_t)(*(_QWORD *)(v46 + 16) + 8 * v50);
          else
            v51 = 1;
          if (!v51)
          {
            appendStringInfoString((uint64_t)v9, ", ");
            v50 = *(int *)(v46 + 4);
          }
          ++v47;
          v48 += 8;
        }
        while (v47 < v50);
      }
      result = appendStringInfoString((uint64_t)v9, ") ");
      if (*(_QWORD *)(a2 + 32))
      {
        appendStringInfoString((uint64_t)v9, "REPEATABLE (");
        deparseExpr(v9, *(_QWORD *)(a2 + 32));
        result = appendStringInfoString((uint64_t)v9, ") ");
      }
      goto LABEL_145;
    case 0x16C:
      if (*(_BYTE *)(a2 + 4))
        appendStringInfoString((uint64_t)result, "LATERAL ");
      appendStringInfoString((uint64_t)v9, "xmltable(");
      if (*(_QWORD *)(a2 + 24))
      {
        appendStringInfoString((uint64_t)v9, "xmlnamespaces(");
        v35 = *(_QWORD *)(a2 + 24);
        if (v35 && *(int *)(v35 + 4) >= 1)
        {
          v36 = 0;
          v37 = 8;
          do
          {
            v38 = *(_QWORD *)(v35 + 16);
            v39 = *(_QWORD *)(v38 + 8 * v36);
            if (!*(_QWORD *)(v39 + 8))
              appendStringInfoString((uint64_t)v9, "DEFAULT ");
            deparseExpr(v9, *(_QWORD *)(v39 + 24));
            if (*(_QWORD *)(v39 + 8))
            {
              appendStringInfoString((uint64_t)v9, " AS ");
              v40 = quote_identifier(*(_BYTE **)(v39 + 8));
              appendStringInfoString((uint64_t)v9, v40);
            }
            v41 = *(int *)(v35 + 4);
            if (v38 + v37)
              v42 = v38 + v37 >= (unint64_t)(*(_QWORD *)(v35 + 16) + 8 * v41);
            else
              v42 = 1;
            if (!v42)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v41 = *(int *)(v35 + 4);
            }
            ++v36;
            v37 += 8;
          }
          while (v36 < v41);
        }
        appendStringInfoString((uint64_t)v9, "), ");
      }
      appendStringInfoChar((uint64_t)v9, 40);
      deparseExpr(v9, *(_QWORD *)(a2 + 16));
      appendStringInfoChar((uint64_t)v9, 41);
      appendStringInfoString((uint64_t)v9, " PASSING ");
      deparseExpr(v9, *(_QWORD *)(a2 + 8));
      appendStringInfoString((uint64_t)v9, " COLUMNS ");
      v59 = *(_QWORD *)(a2 + 32);
      if (v59 && *(int *)(v59 + 4) >= 1)
      {
        v60 = 0;
        v61 = 8;
        do
        {
          v62 = *(_QWORD *)(v59 + 16);
          v63 = *(_QWORD *)(v62 + 8 * v60);
          v64 = quote_identifier(*(_BYTE **)(v63 + 8));
          appendStringInfoString((uint64_t)v9, v64);
          appendStringInfoChar((uint64_t)v9, 32);
          v65 = "FOR ORDINALITY ";
          if (*(_BYTE *)(v63 + 24))
            goto LABEL_99;
          deparseTypeName(v9, *(_QWORD *)(v63 + 16));
          appendStringInfoChar((uint64_t)v9, 32);
          if (*(_QWORD *)(v63 + 32))
          {
            appendStringInfoString((uint64_t)v9, "PATH ");
            deparseExpr(v9, *(_QWORD *)(v63 + 32));
            appendStringInfoChar((uint64_t)v9, 32);
          }
          if (*(_QWORD *)(v63 + 40))
          {
            appendStringInfoString((uint64_t)v9, "DEFAULT ");
            deparseExpr(v9, *(_QWORD *)(v63 + 40));
            appendStringInfoChar((uint64_t)v9, 32);
          }
          v65 = "NOT NULL ";
          if (*(_BYTE *)(v63 + 25))
LABEL_99:
            appendStringInfoString((uint64_t)v9, v65);
          v66 = v9[2];
          v67 = __OFSUB__(v66, 1);
          v68 = (v66 - 1);
          if ((int)v68 < 0 == v67)
          {
            v69 = *(_QWORD *)v9;
            if (*(_BYTE *)(*(_QWORD *)v9 + v68) == 32)
            {
              v9[2] = v68;
              *(_BYTE *)(v69 + v68) = 0;
            }
          }
          if (v62 + v61
            && v62 + v61 < (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                            + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4)))
          {
            appendStringInfoString((uint64_t)v9, ", ");
          }
          ++v60;
          v61 += 8;
        }
        while (v60 < *(int *)(v59 + 4));
      }
      result = appendStringInfoString((uint64_t)v9, ") ");
      if (!*(_QWORD *)(a2 + 40))
        goto LABEL_145;
      appendStringInfoString((uint64_t)v9, "AS ");
      v70 = *(_QWORD *)(a2 + 40);
      goto LABEL_144;
    default:
      if (v10 != 150)
      {
        if (v10 == 103)
          return (_DWORD *)deparseRangeVar((uint64_t)result, a2, 0);
        return result;
      }
      v43 = *(_QWORD *)(a2 + 48);
      v44 = *(_QWORD *)(a2 + 24);
      if (*(_DWORD *)v44 == 150)
      {
        v45 = *(_QWORD *)(v44 + 48) == 0;
        if (!v43)
          goto LABEL_110;
      }
      else
      {
        v45 = 0;
        if (!v43)
          goto LABEL_110;
      }
      appendStringInfoChar((uint64_t)result, 40);
LABEL_110:
      deparseTableRef(v9, *(_QWORD *)(a2 + 16));
      appendStringInfoChar((uint64_t)v9, 32);
      if (*(_BYTE *)(a2 + 8))
        appendStringInfoString((uint64_t)v9, "NATURAL ");
      v71 = "LEFT ";
      switch(*(_DWORD *)(a2 + 4))
      {
        case 0:
          if (!*(_BYTE *)(a2 + 8) && !*(_QWORD *)(a2 + 40))
          {
            v72 = *(_QWORD *)(a2 + 32);
            if (!v72 || !*(_DWORD *)(v72 + 4))
            {
              v71 = "CROSS ";
              goto LABEL_123;
            }
          }
          break;
        case 1:
          goto LABEL_123;
        case 2:
          v71 = "FULL ";
          goto LABEL_123;
        case 3:
          v71 = "RIGHT ";
LABEL_123:
          appendStringInfoString((uint64_t)v9, v71);
          break;
        default:
          break;
      }
      appendStringInfoString((uint64_t)v9, "JOIN ");
      if (v45)
      {
        appendStringInfoChar((uint64_t)v9, 40);
        deparseTableRef(v9, *(_QWORD *)(a2 + 24));
        appendStringInfoChar((uint64_t)v9, 41);
        result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(_QWORD *)(a2 + 40))
          goto LABEL_129;
      }
      else
      {
        deparseTableRef(v9, *(_QWORD *)(a2 + 24));
        result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(_QWORD *)(a2 + 40))
          goto LABEL_129;
      }
      appendStringInfoString((uint64_t)v9, "ON ");
      deparseExpr(v9, *(_QWORD *)(a2 + 40));
      result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
LABEL_129:
      v73 = *(_QWORD *)(a2 + 32);
      if (v73 && *(int *)(v73 + 4) >= 1)
      {
        appendStringInfoString((uint64_t)v9, "USING (");
        v74 = *(_QWORD *)(a2 + 32);
        if (v74 && *(int *)(v74 + 4) >= 1)
        {
          v75 = 0;
          v76 = 8;
          do
          {
            v77 = *(_QWORD *)(v74 + 16);
            v78 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v77 + 8 * v75) + 8));
            appendStringInfoString((uint64_t)v9, v78);
            v79 = *(int *)(v74 + 4);
            if (v77 + v76)
              v80 = v77 + v76 >= (unint64_t)(*(_QWORD *)(v74 + 16) + 8 * v79);
            else
              v80 = 1;
            if (!v80)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              v79 = *(int *)(v74 + 4);
            }
            ++v75;
            v76 += 8;
          }
          while (v75 < v79);
        }
        result = appendStringInfoString((uint64_t)v9, ") ");
      }
      if (v43)
        result = appendStringInfoString((uint64_t)v9, ") ");
      v70 = *(_QWORD *)(a2 + 48);
      if (v70)
LABEL_144:
        result = deparseAlias((uint64_t)v9, v70);
LABEL_145:
      v81 = v9[2];
      v67 = __OFSUB__(v81, 1);
      v82 = (v81 - 1);
      if ((int)v82 < 0 == v67)
      {
        v83 = *(_QWORD *)v9;
        if (*(_BYTE *)(*(_QWORD *)v9 + v82) == 32)
        {
          v9[2] = v82;
          *(_BYTE *)(v83 + v82) = 0;
        }
      }
      return result;
  }
}

uint64_t deparseWithClause(_DWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  BOOL v18;
  int v19;
  char *v20;
  uint64_t *v21;
  unint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;

  result = (uint64_t)appendStringInfoString((uint64_t)a1, "WITH ");
  if (*(_BYTE *)(a2 + 16))
    result = (uint64_t)appendStringInfoString((uint64_t)a1, "RECURSIVE ");
  v5 = *(_QWORD *)(a2 + 8);
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    v6 = 0;
    while (2)
    {
      v7 = *(_QWORD *)(v5 + 16) + 8 * v6;
      v8 = *(_QWORD *)v7;
      v9 = quote_identifier(*(_BYTE **)(*(_QWORD *)v7 + 8));
      appendStringInfoString((uint64_t)a1, v9);
      v10 = *(_QWORD *)(v8 + 16);
      if (v10 && *(int *)(v10 + 4) >= 1)
      {
        v11 = a2;
        appendStringInfoChar((uint64_t)a1, 40);
        v12 = *(_QWORD *)(v8 + 16);
        if (v12 && *(int *)(v12 + 4) >= 1)
        {
          v13 = 0;
          v14 = 8;
          do
          {
            v15 = *(_QWORD *)(v12 + 16);
            v16 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v15 + 8 * v13) + 8));
            appendStringInfoString((uint64_t)a1, v16);
            v17 = *(int *)(v12 + 4);
            if (v15 + v14)
              v18 = v15 + v14 >= (unint64_t)(*(_QWORD *)(v12 + 16) + 8 * v17);
            else
              v18 = 1;
            if (!v18)
            {
              appendStringInfoString((uint64_t)a1, ", ");
              v17 = *(int *)(v12 + 4);
            }
            ++v13;
            v14 += 8;
          }
          while (v13 < v17);
        }
        appendStringInfoChar((uint64_t)a1, 41);
        a2 = v11;
      }
      appendStringInfoChar((uint64_t)a1, 32);
      appendStringInfoString((uint64_t)a1, "AS ");
      v19 = *(_DWORD *)(v8 + 24);
      if (v19 == 1)
      {
        v20 = "MATERIALIZED ";
      }
      else
      {
        if (v19 != 2)
        {
LABEL_24:
          appendStringInfoChar((uint64_t)a1, 40);
          v21 = *(uint64_t **)(v8 + 32);
          switch(*(_DWORD *)v21)
          {
            case 0xE9:
              deparseInsertStmt(a1, (uint64_t)v21);
              result = appendStringInfoChar((uint64_t)a1, 41);
              v22 = v7 + 8;
              if (v7 != -8)
                goto LABEL_31;
              goto LABEL_6;
            case 0xEA:
              deparseDeleteStmt(a1, v21);
              result = appendStringInfoChar((uint64_t)a1, 41);
              v22 = v7 + 8;
              if (v7 != -8)
                goto LABEL_31;
              goto LABEL_6;
            case 0xEB:
              deparseUpdateStmt(a1, v21);
              goto LABEL_30;
            case 0xEC:
              deparseSelectStmt(a1, v21);
              result = appendStringInfoChar((uint64_t)a1, 41);
              v22 = v7 + 8;
              if (v7 == -8)
                goto LABEL_6;
              goto LABEL_31;
            default:
LABEL_30:
              result = appendStringInfoChar((uint64_t)a1, 41);
              v22 = v7 + 8;
              if (v7 != -8)
              {
LABEL_31:
                if (v22 < *(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4))
                  result = (uint64_t)appendStringInfoString((uint64_t)a1, ", ");
              }
LABEL_6:
              if (++v6 < *(int *)(v5 + 4))
                continue;
              goto LABEL_35;
          }
        }
        v20 = "NOT MATERIALIZED ";
      }
      break;
    }
    appendStringInfoString((uint64_t)a1, v20);
    goto LABEL_24;
  }
LABEL_35:
  v23 = a1[2];
  v24 = __OFSUB__(v23, 1);
  v25 = (v23 - 1);
  if ((int)v25 < 0 == v24)
  {
    v26 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v25) == 32)
    {
      a1[2] = v25;
      *(_BYTE *)(v26 + v25) = 0;
    }
  }
  return result;
}

uint64_t deparseTargetList(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v6 + 8 * v4);
      v8 = *(_QWORD *)(v7 + 24);
      if (!v8)
        deparseTargetList_cold_1();
      if (*(_DWORD *)v8 == 347)
      {
        v9 = **(_QWORD **)(*(_QWORD *)(v8 + 8) + 16);
        if (*(_DWORD *)v9 == 223)
        {
          v10 = quote_identifier(*(_BYTE **)(v9 + 8));
          appendStringInfoString(v3, v10);
        }
        else if (*(_DWORD *)v9 == 351)
        {
          appendStringInfoChar(v3, 42);
        }
        result = deparseOptIndirection(v3, *(_QWORD *)(v8 + 8), 1);
        if (!*(_QWORD *)(v7 + 8))
          goto LABEL_15;
      }
      else
      {
        result = deparseExpr(v3, *(_QWORD *)(v7 + 24));
        if (!*(_QWORD *)(v7 + 8))
          goto LABEL_15;
      }
      appendStringInfoString(v3, " AS ");
      v11 = quote_identifier(*(_BYTE **)(v7 + 8));
      result = (uint64_t)appendStringInfoString(v3, v11);
LABEL_15:
      if (v6 + v5)
      {
        if (v6 + v5 < (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * *(int *)(a2 + 4)))
          result = (uint64_t)appendStringInfoString(v3, ", ");
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < *(int *)(a2 + 4));
  }
  return result;
}

uint64_t deparseAccessPriv(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  int v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;

  v4 = *(char **)(a2 + 8);
  if (v4)
  {
    if (!strcmp(v4, "select"))
    {
      v5 = "select";
    }
    else if (!strcmp(v4, "references"))
    {
      v5 = "references";
    }
    else if (!strcmp(v4, "create"))
    {
      v5 = "create";
    }
    else
    {
      v5 = quote_identifier(v4);
    }
  }
  else
  {
    v5 = "ALL";
  }
  appendStringInfoString(a1, v5);
  result = appendStringInfoChar(a1, 32);
  v7 = *(_QWORD *)(a2 + 16);
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    appendStringInfoChar(a1, 40);
    v8 = *(_QWORD *)(a2 + 16);
    if (v8 && *(int *)(v8 + 4) >= 1)
    {
      v9 = 0;
      v10 = 8;
      do
      {
        v11 = *(_QWORD *)(v8 + 16);
        v12 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v11 + 8 * v9) + 8));
        appendStringInfoString(a1, v12);
        v13 = *(int *)(v8 + 4);
        if (v11 + v10)
          v14 = v11 + v10 >= (unint64_t)(*(_QWORD *)(v8 + 16) + 8 * v13);
        else
          v14 = 1;
        if (!v14)
        {
          appendStringInfoString(a1, ", ");
          v13 = *(int *)(v8 + 4);
        }
        ++v9;
        v10 += 8;
      }
      while (v9 < v13);
    }
    result = appendStringInfoChar(a1, 41);
  }
  v15 = *(_DWORD *)(a1 + 8);
  v16 = __OFSUB__(v15, 1);
  v17 = (v15 - 1);
  if ((int)v17 < 0 == v16)
  {
    v18 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v17) == 32)
    {
      *(_DWORD *)(a1 + 8) = v17;
      *(_BYTE *)(v18 + v17) = 0;
    }
  }
  return result;
}

uint64_t deparseSetClauseList(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t i;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v25;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    v4 = 0;
    for (i = 0; i < *(int *)(a2 + 4); ++i)
    {
      if (v4 >= 1)
      {
        --v4;
      }
      else
      {
        v6 = *(_QWORD *)(a2 + 16);
        if (i)
          appendStringInfoString(v3, ", ");
        v7 = (uint64_t *)(v6 + 8 * i);
        v8 = *v7;
        v9 = *(_QWORD *)(*v7 + 24);
        if (*(_DWORD *)v9 == 356)
        {
          appendStringInfoString(v3, "(");
          v10 = ((unint64_t)v7 - *(_QWORD *)(a2 + 16)) >> 3;
          if (*(_DWORD *)(a2 + 4) > (int)v10)
          {
            while (1)
            {
              v11 = *(_QWORD *)(a2 + 16) + 8 * (int)v10;
              v12 = *(_QWORD *)v11;
              v13 = quote_identifier(*(_BYTE **)(*(_QWORD *)v11 + 8));
              appendStringInfoString(v3, v13);
              v14 = *(_QWORD *)(v12 + 16);
              if (v14)
              {
                if (*(int *)(v14 + 4) >= 1)
                  break;
              }
LABEL_30:
              if (*(_DWORD *)(v9 + 20) - 1 != (_DWORD)v10)
              {
                v23 = *(int *)(a2 + 4);
                if (v11 != -8 && v11 + 8 < (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v23))
                {
                  appendStringInfoString(v3, ", ");
                  LODWORD(v23) = *(_DWORD *)(a2 + 4);
                }
                LODWORD(v10) = v10 + 1;
                if ((int)v23 > (int)v10)
                  continue;
              }
              goto LABEL_11;
            }
            v15 = 0;
            while (2)
            {
              v18 = *(_QWORD *)(v14 + 16);
              v19 = *(int **)(v18 + 8 * v15);
              v20 = *v19;
              if (*v19 == 352)
              {
                appendStringInfoChar(v3, 91);
                v21 = *((_QWORD *)v19 + 1);
                if (v21)
                  deparseExpr(v3, v21);
                if (*((_BYTE *)v19 + 4))
                  appendStringInfoChar(v3, 58);
                v22 = *((_QWORD *)v19 + 2);
                if (v22)
                  deparseExpr(v3, v22);
                appendStringInfoChar(v3, 93);
              }
              else
              {
                if (v20 == 351)
                {
                  v16 = v3;
                  v17 = ".*";
                  goto LABEL_17;
                }
                if (v20 == 223)
                {
                  appendStringInfoChar(v3, 46);
                  v17 = quote_identifier(*(_BYTE **)(*(_QWORD *)(v18 + 8 * v15) + 8));
                  v16 = v3;
LABEL_17:
                  appendStringInfoString(v16, v17);
                }
              }
              if (*(_DWORD *)(v14 + 4) <= ++v15)
                goto LABEL_30;
              continue;
            }
          }
LABEL_11:
          appendStringInfoString(v3, ") = ");
          result = deparseExpr(v3, *(_QWORD *)(v9 + 8));
          v4 = *(_DWORD *)(v9 + 20) - 1;
        }
        else
        {
          v25 = quote_identifier(*(_BYTE **)(v8 + 8));
          appendStringInfoString(v3, v25);
          deparseOptIndirection(v3, *(_QWORD *)(v8 + 16), 0);
          appendStringInfoString(v3, " = ");
          result = deparseExpr(v3, *(_QWORD *)(v8 + 24));
        }
      }
    }
  }
  return result;
}

_DWORD *deparseRuleActionStmt(_DWORD *result, uint64_t a2)
{
  uint64_t v3;
  char *v4;

  v3 = (uint64_t)result;
  switch(*(_DWORD *)a2)
  {
    case 0xE9:
      result = (_DWORD *)deparseInsertStmt(result, a2);
      break;
    case 0xEA:
      result = (_DWORD *)deparseDeleteStmt(result, (uint64_t *)a2);
      break;
    case 0xEB:
      result = (_DWORD *)deparseUpdateStmt(result, (uint64_t *)a2);
      break;
    case 0xEC:
      result = (_DWORD *)deparseSelectStmt(result, a2);
      break;
    case 0x103:
      appendStringInfoString((uint64_t)result, "NOTIFY ");
      v4 = quote_identifier(*(_BYTE **)(a2 + 8));
      result = appendStringInfoString(v3, v4);
      if (*(_QWORD *)(a2 + 16))
      {
        appendStringInfoString(v3, ", ");
        result = (_DWORD *)deparseStringLiteral(v3, *(char **)(a2 + 16));
      }
      break;
    default:
      return result;
  }
  return result;
}

void *deparseGroupingSet(void *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  BOOL v22;

  v3 = (uint64_t)result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      return appendStringInfoString((uint64_t)result, "()");
    case 2:
      appendStringInfoString((uint64_t)result, "ROLLUP (");
      v4 = *(_QWORD *)(a2 + 8);
      if (v4 && *(int *)(v4 + 4) >= 1)
      {
        v5 = 0;
        v6 = 8;
        do
        {
          v7 = *(_QWORD *)(v4 + 16);
          deparseExpr(v3, *(_QWORD *)(v7 + 8 * v5));
          v8 = *(int *)(v4 + 4);
          if (v7 + v6)
            v9 = v7 + v6 >= (unint64_t)(*(_QWORD *)(v4 + 16) + 8 * v8);
          else
            v9 = 1;
          if (!v9)
          {
            appendStringInfoString(v3, ", ");
            v8 = *(int *)(v4 + 4);
          }
          ++v5;
          v6 += 8;
        }
        while (v5 < v8);
      }
      goto LABEL_33;
    case 3:
      appendStringInfoString((uint64_t)result, "CUBE (");
      v10 = *(_QWORD *)(a2 + 8);
      if (v10 && *(int *)(v10 + 4) >= 1)
      {
        v11 = 0;
        v12 = 8;
        do
        {
          v13 = *(_QWORD *)(v10 + 16);
          deparseExpr(v3, *(_QWORD *)(v13 + 8 * v11));
          v14 = *(int *)(v10 + 4);
          if (v13 + v12)
            v15 = v13 + v12 >= (unint64_t)(*(_QWORD *)(v10 + 16) + 8 * v14);
          else
            v15 = 1;
          if (!v15)
          {
            appendStringInfoString(v3, ", ");
            v14 = *(int *)(v10 + 4);
          }
          ++v11;
          v12 += 8;
        }
        while (v11 < v14);
      }
      goto LABEL_33;
    case 4:
      appendStringInfoString((uint64_t)result, "GROUPING SETS (");
      v16 = *(_QWORD *)(a2 + 8);
      if (v16 && *(int *)(v16 + 4) >= 1)
      {
        v17 = 0;
        v18 = 8;
        do
        {
          v19 = *(_QWORD *)(v16 + 16);
          v20 = *(_DWORD **)(v19 + 8 * v17);
          if (*v20 == 376)
            deparseGroupingSet(v3);
          else
            deparseExpr(v3, v20);
          v21 = *(int *)(v16 + 4);
          if (v19 + v18)
            v22 = v19 + v18 >= (unint64_t)(*(_QWORD *)(v16 + 16) + 8 * v21);
          else
            v22 = 1;
          if (!v22)
          {
            appendStringInfoString(v3, ", ");
            v21 = *(int *)(v16 + 4);
          }
          ++v17;
          v18 += 8;
        }
        while (v17 < v21);
      }
LABEL_33:
      result = (void *)appendStringInfoChar(v3, 41);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t deparseTransactionModeList(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  int v9;
  char *v10;
  const char *v11;
  int v12;

  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    v3 = result;
    v4 = 0;
    v5 = 8;
    do
    {
      v6 = *(_QWORD *)(a2 + 16);
      v7 = *(_QWORD *)(v6 + 8 * v4);
      v8 = *(const char **)(v7 + 16);
      if (!strcmp(v8, "transaction_isolation"))
      {
        v11 = *(const char **)(*(_QWORD *)(v7 + 24) + 16);
        appendStringInfoString(v3, "ISOLATION LEVEL ");
        if (!strcmp(v11, "read uncommitted"))
        {
          v10 = "READ UNCOMMITTED";
          goto LABEL_24;
        }
        if (!strcmp(v11, "read committed"))
        {
          v10 = "READ COMMITTED";
          goto LABEL_24;
        }
        if (!strcmp(v11, "repeatable read"))
        {
          v10 = "REPEATABLE READ";
          goto LABEL_24;
        }
        result = strcmp(v11, "serializable");
        if (!(_DWORD)result)
        {
          v10 = "SERIALIZABLE";
          goto LABEL_24;
        }
      }
      else
      {
        if (!strcmp(v8, "transaction_read_only"))
        {
          v12 = *(_DWORD *)(*(_QWORD *)(v7 + 24) + 16);
          if (v12 == 1)
          {
            v10 = "READ ONLY";
            goto LABEL_24;
          }
          if (!v12)
          {
            v10 = "READ WRITE";
            goto LABEL_24;
          }
        }
        result = strcmp(v8, "transaction_deferrable");
        if (!(_DWORD)result)
        {
          v9 = *(_DWORD *)(*(_QWORD *)(v7 + 24) + 16);
          if (v9 == 1)
          {
            v10 = "DEFERRABLE";
            goto LABEL_24;
          }
          if (!v9)
          {
            v10 = "NOT DEFERRABLE";
LABEL_24:
            result = (uint64_t)appendStringInfoString(v3, v10);
          }
        }
      }
      if (v6 + v5)
      {
        if (v6 + v5 < (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * *(int *)(a2 + 4)))
          result = (uint64_t)appendStringInfoString(v3, ", ");
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < *(int *)(a2 + 4));
  }
  return result;
}

void pg_query_deparse_protobuf_cold_1()
{
  OUTLINED_FUNCTION_0_5();
  errmsg_internal("deparse error in deparseRawStmt: RawStmt with empty Stmt");
  errfinish("src/pg_query_deparse.c", 2278, (uint64_t)"deparseRawStmt");
  __break(1u);
}

void pg_query_deparse_protobuf_cold_2(_DWORD *a1)
{
  OUTLINED_FUNCTION_0_5();
  errmsg_internal("deparse: unsupported top-level node type: %u", *a1);
  errfinish("src/pg_query_deparse.c", 9904, (uint64_t)"deparseStmt");
  __break(1u);
}

void deparseSelectStmt_cold_1(_DWORD *a1)
{
  OUTLINED_FUNCTION_0_5();
  errmsg_internal("deparse: unpermitted node type in c_expr: %d", *a1);
  errfinish("src/pg_query_deparse.c", 375, (uint64_t)"deparseCExpr");
  __break(1u);
}

void deparseExpr_cold_1(_DWORD *a1)
{
  OUTLINED_FUNCTION_0_5();
  errmsg_internal("deparse: unpermitted node type in a_expr/b_expr: %d", *a1);
  errfinish("src/pg_query_deparse.c", 325, (uint64_t)"deparseExpr");
  __break(1u);
}

void deparseValue_cold_1(_DWORD *a1)
{
  OUTLINED_FUNCTION_0_5();
  errmsg_internal("deparse: unrecognized value node type: %d", *a1);
  errfinish("src/pg_query_deparse.c", 9432, (uint64_t)"deparseValue");
  __break(1u);
}

void deparseTargetList_cold_1()
{
  OUTLINED_FUNCTION_0_5();
  errmsg_internal("deparse: error in deparseTargetList: ResTarget without val");
  errfinish("src/pg_query_deparse.c", 1417, (uint64_t)"deparseTargetList");
  __break(1u);
}

uint64_t pg_query_nodes_to_json(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v39;
  size_t v40;
  size_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  v42 = 0;
  v43 = 0;
  v44 = 0;
  initStringInfo((uint64_t)&v42);
  if (a1)
  {
    appendStringInfoString((uint64_t)&v42, "{");
    appendStringInfo((uint64_t)&v42, "\"version\":%d,", v8, v9, v10, v11, v12, v13, 0x1FBD3uLL);
    appendStringInfoString((uint64_t)&v42, "\"stmts\":");
    appendStringInfoChar((uint64_t)&v42, 91);
    if (*(int *)(a1 + 4) >= 1)
    {
      v14 = 0;
      v15 = 8;
      do
      {
        v16 = *(_QWORD *)(a1 + 16);
        appendStringInfoChar((uint64_t)&v42, 123);
        v23 = *(_QWORD *)(v16 + 8 * v14);
        if (*(_QWORD *)(v23 + 8))
        {
          appendStringInfo((uint64_t)&v42, "\"stmt\":", v17, v18, v19, v20, v21, v22, v39);
          _outNode((int *)&v42, *(unsigned int **)(v23 + 8), v24, v25, v26, v27, v28, v29, v40);
          appendStringInfo((uint64_t)&v42, ",", v30, v31, v32, v33, v34, v35, v41);
        }
        if (*(_DWORD *)(v23 + 16))
          appendStringInfo((uint64_t)&v42, "\"stmt_location\":%d,", v17, v18, v19, v20, v21, v22, *(unsigned int *)(v23 + 16));
        if (*(_DWORD *)(v23 + 20))
          appendStringInfo((uint64_t)&v42, "\"stmt_len\":%d,", v17, v18, v19, v20, v21, v22, *(unsigned int *)(v23 + 20));
        v36 = (v43 - 1);
        if ((int)v43 >= 1 && *(_BYTE *)(v42 + v36) == 44)
        {
          LODWORD(v43) = v43 - 1;
          *(_BYTE *)(v42 + v36) = 0;
        }
        appendStringInfoChar((uint64_t)&v42, 125);
        v37 = *(int *)(a1 + 4);
        if (v16 + v15 && v16 + v15 < (unint64_t)(*(_QWORD *)(a1 + 16) + 8 * v37))
        {
          appendStringInfoString((uint64_t)&v42, ",");
          v37 = *(int *)(a1 + 4);
        }
        ++v14;
        v15 += 8;
      }
      while (v14 < v37);
    }
    appendStringInfoChar((uint64_t)&v42, 93);
    appendStringInfoString((uint64_t)&v42, "}");
  }
  else
  {
    appendStringInfo((uint64_t)&v42, "{\"version\":%d,\"stmts\":[]}", v2, v3, v4, v5, v6, v7, 0x1FBD3uLL);
  }
  return v42;
}

uint64_t _outRawStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"stmt\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"stmt_location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    return appendStringInfo(v9, "\"stmt_len\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  return result;
}

void *_outNode(int *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t v568;
  uint64_t v569;
  uint64_t v570;
  uint64_t v571;
  uint64_t v572;
  uint64_t v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  uint64_t v734;
  uint64_t v735;
  uint64_t v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t v762;
  uint64_t v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t v766;
  uint64_t v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t v795;
  uint64_t v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  uint64_t v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  uint64_t v810;
  uint64_t v811;
  uint64_t v812;
  uint64_t v813;
  uint64_t v814;
  uint64_t v815;
  uint64_t v816;
  uint64_t v817;
  uint64_t v818;
  uint64_t v819;
  uint64_t v820;
  uint64_t v821;
  uint64_t v822;
  uint64_t v823;
  uint64_t v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t v827;
  uint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  uint64_t v848;
  uint64_t v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  uint64_t v861;
  uint64_t v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  uint64_t v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  uint64_t v871;
  uint64_t v872;
  uint64_t v873;
  uint64_t v874;
  uint64_t v875;
  uint64_t v876;
  uint64_t v877;
  uint64_t v878;
  uint64_t v879;
  uint64_t v880;
  uint64_t v881;
  uint64_t v882;
  uint64_t v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t v888;
  uint64_t v889;
  uint64_t v890;
  uint64_t v891;
  uint64_t v892;
  uint64_t v893;
  uint64_t v894;
  uint64_t v895;
  uint64_t v896;
  uint64_t v897;
  uint64_t v898;
  uint64_t v899;
  uint64_t v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  uint64_t v904;
  uint64_t v905;
  uint64_t v906;
  uint64_t v907;
  uint64_t v908;
  uint64_t v909;
  uint64_t v910;
  uint64_t v911;
  uint64_t v912;
  uint64_t v913;
  uint64_t v914;
  uint64_t v915;
  uint64_t v916;
  uint64_t v917;
  uint64_t v918;
  uint64_t v919;
  uint64_t v920;
  uint64_t v921;
  uint64_t v922;
  uint64_t v923;
  uint64_t v924;
  uint64_t v925;
  uint64_t v926;
  uint64_t v927;
  uint64_t v928;
  uint64_t v929;
  uint64_t v930;
  uint64_t v931;
  uint64_t v932;
  uint64_t v933;
  uint64_t v934;
  uint64_t v935;
  uint64_t v936;
  uint64_t v937;
  uint64_t v938;
  uint64_t v939;
  uint64_t v940;
  uint64_t v941;
  uint64_t v942;
  uint64_t v943;
  uint64_t v944;
  uint64_t v945;
  uint64_t v946;
  uint64_t v947;
  uint64_t v948;
  uint64_t v949;
  uint64_t v950;
  uint64_t v951;
  uint64_t v952;
  uint64_t v953;
  uint64_t v954;
  uint64_t v955;
  uint64_t v956;
  uint64_t v957;
  uint64_t v958;
  uint64_t v959;
  uint64_t v960;
  uint64_t v961;
  uint64_t v962;
  uint64_t v963;
  uint64_t v964;
  uint64_t v965;
  uint64_t v966;
  uint64_t v967;
  uint64_t v968;
  uint64_t v969;
  uint64_t v970;
  uint64_t v971;
  uint64_t v972;
  uint64_t v973;
  uint64_t v974;
  uint64_t v975;
  uint64_t v976;
  uint64_t v977;
  uint64_t v978;
  uint64_t v979;
  uint64_t v980;
  uint64_t v981;
  uint64_t v982;
  uint64_t v983;
  uint64_t v984;
  uint64_t v985;
  uint64_t v986;
  uint64_t v987;
  uint64_t v988;
  uint64_t v989;
  uint64_t v990;
  uint64_t v991;
  uint64_t v992;
  uint64_t v993;
  uint64_t v994;
  uint64_t v995;
  uint64_t v996;
  uint64_t v997;
  uint64_t v998;
  uint64_t v999;
  uint64_t v1000;
  uint64_t v1001;
  uint64_t v1002;
  uint64_t v1003;
  uint64_t v1004;
  uint64_t v1005;
  uint64_t v1006;
  uint64_t v1007;
  uint64_t v1008;
  uint64_t v1009;
  uint64_t v1010;
  uint64_t v1011;
  uint64_t v1012;
  uint64_t v1013;
  uint64_t v1014;
  uint64_t v1015;
  uint64_t v1016;
  uint64_t v1017;
  uint64_t v1018;
  uint64_t v1019;
  uint64_t v1020;
  uint64_t v1021;
  uint64_t v1022;
  uint64_t v1023;
  uint64_t v1024;
  uint64_t v1025;
  uint64_t v1026;
  uint64_t v1027;
  uint64_t v1028;
  uint64_t v1029;
  uint64_t v1030;
  uint64_t v1031;
  uint64_t v1032;
  uint64_t v1033;
  uint64_t v1034;
  uint64_t v1035;
  uint64_t v1036;
  uint64_t v1037;
  uint64_t v1038;
  uint64_t v1039;
  uint64_t v1040;
  uint64_t v1041;
  uint64_t v1042;
  uint64_t v1043;
  uint64_t v1044;
  uint64_t v1045;
  uint64_t v1046;
  uint64_t v1047;
  uint64_t v1048;
  uint64_t v1049;
  uint64_t v1050;
  uint64_t v1051;
  uint64_t v1052;
  uint64_t v1053;
  uint64_t v1054;
  uint64_t v1055;
  uint64_t v1056;
  uint64_t v1057;
  uint64_t v1058;
  uint64_t v1059;
  uint64_t v1060;
  uint64_t v1061;
  uint64_t v1062;
  uint64_t v1063;
  uint64_t v1064;
  uint64_t v1065;
  uint64_t v1066;
  uint64_t v1067;
  uint64_t v1068;
  uint64_t v1069;
  uint64_t v1070;
  uint64_t v1071;
  uint64_t v1072;
  uint64_t v1073;
  uint64_t v1074;
  uint64_t v1075;
  uint64_t v1076;
  uint64_t v1077;
  uint64_t v1078;
  uint64_t v1079;
  uint64_t v1080;
  uint64_t v1081;
  uint64_t v1082;
  uint64_t v1083;
  uint64_t v1084;
  uint64_t v1085;
  uint64_t v1086;
  uint64_t v1087;
  uint64_t v1088;
  uint64_t v1089;
  uint64_t v1090;
  uint64_t v1091;
  uint64_t v1092;
  uint64_t v1093;
  uint64_t v1094;
  uint64_t v1095;
  uint64_t v1096;
  uint64_t v1097;
  uint64_t v1098;
  uint64_t v1099;
  uint64_t v1100;
  uint64_t v1101;
  uint64_t v1102;
  uint64_t v1103;
  uint64_t v1104;
  uint64_t v1105;
  uint64_t v1106;
  uint64_t v1107;
  uint64_t v1108;
  uint64_t v1109;
  uint64_t v1110;
  uint64_t v1111;
  uint64_t v1112;
  uint64_t v1113;
  uint64_t v1114;
  uint64_t v1115;
  uint64_t v1116;
  uint64_t v1117;
  uint64_t v1118;
  uint64_t v1119;
  uint64_t v1120;
  uint64_t v1121;
  uint64_t v1122;
  uint64_t v1123;
  uint64_t v1124;
  uint64_t v1125;
  uint64_t v1126;
  uint64_t v1127;
  uint64_t v1128;
  uint64_t v1129;
  uint64_t v1130;
  uint64_t v1131;
  uint64_t v1132;
  uint64_t v1133;
  uint64_t v1134;
  uint64_t v1135;
  uint64_t v1136;
  uint64_t v1137;
  uint64_t v1138;
  uint64_t v1139;
  uint64_t v1140;
  uint64_t v1141;
  uint64_t v1142;
  uint64_t v1143;
  uint64_t v1144;
  uint64_t v1145;
  uint64_t v1146;
  uint64_t v1147;
  uint64_t v1148;
  uint64_t v1149;
  uint64_t v1150;
  uint64_t v1151;
  uint64_t v1152;
  uint64_t v1153;
  uint64_t v1154;
  uint64_t v1155;
  uint64_t v1156;
  uint64_t v1157;
  uint64_t v1158;
  uint64_t v1159;
  uint64_t v1160;
  uint64_t v1161;
  uint64_t v1162;
  uint64_t v1163;
  uint64_t v1164;
  uint64_t v1165;
  uint64_t v1166;
  uint64_t v1167;
  uint64_t v1168;
  uint64_t v1169;
  uint64_t v1170;
  uint64_t v1171;
  uint64_t v1172;
  uint64_t v1173;
  uint64_t v1174;
  uint64_t v1175;
  uint64_t v1176;
  uint64_t v1177;
  uint64_t v1178;
  uint64_t v1179;
  uint64_t v1180;
  uint64_t v1181;
  uint64_t v1182;
  uint64_t v1183;
  uint64_t v1184;
  uint64_t v1185;
  uint64_t v1186;
  uint64_t v1187;
  uint64_t v1188;
  uint64_t v1189;
  uint64_t v1190;
  uint64_t v1191;
  uint64_t v1192;
  uint64_t v1193;
  uint64_t v1194;
  uint64_t v1195;
  uint64_t v1196;
  uint64_t v1197;
  uint64_t v1198;
  uint64_t v1199;
  uint64_t v1200;
  uint64_t v1201;
  uint64_t v1202;
  uint64_t v1203;
  uint64_t v1204;
  uint64_t v1205;
  uint64_t v1206;
  uint64_t v1207;
  uint64_t v1208;
  uint64_t v1209;
  uint64_t v1210;
  uint64_t v1211;
  uint64_t v1212;
  uint64_t v1213;
  uint64_t v1214;
  uint64_t v1215;
  uint64_t v1216;
  uint64_t v1217;
  uint64_t v1218;
  uint64_t v1219;
  uint64_t v1220;
  uint64_t v1221;
  uint64_t v1222;
  uint64_t v1223;
  uint64_t v1224;
  uint64_t v1225;
  uint64_t v1226;
  uint64_t v1227;
  uint64_t v1228;
  uint64_t v1229;
  uint64_t v1230;
  uint64_t v1231;
  uint64_t v1232;
  uint64_t v1233;
  uint64_t v1234;
  uint64_t v1235;
  uint64_t v1236;
  uint64_t v1237;
  uint64_t v1238;
  uint64_t v1239;
  uint64_t v1240;
  uint64_t v1241;
  uint64_t v1242;
  uint64_t v1243;
  uint64_t v1244;
  uint64_t v1245;
  uint64_t v1246;
  uint64_t v1247;
  uint64_t v1248;
  uint64_t v1249;
  uint64_t v1250;
  uint64_t v1251;
  uint64_t v1252;
  uint64_t v1253;
  uint64_t v1254;
  uint64_t v1255;
  uint64_t v1256;
  uint64_t v1257;
  uint64_t v1258;
  uint64_t v1259;
  uint64_t v1260;
  uint64_t v1261;
  uint64_t v1262;
  uint64_t v1263;
  uint64_t v1264;
  uint64_t v1265;
  uint64_t v1266;
  uint64_t v1267;
  uint64_t v1268;
  uint64_t v1269;
  uint64_t v1270;
  uint64_t v1271;
  uint64_t v1272;
  uint64_t v1273;
  uint64_t v1274;
  uint64_t v1275;
  uint64_t v1276;
  uint64_t v1277;
  uint64_t v1278;
  uint64_t v1279;
  uint64_t v1280;
  uint64_t v1281;
  uint64_t v1282;
  uint64_t v1283;
  uint64_t v1284;
  uint64_t v1285;
  uint64_t v1286;
  uint64_t v1287;
  uint64_t v1288;
  uint64_t v1289;
  uint64_t v1290;
  uint64_t v1291;
  uint64_t v1292;
  uint64_t v1293;
  uint64_t v1294;
  uint64_t v1295;
  uint64_t v1296;
  uint64_t v1297;
  uint64_t v1298;
  uint64_t v1299;
  uint64_t v1300;
  uint64_t v1301;
  uint64_t v1302;
  uint64_t v1303;
  uint64_t v1304;
  uint64_t v1305;
  uint64_t v1306;
  uint64_t v1307;
  uint64_t v1308;
  uint64_t v1309;
  uint64_t v1310;
  uint64_t v1311;
  uint64_t v1312;
  uint64_t v1313;
  uint64_t v1314;
  uint64_t v1315;
  uint64_t v1316;
  uint64_t v1317;
  uint64_t v1318;
  uint64_t v1319;
  uint64_t v1320;
  uint64_t v1321;
  uint64_t v1322;
  uint64_t v1323;
  uint64_t v1324;
  uint64_t v1325;
  uint64_t v1326;
  uint64_t v1327;
  uint64_t v1328;
  uint64_t v1329;
  uint64_t v1330;
  uint64_t v1331;
  uint64_t v1332;
  uint64_t v1333;
  uint64_t v1334;
  uint64_t v1335;
  uint64_t v1336;
  uint64_t v1337;
  uint64_t v1338;
  uint64_t v1339;
  uint64_t v1340;
  uint64_t v1341;
  uint64_t v1342;
  uint64_t v1343;
  uint64_t v1344;
  uint64_t v1345;
  uint64_t v1346;
  uint64_t v1347;
  uint64_t v1348;
  uint64_t v1349;
  uint64_t v1350;
  uint64_t v1351;
  uint64_t v1352;
  int v1353;
  BOOL v1354;
  uint64_t v1355;
  uint64_t v1356;
  size_t v1357;

  if (!a2)
    return appendStringInfoString((uint64_t)a1, "null");
  appendStringInfoChar((uint64_t)a1, 123);
  switch(*a2)
  {
    case 0x66u:
      appendStringInfoString((uint64_t)a1, "\"Alias\":{");
      _outAlias((uint64_t)a1, (uint64_t)a2, v11, v12, v13, v14, v15, v16, v1357);
      goto LABEL_240;
    case 0x67u:
      appendStringInfoString((uint64_t)a1, "\"RangeVar\":{");
      _outRangeVar((uint64_t)a1, (uint64_t)a2, v24, v25, v26, v27, v28, v29);
      goto LABEL_240;
    case 0x68u:
      appendStringInfoString((uint64_t)a1, "\"TableFunc\":{");
      _outTableFunc((uint64_t)a1, (uint64_t)a2, v30, v31, v32, v33, v34, v35);
      goto LABEL_240;
    case 0x69u:
      v36 = "\"Expr\":{";
      goto LABEL_190;
    case 0x6Au:
      appendStringInfoString((uint64_t)a1, "\"Var\":{");
      _outVar((uint64_t)a1, (uint64_t)a2, v37, v38, v39, v40, v41, v42);
      goto LABEL_240;
    case 0x6Cu:
      appendStringInfoString((uint64_t)a1, "\"Param\":{");
      _outParam((uint64_t)a1, (uint64_t)a2, v45, v46, v47, v48, v49, v50);
      goto LABEL_240;
    case 0x6Du:
      appendStringInfoString((uint64_t)a1, "\"Aggref\":{");
      _outAggref((uint64_t)a1, (uint64_t)a2, v51, v52, v53, v54, v55, v56);
      goto LABEL_240;
    case 0x6Eu:
      appendStringInfoString((uint64_t)a1, "\"GroupingFunc\":{");
      _outGroupingFunc((uint64_t)a1, (uint64_t)a2, v57, v58, v59, v60, v61, v62);
      goto LABEL_240;
    case 0x6Fu:
      appendStringInfoString((uint64_t)a1, "\"WindowFunc\":{");
      _outWindowFunc((uint64_t)a1, (uint64_t)a2, v63, v64, v65, v66, v67, v68);
      goto LABEL_240;
    case 0x70u:
      appendStringInfoString((uint64_t)a1, "\"SubscriptingRef\":{");
      _outSubscriptingRef((uint64_t)a1, (uint64_t)a2, v69, v70, v71, v72, v73, v74, v1357);
      goto LABEL_240;
    case 0x71u:
      appendStringInfoString((uint64_t)a1, "\"FuncExpr\":{");
      _outFuncExpr((uint64_t)a1, (uint64_t)a2, v75, v76, v77, v78, v79, v80);
      goto LABEL_240;
    case 0x72u:
      appendStringInfoString((uint64_t)a1, "\"NamedArgExpr\":{");
      _outNamedArgExpr((uint64_t)a1, (uint64_t)a2, v81, v82, v83, v84, v85, v86);
      goto LABEL_240;
    case 0x73u:
      appendStringInfoString((uint64_t)a1, "\"OpExpr\":{");
      _outOpExpr((uint64_t)a1, (uint64_t)a2, v87, v88, v89, v90, v91, v92);
      goto LABEL_240;
    case 0x74u:
      appendStringInfoString((uint64_t)a1, "\"DistinctExpr\":{");
      _outOpExpr((uint64_t)a1, (uint64_t)a2, v93, v94, v95, v96, v97, v98);
      goto LABEL_240;
    case 0x75u:
      appendStringInfoString((uint64_t)a1, "\"NullIfExpr\":{");
      _outOpExpr((uint64_t)a1, (uint64_t)a2, v99, v100, v101, v102, v103, v104);
      goto LABEL_240;
    case 0x76u:
      appendStringInfoString((uint64_t)a1, "\"ScalarArrayOpExpr\":{");
      _outScalarArrayOpExpr((uint64_t)a1, (uint64_t)a2, v105, v106, v107, v108, v109, v110);
      goto LABEL_240;
    case 0x77u:
      appendStringInfoString((uint64_t)a1, "\"BoolExpr\":{");
      _outBoolExpr((uint64_t)a1, (uint64_t)a2, v111, v112, v113, v114, v115, v116);
      goto LABEL_240;
    case 0x78u:
      appendStringInfoString((uint64_t)a1, "\"SubLink\":{");
      _outSubLink((uint64_t)a1, (uint64_t)a2, v117, v118, v119, v120, v121, v122);
      goto LABEL_240;
    case 0x79u:
      appendStringInfoString((uint64_t)a1, "\"SubPlan\":{");
      _outSubPlan(a1, (uint64_t)a2, v123, v124, v125, v126, v127, v128);
      goto LABEL_240;
    case 0x7Au:
      appendStringInfoString((uint64_t)a1, "\"AlternativeSubPlan\":{");
      _outAlternativeSubPlan((unint64_t)a1, (uint64_t)a2, v129, v130, v131, v132, v133, v134, v1357);
      goto LABEL_240;
    case 0x7Bu:
      appendStringInfoString((uint64_t)a1, "\"FieldSelect\":{");
      _outFieldSelect((uint64_t)a1, (uint64_t)a2, v135, v136, v137, v138, v139, v140);
      goto LABEL_240;
    case 0x7Cu:
      appendStringInfoString((uint64_t)a1, "\"FieldStore\":{");
      _outFieldStore((uint64_t)a1, (uint64_t)a2, v141, v142, v143, v144, v145, v146);
      goto LABEL_240;
    case 0x7Du:
      appendStringInfoString((uint64_t)a1, "\"RelabelType\":{");
      _outRelabelType((uint64_t)a1, (uint64_t)a2, v147, v148, v149, v150, v151, v152);
      goto LABEL_240;
    case 0x7Eu:
      appendStringInfoString((uint64_t)a1, "\"CoerceViaIO\":{");
      _outCoerceViaIO((uint64_t)a1, (uint64_t)a2, v153, v154, v155, v156, v157, v158);
      goto LABEL_240;
    case 0x7Fu:
      appendStringInfoString((uint64_t)a1, "\"ArrayCoerceExpr\":{");
      _outArrayCoerceExpr((uint64_t)a1, (uint64_t)a2, v159, v160, v161, v162, v163, v164);
      goto LABEL_240;
    case 0x80u:
      appendStringInfoString((uint64_t)a1, "\"ConvertRowtypeExpr\":{");
      _outConvertRowtypeExpr((uint64_t)a1, (uint64_t)a2, v165, v166, v167, v168, v169, v170);
      goto LABEL_240;
    case 0x81u:
      appendStringInfoString((uint64_t)a1, "\"CollateExpr\":{");
      _outCollateExpr((uint64_t)a1, (uint64_t)a2, v171, v172, v173, v174, v175, v176);
      goto LABEL_240;
    case 0x82u:
      appendStringInfoString((uint64_t)a1, "\"CaseExpr\":{");
      _outCaseExpr((uint64_t)a1, (uint64_t)a2, v177, v178, v179, v180, v181, v182);
      goto LABEL_240;
    case 0x83u:
      appendStringInfoString((uint64_t)a1, "\"CaseWhen\":{");
      _outCaseWhen((uint64_t)a1, (uint64_t)a2, v183, v184, v185, v186, v187, v188);
      goto LABEL_240;
    case 0x84u:
      appendStringInfoString((uint64_t)a1, "\"CaseTestExpr\":{");
      _outCaseTestExpr((uint64_t)a1, a2, v189, v190, v191, v192, v193, v194);
      goto LABEL_240;
    case 0x85u:
      appendStringInfoString((uint64_t)a1, "\"ArrayExpr\":{");
      _outArrayExpr((uint64_t)a1, (uint64_t)a2, v195, v196, v197, v198, v199, v200);
      goto LABEL_240;
    case 0x86u:
      appendStringInfoString((uint64_t)a1, "\"RowExpr\":{");
      _outRowExpr((uint64_t)a1, (uint64_t)a2, v201, v202, v203, v204, v205, v206);
      goto LABEL_240;
    case 0x87u:
      appendStringInfoString((uint64_t)a1, "\"RowCompareExpr\":{");
      _outRowCompareExpr((uint64_t)a1, (uint64_t)a2, v207, v208, v209, v210, v211, v212, v1357);
      goto LABEL_240;
    case 0x88u:
      appendStringInfoString((uint64_t)a1, "\"CoalesceExpr\":{");
      _outCoalesceExpr((uint64_t)a1, (uint64_t)a2, v213, v214, v215, v216, v217, v218);
      goto LABEL_240;
    case 0x89u:
      appendStringInfoString((uint64_t)a1, "\"MinMaxExpr\":{");
      _outMinMaxExpr((uint64_t)a1, (uint64_t)a2, v219, v220, v221, v222, v223, v224);
      goto LABEL_240;
    case 0x8Au:
      appendStringInfoString((uint64_t)a1, "\"SQLValueFunction\":{");
      _outSQLValueFunction((uint64_t)a1, (uint64_t)a2, v225, v226, v227, v228, v229, v230);
      goto LABEL_240;
    case 0x8Bu:
      appendStringInfoString((uint64_t)a1, "\"XmlExpr\":{");
      _outXmlExpr(a1, (uint64_t)a2, v231, v232, v233, v234, v235, v236);
      goto LABEL_240;
    case 0x8Cu:
      appendStringInfoString((uint64_t)a1, "\"NullTest\":{");
      _outNullTest((uint64_t)a1, (uint64_t)a2, v237, v238, v239, v240, v241, v242);
      goto LABEL_240;
    case 0x8Du:
      appendStringInfoString((uint64_t)a1, "\"BooleanTest\":{");
      _outBooleanTest((uint64_t)a1, (uint64_t)a2, v243, v244, v245, v246, v247, v248);
      goto LABEL_240;
    case 0x8Eu:
      appendStringInfoString((uint64_t)a1, "\"CoerceToDomain\":{");
      _outCoerceToDomain((uint64_t)a1, (uint64_t)a2, v249, v250, v251, v252, v253, v254);
      goto LABEL_240;
    case 0x8Fu:
      appendStringInfoString((uint64_t)a1, "\"CoerceToDomainValue\":{");
      _outCoerceToDomainValue((uint64_t)a1, a2, v255, v256, v257, v258, v259, v260);
      goto LABEL_240;
    case 0x90u:
      appendStringInfoString((uint64_t)a1, "\"SetToDefault\":{");
      _outCoerceToDomainValue((uint64_t)a1, a2, v261, v262, v263, v264, v265, v266);
      goto LABEL_240;
    case 0x91u:
      appendStringInfoString((uint64_t)a1, "\"CurrentOfExpr\":{");
      _outCurrentOfExpr((uint64_t)a1, (uint64_t)a2, v267, v268, v269, v270, v271, v272);
      goto LABEL_240;
    case 0x92u:
      appendStringInfoString((uint64_t)a1, "\"NextValueExpr\":{");
      _outNextValueExpr((uint64_t)a1, (uint64_t)a2, v273, v274, v275, v276, v277, v278);
      goto LABEL_240;
    case 0x93u:
      appendStringInfoString((uint64_t)a1, "\"InferenceElem\":{");
      _outInferenceElem((uint64_t)a1, (uint64_t)a2, v279, v280, v281, v282, v283, v284);
      goto LABEL_240;
    case 0x94u:
      appendStringInfoString((uint64_t)a1, "\"TargetEntry\":{");
      _outTargetEntry((uint64_t)a1, (uint64_t)a2, v285, v286, v287, v288, v289, v290);
      goto LABEL_240;
    case 0x95u:
      appendStringInfoString((uint64_t)a1, "\"RangeTblRef\":{");
      if (a2[1])
        appendStringInfo((uint64_t)a1, "\"rtindex\":%d,", v17, v18, v19, v20, v21, v22, a2[1]);
      goto LABEL_240;
    case 0x96u:
      appendStringInfoString((uint64_t)a1, "\"JoinExpr\":{");
      _outJoinExpr((uint64_t)a1, (uint64_t)a2, v291, v292, v293, v294, v295, v296);
      goto LABEL_240;
    case 0x97u:
      appendStringInfoString((uint64_t)a1, "\"FromExpr\":{");
      _outFromExpr((uint64_t)a1, (uint64_t)a2, v297, v298, v299, v300, v301, v302, v1357);
      goto LABEL_240;
    case 0x98u:
      appendStringInfoString((uint64_t)a1, "\"OnConflictExpr\":{");
      _outOnConflictExpr((uint64_t)a1, (uint64_t)a2, v303, v304, v305, v306, v307, v308, v1357);
      goto LABEL_240;
    case 0x99u:
      appendStringInfoString((uint64_t)a1, "\"IntoClause\":{");
      _outIntoClause(a1, (uint64_t)a2, v309, v310, v311, v312, v313, v314);
      goto LABEL_240;
    case 0xDDu:
      appendStringInfoString((uint64_t)a1, "\"Integer\":{");
      appendStringInfo((uint64_t)a1, "\"ival\":%d,", v315, v316, v317, v318, v319, v320, a2[2]);
      goto LABEL_240;
    case 0xDEu:
      appendStringInfoString((uint64_t)a1, "\"Float\":{");
      _outFloat(a1, (uint64_t)a2, v321, v322, v323, v324, v325, v326, v1357);
      goto LABEL_240;
    case 0xDFu:
      appendStringInfoString((uint64_t)a1, "\"String\":{");
      _outFloat(a1, (uint64_t)a2, v327, v328, v329, v330, v331, v332, v1357);
      goto LABEL_240;
    case 0xE0u:
      appendStringInfoString((uint64_t)a1, "\"BitString\":{");
      _outFloat(a1, (uint64_t)a2, v333, v334, v335, v336, v337, v338, v1357);
      goto LABEL_240;
    case 0xE1u:
      v36 = "\"Null\":{";
      goto LABEL_190;
    case 0xE2u:
      appendStringInfoString((uint64_t)a1, "\"List\":{");
      _outList((uint64_t)a1, (uint64_t)a2, v339, v340, v341, v342, v343, v344, v1357);
      goto LABEL_240;
    case 0xE3u:
      appendStringInfoString((uint64_t)a1, "\"IntList\":{");
      _outIntList((uint64_t)a1, (uint64_t)a2, v345, v346, v347, v348, v349, v350, v1357);
      goto LABEL_240;
    case 0xE4u:
      appendStringInfoString((uint64_t)a1, "\"OidList\":{");
      _outOidList((uint64_t)a1, (uint64_t)a2, v351, v352, v353, v354, v355, v356, v1357);
      goto LABEL_240;
    case 0xE6u:
      appendStringInfoString((uint64_t)a1, "\"RawStmt\":{");
      _outRawStmt((uint64_t)a1, (uint64_t)a2, v357, v358, v359, v360, v361, v362);
      goto LABEL_240;
    case 0xE7u:
      appendStringInfoString((uint64_t)a1, "\"Query\":{");
      _outQuery((uint64_t)a1, (uint64_t)a2, v363, v364, v365, v366, v367, v368);
      goto LABEL_240;
    case 0xE9u:
      appendStringInfoString((uint64_t)a1, "\"InsertStmt\":{");
      _outInsertStmt((uint64_t)a1, (uint64_t)a2, v369, v370, v371, v372, v373, v374);
      goto LABEL_240;
    case 0xEAu:
      appendStringInfoString((uint64_t)a1, "\"DeleteStmt\":{");
      _outDeleteStmt((uint64_t)a1, (uint64_t *)a2, v375, v376, v377, v378, v379, v380, v1357);
      goto LABEL_240;
    case 0xEBu:
      appendStringInfoString((uint64_t)a1, "\"UpdateStmt\":{");
      _outUpdateStmt((uint64_t)a1, (uint64_t *)a2, v381, v382, v383, v384, v385, v386, v1357);
      goto LABEL_240;
    case 0xECu:
      appendStringInfoString((uint64_t)a1, "\"SelectStmt\":{");
      _outSelectStmt(a1, (uint64_t)a2, v387, v388, v389, v390, v391, v392, v1357);
      goto LABEL_240;
    case 0xEDu:
      appendStringInfoString((uint64_t)a1, "\"AlterTableStmt\":{");
      _outAlterTableStmt((uint64_t)a1, (uint64_t)a2, v393, v394, v395, v396, v397, v398);
      goto LABEL_240;
    case 0xEEu:
      appendStringInfoString((uint64_t)a1, "\"AlterTableCmd\":{");
      _outAlterTableCmd(a1, (uint64_t)a2, v399, v400, v401, v402, v403, v404);
      goto LABEL_240;
    case 0xEFu:
      appendStringInfoString((uint64_t)a1, "\"AlterDomainStmt\":{");
      _outAlterDomainStmt(a1, (uint64_t)a2, v405, v406, v407, v408, v409, v410);
      goto LABEL_240;
    case 0xF0u:
      appendStringInfoString((uint64_t)a1, "\"SetOperationStmt\":{");
      _outSetOperationStmt((uint64_t)a1, (uint64_t)a2, v411, v412, v413, v414, v415, v416, v1357);
      goto LABEL_240;
    case 0xF1u:
      appendStringInfoString((uint64_t)a1, "\"GrantStmt\":{");
      _outGrantStmt((uint64_t)a1, (uint64_t)a2, v417, v418, v419, v420, v421, v422);
      goto LABEL_240;
    case 0xF2u:
      appendStringInfoString((uint64_t)a1, "\"GrantRoleStmt\":{");
      _outGrantRoleStmt(a1, (uint64_t)a2, v423, v424, v425, v426, v427, v428);
      goto LABEL_240;
    case 0xF3u:
      appendStringInfoString((uint64_t)a1, "\"AlterDefaultPrivilegesStmt\":{");
      _outAlterDefaultPrivilegesStmt((uint64_t)a1, (uint64_t)a2, v429, v430, v431, v432, v433, v434, v1357);
      goto LABEL_240;
    case 0xF4u:
      appendStringInfoString((uint64_t)a1, "\"ClosePortalStmt\":{");
      _outClosePortalStmt((unint64_t)a1, (uint64_t)a2, v435, v436, v437, v438, v439, v440, v1357);
      goto LABEL_240;
    case 0xF5u:
      appendStringInfoString((uint64_t)a1, "\"ClusterStmt\":{");
      _outClusterStmt((uint64_t)a1, (uint64_t)a2, v441, v442, v443, v444, v445, v446);
      goto LABEL_240;
    case 0xF6u:
      appendStringInfoString((uint64_t)a1, "\"CopyStmt\":{");
      _outCopyStmt((uint64_t)a1, (uint64_t)a2, v447, v448, v449, v450, v451, v452, v1357);
      goto LABEL_240;
    case 0xF7u:
      appendStringInfoString((uint64_t)a1, "\"CreateStmt\":{");
      _outCreateStmt(a1, (uint64_t)a2, v453, v454, v455, v456, v457, v458);
      goto LABEL_240;
    case 0xF8u:
      appendStringInfoString((uint64_t)a1, "\"DefineStmt\":{");
      _outDefineStmt((uint64_t)a1, (uint64_t)a2, v459, v460, v461, v462, v463, v464);
      goto LABEL_240;
    case 0xF9u:
      appendStringInfoString((uint64_t)a1, "\"DropStmt\":{");
      _outDropStmt((uint64_t)a1, (uint64_t)a2, v465, v466, v467, v468, v469, v470);
      goto LABEL_240;
    case 0xFAu:
      appendStringInfoString((uint64_t)a1, "\"TruncateStmt\":{");
      _outTruncateStmt((uint64_t)a1, (uint64_t)a2, v471, v472, v473, v474, v475, v476);
      goto LABEL_240;
    case 0xFBu:
      appendStringInfoString((uint64_t)a1, "\"CommentStmt\":{");
      _outCommentStmt(a1, (uint64_t)a2, v477, v478, v479, v480, v481, v482, v1357);
      goto LABEL_240;
    case 0xFCu:
      appendStringInfoString((uint64_t)a1, "\"FetchStmt\":{");
      _outFetchStmt(a1, (uint64_t)a2, v483, v484, v485, v486, v487, v488);
      goto LABEL_240;
    case 0xFDu:
      appendStringInfoString((uint64_t)a1, "\"IndexStmt\":{");
      _outIndexStmt((uint64_t)a1, (uint64_t)a2, v489, v490, v491, v492, v493, v494);
      goto LABEL_240;
    case 0xFEu:
      appendStringInfoString((uint64_t)a1, "\"CreateFunctionStmt\":{");
      _outCreateFunctionStmt((uint64_t)a1, (uint64_t)a2, v495, v496, v497, v498, v499, v500, v1357);
      goto LABEL_240;
    case 0xFFu:
      appendStringInfoString((uint64_t)a1, "\"AlterFunctionStmt\":{");
      _outAlterFunctionStmt((uint64_t)a1, (uint64_t)a2, v501, v502, v503, v504, v505, v506, v1357);
      goto LABEL_240;
    case 0x100u:
      appendStringInfoString((uint64_t)a1, "\"DoStmt\":{");
      _outDoStmt((unint64_t)a1, (uint64_t)a2, v507, v508, v509, v510, v511, v512, v1357);
      goto LABEL_240;
    case 0x101u:
      appendStringInfoString((uint64_t)a1, "\"RenameStmt\":{");
      _outRenameStmt(a1, (uint64_t)a2, v513, v514, v515, v516, v517, v518);
      goto LABEL_240;
    case 0x102u:
      appendStringInfoString((uint64_t)a1, "\"RuleStmt\":{");
      _outRuleStmt(a1, (uint64_t)a2, v519, v520, v521, v522, v523, v524);
      goto LABEL_240;
    case 0x103u:
      appendStringInfoString((uint64_t)a1, "\"NotifyStmt\":{");
      _outNotifyStmt((uint64_t)a1, (uint64_t)a2, v525, v526, v527, v528, v529, v530, v1357);
      goto LABEL_240;
    case 0x104u:
      appendStringInfoString((uint64_t)a1, "\"ListenStmt\":{");
      _outListenStmt((unint64_t)a1, (uint64_t)a2, v531, v532, v533, v534, v535, v536, v1357);
      goto LABEL_240;
    case 0x105u:
      appendStringInfoString((uint64_t)a1, "\"UnlistenStmt\":{");
      _outListenStmt((unint64_t)a1, (uint64_t)a2, v537, v538, v539, v540, v541, v542, v1357);
      goto LABEL_240;
    case 0x106u:
      appendStringInfoString((uint64_t)a1, "\"TransactionStmt\":{");
      _outTransactionStmt(a1, (uint64_t)a2, v543, v544, v545, v546, v547, v548);
      goto LABEL_240;
    case 0x107u:
      appendStringInfoString((uint64_t)a1, "\"ViewStmt\":{");
      _outViewStmt((uint64_t)a1, (uint64_t)a2, v549, v550, v551, v552, v553, v554);
      goto LABEL_240;
    case 0x108u:
      appendStringInfoString((uint64_t)a1, "\"LoadStmt\":{");
      _outLoadStmt((unint64_t)a1, (uint64_t)a2, v555, v556, v557, v558, v559, v560, v1357);
      goto LABEL_240;
    case 0x109u:
      appendStringInfoString((uint64_t)a1, "\"CreateDomainStmt\":{");
      _outCreateDomainStmt((uint64_t)a1, a2, v561, v562, v563, v564, v565, v566, v1357);
      goto LABEL_240;
    case 0x10Au:
      appendStringInfoString((uint64_t)a1, "\"CreatedbStmt\":{");
      _outCreatedbStmt((uint64_t)a1, (uint64_t)a2, v567, v568, v569, v570, v571, v572, v1357);
      goto LABEL_240;
    case 0x10Bu:
      appendStringInfoString((uint64_t)a1, "\"DropdbStmt\":{");
      _outDropdbStmt((uint64_t)a1, (uint64_t)a2, v573, v574, v575, v576, v577, v578, v1357);
      goto LABEL_240;
    case 0x10Cu:
      appendStringInfoString((uint64_t)a1, "\"VacuumStmt\":{");
      _outVacuumStmt((uint64_t)a1, (uint64_t)a2, v579, v580, v581, v582, v583, v584);
      goto LABEL_240;
    case 0x10Du:
      appendStringInfoString((uint64_t)a1, "\"ExplainStmt\":{");
      _outExplainStmt((uint64_t)a1, (uint64_t)a2, v585, v586, v587, v588, v589, v590, v1357);
      goto LABEL_240;
    case 0x10Eu:
      appendStringInfoString((uint64_t)a1, "\"CreateTableAsStmt\":{");
      _outCreateTableAsStmt(a1, (uint64_t)a2, v591, v592, v593, v594, v595, v596);
      goto LABEL_240;
    case 0x10Fu:
      appendStringInfoString((uint64_t)a1, "\"CreateSeqStmt\":{");
      _outCreateSeqStmt((uint64_t)a1, (uint64_t)a2, v597, v598, v599, v600, v601, v602);
      goto LABEL_240;
    case 0x110u:
      appendStringInfoString((uint64_t)a1, "\"AlterSeqStmt\":{");
      _outAlterSeqStmt((uint64_t)a1, (uint64_t)a2, v603, v604, v605, v606, v607, v608);
      goto LABEL_240;
    case 0x111u:
      appendStringInfoString((uint64_t)a1, "\"VariableSetStmt\":{");
      _outVariableSetStmt(a1, (uint64_t)a2, v609, v610, v611, v612, v613, v614);
      goto LABEL_240;
    case 0x112u:
      appendStringInfoString((uint64_t)a1, "\"VariableShowStmt\":{");
      _outVariableShowStmt((unint64_t)a1, (uint64_t)a2, v615, v616, v617, v618, v619, v620, v1357);
      goto LABEL_240;
    case 0x113u:
      appendStringInfoString((uint64_t)a1, "\"DiscardStmt\":{");
      _outDiscardStmt((uint64_t)a1, a2[1], v621, v622, v623, v624, v625, v626);
      goto LABEL_240;
    case 0x114u:
      appendStringInfoString((uint64_t)a1, "\"CreateTrigStmt\":{");
      _outCreateTrigStmt((uint64_t)a1, (uint64_t)a2, v627, v628, v629, v630, v631, v632, v1357);
      goto LABEL_240;
    case 0x115u:
      appendStringInfoString((uint64_t)a1, "\"CreatePLangStmt\":{");
      _outCreatePLangStmt((uint64_t)a1, (uint64_t)a2, v633, v634, v635, v636, v637, v638);
      goto LABEL_240;
    case 0x116u:
      appendStringInfoString((uint64_t)a1, "\"CreateRoleStmt\":{");
      _outCreateRoleStmt(a1, (uint64_t)a2, v639, v640, v641, v642, v643, v644, v1357);
      goto LABEL_240;
    case 0x117u:
      appendStringInfoString((uint64_t)a1, "\"AlterRoleStmt\":{");
      _outAlterRoleStmt((uint64_t)a1, (uint64_t)a2, v645, v646, v647, v648, v649, v650);
      goto LABEL_240;
    case 0x118u:
      appendStringInfoString((uint64_t)a1, "\"DropRoleStmt\":{");
      _outDropRoleStmt((uint64_t)a1, (uint64_t)a2, v651, v652, v653, v654, v655, v656);
      goto LABEL_240;
    case 0x119u:
      appendStringInfoString((uint64_t)a1, "\"LockStmt\":{");
      _outLockStmt((uint64_t)a1, (uint64_t)a2, v657, v658, v659, v660, v661, v662);
      goto LABEL_240;
    case 0x11Au:
      appendStringInfoString((uint64_t)a1, "\"ConstraintsSetStmt\":{");
      _outConstraintsSetStmt((uint64_t)a1, (uint64_t)a2, v663, v664, v665, v666, v667, v668);
      goto LABEL_240;
    case 0x11Bu:
      appendStringInfoString((uint64_t)a1, "\"ReindexStmt\":{");
      _outReindexStmt(a1, (uint64_t)a2, v669, v670, v671, v672, v673, v674);
      goto LABEL_240;
    case 0x11Cu:
      v36 = "\"CheckPointStmt\":{";
      goto LABEL_190;
    case 0x11Du:
      appendStringInfoString((uint64_t)a1, "\"CreateSchemaStmt\":{");
      _outCreateSchemaStmt((uint64_t)a1, (uint64_t)a2, v675, v676, v677, v678, v679, v680);
      goto LABEL_240;
    case 0x11Eu:
      appendStringInfoString((uint64_t)a1, "\"AlterDatabaseStmt\":{");
      _outCreatedbStmt((uint64_t)a1, (uint64_t)a2, v681, v682, v683, v684, v685, v686, v1357);
      goto LABEL_240;
    case 0x11Fu:
      appendStringInfoString((uint64_t)a1, "\"AlterDatabaseSetStmt\":{");
      _outAlterDatabaseSetStmt((uint64_t)a1, (uint64_t)a2, v687, v688, v689, v690, v691, v692, v1357);
      goto LABEL_240;
    case 0x120u:
      appendStringInfoString((uint64_t)a1, "\"AlterRoleSetStmt\":{");
      _outAlterRoleSetStmt((uint64_t)a1, (uint64_t)a2, v693, v694, v695, v696, v697, v698, v1357);
      goto LABEL_240;
    case 0x121u:
      appendStringInfoString((uint64_t)a1, "\"CreateConversionStmt\":{");
      _outCreateConversionStmt((uint64_t)a1, (uint64_t)a2, v699, v700, v701, v702, v703, v704);
      goto LABEL_240;
    case 0x122u:
      appendStringInfoString((uint64_t)a1, "\"CreateCastStmt\":{");
      _outCreateCastStmt((uint64_t)a1, (uint64_t)a2, v705, v706, v707, v708, v709, v710);
      goto LABEL_240;
    case 0x123u:
      appendStringInfoString((uint64_t)a1, "\"CreateOpClassStmt\":{");
      _outCreateOpClassStmt((uint64_t)a1, (uint64_t)a2, v711, v712, v713, v714, v715, v716);
      goto LABEL_240;
    case 0x124u:
      appendStringInfoString((uint64_t)a1, "\"CreateOpFamilyStmt\":{");
      _outCreateOpFamilyStmt((uint64_t)a1, (uint64_t)a2, v717, v718, v719, v720, v721, v722, v1357);
      goto LABEL_240;
    case 0x125u:
      appendStringInfoString((uint64_t)a1, "\"AlterOpFamilyStmt\":{");
      _outAlterOpFamilyStmt((uint64_t)a1, (uint64_t)a2, v723, v724, v725, v726, v727, v728, v1357);
      goto LABEL_240;
    case 0x126u:
      appendStringInfoString((uint64_t)a1, "\"PrepareStmt\":{");
      _outPrepareStmt((uint64_t)a1, (uint64_t)a2, v729, v730, v731, v732, v733, v734, v1357);
      goto LABEL_240;
    case 0x127u:
      appendStringInfoString((uint64_t)a1, "\"ExecuteStmt\":{");
      _outExecuteStmt((uint64_t)a1, (uint64_t)a2, v735, v736, v737, v738, v739, v740, v1357);
      goto LABEL_240;
    case 0x128u:
      appendStringInfoString((uint64_t)a1, "\"DeallocateStmt\":{");
      _outVariableShowStmt((unint64_t)a1, (uint64_t)a2, v741, v742, v743, v744, v745, v746, v1357);
      goto LABEL_240;
    case 0x129u:
      appendStringInfoString((uint64_t)a1, "\"DeclareCursorStmt\":{");
      _outDeclareCursorStmt((uint64_t)a1, (uint64_t)a2, v747, v748, v749, v750, v751, v752, v1357);
      goto LABEL_240;
    case 0x12Au:
      appendStringInfoString((uint64_t)a1, "\"CreateTableSpaceStmt\":{");
      _outCreateTableSpaceStmt((uint64_t)a1, (uint64_t)a2, v753, v754, v755, v756, v757, v758, v1357);
      goto LABEL_240;
    case 0x12Bu:
      appendStringInfoString((uint64_t)a1, "\"DropTableSpaceStmt\":{");
      _outDropTableSpaceStmt((uint64_t)a1, (uint64_t)a2, v759, v760, v761, v762, v763, v764);
      goto LABEL_240;
    case 0x12Cu:
      appendStringInfoString((uint64_t)a1, "\"AlterObjectDependsStmt\":{");
      _outAlterObjectDependsStmt((uint64_t)a1, (uint64_t)a2, v765, v766, v767, v768, v769, v770);
      goto LABEL_240;
    case 0x12Du:
      appendStringInfoString((uint64_t)a1, "\"AlterObjectSchemaStmt\":{");
      _outAlterObjectSchemaStmt(a1, (uint64_t)a2, v771, v772, v773, v774, v775, v776);
      goto LABEL_240;
    case 0x12Eu:
      appendStringInfoString((uint64_t)a1, "\"AlterOwnerStmt\":{");
      _outAlterOwnerStmt(a1, (uint64_t)a2, v777, v778, v779, v780, v781, v782, v1357);
      goto LABEL_240;
    case 0x12Fu:
      appendStringInfoString((uint64_t)a1, "\"AlterOperatorStmt\":{");
      _outAlterOperatorStmt((uint64_t)a1, (uint64_t)a2, v783, v784, v785, v786, v787, v788, v1357);
      goto LABEL_240;
    case 0x130u:
      appendStringInfoString((uint64_t)a1, "\"AlterTypeStmt\":{");
      _outAlterTypeStmt((uint64_t)a1, (uint64_t)a2, v789, v790, v791, v792, v793, v794, v1357);
      goto LABEL_240;
    case 0x131u:
      appendStringInfoString((uint64_t)a1, "\"DropOwnedStmt\":{");
      _outDropOwnedStmt((uint64_t)a1, (uint64_t)a2, v795, v796, v797, v798, v799, v800);
      goto LABEL_240;
    case 0x132u:
      appendStringInfoString((uint64_t)a1, "\"ReassignOwnedStmt\":{");
      _outReassignOwnedStmt((uint64_t)a1, (uint64_t)a2, v801, v802, v803, v804, v805, v806, v1357);
      goto LABEL_240;
    case 0x133u:
      appendStringInfoString((uint64_t)a1, "\"CompositeTypeStmt\":{");
      _outCompositeTypeStmt((uint64_t)a1, (uint64_t)a2, v807, v808, v809, v810, v811, v812, v1357);
      goto LABEL_240;
    case 0x134u:
      appendStringInfoString((uint64_t)a1, "\"CreateEnumStmt\":{");
      _outCreateEnumStmt((uint64_t)a1, (uint64_t)a2, v813, v814, v815, v816, v817, v818, v1357);
      goto LABEL_240;
    case 0x135u:
      appendStringInfoString((uint64_t)a1, "\"CreateRangeStmt\":{");
      _outCreateRangeStmt((uint64_t)a1, (uint64_t)a2, v819, v820, v821, v822, v823, v824, v1357);
      goto LABEL_240;
    case 0x136u:
      appendStringInfoString((uint64_t)a1, "\"AlterEnumStmt\":{");
      _outAlterEnumStmt((uint64_t)a1, (uint64_t)a2, v825, v826, v827, v828, v829, v830);
      goto LABEL_240;
    case 0x137u:
      appendStringInfoString((uint64_t)a1, "\"AlterTSDictionaryStmt\":{");
      _outAlterTSDictionaryStmt((uint64_t)a1, (uint64_t)a2, v831, v832, v833, v834, v835, v836, v1357);
      goto LABEL_240;
    case 0x138u:
      appendStringInfoString((uint64_t)a1, "\"AlterTSConfigurationStmt\":{");
      _outAlterTSConfigurationStmt((uint64_t)a1, (uint64_t)a2, v837, v838, v839, v840, v841, v842);
      goto LABEL_240;
    case 0x139u:
      appendStringInfoString((uint64_t)a1, "\"CreateFdwStmt\":{");
      _outCreateFdwStmt((uint64_t)a1, (uint64_t)a2, v843, v844, v845, v846, v847, v848, v1357);
      goto LABEL_240;
    case 0x13Au:
      appendStringInfoString((uint64_t)a1, "\"AlterFdwStmt\":{");
      _outCreateFdwStmt((uint64_t)a1, (uint64_t)a2, v849, v850, v851, v852, v853, v854, v1357);
      goto LABEL_240;
    case 0x13Bu:
      appendStringInfoString((uint64_t)a1, "\"CreateForeignServerStmt\":{");
      _outCreateForeignServerStmt((uint64_t)a1, (uint64_t)a2, v855, v856, v857, v858, v859, v860, v1357);
      goto LABEL_240;
    case 0x13Cu:
      appendStringInfoString((uint64_t)a1, "\"AlterForeignServerStmt\":{");
      _outAlterForeignServerStmt((uint64_t)a1, (uint64_t)a2, v861, v862, v863, v864, v865, v866);
      goto LABEL_240;
    case 0x13Du:
      appendStringInfoString((uint64_t)a1, "\"CreateUserMappingStmt\":{");
      _outCreateUserMappingStmt((uint64_t)a1, (uint64_t)a2, v867, v868, v869, v870, v871, v872, v1357);
      goto LABEL_240;
    case 0x13Eu:
      appendStringInfoString((uint64_t)a1, "\"AlterUserMappingStmt\":{");
      _outAlterUserMappingStmt((uint64_t)a1, (uint64_t)a2, v873, v874, v875, v876, v877, v878, v1357);
      goto LABEL_240;
    case 0x13Fu:
      appendStringInfoString((uint64_t)a1, "\"DropUserMappingStmt\":{");
      _outDropUserMappingStmt((uint64_t)a1, (uint64_t)a2, v879, v880, v881, v882, v883, v884);
      goto LABEL_240;
    case 0x140u:
      appendStringInfoString((uint64_t)a1, "\"AlterTableSpaceOptionsStmt\":{");
      _outAlterTableSpaceOptionsStmt((uint64_t)a1, (uint64_t)a2, v885, v886, v887, v888, v889, v890);
      goto LABEL_240;
    case 0x141u:
      appendStringInfoString((uint64_t)a1, "\"AlterTableMoveAllStmt\":{");
      _outAlterTableMoveAllStmt(a1, (uint64_t)a2, v891, v892, v893, v894, v895, v896);
      goto LABEL_240;
    case 0x142u:
      appendStringInfoString((uint64_t)a1, "\"SecLabelStmt\":{");
      _outSecLabelStmt(a1, (uint64_t)a2, v897, v898, v899, v900, v901, v902, v1357);
      goto LABEL_240;
    case 0x143u:
      appendStringInfoString((uint64_t)a1, "\"CreateForeignTableStmt\":{");
      _outCreateForeignTableStmt(a1, (uint64_t)a2, v903, v904, v905, v906, v907, v908, v1357);
      goto LABEL_240;
    case 0x144u:
      appendStringInfoString((uint64_t)a1, "\"ImportForeignSchemaStmt\":{");
      _outImportForeignSchemaStmt(a1, (uint64_t)a2, v909, v910, v911, v912, v913, v914, v1357);
      goto LABEL_240;
    case 0x145u:
      appendStringInfoString((uint64_t)a1, "\"CreateExtensionStmt\":{");
      _outCreateExtensionStmt((uint64_t)a1, (uint64_t)a2, v915, v916, v917, v918, v919, v920, v1357);
      goto LABEL_240;
    case 0x146u:
      appendStringInfoString((uint64_t)a1, "\"AlterExtensionStmt\":{");
      _outAlterExtensionStmt((uint64_t)a1, (uint64_t)a2, v921, v922, v923, v924, v925, v926, v1357);
      goto LABEL_240;
    case 0x147u:
      appendStringInfoString((uint64_t)a1, "\"AlterExtensionContentsStmt\":{");
      _outAlterExtensionContentsStmt(a1, (uint64_t)a2, v927, v928, v929, v930, v931, v932, v1357);
      goto LABEL_240;
    case 0x148u:
      appendStringInfoString((uint64_t)a1, "\"CreateEventTrigStmt\":{");
      _outCreateEventTrigStmt((uint64_t)a1, (uint64_t)a2, v933, v934, v935, v936, v937, v938, v1357);
      goto LABEL_240;
    case 0x149u:
      appendStringInfoString((uint64_t)a1, "\"AlterEventTrigStmt\":{");
      _outAlterEventTrigStmt((uint64_t)a1, (uint64_t)a2, v939, v940, v941, v942, v943, v944);
      goto LABEL_240;
    case 0x14Au:
      appendStringInfoString((uint64_t)a1, "\"RefreshMatViewStmt\":{");
      _outRefreshMatViewStmt((uint64_t)a1, (uint64_t)a2, v945, v946, v947, v948, v949, v950, v1357);
      goto LABEL_240;
    case 0x14Bu:
      appendStringInfoString((uint64_t)a1, "\"ReplicaIdentityStmt\":{");
      _outReplicaIdentityStmt((uint64_t)a1, (uint64_t)a2, v951, v952, v953, v954, v955, v956, v1357);
      goto LABEL_240;
    case 0x14Cu:
      appendStringInfoString((uint64_t)a1, "\"AlterSystemStmt\":{");
      _outAlterSystemStmt((unint64_t)a1, (uint64_t)a2, v957, v958, v959, v960, v961, v962, v1357);
      goto LABEL_240;
    case 0x14Du:
      appendStringInfoString((uint64_t)a1, "\"CreatePolicyStmt\":{");
      _outCreatePolicyStmt((uint64_t)a1, (uint64_t)a2, v963, v964, v965, v966, v967, v968, v1357);
      goto LABEL_240;
    case 0x14Eu:
      appendStringInfoString((uint64_t)a1, "\"AlterPolicyStmt\":{");
      _outAlterPolicyStmt((uint64_t)a1, (uint64_t)a2, v969, v970, v971, v972, v973, v974, v1357);
      goto LABEL_240;
    case 0x14Fu:
      appendStringInfoString((uint64_t)a1, "\"CreateTransformStmt\":{");
      _outCreateTransformStmt((uint64_t)a1, (uint64_t)a2, v975, v976, v977, v978, v979, v980, v1357);
      goto LABEL_240;
    case 0x150u:
      appendStringInfoString((uint64_t)a1, "\"CreateAmStmt\":{");
      _outCreateAmStmt((uint64_t)a1, (uint64_t)a2, v981, v982, v983, v984, v985, v986);
      goto LABEL_240;
    case 0x151u:
      appendStringInfoString((uint64_t)a1, "\"CreatePublicationStmt\":{");
      _outCreatePublicationStmt((uint64_t)a1, (uint64_t)a2, v987, v988, v989, v990, v991, v992);
      goto LABEL_240;
    case 0x152u:
      appendStringInfoString((uint64_t)a1, "\"AlterPublicationStmt\":{");
      _outAlterPublicationStmt(a1, (uint64_t)a2, v993, v994, v995, v996, v997, v998);
      goto LABEL_240;
    case 0x153u:
      appendStringInfoString((uint64_t)a1, "\"CreateSubscriptionStmt\":{");
      _outCreateSubscriptionStmt((uint64_t)a1, (uint64_t)a2, v999, v1000, v1001, v1002, v1003, v1004, v1357);
      goto LABEL_240;
    case 0x154u:
      appendStringInfoString((uint64_t)a1, "\"AlterSubscriptionStmt\":{");
      _outAlterSubscriptionStmt(a1, (uint64_t)a2, v1005, v1006, v1007, v1008, v1009, v1010, v1357);
      goto LABEL_240;
    case 0x155u:
      appendStringInfoString((uint64_t)a1, "\"DropSubscriptionStmt\":{");
      _outDropSubscriptionStmt(a1, (uint64_t)a2, v1011, v1012, v1013, v1014, v1015, v1016);
      goto LABEL_240;
    case 0x156u:
      appendStringInfoString((uint64_t)a1, "\"CreateStatsStmt\":{");
      _outCreateStatsStmt((uint64_t)a1, (uint64_t)a2, v1017, v1018, v1019, v1020, v1021, v1022);
      goto LABEL_240;
    case 0x157u:
      appendStringInfoString((uint64_t)a1, "\"AlterCollationStmt\":{");
      _outAlterCollationStmt((unint64_t)a1, (uint64_t)a2, v1023, v1024, v1025, v1026, v1027, v1028, v1357);
      goto LABEL_240;
    case 0x158u:
      appendStringInfoString((uint64_t)a1, "\"CallStmt\":{");
      _outCallStmt((uint64_t)a1, (uint64_t)a2, v1029, v1030, v1031, v1032, v1033, v1034, v1357);
      goto LABEL_240;
    case 0x159u:
      appendStringInfoString((uint64_t)a1, "\"AlterStatsStmt\":{");
      _outAlterStatsStmt((uint64_t)a1, (uint64_t)a2, v1035, v1036, v1037, v1038, v1039, v1040);
      goto LABEL_240;
    case 0x15Au:
      appendStringInfoString((uint64_t)a1, "\"A_Expr\":{");
      _outAExpr((uint64_t)a1, (uint64_t)a2, v1041, v1042, v1043, v1044, v1045, v1046);
      goto LABEL_240;
    case 0x15Bu:
      appendStringInfoString((uint64_t)a1, "\"ColumnRef\":{");
      _outColumnRef((uint64_t)a1, (uint64_t)a2, v1047, v1048, v1049, v1050, v1051, v1052);
      goto LABEL_240;
    case 0x15Cu:
      appendStringInfoString((uint64_t)a1, "\"ParamRef\":{");
      _outParamRef((uint64_t)a1, (uint64_t)a2, v1053, v1054, v1055, v1056, v1057, v1058);
      goto LABEL_240;
    case 0x15Du:
      appendStringInfoString((uint64_t)a1, "\"A_Const\":{");
      _outAConst((uint64_t)a1, (uint64_t)a2, v1059, v1060, v1061, v1062, v1063, v1064);
      goto LABEL_240;
    case 0x15Eu:
      appendStringInfoString((uint64_t)a1, "\"FuncCall\":{");
      _outFuncCall((uint64_t)a1, (uint64_t)a2, v1065, v1066, v1067, v1068, v1069, v1070);
      goto LABEL_240;
    case 0x15Fu:
      v36 = "\"A_Star\":{";
LABEL_190:
      appendStringInfoString((uint64_t)a1, v36);
      goto LABEL_240;
    case 0x160u:
      appendStringInfoString((uint64_t)a1, "\"A_Indices\":{");
      _outAIndices((uint64_t)a1, (uint64_t)a2, v1071, v1072, v1073, v1074, v1075, v1076, v1357);
      goto LABEL_240;
    case 0x161u:
      appendStringInfoString((uint64_t)a1, "\"A_Indirection\":{");
      _outAIndirection((uint64_t)a1, (uint64_t)a2, v1077, v1078, v1079, v1080, v1081, v1082, v1357);
      goto LABEL_240;
    case 0x162u:
      appendStringInfoString((uint64_t)a1, "\"A_ArrayExpr\":{");
      _outAArrayExpr((uint64_t)a1, (uint64_t)a2, v1083, v1084, v1085, v1086, v1087, v1088);
      goto LABEL_240;
    case 0x163u:
      appendStringInfoString((uint64_t)a1, "\"ResTarget\":{");
      _outResTarget((uint64_t)a1, (uint64_t)a2, v1089, v1090, v1091, v1092, v1093, v1094);
      goto LABEL_240;
    case 0x164u:
      appendStringInfoString((uint64_t)a1, "\"MultiAssignRef\":{");
      _outMultiAssignRef((uint64_t)a1, (uint64_t)a2, v1095, v1096, v1097, v1098, v1099, v1100);
      goto LABEL_240;
    case 0x165u:
      appendStringInfoString((uint64_t)a1, "\"TypeCast\":{");
      _outTypeCast((uint64_t)a1, (uint64_t)a2, v1101, v1102, v1103, v1104, v1105, v1106);
      goto LABEL_240;
    case 0x166u:
      appendStringInfoString((uint64_t)a1, "\"CollateClause\":{");
      _outCollateClause((uint64_t)a1, (uint64_t)a2, v1107, v1108, v1109, v1110, v1111, v1112);
      goto LABEL_240;
    case 0x167u:
      appendStringInfoString((uint64_t)a1, "\"SortBy\":{");
      _outSortBy((uint64_t)a1, (uint64_t)a2, v1113, v1114, v1115, v1116, v1117, v1118);
      goto LABEL_240;
    case 0x168u:
      appendStringInfoString((uint64_t)a1, "\"WindowDef\":{");
      _outWindowDef((uint64_t)a1, (uint64_t)a2, v1119, v1120, v1121, v1122, v1123, v1124);
      goto LABEL_240;
    case 0x169u:
      appendStringInfoString((uint64_t)a1, "\"RangeSubselect\":{");
      _outRangeSubselect((uint64_t)a1, (uint64_t)a2, v1125, v1126, v1127, v1128, v1129, v1130, v1357);
      goto LABEL_240;
    case 0x16Au:
      appendStringInfoString((uint64_t)a1, "\"RangeFunction\":{");
      _outRangeFunction((uint64_t)a1, (uint64_t)a2, v1131, v1132, v1133, v1134, v1135, v1136, v1357);
      goto LABEL_240;
    case 0x16Bu:
      appendStringInfoString((uint64_t)a1, "\"RangeTableSample\":{");
      _outRangeTableSample((uint64_t)a1, (uint64_t)a2, v1137, v1138, v1139, v1140, v1141, v1142);
      goto LABEL_240;
    case 0x16Cu:
      appendStringInfoString((uint64_t)a1, "\"RangeTableFunc\":{");
      _outRangeTableFunc((uint64_t)a1, (uint64_t)a2, v1143, v1144, v1145, v1146, v1147, v1148);
      goto LABEL_240;
    case 0x16Du:
      appendStringInfoString((uint64_t)a1, "\"RangeTableFuncCol\":{");
      _outRangeTableFuncCol((uint64_t)a1, (uint64_t)a2, v1149, v1150, v1151, v1152, v1153, v1154);
      goto LABEL_240;
    case 0x16Eu:
      appendStringInfoString((uint64_t)a1, "\"TypeName\":{");
      _outTypeName((uint64_t)a1, (uint64_t)a2, v1155, v1156, v1157, v1158, v1159, v1160);
      goto LABEL_240;
    case 0x16Fu:
      appendStringInfoString((uint64_t)a1, "\"ColumnDef\":{");
      _outColumnDef((uint64_t)a1, (uint64_t)a2, v1161, v1162, v1163, v1164, v1165, v1166);
      goto LABEL_240;
    case 0x170u:
      appendStringInfoString((uint64_t)a1, "\"IndexElem\":{");
      _outIndexElem(a1, (uint64_t)a2, v1167, v1168, v1169, v1170, v1171, v1172);
      goto LABEL_240;
    case 0x171u:
      appendStringInfoString((uint64_t)a1, "\"Constraint\":{");
      _outConstraint(a1, (uint64_t)a2, v1173, v1174, v1175, v1176, v1177, v1178);
      goto LABEL_240;
    case 0x172u:
      appendStringInfoString((uint64_t)a1, "\"DefElem\":{");
      _outDefElem(a1, (uint64_t)a2, v1179, v1180, v1181, v1182, v1183, v1184);
      goto LABEL_240;
    case 0x173u:
      appendStringInfoString((uint64_t)a1, "\"RangeTblEntry\":{");
      _outRangeTblEntry(a1, (uint64_t)a2, v1185, v1186, v1187, v1188, v1189, v1190, v1357);
      goto LABEL_240;
    case 0x174u:
      appendStringInfoString((uint64_t)a1, "\"RangeTblFunction\":{");
      _outRangeTblFunction((uint64_t)a1, (uint64_t)a2, v1191, v1192, v1193, v1194, v1195, v1196, v1357);
      goto LABEL_240;
    case 0x175u:
      appendStringInfoString((uint64_t)a1, "\"TableSampleClause\":{");
      _outTableSampleClause((uint64_t)a1, (uint64_t)a2, v1197, v1198, v1199, v1200, v1201, v1202, v1357);
      goto LABEL_240;
    case 0x176u:
      appendStringInfoString((uint64_t)a1, "\"WithCheckOption\":{");
      _outWithCheckOption(a1, (uint64_t)a2, v1203, v1204, v1205, v1206, v1207, v1208);
      goto LABEL_240;
    case 0x177u:
      appendStringInfoString((uint64_t)a1, "\"SortGroupClause\":{");
      _outSortGroupClause((uint64_t)a1, (uint64_t)a2, v1209, v1210, v1211, v1212, v1213, v1214);
      goto LABEL_240;
    case 0x178u:
      appendStringInfoString((uint64_t)a1, "\"GroupingSet\":{");
      _outGroupingSet((uint64_t)a1, (uint64_t)a2, v1215, v1216, v1217, v1218, v1219, v1220);
      goto LABEL_240;
    case 0x179u:
      appendStringInfoString((uint64_t)a1, "\"WindowClause\":{");
      _outWindowClause((uint64_t)a1, (uint64_t)a2, v1221, v1222, v1223, v1224, v1225, v1226);
      goto LABEL_240;
    case 0x17Au:
      appendStringInfoString((uint64_t)a1, "\"ObjectWithArgs\":{");
      _outObjectWithArgs((uint64_t)a1, (uint64_t)a2, v1227, v1228, v1229, v1230, v1231, v1232);
      goto LABEL_240;
    case 0x17Bu:
      appendStringInfoString((uint64_t)a1, "\"AccessPriv\":{");
      _outAccessPriv((uint64_t)a1, (uint64_t)a2, v1233, v1234, v1235, v1236, v1237, v1238, v1357);
      goto LABEL_240;
    case 0x17Cu:
      appendStringInfoString((uint64_t)a1, "\"CreateOpClassItem\":{");
      _outCreateOpClassItem((uint64_t)a1, (uint64_t)a2, v1239, v1240, v1241, v1242, v1243, v1244, v1357);
      goto LABEL_240;
    case 0x17Du:
      appendStringInfoString((uint64_t)a1, "\"TableLikeClause\":{");
      _outTableLikeClause((uint64_t)a1, (uint64_t)a2, v1245, v1246, v1247, v1248, v1249, v1250);
      goto LABEL_240;
    case 0x17Eu:
      appendStringInfoString((uint64_t)a1, "\"FunctionParameter\":{");
      _outFunctionParameter(a1, (uint64_t)a2, v1251, v1252, v1253, v1254, v1255, v1256, v1357);
      goto LABEL_240;
    case 0x17Fu:
      appendStringInfoString((uint64_t)a1, "\"LockingClause\":{");
      _outLockingClause((uint64_t)a1, (uint64_t)a2, v1257, v1258, v1259, v1260, v1261, v1262);
      goto LABEL_240;
    case 0x180u:
      appendStringInfoString((uint64_t)a1, "\"RowMarkClause\":{");
      _outRowMarkClause((uint64_t)a1, (uint64_t)a2, v1263, v1264, v1265, v1266, v1267, v1268);
      goto LABEL_240;
    case 0x181u:
      appendStringInfoString((uint64_t)a1, "\"XmlSerialize\":{");
      _outXmlSerialize((uint64_t)a1, (uint64_t)a2, v1269, v1270, v1271, v1272, v1273, v1274);
      goto LABEL_240;
    case 0x182u:
      appendStringInfoString((uint64_t)a1, "\"WithClause\":{");
      _outWithClause((uint64_t)a1, (uint64_t)a2, v1275, v1276, v1277, v1278, v1279, v1280);
      goto LABEL_240;
    case 0x183u:
      appendStringInfoString((uint64_t)a1, "\"InferClause\":{");
      _outInferClause((uint64_t)a1, (uint64_t)a2, v1281, v1282, v1283, v1284, v1285, v1286);
      goto LABEL_240;
    case 0x184u:
      appendStringInfoString((uint64_t)a1, "\"OnConflictClause\":{");
      _outOnConflictClause((uint64_t)a1, (uint64_t)a2, v1287, v1288, v1289, v1290, v1291, v1292);
      goto LABEL_240;
    case 0x185u:
      appendStringInfoString((uint64_t)a1, "\"CommonTableExpr\":{");
      _outCommonTableExpr(a1, (uint64_t)a2, v1293, v1294, v1295, v1296, v1297, v1298, v1357);
      goto LABEL_240;
    case 0x186u:
      appendStringInfoString((uint64_t)a1, "\"RoleSpec\":{");
      _outRoleSpec(a1, (uint64_t)a2, v1299, v1300, v1301, v1302, v1303, v1304);
      goto LABEL_240;
    case 0x187u:
      appendStringInfoString((uint64_t)a1, "\"TriggerTransition\":{");
      _outTriggerTransition((uint64_t)a1, (uint64_t)a2, v1305, v1306, v1307, v1308, v1309, v1310);
      goto LABEL_240;
    case 0x188u:
      appendStringInfoString((uint64_t)a1, "\"PartitionElem\":{");
      _outPartitionElem((uint64_t)a1, (uint64_t)a2, v1311, v1312, v1313, v1314, v1315, v1316);
      goto LABEL_240;
    case 0x189u:
      appendStringInfoString((uint64_t)a1, "\"PartitionSpec\":{");
      _outPartitionSpec((uint64_t)a1, (uint64_t)a2, v1317, v1318, v1319, v1320, v1321, v1322);
      goto LABEL_240;
    case 0x18Au:
      appendStringInfoString((uint64_t)a1, "\"PartitionBoundSpec\":{");
      _outPartitionBoundSpec((uint64_t)a1, (uint64_t)a2, v1323, v1324, v1325, v1326, v1327, v1328);
      goto LABEL_240;
    case 0x18Bu:
      appendStringInfoString((uint64_t)a1, "\"PartitionRangeDatum\":{");
      _outPartitionRangeDatum((uint64_t)a1, (uint64_t)a2, v1329, v1330, v1331, v1332, v1333, v1334);
      goto LABEL_240;
    case 0x18Cu:
      appendStringInfoString((uint64_t)a1, "\"PartitionCmd\":{");
      _outPartitionCmd((uint64_t)a1, (uint64_t)a2, v1335, v1336, v1337, v1338, v1339, v1340, v1357);
      goto LABEL_240;
    case 0x18Du:
      appendStringInfoString((uint64_t)a1, "\"VacuumRelation\":{");
      _outVacuumRelation((uint64_t)a1, (uint64_t)a2, v1341, v1342, v1343, v1344, v1345, v1346, v1357);
      goto LABEL_240;
    case 0x19Au:
      appendStringInfoString((uint64_t)a1, "\"InlineCodeBlock\":{");
      _outInlineCodeBlock((uint64_t)a1, (uint64_t)a2, v1347, v1348, v1349, v1350, v1351, v1352);
      goto LABEL_240;
    case 0x1A0u:
      appendStringInfoString((uint64_t)a1, "\"CallContext\":{");
      if (*((_BYTE *)a2 + 4))
        appendStringInfo((uint64_t)a1, "\"atomic\":%s,", v17, v18, v19, v20, v21, v22, (size_t)"true");
LABEL_240:
      v1353 = a1[2];
      v1354 = __OFSUB__(v1353, 1);
      v1355 = (v1353 - 1);
      if ((int)v1355 < 0 == v1354)
      {
        v1356 = *(_QWORD *)a1;
        if (*(_BYTE *)(*(_QWORD *)a1 + v1355) == 44)
        {
          a1[2] = v1355;
          *(_BYTE *)(v1356 + v1355) = 0;
        }
      }
      v43 = "}}";
      v44 = (uint64_t)a1;
      break;
    default:
      if (errstart(19, 0))
      {
        errmsg_internal("could not dump unrecognized node type: %d", *a2);
        errfinish("src/pg_query_outfuncs_json.c", 252, (uint64_t)"_outNode");
      }
      v43 = "}";
      v44 = (uint64_t)a1;
      break;
  }
  return (void *)appendStringInfo(v44, v43, v17, v18, v19, v20, v21, v22, a9);
}

unint64_t _outFloat(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v24;

  appendStringInfo((uint64_t)a1, "\"str\":", a3, a4, a5, a6, a7, a8, v24);
  _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
  return appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, a9);
}

unint64_t _outList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v24;

  appendStringInfo(a1, "\"items\":", a3, a4, a5, a6, a7, a8, v24);
  appendStringInfoChar(a1, 91);
  if (*(int *)(a2 + 4) >= 1)
  {
    v11 = 0;
    v12 = 8;
    do
    {
      v13 = *(_QWORD *)(a2 + 16);
      v14 = *(_QWORD *)(v13 + 8 * v11);
      if (v14)
        _outNode(a1, v14);
      else
        appendStringInfoString(a1, "{}");
      v15 = *(int *)(a2 + 4);
      if (v13 + v12)
        v16 = v13 + v12 >= (unint64_t)(*(_QWORD *)(a2 + 16) + 8 * v15);
      else
        v16 = 1;
      if (!v16)
      {
        appendStringInfoString(a1, ",");
        v15 = *(int *)(a2 + 4);
      }
      ++v11;
      v12 += 8;
    }
    while (v11 < v15);
  }
  appendStringInfoChar(a1, 93);
  return appendStringInfo(a1, ",", v17, v18, v19, v20, v21, v22, a9);
}

unint64_t _outIntList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v31;

  appendStringInfo(a1, "\"items\":", a3, a4, a5, a6, a7, a8, v31);
  appendStringInfoChar(a1, 91);
  if (*(int *)(a2 + 4) >= 1)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = (unsigned int *)(*(_QWORD *)(a2 + 16) + v17);
      v21 = *v19;
      v20 = (unint64_t)(v19 + 2);
      appendStringInfo(a1, "%d", v11, v12, v13, v14, v15, v16, v21);
      v22 = *(int *)(a2 + 4);
      if (v20)
        v23 = v20 >= *(_QWORD *)(a2 + 16) + 8 * v22;
      else
        v23 = 1;
      if (!v23)
      {
        appendStringInfoString(a1, ",");
        v22 = *(int *)(a2 + 4);
      }
      ++v18;
      v17 += 8;
    }
    while (v18 < v22);
  }
  appendStringInfoChar(a1, 93);
  return appendStringInfo(a1, ",", v24, v25, v26, v27, v28, v29, a9);
}

unint64_t _outOidList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v31;

  appendStringInfo(a1, "\"items\":", a3, a4, a5, a6, a7, a8, v31);
  appendStringInfoChar(a1, 91);
  if (*(int *)(a2 + 4) >= 1)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = (unsigned int *)(*(_QWORD *)(a2 + 16) + v17);
      v21 = *v19;
      v20 = (unint64_t)(v19 + 2);
      appendStringInfo(a1, "%u", v11, v12, v13, v14, v15, v16, v21);
      v22 = *(int *)(a2 + 4);
      if (v20)
        v23 = v20 >= *(_QWORD *)(a2 + 16) + 8 * v22;
      else
        v23 = 1;
      if (!v23)
      {
        appendStringInfoString(a1, ",");
        v22 = *(int *)(a2 + 4);
      }
      ++v18;
      v17 += 8;
    }
    while (v18 < v22);
  }
  appendStringInfoChar(a1, 93);
  return appendStringInfo(a1, ",", v24, v25, v26, v27, v28, v29, a9);
}

uint64_t _outAlias(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"aliasname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"colnames\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outRangeVar(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  size_t v62;
  size_t v63;
  size_t v64;
  size_t v65;
  size_t v66;
  size_t v67;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"catalogname\":", a3, a4, a5, a6, a7, a8, v62);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v63);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"schemaname\":", a3, a4, a5, a6, a7, a8, v62);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v64);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"relname\":", a3, a4, a5, a6, a7, a8, v62);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v65);
  }
  if (*(_BYTE *)(a2 + 32))
    result = appendStringInfo((uint64_t)v9, "\"inh\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 33))
    result = appendStringInfo((uint64_t)v9, "\"relpersistence\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 33));
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"alias\":{", a3, a4, a5, a6, a7, a8, v62);
    _outAlias((uint64_t)v9, *(_QWORD *)(a2 + 40), v46, v47, v48, v49, v50, v51, v66);
    v58 = v9[2];
    v59 = __OFSUB__(v58, 1);
    v60 = (v58 - 1);
    if ((int)v60 < 0 == v59)
    {
      v61 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v60) == 44)
      {
        v9[2] = v60;
        *(_BYTE *)(v61 + v60) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v52, v53, v54, v55, v56, v57, v67);
  }
  if (*(_DWORD *)(a2 + 48))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  return result;
}

unint64_t _outTableFunc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  BOOL v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  BOOL v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  BOOL v117;
  unint64_t result;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t member;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  BOOL v134;
  uint64_t v135;
  uint64_t v136;
  size_t v137;
  size_t v138;
  size_t v139;
  size_t v140;
  size_t v141;
  size_t v142;
  size_t v143;
  size_t v144;
  size_t v145;
  size_t v146;
  size_t v147;
  size_t v148;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"ns_uris\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString(a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v138);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"ns_names\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(a1, v32);
        else
          appendStringInfoString(a1, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(a1, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo(a1, "],", v22, v23, v24, v25, v26, v27, v139);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"docexpr\":", a3, a4, a5, a6, a7, a8, v137);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    appendStringInfo(a1, ",", v34, v35, v36, v37, v38, v39, v140);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"rowexpr\":", a3, a4, a5, a6, a7, a8, v137);
    _outNode(a1, *(_QWORD *)(a2 + 32));
    appendStringInfo(a1, ",", v40, v41, v42, v43, v44, v45, v141);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"colnames\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v52 = *(_QWORD *)(a2 + 40);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(a1, v56);
        else
          appendStringInfoString(a1, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString(a1, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    appendStringInfo(a1, "],", v46, v47, v48, v49, v50, v51, v142);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(a1, "\"coltypes\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v64 = *(_QWORD *)(a2 + 48);
    if (v64 && *(int *)(v64 + 4) >= 1)
    {
      v65 = 0;
      v66 = 8;
      do
      {
        v67 = *(_QWORD *)(v64 + 16);
        v68 = *(_QWORD *)(v67 + 8 * v65);
        if (v68)
          _outNode(a1, v68);
        else
          appendStringInfoString(a1, "{}");
        if (v67 + v66)
          v69 = v67 + v66 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v69 = 1;
        if (!v69)
          appendStringInfoString(a1, ",");
        ++v65;
        v66 += 8;
      }
      while (v65 < *(int *)(v64 + 4));
    }
    appendStringInfo(a1, "],", v58, v59, v60, v61, v62, v63, v143);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo(a1, "\"coltypmods\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v76 = *(_QWORD *)(a2 + 56);
    if (v76 && *(int *)(v76 + 4) >= 1)
    {
      v77 = 0;
      v78 = 8;
      do
      {
        v79 = *(_QWORD *)(v76 + 16);
        v80 = *(_QWORD *)(v79 + 8 * v77);
        if (v80)
          _outNode(a1, v80);
        else
          appendStringInfoString(a1, "{}");
        if (v79 + v78)
          v81 = v79 + v78 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v81 = 1;
        if (!v81)
          appendStringInfoString(a1, ",");
        ++v77;
        v78 += 8;
      }
      while (v77 < *(int *)(v76 + 4));
    }
    appendStringInfo(a1, "],", v70, v71, v72, v73, v74, v75, v144);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo(a1, "\"colcollations\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v88 = *(_QWORD *)(a2 + 64);
    if (v88 && *(int *)(v88 + 4) >= 1)
    {
      v89 = 0;
      v90 = 8;
      do
      {
        v91 = *(_QWORD *)(v88 + 16);
        v92 = *(_QWORD *)(v91 + 8 * v89);
        if (v92)
          _outNode(a1, v92);
        else
          appendStringInfoString(a1, "{}");
        if (v91 + v90)
          v93 = v91 + v90 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v93 = 1;
        if (!v93)
          appendStringInfoString(a1, ",");
        ++v89;
        v90 += 8;
      }
      while (v89 < *(int *)(v88 + 4));
    }
    appendStringInfo(a1, "],", v82, v83, v84, v85, v86, v87, v145);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo(a1, "\"colexprs\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v100 = *(_QWORD *)(a2 + 72);
    if (v100 && *(int *)(v100 + 4) >= 1)
    {
      v101 = 0;
      v102 = 8;
      do
      {
        v103 = *(_QWORD *)(v100 + 16);
        v104 = *(_QWORD *)(v103 + 8 * v101);
        if (v104)
          _outNode(a1, v104);
        else
          appendStringInfoString(a1, "{}");
        if (v103 + v102)
          v105 = v103 + v102 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v105 = 1;
        if (!v105)
          appendStringInfoString(a1, ",");
        ++v101;
        v102 += 8;
      }
      while (v101 < *(int *)(v100 + 4));
    }
    appendStringInfo(a1, "],", v94, v95, v96, v97, v98, v99, v146);
  }
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo(a1, "\"coldefexprs\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    v112 = *(_QWORD *)(a2 + 80);
    if (v112 && *(int *)(v112 + 4) >= 1)
    {
      v113 = 0;
      v114 = 8;
      do
      {
        v115 = *(_QWORD *)(v112 + 16);
        v116 = *(_QWORD *)(v115 + 8 * v113);
        if (v116)
          _outNode(a1, v116);
        else
          appendStringInfoString(a1, "{}");
        if (v115 + v114)
          v117 = v115 + v114 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 80) + 4));
        else
          v117 = 1;
        if (!v117)
          appendStringInfoString(a1, ",");
        ++v113;
        v114 += 8;
      }
      while (v113 < *(int *)(v112 + 4));
    }
    appendStringInfo(a1, "],", v106, v107, v108, v109, v110, v111, v147);
  }
  result = bms_is_empty(*(unsigned int **)(a2 + 88));
  if ((result & 1) == 0)
  {
    appendStringInfo(a1, "\"notnulls\":[", v119, v120, v121, v122, v123, v124, v137);
    member = bms_next_member(*(int **)(a2 + 88), 0);
    if ((member & 0x80000000) == 0)
    {
      v132 = member;
      do
      {
        appendStringInfo(a1, "%d,", v126, v127, v128, v129, v130, v131, v132);
        v132 = bms_next_member(*(int **)(a2 + 88), v132);
      }
      while ((v132 & 0x80000000) == 0);
    }
    v133 = *(_DWORD *)(a1 + 8);
    v134 = __OFSUB__(v133, 1);
    v135 = (v133 - 1);
    if ((int)v135 < 0 == v134)
    {
      v136 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v135) == 44)
      {
        *(_DWORD *)(a1 + 8) = v135;
        *(_BYTE *)(v136 + v135) = 0;
      }
    }
    result = appendStringInfo(a1, "],", v126, v127, v128, v129, v130, v131, v148);
  }
  if (*(_DWORD *)(a2 + 96))
    result = appendStringInfo(a1, "\"ordinalitycol\":%d,", v119, v120, v121, v122, v123, v124, *(unsigned int *)(a2 + 96));
  if (*(_DWORD *)(a2 + 100))
    return appendStringInfo(a1, "\"location\":%d,", v119, v120, v121, v122, v123, v124, *(unsigned int *)(a2 + 100));
  return result;
}

uint64_t _outVar(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"varno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_WORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"varattno\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(v9, "\"vartype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"vartypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    result = appendStringInfo(v9, "\"varcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo(v9, "\"varlevelsup\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  if (*(_DWORD *)(a2 + 28))
    result = appendStringInfo(v9, "\"varnosyn\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  if (*(_WORD *)(a2 + 32))
    result = appendStringInfo(v9, "\"varattnosyn\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 32));
  if (*(_DWORD *)(a2 + 36))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 36));
  return result;
}

unint64_t _outParam(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v10 = *(int *)(a2 + 4);
  if (v10 > 3)
    v11 = 0;
  else
    v11 = (&off_1E264AC10)[v10];
  result = appendStringInfo(a1, "\"paramkind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(a1, "\"paramid\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(a1, "\"paramtype\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 12));
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(a1, "\"paramtypmod\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    result = appendStringInfo(a1, "\"paramcollid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 20));
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 24));
  return result;
}

unint64_t _outAggref(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  BOOL v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  unint64_t result;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  size_t v85;
  size_t v86;
  size_t v87;
  size_t v88;
  size_t v89;
  size_t v90;
  size_t v91;

  if (*(_DWORD *)(a2 + 4))
    appendStringInfo(a1, "\"aggfnoid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    appendStringInfo(a1, "\"aggtype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    appendStringInfo(a1, "\"aggcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo(a1, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    appendStringInfo(a1, "\"aggtranstype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"aggargtypes\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    v16 = *(_QWORD *)(a2 + 24);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString(a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v86);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"aggdirectargs\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    v28 = *(_QWORD *)(a2 + 32);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(a1, v32);
        else
          appendStringInfoString(a1, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(a1, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo(a1, "],", v22, v23, v24, v25, v26, v27, v87);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"args\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    v40 = *(_QWORD *)(a2 + 40);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(a1, v44);
        else
          appendStringInfoString(a1, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString(a1, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    appendStringInfo(a1, "],", v34, v35, v36, v37, v38, v39, v88);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(a1, "\"aggorder\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    v52 = *(_QWORD *)(a2 + 48);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(a1, v56);
        else
          appendStringInfoString(a1, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString(a1, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    appendStringInfo(a1, "],", v46, v47, v48, v49, v50, v51, v89);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo(a1, "\"aggdistinct\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    v64 = *(_QWORD *)(a2 + 56);
    if (v64 && *(int *)(v64 + 4) >= 1)
    {
      v65 = 0;
      v66 = 8;
      do
      {
        v67 = *(_QWORD *)(v64 + 16);
        v68 = *(_QWORD *)(v67 + 8 * v65);
        if (v68)
          _outNode(a1, v68);
        else
          appendStringInfoString(a1, "{}");
        if (v67 + v66)
          v69 = v67 + v66 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v69 = 1;
        if (!v69)
          appendStringInfoString(a1, ",");
        ++v65;
        v66 += 8;
      }
      while (v65 < *(int *)(v64 + 4));
    }
    appendStringInfo(a1, "],", v58, v59, v60, v61, v62, v63, v90);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo(a1, "\"aggfilter\":", a3, a4, a5, a6, a7, a8, v85);
    _outNode(a1, *(_QWORD *)(a2 + 64));
    appendStringInfo(a1, ",", v70, v71, v72, v73, v74, v75, v91);
  }
  if (*(_BYTE *)(a2 + 72))
    appendStringInfo(a1, "\"aggstar\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 73))
    appendStringInfo(a1, "\"aggvariadic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 74))
    appendStringInfo(a1, "\"aggkind\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 74));
  if (*(_DWORD *)(a2 + 76))
    appendStringInfo(a1, "\"agglevelsup\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 76));
  v76 = *(_DWORD *)(a2 + 80);
  if (v76)
  {
    if (v76 == 9)
    {
      v77 = "AGGSPLIT_FINAL_DESERIAL";
    }
    else if (v76 == 6)
    {
      v77 = "AGGSPLIT_INITIAL_SERIAL";
    }
    else
    {
      v77 = 0;
    }
  }
  else
  {
    v77 = "AGGSPLIT_SIMPLE";
  }
  result = appendStringInfo(a1, "\"aggsplit\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v77);
  if (*(_DWORD *)(a2 + 84))
    return appendStringInfo(a1, "\"location\":%d,", v79, v80, v81, v82, v83, v84, *(unsigned int *)(a2 + 84));
  return result;
}

uint64_t _outGroupingFunc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  size_t v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"args\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"refs\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString(v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"cols\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString(v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString(v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_DWORD *)(a2 + 32))
    result = appendStringInfo(v9, "\"agglevelsup\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  if (*(_DWORD *)(a2 + 36))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 36));
  return result;
}

uint64_t _outWindowFunc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  size_t v29;
  size_t v30;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"winfnoid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"wintype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(v9, "\"wincollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v28);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 24);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v9, "\"aggfilter\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(_QWORD *)(a2 + 32));
    result = appendStringInfo(v9, ",", v22, v23, v24, v25, v26, v27, v30);
  }
  if (*(_DWORD *)(a2 + 40))
    result = appendStringInfo(v9, "\"winref\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  if (*(_BYTE *)(a2 + 44))
    result = appendStringInfo(v9, "\"winstar\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 45))
    result = appendStringInfo(v9, "\"winagg\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_DWORD *)(a2 + 48))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  return result;
}

uint64_t _outSubscriptingRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t v47;
  size_t v48;
  size_t v49;
  size_t v50;

  v10 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"refcontainertype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v10, "\"refelemtype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(v10, "\"reftypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v10, "\"refcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v10, "\"refupperindexpr\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 24);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v48);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v10, "\"reflowerindexpr\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar(v10, 91);
    v29 = *(_QWORD *)(a2 + 32);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString(v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString(v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    result = appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, v49);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(v10, "\"refexpr\":", a3, a4, a5, a6, a7, a8, v47);
    _outNode(v10, *(_QWORD *)(a2 + 40));
    result = appendStringInfo(v10, ",", v35, v36, v37, v38, v39, v40, v50);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(v10, "\"refassgnexpr\":", a3, a4, a5, a6, a7, a8, v47);
    _outNode(v10, *(_QWORD *)(a2 + 48));
    return appendStringInfo(v10, ",", v41, v42, v43, v44, v45, v46, a9);
  }
  return result;
}

unint64_t _outFuncExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  size_t v31;
  size_t v32;

  if (*(_DWORD *)(a2 + 4))
    appendStringInfo(a1, "\"funcid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    appendStringInfo(a1, "\"funcresulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_BYTE *)(a2 + 12))
    appendStringInfo(a1, "\"funcretset\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 13))
    appendStringInfo(a1, "\"funcvariadic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  v10 = *(int *)(a2 + 16);
  if (v10 > 2)
    v11 = 0;
  else
    v11 = (&off_1E264ADA0)[v10];
  result = appendStringInfo(a1, "\"funcformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 20))
    result = appendStringInfo(a1, "\"funccollid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 20));
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo(a1, "\"inputcollid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 24));
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"args\":", v13, v14, v15, v16, v17, v18, v31);
    appendStringInfoChar(a1, 91);
    v25 = *(_QWORD *)(a2 + 32);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        v29 = *(_QWORD *)(v28 + 8 * v26);
        if (v29)
          _outNode(a1, v29);
        else
          appendStringInfoString(a1, "{}");
        if (v28 + v27)
          v30 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v30 = 1;
        if (!v30)
          appendStringInfoString(a1, ",");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v32);
  }
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 40));
  return result;
}

uint64_t _outNamedArgExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  size_t v29;
  size_t v30;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo((uint64_t)v9, ",", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"name\":", a3, a4, a5, a6, a7, a8, v28);
    _outToken(v9, *(char **)(a2 + 16), v16, v17, v18, v19, v20, v21);
    result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v30);
  }
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo((uint64_t)v9, "\"argnumber\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  if (*(_DWORD *)(a2 + 28))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  return result;
}

uint64_t _outOpExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"opno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"opfuncid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(v9, "\"opresulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfo(v9, "\"opretset\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_DWORD *)(a2 + 20))
    result = appendStringInfo(v9, "\"opcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo(v9, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 32);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  return result;
}

uint64_t _outScalarArrayOpExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"opno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"opfuncid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_BYTE *)(a2 + 12))
    result = appendStringInfo(v9, "\"useOr\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 24);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  return result;
}

unint64_t _outBoolExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  size_t v31;
  size_t v32;

  v10 = *(int *)(a2 + 4);
  if (v10 > 2)
    v11 = 0;
  else
    v11 = (&off_1E264AC30)[v10];
  result = appendStringInfo(a1, "\"BOOLop\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"args\":", v13, v14, v15, v16, v17, v18, v31);
    appendStringInfoChar(a1, 91);
    v25 = *(_QWORD *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        v29 = *(_QWORD *)(v28 + 8 * v26);
        if (v29)
          _outNode(a1, v29);
        else
          appendStringInfoString(a1, "{}");
        if (v28 + v27)
          v30 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v30 = 1;
        if (!v30)
          appendStringInfoString(a1, ",");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v32);
  }
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  return result;
}

unint64_t _outSubLink(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  size_t v43;
  size_t v44;
  size_t v45;
  size_t v46;

  v10 = *(int *)(a2 + 4);
  if (v10 > 7)
    v11 = 0;
  else
    v11 = (&off_1E264AC48)[v10];
  result = appendStringInfo(a1, "\"subLinkType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(a1, "\"subLinkId\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"testexpr\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(a1, ",", v19, v20, v21, v22, v23, v24, v44);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"operName\":", v13, v14, v15, v16, v17, v18, v43);
    appendStringInfoChar(a1, 91);
    v31 = *(_QWORD *)(a2 + 24);
    if (v31 && *(int *)(v31 + 4) >= 1)
    {
      v32 = 0;
      v33 = 8;
      do
      {
        v34 = *(_QWORD *)(v31 + 16);
        v35 = *(_QWORD *)(v34 + 8 * v32);
        if (v35)
          _outNode(a1, v35);
        else
          appendStringInfoString(a1, "{}");
        if (v34 + v33)
          v36 = v34 + v33 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v36 = 1;
        if (!v36)
          appendStringInfoString(a1, ",");
        ++v32;
        v33 += 8;
      }
      while (v32 < *(int *)(v31 + 4));
    }
    result = appendStringInfo(a1, "],", v25, v26, v27, v28, v29, v30, v45);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"subselect\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(_QWORD *)(a2 + 32));
    result = appendStringInfo(a1, ",", v37, v38, v39, v40, v41, v42, v46);
  }
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 40));
  return result;
}

unint64_t _outSubPlan(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  BOOL v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  size_t v91;
  size_t v92;
  size_t v93;
  size_t v94;
  size_t v95;
  size_t v96;
  size_t v97;

  v10 = *(int *)(a2 + 4);
  if (v10 > 7)
    v11 = 0;
  else
    v11 = (&off_1E264AC48)[v10];
  appendStringInfo((uint64_t)a1, "\"subLinkType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"testexpr\":", v12, v13, v14, v15, v16, v17, v91);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo((uint64_t)a1, ",", v18, v19, v20, v21, v22, v23, v92);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"paramIds\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    v30 = *(_QWORD *)(a2 + 16);
    if (v30 && *(int *)(v30 + 4) >= 1)
    {
      v31 = 0;
      v32 = 8;
      do
      {
        v33 = *(_QWORD *)(v30 + 16);
        v34 = *(_QWORD *)(v33 + 8 * v31);
        if (v34)
          _outNode(a1, v34);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v33 + v32)
          v35 = v33 + v32 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v35 = 1;
        if (!v35)
          appendStringInfoString((uint64_t)a1, ",");
        ++v31;
        v32 += 8;
      }
      while (v31 < *(int *)(v30 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v24, v25, v26, v27, v28, v29, v93);
  }
  if (*(_DWORD *)(a2 + 24))
    appendStringInfo((uint64_t)a1, "\"plan_id\":%d,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 24));
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"plan_name\":", v12, v13, v14, v15, v16, v17, v91);
    _outToken(a1, *(char **)(a2 + 32), v36, v37, v38, v39, v40, v41);
    appendStringInfo((uint64_t)a1, ",", v42, v43, v44, v45, v46, v47, v94);
  }
  if (*(_DWORD *)(a2 + 40))
    appendStringInfo((uint64_t)a1, "\"firstColType\":%u,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 40));
  if (*(_DWORD *)(a2 + 44))
    appendStringInfo((uint64_t)a1, "\"firstColTypmod\":%d,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 44));
  if (*(_DWORD *)(a2 + 48))
    appendStringInfo((uint64_t)a1, "\"firstColCollation\":%u,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 48));
  if (*(_BYTE *)(a2 + 52))
    appendStringInfo((uint64_t)a1, "\"useHashTable\":%s,", v12, v13, v14, v15, v16, v17, (size_t)"true");
  if (*(_BYTE *)(a2 + 53))
    appendStringInfo((uint64_t)a1, "\"unknownEqFalse\":%s,", v12, v13, v14, v15, v16, v17, (size_t)"true");
  if (*(_BYTE *)(a2 + 54))
    appendStringInfo((uint64_t)a1, "\"parallel_safe\":%s,", v12, v13, v14, v15, v16, v17, (size_t)"true");
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"setParam\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    v54 = *(_QWORD *)(a2 + 56);
    if (v54 && *(int *)(v54 + 4) >= 1)
    {
      v55 = 0;
      v56 = 8;
      do
      {
        v57 = *(_QWORD *)(v54 + 16);
        v58 = *(_QWORD *)(v57 + 8 * v55);
        if (v58)
          _outNode(a1, v58);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v57 + v56)
          v59 = v57 + v56 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v59 = 1;
        if (!v59)
          appendStringInfoString((uint64_t)a1, ",");
        ++v55;
        v56 += 8;
      }
      while (v55 < *(int *)(v54 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v48, v49, v50, v51, v52, v53, v95);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"parParam\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    v66 = *(_QWORD *)(a2 + 64);
    if (v66 && *(int *)(v66 + 4) >= 1)
    {
      v67 = 0;
      v68 = 8;
      do
      {
        v69 = *(_QWORD *)(v66 + 16);
        v70 = *(_QWORD *)(v69 + 8 * v67);
        if (v70)
          _outNode(a1, v70);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v69 + v68)
          v71 = v69 + v68 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v71 = 1;
        if (!v71)
          appendStringInfoString((uint64_t)a1, ",");
        ++v67;
        v68 += 8;
      }
      while (v67 < *(int *)(v66 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v60, v61, v62, v63, v64, v65, v96);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"args\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    v78 = *(_QWORD *)(a2 + 72);
    if (v78 && *(int *)(v78 + 4) >= 1)
    {
      v79 = 0;
      v80 = 8;
      do
      {
        v81 = *(_QWORD *)(v78 + 16);
        v82 = *(_QWORD *)(v81 + 8 * v79);
        if (v82)
          _outNode(a1, v82);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v81 + v80)
          v83 = v81 + v80 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v83 = 1;
        if (!v83)
          appendStringInfoString((uint64_t)a1, ",");
        ++v79;
        v80 += 8;
      }
      while (v79 < *(int *)(v78 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v72, v73, v74, v75, v76, v77, v97);
  }
  appendStringInfo((uint64_t)a1, "\"startup_cost\":%f,", v12, v13, v14, v15, v16, v17, *(_QWORD *)(a2 + 80));
  return appendStringInfo((uint64_t)a1, "\"per_call_cost\":%f,", v84, v85, v86, v87, v88, v89, *(_QWORD *)(a2 + 88));
}

unint64_t _outAlternativeSubPlan(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  size_t v23;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = result;
    appendStringInfo(result, "\"subplans\":", a3, a4, a5, a6, a7, a8, v23);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    return appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, a9);
  }
  return result;
}

uint64_t _outFieldSelect(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_WORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"fieldnum\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    result = appendStringInfo(v9, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo(v9, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  if (*(_DWORD *)(a2 + 28))
    return appendStringInfo(v9, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  return result;
}

uint64_t _outFieldStore(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  size_t v40;
  size_t v41;
  size_t v42;
  size_t v43;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v40);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v41);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"newvals\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar(v9, 91);
    v22 = *(_QWORD *)(a2 + 16);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      v23 = 0;
      v24 = 8;
      do
      {
        v25 = *(_QWORD *)(v22 + 16);
        v26 = *(_QWORD *)(v25 + 8 * v23);
        if (v26)
          _outNode(v9, v26);
        else
          appendStringInfoString(v9, "{}");
        if (v25 + v24)
          v27 = v25 + v24 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v27 = 1;
        if (!v27)
          appendStringInfoString(v9, ",");
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v42);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"fieldnums\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar(v9, 91);
    v34 = *(_QWORD *)(a2 + 24);
    if (v34 && *(int *)(v34 + 4) >= 1)
    {
      v35 = 0;
      v36 = 8;
      do
      {
        v37 = *(_QWORD *)(v34 + 16);
        v38 = *(_QWORD *)(v37 + 8 * v35);
        if (v38)
          _outNode(v9, v38);
        else
          appendStringInfoString(v9, "{}");
        if (v37 + v36)
          v39 = v37 + v36 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v39 = 1;
        if (!v39)
          appendStringInfoString(v9, ",");
        ++v35;
        v36 += 8;
      }
      while (v35 < *(int *)(v34 + 4));
    }
    result = appendStringInfo(v9, "],", v28, v29, v30, v31, v32, v33, v43);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(v9, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  return result;
}

unint64_t _outRelabelType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    appendStringInfo(a1, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  if (*(_DWORD *)(a2 + 24))
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  v16 = *(int *)(a2 + 28);
  if (v16 > 2)
    v17 = 0;
  else
    v17 = (&off_1E264ADA0)[v16];
  result = appendStringInfo(a1, "\"relabelformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 32));
  return result;
}

unint64_t _outCoerceViaIO(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  v16 = *(int *)(a2 + 24);
  if (v16 > 2)
    v17 = 0;
  else
    v17 = (&off_1E264ADA0)[v16];
  result = appendStringInfo(a1, "\"coerceformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 28))
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 28));
  return result;
}

unint64_t _outArrayCoerceExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  size_t v32;
  size_t v33;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v31);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v32);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"elemexpr\":", a3, a4, a5, a6, a7, a8, v31);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    appendStringInfo(a1, ",", v16, v17, v18, v19, v20, v21, v33);
  }
  if (*(_DWORD *)(a2 + 24))
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  if (*(_DWORD *)(a2 + 28))
    appendStringInfo(a1, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  if (*(_DWORD *)(a2 + 32))
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  v22 = *(int *)(a2 + 36);
  if (v22 > 2)
    v23 = 0;
  else
    v23 = (&off_1E264ADA0)[v22];
  result = appendStringInfo(a1, "\"coerceformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo(a1, "\"location\":%d,", v25, v26, v27, v28, v29, v30, *(unsigned int *)(a2 + 40));
  return result;
}

unint64_t _outConvertRowtypeExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  v16 = *(int *)(a2 + 20);
  if (v16 > 2)
    v17 = 0;
  else
    v17 = (&off_1E264ADA0)[v16];
  result = appendStringInfo(a1, "\"convertformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outCollateExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"collOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  return result;
}

uint64_t _outCaseExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  size_t v34;
  size_t v35;
  size_t v36;
  size_t v37;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"casetype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"casecollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"arg\":", a3, a4, a5, a6, a7, a8, v34);
    _outNode(v9, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v35);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    v22 = *(_QWORD *)(a2 + 24);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      v23 = 0;
      v24 = 8;
      do
      {
        v25 = *(_QWORD *)(v22 + 16);
        v26 = *(_QWORD *)(v25 + 8 * v23);
        if (v26)
          _outNode(v9, v26);
        else
          appendStringInfoString(v9, "{}");
        if (v25 + v24)
          v27 = v25 + v24 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v27 = 1;
        if (!v27)
          appendStringInfoString(v9, ",");
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v36);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v9, "\"defresult\":", a3, a4, a5, a6, a7, a8, v34);
    _outNode(v9, *(_QWORD *)(a2 + 32));
    result = appendStringInfo(v9, ",", v28, v29, v30, v31, v32, v33, v37);
  }
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  return result;
}

uint64_t _outCaseWhen(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  size_t v23;
  size_t v24;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"expr\":", a3, a4, a5, a6, a7, a8, v22);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"result\":", a3, a4, a5, a6, a7, a8, v22);
    _outNode(v9, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(v9, ",", v16, v17, v18, v19, v20, v21, v24);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outCaseTestExpr(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = result;
  if (a2[1])
    result = appendStringInfo(result, "\"typeId\":%u,", a3, a4, a5, a6, a7, a8, a2[1]);
  if (a2[2])
    result = appendStringInfo(v9, "\"typeMod\":%d,", a3, a4, a5, a6, a7, a8, a2[2]);
  if (a2[3])
    return appendStringInfo(v9, "\"collation\":%u,", a3, a4, a5, a6, a7, a8, a2[3]);
  return result;
}

uint64_t _outArrayExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"array_typeid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"array_collid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(v9, "\"element_typeid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"elements\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 16);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfo(v9, "\"multidims\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_DWORD *)(a2 + 28))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  return result;
}

unint64_t _outRowExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  char *v23;
  unint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  size_t v43;
  size_t v44;
  size_t v45;
  size_t v46;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"args\":", a3, a4, a5, a6, a7, a8, v43);
    appendStringInfoChar(a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString(a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v44);
  }
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo(a1, "\"row_typeid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  v22 = *(int *)(a2 + 20);
  if (v22 > 2)
    v23 = 0;
  else
    v23 = (&off_1E264ADA0)[v22];
  result = appendStringInfo(a1, "\"row_format\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"colnames\":", v25, v26, v27, v28, v29, v30, v45);
    appendStringInfoChar(a1, 91);
    v37 = *(_QWORD *)(a2 + 24);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      v38 = 0;
      v39 = 8;
      do
      {
        v40 = *(_QWORD *)(v37 + 16);
        v41 = *(_QWORD *)(v40 + 8 * v38);
        if (v41)
          _outNode(a1, v41);
        else
          appendStringInfoString(a1, "{}");
        if (v40 + v39)
          v42 = v40 + v39 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v42 = 1;
        if (!v42)
          appendStringInfoString(a1, ",");
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v46);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(a1, "\"location\":%d,", v25, v26, v27, v28, v29, v30, *(unsigned int *)(a2 + 32));
  return result;
}

unint64_t _outRowCompareExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  unsigned int v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  BOOL v79;
  size_t v80;
  size_t v81;
  size_t v82;
  size_t v83;
  size_t v84;

  v11 = *(_DWORD *)(a2 + 4) - 1;
  if (v11 > 5)
    v12 = 0;
  else
    v12 = (&off_1E264AC88)[v11];
  result = appendStringInfo(a1, "\"rctype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"opnos\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v26 = *(_QWORD *)(a2 + 8);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      v27 = 0;
      v28 = 8;
      do
      {
        v29 = *(_QWORD *)(v26 + 16);
        v30 = *(_QWORD *)(v29 + 8 * v27);
        if (v30)
          _outNode(a1, v30);
        else
          appendStringInfoString(a1, "{}");
        if (v29 + v28)
          v31 = v29 + v28 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v31 = 1;
        if (!v31)
          appendStringInfoString(a1, ",");
        ++v27;
        v28 += 8;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    result = appendStringInfo(a1, "],", v20, v21, v22, v23, v24, v25, v81);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"opfamilies\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v38 = *(_QWORD *)(a2 + 16);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      v39 = 0;
      v40 = 8;
      do
      {
        v41 = *(_QWORD *)(v38 + 16);
        v42 = *(_QWORD *)(v41 + 8 * v39);
        if (v42)
          _outNode(a1, v42);
        else
          appendStringInfoString(a1, "{}");
        if (v41 + v40)
          v43 = v41 + v40 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v43 = 1;
        if (!v43)
          appendStringInfoString(a1, ",");
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    result = appendStringInfo(a1, "],", v32, v33, v34, v35, v36, v37, v82);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"inputcollids\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v50 = *(_QWORD *)(a2 + 24);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      v51 = 0;
      v52 = 8;
      do
      {
        v53 = *(_QWORD *)(v50 + 16);
        v54 = *(_QWORD *)(v53 + 8 * v51);
        if (v54)
          _outNode(a1, v54);
        else
          appendStringInfoString(a1, "{}");
        if (v53 + v52)
          v55 = v53 + v52 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v55 = 1;
        if (!v55)
          appendStringInfoString(a1, ",");
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    result = appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v83);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"largs\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v62 = *(_QWORD *)(a2 + 32);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      v63 = 0;
      v64 = 8;
      do
      {
        v65 = *(_QWORD *)(v62 + 16);
        v66 = *(_QWORD *)(v65 + 8 * v63);
        if (v66)
          _outNode(a1, v66);
        else
          appendStringInfoString(a1, "{}");
        if (v65 + v64)
          v67 = v65 + v64 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v67 = 1;
        if (!v67)
          appendStringInfoString(a1, ",");
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    result = appendStringInfo(a1, "],", v56, v57, v58, v59, v60, v61, v84);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"rargs\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v74 = *(_QWORD *)(a2 + 40);
    if (v74 && *(int *)(v74 + 4) >= 1)
    {
      v75 = 0;
      v76 = 8;
      do
      {
        v77 = *(_QWORD *)(v74 + 16);
        v78 = *(_QWORD *)(v77 + 8 * v75);
        if (v78)
          _outNode(a1, v78);
        else
          appendStringInfoString(a1, "{}");
        if (v77 + v76)
          v79 = v77 + v76 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v79 = 1;
        if (!v79)
          appendStringInfoString(a1, ",");
        ++v75;
        v76 += 8;
      }
      while (v75 < *(int *)(v74 + 4));
    }
    return appendStringInfo(a1, "],", v68, v69, v70, v71, v72, v73, a9);
  }
  return result;
}

uint64_t _outCoalesceExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"coalescetype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"coalescecollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 16);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  return result;
}

unint64_t _outMinMaxExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  const char *v11;
  const char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  size_t v32;
  size_t v33;

  if (*(_DWORD *)(a2 + 4))
    appendStringInfo(a1, "\"minmaxtype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    appendStringInfo(a1, "\"minmaxcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    appendStringInfo(a1, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  v10 = *(_DWORD *)(a2 + 16);
  v11 = "IS_LEAST";
  if (v10 != 1)
    v11 = 0;
  if (v10)
    v12 = v11;
  else
    v12 = "IS_GREATEST";
  result = appendStringInfo(a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"args\":", v14, v15, v16, v17, v18, v19, v32);
    appendStringInfoChar(a1, 91);
    v26 = *(_QWORD *)(a2 + 24);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      v27 = 0;
      v28 = 8;
      do
      {
        v29 = *(_QWORD *)(v26 + 16);
        v30 = *(_QWORD *)(v29 + 8 * v27);
        if (v30)
          _outNode(a1, v30);
        else
          appendStringInfoString(a1, "{}");
        if (v29 + v28)
          v31 = v29 + v28 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v31 = 1;
        if (!v31)
          appendStringInfoString(a1, ",");
        ++v27;
        v28 += 8;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    result = appendStringInfo(a1, "],", v20, v21, v22, v23, v24, v25, v33);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(a1, "\"location\":%d,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 32));
  return result;
}

unint64_t _outSQLValueFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0xE)
    v11 = 0;
  else
    v11 = (&off_1E264ACB8)[v10];
  result = appendStringInfo(a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(a1, "\"type\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(a1, "\"typmod\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 12));
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  return result;
}

unint64_t _outXmlExpr(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  BOOL v65;
  int v66;
  const char *v67;
  const char *v68;
  unint64_t result;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  size_t v76;
  size_t v77;
  size_t v78;
  size_t v79;
  size_t v80;

  v10 = *(int *)(a2 + 4);
  if (v10 > 7)
    v11 = 0;
  else
    v11 = (&off_1E264AD30)[v10];
  appendStringInfo((uint64_t)a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v12, v13, v14, v15, v16, v17, v76);
    _outToken(a1, *(char **)(a2 + 8), v18, v19, v20, v21, v22, v23);
    appendStringInfo((uint64_t)a1, ",", v24, v25, v26, v27, v28, v29, v77);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"named_args\":", v12, v13, v14, v15, v16, v17, v76);
    appendStringInfoChar((uint64_t)a1, 91);
    v36 = *(_QWORD *)(a2 + 16);
    if (v36 && *(int *)(v36 + 4) >= 1)
    {
      v37 = 0;
      v38 = 8;
      do
      {
        v39 = *(_QWORD *)(v36 + 16);
        v40 = *(_QWORD *)(v39 + 8 * v37);
        if (v40)
          _outNode(a1, v40);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v39 + v38)
          v41 = v39 + v38 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v41 = 1;
        if (!v41)
          appendStringInfoString((uint64_t)a1, ",");
        ++v37;
        v38 += 8;
      }
      while (v37 < *(int *)(v36 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v30, v31, v32, v33, v34, v35, v78);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"arg_names\":", v12, v13, v14, v15, v16, v17, v76);
    appendStringInfoChar((uint64_t)a1, 91);
    v48 = *(_QWORD *)(a2 + 24);
    if (v48 && *(int *)(v48 + 4) >= 1)
    {
      v49 = 0;
      v50 = 8;
      do
      {
        v51 = *(_QWORD *)(v48 + 16);
        v52 = *(_QWORD *)(v51 + 8 * v49);
        if (v52)
          _outNode(a1, v52);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v51 + v50)
          v53 = v51 + v50 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v53 = 1;
        if (!v53)
          appendStringInfoString((uint64_t)a1, ",");
        ++v49;
        v50 += 8;
      }
      while (v49 < *(int *)(v48 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v42, v43, v44, v45, v46, v47, v79);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"args\":", v12, v13, v14, v15, v16, v17, v76);
    appendStringInfoChar((uint64_t)a1, 91);
    v60 = *(_QWORD *)(a2 + 32);
    if (v60 && *(int *)(v60 + 4) >= 1)
    {
      v61 = 0;
      v62 = 8;
      do
      {
        v63 = *(_QWORD *)(v60 + 16);
        v64 = *(_QWORD *)(v63 + 8 * v61);
        if (v64)
          _outNode(a1, v64);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v63 + v62)
          v65 = v63 + v62 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v65 = 1;
        if (!v65)
          appendStringInfoString((uint64_t)a1, ",");
        ++v61;
        v62 += 8;
      }
      while (v61 < *(int *)(v60 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v54, v55, v56, v57, v58, v59, v80);
  }
  v66 = *(_DWORD *)(a2 + 40);
  v67 = "XMLOPTION_CONTENT";
  if (v66 != 1)
    v67 = 0;
  if (v66)
    v68 = v67;
  else
    v68 = "XMLOPTION_DOCUMENT";
  result = appendStringInfo((uint64_t)a1, "\"xmloption\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v68);
  if (*(_DWORD *)(a2 + 44))
    result = appendStringInfo((uint64_t)a1, "\"type\":%u,", v70, v71, v72, v73, v74, v75, *(unsigned int *)(a2 + 44));
  if (*(_DWORD *)(a2 + 48))
    result = appendStringInfo((uint64_t)a1, "\"typmod\":%d,", v70, v71, v72, v73, v74, v75, *(unsigned int *)(a2 + 48));
  if (*(_DWORD *)(a2 + 52))
    return appendStringInfo((uint64_t)a1, "\"location\":%d,", v70, v71, v72, v73, v74, v75, *(unsigned int *)(a2 + 52));
  return result;
}

unint64_t _outNullTest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  const char *v18;
  unint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  size_t v27;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v26);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v27);
  }
  v16 = *(_DWORD *)(a2 + 16);
  v17 = "IS_NOT_NULL";
  if (v16 != 1)
    v17 = 0;
  if (v16)
    v18 = v17;
  else
    v18 = "IS_NULL";
  result = appendStringInfo(a1, "\"nulltesttype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v18);
  if (*(_BYTE *)(a2 + 20))
    result = appendStringInfo(a1, "\"argisrow\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(a1, "\"location\":%d,", v20, v21, v22, v23, v24, v25, *(unsigned int *)(a2 + 24));
  return result;
}

unint64_t _outBooleanTest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  v16 = *(int *)(a2 + 16);
  if (v16 > 5)
    v17 = 0;
  else
    v17 = (&off_1E264AD70)[v16];
  result = appendStringInfo(a1, "\"BOOLtesttype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 20))
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 20));
  return result;
}

unint64_t _outCoerceToDomain(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    appendStringInfo(a1, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  if (*(_DWORD *)(a2 + 24))
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  v16 = *(int *)(a2 + 28);
  if (v16 > 2)
    v17 = 0;
  else
    v17 = (&off_1E264ADA0)[v16];
  result = appendStringInfo(a1, "\"coercionformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 32));
  return result;
}

uint64_t _outCoerceToDomainValue(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = result;
  if (a2[1])
    result = appendStringInfo(result, "\"typeId\":%u,", a3, a4, a5, a6, a7, a8, a2[1]);
  if (a2[2])
    result = appendStringInfo(v9, "\"typeMod\":%d,", a3, a4, a5, a6, a7, a8, a2[2]);
  if (a2[3])
    result = appendStringInfo(v9, "\"collation\":%u,", a3, a4, a5, a6, a7, a8, a2[3]);
  if (a2[4])
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, a2[4]);
  return result;
}

uint64_t _outCurrentOfExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  size_t v23;

  v9 = (int *)result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"cvarno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v9, "\"cursor_name\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo((uint64_t)v9, "\"cursor_param\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  return result;
}

uint64_t _outNextValueExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"seqid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    return appendStringInfo(v9, "\"typeId\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  return result;
}

uint64_t _outInferenceElem(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"expr\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"infercollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    return appendStringInfo(v9, "\"inferopclass\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  return result;
}

uint64_t _outTargetEntry(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  size_t v29;
  size_t v30;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"expr\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo((uint64_t)v9, ",", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(_WORD *)(a2 + 16))
    result = appendStringInfo((uint64_t)v9, "\"resno\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"resname\":", a3, a4, a5, a6, a7, a8, v28);
    _outToken(v9, *(char **)(a2 + 24), v16, v17, v18, v19, v20, v21);
    result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v30);
  }
  if (*(_DWORD *)(a2 + 32))
    result = appendStringInfo((uint64_t)v9, "\"ressortgroupref\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  if (*(_DWORD *)(a2 + 36))
    result = appendStringInfo((uint64_t)v9, "\"resorigtbl\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 36));
  if (*(_WORD *)(a2 + 40))
    result = appendStringInfo((uint64_t)v9, "\"resorigcol\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 40));
  if (*(_BYTE *)(a2 + 42))
    return appendStringInfo((uint64_t)v9, "\"resjunk\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outJoinExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  size_t v66;
  size_t v67;
  size_t v68;
  size_t v69;
  size_t v70;
  size_t v71;

  v10 = *(int *)(a2 + 4);
  if (v10 > 7)
    v11 = 0;
  else
    v11 = (&off_1E264B570)[v10];
  result = appendStringInfo(a1, "\"jointype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_BYTE *)(a2 + 8))
    result = appendStringInfo(a1, "\"isNatural\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"larg\":", v13, v14, v15, v16, v17, v18, v65);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(a1, ",", v19, v20, v21, v22, v23, v24, v66);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"rarg\":", v13, v14, v15, v16, v17, v18, v65);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    result = appendStringInfo(a1, ",", v25, v26, v27, v28, v29, v30, v67);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"usingClause\":", v13, v14, v15, v16, v17, v18, v65);
    appendStringInfoChar(a1, 91);
    v37 = *(_QWORD *)(a2 + 32);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      v38 = 0;
      v39 = 8;
      do
      {
        v40 = *(_QWORD *)(v37 + 16);
        v41 = *(_QWORD *)(v40 + 8 * v38);
        if (v41)
          _outNode(a1, v41);
        else
          appendStringInfoString(a1, "{}");
        if (v40 + v39)
          v42 = v40 + v39 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v42 = 1;
        if (!v42)
          appendStringInfoString(a1, ",");
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v68);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"quals\":", v13, v14, v15, v16, v17, v18, v65);
    _outNode(a1, *(_QWORD *)(a2 + 40));
    result = appendStringInfo(a1, ",", v43, v44, v45, v46, v47, v48, v69);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(a1, "\"alias\":{", v13, v14, v15, v16, v17, v18, v65);
    _outAlias(a1, *(_QWORD *)(a2 + 48), v49, v50, v51, v52, v53, v54, v70);
    v61 = *(_DWORD *)(a1 + 8);
    v62 = __OFSUB__(v61, 1);
    v63 = (v61 - 1);
    if ((int)v63 < 0 == v62)
    {
      v64 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v63) == 44)
      {
        *(_DWORD *)(a1 + 8) = v63;
        *(_BYTE *)(v64 + v63) = 0;
      }
    }
    result = appendStringInfo(a1, "},", v55, v56, v57, v58, v59, v60, v71);
  }
  if (*(_DWORD *)(a2 + 56))
    return appendStringInfo(a1, "\"rtindex\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 56));
  return result;
}

uint64_t _outFromExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  size_t v30;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"fromlist\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"quals\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(_QWORD *)(a2 + 16));
    return appendStringInfo(v10, ",", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outOnConflictExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  size_t v68;
  size_t v69;
  size_t v70;
  size_t v71;
  size_t v72;

  v11 = *(int *)(a2 + 4);
  if (v11 > 2)
    v12 = 0;
  else
    v12 = (&off_1E264B638)[v11];
  result = appendStringInfo(a1, "\"action\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arbiterElems\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar(a1, 91);
    v26 = *(_QWORD *)(a2 + 8);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      v27 = 0;
      v28 = 8;
      do
      {
        v29 = *(_QWORD *)(v26 + 16);
        v30 = *(_QWORD *)(v29 + 8 * v27);
        if (v30)
          _outNode(a1, v30);
        else
          appendStringInfoString(a1, "{}");
        if (v29 + v28)
          v31 = v29 + v28 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v31 = 1;
        if (!v31)
          appendStringInfoString(a1, ",");
        ++v27;
        v28 += 8;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    result = appendStringInfo(a1, "],", v20, v21, v22, v23, v24, v25, v69);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"arbiterWhere\":", v14, v15, v16, v17, v18, v19, v68);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(a1, ",", v32, v33, v34, v35, v36, v37, v70);
  }
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo(a1, "\"constraint\":%u,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 24));
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"onConflictSet\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar(a1, 91);
    v44 = *(_QWORD *)(a2 + 32);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      v45 = 0;
      v46 = 8;
      do
      {
        v47 = *(_QWORD *)(v44 + 16);
        v48 = *(_QWORD *)(v47 + 8 * v45);
        if (v48)
          _outNode(a1, v48);
        else
          appendStringInfoString(a1, "{}");
        if (v47 + v46)
          v49 = v47 + v46 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v49 = 1;
        if (!v49)
          appendStringInfoString(a1, ",");
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    result = appendStringInfo(a1, "],", v38, v39, v40, v41, v42, v43, v71);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"onConflictWhere\":", v14, v15, v16, v17, v18, v19, v68);
    _outNode(a1, *(_QWORD *)(a2 + 40));
    result = appendStringInfo(a1, ",", v50, v51, v52, v53, v54, v55, v72);
  }
  if (*(_DWORD *)(a2 + 48))
    result = appendStringInfo(a1, "\"exclRelIndex\":%d,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 48));
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo(a1, "\"exclRelTlist\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar(a1, 91);
    v62 = *(_QWORD *)(a2 + 56);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      v63 = 0;
      v64 = 8;
      do
      {
        v65 = *(_QWORD *)(v62 + 16);
        v66 = *(_QWORD *)(v65 + 8 * v63);
        if (v66)
          _outNode(a1, v66);
        else
          appendStringInfoString(a1, "{}");
        if (v65 + v64)
          v67 = v65 + v64 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v67 = 1;
        if (!v67)
          appendStringInfoString(a1, ",");
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    return appendStringInfo(a1, "],", v56, v57, v58, v59, v60, v61, a9);
  }
  return result;
}

unint64_t _outIntoClause(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  char *v63;
  unint64_t result;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  size_t v89;
  size_t v90;
  size_t v91;
  size_t v92;
  size_t v93;
  size_t v94;
  size_t v95;
  size_t v96;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"rel\":{", a3, a4, a5, a6, a7, a8, v89);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = a1[2];
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v24) == 44)
      {
        a1[2] = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v16, v17, v18, v19, v20, v21, v90);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"colNames\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar((uint64_t)a1, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(a1, v36);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString((uint64_t)a1, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v26, v27, v28, v29, v30, v31, v91);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"accessMethod\":", a3, a4, a5, a6, a7, a8, v89);
    _outToken(a1, *(char **)(a2 + 24), v38, v39, v40, v41, v42, v43);
    appendStringInfo((uint64_t)a1, ",", v44, v45, v46, v47, v48, v49, v92);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar((uint64_t)a1, 91);
    v56 = *(_QWORD *)(a2 + 32);
    if (v56 && *(int *)(v56 + 4) >= 1)
    {
      v57 = 0;
      v58 = 8;
      do
      {
        v59 = *(_QWORD *)(v56 + 16);
        v60 = *(_QWORD *)(v59 + 8 * v57);
        if (v60)
          _outNode(a1, v60);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v59 + v58)
          v61 = v59 + v58 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v61 = 1;
        if (!v61)
          appendStringInfoString((uint64_t)a1, ",");
        ++v57;
        v58 += 8;
      }
      while (v57 < *(int *)(v56 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v50, v51, v52, v53, v54, v55, v93);
  }
  v62 = *(int *)(a2 + 40);
  if (v62 > 3)
    v63 = 0;
  else
    v63 = (&off_1E264B060)[v62];
  result = appendStringInfo((uint64_t)a1, "\"onCommit\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v63);
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"tableSpaceName\":", v65, v66, v67, v68, v69, v70, v94);
    _outToken(a1, *(char **)(a2 + 48), v71, v72, v73, v74, v75, v76);
    result = appendStringInfo((uint64_t)a1, ",", v77, v78, v79, v80, v81, v82, v95);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"viewQuery\":", v65, v66, v67, v68, v69, v70, v94);
    _outNode(a1, *(_QWORD *)(a2 + 56));
    result = appendStringInfo((uint64_t)a1, ",", v83, v84, v85, v86, v87, v88, v96);
  }
  if (*(_BYTE *)(a2 + 64))
    return appendStringInfo((uint64_t)a1, "\"skipData\":%s,", v65, v66, v67, v68, v69, v70, (size_t)"true");
  return result;
}

unint64_t _outQuery(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  BOOL v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  BOOL v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  BOOL v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  BOOL v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  BOOL v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  BOOL v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  BOOL v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  BOOL v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  char *v198;
  unint64_t result;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  BOOL v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  BOOL v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  BOOL v247;
  size_t v248;
  size_t v249;
  size_t v250;
  size_t v251;
  size_t v252;
  size_t v253;
  size_t v254;
  size_t v255;
  size_t v256;
  size_t v257;
  size_t v258;
  size_t v259;
  size_t v260;
  size_t v261;
  size_t v262;
  size_t v263;
  size_t v264;
  size_t v265;
  size_t v266;
  size_t v267;
  size_t v268;
  size_t v269;
  size_t v270;
  size_t v271;

  v10 = *(int *)(a2 + 4);
  if (v10 > 6)
    v11 = 0;
  else
    v11 = (&off_1E264B0A0)[v10];
  appendStringInfo(a1, "\"commandType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  v18 = *(int *)(a2 + 8);
  if (v18 > 4)
    v19 = 0;
  else
    v19 = (&off_1E264ADB8)[v18];
  appendStringInfo(a1, "\"querySource\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(_BYTE *)(a2 + 24))
    appendStringInfo(a1, "\"canSetTag\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"utilityStmt\":", v20, v21, v22, v23, v24, v25, v248);
    _outNode(a1, *(_QWORD *)(a2 + 32));
    appendStringInfo(a1, ",", v26, v27, v28, v29, v30, v31, v249);
  }
  if (*(_DWORD *)(a2 + 40))
    appendStringInfo(a1, "\"resultRelation\":%d,", v20, v21, v22, v23, v24, v25, *(unsigned int *)(a2 + 40));
  if (*(_BYTE *)(a2 + 44))
    appendStringInfo(a1, "\"hasAggs\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 45))
    appendStringInfo(a1, "\"hasWindowFuncs\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 46))
    appendStringInfo(a1, "\"hasTargetSRFs\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 47))
    appendStringInfo(a1, "\"hasSubLinks\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 48))
    appendStringInfo(a1, "\"hasDistinctOn\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 49))
    appendStringInfo(a1, "\"hasRecursive\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 50))
    appendStringInfo(a1, "\"hasModifyingCTE\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 51))
    appendStringInfo(a1, "\"hasForUpdate\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_BYTE *)(a2 + 52))
    appendStringInfo(a1, "\"hasRowSecurity\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo(a1, "\"cteList\":", v20, v21, v22, v23, v24, v25, v248);
    appendStringInfoChar(a1, 91);
    v38 = *(_QWORD *)(a2 + 56);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      v39 = 0;
      v40 = 8;
      do
      {
        v41 = *(_QWORD *)(v38 + 16);
        v42 = *(_QWORD *)(v41 + 8 * v39);
        if (v42)
          _outNode(a1, v42);
        else
          appendStringInfoString(a1, "{}");
        if (v41 + v40)
          v43 = v41 + v40 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v43 = 1;
        if (!v43)
          appendStringInfoString(a1, ",");
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    appendStringInfo(a1, "],", v32, v33, v34, v35, v36, v37, v250);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo(a1, "\"rtable\":", v20, v21, v22, v23, v24, v25, v248);
    appendStringInfoChar(a1, 91);
    v50 = *(_QWORD *)(a2 + 64);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      v51 = 0;
      v52 = 8;
      do
      {
        v53 = *(_QWORD *)(v50 + 16);
        v54 = *(_QWORD *)(v53 + 8 * v51);
        if (v54)
          _outNode(a1, v54);
        else
          appendStringInfoString(a1, "{}");
        if (v53 + v52)
          v55 = v53 + v52 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v55 = 1;
        if (!v55)
          appendStringInfoString(a1, ",");
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v251);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo(a1, "\"jointree\":{", v20, v21, v22, v23, v24, v25, v248);
    _outFromExpr(a1, *(_QWORD *)(a2 + 72), v56, v57, v58, v59, v60, v61, v252);
    v68 = *(_DWORD *)(a1 + 8);
    v69 = __OFSUB__(v68, 1);
    v70 = (v68 - 1);
    if ((int)v70 < 0 == v69)
    {
      v71 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v70) == 44)
      {
        *(_DWORD *)(a1 + 8) = v70;
        *(_BYTE *)(v71 + v70) = 0;
      }
    }
    appendStringInfo(a1, "},", v62, v63, v64, v65, v66, v67, v253);
  }
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo(a1, "\"targetList\":", v20, v21, v22, v23, v24, v25, v248);
    appendStringInfoChar(a1, 91);
    v78 = *(_QWORD *)(a2 + 80);
    if (v78 && *(int *)(v78 + 4) >= 1)
    {
      v79 = 0;
      v80 = 8;
      do
      {
        v81 = *(_QWORD *)(v78 + 16);
        v82 = *(_QWORD *)(v81 + 8 * v79);
        if (v82)
          _outNode(a1, v82);
        else
          appendStringInfoString(a1, "{}");
        if (v81 + v80)
          v83 = v81 + v80 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 80) + 4));
        else
          v83 = 1;
        if (!v83)
          appendStringInfoString(a1, ",");
        ++v79;
        v80 += 8;
      }
      while (v79 < *(int *)(v78 + 4));
    }
    appendStringInfo(a1, "],", v72, v73, v74, v75, v76, v77, v254);
  }
  v84 = *(int *)(a2 + 88);
  if (v84 > 2)
    v85 = 0;
  else
    v85 = (&off_1E264ADE0)[v84];
  appendStringInfo(a1, "\"override\":\"%s\",", v20, v21, v22, v23, v24, v25, (size_t)v85);
  if (*(_QWORD *)(a2 + 96))
  {
    appendStringInfo(a1, "\"onConflict\":{", v86, v87, v88, v89, v90, v91, v255);
    _outOnConflictExpr(a1, *(_QWORD *)(a2 + 96), v92, v93, v94, v95, v96, v97, v256);
    v104 = *(_DWORD *)(a1 + 8);
    v69 = __OFSUB__(v104, 1);
    v105 = (v104 - 1);
    if ((int)v105 < 0 == v69)
    {
      v106 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v105) == 44)
      {
        *(_DWORD *)(a1 + 8) = v105;
        *(_BYTE *)(v106 + v105) = 0;
      }
    }
    appendStringInfo(a1, "},", v98, v99, v100, v101, v102, v103, v257);
  }
  if (*(_QWORD *)(a2 + 104))
  {
    appendStringInfo(a1, "\"returningList\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    v113 = *(_QWORD *)(a2 + 104);
    if (v113 && *(int *)(v113 + 4) >= 1)
    {
      v114 = 0;
      v115 = 8;
      do
      {
        v116 = *(_QWORD *)(v113 + 16);
        v117 = *(_QWORD *)(v116 + 8 * v114);
        if (v117)
          _outNode(a1, v117);
        else
          appendStringInfoString(a1, "{}");
        if (v116 + v115)
          v118 = v116 + v115 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 104) + 4));
        else
          v118 = 1;
        if (!v118)
          appendStringInfoString(a1, ",");
        ++v114;
        v115 += 8;
      }
      while (v114 < *(int *)(v113 + 4));
    }
    appendStringInfo(a1, "],", v107, v108, v109, v110, v111, v112, v258);
  }
  if (*(_QWORD *)(a2 + 112))
  {
    appendStringInfo(a1, "\"groupClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    v125 = *(_QWORD *)(a2 + 112);
    if (v125 && *(int *)(v125 + 4) >= 1)
    {
      v126 = 0;
      v127 = 8;
      do
      {
        v128 = *(_QWORD *)(v125 + 16);
        v129 = *(_QWORD *)(v128 + 8 * v126);
        if (v129)
          _outNode(a1, v129);
        else
          appendStringInfoString(a1, "{}");
        if (v128 + v127)
          v130 = v128 + v127 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 112) + 4));
        else
          v130 = 1;
        if (!v130)
          appendStringInfoString(a1, ",");
        ++v126;
        v127 += 8;
      }
      while (v126 < *(int *)(v125 + 4));
    }
    appendStringInfo(a1, "],", v119, v120, v121, v122, v123, v124, v259);
  }
  if (*(_QWORD *)(a2 + 120))
  {
    appendStringInfo(a1, "\"groupingSets\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    v137 = *(_QWORD *)(a2 + 120);
    if (v137 && *(int *)(v137 + 4) >= 1)
    {
      v138 = 0;
      v139 = 8;
      do
      {
        v140 = *(_QWORD *)(v137 + 16);
        v141 = *(_QWORD *)(v140 + 8 * v138);
        if (v141)
          _outNode(a1, v141);
        else
          appendStringInfoString(a1, "{}");
        if (v140 + v139)
          v142 = v140 + v139 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 120) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 120) + 4));
        else
          v142 = 1;
        if (!v142)
          appendStringInfoString(a1, ",");
        ++v138;
        v139 += 8;
      }
      while (v138 < *(int *)(v137 + 4));
    }
    appendStringInfo(a1, "],", v131, v132, v133, v134, v135, v136, v260);
  }
  if (*(_QWORD *)(a2 + 128))
  {
    appendStringInfo(a1, "\"havingQual\":", v86, v87, v88, v89, v90, v91, v255);
    _outNode(a1, *(_QWORD *)(a2 + 128));
    appendStringInfo(a1, ",", v143, v144, v145, v146, v147, v148, v261);
  }
  if (*(_QWORD *)(a2 + 136))
  {
    appendStringInfo(a1, "\"windowClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    v155 = *(_QWORD *)(a2 + 136);
    if (v155 && *(int *)(v155 + 4) >= 1)
    {
      v156 = 0;
      v157 = 8;
      do
      {
        v158 = *(_QWORD *)(v155 + 16);
        v159 = *(_QWORD *)(v158 + 8 * v156);
        if (v159)
          _outNode(a1, v159);
        else
          appendStringInfoString(a1, "{}");
        if (v158 + v157)
          v160 = v158 + v157 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 136) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 136) + 4));
        else
          v160 = 1;
        if (!v160)
          appendStringInfoString(a1, ",");
        ++v156;
        v157 += 8;
      }
      while (v156 < *(int *)(v155 + 4));
    }
    appendStringInfo(a1, "],", v149, v150, v151, v152, v153, v154, v262);
  }
  if (*(_QWORD *)(a2 + 144))
  {
    appendStringInfo(a1, "\"distinctClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    v167 = *(_QWORD *)(a2 + 144);
    if (v167 && *(int *)(v167 + 4) >= 1)
    {
      v168 = 0;
      v169 = 8;
      do
      {
        v170 = *(_QWORD *)(v167 + 16);
        v171 = *(_QWORD *)(v170 + 8 * v168);
        if (v171)
          _outNode(a1, v171);
        else
          appendStringInfoString(a1, "{}");
        if (v170 + v169)
          v172 = v170 + v169 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 144) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 144) + 4));
        else
          v172 = 1;
        if (!v172)
          appendStringInfoString(a1, ",");
        ++v168;
        v169 += 8;
      }
      while (v168 < *(int *)(v167 + 4));
    }
    appendStringInfo(a1, "],", v161, v162, v163, v164, v165, v166, v263);
  }
  if (*(_QWORD *)(a2 + 152))
  {
    appendStringInfo(a1, "\"sortClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    v179 = *(_QWORD *)(a2 + 152);
    if (v179 && *(int *)(v179 + 4) >= 1)
    {
      v180 = 0;
      v181 = 8;
      do
      {
        v182 = *(_QWORD *)(v179 + 16);
        v183 = *(_QWORD *)(v182 + 8 * v180);
        if (v183)
          _outNode(a1, v183);
        else
          appendStringInfoString(a1, "{}");
        if (v182 + v181)
          v184 = v182 + v181 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 152) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 152) + 4));
        else
          v184 = 1;
        if (!v184)
          appendStringInfoString(a1, ",");
        ++v180;
        v181 += 8;
      }
      while (v180 < *(int *)(v179 + 4));
    }
    appendStringInfo(a1, "],", v173, v174, v175, v176, v177, v178, v264);
  }
  if (*(_QWORD *)(a2 + 160))
  {
    appendStringInfo(a1, "\"limitOffset\":", v86, v87, v88, v89, v90, v91, v255);
    _outNode(a1, *(_QWORD *)(a2 + 160));
    appendStringInfo(a1, ",", v185, v186, v187, v188, v189, v190, v265);
  }
  if (*(_QWORD *)(a2 + 168))
  {
    appendStringInfo(a1, "\"limitCount\":", v86, v87, v88, v89, v90, v91, v255);
    _outNode(a1, *(_QWORD *)(a2 + 168));
    appendStringInfo(a1, ",", v191, v192, v193, v194, v195, v196, v266);
  }
  v197 = *(int *)(a2 + 176);
  if (v197 > 2)
    v198 = 0;
  else
    v198 = (&off_1E264ADF8)[v197];
  result = appendStringInfo(a1, "\"limitOption\":\"%s\",", v86, v87, v88, v89, v90, v91, (size_t)v198);
  if (*(_QWORD *)(a2 + 184))
  {
    appendStringInfo(a1, "\"rowMarks\":", v200, v201, v202, v203, v204, v205, v267);
    appendStringInfoChar(a1, 91);
    v212 = *(_QWORD *)(a2 + 184);
    if (v212 && *(int *)(v212 + 4) >= 1)
    {
      v213 = 0;
      v214 = 8;
      do
      {
        v215 = *(_QWORD *)(v212 + 16);
        v216 = *(_QWORD *)(v215 + 8 * v213);
        if (v216)
          _outNode(a1, v216);
        else
          appendStringInfoString(a1, "{}");
        if (v215 + v214)
          v217 = v215 + v214 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 184) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 184) + 4));
        else
          v217 = 1;
        if (!v217)
          appendStringInfoString(a1, ",");
        ++v213;
        v214 += 8;
      }
      while (v213 < *(int *)(v212 + 4));
    }
    result = appendStringInfo(a1, "],", v206, v207, v208, v209, v210, v211, v268);
  }
  if (*(_QWORD *)(a2 + 192))
  {
    appendStringInfo(a1, "\"setOperations\":", v200, v201, v202, v203, v204, v205, v267);
    _outNode(a1, *(_QWORD *)(a2 + 192));
    result = appendStringInfo(a1, ",", v218, v219, v220, v221, v222, v223, v269);
  }
  if (*(_QWORD *)(a2 + 200))
  {
    appendStringInfo(a1, "\"constraintDeps\":", v200, v201, v202, v203, v204, v205, v267);
    appendStringInfoChar(a1, 91);
    v230 = *(_QWORD *)(a2 + 200);
    if (v230 && *(int *)(v230 + 4) >= 1)
    {
      v231 = 0;
      v232 = 8;
      do
      {
        v233 = *(_QWORD *)(v230 + 16);
        v234 = *(_QWORD *)(v233 + 8 * v231);
        if (v234)
          _outNode(a1, v234);
        else
          appendStringInfoString(a1, "{}");
        if (v233 + v232)
          v235 = v233 + v232 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 200) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 200) + 4));
        else
          v235 = 1;
        if (!v235)
          appendStringInfoString(a1, ",");
        ++v231;
        v232 += 8;
      }
      while (v231 < *(int *)(v230 + 4));
    }
    result = appendStringInfo(a1, "],", v224, v225, v226, v227, v228, v229, v270);
  }
  if (*(_QWORD *)(a2 + 208))
  {
    appendStringInfo(a1, "\"withCheckOptions\":", v200, v201, v202, v203, v204, v205, v267);
    appendStringInfoChar(a1, 91);
    v242 = *(_QWORD *)(a2 + 208);
    if (v242 && *(int *)(v242 + 4) >= 1)
    {
      v243 = 0;
      v244 = 8;
      do
      {
        v245 = *(_QWORD *)(v242 + 16);
        v246 = *(_QWORD *)(v245 + 8 * v243);
        if (v246)
          _outNode(a1, v246);
        else
          appendStringInfoString(a1, "{}");
        if (v245 + v244)
          v247 = v245 + v244 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 208) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 208) + 4));
        else
          v247 = 1;
        if (!v247)
          appendStringInfoString(a1, ",");
        ++v243;
        v244 += 8;
      }
      while (v243 < *(int *)(v242 + 4));
    }
    result = appendStringInfo(a1, "],", v236, v237, v238, v239, v240, v241, v271);
  }
  if (*(_DWORD *)(a2 + 216))
    result = appendStringInfo(a1, "\"stmt_location\":%d,", v200, v201, v202, v203, v204, v205, *(unsigned int *)(a2 + 216));
  if (*(_DWORD *)(a2 + 220))
    return appendStringInfo(a1, "\"stmt_len\":%d,", v200, v201, v202, v203, v204, v205, *(unsigned int *)(a2 + 220));
  return result;
}

unint64_t _outInsertStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  BOOL v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  size_t v89;
  size_t v90;
  size_t v91;
  size_t v92;
  size_t v93;
  size_t v94;
  size_t v95;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v89);
    _outRangeVar(a1, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v90);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"cols\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar(a1, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(a1, v36);
        else
          appendStringInfoString(a1, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString(a1, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v91);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"selectStmt\":", a3, a4, a5, a6, a7, a8, v89);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    appendStringInfo(a1, ",", v38, v39, v40, v41, v42, v43, v92);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"onConflictClause\":{", a3, a4, a5, a6, a7, a8, v89);
    _outOnConflictClause(a1, *(_QWORD *)(a2 + 32), v44, v45, v46, v47, v48, v49);
    v56 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v56, 1);
    v57 = (v56 - 1);
    if ((int)v57 < 0 == v23)
    {
      v58 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v57) == 44)
      {
        *(_DWORD *)(a1 + 8) = v57;
        *(_BYTE *)(v58 + v57) = 0;
      }
    }
    appendStringInfo(a1, "},", v50, v51, v52, v53, v54, v55, v93);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"returningList\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar(a1, 91);
    v65 = *(_QWORD *)(a2 + 40);
    if (v65 && *(int *)(v65 + 4) >= 1)
    {
      v66 = 0;
      v67 = 8;
      do
      {
        v68 = *(_QWORD *)(v65 + 16);
        v69 = *(_QWORD *)(v68 + 8 * v66);
        if (v69)
          _outNode(a1, v69);
        else
          appendStringInfoString(a1, "{}");
        if (v68 + v67)
          v70 = v68 + v67 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v70 = 1;
        if (!v70)
          appendStringInfoString(a1, ",");
        ++v66;
        v67 += 8;
      }
      while (v66 < *(int *)(v65 + 4));
    }
    appendStringInfo(a1, "],", v59, v60, v61, v62, v63, v64, v94);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(a1, "\"withClause\":{", a3, a4, a5, a6, a7, a8, v89);
    _outWithClause(a1, *(_QWORD *)(a2 + 48), v71, v72, v73, v74, v75, v76);
    v83 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v83, 1);
    v84 = (v83 - 1);
    if ((int)v84 < 0 == v23)
    {
      v85 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v84) == 44)
      {
        *(_DWORD *)(a1 + 8) = v84;
        *(_BYTE *)(v85 + v84) = 0;
      }
    }
    appendStringInfo(a1, "},", v77, v78, v79, v80, v81, v82, v95);
  }
  v86 = *(int *)(a2 + 56);
  if (v86 > 2)
    v87 = 0;
  else
    v87 = (&off_1E264ADE0)[v86];
  return appendStringInfo(a1, "\"override\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v87);
}

uint64_t _outDeleteStmt(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  size_t v72;
  size_t v73;
  size_t v74;
  size_t v75;
  size_t v76;

  v10 = result;
  if (a2[1])
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v72);
    _outRangeVar(v10, a2[1], v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v73);
  }
  if (a2[2])
  {
    appendStringInfo(v10, "\"usingClause\":", a3, a4, a5, a6, a7, a8, v72);
    appendStringInfoChar(v10, 91);
    v33 = a2[2];
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      v34 = 0;
      v35 = 8;
      do
      {
        v36 = *(_QWORD *)(v33 + 16);
        v37 = *(_QWORD *)(v36 + 8 * v34);
        if (v37)
          _outNode(v10, v37);
        else
          appendStringInfoString(v10, "{}");
        if (v36 + v35)
          v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(a2[2] + 16) + 8 * *(int *)(a2[2] + 4));
        else
          v38 = 1;
        if (!v38)
          appendStringInfoString(v10, ",");
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    result = appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, v74);
  }
  if (a2[3])
  {
    appendStringInfo(v10, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v72);
    _outNode(v10, a2[3]);
    result = appendStringInfo(v10, ",", v39, v40, v41, v42, v43, v44, v75);
  }
  if (a2[4])
  {
    appendStringInfo(v10, "\"returningList\":", a3, a4, a5, a6, a7, a8, v72);
    appendStringInfoChar(v10, 91);
    v51 = a2[4];
    if (v51 && *(int *)(v51 + 4) >= 1)
    {
      v52 = 0;
      v53 = 8;
      do
      {
        v54 = *(_QWORD *)(v51 + 16);
        v55 = *(_QWORD *)(v54 + 8 * v52);
        if (v55)
          _outNode(v10, v55);
        else
          appendStringInfoString(v10, "{}");
        if (v54 + v53)
          v56 = v54 + v53 >= (unint64_t)(*(_QWORD *)(a2[4] + 16) + 8 * *(int *)(a2[4] + 4));
        else
          v56 = 1;
        if (!v56)
          appendStringInfoString(v10, ",");
        ++v52;
        v53 += 8;
      }
      while (v52 < *(int *)(v51 + 4));
    }
    result = appendStringInfo(v10, "],", v45, v46, v47, v48, v49, v50, v76);
  }
  if (a2[5])
  {
    appendStringInfo(v10, "\"withClause\":{", a3, a4, a5, a6, a7, a8, v72);
    _outWithClause(v10, a2[5], v57, v58, v59, v60, v61, v62);
    v69 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v69, 1);
    v70 = (v69 - 1);
    if ((int)v70 < 0 == v24)
    {
      v71 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v70) == 44)
      {
        *(_DWORD *)(v10 + 8) = v70;
        *(_BYTE *)(v71 + v70) = 0;
      }
    }
    return appendStringInfo(v10, "},", v63, v64, v65, v66, v67, v68, a9);
  }
  return result;
}

uint64_t _outUpdateStmt(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  size_t v84;
  size_t v85;
  size_t v86;
  size_t v87;
  size_t v88;
  size_t v89;

  v10 = result;
  if (a2[1])
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v84);
    _outRangeVar(v10, a2[1], v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v85);
  }
  if (a2[2])
  {
    appendStringInfo(v10, "\"targetList\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(v10, 91);
    v33 = a2[2];
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      v34 = 0;
      v35 = 8;
      do
      {
        v36 = *(_QWORD *)(v33 + 16);
        v37 = *(_QWORD *)(v36 + 8 * v34);
        if (v37)
          _outNode(v10, v37);
        else
          appendStringInfoString(v10, "{}");
        if (v36 + v35)
          v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(a2[2] + 16) + 8 * *(int *)(a2[2] + 4));
        else
          v38 = 1;
        if (!v38)
          appendStringInfoString(v10, ",");
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    result = appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, v86);
  }
  if (a2[3])
  {
    appendStringInfo(v10, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v84);
    _outNode(v10, a2[3]);
    result = appendStringInfo(v10, ",", v39, v40, v41, v42, v43, v44, v87);
  }
  if (a2[4])
  {
    appendStringInfo(v10, "\"fromClause\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(v10, 91);
    v51 = a2[4];
    if (v51 && *(int *)(v51 + 4) >= 1)
    {
      v52 = 0;
      v53 = 8;
      do
      {
        v54 = *(_QWORD *)(v51 + 16);
        v55 = *(_QWORD *)(v54 + 8 * v52);
        if (v55)
          _outNode(v10, v55);
        else
          appendStringInfoString(v10, "{}");
        if (v54 + v53)
          v56 = v54 + v53 >= (unint64_t)(*(_QWORD *)(a2[4] + 16) + 8 * *(int *)(a2[4] + 4));
        else
          v56 = 1;
        if (!v56)
          appendStringInfoString(v10, ",");
        ++v52;
        v53 += 8;
      }
      while (v52 < *(int *)(v51 + 4));
    }
    result = appendStringInfo(v10, "],", v45, v46, v47, v48, v49, v50, v88);
  }
  if (a2[5])
  {
    appendStringInfo(v10, "\"returningList\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(v10, 91);
    v63 = a2[5];
    if (v63 && *(int *)(v63 + 4) >= 1)
    {
      v64 = 0;
      v65 = 8;
      do
      {
        v66 = *(_QWORD *)(v63 + 16);
        v67 = *(_QWORD *)(v66 + 8 * v64);
        if (v67)
          _outNode(v10, v67);
        else
          appendStringInfoString(v10, "{}");
        if (v66 + v65)
          v68 = v66 + v65 >= (unint64_t)(*(_QWORD *)(a2[5] + 16) + 8 * *(int *)(a2[5] + 4));
        else
          v68 = 1;
        if (!v68)
          appendStringInfoString(v10, ",");
        ++v64;
        v65 += 8;
      }
      while (v64 < *(int *)(v63 + 4));
    }
    result = appendStringInfo(v10, "],", v57, v58, v59, v60, v61, v62, v89);
  }
  if (a2[6])
  {
    appendStringInfo(v10, "\"withClause\":{", a3, a4, a5, a6, a7, a8, v84);
    _outWithClause(v10, a2[6], v69, v70, v71, v72, v73, v74);
    v81 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v81, 1);
    v82 = (v81 - 1);
    if ((int)v82 < 0 == v24)
    {
      v83 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v82) == 44)
      {
        *(_DWORD *)(v10 + 8) = v82;
        *(_BYTE *)(v83 + v82) = 0;
      }
    }
    return appendStringInfo(v10, "},", v75, v76, v77, v78, v79, v80, a9);
  }
  return result;
}

unint64_t _outSelectStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  BOOL v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  BOOL v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  char *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  BOOL v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  char *v171;
  unint64_t result;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  int v194;
  uint64_t v195;
  uint64_t v196;
  size_t v197;
  size_t v198;
  size_t v199;
  size_t v200;
  size_t v201;
  size_t v202;
  size_t v203;
  size_t v204;
  size_t v205;
  size_t v206;
  size_t v207;
  size_t v208;
  size_t v209;
  size_t v210;
  size_t v211;
  size_t v212;
  size_t v213;
  size_t v214;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"distinctClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(a1, v21);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString((uint64_t)a1, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v11, v12, v13, v14, v15, v16, v198);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"intoClause\":{", a3, a4, a5, a6, a7, a8, v197);
    _outIntoClause(a1, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = a1[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v37) == 44)
      {
        a1[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v29, v30, v31, v32, v33, v34, v199);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"targetList\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    v45 = *(_QWORD *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      v46 = 0;
      v47 = 8;
      do
      {
        v48 = *(_QWORD *)(v45 + 16);
        v49 = *(_QWORD *)(v48 + 8 * v46);
        if (v49)
          _outNode(a1, v49);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v48 + v47)
          v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v50 = 1;
        if (!v50)
          appendStringInfoString((uint64_t)a1, ",");
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v39, v40, v41, v42, v43, v44, v200);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"fromClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    v57 = *(_QWORD *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      v58 = 0;
      v59 = 8;
      do
      {
        v60 = *(_QWORD *)(v57 + 16);
        v61 = *(_QWORD *)(v60 + 8 * v58);
        if (v61)
          _outNode(a1, v61);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v60 + v59)
          v62 = v60 + v59 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v62 = 1;
        if (!v62)
          appendStringInfoString((uint64_t)a1, ",");
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v51, v52, v53, v54, v55, v56, v201);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(_QWORD *)(a2 + 40));
    appendStringInfo((uint64_t)a1, ",", v63, v64, v65, v66, v67, v68, v202);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"groupClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    v75 = *(_QWORD *)(a2 + 48);
    if (v75 && *(int *)(v75 + 4) >= 1)
    {
      v76 = 0;
      v77 = 8;
      do
      {
        v78 = *(_QWORD *)(v75 + 16);
        v79 = *(_QWORD *)(v78 + 8 * v76);
        if (v79)
          _outNode(a1, v79);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v78 + v77)
          v80 = v78 + v77 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v80 = 1;
        if (!v80)
          appendStringInfoString((uint64_t)a1, ",");
        ++v76;
        v77 += 8;
      }
      while (v76 < *(int *)(v75 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v69, v70, v71, v72, v73, v74, v203);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"havingClause\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(_QWORD *)(a2 + 56));
    appendStringInfo((uint64_t)a1, ",", v81, v82, v83, v84, v85, v86, v204);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"windowClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    v93 = *(_QWORD *)(a2 + 64);
    if (v93 && *(int *)(v93 + 4) >= 1)
    {
      v94 = 0;
      v95 = 8;
      do
      {
        v96 = *(_QWORD *)(v93 + 16);
        v97 = *(_QWORD *)(v96 + 8 * v94);
        if (v97)
          _outNode(a1, v97);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v96 + v95)
          v98 = v96 + v95 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v98 = 1;
        if (!v98)
          appendStringInfoString((uint64_t)a1, ",");
        ++v94;
        v95 += 8;
      }
      while (v94 < *(int *)(v93 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v87, v88, v89, v90, v91, v92, v205);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"valuesLists\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    v105 = *(_QWORD *)(a2 + 72);
    if (v105 && *(int *)(v105 + 4) >= 1)
    {
      v106 = 0;
      v107 = 8;
      do
      {
        v108 = *(_QWORD *)(v105 + 16);
        v109 = *(_QWORD *)(v108 + 8 * v106);
        if (v109)
          _outNode(a1, v109);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v108 + v107)
          v110 = v108 + v107 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v110 = 1;
        if (!v110)
          appendStringInfoString((uint64_t)a1, ",");
        ++v106;
        v107 += 8;
      }
      while (v106 < *(int *)(v105 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v99, v100, v101, v102, v103, v104, v206);
  }
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"sortClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    v117 = *(_QWORD *)(a2 + 80);
    if (v117 && *(int *)(v117 + 4) >= 1)
    {
      v118 = 0;
      v119 = 8;
      do
      {
        v120 = *(_QWORD *)(v117 + 16);
        v121 = *(_QWORD *)(v120 + 8 * v118);
        if (v121)
          _outNode(a1, v121);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v120 + v119)
          v122 = v120 + v119 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 80) + 4));
        else
          v122 = 1;
        if (!v122)
          appendStringInfoString((uint64_t)a1, ",");
        ++v118;
        v119 += 8;
      }
      while (v118 < *(int *)(v117 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v111, v112, v113, v114, v115, v116, v207);
  }
  if (*(_QWORD *)(a2 + 88))
  {
    appendStringInfo((uint64_t)a1, "\"limitOffset\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(_QWORD *)(a2 + 88));
    appendStringInfo((uint64_t)a1, ",", v123, v124, v125, v126, v127, v128, v208);
  }
  if (*(_QWORD *)(a2 + 96))
  {
    appendStringInfo((uint64_t)a1, "\"limitCount\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(_QWORD *)(a2 + 96));
    appendStringInfo((uint64_t)a1, ",", v129, v130, v131, v132, v133, v134, v209);
  }
  v135 = *(int *)(a2 + 104);
  if (v135 > 2)
    v136 = 0;
  else
    v136 = (&off_1E264ADF8)[v135];
  appendStringInfo((uint64_t)a1, "\"limitOption\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v136);
  if (*(_QWORD *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"lockingClause\":", v137, v138, v139, v140, v141, v142, v210);
    appendStringInfoChar((uint64_t)a1, 91);
    v149 = *(_QWORD *)(a2 + 112);
    if (v149 && *(int *)(v149 + 4) >= 1)
    {
      v150 = 0;
      v151 = 8;
      do
      {
        v152 = *(_QWORD *)(v149 + 16);
        v153 = *(_QWORD *)(v152 + 8 * v150);
        if (v153)
          _outNode(a1, v153);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v152 + v151)
          v154 = v152 + v151 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 112) + 4));
        else
          v154 = 1;
        if (!v154)
          appendStringInfoString((uint64_t)a1, ",");
        ++v150;
        v151 += 8;
      }
      while (v150 < *(int *)(v149 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v143, v144, v145, v146, v147, v148, v211);
  }
  if (*(_QWORD *)(a2 + 120))
  {
    appendStringInfo((uint64_t)a1, "\"withClause\":{", v137, v138, v139, v140, v141, v142, v210);
    _outWithClause((uint64_t)a1, *(_QWORD *)(a2 + 120), v155, v156, v157, v158, v159, v160);
    v167 = a1[2];
    v36 = __OFSUB__(v167, 1);
    v168 = (v167 - 1);
    if ((int)v168 < 0 == v36)
    {
      v169 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v168) == 44)
      {
        a1[2] = v168;
        *(_BYTE *)(v169 + v168) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v161, v162, v163, v164, v165, v166, v212);
  }
  v170 = *(int *)(a2 + 128);
  if (v170 > 3)
    v171 = 0;
  else
    v171 = (&off_1E264B028)[v170];
  result = appendStringInfo((uint64_t)a1, "\"op\":\"%s\",", v137, v138, v139, v140, v141, v142, (size_t)v171);
  if (*(_BYTE *)(a2 + 132))
    result = appendStringInfo((uint64_t)a1, "\"all\":%s,", v173, v174, v175, v176, v177, v178, (size_t)"true");
  if (*(_QWORD *)(a2 + 136))
  {
    appendStringInfo((uint64_t)a1, "\"larg\":{", v173, v174, v175, v176, v177, v178, v213);
    _outSelectStmt(a1, *(_QWORD *)(a2 + 136));
    v185 = a1[2];
    v36 = __OFSUB__(v185, 1);
    v186 = (v185 - 1);
    if ((int)v186 < 0 == v36)
    {
      v187 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v186) == 44)
      {
        a1[2] = v186;
        *(_BYTE *)(v187 + v186) = 0;
      }
    }
    result = appendStringInfo((uint64_t)a1, "},", v179, v180, v181, v182, v183, v184, v214);
  }
  if (*(_QWORD *)(a2 + 144))
  {
    appendStringInfo((uint64_t)a1, "\"rarg\":{", v173, v174, v175, v176, v177, v178, v213);
    _outSelectStmt(a1, *(_QWORD *)(a2 + 144));
    v194 = a1[2];
    v36 = __OFSUB__(v194, 1);
    v195 = (v194 - 1);
    if ((int)v195 < 0 == v36)
    {
      v196 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v195) == 44)
      {
        a1[2] = v195;
        *(_BYTE *)(v196 + v195) = 0;
      }
    }
    return appendStringInfo((uint64_t)a1, "},", v188, v189, v190, v191, v192, v193, a9);
  }
  return result;
}

unint64_t _outAlterTableStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  char *v39;
  unint64_t result;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t v47;
  size_t v48;
  size_t v49;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v47);
    _outRangeVar(a1, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v48);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"cmds\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar(a1, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(a1, v36);
        else
          appendStringInfoString(a1, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString(a1, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v49);
  }
  v38 = *(int *)(a2 + 24);
  if (v38 > 0x31)
    v39 = 0;
  else
    v39 = (&off_1E264B228)[v38];
  result = appendStringInfo(a1, "\"relkind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v39);
  if (*(_BYTE *)(a2 + 28))
    return appendStringInfo(a1, "\"missing_ok\":%s,", v41, v42, v43, v44, v45, v46, (size_t)"true");
  return result;
}

unint64_t _outAlterTableCmd(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  const char *v53;
  const char *v54;
  unint64_t result;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  size_t v62;
  size_t v63;
  size_t v64;
  size_t v65;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0x42)
    v11 = 0;
  else
    v11 = (&off_1E264AE10)[v10];
  appendStringInfo((uint64_t)a1, "\"subtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v12, v13, v14, v15, v16, v17, v62);
    _outToken(a1, *(char **)(a2 + 8), v18, v19, v20, v21, v22, v23);
    appendStringInfo((uint64_t)a1, ",", v24, v25, v26, v27, v28, v29, v63);
  }
  if (*(_WORD *)(a2 + 16))
    appendStringInfo((uint64_t)a1, "\"num\":%d,", v12, v13, v14, v15, v16, v17, *(__int16 *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"newowner\":{", v12, v13, v14, v15, v16, v17, v62);
    _outRoleSpec(a1, *(_QWORD *)(a2 + 24), v30, v31, v32, v33, v34, v35);
    v42 = a1[2];
    v43 = __OFSUB__(v42, 1);
    v44 = (v42 - 1);
    if ((int)v44 < 0 == v43)
    {
      v45 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v44) == 44)
      {
        a1[2] = v44;
        *(_BYTE *)(v45 + v44) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v36, v37, v38, v39, v40, v41, v64);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"def\":", v12, v13, v14, v15, v16, v17, v62);
    _outNode(a1, *(_QWORD *)(a2 + 32));
    appendStringInfo((uint64_t)a1, ",", v46, v47, v48, v49, v50, v51, v65);
  }
  v52 = *(_DWORD *)(a2 + 40);
  v53 = "DROP_CASCADE";
  if (v52 != 1)
    v53 = 0;
  if (v52)
    v54 = v53;
  else
    v54 = "DROP_RESTRICT";
  result = appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v54);
  if (*(_BYTE *)(a2 + 44))
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v56, v57, v58, v59, v60, v61, (size_t)"true");
  return result;
}

unint64_t _outAlterDomainStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  const char *v41;
  const char *v42;
  unint64_t result;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  size_t v50;
  size_t v51;
  size_t v52;
  size_t v53;

  if (*(_BYTE *)(a2 + 4))
    appendStringInfo((uint64_t)a1, "\"subtype\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 4));
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"typeName\":", a3, a4, a5, a6, a7, a8, v50);
    appendStringInfoChar((uint64_t)a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString((uint64_t)a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v10, v11, v12, v13, v14, v15, v51);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", a3, a4, a5, a6, a7, a8, v50);
    _outToken(a1, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    appendStringInfo((uint64_t)a1, ",", v28, v29, v30, v31, v32, v33, v52);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"def\":", a3, a4, a5, a6, a7, a8, v50);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v34, v35, v36, v37, v38, v39, v53);
  }
  v40 = *(_DWORD *)(a2 + 32);
  v41 = "DROP_CASCADE";
  if (v40 != 1)
    v41 = 0;
  if (v40)
    v42 = v41;
  else
    v42 = "DROP_RESTRICT";
  result = appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v42);
  if (*(_BYTE *)(a2 + 36))
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v44, v45, v46, v47, v48, v49, (size_t)"true");
  return result;
}

unint64_t _outSetOperationStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  BOOL v79;
  size_t v80;
  size_t v81;
  size_t v82;
  size_t v83;
  size_t v84;
  size_t v85;

  v11 = *(int *)(a2 + 4);
  if (v11 > 3)
    v12 = 0;
  else
    v12 = (&off_1E264B028)[v11];
  result = appendStringInfo(a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_BYTE *)(a2 + 8))
    result = appendStringInfo(a1, "\"all\":%s,", v14, v15, v16, v17, v18, v19, (size_t)"true");
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"larg\":", v14, v15, v16, v17, v18, v19, v80);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(a1, ",", v20, v21, v22, v23, v24, v25, v81);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"rarg\":", v14, v15, v16, v17, v18, v19, v80);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    result = appendStringInfo(a1, ",", v26, v27, v28, v29, v30, v31, v82);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"colTypes\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v38 = *(_QWORD *)(a2 + 32);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      v39 = 0;
      v40 = 8;
      do
      {
        v41 = *(_QWORD *)(v38 + 16);
        v42 = *(_QWORD *)(v41 + 8 * v39);
        if (v42)
          _outNode(a1, v42);
        else
          appendStringInfoString(a1, "{}");
        if (v41 + v40)
          v43 = v41 + v40 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v43 = 1;
        if (!v43)
          appendStringInfoString(a1, ",");
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    result = appendStringInfo(a1, "],", v32, v33, v34, v35, v36, v37, v83);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"colTypmods\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v50 = *(_QWORD *)(a2 + 40);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      v51 = 0;
      v52 = 8;
      do
      {
        v53 = *(_QWORD *)(v50 + 16);
        v54 = *(_QWORD *)(v53 + 8 * v51);
        if (v54)
          _outNode(a1, v54);
        else
          appendStringInfoString(a1, "{}");
        if (v53 + v52)
          v55 = v53 + v52 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v55 = 1;
        if (!v55)
          appendStringInfoString(a1, ",");
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    result = appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v84);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(a1, "\"colCollations\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v62 = *(_QWORD *)(a2 + 48);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      v63 = 0;
      v64 = 8;
      do
      {
        v65 = *(_QWORD *)(v62 + 16);
        v66 = *(_QWORD *)(v65 + 8 * v63);
        if (v66)
          _outNode(a1, v66);
        else
          appendStringInfoString(a1, "{}");
        if (v65 + v64)
          v67 = v65 + v64 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v67 = 1;
        if (!v67)
          appendStringInfoString(a1, ",");
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    result = appendStringInfo(a1, "],", v56, v57, v58, v59, v60, v61, v85);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo(a1, "\"groupClauses\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    v74 = *(_QWORD *)(a2 + 56);
    if (v74 && *(int *)(v74 + 4) >= 1)
    {
      v75 = 0;
      v76 = 8;
      do
      {
        v77 = *(_QWORD *)(v74 + 16);
        v78 = *(_QWORD *)(v77 + 8 * v75);
        if (v78)
          _outNode(a1, v78);
        else
          appendStringInfoString(a1, "{}");
        if (v77 + v76)
          v79 = v77 + v76 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v79 = 1;
        if (!v79)
          appendStringInfoString(a1, ",");
        ++v75;
        v76 += 8;
      }
      while (v75 < *(int *)(v74 + 4));
    }
    return appendStringInfo(a1, "],", v68, v69, v70, v71, v72, v73, a9);
  }
  return result;
}

unint64_t _outGrantStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  int v62;
  const char *v63;
  const char *v64;
  size_t v66;
  size_t v67;
  size_t v68;
  size_t v69;

  if (*(_BYTE *)(a2 + 4))
    appendStringInfo(a1, "\"is_grant\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  v10 = *(int *)(a2 + 8);
  if (v10 > 2)
    v11 = 0;
  else
    v11 = (&off_1E264B048)[v10];
  appendStringInfo(a1, "\"targtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  v18 = *(int *)(a2 + 12);
  if (v18 > 0x31)
    v19 = 0;
  else
    v19 = (&off_1E264B228)[v18];
  appendStringInfo(a1, "\"objtype\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"objects\":", v20, v21, v22, v23, v24, v25, v66);
    appendStringInfoChar(a1, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(a1, v36);
        else
          appendStringInfoString(a1, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString(a1, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v67);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"privileges\":", v20, v21, v22, v23, v24, v25, v66);
    appendStringInfoChar(a1, 91);
    v44 = *(_QWORD *)(a2 + 24);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      v45 = 0;
      v46 = 8;
      do
      {
        v47 = *(_QWORD *)(v44 + 16);
        v48 = *(_QWORD *)(v47 + 8 * v45);
        if (v48)
          _outNode(a1, v48);
        else
          appendStringInfoString(a1, "{}");
        if (v47 + v46)
          v49 = v47 + v46 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v49 = 1;
        if (!v49)
          appendStringInfoString(a1, ",");
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    appendStringInfo(a1, "],", v38, v39, v40, v41, v42, v43, v68);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"grantees\":", v20, v21, v22, v23, v24, v25, v66);
    appendStringInfoChar(a1, 91);
    v56 = *(_QWORD *)(a2 + 32);
    if (v56 && *(int *)(v56 + 4) >= 1)
    {
      v57 = 0;
      v58 = 8;
      do
      {
        v59 = *(_QWORD *)(v56 + 16);
        v60 = *(_QWORD *)(v59 + 8 * v57);
        if (v60)
          _outNode(a1, v60);
        else
          appendStringInfoString(a1, "{}");
        if (v59 + v58)
          v61 = v59 + v58 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v61 = 1;
        if (!v61)
          appendStringInfoString(a1, ",");
        ++v57;
        v58 += 8;
      }
      while (v57 < *(int *)(v56 + 4));
    }
    appendStringInfo(a1, "],", v50, v51, v52, v53, v54, v55, v69);
  }
  if (*(_BYTE *)(a2 + 40))
    appendStringInfo(a1, "\"grant_option\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  v62 = *(_DWORD *)(a2 + 44);
  v63 = "DROP_CASCADE";
  if (v62 != 1)
    v63 = 0;
  if (v62)
    v64 = v63;
  else
    v64 = "DROP_RESTRICT";
  return appendStringInfo(a1, "\"behavior\":\"%s\",", v20, v21, v22, v23, v24, v25, (size_t)v64);
}

unint64_t _outGrantRoleStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  const char *v51;
  const char *v52;
  size_t v54;
  size_t v55;
  size_t v56;
  size_t v57;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"granted_roles\":", a3, a4, a5, a6, a7, a8, v54);
    appendStringInfoChar((uint64_t)a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString((uint64_t)a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v10, v11, v12, v13, v14, v15, v55);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"grantee_roles\":", a3, a4, a5, a6, a7, a8, v54);
    appendStringInfoChar((uint64_t)a1, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(a1, v32);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)a1, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v22, v23, v24, v25, v26, v27, v56);
  }
  if (*(_BYTE *)(a2 + 24))
    appendStringInfo((uint64_t)a1, "\"is_grant\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 25))
    appendStringInfo((uint64_t)a1, "\"admin_opt\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"grantor\":{", a3, a4, a5, a6, a7, a8, v54);
    _outRoleSpec(a1, *(_QWORD *)(a2 + 32), v34, v35, v36, v37, v38, v39);
    v46 = a1[2];
    v47 = __OFSUB__(v46, 1);
    v48 = (v46 - 1);
    if ((int)v48 < 0 == v47)
    {
      v49 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v48) == 44)
      {
        a1[2] = v48;
        *(_BYTE *)(v49 + v48) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v40, v41, v42, v43, v44, v45, v57);
  }
  v50 = *(_DWORD *)(a2 + 40);
  v51 = "DROP_CASCADE";
  if (v50 != 1)
    v51 = 0;
  if (v50)
    v52 = v51;
  else
    v52 = "DROP_RESTRICT";
  return appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v52);
}

uint64_t _outAlterDefaultPrivilegesStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  size_t v39;
  size_t v40;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"options\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v40);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"action\":{", a3, a4, a5, a6, a7, a8, v39);
    _outGrantStmt(v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = *(_DWORD *)(v10 + 8);
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        *(_DWORD *)(v10 + 8) = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    return appendStringInfo(v10, "},", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

unint64_t _outClosePortalStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = (int *)result;
    appendStringInfo(result, "\"portalname\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outClusterStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  size_t v39;
  size_t v40;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRangeVar((uint64_t)v9, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = v9[2];
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v24) == 44)
      {
        v9[2] = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"indexname\":", a3, a4, a5, a6, a7, a8, v38);
    _outToken(v9, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    result = appendStringInfo((uint64_t)v9, ",", v32, v33, v34, v35, v36, v37, v40);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo((uint64_t)v9, "\"options\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outCopyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  size_t v75;
  size_t v76;
  size_t v77;
  size_t v78;
  size_t v79;
  size_t v80;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v75);
    _outRangeVar((uint64_t)v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = v10[2];
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        v10[2] = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v76);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"query\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(_QWORD *)(a2 + 16));
    result = appendStringInfo((uint64_t)v10, ",", v27, v28, v29, v30, v31, v32, v77);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"attlist\":", a3, a4, a5, a6, a7, a8, v75);
    appendStringInfoChar((uint64_t)v10, 91);
    v39 = *(_QWORD *)(a2 + 24);
    if (v39 && *(int *)(v39 + 4) >= 1)
    {
      v40 = 0;
      v41 = 8;
      do
      {
        v42 = *(_QWORD *)(v39 + 16);
        v43 = *(_QWORD *)(v42 + 8 * v40);
        if (v43)
          _outNode(v10, v43);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v42 + v41)
          v44 = v42 + v41 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v44 = 1;
        if (!v44)
          appendStringInfoString((uint64_t)v10, ",");
        ++v40;
        v41 += 8;
      }
      while (v40 < *(int *)(v39 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v33, v34, v35, v36, v37, v38, v78);
  }
  if (*(_BYTE *)(a2 + 32))
    result = appendStringInfo((uint64_t)v10, "\"is_from\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 33))
    result = appendStringInfo((uint64_t)v10, "\"is_program\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v10, "\"filename\":", a3, a4, a5, a6, a7, a8, v75);
    _outToken(v10, *(char **)(a2 + 40), v45, v46, v47, v48, v49, v50);
    result = appendStringInfo((uint64_t)v10, ",", v51, v52, v53, v54, v55, v56, v79);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v75);
    appendStringInfoChar((uint64_t)v10, 91);
    v63 = *(_QWORD *)(a2 + 48);
    if (v63 && *(int *)(v63 + 4) >= 1)
    {
      v64 = 0;
      v65 = 8;
      do
      {
        v66 = *(_QWORD *)(v63 + 16);
        v67 = *(_QWORD *)(v66 + 8 * v64);
        if (v67)
          _outNode(v10, v67);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v66 + v65)
          v68 = v66 + v65 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v68 = 1;
        if (!v68)
          appendStringInfoString((uint64_t)v10, ",");
        ++v64;
        v65 += 8;
      }
      while (v64 < *(int *)(v63 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v57, v58, v59, v60, v61, v62, v80);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v10, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(_QWORD *)(a2 + 56));
    return appendStringInfo((uint64_t)v10, ",", v69, v70, v71, v72, v73, v74, a9);
  }
  return result;
}

unint64_t _outCreateStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  BOOL v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  BOOL v118;
  uint64_t v119;
  char *v120;
  unint64_t result;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  size_t v152;
  size_t v153;
  size_t v154;
  size_t v155;
  size_t v156;
  size_t v157;
  size_t v158;
  size_t v159;
  size_t v160;
  size_t v161;
  size_t v162;
  size_t v163;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v152);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = a1[2];
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v24) == 44)
      {
        a1[2] = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v16, v17, v18, v19, v20, v21, v153);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"tableElts\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(a1, v36);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString((uint64_t)a1, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v26, v27, v28, v29, v30, v31, v154);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"inhRelations\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    v44 = *(_QWORD *)(a2 + 24);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      v45 = 0;
      v46 = 8;
      do
      {
        v47 = *(_QWORD *)(v44 + 16);
        v48 = *(_QWORD *)(v47 + 8 * v45);
        if (v48)
          _outNode(a1, v48);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v47 + v46)
          v49 = v47 + v46 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v49 = 1;
        if (!v49)
          appendStringInfoString((uint64_t)a1, ",");
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v38, v39, v40, v41, v42, v43, v155);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"partbound\":{", a3, a4, a5, a6, a7, a8, v152);
    _outPartitionBoundSpec((uint64_t)a1, *(_QWORD *)(a2 + 32), v50, v51, v52, v53, v54, v55);
    v62 = a1[2];
    v23 = __OFSUB__(v62, 1);
    v63 = (v62 - 1);
    if ((int)v63 < 0 == v23)
    {
      v64 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v63) == 44)
      {
        a1[2] = v63;
        *(_BYTE *)(v64 + v63) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v56, v57, v58, v59, v60, v61, v156);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"partspec\":{", a3, a4, a5, a6, a7, a8, v152);
    _outPartitionSpec((uint64_t)a1, *(_QWORD *)(a2 + 40), v65, v66, v67, v68, v69, v70);
    v77 = a1[2];
    v23 = __OFSUB__(v77, 1);
    v78 = (v77 - 1);
    if ((int)v78 < 0 == v23)
    {
      v79 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v78) == 44)
      {
        a1[2] = v78;
        *(_BYTE *)(v79 + v78) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v71, v72, v73, v74, v75, v76, v157);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"ofTypename\":{", a3, a4, a5, a6, a7, a8, v152);
    _outTypeName((uint64_t)a1, *(_QWORD *)(a2 + 48), v80, v81, v82, v83, v84, v85);
    v92 = a1[2];
    v23 = __OFSUB__(v92, 1);
    v93 = (v92 - 1);
    if ((int)v93 < 0 == v23)
    {
      v94 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v93) == 44)
      {
        a1[2] = v93;
        *(_BYTE *)(v94 + v93) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v86, v87, v88, v89, v90, v91, v158);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"constraints\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    v101 = *(_QWORD *)(a2 + 56);
    if (v101 && *(int *)(v101 + 4) >= 1)
    {
      v102 = 0;
      v103 = 8;
      do
      {
        v104 = *(_QWORD *)(v101 + 16);
        v105 = *(_QWORD *)(v104 + 8 * v102);
        if (v105)
          _outNode(a1, v105);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v104 + v103)
          v106 = v104 + v103 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v106 = 1;
        if (!v106)
          appendStringInfoString((uint64_t)a1, ",");
        ++v102;
        v103 += 8;
      }
      while (v102 < *(int *)(v101 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v95, v96, v97, v98, v99, v100, v159);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    v113 = *(_QWORD *)(a2 + 64);
    if (v113 && *(int *)(v113 + 4) >= 1)
    {
      v114 = 0;
      v115 = 8;
      do
      {
        v116 = *(_QWORD *)(v113 + 16);
        v117 = *(_QWORD *)(v116 + 8 * v114);
        if (v117)
          _outNode(a1, v117);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v116 + v115)
          v118 = v116 + v115 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v118 = 1;
        if (!v118)
          appendStringInfoString((uint64_t)a1, ",");
        ++v114;
        v115 += 8;
      }
      while (v114 < *(int *)(v113 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v107, v108, v109, v110, v111, v112, v160);
  }
  v119 = *(int *)(a2 + 72);
  if (v119 > 3)
    v120 = 0;
  else
    v120 = (&off_1E264B060)[v119];
  result = appendStringInfo((uint64_t)a1, "\"oncommit\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v120);
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"tablespacename\":", v122, v123, v124, v125, v126, v127, v161);
    _outToken(a1, *(char **)(a2 + 80), v128, v129, v130, v131, v132, v133);
    result = appendStringInfo((uint64_t)a1, ",", v134, v135, v136, v137, v138, v139, v162);
  }
  if (*(_QWORD *)(a2 + 88))
  {
    appendStringInfo((uint64_t)a1, "\"accessMethod\":", v122, v123, v124, v125, v126, v127, v161);
    _outToken(a1, *(char **)(a2 + 88), v140, v141, v142, v143, v144, v145);
    result = appendStringInfo((uint64_t)a1, ",", v146, v147, v148, v149, v150, v151, v163);
  }
  if (*(_BYTE *)(a2 + 96))
    return appendStringInfo((uint64_t)a1, "\"if_not_exists\":%s,", v122, v123, v124, v125, v126, v127, (size_t)"true");
  return result;
}

unint64_t _outDefineStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  size_t v55;
  size_t v56;
  size_t v57;
  size_t v58;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0x31)
    v11 = 0;
  else
    v11 = (&off_1E264B228)[v10];
  result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_BYTE *)(a2 + 8))
    result = appendStringInfo(a1, "\"oldstyle\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"defnames\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    v25 = *(_QWORD *)(a2 + 16);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        v29 = *(_QWORD *)(v28 + 8 * v26);
        if (v29)
          _outNode(a1, v29);
        else
          appendStringInfoString(a1, "{}");
        if (v28 + v27)
          v30 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v30 = 1;
        if (!v30)
          appendStringInfoString(a1, ",");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v56);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"args\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    v37 = *(_QWORD *)(a2 + 24);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      v38 = 0;
      v39 = 8;
      do
      {
        v40 = *(_QWORD *)(v37 + 16);
        v41 = *(_QWORD *)(v40 + 8 * v38);
        if (v41)
          _outNode(a1, v41);
        else
          appendStringInfoString(a1, "{}");
        if (v40 + v39)
          v42 = v40 + v39 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v42 = 1;
        if (!v42)
          appendStringInfoString(a1, ",");
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v57);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"definition\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    v49 = *(_QWORD *)(a2 + 32);
    if (v49 && *(int *)(v49 + 4) >= 1)
    {
      v50 = 0;
      v51 = 8;
      do
      {
        v52 = *(_QWORD *)(v49 + 16);
        v53 = *(_QWORD *)(v52 + 8 * v50);
        if (v53)
          _outNode(a1, v53);
        else
          appendStringInfoString(a1, "{}");
        if (v52 + v51)
          v54 = v52 + v51 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v54 = 1;
        if (!v54)
          appendStringInfoString(a1, ",");
        ++v50;
        v51 += 8;
      }
      while (v50 < *(int *)(v49 + 4));
    }
    result = appendStringInfo(a1, "],", v43, v44, v45, v46, v47, v48, v58);
  }
  if (*(_BYTE *)(a2 + 40))
    result = appendStringInfo(a1, "\"if_not_exists\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_BYTE *)(a2 + 41))
    return appendStringInfo(a1, "\"replace\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

unint64_t _outDropStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  const char *v31;
  const char *v32;
  unint64_t result;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  size_t v41;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"objects\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar(a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString(a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v41);
  }
  v22 = *(int *)(a2 + 16);
  if (v22 > 0x31)
    v23 = 0;
  else
    v23 = (&off_1E264B228)[v22];
  appendStringInfo(a1, "\"removeType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  v30 = *(_DWORD *)(a2 + 20);
  v31 = "DROP_CASCADE";
  if (v30 != 1)
    v31 = 0;
  if (v30)
    v32 = v31;
  else
    v32 = "DROP_RESTRICT";
  result = appendStringInfo(a1, "\"behavior\":\"%s\",", v24, v25, v26, v27, v28, v29, (size_t)v32);
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfo(a1, "\"missing_ok\":%s,", v34, v35, v36, v37, v38, v39, (size_t)"true");
  if (*(_BYTE *)(a2 + 25))
    return appendStringInfo(a1, "\"concurrent\":%s,", v34, v35, v36, v37, v38, v39, (size_t)"true");
  return result;
}

unint64_t _outTruncateStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  int v22;
  const char *v23;
  const char *v24;
  size_t v26;
  size_t v27;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relations\":", a3, a4, a5, a6, a7, a8, v26);
    appendStringInfoChar(a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString(a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v27);
  }
  if (*(_BYTE *)(a2 + 16))
    appendStringInfo(a1, "\"restart_seqs\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  v22 = *(_DWORD *)(a2 + 20);
  v23 = "DROP_CASCADE";
  if (v22 != 1)
    v23 = 0;
  if (v22)
    v24 = v23;
  else
    v24 = "DROP_RESTRICT";
  return appendStringInfo(a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
}

unint64_t _outCommentStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  size_t v39;

  v11 = *(int *)(a2 + 4);
  if (v11 > 0x31)
    v12 = 0;
  else
    v12 = (&off_1E264B228)[v11];
  result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v14, v15, v16, v17, v18, v19, v38);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    result = appendStringInfo((uint64_t)a1, ",", v20, v21, v22, v23, v24, v25, v39);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"comment\":", v14, v15, v16, v17, v18, v19, v38);
    _outToken(a1, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    return appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, a9);
  }
  return result;
}

unint64_t _outFetchStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  size_t v32;

  v10 = *(int *)(a2 + 4);
  if (v10 > 3)
    v11 = 0;
  else
    v11 = (&off_1E264B080)[v10];
  result = appendStringInfo((uint64_t)a1, "\"direction\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
    result = appendStringInfo((uint64_t)a1, "\"howMany\":%ld,", v13, v14, v15, v16, v17, v18, *(_QWORD *)(a2 + 8));
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"portalname\":", v13, v14, v15, v16, v17, v18, v31);
    _outToken(a1, *(char **)(a2 + 16), v19, v20, v21, v22, v23, v24);
    result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v32);
  }
  if (*(_BYTE *)(a2 + 24))
    return appendStringInfo((uint64_t)a1, "\"ismove\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

uint64_t _outIndexStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  BOOL v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  BOOL v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  BOOL v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  BOOL v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  size_t v128;
  size_t v129;
  size_t v130;
  size_t v131;
  size_t v132;
  size_t v133;
  size_t v134;
  size_t v135;
  size_t v136;
  size_t v137;
  size_t v138;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"idxname\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v129);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"relation\":{", a3, a4, a5, a6, a7, a8, v128);
    _outRangeVar((uint64_t)v9, *(_QWORD *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    v34 = v9[2];
    v35 = __OFSUB__(v34, 1);
    v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      v37 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v36) == 44)
      {
        v9[2] = v36;
        *(_BYTE *)(v37 + v36) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v130);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"accessMethod\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 24), v38, v39, v40, v41, v42, v43);
    result = appendStringInfo((uint64_t)v9, ",", v44, v45, v46, v47, v48, v49, v131);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"tableSpace\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 32), v50, v51, v52, v53, v54, v55);
    result = appendStringInfo((uint64_t)v9, ",", v56, v57, v58, v59, v60, v61, v132);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"indexParams\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    v68 = *(_QWORD *)(a2 + 40);
    if (v68 && *(int *)(v68 + 4) >= 1)
    {
      v69 = 0;
      v70 = 8;
      do
      {
        v71 = *(_QWORD *)(v68 + 16);
        v72 = *(_QWORD *)(v71 + 8 * v69);
        if (v72)
          _outNode(v9, v72);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v71 + v70)
          v73 = v71 + v70 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v73 = 1;
        if (!v73)
          appendStringInfoString((uint64_t)v9, ",");
        ++v69;
        v70 += 8;
      }
      while (v69 < *(int *)(v68 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v62, v63, v64, v65, v66, v67, v133);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v9, "\"indexIncludingParams\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    v80 = *(_QWORD *)(a2 + 48);
    if (v80 && *(int *)(v80 + 4) >= 1)
    {
      v81 = 0;
      v82 = 8;
      do
      {
        v83 = *(_QWORD *)(v80 + 16);
        v84 = *(_QWORD *)(v83 + 8 * v81);
        if (v84)
          _outNode(v9, v84);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v83 + v82)
          v85 = v83 + v82 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v85 = 1;
        if (!v85)
          appendStringInfoString((uint64_t)v9, ",");
        ++v81;
        v82 += 8;
      }
      while (v81 < *(int *)(v80 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v74, v75, v76, v77, v78, v79, v134);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    v92 = *(_QWORD *)(a2 + 56);
    if (v92 && *(int *)(v92 + 4) >= 1)
    {
      v93 = 0;
      v94 = 8;
      do
      {
        v95 = *(_QWORD *)(v92 + 16);
        v96 = *(_QWORD *)(v95 + 8 * v93);
        if (v96)
          _outNode(v9, v96);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v95 + v94)
          v97 = v95 + v94 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v97 = 1;
        if (!v97)
          appendStringInfoString((uint64_t)v9, ",");
        ++v93;
        v94 += 8;
      }
      while (v93 < *(int *)(v92 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v86, v87, v88, v89, v90, v91, v135);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo((uint64_t)v9, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v128);
    _outNode(v9, *(_QWORD *)(a2 + 64));
    result = appendStringInfo((uint64_t)v9, ",", v98, v99, v100, v101, v102, v103, v136);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)v9, "\"excludeOpNames\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    v110 = *(_QWORD *)(a2 + 72);
    if (v110 && *(int *)(v110 + 4) >= 1)
    {
      v111 = 0;
      v112 = 8;
      do
      {
        v113 = *(_QWORD *)(v110 + 16);
        v114 = *(_QWORD *)(v113 + 8 * v111);
        if (v114)
          _outNode(v9, v114);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v113 + v112)
          v115 = v113 + v112 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v115 = 1;
        if (!v115)
          appendStringInfoString((uint64_t)v9, ",");
        ++v111;
        v112 += 8;
      }
      while (v111 < *(int *)(v110 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v104, v105, v106, v107, v108, v109, v137);
  }
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo((uint64_t)v9, "\"idxcomment\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 80), v116, v117, v118, v119, v120, v121);
    result = appendStringInfo((uint64_t)v9, ",", v122, v123, v124, v125, v126, v127, v138);
  }
  if (*(_DWORD *)(a2 + 88))
    result = appendStringInfo((uint64_t)v9, "\"indexOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 88));
  if (*(_DWORD *)(a2 + 92))
    result = appendStringInfo((uint64_t)v9, "\"oldNode\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 92));
  if (*(_DWORD *)(a2 + 96))
    result = appendStringInfo((uint64_t)v9, "\"oldCreateSubid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 96));
  if (*(_DWORD *)(a2 + 100))
    result = appendStringInfo((uint64_t)v9, "\"oldFirstRelfilenodeSubid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 100));
  if (*(_BYTE *)(a2 + 104))
    result = appendStringInfo((uint64_t)v9, "\"unique\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 105))
    result = appendStringInfo((uint64_t)v9, "\"primary\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 106))
    result = appendStringInfo((uint64_t)v9, "\"isconstraint\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 107))
    result = appendStringInfo((uint64_t)v9, "\"deferrable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 108))
    result = appendStringInfo((uint64_t)v9, "\"initdeferred\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 109))
    result = appendStringInfo((uint64_t)v9, "\"transformed\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 110))
    result = appendStringInfo((uint64_t)v9, "\"concurrent\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 111))
    result = appendStringInfo((uint64_t)v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 112))
    return appendStringInfo((uint64_t)v9, "\"reset_default_tblspc\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outCreateFunctionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  BOOL v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  size_t v63;
  size_t v64;
  size_t v65;
  size_t v66;

  v10 = result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"is_procedure\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 5))
    result = appendStringInfo(v10, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v10, "\"funcname\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v64);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"parameters\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar(v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString(v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString(v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    result = appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, v65);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v10, "\"returnType\":{", a3, a4, a5, a6, a7, a8, v63);
    _outTypeName(v10, *(_QWORD *)(a2 + 24), v35, v36, v37, v38, v39, v40);
    v47 = *(_DWORD *)(v10 + 8);
    v48 = __OFSUB__(v47, 1);
    v49 = (v47 - 1);
    if ((int)v49 < 0 == v48)
    {
      v50 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v49) == 44)
      {
        *(_DWORD *)(v10 + 8) = v49;
        *(_BYTE *)(v50 + v49) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v41, v42, v43, v44, v45, v46, v66);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar(v10, 91);
    v57 = *(_QWORD *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      v58 = 0;
      v59 = 8;
      do
      {
        v60 = *(_QWORD *)(v57 + 16);
        v61 = *(_QWORD *)(v60 + 8 * v58);
        if (v61)
          _outNode(v10, v61);
        else
          appendStringInfoString(v10, "{}");
        if (v60 + v59)
          v62 = v60 + v59 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v62 = 1;
        if (!v62)
          appendStringInfoString(v10, ",");
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    return appendStringInfo(v10, "],", v51, v52, v53, v54, v55, v56, a9);
  }
  return result;
}

unint64_t _outAlterFunctionStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  size_t v48;
  size_t v49;

  v11 = *(int *)(a2 + 4);
  if (v11 > 0x31)
    v12 = 0;
  else
    v12 = (&off_1E264B228)[v11];
  result = appendStringInfo(a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"func\":{", v14, v15, v16, v17, v18, v19, v48);
    _outObjectWithArgs(a1, *(_QWORD *)(a2 + 8), v20, v21, v22, v23, v24, v25);
    v32 = *(_DWORD *)(a1 + 8);
    v33 = __OFSUB__(v32, 1);
    v34 = (v32 - 1);
    if ((int)v34 < 0 == v33)
    {
      v35 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v34) == 44)
      {
        *(_DWORD *)(a1 + 8) = v34;
        *(_BYTE *)(v35 + v34) = 0;
      }
    }
    result = appendStringInfo(a1, "},", v26, v27, v28, v29, v30, v31, v49);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"actions\":", v14, v15, v16, v17, v18, v19, v48);
    appendStringInfoChar(a1, 91);
    v42 = *(_QWORD *)(a2 + 16);
    if (v42 && *(int *)(v42 + 4) >= 1)
    {
      v43 = 0;
      v44 = 8;
      do
      {
        v45 = *(_QWORD *)(v42 + 16);
        v46 = *(_QWORD *)(v45 + 8 * v43);
        if (v46)
          _outNode(a1, v46);
        else
          appendStringInfoString(a1, "{}");
        if (v45 + v44)
          v47 = v45 + v44 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v47 = 1;
        if (!v47)
          appendStringInfoString(a1, ",");
        ++v43;
        v44 += 8;
      }
      while (v43 < *(int *)(v42 + 4));
    }
    return appendStringInfo(a1, "],", v36, v37, v38, v39, v40, v41, a9);
  }
  return result;
}

unint64_t _outDoStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  size_t v23;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = result;
    appendStringInfo(result, "\"args\":", a3, a4, a5, a6, a7, a8, v23);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    return appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, a9);
  }
  return result;
}

unint64_t _outRenameStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  const char *v73;
  const char *v74;
  unint64_t result;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  size_t v82;
  size_t v83;
  size_t v84;
  size_t v85;
  size_t v86;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0x31)
    v11 = 0;
  else
    v11 = (&off_1E264B228)[v10];
  appendStringInfo((uint64_t)a1, "\"renameType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  v18 = *(int *)(a2 + 8);
  if (v18 > 0x31)
    v19 = 0;
  else
    v19 = (&off_1E264B228)[v18];
  appendStringInfo((uint64_t)a1, "\"relationType\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v20, v21, v22, v23, v24, v25, v82);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 16), v26, v27, v28, v29, v30, v31);
    v38 = a1[2];
    v39 = __OFSUB__(v38, 1);
    v40 = (v38 - 1);
    if ((int)v40 < 0 == v39)
    {
      v41 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v40) == 44)
      {
        a1[2] = v40;
        *(_BYTE *)(v41 + v40) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v32, v33, v34, v35, v36, v37, v83);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v20, v21, v22, v23, v24, v25, v82);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v42, v43, v44, v45, v46, v47, v84);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"subname\":", v20, v21, v22, v23, v24, v25, v82);
    _outToken(a1, *(char **)(a2 + 32), v48, v49, v50, v51, v52, v53);
    appendStringInfo((uint64_t)a1, ",", v54, v55, v56, v57, v58, v59, v85);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"newname\":", v20, v21, v22, v23, v24, v25, v82);
    _outToken(a1, *(char **)(a2 + 40), v60, v61, v62, v63, v64, v65);
    appendStringInfo((uint64_t)a1, ",", v66, v67, v68, v69, v70, v71, v86);
  }
  v72 = *(_DWORD *)(a2 + 48);
  v73 = "DROP_CASCADE";
  if (v72 != 1)
    v73 = 0;
  if (v72)
    v74 = v73;
  else
    v74 = "DROP_RESTRICT";
  result = appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", v20, v21, v22, v23, v24, v25, (size_t)v74);
  if (*(_BYTE *)(a2 + 52))
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v76, v77, v78, v79, v80, v81, (size_t)"true");
  return result;
}

unint64_t _outRuleStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  unint64_t result;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  BOOL v64;
  size_t v65;
  size_t v66;
  size_t v67;
  size_t v68;
  size_t v69;
  size_t v70;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v65);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = a1[2];
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v24) == 44)
      {
        a1[2] = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v16, v17, v18, v19, v20, v21, v66);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"rulename\":", a3, a4, a5, a6, a7, a8, v65);
    _outToken(a1, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, v67);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v65);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v38, v39, v40, v41, v42, v43, v68);
  }
  v44 = *(int *)(a2 + 32);
  if (v44 > 6)
    v45 = 0;
  else
    v45 = (&off_1E264B0A0)[v44];
  result = appendStringInfo((uint64_t)a1, "\"event\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v45);
  if (*(_BYTE *)(a2 + 36))
    result = appendStringInfo((uint64_t)a1, "\"instead\":%s,", v47, v48, v49, v50, v51, v52, (size_t)"true");
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"actions\":", v47, v48, v49, v50, v51, v52, v69);
    appendStringInfoChar((uint64_t)a1, 91);
    v59 = *(_QWORD *)(a2 + 40);
    if (v59 && *(int *)(v59 + 4) >= 1)
    {
      v60 = 0;
      v61 = 8;
      do
      {
        v62 = *(_QWORD *)(v59 + 16);
        v63 = *(_QWORD *)(v62 + 8 * v60);
        if (v63)
          _outNode(a1, v63);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v62 + v61)
          v64 = v62 + v61 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v64 = 1;
        if (!v64)
          appendStringInfoString((uint64_t)a1, ",");
        ++v60;
        v61 += 8;
      }
      while (v60 < *(int *)(v59 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v53, v54, v55, v56, v57, v58, v70);
  }
  if (*(_BYTE *)(a2 + 48))
    return appendStringInfo((uint64_t)a1, "\"replace\":%s,", v47, v48, v49, v50, v51, v52, (size_t)"true");
  return result;
}

uint64_t _outNotifyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"conditionname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"payload\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    return appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

unint64_t _outListenStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = (int *)result;
    appendStringInfo(result, "\"conditionname\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outTransactionStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  size_t v55;
  size_t v56;
  size_t v57;
  size_t v58;

  v10 = *(int *)(a2 + 4);
  if (v10 > 9)
    v11 = 0;
  else
    v11 = (&off_1E264B0D8)[v10];
  result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar((uint64_t)a1, 91);
    v25 = *(_QWORD *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        v29 = *(_QWORD *)(v28 + 8 * v26);
        if (v29)
          _outNode(a1, v29);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v28 + v27)
          v30 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v30 = 1;
        if (!v30)
          appendStringInfoString((uint64_t)a1, ",");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v19, v20, v21, v22, v23, v24, v56);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"savepoint_name\":", v13, v14, v15, v16, v17, v18, v55);
    _outToken(a1, *(char **)(a2 + 16), v31, v32, v33, v34, v35, v36);
    result = appendStringInfo((uint64_t)a1, ",", v37, v38, v39, v40, v41, v42, v57);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"gid\":", v13, v14, v15, v16, v17, v18, v55);
    _outToken(a1, *(char **)(a2 + 24), v43, v44, v45, v46, v47, v48);
    result = appendStringInfo((uint64_t)a1, ",", v49, v50, v51, v52, v53, v54, v58);
  }
  if (*(_BYTE *)(a2 + 32))
    return appendStringInfo((uint64_t)a1, "\"chain\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

unint64_t _outViewStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  char *v57;
  size_t v59;
  size_t v60;
  size_t v61;
  size_t v62;
  size_t v63;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"view\":{", a3, a4, a5, a6, a7, a8, v59);
    _outRangeVar(a1, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v60);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"aliases\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar(a1, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(a1, v36);
        else
          appendStringInfoString(a1, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString(a1, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v61);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"query\":", a3, a4, a5, a6, a7, a8, v59);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    appendStringInfo(a1, ",", v38, v39, v40, v41, v42, v43, v62);
  }
  if (*(_BYTE *)(a2 + 32))
    appendStringInfo(a1, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"options\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar(a1, 91);
    v50 = *(_QWORD *)(a2 + 40);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      v51 = 0;
      v52 = 8;
      do
      {
        v53 = *(_QWORD *)(v50 + 16);
        v54 = *(_QWORD *)(v53 + 8 * v51);
        if (v54)
          _outNode(a1, v54);
        else
          appendStringInfoString(a1, "{}");
        if (v53 + v52)
          v55 = v53 + v52 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v55 = 1;
        if (!v55)
          appendStringInfoString(a1, ",");
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v63);
  }
  v56 = *(int *)(a2 + 48);
  if (v56 > 2)
    v57 = 0;
  else
    v57 = (&off_1E264B128)[v56];
  return appendStringInfo(a1, "\"withCheckOption\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v57);
}

unint64_t _outLoadStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = (int *)result;
    appendStringInfo(result, "\"filename\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outCreateDomainStmt(uint64_t result, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  BOOL v65;
  size_t v66;
  size_t v67;
  size_t v68;
  size_t v69;

  v10 = result;
  if (a2[1])
  {
    appendStringInfo(result, "\"domainname\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    v17 = a2[1];
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(a2[1] + 16) + 8 * *(int *)(a2[1] + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v67);
  }
  if (a2[2])
  {
    appendStringInfo(v10, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v66);
    _outTypeName(v10, a2[2], v23, v24, v25, v26, v27, v28);
    v35 = *(_DWORD *)(v10 + 8);
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        *(_DWORD *)(v10 + 8) = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v29, v30, v31, v32, v33, v34, v68);
  }
  if (a2[3])
  {
    appendStringInfo(v10, "\"collClause\":{", a3, a4, a5, a6, a7, a8, v66);
    _outCollateClause(v10, a2[3], v39, v40, v41, v42, v43, v44);
    v51 = *(_DWORD *)(v10 + 8);
    v36 = __OFSUB__(v51, 1);
    v52 = (v51 - 1);
    if ((int)v52 < 0 == v36)
    {
      v53 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v52) == 44)
      {
        *(_DWORD *)(v10 + 8) = v52;
        *(_BYTE *)(v53 + v52) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v45, v46, v47, v48, v49, v50, v69);
  }
  if (a2[4])
  {
    appendStringInfo(v10, "\"constraints\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    v60 = a2[4];
    if (v60 && *(int *)(v60 + 4) >= 1)
    {
      v61 = 0;
      v62 = 8;
      do
      {
        v63 = *(_QWORD *)(v60 + 16);
        v64 = *(_QWORD *)(v63 + 8 * v61);
        if (v64)
          _outNode(v10, v64);
        else
          appendStringInfoString(v10, "{}");
        if (v63 + v62)
          v65 = v63 + v62 >= (unint64_t)(*(_QWORD *)(a2[4] + 16) + 8 * *(int *)(a2[4] + 4));
        else
          v65 = 1;
        if (!v65)
          appendStringInfoString(v10, ",");
        ++v61;
        v62 += 8;
      }
      while (v61 < *(int *)(v60 + 4));
    }
    return appendStringInfo(v10, "],", v54, v55, v56, v57, v58, v59, a9);
  }
  return result;
}

uint64_t _outCreatedbStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"dbname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outDropdbStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"dbname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfo((uint64_t)v10, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 24);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outVacuumStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  size_t v34;
  size_t v35;
  size_t v36;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"options\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v35);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"rels\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString(v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(_BYTE *)(a2 + 24))
    return appendStringInfo(v9, "\"is_vacuumcmd\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outExplainStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  size_t v29;
  size_t v30;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"query\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    v23 = *(_QWORD *)(a2 + 16);
    if (v23 && *(int *)(v23 + 4) >= 1)
    {
      v24 = 0;
      v25 = 8;
      do
      {
        v26 = *(_QWORD *)(v23 + 16);
        v27 = *(_QWORD *)(v26 + 8 * v24);
        if (v27)
          _outNode(v10, v27);
        else
          appendStringInfoString(v10, "{}");
        if (v26 + v25)
          v28 = v26 + v25 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v28 = 1;
        if (!v28)
          appendStringInfoString(v10, ",");
        ++v24;
        v25 += 8;
      }
      while (v24 < *(int *)(v23 + 4));
    }
    return appendStringInfo(v10, "],", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outCreateTableAsStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t result;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  size_t v41;
  size_t v42;
  size_t v43;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"query\":", a3, a4, a5, a6, a7, a8, v41);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo((uint64_t)a1, ",", v10, v11, v12, v13, v14, v15, v42);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"into\":{", a3, a4, a5, a6, a7, a8, v41);
    _outIntoClause(a1, *(_QWORD *)(a2 + 16), v16, v17, v18, v19, v20, v21);
    v28 = a1[2];
    v29 = __OFSUB__(v28, 1);
    v30 = (v28 - 1);
    if ((int)v30 < 0 == v29)
    {
      v31 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v30) == 44)
      {
        a1[2] = v30;
        *(_BYTE *)(v31 + v30) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v22, v23, v24, v25, v26, v27, v43);
  }
  v32 = *(int *)(a2 + 24);
  if (v32 > 0x31)
    v33 = 0;
  else
    v33 = (&off_1E264B228)[v32];
  result = appendStringInfo((uint64_t)a1, "\"relkind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v33);
  if (*(_BYTE *)(a2 + 28))
    result = appendStringInfo((uint64_t)a1, "\"is_select_into\":%s,", v35, v36, v37, v38, v39, v40, (size_t)"true");
  if (*(_BYTE *)(a2 + 29))
    return appendStringInfo((uint64_t)a1, "\"if_not_exists\":%s,", v35, v36, v37, v38, v39, v40, (size_t)"true");
  return result;
}

uint64_t _outCreateSeqStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  size_t v38;
  size_t v39;
  size_t v40;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"sequence\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRangeVar(v9, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = *(_DWORD *)(v9 + 8);
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v24) == 44)
      {
        *(_DWORD *)(v9 + 8) = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    result = appendStringInfo(v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"options\":", a3, a4, a5, a6, a7, a8, v38);
    appendStringInfoChar(v9, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(v9, v36);
        else
          appendStringInfoString(v9, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString(v9, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    result = appendStringInfo(v9, "],", v26, v27, v28, v29, v30, v31, v40);
  }
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo(v9, "\"ownerId\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  if (*(_BYTE *)(a2 + 28))
    result = appendStringInfo(v9, "\"for_identity\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 29))
    return appendStringInfo(v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outAlterSeqStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  size_t v38;
  size_t v39;
  size_t v40;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"sequence\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRangeVar(v9, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = *(_DWORD *)(v9 + 8);
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v24) == 44)
      {
        *(_DWORD *)(v9 + 8) = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    result = appendStringInfo(v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"options\":", a3, a4, a5, a6, a7, a8, v38);
    appendStringInfoChar(v9, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(v9, v36);
        else
          appendStringInfoString(v9, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString(v9, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    result = appendStringInfo(v9, "],", v26, v27, v28, v29, v30, v31, v40);
  }
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfo(v9, "\"for_identity\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 25))
    return appendStringInfo(v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outVariableSetStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  size_t v43;
  size_t v44;
  size_t v45;

  v10 = *(int *)(a2 + 4);
  if (v10 > 5)
    v11 = 0;
  else
    v11 = (&off_1E264B140)[v10];
  result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v13, v14, v15, v16, v17, v18, v43);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v44);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"args\":", v13, v14, v15, v16, v17, v18, v43);
    appendStringInfoChar((uint64_t)a1, 91);
    v37 = *(_QWORD *)(a2 + 16);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      v38 = 0;
      v39 = 8;
      do
      {
        v40 = *(_QWORD *)(v37 + 16);
        v41 = *(_QWORD *)(v40 + 8 * v38);
        if (v41)
          _outNode(a1, v41);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v40 + v39)
          v42 = v40 + v39 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v42 = 1;
        if (!v42)
          appendStringInfoString((uint64_t)a1, ",");
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v31, v32, v33, v34, v35, v36, v45);
  }
  if (*(_BYTE *)(a2 + 24))
    return appendStringInfo((uint64_t)a1, "\"is_local\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

unint64_t _outVariableShowStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = (int *)result;
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outDiscardStmt(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;

  if (a2 > 3)
    v8 = 0;
  else
    v8 = (&off_1E264B170)[a2];
  return appendStringInfo(a1, "\"target\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v8);
}

uint64_t _outCreateTrigStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  BOOL v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  size_t v108;
  size_t v109;
  size_t v110;
  size_t v111;
  size_t v112;
  size_t v113;
  size_t v114;
  size_t v115;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"trigname\":", a3, a4, a5, a6, a7, a8, v108);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v109);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"relation\":{", a3, a4, a5, a6, a7, a8, v108);
    _outRangeVar((uint64_t)v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = v10[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        v10[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v110);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"funcname\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    v45 = *(_QWORD *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      v46 = 0;
      v47 = 8;
      do
      {
        v48 = *(_QWORD *)(v45 + 16);
        v49 = *(_QWORD *)(v48 + 8 * v46);
        if (v49)
          _outNode(v10, v49);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v48 + v47)
          v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v50 = 1;
        if (!v50)
          appendStringInfoString((uint64_t)v10, ",");
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, v111);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"args\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    v57 = *(_QWORD *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      v58 = 0;
      v59 = 8;
      do
      {
        v60 = *(_QWORD *)(v57 + 16);
        v61 = *(_QWORD *)(v60 + 8 * v58);
        if (v61)
          _outNode(v10, v61);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v60 + v59)
          v62 = v60 + v59 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v62 = 1;
        if (!v62)
          appendStringInfoString((uint64_t)v10, ",");
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v51, v52, v53, v54, v55, v56, v112);
  }
  if (*(_BYTE *)(a2 + 40))
    result = appendStringInfo((uint64_t)v10, "\"row\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_WORD *)(a2 + 42))
    result = appendStringInfo((uint64_t)v10, "\"timing\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 42));
  if (*(_WORD *)(a2 + 44))
    result = appendStringInfo((uint64_t)v10, "\"events\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 44));
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"columns\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    v69 = *(_QWORD *)(a2 + 48);
    if (v69 && *(int *)(v69 + 4) >= 1)
    {
      v70 = 0;
      v71 = 8;
      do
      {
        v72 = *(_QWORD *)(v69 + 16);
        v73 = *(_QWORD *)(v72 + 8 * v70);
        if (v73)
          _outNode(v10, v73);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v72 + v71)
          v74 = v72 + v71 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v74 = 1;
        if (!v74)
          appendStringInfoString((uint64_t)v10, ",");
        ++v70;
        v71 += 8;
      }
      while (v70 < *(int *)(v69 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v63, v64, v65, v66, v67, v68, v113);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v10, "\"whenClause\":", a3, a4, a5, a6, a7, a8, v108);
    _outNode(v10, *(_QWORD *)(a2 + 56));
    result = appendStringInfo((uint64_t)v10, ",", v75, v76, v77, v78, v79, v80, v114);
  }
  if (*(_BYTE *)(a2 + 64))
    result = appendStringInfo((uint64_t)v10, "\"isconstraint\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)v10, "\"transitionRels\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    v87 = *(_QWORD *)(a2 + 72);
    if (v87 && *(int *)(v87 + 4) >= 1)
    {
      v88 = 0;
      v89 = 8;
      do
      {
        v90 = *(_QWORD *)(v87 + 16);
        v91 = *(_QWORD *)(v90 + 8 * v88);
        if (v91)
          _outNode(v10, v91);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v90 + v89)
          v92 = v90 + v89 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v92 = 1;
        if (!v92)
          appendStringInfoString((uint64_t)v10, ",");
        ++v88;
        v89 += 8;
      }
      while (v88 < *(int *)(v87 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v81, v82, v83, v84, v85, v86, v115);
  }
  if (*(_BYTE *)(a2 + 80))
    result = appendStringInfo((uint64_t)v10, "\"deferrable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 81))
    result = appendStringInfo((uint64_t)v10, "\"initdeferred\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 88))
  {
    appendStringInfo((uint64_t)v10, "\"constrrel\":{", a3, a4, a5, a6, a7, a8, v108);
    _outRangeVar((uint64_t)v10, *(_QWORD *)(a2 + 88), v93, v94, v95, v96, v97, v98);
    v105 = v10[2];
    v36 = __OFSUB__(v105, 1);
    v106 = (v105 - 1);
    if ((int)v106 < 0 == v36)
    {
      v107 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v106) == 44)
      {
        v10[2] = v106;
        *(_BYTE *)(v107 + v106) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v99, v100, v101, v102, v103, v104, a9);
  }
  return result;
}

uint64_t _outCreatePLangStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  size_t v58;
  size_t v59;
  size_t v60;
  size_t v61;
  size_t v62;

  v9 = (int *)result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v9, "\"plname\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v59);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"plhandler\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v60);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"plinline\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString((uint64_t)v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v61);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"plvalidator\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    v52 = *(_QWORD *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(v9, v56);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString((uint64_t)v9, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v62);
  }
  if (*(_BYTE *)(a2 + 40))
    return appendStringInfo((uint64_t)v9, "\"pltrusted\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outCreateRoleStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  size_t v44;
  size_t v45;

  v11 = *(int *)(a2 + 4);
  if (v11 > 2)
    v12 = 0;
  else
    v12 = (&off_1E264B190)[v11];
  result = appendStringInfo((uint64_t)a1, "\"stmt_type\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"role\":", v14, v15, v16, v17, v18, v19, v44);
    _outToken(a1, *(char **)(a2 + 8), v20, v21, v22, v23, v24, v25);
    result = appendStringInfo((uint64_t)a1, ",", v26, v27, v28, v29, v30, v31, v45);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v14, v15, v16, v17, v18, v19, v44);
    appendStringInfoChar((uint64_t)a1, 91);
    v38 = *(_QWORD *)(a2 + 16);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      v39 = 0;
      v40 = 8;
      do
      {
        v41 = *(_QWORD *)(v38 + 16);
        v42 = *(_QWORD *)(v41 + 8 * v39);
        if (v42)
          _outNode(a1, v42);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v41 + v40)
          v43 = v41 + v40 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v43 = 1;
        if (!v43)
          appendStringInfoString((uint64_t)a1, ",");
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v32, v33, v34, v35, v36, v37, a9);
  }
  return result;
}

uint64_t _outAlterRoleStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  size_t v38;
  size_t v39;
  size_t v40;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"role\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRoleSpec(v9, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = v9[2];
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v24) == 44)
      {
        v9[2] = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v38);
    appendStringInfoChar((uint64_t)v9, 91);
    v32 = *(_QWORD *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      v33 = 0;
      v34 = 8;
      do
      {
        v35 = *(_QWORD *)(v32 + 16);
        v36 = *(_QWORD *)(v35 + 8 * v33);
        if (v36)
          _outNode(v9, v36);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v35 + v34)
          v37 = v35 + v34 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v37 = 1;
        if (!v37)
          appendStringInfoString((uint64_t)v9, ",");
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v26, v27, v28, v29, v30, v31, v40);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo((uint64_t)v9, "\"action\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outDropRoleStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"roles\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_BYTE *)(a2 + 16))
    return appendStringInfo(v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outLockStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"relations\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"mode\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_BYTE *)(a2 + 20))
    return appendStringInfo(v9, "\"nowait\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outConstraintsSetStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"constraints\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_BYTE *)(a2 + 16))
    return appendStringInfo(v9, "\"deferred\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outReindexStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v10 = *(int *)(a2 + 4);
  if (v10 > 4)
    v11 = 0;
  else
    v11 = (&off_1E264B1A8)[v10];
  result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v13, v14, v15, v16, v17, v18, v47);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    v31 = a1[2];
    v32 = __OFSUB__(v31, 1);
    v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      v34 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v33) == 44)
      {
        a1[2] = v33;
        *(_BYTE *)(v34 + v33) = 0;
      }
    }
    result = appendStringInfo((uint64_t)a1, "},", v25, v26, v27, v28, v29, v30, v48);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v13, v14, v15, v16, v17, v18, v47);
    _outToken(a1, *(char **)(a2 + 16), v35, v36, v37, v38, v39, v40);
    result = appendStringInfo((uint64_t)a1, ",", v41, v42, v43, v44, v45, v46, v49);
  }
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo((uint64_t)a1, "\"options\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 24));
  if (*(_BYTE *)(a2 + 28))
    return appendStringInfo((uint64_t)a1, "\"concurrent\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

uint64_t _outCreateSchemaStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  size_t v50;
  size_t v51;
  size_t v52;
  size_t v53;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"schemaname\":", a3, a4, a5, a6, a7, a8, v50);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v51);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"authrole\":{", a3, a4, a5, a6, a7, a8, v50);
    _outRoleSpec(v9, *(_QWORD *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    v34 = v9[2];
    v35 = __OFSUB__(v34, 1);
    v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      v37 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v36) == 44)
      {
        v9[2] = v36;
        *(_BYTE *)(v37 + v36) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v52);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"schemaElts\":", a3, a4, a5, a6, a7, a8, v50);
    appendStringInfoChar((uint64_t)v9, 91);
    v44 = *(_QWORD *)(a2 + 24);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      v45 = 0;
      v46 = 8;
      do
      {
        v47 = *(_QWORD *)(v44 + 16);
        v48 = *(_QWORD *)(v47 + 8 * v45);
        if (v48)
          _outNode(v9, v48);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v47 + v46)
          v49 = v47 + v46 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v49 = 1;
        if (!v49)
          appendStringInfoString((uint64_t)v9, ",");
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v38, v39, v40, v41, v42, v43, v53);
  }
  if (*(_BYTE *)(a2 + 32))
    return appendStringInfo((uint64_t)v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outAlterDatabaseSetStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  size_t v39;
  size_t v40;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"dbname\":", a3, a4, a5, a6, a7, a8, v39);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"setstmt\":{", a3, a4, a5, a6, a7, a8, v39);
    _outVariableSetStmt(v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = v10[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        v10[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

uint64_t _outAlterRoleSetStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  size_t v54;
  size_t v55;
  size_t v56;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"role\":{", a3, a4, a5, a6, a7, a8, v54);
    _outRoleSpec(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = v10[2];
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        v10[2] = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v55);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"database\":", a3, a4, a5, a6, a7, a8, v54);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v56);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"setstmt\":{", a3, a4, a5, a6, a7, a8, v54);
    _outVariableSetStmt(v10, *(_QWORD *)(a2 + 24), v39, v40, v41, v42, v43, v44);
    v51 = v10[2];
    v24 = __OFSUB__(v51, 1);
    v52 = (v51 - 1);
    if ((int)v52 < 0 == v24)
    {
      v53 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v52) == 44)
      {
        v10[2] = v52;
        *(_BYTE *)(v53 + v52) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v45, v46, v47, v48, v49, v50, a9);
  }
  return result;
}

uint64_t _outCreateConversionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  size_t v58;
  size_t v59;
  size_t v60;
  size_t v61;
  size_t v62;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"conversion_name\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString((uint64_t)v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v59);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"for_encoding_name\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v60);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"to_encoding_name\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v61);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"func_name\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    v52 = *(_QWORD *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(v9, v56);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString((uint64_t)v9, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v62);
  }
  if (*(_BYTE *)(a2 + 40))
    return appendStringInfo((uint64_t)v9, "\"def\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outCreateCastStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  unint64_t result;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  size_t v66;
  size_t v67;
  size_t v68;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"sourcetype\":{", a3, a4, a5, a6, a7, a8, v65);
    _outTypeName(a1, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v66);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"targettype\":{", a3, a4, a5, a6, a7, a8, v65);
    _outTypeName(a1, *(_QWORD *)(a2 + 16), v26, v27, v28, v29, v30, v31);
    v38 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v38, 1);
    v39 = (v38 - 1);
    if ((int)v39 < 0 == v23)
    {
      v40 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v39) == 44)
      {
        *(_DWORD *)(a1 + 8) = v39;
        *(_BYTE *)(v40 + v39) = 0;
      }
    }
    appendStringInfo(a1, "},", v32, v33, v34, v35, v36, v37, v67);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"func\":{", a3, a4, a5, a6, a7, a8, v65);
    _outObjectWithArgs(a1, *(_QWORD *)(a2 + 24), v41, v42, v43, v44, v45, v46);
    v53 = *(_DWORD *)(a1 + 8);
    v23 = __OFSUB__(v53, 1);
    v54 = (v53 - 1);
    if ((int)v54 < 0 == v23)
    {
      v55 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v54) == 44)
      {
        *(_DWORD *)(a1 + 8) = v54;
        *(_BYTE *)(v55 + v54) = 0;
      }
    }
    appendStringInfo(a1, "},", v47, v48, v49, v50, v51, v52, v68);
  }
  v56 = *(int *)(a2 + 32);
  if (v56 > 2)
    v57 = 0;
  else
    v57 = (&off_1E264B1D0)[v56];
  result = appendStringInfo(a1, "\"context\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v57);
  if (*(_BYTE *)(a2 + 36))
    return appendStringInfo(a1, "\"inout\":%s,", v59, v60, v61, v62, v63, v64, (size_t)"true");
  return result;
}

uint64_t _outCreateOpClassStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  BOOL v73;
  size_t v74;
  size_t v75;
  size_t v76;
  size_t v77;
  size_t v78;
  size_t v79;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"opclassname\":", a3, a4, a5, a6, a7, a8, v74);
    appendStringInfoChar((uint64_t)v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString((uint64_t)v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v75);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"opfamilyname\":", a3, a4, a5, a6, a7, a8, v74);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v76);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"amname\":", a3, a4, a5, a6, a7, a8, v74);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v77);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"datatype\":{", a3, a4, a5, a6, a7, a8, v74);
    _outTypeName((uint64_t)v9, *(_QWORD *)(a2 + 32), v46, v47, v48, v49, v50, v51);
    v58 = v9[2];
    v59 = __OFSUB__(v58, 1);
    v60 = (v58 - 1);
    if ((int)v60 < 0 == v59)
    {
      v61 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v60) == 44)
      {
        v9[2] = v60;
        *(_BYTE *)(v61 + v60) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v52, v53, v54, v55, v56, v57, v78);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"items\":", a3, a4, a5, a6, a7, a8, v74);
    appendStringInfoChar((uint64_t)v9, 91);
    v68 = *(_QWORD *)(a2 + 40);
    if (v68 && *(int *)(v68 + 4) >= 1)
    {
      v69 = 0;
      v70 = 8;
      do
      {
        v71 = *(_QWORD *)(v68 + 16);
        v72 = *(_QWORD *)(v71 + 8 * v69);
        if (v72)
          _outNode(v9, v72);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v71 + v70)
          v73 = v71 + v70 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v73 = 1;
        if (!v73)
          appendStringInfoString((uint64_t)v9, ",");
        ++v69;
        v70 += 8;
      }
      while (v69 < *(int *)(v68 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v62, v63, v64, v65, v66, v67, v79);
  }
  if (*(_BYTE *)(a2 + 48))
    return appendStringInfo((uint64_t)v9, "\"isDefault\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outCreateOpFamilyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"opfamilyname\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString((uint64_t)v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"amname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    return appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

uint64_t _outAlterOpFamilyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"opfamilyname\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString((uint64_t)v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v11, v12, v13, v14, v15, v16, v48);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"amname\":", a3, a4, a5, a6, a7, a8, v47);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v49);
  }
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfo((uint64_t)v10, "\"isDrop\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"items\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    v41 = *(_QWORD *)(a2 + 32);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      v42 = 0;
      v43 = 8;
      do
      {
        v44 = *(_QWORD *)(v41 + 16);
        v45 = *(_QWORD *)(v44 + 8 * v42);
        if (v45)
          _outNode(v10, v45);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v44 + v43)
          v46 = v44 + v43 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v46 = 1;
        if (!v46)
          appendStringInfoString((uint64_t)v10, ",");
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, a9);
  }
  return result;
}

uint64_t _outPrepareStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  size_t v41;
  size_t v42;
  size_t v43;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v41);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v42);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"argtypes\":", a3, a4, a5, a6, a7, a8, v41);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, v43);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"query\":", a3, a4, a5, a6, a7, a8, v41);
    _outNode(v10, *(_QWORD *)(a2 + 24));
    return appendStringInfo((uint64_t)v10, ",", v35, v36, v37, v38, v39, v40, a9);
  }
  return result;
}

uint64_t _outExecuteStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"params\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outDeclareCursorStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  size_t v30;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"portalname\":", a3, a4, a5, a6, a7, a8, v29);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v30);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo((uint64_t)v10, "\"options\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"query\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(_QWORD *)(a2 + 24));
    return appendStringInfo((uint64_t)v10, ",", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outCreateTableSpaceStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  size_t v63;
  size_t v64;
  size_t v65;
  size_t v66;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"tablespacename\":", a3, a4, a5, a6, a7, a8, v63);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v64);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"owner\":{", a3, a4, a5, a6, a7, a8, v63);
    _outRoleSpec(v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = v10[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        v10[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v65);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"location\":", a3, a4, a5, a6, a7, a8, v63);
    _outToken(v10, *(char **)(a2 + 24), v39, v40, v41, v42, v43, v44);
    result = appendStringInfo((uint64_t)v10, ",", v45, v46, v47, v48, v49, v50, v66);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar((uint64_t)v10, 91);
    v57 = *(_QWORD *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      v58 = 0;
      v59 = 8;
      do
      {
        v60 = *(_QWORD *)(v57 + 16);
        v61 = *(_QWORD *)(v60 + 8 * v58);
        if (v61)
          _outNode(v10, v61);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v60 + v59)
          v62 = v60 + v59 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v62 = 1;
        if (!v62)
          appendStringInfoString((uint64_t)v10, ",");
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v51, v52, v53, v54, v55, v56, a9);
  }
  return result;
}

uint64_t _outDropTableSpaceStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  size_t v23;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"tablespacename\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(_BYTE *)(a2 + 16))
    return appendStringInfo((uint64_t)v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outAlterObjectDependsStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t v47;
  size_t v48;
  size_t v49;
  size_t v50;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0x31)
    v11 = 0;
  else
    v11 = (&off_1E264B228)[v10];
  result = appendStringInfo(a1, "\"objectType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relation\":{", v13, v14, v15, v16, v17, v18, v47);
    _outRangeVar(a1, *(_QWORD *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    v31 = *(_DWORD *)(a1 + 8);
    v32 = __OFSUB__(v31, 1);
    v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      v34 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v33) == 44)
      {
        *(_DWORD *)(a1 + 8) = v33;
        *(_BYTE *)(v34 + v33) = 0;
      }
    }
    result = appendStringInfo(a1, "},", v25, v26, v27, v28, v29, v30, v48);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"object\":", v13, v14, v15, v16, v17, v18, v47);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(a1, ",", v35, v36, v37, v38, v39, v40, v49);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"extname\":", v13, v14, v15, v16, v17, v18, v47);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    result = appendStringInfo(a1, ",", v41, v42, v43, v44, v45, v46, v50);
  }
  if (*(_BYTE *)(a2 + 32))
    return appendStringInfo(a1, "\"remove\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

unint64_t _outAlterObjectSchemaStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t v53;
  size_t v54;
  size_t v55;
  size_t v56;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0x31)
    v11 = 0;
  else
    v11 = (&off_1E264B228)[v10];
  result = appendStringInfo((uint64_t)a1, "\"objectType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v13, v14, v15, v16, v17, v18, v53);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    v31 = a1[2];
    v32 = __OFSUB__(v31, 1);
    v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      v34 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v33) == 44)
      {
        a1[2] = v33;
        *(_BYTE *)(v34 + v33) = 0;
      }
    }
    result = appendStringInfo((uint64_t)a1, "},", v25, v26, v27, v28, v29, v30, v54);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v13, v14, v15, v16, v17, v18, v53);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo((uint64_t)a1, ",", v35, v36, v37, v38, v39, v40, v55);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"newschema\":", v13, v14, v15, v16, v17, v18, v53);
    _outToken(a1, *(char **)(a2 + 24), v41, v42, v43, v44, v45, v46);
    result = appendStringInfo((uint64_t)a1, ",", v47, v48, v49, v50, v51, v52, v56);
  }
  if (*(_BYTE *)(a2 + 32))
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

unint64_t _outAlterOwnerStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  size_t v57;
  size_t v58;
  size_t v59;

  v11 = *(int *)(a2 + 4);
  if (v11 > 0x31)
    v12 = 0;
  else
    v12 = (&off_1E264B228)[v11];
  result = appendStringInfo((uint64_t)a1, "\"objectType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v14, v15, v16, v17, v18, v19, v57);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 8), v20, v21, v22, v23, v24, v25);
    v32 = a1[2];
    v33 = __OFSUB__(v32, 1);
    v34 = (v32 - 1);
    if ((int)v34 < 0 == v33)
    {
      v35 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v34) == 44)
      {
        a1[2] = v34;
        *(_BYTE *)(v35 + v34) = 0;
      }
    }
    result = appendStringInfo((uint64_t)a1, "},", v26, v27, v28, v29, v30, v31, v58);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v14, v15, v16, v17, v18, v19, v57);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo((uint64_t)a1, ",", v36, v37, v38, v39, v40, v41, v59);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"newowner\":{", v14, v15, v16, v17, v18, v19, v57);
    _outRoleSpec(a1, *(_QWORD *)(a2 + 24), v42, v43, v44, v45, v46, v47);
    v54 = a1[2];
    v33 = __OFSUB__(v54, 1);
    v55 = (v54 - 1);
    if ((int)v55 < 0 == v33)
    {
      v56 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v55) == 44)
      {
        a1[2] = v55;
        *(_BYTE *)(v56 + v55) = 0;
      }
    }
    return appendStringInfo((uint64_t)a1, "},", v48, v49, v50, v51, v52, v53, a9);
  }
  return result;
}

uint64_t _outAlterOperatorStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  size_t v39;
  size_t v40;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"opername\":{", a3, a4, a5, a6, a7, a8, v39);
    _outObjectWithArgs(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    v33 = *(_QWORD *)(a2 + 16);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      v34 = 0;
      v35 = 8;
      do
      {
        v36 = *(_QWORD *)(v33 + 16);
        v37 = *(_QWORD *)(v36 + 8 * v34);
        if (v37)
          _outNode(v10, v37);
        else
          appendStringInfoString(v10, "{}");
        if (v36 + v35)
          v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v38 = 1;
        if (!v38)
          appendStringInfoString(v10, ",");
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    return appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, a9);
  }
  return result;
}

uint64_t _outAlterTypeStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString(v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString(v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outDropOwnedStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  int v22;
  const char *v23;
  const char *v24;
  size_t v26;
  size_t v27;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"roles\":", a3, a4, a5, a6, a7, a8, v26);
    appendStringInfoChar(a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString(a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v27);
  }
  v22 = *(_DWORD *)(a2 + 16);
  v23 = "DROP_CASCADE";
  if (v22 != 1)
    v23 = 0;
  if (v22)
    v24 = v23;
  else
    v24 = "DROP_RESTRICT";
  return appendStringInfo(a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
}

uint64_t _outReassignOwnedStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  size_t v39;
  size_t v40;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"roles\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar((uint64_t)v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString((uint64_t)v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v11, v12, v13, v14, v15, v16, v40);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"newrole\":{", a3, a4, a5, a6, a7, a8, v39);
    _outRoleSpec(v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = v10[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        v10[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

uint64_t _outCompositeTypeStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  size_t v39;
  size_t v40;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"typevar\":{", a3, a4, a5, a6, a7, a8, v39);
    _outRangeVar(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"coldeflist\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    v33 = *(_QWORD *)(a2 + 16);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      v34 = 0;
      v35 = 8;
      do
      {
        v36 = *(_QWORD *)(v33 + 16);
        v37 = *(_QWORD *)(v36 + 8 * v34);
        if (v37)
          _outNode(v10, v37);
        else
          appendStringInfoString(v10, "{}");
        if (v36 + v35)
          v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v38 = 1;
        if (!v38)
          appendStringInfoString(v10, ",");
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    return appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, a9);
  }
  return result;
}

uint64_t _outCreateEnumStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"vals\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString(v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString(v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outCreateRangeStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"params\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString(v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString(v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outAlterEnumStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  size_t v58;
  size_t v59;
  size_t v60;
  size_t v61;
  size_t v62;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString((uint64_t)v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v59);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"oldVal\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v60);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"newVal\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v61);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"newValNeighbor\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 32), v46, v47, v48, v49, v50, v51);
    result = appendStringInfo((uint64_t)v9, ",", v52, v53, v54, v55, v56, v57, v62);
  }
  if (*(_BYTE *)(a2 + 40))
    result = appendStringInfo((uint64_t)v9, "\"newValIsAfter\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 41))
    return appendStringInfo((uint64_t)v9, "\"skipIfNewValExists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outAlterTSDictionaryStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"dictname\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString(v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString(v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outAlterTSConfigurationStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  size_t v55;
  size_t v56;
  size_t v57;
  size_t v58;

  v10 = *(int *)(a2 + 4);
  if (v10 > 4)
    v11 = 0;
  else
    v11 = (&off_1E264B1E8)[v10];
  result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"cfgname\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    v25 = *(_QWORD *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        v29 = *(_QWORD *)(v28 + 8 * v26);
        if (v29)
          _outNode(a1, v29);
        else
          appendStringInfoString(a1, "{}");
        if (v28 + v27)
          v30 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v30 = 1;
        if (!v30)
          appendStringInfoString(a1, ",");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v56);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"tokentype\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    v37 = *(_QWORD *)(a2 + 16);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      v38 = 0;
      v39 = 8;
      do
      {
        v40 = *(_QWORD *)(v37 + 16);
        v41 = *(_QWORD *)(v40 + 8 * v38);
        if (v41)
          _outNode(a1, v41);
        else
          appendStringInfoString(a1, "{}");
        if (v40 + v39)
          v42 = v40 + v39 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v42 = 1;
        if (!v42)
          appendStringInfoString(a1, ",");
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v57);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"dicts\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    v49 = *(_QWORD *)(a2 + 24);
    if (v49 && *(int *)(v49 + 4) >= 1)
    {
      v50 = 0;
      v51 = 8;
      do
      {
        v52 = *(_QWORD *)(v49 + 16);
        v53 = *(_QWORD *)(v52 + 8 * v50);
        if (v53)
          _outNode(a1, v53);
        else
          appendStringInfoString(a1, "{}");
        if (v52 + v51)
          v54 = v52 + v51 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v54 = 1;
        if (!v54)
          appendStringInfoString(a1, ",");
        ++v50;
        v51 += 8;
      }
      while (v50 < *(int *)(v49 + 4));
    }
    result = appendStringInfo(a1, "],", v43, v44, v45, v46, v47, v48, v58);
  }
  if (*(_BYTE *)(a2 + 32))
    result = appendStringInfo(a1, "\"override\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_BYTE *)(a2 + 33))
    result = appendStringInfo(a1, "\"replace\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_BYTE *)(a2 + 34))
    return appendStringInfo(a1, "\"missing_ok\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

uint64_t _outCreateFdwStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"fdwname\":", a3, a4, a5, a6, a7, a8, v47);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v48);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"func_options\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, v49);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    v41 = *(_QWORD *)(a2 + 24);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      v42 = 0;
      v43 = 8;
      do
      {
        v44 = *(_QWORD *)(v41 + 16);
        v45 = *(_QWORD *)(v44 + 8 * v42);
        if (v45)
          _outNode(v10, v45);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v44 + v43)
          v46 = v44 + v43 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v46 = 1;
        if (!v46)
          appendStringInfoString((uint64_t)v10, ",");
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, a9);
  }
  return result;
}

uint64_t _outCreateForeignServerStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  BOOL v70;
  size_t v71;
  size_t v72;
  size_t v73;
  size_t v74;
  size_t v75;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"servername\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v72);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"servertype\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v73);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"version\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 24), v35, v36, v37, v38, v39, v40);
    result = appendStringInfo((uint64_t)v10, ",", v41, v42, v43, v44, v45, v46, v74);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"fdwname\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 32), v47, v48, v49, v50, v51, v52);
    result = appendStringInfo((uint64_t)v10, ",", v53, v54, v55, v56, v57, v58, v75);
  }
  if (*(_BYTE *)(a2 + 40))
    result = appendStringInfo((uint64_t)v10, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v71);
    appendStringInfoChar((uint64_t)v10, 91);
    v65 = *(_QWORD *)(a2 + 48);
    if (v65 && *(int *)(v65 + 4) >= 1)
    {
      v66 = 0;
      v67 = 8;
      do
      {
        v68 = *(_QWORD *)(v65 + 16);
        v69 = *(_QWORD *)(v68 + 8 * v66);
        if (v69)
          _outNode(v10, v69);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v68 + v67)
          v70 = v68 + v67 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v70 = 1;
        if (!v70)
          appendStringInfoString((uint64_t)v10, ",");
        ++v66;
        v67 += 8;
      }
      while (v66 < *(int *)(v65 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v59, v60, v61, v62, v63, v64, a9);
  }
  return result;
}

uint64_t _outAlterForeignServerStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  size_t v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"servername\":", a3, a4, a5, a6, a7, a8, v46);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v47);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"version\":", a3, a4, a5, a6, a7, a8, v46);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v48);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar((uint64_t)v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString((uint64_t)v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_BYTE *)(a2 + 32))
    return appendStringInfo((uint64_t)v9, "\"has_version\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outCreateUserMappingStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  size_t v51;
  size_t v52;
  size_t v53;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"user\":{", a3, a4, a5, a6, a7, a8, v51);
    _outRoleSpec(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = v10[2];
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        v10[2] = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v52);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"servername\":", a3, a4, a5, a6, a7, a8, v51);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v53);
  }
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfo((uint64_t)v10, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar((uint64_t)v10, 91);
    v45 = *(_QWORD *)(a2 + 32);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      v46 = 0;
      v47 = 8;
      do
      {
        v48 = *(_QWORD *)(v45 + 16);
        v49 = *(_QWORD *)(v48 + 8 * v46);
        if (v49)
          _outNode(v10, v49);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v48 + v47)
          v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v50 = 1;
        if (!v50)
          appendStringInfoString((uint64_t)v10, ",");
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, a9);
  }
  return result;
}

uint64_t _outAlterUserMappingStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  size_t v51;
  size_t v52;
  size_t v53;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"user\":{", a3, a4, a5, a6, a7, a8, v51);
    _outRoleSpec(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = v10[2];
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        v10[2] = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v52);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"servername\":", a3, a4, a5, a6, a7, a8, v51);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v53);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar((uint64_t)v10, 91);
    v45 = *(_QWORD *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      v46 = 0;
      v47 = 8;
      do
      {
        v48 = *(_QWORD *)(v45 + 16);
        v49 = *(_QWORD *)(v48 + 8 * v46);
        if (v49)
          _outNode(v10, v49);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v48 + v47)
          v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v50 = 1;
        if (!v50)
          appendStringInfoString((uint64_t)v10, ",");
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, a9);
  }
  return result;
}

uint64_t _outDropUserMappingStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  size_t v39;
  size_t v40;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"user\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRoleSpec(v9, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = v9[2];
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v24) == 44)
      {
        v9[2] = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"servername\":", a3, a4, a5, a6, a7, a8, v38);
    _outToken(v9, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    result = appendStringInfo((uint64_t)v9, ",", v32, v33, v34, v35, v36, v37, v40);
  }
  if (*(_BYTE *)(a2 + 24))
    return appendStringInfo((uint64_t)v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outAlterTableSpaceOptionsStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  size_t v34;
  size_t v35;
  size_t v36;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"tablespacename\":", a3, a4, a5, a6, a7, a8, v34);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v35);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(_BYTE *)(a2 + 24))
    return appendStringInfo((uint64_t)v9, "\"isReset\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outAlterTableMoveAllStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  size_t v55;
  size_t v56;
  size_t v57;
  size_t v58;
  size_t v59;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"orig_tablespacename\":", a3, a4, a5, a6, a7, a8, v55);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v56);
  }
  v22 = *(int *)(a2 + 16);
  if (v22 > 0x31)
    v23 = 0;
  else
    v23 = (&off_1E264B228)[v22];
  result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"roles\":", v25, v26, v27, v28, v29, v30, v57);
    appendStringInfoChar((uint64_t)a1, 91);
    v37 = *(_QWORD *)(a2 + 24);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      v38 = 0;
      v39 = 8;
      do
      {
        v40 = *(_QWORD *)(v37 + 16);
        v41 = *(_QWORD *)(v40 + 8 * v38);
        if (v41)
          _outNode(a1, v41);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v40 + v39)
          v42 = v40 + v39 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v42 = 1;
        if (!v42)
          appendStringInfoString((uint64_t)a1, ",");
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v31, v32, v33, v34, v35, v36, v58);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"new_tablespacename\":", v25, v26, v27, v28, v29, v30, v57);
    _outToken(a1, *(char **)(a2 + 32), v43, v44, v45, v46, v47, v48);
    result = appendStringInfo((uint64_t)a1, ",", v49, v50, v51, v52, v53, v54, v59);
  }
  if (*(_BYTE *)(a2 + 40))
    return appendStringInfo((uint64_t)a1, "\"nowait\":%s,", v25, v26, v27, v28, v29, v30, (size_t)"true");
  return result;
}

unint64_t _outSecLabelStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  size_t v50;
  size_t v51;
  size_t v52;

  v11 = *(int *)(a2 + 4);
  if (v11 > 0x31)
    v12 = 0;
  else
    v12 = (&off_1E264B228)[v11];
  result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v14, v15, v16, v17, v18, v19, v50);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    result = appendStringInfo((uint64_t)a1, ",", v20, v21, v22, v23, v24, v25, v51);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"provider\":", v14, v15, v16, v17, v18, v19, v50);
    _outToken(a1, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    result = appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, v52);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"label\":", v14, v15, v16, v17, v18, v19, v50);
    _outToken(a1, *(char **)(a2 + 24), v38, v39, v40, v41, v42, v43);
    return appendStringInfo((uint64_t)a1, ",", v44, v45, v46, v47, v48, v49, a9);
  }
  return result;
}

unint64_t _outCreateForeignTableStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t result;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  size_t v58;
  size_t v59;
  size_t v60;
  size_t v61;

  appendStringInfo((uint64_t)a1, "\"base\":{", a3, a4, a5, a6, a7, a8, v58);
  _outCreateStmt(a1, a2, v11, v12, v13, v14, v15, v16);
  v23 = a1[2];
  v24 = __OFSUB__(v23, 1);
  v25 = (v23 - 1);
  if ((int)v25 < 0 == v24)
  {
    v26 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v25) == 44)
    {
      a1[2] = v25;
      *(_BYTE *)(v26 + v25) = 0;
    }
  }
  result = appendStringInfo((uint64_t)a1, "},", v17, v18, v19, v20, v21, v22, v59);
  if (*(_QWORD *)(a2 + 104))
  {
    appendStringInfo((uint64_t)a1, "\"servername\":", v28, v29, v30, v31, v32, v33, v60);
    _outToken(a1, *(char **)(a2 + 104), v34, v35, v36, v37, v38, v39);
    result = appendStringInfo((uint64_t)a1, ",", v40, v41, v42, v43, v44, v45, v61);
  }
  if (*(_QWORD *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v28, v29, v30, v31, v32, v33, v60);
    appendStringInfoChar((uint64_t)a1, 91);
    v52 = *(_QWORD *)(a2 + 112);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(a1, v56);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 112) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString((uint64_t)a1, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v46, v47, v48, v49, v50, v51, a9);
  }
  return result;
}

unint64_t _outImportForeignSchemaStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  unint64_t result;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  BOOL v79;
  size_t v80;
  size_t v81;
  size_t v82;
  size_t v83;
  size_t v84;
  size_t v85;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"server_name\":", a3, a4, a5, a6, a7, a8, v80);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v81);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"remote_schema\":", a3, a4, a5, a6, a7, a8, v80);
    _outToken(a1, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    appendStringInfo((uint64_t)a1, ",", v29, v30, v31, v32, v33, v34, v82);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"local_schema\":", a3, a4, a5, a6, a7, a8, v80);
    _outToken(a1, *(char **)(a2 + 24), v35, v36, v37, v38, v39, v40);
    appendStringInfo((uint64_t)a1, ",", v41, v42, v43, v44, v45, v46, v83);
  }
  v47 = *(int *)(a2 + 32);
  if (v47 > 2)
    v48 = 0;
  else
    v48 = (&off_1E264B210)[v47];
  result = appendStringInfo((uint64_t)a1, "\"list_type\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v48);
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"table_list\":", v50, v51, v52, v53, v54, v55, v84);
    appendStringInfoChar((uint64_t)a1, 91);
    v62 = *(_QWORD *)(a2 + 40);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      v63 = 0;
      v64 = 8;
      do
      {
        v65 = *(_QWORD *)(v62 + 16);
        v66 = *(_QWORD *)(v65 + 8 * v63);
        if (v66)
          _outNode(a1, v66);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v65 + v64)
          v67 = v65 + v64 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v67 = 1;
        if (!v67)
          appendStringInfoString((uint64_t)a1, ",");
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v56, v57, v58, v59, v60, v61, v85);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v50, v51, v52, v53, v54, v55, v84);
    appendStringInfoChar((uint64_t)a1, 91);
    v74 = *(_QWORD *)(a2 + 48);
    if (v74 && *(int *)(v74 + 4) >= 1)
    {
      v75 = 0;
      v76 = 8;
      do
      {
        v77 = *(_QWORD *)(v74 + 16);
        v78 = *(_QWORD *)(v77 + 8 * v75);
        if (v78)
          _outNode(a1, v78);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v77 + v76)
          v79 = v77 + v76 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v79 = 1;
        if (!v79)
          appendStringInfoString((uint64_t)a1, ",");
        ++v75;
        v76 += 8;
      }
      while (v75 < *(int *)(v74 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v68, v69, v70, v71, v72, v73, a9);
  }
  return result;
}

uint64_t _outCreateExtensionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"extname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfo((uint64_t)v10, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 24);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outAlterExtensionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"extname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outAlterExtensionContentsStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  unint64_t result;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  size_t v39;
  size_t v40;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"extname\":", a3, a4, a5, a6, a7, a8, v38);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v39);
  }
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo((uint64_t)a1, "\"action\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  v23 = *(int *)(a2 + 20);
  if (v23 > 0x31)
    v24 = 0;
  else
    v24 = (&off_1E264B228)[v23];
  result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v26, v27, v28, v29, v30, v31, v40);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    return appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, a9);
  }
  return result;
}

uint64_t _outCreateEventTrigStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  size_t v59;
  size_t v60;
  size_t v61;
  size_t v62;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"trigname\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v60);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"eventname\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v61);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"whenclause\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    v41 = *(_QWORD *)(a2 + 24);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      v42 = 0;
      v43 = 8;
      do
      {
        v44 = *(_QWORD *)(v41 + 16);
        v45 = *(_QWORD *)(v44 + 8 * v42);
        if (v45)
          _outNode(v10, v45);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v44 + v43)
          v46 = v44 + v43 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v46 = 1;
        if (!v46)
          appendStringInfoString((uint64_t)v10, ",");
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, v62);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"funcname\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    v53 = *(_QWORD *)(a2 + 32);
    if (v53 && *(int *)(v53 + 4) >= 1)
    {
      v54 = 0;
      v55 = 8;
      do
      {
        v56 = *(_QWORD *)(v53 + 16);
        v57 = *(_QWORD *)(v56 + 8 * v54);
        if (v57)
          _outNode(v10, v57);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v56 + v55)
          v58 = v56 + v55 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v58 = 1;
        if (!v58)
          appendStringInfoString((uint64_t)v10, ",");
        ++v54;
        v55 += 8;
      }
      while (v54 < *(int *)(v53 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v47, v48, v49, v50, v51, v52, a9);
  }
  return result;
}

uint64_t _outAlterEventTrigStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  size_t v23;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"trigname\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(_BYTE *)(a2 + 16))
    return appendStringInfo((uint64_t)v9, "\"tgenabled\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 16));
  return result;
}

uint64_t _outRefreshMatViewStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;

  v10 = result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"concurrent\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 5))
    result = appendStringInfo(v10, "\"skipData\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v10, "\"relation\":{", a3, a4, a5, a6, a7, a8, v27);
    _outRangeVar(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    return appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outReplicaIdentityStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;

  v10 = (int *)result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"identity_type\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 4));
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v10, "\"name\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outAlterSystemStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = (int *)result;
    appendStringInfo(result, "\"setstmt\":{", a3, a4, a5, a6, a7, a8, v27);
    _outVariableSetStmt(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = v10[2];
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        v10[2] = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outCreatePolicyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  size_t v75;
  size_t v76;
  size_t v77;
  size_t v78;
  size_t v79;
  size_t v80;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"policy_name\":", a3, a4, a5, a6, a7, a8, v75);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v76);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"table\":{", a3, a4, a5, a6, a7, a8, v75);
    _outRangeVar((uint64_t)v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = v10[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        v10[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v77);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"cmd_name\":", a3, a4, a5, a6, a7, a8, v75);
    _outToken(v10, *(char **)(a2 + 24), v39, v40, v41, v42, v43, v44);
    result = appendStringInfo((uint64_t)v10, ",", v45, v46, v47, v48, v49, v50, v78);
  }
  if (*(_BYTE *)(a2 + 32))
    result = appendStringInfo((uint64_t)v10, "\"permissive\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v10, "\"roles\":", a3, a4, a5, a6, a7, a8, v75);
    appendStringInfoChar((uint64_t)v10, 91);
    v57 = *(_QWORD *)(a2 + 40);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      v58 = 0;
      v59 = 8;
      do
      {
        v60 = *(_QWORD *)(v57 + 16);
        v61 = *(_QWORD *)(v60 + 8 * v58);
        if (v61)
          _outNode(v10, v61);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v60 + v59)
          v62 = v60 + v59 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v62 = 1;
        if (!v62)
          appendStringInfoString((uint64_t)v10, ",");
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v51, v52, v53, v54, v55, v56, v79);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"qual\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(_QWORD *)(a2 + 48));
    result = appendStringInfo((uint64_t)v10, ",", v63, v64, v65, v66, v67, v68, v80);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v10, "\"with_check\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(_QWORD *)(a2 + 56));
    return appendStringInfo((uint64_t)v10, ",", v69, v70, v71, v72, v73, v74, a9);
  }
  return result;
}

uint64_t _outAlterPolicyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  size_t v63;
  size_t v64;
  size_t v65;
  size_t v66;
  size_t v67;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"policy_name\":", a3, a4, a5, a6, a7, a8, v63);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v64);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"table\":{", a3, a4, a5, a6, a7, a8, v63);
    _outRangeVar((uint64_t)v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = v10[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        v10[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v65);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"roles\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar((uint64_t)v10, 91);
    v45 = *(_QWORD *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      v46 = 0;
      v47 = 8;
      do
      {
        v48 = *(_QWORD *)(v45 + 16);
        v49 = *(_QWORD *)(v48 + 8 * v46);
        if (v49)
          _outNode(v10, v49);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v48 + v47)
          v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v50 = 1;
        if (!v50)
          appendStringInfoString((uint64_t)v10, ",");
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, v66);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"qual\":", a3, a4, a5, a6, a7, a8, v63);
    _outNode(v10, *(_QWORD *)(a2 + 32));
    result = appendStringInfo((uint64_t)v10, ",", v51, v52, v53, v54, v55, v56, v67);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v10, "\"with_check\":", a3, a4, a5, a6, a7, a8, v63);
    _outNode(v10, *(_QWORD *)(a2 + 40));
    return appendStringInfo((uint64_t)v10, ",", v57, v58, v59, v60, v61, v62, a9);
  }
  return result;
}

uint64_t _outCreateTransformStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  size_t v69;
  size_t v70;
  size_t v71;
  size_t v72;

  v10 = (int *)result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v10, "\"type_name\":{", a3, a4, a5, a6, a7, a8, v69);
    _outTypeName((uint64_t)v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = v10[2];
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        v10[2] = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v70);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"lang\":", a3, a4, a5, a6, a7, a8, v69);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v71);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"fromsql\":{", a3, a4, a5, a6, a7, a8, v69);
    _outObjectWithArgs((uint64_t)v10, *(_QWORD *)(a2 + 24), v39, v40, v41, v42, v43, v44);
    v51 = v10[2];
    v24 = __OFSUB__(v51, 1);
    v52 = (v51 - 1);
    if ((int)v52 < 0 == v24)
    {
      v53 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v52) == 44)
      {
        v10[2] = v52;
        *(_BYTE *)(v53 + v52) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v10, "},", v45, v46, v47, v48, v49, v50, v72);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"tosql\":{", a3, a4, a5, a6, a7, a8, v69);
    _outObjectWithArgs((uint64_t)v10, *(_QWORD *)(a2 + 32), v54, v55, v56, v57, v58, v59);
    v66 = v10[2];
    v24 = __OFSUB__(v66, 1);
    v67 = (v66 - 1);
    if ((int)v67 < 0 == v24)
    {
      v68 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v67) == 44)
      {
        v10[2] = v67;
        *(_BYTE *)(v68 + v67) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v60, v61, v62, v63, v64, v65, a9);
  }
  return result;
}

uint64_t _outCreateAmStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  size_t v34;
  size_t v35;
  size_t v36;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"amname\":", a3, a4, a5, a6, a7, a8, v34);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v35);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"handler_name\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(_BYTE *)(a2 + 24))
    return appendStringInfo((uint64_t)v9, "\"amtype\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 24));
  return result;
}

uint64_t _outCreatePublicationStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  size_t v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"pubname\":", a3, a4, a5, a6, a7, a8, v46);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v47);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"tables\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar((uint64_t)v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString((uint64_t)v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_BYTE *)(a2 + 32))
    return appendStringInfo((uint64_t)v9, "\"for_all_tables\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outAlterPublicationStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  char *v47;
  size_t v49;
  size_t v50;
  size_t v51;
  size_t v52;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"pubname\":", a3, a4, a5, a6, a7, a8, v49);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v50);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", a3, a4, a5, a6, a7, a8, v49);
    appendStringInfoChar((uint64_t)a1, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(a1, v32);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)a1, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v22, v23, v24, v25, v26, v27, v51);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"tables\":", a3, a4, a5, a6, a7, a8, v49);
    appendStringInfoChar((uint64_t)a1, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(a1, v44);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString((uint64_t)a1, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v34, v35, v36, v37, v38, v39, v52);
  }
  if (*(_BYTE *)(a2 + 32))
    appendStringInfo((uint64_t)a1, "\"for_all_tables\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  v46 = *(int *)(a2 + 36);
  if (v46 > 3)
    v47 = 0;
  else
    v47 = (&off_1E264B508)[v46];
  return appendStringInfo((uint64_t)a1, "\"tableAction\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v47);
}

uint64_t _outCreateSubscriptionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  size_t v59;
  size_t v60;
  size_t v61;
  size_t v62;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"subname\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v60);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"conninfo\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v61);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"publication\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    v41 = *(_QWORD *)(a2 + 24);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      v42 = 0;
      v43 = 8;
      do
      {
        v44 = *(_QWORD *)(v41 + 16);
        v45 = *(_QWORD *)(v44 + 8 * v42);
        if (v45)
          _outNode(v10, v45);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v44 + v43)
          v46 = v44 + v43 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v46 = 1;
        if (!v46)
          appendStringInfoString((uint64_t)v10, ",");
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    result = appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, v62);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    v53 = *(_QWORD *)(a2 + 32);
    if (v53 && *(int *)(v53 + 4) >= 1)
    {
      v54 = 0;
      v55 = 8;
      do
      {
        v56 = *(_QWORD *)(v53 + 16);
        v57 = *(_QWORD *)(v56 + 8 * v54);
        if (v57)
          _outNode(v10, v57);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v56 + v55)
          v58 = v56 + v55 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v58 = 1;
        if (!v58)
          appendStringInfoString((uint64_t)v10, ",");
        ++v54;
        v55 += 8;
      }
      while (v54 < *(int *)(v53 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v47, v48, v49, v50, v51, v52, a9);
  }
  return result;
}

unint64_t _outAlterSubscriptionStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  size_t v68;
  size_t v69;
  size_t v70;
  size_t v71;

  v11 = *(int *)(a2 + 4);
  if (v11 > 4)
    v12 = 0;
  else
    v12 = (&off_1E264B3B8)[v11];
  result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"subname\":", v14, v15, v16, v17, v18, v19, v68);
    _outToken(a1, *(char **)(a2 + 8), v20, v21, v22, v23, v24, v25);
    result = appendStringInfo((uint64_t)a1, ",", v26, v27, v28, v29, v30, v31, v69);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"conninfo\":", v14, v15, v16, v17, v18, v19, v68);
    _outToken(a1, *(char **)(a2 + 16), v32, v33, v34, v35, v36, v37);
    result = appendStringInfo((uint64_t)a1, ",", v38, v39, v40, v41, v42, v43, v70);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"publication\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar((uint64_t)a1, 91);
    v50 = *(_QWORD *)(a2 + 24);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      v51 = 0;
      v52 = 8;
      do
      {
        v53 = *(_QWORD *)(v50 + 16);
        v54 = *(_QWORD *)(v53 + 8 * v51);
        if (v54)
          _outNode(a1, v54);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v53 + v52)
          v55 = v53 + v52 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v55 = 1;
        if (!v55)
          appendStringInfoString((uint64_t)a1, ",");
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v44, v45, v46, v47, v48, v49, v71);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar((uint64_t)a1, 91);
    v62 = *(_QWORD *)(a2 + 32);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      v63 = 0;
      v64 = 8;
      do
      {
        v65 = *(_QWORD *)(v62 + 16);
        v66 = *(_QWORD *)(v65 + 8 * v63);
        if (v66)
          _outNode(a1, v66);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v65 + v64)
          v67 = v65 + v64 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v67 = 1;
        if (!v67)
          appendStringInfoString((uint64_t)a1, ",");
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v56, v57, v58, v59, v60, v61, a9);
  }
  return result;
}

unint64_t _outDropSubscriptionStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  const char *v23;
  const char *v24;
  size_t v26;
  size_t v27;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"subname\":", a3, a4, a5, a6, a7, a8, v26);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v27);
  }
  if (*(_BYTE *)(a2 + 16))
    appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  v22 = *(_DWORD *)(a2 + 20);
  v23 = "DROP_CASCADE";
  if (v22 != 1)
    v23 = 0;
  if (v22)
    v24 = v23;
  else
    v24 = "DROP_RESTRICT";
  return appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
}

uint64_t _outCreateStatsStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  size_t v70;
  size_t v71;
  size_t v72;
  size_t v73;
  size_t v74;
  size_t v75;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"defnames\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString((uint64_t)v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v71);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"stat_types\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v72);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"exprs\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString((uint64_t)v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v73);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"relations\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v52 = *(_QWORD *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(v9, v56);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString((uint64_t)v9, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v74);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"stxcomment\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 40), v58, v59, v60, v61, v62, v63);
    result = appendStringInfo((uint64_t)v9, ",", v64, v65, v66, v67, v68, v69, v75);
  }
  if (*(_BYTE *)(a2 + 48))
    return appendStringInfo((uint64_t)v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outAlterCollationStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  size_t v23;

  if (*(_QWORD *)(a2 + 8))
  {
    v10 = result;
    appendStringInfo(result, "\"collname\":", a3, a4, a5, a6, a7, a8, v23);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    return appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, a9);
  }
  return result;
}

uint64_t _outCallStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  size_t v43;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"funccall\":{", a3, a4, a5, a6, a7, a8, v42);
    _outFuncCall(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v43);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"funcexpr\":{", a3, a4, a5, a6, a7, a8, v42);
    _outFuncExpr(v10, *(_QWORD *)(a2 + 16), v27, v28, v29, v30, v31, v32);
    v39 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v39, 1);
    v40 = (v39 - 1);
    if ((int)v40 < 0 == v24)
    {
      v41 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v40) == 44)
      {
        *(_DWORD *)(v10 + 8) = v40;
        *(_BYTE *)(v41 + v40) = 0;
      }
    }
    return appendStringInfo(v10, "},", v33, v34, v35, v36, v37, v38, a9);
  }
  return result;
}

uint64_t _outAlterStatsStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"defnames\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"stxstattarget\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_BYTE *)(a2 + 20))
    return appendStringInfo(v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outAExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  size_t v43;
  size_t v44;
  size_t v45;
  size_t v46;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0xF)
    v11 = 0;
  else
    v11 = (&off_1E264B3E0)[v10];
  result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"name\":", v13, v14, v15, v16, v17, v18, v43);
    appendStringInfoChar(a1, 91);
    v25 = *(_QWORD *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        v29 = *(_QWORD *)(v28 + 8 * v26);
        if (v29)
          _outNode(a1, v29);
        else
          appendStringInfoString(a1, "{}");
        if (v28 + v27)
          v30 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v30 = 1;
        if (!v30)
          appendStringInfoString(a1, ",");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v44);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"lexpr\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(a1, ",", v31, v32, v33, v34, v35, v36, v45);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"rexpr\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    result = appendStringInfo(a1, ",", v37, v38, v39, v40, v41, v42, v46);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 32));
  return result;
}

uint64_t _outColumnRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"fields\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  return result;
}

uint64_t _outParamRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"number\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  return result;
}

unint64_t _outAConst(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  size_t v24;

  appendStringInfo(a1, "\"val\":", a3, a4, a5, a6, a7, a8, v23);
  _outNode(a1, a2 + 8);
  result = appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v24);
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(a1, "\"location\":%d,", v17, v18, v19, v20, v21, v22, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outFuncCall(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  size_t v68;
  size_t v69;
  size_t v70;
  size_t v71;
  size_t v72;
  size_t v73;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"funcname\":", a3, a4, a5, a6, a7, a8, v68);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v69);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v68);
    appendStringInfoChar(v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString(v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v70);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"agg_order\":", a3, a4, a5, a6, a7, a8, v68);
    appendStringInfoChar(v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString(v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString(v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v71);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v9, "\"agg_filter\":", a3, a4, a5, a6, a7, a8, v68);
    _outNode(v9, *(_QWORD *)(a2 + 32));
    result = appendStringInfo(v9, ",", v46, v47, v48, v49, v50, v51, v72);
  }
  if (*(_BYTE *)(a2 + 40))
    result = appendStringInfo(v9, "\"agg_within_group\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 41))
    result = appendStringInfo(v9, "\"agg_star\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 42))
    result = appendStringInfo(v9, "\"agg_distinct\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 43))
    result = appendStringInfo(v9, "\"func_variadic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(v9, "\"over\":{", a3, a4, a5, a6, a7, a8, v68);
    _outWindowDef(v9, *(_QWORD *)(a2 + 48), v52, v53, v54, v55, v56, v57);
    v64 = *(_DWORD *)(v9 + 8);
    v65 = __OFSUB__(v64, 1);
    v66 = (v64 - 1);
    if ((int)v66 < 0 == v65)
    {
      v67 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v66) == 44)
      {
        *(_DWORD *)(v9 + 8) = v66;
        *(_BYTE *)(v67 + v66) = 0;
      }
    }
    result = appendStringInfo(v9, "},", v58, v59, v60, v61, v62, v63, v73);
  }
  if (*(_DWORD *)(a2 + 56))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 56));
  return result;
}

uint64_t _outAIndices(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  size_t v24;

  v10 = result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"is_slice\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v10, "\"lidx\":", a3, a4, a5, a6, a7, a8, v23);
    _outNode(v10, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v24);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"uidx\":", a3, a4, a5, a6, a7, a8, v23);
    _outNode(v10, *(_QWORD *)(a2 + 16));
    return appendStringInfo(v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outAIndirection(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  size_t v29;
  size_t v30;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"indirection\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    v23 = *(_QWORD *)(a2 + 16);
    if (v23 && *(int *)(v23 + 4) >= 1)
    {
      v24 = 0;
      v25 = 8;
      do
      {
        v26 = *(_QWORD *)(v23 + 16);
        v27 = *(_QWORD *)(v26 + 8 * v24);
        if (v27)
          _outNode(v10, v27);
        else
          appendStringInfoString(v10, "{}");
        if (v26 + v25)
          v28 = v26 + v25 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v28 = 1;
        if (!v28)
          appendStringInfoString(v10, ",");
        ++v24;
        v25 += 8;
      }
      while (v24 < *(int *)(v23 + 4));
    }
    return appendStringInfo(v10, "],", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outAArrayExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"elements\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  return result;
}

uint64_t _outResTarget(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  size_t v41;
  size_t v42;
  size_t v43;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v40);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v41);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"indirection\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v42);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"val\":", a3, a4, a5, a6, a7, a8, v40);
    _outNode(v9, *(_QWORD *)(a2 + 24));
    result = appendStringInfo((uint64_t)v9, ",", v34, v35, v36, v37, v38, v39, v43);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  return result;
}

uint64_t _outMultiAssignRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"source\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"colno\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    return appendStringInfo(v9, "\"ncolumns\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  return result;
}

uint64_t _outTypeCast(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  size_t v32;
  size_t v33;
  size_t v34;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v32);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v33);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v32);
    _outTypeName(v9, *(_QWORD *)(a2 + 16), v16, v17, v18, v19, v20, v21);
    v28 = *(_DWORD *)(v9 + 8);
    v29 = __OFSUB__(v28, 1);
    v30 = (v28 - 1);
    if ((int)v30 < 0 == v29)
    {
      v31 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v30) == 44)
      {
        *(_DWORD *)(v9 + 8) = v30;
        *(_BYTE *)(v31 + v30) = 0;
      }
    }
    result = appendStringInfo(v9, "},", v22, v23, v24, v25, v26, v27, v34);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outCollateClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  size_t v28;
  size_t v29;
  size_t v30;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"collname\":", a3, a4, a5, a6, a7, a8, v28);
    appendStringInfoChar(v9, 91);
    v22 = *(_QWORD *)(a2 + 16);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      v23 = 0;
      v24 = 8;
      do
      {
        v25 = *(_QWORD *)(v22 + 16);
        v26 = *(_QWORD *)(v25 + 8 * v23);
        if (v26)
          _outNode(v9, v26);
        else
          appendStringInfoString(v9, "{}");
        if (v25 + v24)
          v27 = v25 + v24 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v27 = 1;
        if (!v27)
          appendStringInfoString(v9, ",");
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v30);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  return result;
}

unint64_t _outSortBy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  BOOL v44;
  size_t v45;
  size_t v46;
  size_t v47;
  size_t v48;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"node\":", a3, a4, a5, a6, a7, a8, v45);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v46);
  }
  v16 = *(int *)(a2 + 16);
  if (v16 > 3)
    v17 = 0;
  else
    v17 = (&off_1E264B460)[v16];
  appendStringInfo(a1, "\"sortby_dir\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  v24 = *(int *)(a2 + 20);
  if (v24 > 2)
    v25 = 0;
  else
    v25 = (&off_1E264B480)[v24];
  result = appendStringInfo(a1, "\"sortby_nulls\":\"%s\",", v18, v19, v20, v21, v22, v23, (size_t)v25);
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"useOp\":", v27, v28, v29, v30, v31, v32, v47);
    appendStringInfoChar(a1, 91);
    v39 = *(_QWORD *)(a2 + 24);
    if (v39 && *(int *)(v39 + 4) >= 1)
    {
      v40 = 0;
      v41 = 8;
      do
      {
        v42 = *(_QWORD *)(v39 + 16);
        v43 = *(_QWORD *)(v42 + 8 * v40);
        if (v43)
          _outNode(a1, v43);
        else
          appendStringInfoString(a1, "{}");
        if (v42 + v41)
          v44 = v42 + v41 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v44 = 1;
        if (!v44)
          appendStringInfoString(a1, ",");
        ++v40;
        v41 += 8;
      }
      while (v40 < *(int *)(v39 + 4));
    }
    result = appendStringInfo(a1, "],", v33, v34, v35, v36, v37, v38, v48);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(a1, "\"location\":%d,", v27, v28, v29, v30, v31, v32, *(unsigned int *)(a2 + 32));
  return result;
}

uint64_t _outWindowDef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  size_t v70;
  size_t v71;
  size_t v72;
  size_t v73;
  size_t v74;
  size_t v75;
  size_t v76;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v71);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"refname\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v72);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"partitionClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString((uint64_t)v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v73);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"orderClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v52 = *(_QWORD *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(v9, v56);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString((uint64_t)v9, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v74);
  }
  if (*(_DWORD *)(a2 + 40))
    result = appendStringInfo((uint64_t)v9, "\"frameOptions\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v9, "\"startOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(_QWORD *)(a2 + 48));
    result = appendStringInfo((uint64_t)v9, ",", v58, v59, v60, v61, v62, v63, v75);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"endOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(_QWORD *)(a2 + 56));
    result = appendStringInfo((uint64_t)v9, ",", v64, v65, v66, v67, v68, v69, v76);
  }
  if (*(_DWORD *)(a2 + 64))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 64));
  return result;
}

uint64_t _outRangeSubselect(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  size_t v34;
  size_t v35;

  v10 = result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"lateral\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v10, "\"subquery\":", a3, a4, a5, a6, a7, a8, v33);
    _outNode(v10, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v34);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"alias\":{", a3, a4, a5, a6, a7, a8, v33);
    _outAlias(v10, *(_QWORD *)(a2 + 16), v17, v18, v19, v20, v21, v22, v35);
    v29 = *(_DWORD *)(v10 + 8);
    v30 = __OFSUB__(v29, 1);
    v31 = (v29 - 1);
    if ((int)v31 < 0 == v30)
    {
      v32 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v31) == 44)
      {
        *(_DWORD *)(v10 + 8) = v31;
        *(_BYTE *)(v32 + v31) = 0;
      }
    }
    return appendStringInfo(v10, "},", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outRangeFunction(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  size_t v51;
  size_t v52;
  size_t v53;
  size_t v54;

  v10 = result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"lateral\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 5))
    result = appendStringInfo(v10, "\"ordinality\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 6))
    result = appendStringInfo(v10, "\"is_rowsfrom\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v10, "\"functions\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v52);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"alias\":{", a3, a4, a5, a6, a7, a8, v51);
    _outAlias(v10, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28, v53);
    v35 = *(_DWORD *)(v10 + 8);
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v37) == 44)
      {
        *(_DWORD *)(v10 + 8) = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v29, v30, v31, v32, v33, v34, v54);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v10, "\"coldeflist\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar(v10, 91);
    v45 = *(_QWORD *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      v46 = 0;
      v47 = 8;
      do
      {
        v48 = *(_QWORD *)(v45 + 16);
        v49 = *(_QWORD *)(v48 + 8 * v46);
        if (v49)
          _outNode(v10, v49);
        else
          appendStringInfoString(v10, "{}");
        if (v48 + v47)
          v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v50 = 1;
        if (!v50)
          appendStringInfoString(v10, ",");
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    return appendStringInfo(v10, "],", v39, v40, v41, v42, v43, v44, a9);
  }
  return result;
}

uint64_t _outRangeTableSample(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  size_t v47;
  size_t v48;
  size_t v49;
  size_t v50;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":", a3, a4, a5, a6, a7, a8, v46);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"method\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v22 = *(_QWORD *)(a2 + 16);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      v23 = 0;
      v24 = 8;
      do
      {
        v25 = *(_QWORD *)(v22 + 16);
        v26 = *(_QWORD *)(v25 + 8 * v23);
        if (v26)
          _outNode(v9, v26);
        else
          appendStringInfoString(v9, "{}");
        if (v25 + v24)
          v27 = v25 + v24 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v27 = 1;
        if (!v27)
          appendStringInfoString(v9, ",");
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v48);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v34 = *(_QWORD *)(a2 + 24);
    if (v34 && *(int *)(v34 + 4) >= 1)
    {
      v35 = 0;
      v36 = 8;
      do
      {
        v37 = *(_QWORD *)(v34 + 16);
        v38 = *(_QWORD *)(v37 + 8 * v35);
        if (v38)
          _outNode(v9, v38);
        else
          appendStringInfoString(v9, "{}");
        if (v37 + v36)
          v39 = v37 + v36 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v39 = 1;
        if (!v39)
          appendStringInfoString(v9, ",");
        ++v35;
        v36 += 8;
      }
      while (v35 < *(int *)(v34 + 4));
    }
    result = appendStringInfo(v9, "],", v28, v29, v30, v31, v32, v33, v49);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v9, "\"repeatable\":", a3, a4, a5, a6, a7, a8, v46);
    _outNode(v9, *(_QWORD *)(a2 + 32));
    result = appendStringInfo(v9, ",", v40, v41, v42, v43, v44, v45, v50);
  }
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  return result;
}

uint64_t _outRangeTableFunc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  size_t v62;
  size_t v63;
  size_t v64;
  size_t v65;
  size_t v66;
  size_t v67;
  size_t v68;

  v9 = result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"lateral\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v9, "\"docexpr\":", a3, a4, a5, a6, a7, a8, v62);
    _outNode(v9, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v63);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"rowexpr\":", a3, a4, a5, a6, a7, a8, v62);
    _outNode(v9, *(_QWORD *)(a2 + 16));
    result = appendStringInfo(v9, ",", v16, v17, v18, v19, v20, v21, v64);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"namespaces\":", a3, a4, a5, a6, a7, a8, v62);
    appendStringInfoChar(v9, 91);
    v28 = *(_QWORD *)(a2 + 24);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString(v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v65);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v9, "\"columns\":", a3, a4, a5, a6, a7, a8, v62);
    appendStringInfoChar(v9, 91);
    v40 = *(_QWORD *)(a2 + 32);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString(v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString(v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v66);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(v9, "\"alias\":{", a3, a4, a5, a6, a7, a8, v62);
    _outAlias(v9, *(_QWORD *)(a2 + 40), v46, v47, v48, v49, v50, v51, v67);
    v58 = *(_DWORD *)(v9 + 8);
    v59 = __OFSUB__(v58, 1);
    v60 = (v58 - 1);
    if ((int)v60 < 0 == v59)
    {
      v61 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v60) == 44)
      {
        *(_DWORD *)(v9 + 8) = v60;
        *(_BYTE *)(v61 + v60) = 0;
      }
    }
    result = appendStringInfo(v9, "},", v52, v53, v54, v55, v56, v57, v68);
  }
  if (*(_DWORD *)(a2 + 48))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  return result;
}

uint64_t _outRangeTableFuncCol(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  size_t v50;
  size_t v51;
  size_t v52;
  size_t v53;
  size_t v54;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"colname\":", a3, a4, a5, a6, a7, a8, v50);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v51);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v50);
    _outTypeName((uint64_t)v9, *(_QWORD *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    v34 = v9[2];
    v35 = __OFSUB__(v34, 1);
    v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      v37 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v36) == 44)
      {
        v9[2] = v36;
        *(_BYTE *)(v37 + v36) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v52);
  }
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfo((uint64_t)v9, "\"for_ordinality\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 25))
    result = appendStringInfo((uint64_t)v9, "\"is_not_null\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"colexpr\":", a3, a4, a5, a6, a7, a8, v50);
    _outNode(v9, *(_QWORD *)(a2 + 32));
    result = appendStringInfo((uint64_t)v9, ",", v38, v39, v40, v41, v42, v43, v53);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"coldefexpr\":", a3, a4, a5, a6, a7, a8, v50);
    _outNode(v9, *(_QWORD *)(a2 + 40));
    result = appendStringInfo((uint64_t)v9, ",", v44, v45, v46, v47, v48, v49, v54);
  }
  if (*(_DWORD *)(a2 + 48))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  return result;
}

uint64_t _outTypeName(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  size_t v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"names\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"typeOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_BYTE *)(a2 + 20))
    result = appendStringInfo(v9, "\"setof\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 21))
    result = appendStringInfo(v9, "\"pct_type\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"typmods\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v28 = *(_QWORD *)(a2 + 24);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString(v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(_DWORD *)(a2 + 32))
    result = appendStringInfo(v9, "\"typemod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(v9, "\"arrayBounds\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v40 = *(_QWORD *)(a2 + 40);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString(v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString(v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_DWORD *)(a2 + 48))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  return result;
}

uint64_t _outColumnDef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  BOOL v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  BOOL v103;
  size_t v104;
  size_t v105;
  size_t v106;
  size_t v107;
  size_t v108;
  size_t v109;
  size_t v110;
  size_t v111;
  size_t v112;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"colname\":", a3, a4, a5, a6, a7, a8, v104);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v105);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v104);
    _outTypeName((uint64_t)v9, *(_QWORD *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    v34 = v9[2];
    v35 = __OFSUB__(v34, 1);
    v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      v37 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v36) == 44)
      {
        v9[2] = v36;
        *(_BYTE *)(v37 + v36) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v106);
  }
  if (*(_DWORD *)(a2 + 24))
    result = appendStringInfo((uint64_t)v9, "\"inhcount\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  if (*(_BYTE *)(a2 + 28))
    result = appendStringInfo((uint64_t)v9, "\"is_local\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 29))
    result = appendStringInfo((uint64_t)v9, "\"is_not_null\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 30))
    result = appendStringInfo((uint64_t)v9, "\"is_from_type\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 31))
    result = appendStringInfo((uint64_t)v9, "\"storage\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 31));
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"raw_default\":", a3, a4, a5, a6, a7, a8, v104);
    _outNode(v9, *(_QWORD *)(a2 + 32));
    result = appendStringInfo((uint64_t)v9, ",", v38, v39, v40, v41, v42, v43, v107);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"cooked_default\":", a3, a4, a5, a6, a7, a8, v104);
    _outNode(v9, *(_QWORD *)(a2 + 40));
    result = appendStringInfo((uint64_t)v9, ",", v44, v45, v46, v47, v48, v49, v108);
  }
  if (*(_BYTE *)(a2 + 48))
    result = appendStringInfo((uint64_t)v9, "\"identity\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 48));
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"identitySequence\":{", a3, a4, a5, a6, a7, a8, v104);
    _outRangeVar((uint64_t)v9, *(_QWORD *)(a2 + 56), v50, v51, v52, v53, v54, v55);
    v62 = v9[2];
    v35 = __OFSUB__(v62, 1);
    v63 = (v62 - 1);
    if ((int)v63 < 0 == v35)
    {
      v64 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v63) == 44)
      {
        v9[2] = v63;
        *(_BYTE *)(v64 + v63) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v56, v57, v58, v59, v60, v61, v109);
  }
  if (*(_BYTE *)(a2 + 64))
    result = appendStringInfo((uint64_t)v9, "\"generated\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 64));
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)v9, "\"collClause\":{", a3, a4, a5, a6, a7, a8, v104);
    _outCollateClause((uint64_t)v9, *(_QWORD *)(a2 + 72), v65, v66, v67, v68, v69, v70);
    v77 = v9[2];
    v35 = __OFSUB__(v77, 1);
    v78 = (v77 - 1);
    if ((int)v78 < 0 == v35)
    {
      v79 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v78) == 44)
      {
        v9[2] = v78;
        *(_BYTE *)(v79 + v78) = 0;
      }
    }
    result = appendStringInfo((uint64_t)v9, "},", v71, v72, v73, v74, v75, v76, v110);
  }
  if (*(_DWORD *)(a2 + 80))
    result = appendStringInfo((uint64_t)v9, "\"collOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 80));
  if (*(_QWORD *)(a2 + 88))
  {
    appendStringInfo((uint64_t)v9, "\"constraints\":", a3, a4, a5, a6, a7, a8, v104);
    appendStringInfoChar((uint64_t)v9, 91);
    v86 = *(_QWORD *)(a2 + 88);
    if (v86 && *(int *)(v86 + 4) >= 1)
    {
      v87 = 0;
      v88 = 8;
      do
      {
        v89 = *(_QWORD *)(v86 + 16);
        v90 = *(_QWORD *)(v89 + 8 * v87);
        if (v90)
          _outNode(v9, v90);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v89 + v88)
          v91 = v89 + v88 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 88) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 88) + 4));
        else
          v91 = 1;
        if (!v91)
          appendStringInfoString((uint64_t)v9, ",");
        ++v87;
        v88 += 8;
      }
      while (v87 < *(int *)(v86 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v80, v81, v82, v83, v84, v85, v111);
  }
  if (*(_QWORD *)(a2 + 96))
  {
    appendStringInfo((uint64_t)v9, "\"fdwoptions\":", a3, a4, a5, a6, a7, a8, v104);
    appendStringInfoChar((uint64_t)v9, 91);
    v98 = *(_QWORD *)(a2 + 96);
    if (v98 && *(int *)(v98 + 4) >= 1)
    {
      v99 = 0;
      v100 = 8;
      do
      {
        v101 = *(_QWORD *)(v98 + 16);
        v102 = *(_QWORD *)(v101 + 8 * v99);
        if (v102)
          _outNode(v9, v102);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v101 + v100)
          v103 = v101 + v100 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 96) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 96) + 4));
        else
          v103 = 1;
        if (!v103)
          appendStringInfoString((uint64_t)v9, ",");
        ++v99;
        v100 += 8;
      }
      while (v99 < *(int *)(v98 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v92, v93, v94, v95, v96, v97, v112);
  }
  if (*(_DWORD *)(a2 + 104))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 104));
  return result;
}

unint64_t _outIndexElem(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  BOOL v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  size_t v87;
  size_t v88;
  size_t v89;
  size_t v90;
  size_t v91;
  size_t v92;
  size_t v93;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", a3, a4, a5, a6, a7, a8, v87);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v88);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"expr\":", a3, a4, a5, a6, a7, a8, v87);
    _outNode(a1, *(_QWORD *)(a2 + 16));
    appendStringInfo((uint64_t)a1, ",", v22, v23, v24, v25, v26, v27, v89);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"indexcolname\":", a3, a4, a5, a6, a7, a8, v87);
    _outToken(a1, *(char **)(a2 + 24), v28, v29, v30, v31, v32, v33);
    appendStringInfo((uint64_t)a1, ",", v34, v35, v36, v37, v38, v39, v90);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"collation\":", a3, a4, a5, a6, a7, a8, v87);
    appendStringInfoChar((uint64_t)a1, 91);
    v46 = *(_QWORD *)(a2 + 32);
    if (v46 && *(int *)(v46 + 4) >= 1)
    {
      v47 = 0;
      v48 = 8;
      do
      {
        v49 = *(_QWORD *)(v46 + 16);
        v50 = *(_QWORD *)(v49 + 8 * v47);
        if (v50)
          _outNode(a1, v50);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v49 + v48)
          v51 = v49 + v48 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v51 = 1;
        if (!v51)
          appendStringInfoString((uint64_t)a1, ",");
        ++v47;
        v48 += 8;
      }
      while (v47 < *(int *)(v46 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v40, v41, v42, v43, v44, v45, v91);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"opclass\":", a3, a4, a5, a6, a7, a8, v87);
    appendStringInfoChar((uint64_t)a1, 91);
    v58 = *(_QWORD *)(a2 + 40);
    if (v58 && *(int *)(v58 + 4) >= 1)
    {
      v59 = 0;
      v60 = 8;
      do
      {
        v61 = *(_QWORD *)(v58 + 16);
        v62 = *(_QWORD *)(v61 + 8 * v59);
        if (v62)
          _outNode(a1, v62);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v61 + v60)
          v63 = v61 + v60 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v63 = 1;
        if (!v63)
          appendStringInfoString((uint64_t)a1, ",");
        ++v59;
        v60 += 8;
      }
      while (v59 < *(int *)(v58 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v52, v53, v54, v55, v56, v57, v92);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"opclassopts\":", a3, a4, a5, a6, a7, a8, v87);
    appendStringInfoChar((uint64_t)a1, 91);
    v70 = *(_QWORD *)(a2 + 48);
    if (v70 && *(int *)(v70 + 4) >= 1)
    {
      v71 = 0;
      v72 = 8;
      do
      {
        v73 = *(_QWORD *)(v70 + 16);
        v74 = *(_QWORD *)(v73 + 8 * v71);
        if (v74)
          _outNode(a1, v74);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v73 + v72)
          v75 = v73 + v72 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v75 = 1;
        if (!v75)
          appendStringInfoString((uint64_t)a1, ",");
        ++v71;
        v72 += 8;
      }
      while (v71 < *(int *)(v70 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v64, v65, v66, v67, v68, v69, v93);
  }
  v76 = *(int *)(a2 + 56);
  if (v76 > 3)
    v77 = 0;
  else
    v77 = (&off_1E264B460)[v76];
  appendStringInfo((uint64_t)a1, "\"ordering\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v77);
  v84 = *(int *)(a2 + 60);
  if (v84 > 2)
    v85 = 0;
  else
    v85 = (&off_1E264B480)[v84];
  return appendStringInfo((uint64_t)a1, "\"nulls_ordering\":\"%s\",", v78, v79, v80, v81, v82, v83, (size_t)v85);
}

unint64_t _outConstraint(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  BOOL v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  BOOL v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  BOOL v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  BOOL v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int v151;
  BOOL v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  BOOL v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  BOOL v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  BOOL v190;
  size_t v191;
  size_t v192;
  size_t v193;
  size_t v194;
  size_t v195;
  size_t v196;
  size_t v197;
  size_t v198;
  size_t v199;
  size_t v200;
  size_t v201;
  size_t v202;
  size_t v203;
  size_t v204;
  size_t v205;
  size_t v206;

  v10 = *(int *)(a2 + 4);
  if (v10 > 0xD)
    v11 = 0;
  else
    v11 = (&off_1E264B498)[v10];
  result = appendStringInfo((uint64_t)a1, "\"contype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"conname\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v192);
  }
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfo((uint64_t)a1, "\"deferrable\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_BYTE *)(a2 + 17))
    result = appendStringInfo((uint64_t)a1, "\"initdeferred\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_DWORD *)(a2 + 20))
    result = appendStringInfo((uint64_t)a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 20));
  if (*(_BYTE *)(a2 + 24))
    result = appendStringInfo((uint64_t)a1, "\"is_no_inherit\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"raw_expr\":", v13, v14, v15, v16, v17, v18, v191);
    _outNode(a1, *(_QWORD *)(a2 + 32));
    result = appendStringInfo((uint64_t)a1, ",", v31, v32, v33, v34, v35, v36, v193);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"cooked_expr\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 40), v37, v38, v39, v40, v41, v42);
    result = appendStringInfo((uint64_t)a1, ",", v43, v44, v45, v46, v47, v48, v194);
  }
  if (*(_BYTE *)(a2 + 48))
    result = appendStringInfo((uint64_t)a1, "\"generated_when\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 48));
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"keys\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    v55 = *(_QWORD *)(a2 + 56);
    if (v55 && *(int *)(v55 + 4) >= 1)
    {
      v56 = 0;
      v57 = 8;
      do
      {
        v58 = *(_QWORD *)(v55 + 16);
        v59 = *(_QWORD *)(v58 + 8 * v56);
        if (v59)
          _outNode(a1, v59);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v58 + v57)
          v60 = v58 + v57 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v60 = 1;
        if (!v60)
          appendStringInfoString((uint64_t)a1, ",");
        ++v56;
        v57 += 8;
      }
      while (v56 < *(int *)(v55 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v49, v50, v51, v52, v53, v54, v195);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"including\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    v67 = *(_QWORD *)(a2 + 64);
    if (v67 && *(int *)(v67 + 4) >= 1)
    {
      v68 = 0;
      v69 = 8;
      do
      {
        v70 = *(_QWORD *)(v67 + 16);
        v71 = *(_QWORD *)(v70 + 8 * v68);
        if (v71)
          _outNode(a1, v71);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v70 + v69)
          v72 = v70 + v69 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v72 = 1;
        if (!v72)
          appendStringInfoString((uint64_t)a1, ",");
        ++v68;
        v69 += 8;
      }
      while (v68 < *(int *)(v67 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v61, v62, v63, v64, v65, v66, v196);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"exclusions\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    v79 = *(_QWORD *)(a2 + 72);
    if (v79 && *(int *)(v79 + 4) >= 1)
    {
      v80 = 0;
      v81 = 8;
      do
      {
        v82 = *(_QWORD *)(v79 + 16);
        v83 = *(_QWORD *)(v82 + 8 * v80);
        if (v83)
          _outNode(a1, v83);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v82 + v81)
          v84 = v82 + v81 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v84 = 1;
        if (!v84)
          appendStringInfoString((uint64_t)a1, ",");
        ++v80;
        v81 += 8;
      }
      while (v80 < *(int *)(v79 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v73, v74, v75, v76, v77, v78, v197);
  }
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    v91 = *(_QWORD *)(a2 + 80);
    if (v91 && *(int *)(v91 + 4) >= 1)
    {
      v92 = 0;
      v93 = 8;
      do
      {
        v94 = *(_QWORD *)(v91 + 16);
        v95 = *(_QWORD *)(v94 + 8 * v92);
        if (v95)
          _outNode(a1, v95);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v94 + v93)
          v96 = v94 + v93 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 80) + 4));
        else
          v96 = 1;
        if (!v96)
          appendStringInfoString((uint64_t)a1, ",");
        ++v92;
        v93 += 8;
      }
      while (v92 < *(int *)(v91 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v85, v86, v87, v88, v89, v90, v198);
  }
  if (*(_QWORD *)(a2 + 88))
  {
    appendStringInfo((uint64_t)a1, "\"indexname\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 88), v97, v98, v99, v100, v101, v102);
    result = appendStringInfo((uint64_t)a1, ",", v103, v104, v105, v106, v107, v108, v199);
  }
  if (*(_QWORD *)(a2 + 96))
  {
    appendStringInfo((uint64_t)a1, "\"indexspace\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 96), v109, v110, v111, v112, v113, v114);
    result = appendStringInfo((uint64_t)a1, ",", v115, v116, v117, v118, v119, v120, v200);
  }
  if (*(_BYTE *)(a2 + 104))
    result = appendStringInfo((uint64_t)a1, "\"reset_default_tblspc\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_QWORD *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"access_method\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 112), v121, v122, v123, v124, v125, v126);
    result = appendStringInfo((uint64_t)a1, ",", v127, v128, v129, v130, v131, v132, v201);
  }
  if (*(_QWORD *)(a2 + 120))
  {
    appendStringInfo((uint64_t)a1, "\"where_clause\":", v13, v14, v15, v16, v17, v18, v191);
    _outNode(a1, *(_QWORD *)(a2 + 120));
    result = appendStringInfo((uint64_t)a1, ",", v133, v134, v135, v136, v137, v138, v202);
  }
  if (*(_QWORD *)(a2 + 128))
  {
    appendStringInfo((uint64_t)a1, "\"pktable\":{", v13, v14, v15, v16, v17, v18, v191);
    _outRangeVar((uint64_t)a1, *(_QWORD *)(a2 + 128), v139, v140, v141, v142, v143, v144);
    v151 = a1[2];
    v152 = __OFSUB__(v151, 1);
    v153 = (v151 - 1);
    if ((int)v153 < 0 == v152)
    {
      v154 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v153) == 44)
      {
        a1[2] = v153;
        *(_BYTE *)(v154 + v153) = 0;
      }
    }
    result = appendStringInfo((uint64_t)a1, "},", v145, v146, v147, v148, v149, v150, v203);
  }
  if (*(_QWORD *)(a2 + 136))
  {
    appendStringInfo((uint64_t)a1, "\"fk_attrs\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    v161 = *(_QWORD *)(a2 + 136);
    if (v161 && *(int *)(v161 + 4) >= 1)
    {
      v162 = 0;
      v163 = 8;
      do
      {
        v164 = *(_QWORD *)(v161 + 16);
        v165 = *(_QWORD *)(v164 + 8 * v162);
        if (v165)
          _outNode(a1, v165);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v164 + v163)
          v166 = v164 + v163 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 136) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 136) + 4));
        else
          v166 = 1;
        if (!v166)
          appendStringInfoString((uint64_t)a1, ",");
        ++v162;
        v163 += 8;
      }
      while (v162 < *(int *)(v161 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v155, v156, v157, v158, v159, v160, v204);
  }
  if (*(_QWORD *)(a2 + 144))
  {
    appendStringInfo((uint64_t)a1, "\"pk_attrs\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    v173 = *(_QWORD *)(a2 + 144);
    if (v173 && *(int *)(v173 + 4) >= 1)
    {
      v174 = 0;
      v175 = 8;
      do
      {
        v176 = *(_QWORD *)(v173 + 16);
        v177 = *(_QWORD *)(v176 + 8 * v174);
        if (v177)
          _outNode(a1, v177);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v176 + v175)
          v178 = v176 + v175 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 144) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 144) + 4));
        else
          v178 = 1;
        if (!v178)
          appendStringInfoString((uint64_t)a1, ",");
        ++v174;
        v175 += 8;
      }
      while (v174 < *(int *)(v173 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v167, v168, v169, v170, v171, v172, v205);
  }
  if (*(_BYTE *)(a2 + 152))
    result = appendStringInfo((uint64_t)a1, "\"fk_matchtype\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 152));
  if (*(_BYTE *)(a2 + 153))
    result = appendStringInfo((uint64_t)a1, "\"fk_upd_action\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 153));
  if (*(_BYTE *)(a2 + 154))
    result = appendStringInfo((uint64_t)a1, "\"fk_del_action\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 154));
  if (*(_QWORD *)(a2 + 160))
  {
    appendStringInfo((uint64_t)a1, "\"old_conpfeqop\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    v185 = *(_QWORD *)(a2 + 160);
    if (v185 && *(int *)(v185 + 4) >= 1)
    {
      v186 = 0;
      v187 = 8;
      do
      {
        v188 = *(_QWORD *)(v185 + 16);
        v189 = *(_QWORD *)(v188 + 8 * v186);
        if (v189)
          _outNode(a1, v189);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v188 + v187)
          v190 = v188 + v187 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 160) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 160) + 4));
        else
          v190 = 1;
        if (!v190)
          appendStringInfoString((uint64_t)a1, ",");
        ++v186;
        v187 += 8;
      }
      while (v186 < *(int *)(v185 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v179, v180, v181, v182, v183, v184, v206);
  }
  if (*(_DWORD *)(a2 + 168))
    result = appendStringInfo((uint64_t)a1, "\"old_pktable_oid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 168));
  if (*(_BYTE *)(a2 + 172))
    result = appendStringInfo((uint64_t)a1, "\"skip_validation\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  if (*(_BYTE *)(a2 + 173))
    return appendStringInfo((uint64_t)a1, "\"initially_valid\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

unint64_t _outDefElem(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  unint64_t result;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  size_t v49;
  size_t v50;
  size_t v51;
  size_t v52;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"defnamespace\":", a3, a4, a5, a6, a7, a8, v49);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v50);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"defname\":", a3, a4, a5, a6, a7, a8, v49);
    _outToken(a1, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    appendStringInfo((uint64_t)a1, ",", v28, v29, v30, v31, v32, v33, v51);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v49);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v34, v35, v36, v37, v38, v39, v52);
  }
  v40 = *(int *)(a2 + 32);
  if (v40 > 3)
    v41 = 0;
  else
    v41 = (&off_1E264B508)[v40];
  result = appendStringInfo((uint64_t)a1, "\"defaction\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v41);
  if (*(_DWORD *)(a2 + 36))
    return appendStringInfo((uint64_t)a1, "\"location\":%d,", v43, v44, v45, v46, v47, v48, *(unsigned int *)(a2 + 36));
  return result;
}

unint64_t _outRangeTblEntry(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  BOOL v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  BOOL v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  BOOL v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  BOOL v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  BOOL v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  BOOL v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  int v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  int v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  unint64_t result;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  BOOL v265;
  uint64_t member;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  int v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  int v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  int v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  int v307;
  uint64_t v308;
  uint64_t v309;
  size_t v310;
  size_t v311;
  size_t v312;
  size_t v313;
  size_t v314;
  size_t v315;
  size_t v316;
  size_t v317;
  size_t v318;
  size_t v319;
  size_t v320;
  size_t v321;
  size_t v322;
  size_t v323;
  size_t v324;
  size_t v325;
  size_t v326;
  size_t v327;
  size_t v328;
  size_t v329;
  size_t v330;
  size_t v331;
  size_t v332;
  size_t v333;
  size_t v334;

  v11 = *(int *)(a2 + 4);
  if (v11 > 8)
    v12 = 0;
  else
    v12 = (&off_1E264B528)[v11];
  appendStringInfo((uint64_t)a1, "\"rtekind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_DWORD *)(a2 + 8))
    appendStringInfo((uint64_t)a1, "\"relid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  if (*(_BYTE *)(a2 + 12))
    appendStringInfo((uint64_t)a1, "\"relkind\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 12));
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo((uint64_t)a1, "\"rellockmode\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"tablesample\":{", v13, v14, v15, v16, v17, v18, v310);
    _outTableSampleClause((uint64_t)a1, *(_QWORD *)(a2 + 24), v19, v20, v21, v22, v23, v24, v311);
    v31 = a1[2];
    v32 = __OFSUB__(v31, 1);
    v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      v34 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v33) == 44)
      {
        a1[2] = v33;
        *(_BYTE *)(v34 + v33) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v25, v26, v27, v28, v29, v30, v312);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"subquery\":{", v13, v14, v15, v16, v17, v18, v310);
    _outQuery((uint64_t)a1, *(_QWORD *)(a2 + 32), v35, v36, v37, v38, v39, v40);
    v47 = a1[2];
    v32 = __OFSUB__(v47, 1);
    v48 = (v47 - 1);
    if ((int)v48 < 0 == v32)
    {
      v49 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v48) == 44)
      {
        a1[2] = v48;
        *(_BYTE *)(v49 + v48) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v41, v42, v43, v44, v45, v46, v313);
  }
  if (*(_BYTE *)(a2 + 40))
    appendStringInfo((uint64_t)a1, "\"security_barrier\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  v50 = *(int *)(a2 + 44);
  if (v50 > 7)
    v51 = 0;
  else
    v51 = (&off_1E264B570)[v50];
  appendStringInfo((uint64_t)a1, "\"jointype\":\"%s\",", v13, v14, v15, v16, v17, v18, (size_t)v51);
  if (*(_DWORD *)(a2 + 48))
    appendStringInfo((uint64_t)a1, "\"joinmergedcols\":%d,", v52, v53, v54, v55, v56, v57, *(unsigned int *)(a2 + 48));
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"joinaliasvars\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v64 = *(_QWORD *)(a2 + 56);
    if (v64 && *(int *)(v64 + 4) >= 1)
    {
      v65 = 0;
      v66 = 8;
      do
      {
        v67 = *(_QWORD *)(v64 + 16);
        v68 = *(_QWORD *)(v67 + 8 * v65);
        if (v68)
          _outNode(a1, v68);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v67 + v66)
          v69 = v67 + v66 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v69 = 1;
        if (!v69)
          appendStringInfoString((uint64_t)a1, ",");
        ++v65;
        v66 += 8;
      }
      while (v65 < *(int *)(v64 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v58, v59, v60, v61, v62, v63, v315);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"joinleftcols\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v76 = *(_QWORD *)(a2 + 64);
    if (v76 && *(int *)(v76 + 4) >= 1)
    {
      v77 = 0;
      v78 = 8;
      do
      {
        v79 = *(_QWORD *)(v76 + 16);
        v80 = *(_QWORD *)(v79 + 8 * v77);
        if (v80)
          _outNode(a1, v80);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v79 + v78)
          v81 = v79 + v78 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v81 = 1;
        if (!v81)
          appendStringInfoString((uint64_t)a1, ",");
        ++v77;
        v78 += 8;
      }
      while (v77 < *(int *)(v76 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v70, v71, v72, v73, v74, v75, v316);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"joinrightcols\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v88 = *(_QWORD *)(a2 + 72);
    if (v88 && *(int *)(v88 + 4) >= 1)
    {
      v89 = 0;
      v90 = 8;
      do
      {
        v91 = *(_QWORD *)(v88 + 16);
        v92 = *(_QWORD *)(v91 + 8 * v89);
        if (v92)
          _outNode(a1, v92);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v91 + v90)
          v93 = v91 + v90 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v93 = 1;
        if (!v93)
          appendStringInfoString((uint64_t)a1, ",");
        ++v89;
        v90 += 8;
      }
      while (v89 < *(int *)(v88 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v82, v83, v84, v85, v86, v87, v317);
  }
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"functions\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v100 = *(_QWORD *)(a2 + 80);
    if (v100 && *(int *)(v100 + 4) >= 1)
    {
      v101 = 0;
      v102 = 8;
      do
      {
        v103 = *(_QWORD *)(v100 + 16);
        v104 = *(_QWORD *)(v103 + 8 * v101);
        if (v104)
          _outNode(a1, v104);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v103 + v102)
          v105 = v103 + v102 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 80) + 4));
        else
          v105 = 1;
        if (!v105)
          appendStringInfoString((uint64_t)a1, ",");
        ++v101;
        v102 += 8;
      }
      while (v101 < *(int *)(v100 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v94, v95, v96, v97, v98, v99, v318);
  }
  if (*(_BYTE *)(a2 + 88))
    appendStringInfo((uint64_t)a1, "\"funcordinality\":%s,", v52, v53, v54, v55, v56, v57, (size_t)"true");
  if (*(_QWORD *)(a2 + 96))
  {
    appendStringInfo((uint64_t)a1, "\"tablefunc\":{", v52, v53, v54, v55, v56, v57, v314);
    _outTableFunc((uint64_t)a1, *(_QWORD *)(a2 + 96), v106, v107, v108, v109, v110, v111);
    v118 = a1[2];
    v32 = __OFSUB__(v118, 1);
    v119 = (v118 - 1);
    if ((int)v119 < 0 == v32)
    {
      v120 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v119) == 44)
      {
        a1[2] = v119;
        *(_BYTE *)(v120 + v119) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v112, v113, v114, v115, v116, v117, v319);
  }
  if (*(_QWORD *)(a2 + 104))
  {
    appendStringInfo((uint64_t)a1, "\"values_lists\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v127 = *(_QWORD *)(a2 + 104);
    if (v127 && *(int *)(v127 + 4) >= 1)
    {
      v128 = 0;
      v129 = 8;
      do
      {
        v130 = *(_QWORD *)(v127 + 16);
        v131 = *(_QWORD *)(v130 + 8 * v128);
        if (v131)
          _outNode(a1, v131);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v130 + v129)
          v132 = v130 + v129 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 104) + 4));
        else
          v132 = 1;
        if (!v132)
          appendStringInfoString((uint64_t)a1, ",");
        ++v128;
        v129 += 8;
      }
      while (v128 < *(int *)(v127 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v121, v122, v123, v124, v125, v126, v320);
  }
  if (*(_QWORD *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"ctename\":", v52, v53, v54, v55, v56, v57, v314);
    _outToken(a1, *(char **)(a2 + 112), v133, v134, v135, v136, v137, v138);
    appendStringInfo((uint64_t)a1, ",", v139, v140, v141, v142, v143, v144, v321);
  }
  if (*(_DWORD *)(a2 + 120))
    appendStringInfo((uint64_t)a1, "\"ctelevelsup\":%u,", v52, v53, v54, v55, v56, v57, *(unsigned int *)(a2 + 120));
  if (*(_BYTE *)(a2 + 124))
    appendStringInfo((uint64_t)a1, "\"self_reference\":%s,", v52, v53, v54, v55, v56, v57, (size_t)"true");
  if (*(_QWORD *)(a2 + 128))
  {
    appendStringInfo((uint64_t)a1, "\"coltypes\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v151 = *(_QWORD *)(a2 + 128);
    if (v151 && *(int *)(v151 + 4) >= 1)
    {
      v152 = 0;
      v153 = 8;
      do
      {
        v154 = *(_QWORD *)(v151 + 16);
        v155 = *(_QWORD *)(v154 + 8 * v152);
        if (v155)
          _outNode(a1, v155);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v154 + v153)
          v156 = v154 + v153 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 128) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 128) + 4));
        else
          v156 = 1;
        if (!v156)
          appendStringInfoString((uint64_t)a1, ",");
        ++v152;
        v153 += 8;
      }
      while (v152 < *(int *)(v151 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v145, v146, v147, v148, v149, v150, v322);
  }
  if (*(_QWORD *)(a2 + 136))
  {
    appendStringInfo((uint64_t)a1, "\"coltypmods\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v163 = *(_QWORD *)(a2 + 136);
    if (v163 && *(int *)(v163 + 4) >= 1)
    {
      v164 = 0;
      v165 = 8;
      do
      {
        v166 = *(_QWORD *)(v163 + 16);
        v167 = *(_QWORD *)(v166 + 8 * v164);
        if (v167)
          _outNode(a1, v167);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v166 + v165)
          v168 = v166 + v165 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 136) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 136) + 4));
        else
          v168 = 1;
        if (!v168)
          appendStringInfoString((uint64_t)a1, ",");
        ++v164;
        v165 += 8;
      }
      while (v164 < *(int *)(v163 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v157, v158, v159, v160, v161, v162, v323);
  }
  if (*(_QWORD *)(a2 + 144))
  {
    appendStringInfo((uint64_t)a1, "\"colcollations\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    v175 = *(_QWORD *)(a2 + 144);
    if (v175 && *(int *)(v175 + 4) >= 1)
    {
      v176 = 0;
      v177 = 8;
      do
      {
        v178 = *(_QWORD *)(v175 + 16);
        v179 = *(_QWORD *)(v178 + 8 * v176);
        if (v179)
          _outNode(a1, v179);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v178 + v177)
          v180 = v178 + v177 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 144) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 144) + 4));
        else
          v180 = 1;
        if (!v180)
          appendStringInfoString((uint64_t)a1, ",");
        ++v176;
        v177 += 8;
      }
      while (v176 < *(int *)(v175 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v169, v170, v171, v172, v173, v174, v324);
  }
  if (*(_QWORD *)(a2 + 152))
  {
    appendStringInfo((uint64_t)a1, "\"enrname\":", v52, v53, v54, v55, v56, v57, v314);
    _outToken(a1, *(char **)(a2 + 152), v181, v182, v183, v184, v185, v186);
    appendStringInfo((uint64_t)a1, ",", v187, v188, v189, v190, v191, v192, v325);
  }
  appendStringInfo((uint64_t)a1, "\"enrtuples\":%f,", v52, v53, v54, v55, v56, v57, *(_QWORD *)(a2 + 160));
  if (*(_QWORD *)(a2 + 168))
  {
    appendStringInfo((uint64_t)a1, "\"alias\":{", v193, v194, v195, v196, v197, v198, v326);
    _outAlias((uint64_t)a1, *(_QWORD *)(a2 + 168), v199, v200, v201, v202, v203, v204, v327);
    v211 = a1[2];
    v32 = __OFSUB__(v211, 1);
    v212 = (v211 - 1);
    if ((int)v212 < 0 == v32)
    {
      v213 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v212) == 44)
      {
        a1[2] = v212;
        *(_BYTE *)(v213 + v212) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v205, v206, v207, v208, v209, v210, v328);
  }
  if (*(_QWORD *)(a2 + 176))
  {
    appendStringInfo((uint64_t)a1, "\"eref\":{", v193, v194, v195, v196, v197, v198, v326);
    _outAlias((uint64_t)a1, *(_QWORD *)(a2 + 176), v214, v215, v216, v217, v218, v219, v329);
    v226 = a1[2];
    v32 = __OFSUB__(v226, 1);
    v227 = (v226 - 1);
    if ((int)v227 < 0 == v32)
    {
      v228 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v227) == 44)
      {
        a1[2] = v227;
        *(_BYTE *)(v228 + v227) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v220, v221, v222, v223, v224, v225, v330);
  }
  if (*(_BYTE *)(a2 + 184))
    appendStringInfo((uint64_t)a1, "\"lateral\":%s,", v193, v194, v195, v196, v197, v198, (size_t)"true");
  if (*(_BYTE *)(a2 + 185))
    appendStringInfo((uint64_t)a1, "\"inh\":%s,", v193, v194, v195, v196, v197, v198, (size_t)"true");
  if (*(_BYTE *)(a2 + 186))
    appendStringInfo((uint64_t)a1, "\"inFromCl\":%s,", v193, v194, v195, v196, v197, v198, (size_t)"true");
  if (*(_DWORD *)(a2 + 188))
    appendStringInfo((uint64_t)a1, "\"requiredPerms\":%u,", v193, v194, v195, v196, v197, v198, *(unsigned int *)(a2 + 188));
  if (*(_DWORD *)(a2 + 192))
    appendStringInfo((uint64_t)a1, "\"checkAsUser\":%u,", v193, v194, v195, v196, v197, v198, *(unsigned int *)(a2 + 192));
  if (bms_is_empty(*(unsigned int **)(a2 + 200)))
  {
    if (bms_is_empty(*(unsigned int **)(a2 + 208)))
      goto LABEL_176;
  }
  else
  {
    appendStringInfo((uint64_t)a1, "\"selectedCols\":[", v229, v230, v231, v232, v233, v234, v326);
    member = bms_next_member(*(int **)(a2 + 200), 0);
    if ((member & 0x80000000) == 0)
    {
      v273 = member;
      do
      {
        appendStringInfo((uint64_t)a1, "%d,", v267, v268, v269, v270, v271, v272, v273);
        v273 = bms_next_member(*(int **)(a2 + 200), v273);
      }
      while ((v273 & 0x80000000) == 0);
    }
    v274 = a1[2];
    v32 = __OFSUB__(v274, 1);
    v275 = (v274 - 1);
    if ((int)v275 < 0 == v32)
    {
      v276 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v275) == 44)
      {
        a1[2] = v275;
        *(_BYTE *)(v276 + v275) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "],", v267, v268, v269, v270, v271, v272, v331);
    if (bms_is_empty(*(unsigned int **)(a2 + 208)))
    {
LABEL_176:
      if (bms_is_empty(*(unsigned int **)(a2 + 216)))
        goto LABEL_177;
      goto LABEL_206;
    }
  }
  appendStringInfo((uint64_t)a1, "\"insertedCols\":[", v235, v236, v237, v238, v239, v240, v326);
  v277 = bms_next_member(*(int **)(a2 + 208), 0);
  if ((v277 & 0x80000000) == 0)
  {
    v284 = v277;
    do
    {
      appendStringInfo((uint64_t)a1, "%d,", v278, v279, v280, v281, v282, v283, v284);
      v284 = bms_next_member(*(int **)(a2 + 208), v284);
    }
    while ((v284 & 0x80000000) == 0);
  }
  v285 = a1[2];
  v32 = __OFSUB__(v285, 1);
  v286 = (v285 - 1);
  if ((int)v286 < 0 == v32)
  {
    v287 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v286) == 44)
    {
      a1[2] = v286;
      *(_BYTE *)(v287 + v286) = 0;
    }
  }
  appendStringInfo((uint64_t)a1, "],", v278, v279, v280, v281, v282, v283, v332);
  if (bms_is_empty(*(unsigned int **)(a2 + 216)))
  {
LABEL_177:
    result = bms_is_empty(*(unsigned int **)(a2 + 224));
    if ((result & 1) != 0)
      goto LABEL_178;
    goto LABEL_213;
  }
LABEL_206:
  appendStringInfo((uint64_t)a1, "\"updatedCols\":[", v241, v242, v243, v244, v245, v246, v326);
  v288 = bms_next_member(*(int **)(a2 + 216), 0);
  if ((v288 & 0x80000000) == 0)
  {
    v295 = v288;
    do
    {
      appendStringInfo((uint64_t)a1, "%d,", v289, v290, v291, v292, v293, v294, v295);
      v295 = bms_next_member(*(int **)(a2 + 216), v295);
    }
    while ((v295 & 0x80000000) == 0);
  }
  v296 = a1[2];
  v32 = __OFSUB__(v296, 1);
  v297 = (v296 - 1);
  if ((int)v297 < 0 == v32)
  {
    v298 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v297) == 44)
    {
      a1[2] = v297;
      *(_BYTE *)(v298 + v297) = 0;
    }
  }
  appendStringInfo((uint64_t)a1, "],", v289, v290, v291, v292, v293, v294, v333);
  result = bms_is_empty(*(unsigned int **)(a2 + 224));
  if ((result & 1) != 0)
  {
LABEL_178:
    if (!*(_QWORD *)(a2 + 232))
      return result;
    goto LABEL_179;
  }
LABEL_213:
  appendStringInfo((uint64_t)a1, "\"extraUpdatedCols\":[", v248, v249, v250, v251, v252, v253, v326);
  v299 = bms_next_member(*(int **)(a2 + 224), 0);
  if ((v299 & 0x80000000) == 0)
  {
    v306 = v299;
    do
    {
      appendStringInfo((uint64_t)a1, "%d,", v300, v301, v302, v303, v304, v305, v306);
      v306 = bms_next_member(*(int **)(a2 + 224), v306);
    }
    while ((v306 & 0x80000000) == 0);
  }
  v307 = a1[2];
  v32 = __OFSUB__(v307, 1);
  v308 = (v307 - 1);
  if ((int)v308 < 0 == v32)
  {
    v309 = *(_QWORD *)a1;
    if (*(_BYTE *)(*(_QWORD *)a1 + v308) == 44)
    {
      a1[2] = v308;
      *(_BYTE *)(v309 + v308) = 0;
    }
  }
  result = appendStringInfo((uint64_t)a1, "],", v300, v301, v302, v303, v304, v305, v334);
  if (*(_QWORD *)(a2 + 232))
  {
LABEL_179:
    appendStringInfo((uint64_t)a1, "\"securityQuals\":", v248, v249, v250, v251, v252, v253, v326);
    appendStringInfoChar((uint64_t)a1, 91);
    v260 = *(_QWORD *)(a2 + 232);
    if (v260 && *(int *)(v260 + 4) >= 1)
    {
      v261 = 0;
      v262 = 8;
      do
      {
        v263 = *(_QWORD *)(v260 + 16);
        v264 = *(_QWORD *)(v263 + 8 * v261);
        if (v264)
          _outNode(a1, v264);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v263 + v262)
          v265 = v263 + v262 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 232) + 16)
                                                 + 8 * *(int *)(*(_QWORD *)(a2 + 232) + 4));
        else
          v265 = 1;
        if (!v265)
          appendStringInfoString((uint64_t)a1, ",");
        ++v261;
        v262 += 8;
      }
      while (v261 < *(int *)(v260 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v254, v255, v256, v257, v258, v259, a9);
  }
  return result;
}

unint64_t _outRangeTblFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  BOOL v64;
  unint64_t result;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t member;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  BOOL v81;
  uint64_t v82;
  uint64_t v83;
  size_t v84;
  size_t v85;
  size_t v86;
  size_t v87;
  size_t v88;
  size_t v89;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"funcexpr\":", a3, a4, a5, a6, a7, a8, v84);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    appendStringInfo(a1, ",", v11, v12, v13, v14, v15, v16, v85);
  }
  if (*(_DWORD *)(a2 + 16))
    appendStringInfo(a1, "\"funccolcount\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"funccolnames\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    v23 = *(_QWORD *)(a2 + 24);
    if (v23 && *(int *)(v23 + 4) >= 1)
    {
      v24 = 0;
      v25 = 8;
      do
      {
        v26 = *(_QWORD *)(v23 + 16);
        v27 = *(_QWORD *)(v26 + 8 * v24);
        if (v27)
          _outNode(a1, v27);
        else
          appendStringInfoString(a1, "{}");
        if (v26 + v25)
          v28 = v26 + v25 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v28 = 1;
        if (!v28)
          appendStringInfoString(a1, ",");
        ++v24;
        v25 += 8;
      }
      while (v24 < *(int *)(v23 + 4));
    }
    appendStringInfo(a1, "],", v17, v18, v19, v20, v21, v22, v86);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(a1, "\"funccoltypes\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    v35 = *(_QWORD *)(a2 + 32);
    if (v35 && *(int *)(v35 + 4) >= 1)
    {
      v36 = 0;
      v37 = 8;
      do
      {
        v38 = *(_QWORD *)(v35 + 16);
        v39 = *(_QWORD *)(v38 + 8 * v36);
        if (v39)
          _outNode(a1, v39);
        else
          appendStringInfoString(a1, "{}");
        if (v38 + v37)
          v40 = v38 + v37 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v40 = 1;
        if (!v40)
          appendStringInfoString(a1, ",");
        ++v36;
        v37 += 8;
      }
      while (v36 < *(int *)(v35 + 4));
    }
    appendStringInfo(a1, "],", v29, v30, v31, v32, v33, v34, v87);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(a1, "\"funccoltypmods\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    v47 = *(_QWORD *)(a2 + 40);
    if (v47 && *(int *)(v47 + 4) >= 1)
    {
      v48 = 0;
      v49 = 8;
      do
      {
        v50 = *(_QWORD *)(v47 + 16);
        v51 = *(_QWORD *)(v50 + 8 * v48);
        if (v51)
          _outNode(a1, v51);
        else
          appendStringInfoString(a1, "{}");
        if (v50 + v49)
          v52 = v50 + v49 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 40) + 4));
        else
          v52 = 1;
        if (!v52)
          appendStringInfoString(a1, ",");
        ++v48;
        v49 += 8;
      }
      while (v48 < *(int *)(v47 + 4));
    }
    appendStringInfo(a1, "],", v41, v42, v43, v44, v45, v46, v88);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo(a1, "\"funccolcollations\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    v59 = *(_QWORD *)(a2 + 48);
    if (v59 && *(int *)(v59 + 4) >= 1)
    {
      v60 = 0;
      v61 = 8;
      do
      {
        v62 = *(_QWORD *)(v59 + 16);
        v63 = *(_QWORD *)(v62 + 8 * v60);
        if (v63)
          _outNode(a1, v63);
        else
          appendStringInfoString(a1, "{}");
        if (v62 + v61)
          v64 = v62 + v61 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 48) + 4));
        else
          v64 = 1;
        if (!v64)
          appendStringInfoString(a1, ",");
        ++v60;
        v61 += 8;
      }
      while (v60 < *(int *)(v59 + 4));
    }
    appendStringInfo(a1, "],", v53, v54, v55, v56, v57, v58, v89);
  }
  result = bms_is_empty(*(unsigned int **)(a2 + 56));
  if ((result & 1) == 0)
  {
    appendStringInfo(a1, "\"funcparams\":[", v66, v67, v68, v69, v70, v71, v84);
    member = bms_next_member(*(int **)(a2 + 56), 0);
    if ((member & 0x80000000) == 0)
    {
      v79 = member;
      do
      {
        appendStringInfo(a1, "%d,", v73, v74, v75, v76, v77, v78, v79);
        v79 = bms_next_member(*(int **)(a2 + 56), v79);
      }
      while ((v79 & 0x80000000) == 0);
    }
    v80 = *(_DWORD *)(a1 + 8);
    v81 = __OFSUB__(v80, 1);
    v82 = (v80 - 1);
    if ((int)v82 < 0 == v81)
    {
      v83 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v82) == 44)
      {
        *(_DWORD *)(a1 + 8) = v82;
        *(_BYTE *)(v83 + v82) = 0;
      }
    }
    return appendStringInfo(a1, "],", v73, v74, v75, v76, v77, v78, a9);
  }
  return result;
}

uint64_t _outTableSampleClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  size_t v30;

  v10 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"tsmhandler\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v10, "\"args\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    v17 = *(_QWORD *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v18 = 0;
      v19 = 8;
      do
      {
        v20 = *(_QWORD *)(v17 + 16);
        v21 = *(_QWORD *)(v20 + 8 * v18);
        if (v21)
          _outNode(v10, v21);
        else
          appendStringInfoString(v10, "{}");
        if (v20 + v19)
          v22 = v20 + v19 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v22 = 1;
        if (!v22)
          appendStringInfoString(v10, ",");
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"repeatable\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(_QWORD *)(a2 + 16));
    return appendStringInfo(v10, ",", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outWithCheckOption(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  size_t v49;
  size_t v50;
  size_t v51;
  size_t v52;

  v10 = *(int *)(a2 + 4);
  if (v10 > 3)
    v11 = 0;
  else
    v11 = (&off_1E264B5B0)[v10];
  result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relname\":", v13, v14, v15, v16, v17, v18, v49);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v50);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"polname\":", v13, v14, v15, v16, v17, v18, v49);
    _outToken(a1, *(char **)(a2 + 16), v31, v32, v33, v34, v35, v36);
    result = appendStringInfo((uint64_t)a1, ",", v37, v38, v39, v40, v41, v42, v51);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"qual\":", v13, v14, v15, v16, v17, v18, v49);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    result = appendStringInfo((uint64_t)a1, ",", v43, v44, v45, v46, v47, v48, v52);
  }
  if (*(_BYTE *)(a2 + 32))
    return appendStringInfo((uint64_t)a1, "\"cascaded\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  return result;
}

uint64_t _outSortGroupClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"tleSortGroupRef\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"eqop\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(v9, "\"sortop\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfo(v9, "\"nulls_first\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 17))
    return appendStringInfo(v9, "\"hashable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

unint64_t _outGroupingSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  size_t v31;
  size_t v32;

  v10 = *(int *)(a2 + 4);
  if (v10 > 4)
    v11 = 0;
  else
    v11 = (&off_1E264B5D0)[v10];
  result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"content\":", v13, v14, v15, v16, v17, v18, v31);
    appendStringInfoChar(a1, 91);
    v25 = *(_QWORD *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      v26 = 0;
      v27 = 8;
      do
      {
        v28 = *(_QWORD *)(v25 + 16);
        v29 = *(_QWORD *)(v28 + 8 * v26);
        if (v29)
          _outNode(a1, v29);
        else
          appendStringInfoString(a1, "{}");
        if (v28 + v27)
          v30 = v28 + v27 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v30 = 1;
        if (!v30)
          appendStringInfoString(a1, ",");
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v32);
  }
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  return result;
}

uint64_t _outWindowClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  size_t v70;
  size_t v71;
  size_t v72;
  size_t v73;
  size_t v74;
  size_t v75;
  size_t v76;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v71);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"refname\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v72);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"partitionClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v40 = *(_QWORD *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString((uint64_t)v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v73);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"orderClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    v52 = *(_QWORD *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      v53 = 0;
      v54 = 8;
      do
      {
        v55 = *(_QWORD *)(v52 + 16);
        v56 = *(_QWORD *)(v55 + 8 * v53);
        if (v56)
          _outNode(v9, v56);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v55 + v54)
          v57 = v55 + v54 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v57 = 1;
        if (!v57)
          appendStringInfoString((uint64_t)v9, ",");
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v74);
  }
  if (*(_DWORD *)(a2 + 40))
    result = appendStringInfo((uint64_t)v9, "\"frameOptions\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  if (*(_QWORD *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v9, "\"startOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(_QWORD *)(a2 + 48));
    result = appendStringInfo((uint64_t)v9, ",", v58, v59, v60, v61, v62, v63, v75);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"endOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(_QWORD *)(a2 + 56));
    result = appendStringInfo((uint64_t)v9, ",", v64, v65, v66, v67, v68, v69, v76);
  }
  if (*(_DWORD *)(a2 + 64))
    result = appendStringInfo((uint64_t)v9, "\"startInRangeFunc\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 64));
  if (*(_DWORD *)(a2 + 68))
    result = appendStringInfo((uint64_t)v9, "\"endInRangeFunc\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 68));
  if (*(_DWORD *)(a2 + 72))
    result = appendStringInfo((uint64_t)v9, "\"inRangeColl\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 72));
  if (*(_BYTE *)(a2 + 76))
    result = appendStringInfo((uint64_t)v9, "\"inRangeAsc\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 77))
    result = appendStringInfo((uint64_t)v9, "\"inRangeNullsFirst\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_DWORD *)(a2 + 80))
    result = appendStringInfo((uint64_t)v9, "\"winref\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 80));
  if (*(_BYTE *)(a2 + 84))
    return appendStringInfo((uint64_t)v9, "\"copiedOrder\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outObjectWithArgs(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  size_t v34;
  size_t v35;
  size_t v36;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"objname\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v35);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"objargs\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString(v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(_BYTE *)(a2 + 24))
    return appendStringInfo(v9, "\"args_unspecified\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outAccessPriv(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  size_t v35;
  size_t v36;

  v10 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"priv_name\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"cols\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(v10, v33);
        else
          appendStringInfoString((uint64_t)v10, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)v10, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outCreateOpClassItem(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  size_t v66;
  size_t v67;
  size_t v68;
  size_t v69;

  v10 = result;
  if (*(_DWORD *)(a2 + 4))
    result = appendStringInfo(result, "\"itemtype\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(v10, "\"name\":{", a3, a4, a5, a6, a7, a8, v66);
    _outObjectWithArgs(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v67);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v10, "\"number\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v10, "\"order_family\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    v33 = *(_QWORD *)(a2 + 24);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      v34 = 0;
      v35 = 8;
      do
      {
        v36 = *(_QWORD *)(v33 + 16);
        v37 = *(_QWORD *)(v36 + 8 * v34);
        if (v37)
          _outNode(v10, v37);
        else
          appendStringInfoString(v10, "{}");
        if (v36 + v35)
          v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v38 = 1;
        if (!v38)
          appendStringInfoString(v10, ",");
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    result = appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, v68);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v10, "\"class_args\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    v45 = *(_QWORD *)(a2 + 32);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      v46 = 0;
      v47 = 8;
      do
      {
        v48 = *(_QWORD *)(v45 + 16);
        v49 = *(_QWORD *)(v48 + 8 * v46);
        if (v49)
          _outNode(v10, v49);
        else
          appendStringInfoString(v10, "{}");
        if (v48 + v47)
          v50 = v48 + v47 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v50 = 1;
        if (!v50)
          appendStringInfoString(v10, ",");
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    result = appendStringInfo(v10, "],", v39, v40, v41, v42, v43, v44, v69);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    appendStringInfo(v10, "\"storedtype\":{", a3, a4, a5, a6, a7, a8, v66);
    _outTypeName(v10, *(_QWORD *)(a2 + 40), v51, v52, v53, v54, v55, v56);
    v63 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v63, 1);
    v64 = (v63 - 1);
    if ((int)v64 < 0 == v24)
    {
      v65 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v64) == 44)
      {
        *(_DWORD *)(v10 + 8) = v64;
        *(_BYTE *)(v65 + v64) = 0;
      }
    }
    return appendStringInfo(v10, "},", v57, v58, v59, v60, v61, v62, a9);
  }
  return result;
}

uint64_t _outTableLikeClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  size_t v27;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v26);
    _outRangeVar(v9, *(_QWORD *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    v22 = *(_DWORD *)(v9 + 8);
    v23 = __OFSUB__(v22, 1);
    v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      v25 = *(_QWORD *)v9;
      if (*(_BYTE *)(*(_QWORD *)v9 + v24) == 44)
      {
        *(_DWORD *)(v9 + 8) = v24;
        *(_BYTE *)(v25 + v24) = 0;
      }
    }
    result = appendStringInfo(v9, "},", v16, v17, v18, v19, v20, v21, v27);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v9, "\"options\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_DWORD *)(a2 + 20))
    return appendStringInfo(v9, "\"relationOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  return result;
}

unint64_t _outFunctionParameter(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  unint64_t result;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t v53;
  size_t v54;
  size_t v55;
  size_t v56;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", a3, a4, a5, a6, a7, a8, v53);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v54);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"argType\":{", a3, a4, a5, a6, a7, a8, v53);
    _outTypeName((uint64_t)a1, *(_QWORD *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    v35 = a1[2];
    v36 = __OFSUB__(v35, 1);
    v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      v38 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v37) == 44)
      {
        a1[2] = v37;
        *(_BYTE *)(v38 + v37) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v29, v30, v31, v32, v33, v34, v55);
  }
  v39 = "FUNC_PARAM_IN";
  switch(*(_DWORD *)(a2 + 24))
  {
    case 'b':
      v39 = "FUNC_PARAM_INOUT";
      break;
    case 'i':
      break;
    case 'o':
      v39 = "FUNC_PARAM_OUT";
      break;
    case 't':
      v39 = "FUNC_PARAM_TABLE";
      break;
    case 'v':
      v39 = "FUNC_PARAM_VARIADIC";
      break;
    default:
      v39 = 0;
      break;
  }
  result = appendStringInfo((uint64_t)a1, "\"mode\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v39);
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"defexpr\":", v41, v42, v43, v44, v45, v46, v56);
    _outNode(a1, *(_QWORD *)(a2 + 32));
    return appendStringInfo((uint64_t)a1, ",", v47, v48, v49, v50, v51, v52, a9);
  }
  return result;
}

unint64_t _outLockingClause(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  size_t v33;
  size_t v34;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"lockedRels\":", a3, a4, a5, a6, a7, a8, v33);
    appendStringInfoChar(a1, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(a1, v20);
        else
          appendStringInfoString(a1, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(a1, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v34);
  }
  v22 = *(int *)(a2 + 16);
  if (v22 > 4)
    v23 = 0;
  else
    v23 = (&off_1E264B5F8)[v22];
  appendStringInfo(a1, "\"strength\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  v30 = *(int *)(a2 + 20);
  if (v30 > 2)
    v31 = 0;
  else
    v31 = (&off_1E264B620)[v30];
  return appendStringInfo(a1, "\"waitPolicy\":\"%s\",", v24, v25, v26, v27, v28, v29, (size_t)v31);
}

unint64_t _outRowMarkClause(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (*(_DWORD *)(a2 + 4))
    appendStringInfo(a1, "\"rti\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  v10 = *(int *)(a2 + 8);
  if (v10 > 4)
    v11 = 0;
  else
    v11 = (&off_1E264B5F8)[v10];
  appendStringInfo(a1, "\"strength\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  v18 = *(int *)(a2 + 12);
  if (v18 > 2)
    v19 = 0;
  else
    v19 = (&off_1E264B620)[v18];
  result = appendStringInfo(a1, "\"waitPolicy\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(_BYTE *)(a2 + 16))
    return appendStringInfo(a1, "\"pushedDown\":%s,", v21, v22, v23, v24, v25, v26, (size_t)"true");
  return result;
}

unint64_t _outXmlSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  const char *v11;
  const char *v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  size_t v43;
  size_t v44;

  v10 = *(_DWORD *)(a2 + 4);
  v11 = "XMLOPTION_CONTENT";
  if (v10 != 1)
    v11 = 0;
  if (v10)
    v12 = v11;
  else
    v12 = "XMLOPTION_DOCUMENT";
  result = appendStringInfo(a1, "\"xmloption\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"expr\":", v14, v15, v16, v17, v18, v19, v42);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(a1, ",", v20, v21, v22, v23, v24, v25, v43);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"typeName\":{", v14, v15, v16, v17, v18, v19, v42);
    _outTypeName(a1, *(_QWORD *)(a2 + 16), v26, v27, v28, v29, v30, v31);
    v38 = *(_DWORD *)(a1 + 8);
    v39 = __OFSUB__(v38, 1);
    v40 = (v38 - 1);
    if ((int)v40 < 0 == v39)
    {
      v41 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v40) == 44)
      {
        *(_DWORD *)(a1 + 8) = v40;
        *(_BYTE *)(v41 + v40) = 0;
      }
    }
    result = appendStringInfo(a1, "},", v32, v33, v34, v35, v36, v37, v44);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo(a1, "\"location\":%d,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outWithClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  size_t v23;

  v9 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"ctes\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfo(v9, "\"recursive\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_DWORD *)(a2 + 20))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  return result;
}

uint64_t _outInferClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  size_t v41;
  size_t v42;
  size_t v43;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"indexElems\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar((uint64_t)v9, 91);
    v16 = *(_QWORD *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 8) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString((uint64_t)v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v41);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v40);
    _outNode(v9, *(_QWORD *)(a2 + 16));
    result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v42);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"conname\":", a3, a4, a5, a6, a7, a8, v40);
    _outToken(v9, *(char **)(a2 + 24), v28, v29, v30, v31, v32, v33);
    result = appendStringInfo((uint64_t)v9, ",", v34, v35, v36, v37, v38, v39, v43);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  return result;
}

unint64_t _outOnConflictClause(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t v53;
  size_t v54;
  size_t v55;
  size_t v56;

  v10 = *(int *)(a2 + 4);
  if (v10 > 2)
    v11 = 0;
  else
    v11 = (&off_1E264B638)[v10];
  result = appendStringInfo(a1, "\"action\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"infer\":{", v13, v14, v15, v16, v17, v18, v53);
    _outInferClause(a1, *(_QWORD *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    v31 = *(_DWORD *)(a1 + 8);
    v32 = __OFSUB__(v31, 1);
    v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      v34 = *(_QWORD *)a1;
      if (*(_BYTE *)(*(_QWORD *)a1 + v33) == 44)
      {
        *(_DWORD *)(a1 + 8) = v33;
        *(_BYTE *)(v34 + v33) = 0;
      }
    }
    result = appendStringInfo(a1, "},", v25, v26, v27, v28, v29, v30, v54);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(a1, "\"targetList\":", v13, v14, v15, v16, v17, v18, v53);
    appendStringInfoChar(a1, 91);
    v41 = *(_QWORD *)(a2 + 16);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      v42 = 0;
      v43 = 8;
      do
      {
        v44 = *(_QWORD *)(v41 + 16);
        v45 = *(_QWORD *)(v44 + 8 * v42);
        if (v45)
          _outNode(a1, v45);
        else
          appendStringInfoString(a1, "{}");
        if (v44 + v43)
          v46 = v44 + v43 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v46 = 1;
        if (!v46)
          appendStringInfoString(a1, ",");
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    result = appendStringInfo(a1, "],", v35, v36, v37, v38, v39, v40, v55);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(a1, "\"whereClause\":", v13, v14, v15, v16, v17, v18, v53);
    _outNode(a1, *(_QWORD *)(a2 + 24));
    result = appendStringInfo(a1, ",", v47, v48, v49, v50, v51, v52, v56);
  }
  if (*(_DWORD *)(a2 + 32))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 32));
  return result;
}

unint64_t _outCommonTableExpr(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  char *v36;
  unint64_t result;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  BOOL v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  BOOL v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  BOOL v97;
  size_t v98;
  size_t v99;
  size_t v100;
  size_t v101;
  size_t v102;
  size_t v103;
  size_t v104;
  size_t v105;

  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"ctename\":", a3, a4, a5, a6, a7, a8, v98);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v99);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"aliascolnames\":", a3, a4, a5, a6, a7, a8, v98);
    appendStringInfoChar((uint64_t)a1, 91);
    v29 = *(_QWORD *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      v30 = 0;
      v31 = 8;
      do
      {
        v32 = *(_QWORD *)(v29 + 16);
        v33 = *(_QWORD *)(v32 + 8 * v30);
        if (v33)
          _outNode(a1, v33);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v32 + v31)
          v34 = v32 + v31 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v34 = 1;
        if (!v34)
          appendStringInfoString((uint64_t)a1, ",");
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v23, v24, v25, v26, v27, v28, v100);
  }
  v35 = *(int *)(a2 + 24);
  if (v35 > 2)
    v36 = 0;
  else
    v36 = (&off_1E264B650)[v35];
  result = appendStringInfo((uint64_t)a1, "\"ctematerialized\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v36);
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"ctequery\":", v38, v39, v40, v41, v42, v43, v101);
    _outNode(a1, *(_QWORD *)(a2 + 32));
    result = appendStringInfo((uint64_t)a1, ",", v44, v45, v46, v47, v48, v49, v102);
  }
  if (*(_DWORD *)(a2 + 40))
    result = appendStringInfo((uint64_t)a1, "\"location\":%d,", v38, v39, v40, v41, v42, v43, *(unsigned int *)(a2 + 40));
  if (*(_BYTE *)(a2 + 44))
    result = appendStringInfo((uint64_t)a1, "\"cterecursive\":%s,", v38, v39, v40, v41, v42, v43, (size_t)"true");
  if (*(_DWORD *)(a2 + 48))
    result = appendStringInfo((uint64_t)a1, "\"cterefcount\":%d,", v38, v39, v40, v41, v42, v43, *(unsigned int *)(a2 + 48));
  if (*(_QWORD *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"ctecolnames\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    v56 = *(_QWORD *)(a2 + 56);
    if (v56 && *(int *)(v56 + 4) >= 1)
    {
      v57 = 0;
      v58 = 8;
      do
      {
        v59 = *(_QWORD *)(v56 + 16);
        v60 = *(_QWORD *)(v59 + 8 * v57);
        if (v60)
          _outNode(a1, v60);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v59 + v58)
          v61 = v59 + v58 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 56) + 4));
        else
          v61 = 1;
        if (!v61)
          appendStringInfoString((uint64_t)a1, ",");
        ++v57;
        v58 += 8;
      }
      while (v57 < *(int *)(v56 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v50, v51, v52, v53, v54, v55, v103);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"ctecoltypes\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    v68 = *(_QWORD *)(a2 + 64);
    if (v68 && *(int *)(v68 + 4) >= 1)
    {
      v69 = 0;
      v70 = 8;
      do
      {
        v71 = *(_QWORD *)(v68 + 16);
        v72 = *(_QWORD *)(v71 + 8 * v69);
        if (v72)
          _outNode(a1, v72);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v71 + v70)
          v73 = v71 + v70 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 64) + 4));
        else
          v73 = 1;
        if (!v73)
          appendStringInfoString((uint64_t)a1, ",");
        ++v69;
        v70 += 8;
      }
      while (v69 < *(int *)(v68 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v62, v63, v64, v65, v66, v67, v104);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"ctecoltypmods\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    v80 = *(_QWORD *)(a2 + 72);
    if (v80 && *(int *)(v80 + 4) >= 1)
    {
      v81 = 0;
      v82 = 8;
      do
      {
        v83 = *(_QWORD *)(v80 + 16);
        v84 = *(_QWORD *)(v83 + 8 * v81);
        if (v84)
          _outNode(a1, v84);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v83 + v82)
          v85 = v83 + v82 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 72) + 4));
        else
          v85 = 1;
        if (!v85)
          appendStringInfoString((uint64_t)a1, ",");
        ++v81;
        v82 += 8;
      }
      while (v81 < *(int *)(v80 + 4));
    }
    result = appendStringInfo((uint64_t)a1, "],", v74, v75, v76, v77, v78, v79, v105);
  }
  if (*(_QWORD *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"ctecolcollations\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    v92 = *(_QWORD *)(a2 + 80);
    if (v92 && *(int *)(v92 + 4) >= 1)
    {
      v93 = 0;
      v94 = 8;
      do
      {
        v95 = *(_QWORD *)(v92 + 16);
        v96 = *(_QWORD *)(v95 + 8 * v93);
        if (v96)
          _outNode(a1, v96);
        else
          appendStringInfoString((uint64_t)a1, "{}");
        if (v95 + v94)
          v97 = v95 + v94 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 80) + 4));
        else
          v97 = 1;
        if (!v97)
          appendStringInfoString((uint64_t)a1, ",");
        ++v93;
        v94 += 8;
      }
      while (v93 < *(int *)(v92 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v86, v87, v88, v89, v90, v91, a9);
  }
  return result;
}

unint64_t _outRoleSpec(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  size_t v32;

  v10 = *(int *)(a2 + 4);
  if (v10 > 3)
    v11 = 0;
  else
    v11 = (&off_1E264B668)[v10];
  result = appendStringInfo((uint64_t)a1, "\"roletype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"rolename\":", v13, v14, v15, v16, v17, v18, v31);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v32);
  }
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo((uint64_t)a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  return result;
}

uint64_t _outTriggerTransition(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  size_t v23;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(_BYTE *)(a2 + 16))
    result = appendStringInfo((uint64_t)v9, "\"isNew\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 17))
    return appendStringInfo((uint64_t)v9, "\"isTable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

uint64_t _outPartitionElem(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  size_t v52;
  size_t v53;
  size_t v54;
  size_t v55;
  size_t v56;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v52);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v53);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"expr\":", a3, a4, a5, a6, a7, a8, v52);
    _outNode(v9, *(_QWORD *)(a2 + 16));
    result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v54);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"collation\":", a3, a4, a5, a6, a7, a8, v52);
    appendStringInfoChar((uint64_t)v9, 91);
    v34 = *(_QWORD *)(a2 + 24);
    if (v34 && *(int *)(v34 + 4) >= 1)
    {
      v35 = 0;
      v36 = 8;
      do
      {
        v37 = *(_QWORD *)(v34 + 16);
        v38 = *(_QWORD *)(v37 + 8 * v35);
        if (v38)
          _outNode(v9, v38);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v37 + v36)
          v39 = v37 + v36 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v39 = 1;
        if (!v39)
          appendStringInfoString((uint64_t)v9, ",");
        ++v35;
        v36 += 8;
      }
      while (v35 < *(int *)(v34 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v28, v29, v30, v31, v32, v33, v55);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"opclass\":", a3, a4, a5, a6, a7, a8, v52);
    appendStringInfoChar((uint64_t)v9, 91);
    v46 = *(_QWORD *)(a2 + 32);
    if (v46 && *(int *)(v46 + 4) >= 1)
    {
      v47 = 0;
      v48 = 8;
      do
      {
        v49 = *(_QWORD *)(v46 + 16);
        v50 = *(_QWORD *)(v49 + 8 * v47);
        if (v50)
          _outNode(v9, v50);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v49 + v48)
          v51 = v49 + v48 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v51 = 1;
        if (!v51)
          appendStringInfoString((uint64_t)v9, ",");
        ++v47;
        v48 += 8;
      }
      while (v47 < *(int *)(v46 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v40, v41, v42, v43, v44, v45, v56);
  }
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  return result;
}

uint64_t _outPartitionSpec(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  size_t v34;
  size_t v35;
  size_t v36;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"strategy\":", a3, a4, a5, a6, a7, a8, v34);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v35);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"partParams\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar((uint64_t)v9, 91);
    v28 = *(_QWORD *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString((uint64_t)v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString((uint64_t)v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(_DWORD *)(a2 + 24))
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  return result;
}

uint64_t _outPartitionBoundSpec(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  size_t v46;
  size_t v47;
  size_t v48;
  size_t v49;

  v9 = result;
  if (*(_BYTE *)(a2 + 4))
    result = appendStringInfo(result, "\"strategy\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 4));
  if (*(_BYTE *)(a2 + 5))
    result = appendStringInfo(v9, "\"is_default\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_DWORD *)(a2 + 8))
    result = appendStringInfo(v9, "\"modulus\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 12))
    result = appendStringInfo(v9, "\"remainder\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v9, "\"listdatums\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v16 = *(_QWORD *)(a2 + 16);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      v17 = 0;
      v18 = 8;
      do
      {
        v19 = *(_QWORD *)(v16 + 16);
        v20 = *(_QWORD *)(v19 + 8 * v17);
        if (v20)
          _outNode(v9, v20);
        else
          appendStringInfoString(v9, "{}");
        if (v19 + v18)
          v21 = v19 + v18 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 16) + 4));
        else
          v21 = 1;
        if (!v21)
          appendStringInfoString(v9, ",");
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v9, "\"lowerdatums\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v28 = *(_QWORD *)(a2 + 24);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      v29 = 0;
      v30 = 8;
      do
      {
        v31 = *(_QWORD *)(v28 + 16);
        v32 = *(_QWORD *)(v31 + 8 * v29);
        if (v32)
          _outNode(v9, v32);
        else
          appendStringInfoString(v9, "{}");
        if (v31 + v30)
          v33 = v31 + v30 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v33 = 1;
        if (!v33)
          appendStringInfoString(v9, ",");
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    appendStringInfo(v9, "\"upperdatums\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    v40 = *(_QWORD *)(a2 + 32);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      v41 = 0;
      v42 = 8;
      do
      {
        v43 = *(_QWORD *)(v40 + 16);
        v44 = *(_QWORD *)(v43 + 8 * v41);
        if (v44)
          _outNode(v9, v44);
        else
          appendStringInfoString(v9, "{}");
        if (v43 + v42)
          v45 = v43 + v42 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 32) + 4));
        else
          v45 = 1;
        if (!v45)
          appendStringInfoString(v9, ",");
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_DWORD *)(a2 + 40))
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  return result;
}

unint64_t _outPartitionRangeDatum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  char *v11;
  unint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;

  v10 = *(_DWORD *)(a2 + 4) + 1;
  if (v10 > 2)
    v11 = 0;
  else
    v11 = (&off_1E264B688)[v10];
  result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(a1, "\"value\":", v13, v14, v15, v16, v17, v18, v25);
    _outNode(a1, *(_QWORD *)(a2 + 8));
    result = appendStringInfo(a1, ",", v19, v20, v21, v22, v23, v24, v26);
  }
  if (*(_DWORD *)(a2 + 16))
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  return result;
}

uint64_t _outPartitionCmd(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  size_t v42;
  size_t v43;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":{", a3, a4, a5, a6, a7, a8, v42);
    _outRangeVar(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v43);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    appendStringInfo(v10, "\"bound\":{", a3, a4, a5, a6, a7, a8, v42);
    _outPartitionBoundSpec(v10, *(_QWORD *)(a2 + 16), v27, v28, v29, v30, v31, v32);
    v39 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v39, 1);
    v40 = (v39 - 1);
    if ((int)v40 < 0 == v24)
    {
      v41 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v40) == 44)
      {
        *(_DWORD *)(v10 + 8) = v40;
        *(_BYTE *)(v41 + v40) = 0;
      }
    }
    return appendStringInfo(v10, "},", v33, v34, v35, v36, v37, v38, a9);
  }
  return result;
}

uint64_t _outVacuumRelation(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  size_t v39;
  size_t v40;

  v10 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v39);
    _outRangeVar(v10, *(_QWORD *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    v23 = *(_DWORD *)(v10 + 8);
    v24 = __OFSUB__(v23, 1);
    v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      v26 = *(_QWORD *)v10;
      if (*(_BYTE *)(*(_QWORD *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(_BYTE *)(v26 + v25) = 0;
      }
    }
    result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo(v10, "\"oid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_QWORD *)(a2 + 24))
  {
    appendStringInfo(v10, "\"va_cols\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    v33 = *(_QWORD *)(a2 + 24);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      v34 = 0;
      v35 = 8;
      do
      {
        v36 = *(_QWORD *)(v33 + 16);
        v37 = *(_QWORD *)(v36 + 8 * v34);
        if (v37)
          _outNode(v10, v37);
        else
          appendStringInfoString(v10, "{}");
        if (v36 + v35)
          v38 = v36 + v35 >= (unint64_t)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16)
                                              + 8 * *(int *)(*(_QWORD *)(a2 + 24) + 4));
        else
          v38 = 1;
        if (!v38)
          appendStringInfoString(v10, ",");
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    return appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, a9);
  }
  return result;
}

uint64_t _outInlineCodeBlock(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  size_t v23;

  v9 = (int *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    appendStringInfo(result, "\"source_text\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(_DWORD *)(a2 + 16))
    result = appendStringInfo((uint64_t)v9, "\"langOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  if (*(_BYTE *)(a2 + 20))
    result = appendStringInfo((uint64_t)v9, "\"langIsTrusted\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  if (*(_BYTE *)(a2 + 21))
    return appendStringInfo((uint64_t)v9, "\"atomic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  return result;
}

int *_outToken(int *result, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  int v12;
  char v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;

  v8 = (uint64_t)result;
  if (!a2)
    return (int *)appendStringInfoString((uint64_t)result, "null");
  v10 = result[2];
  if ((int)v10 + 1 >= result[3])
  {
    result = (int *)appendStringInfoChar((uint64_t)result, 34);
    v13 = *a2;
    if (!*a2)
      goto LABEL_25;
LABEL_7:
    v14 = a2 + 1;
    while (2)
    {
      switch(v13)
      {
        case 8:
          v15 = v8;
          v16 = "\\b";
          goto LABEL_9;
        case 9:
          v15 = v8;
          v16 = "\\t";
          goto LABEL_9;
        case 10:
          v15 = v8;
          v16 = "\\n";
          goto LABEL_9;
        case 11:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
          goto LABEL_15;
        case 12:
          v15 = v8;
          v16 = "\\f";
          goto LABEL_9;
        case 13:
          v15 = v8;
          v16 = "\\r";
          goto LABEL_9;
        case 34:
          v15 = v8;
          v16 = "\\\"";
          goto LABEL_9;
        default:
          if (v13 == 92)
          {
            v15 = v8;
            v16 = "\\\\";
LABEL_9:
            result = (int *)appendStringInfoString(v15, v16);
          }
          else
          {
LABEL_15:
            if (v13 < 0x20u || (v13 | 2) == 0x3E)
            {
              result = (int *)appendStringInfo(v8, "\\u%04x", a3, a4, a5, a6, a7, a8, v13);
            }
            else
            {
              v18 = *(int *)(v8 + 8);
              if ((int)v18 + 1 >= *(_DWORD *)(v8 + 12))
              {
                result = (int *)appendStringInfoChar(v8, v13);
              }
              else
              {
                *(_BYTE *)(*(_QWORD *)v8 + v18) = v13;
                v19 = *(_QWORD *)v8;
                v20 = *(_DWORD *)(v8 + 8) + 1;
                *(_DWORD *)(v8 + 8) = v20;
                *(_BYTE *)(v19 + v20) = 0;
              }
            }
          }
          v17 = *v14++;
          v13 = v17;
          if (v17)
            continue;
          goto LABEL_25;
      }
    }
  }
  *(_BYTE *)(*(_QWORD *)result + v10) = 34;
  v11 = *(_QWORD *)result;
  v12 = result[2] + 1;
  result[2] = v12;
  *(_BYTE *)(v11 + v12) = 0;
  v13 = *a2;
  if (*a2)
    goto LABEL_7;
LABEL_25:
  v21 = *(int *)(v8 + 8);
  if ((int)v21 + 1 >= *(_DWORD *)(v8 + 12))
    return (int *)appendStringInfoChar(v8, 34);
  *(_BYTE *)(*(_QWORD *)v8 + v21) = 34;
  v22 = *(_QWORD *)v8;
  v23 = *(_DWORD *)(v8 + 8) + 1;
  *(_DWORD *)(v8 + 8) = v23;
  *(_BYTE *)(v22 + v23) = 0;
  return result;
}

size_t pg_query_nodes_to_protobuf(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t packed_size;
  void *v17;
  uint64_t v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v20 = xmmword_1E264B6A0;
  v21 = *(_OWORD *)algn_1E264B6B0;
  v22 = xmmword_1E264B6C0;
  DWORD2(v21) = 130003;
  if (a1)
  {
    *(_QWORD *)&v22 = *(int *)(a1 + 4);
    v2 = palloc(8 * v22);
    *((_QWORD *)&v22 + 1) = v2;
    if (*(int *)(a1 + 4) >= 1)
    {
      v3 = v2;
      v4 = 0;
      do
      {
        v5 = *(_QWORD *)(a1 + 16);
        v6 = palloc(0x28uLL);
        *(_QWORD *)(v3 + 8 * v4) = v6;
        pg_query__raw_stmt__init(v6);
        v7 = *(_QWORD *)(v3 + 8 * v4);
        v8 = *(_QWORD *)(v5 + 8 * v4);
        if (*(_QWORD *)(v8 + 8))
        {
          v9 = palloc(0x28uLL);
          pg_query__node__init(v9);
          *(_QWORD *)(v7 + 24) = v9;
          _outNode_0(v9, *(unsigned int **)(v8 + 8), v10, v11, v12, v13, v14, v15);
        }
        *(_DWORD *)(v7 + 32) = *(_DWORD *)(v8 + 16);
        *(_DWORD *)(v7 + 36) = *(_DWORD *)(v8 + 20);
        ++v4;
      }
      while (v4 < *(int *)(a1 + 4));
    }
  }
  else
  {
    v22 = 0uLL;
  }
  packed_size = pg_query__parse_result__get_packed_size((void **)&v20);
  v17 = malloc_type_malloc(packed_size, 0x100004077774924uLL);
  pg_query__parse_result__pack((void **)&v20, (uint64_t)v17, v18);
  return packed_size;
}

uint64_t _outRawStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 24) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 32) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 36) = *(_DWORD *)(a2 + 20);
  return result;
}

void _outNode_0(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _OWORD *v10;
  int v11;
  _OWORD *v12;
  _OWORD *v13;
  uint64_t v14;
  _DWORD *v15;
  _DWORD *v16;
  _OWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD *v23;
  _OWORD *v24;
  _OWORD *v25;
  uint64_t v26;
  _OWORD *v27;
  _OWORD *v28;
  uint64_t v29;
  _OWORD *v30;
  uint64_t v31;
  _OWORD *v32;
  _OWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _OWORD *v37;
  _OWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _OWORD *v42;
  uint64_t v43;
  _OWORD *v44;
  uint64_t v45;
  _OWORD *v46;
  _OWORD *v47;
  uint64_t v48;
  _OWORD *v49;
  _OWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  _OWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _OWORD *v60;
  _OWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _DWORD *v72;
  _OWORD *v73;
  _OWORD *v74;
  _OWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _OWORD *v80;
  _OWORD *v81;
  _OWORD *v82;
  _OWORD *v83;
  uint64_t v84;
  const char *v85;
  _OWORD *v86;
  _OWORD *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _OWORD *v91;
  _OWORD *v92;
  uint64_t v93;
  _OWORD *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _OWORD *v99;
  uint64_t v100;
  uint64_t v101;
  const char *v102;
  uint64_t v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  _OWORD *v110;
  uint64_t v111;
  _OWORD *v112;
  _OWORD *v113;
  const char *v114;
  _OWORD *v115;
  uint64_t v116;
  _OWORD *v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  unsigned int v121;
  int v122;
  uint64_t v123;
  _OWORD *v124;
  uint64_t v125;
  const char *v126;
  _OWORD *v127;
  _OWORD *v128;
  _OWORD *v129;
  uint64_t v130;
  uint64_t v131;
  _OWORD *v132;
  _OWORD *v133;
  uint64_t v134;
  _OWORD *v135;
  _OWORD *v136;
  uint64_t v137;
  _OWORD *v138;
  _OWORD *v139;
  uint64_t v140;
  _QWORD *v141;
  _OWORD *v142;
  uint64_t v143;
  const char *v144;
  _OWORD *v145;
  _OWORD *v146;
  uint64_t v147;
  const char *v148;
  char *v149;
  _OWORD *v150;
  _QWORD *v151;
  _OWORD *v152;
  uint64_t v153;
  _OWORD *v154;
  _OWORD *v155;
  _OWORD *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  _OWORD *v161;
  _OWORD *v162;
  _OWORD *v163;
  _OWORD *v164;
  _OWORD *v165;
  _OWORD *v166;
  _QWORD *v167;
  _OWORD *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  _QWORD *v172;
  uint64_t v173;
  uint64_t v174;
  _OWORD *v175;
  _OWORD *v176;
  _QWORD *v177;
  uint64_t v178;
  char *v179;
  uint64_t v180;
  char *v181;
  uint64_t v182;
  _QWORD *v183;
  _OWORD *v184;
  _QWORD *v185;
  uint64_t v186;
  uint64_t v187;
  _QWORD *v188;
  _OWORD *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  _OWORD *v194;
  uint64_t v195;
  _OWORD *v196;
  uint64_t v197;
  uint64_t v198;
  _OWORD *v199;
  uint64_t v200;
  _OWORD *v201;
  _OWORD *v202;
  _OWORD *v203;
  _OWORD *v204;
  uint64_t v205;
  _OWORD *v206;
  uint64_t v207;
  _OWORD *v208;
  uint64_t v209;
  char *v210;
  _OWORD *v211;
  _OWORD *v212;
  _OWORD *v213;
  uint64_t v214;
  uint64_t v215;
  _OWORD *v216;
  uint64_t v217;
  void *v218;
  uint64_t v219;
  void *v220;
  uint64_t v221;
  uint64_t v222;
  _OWORD *v223;
  uint64_t v224;
  uint64_t v225;
  _OWORD *v226;
  _OWORD *v227;
  _OWORD *v228;
  uint64_t v229;
  char *v230;
  uint64_t v231;
  _OWORD *v232;
  _DWORD *v233;
  uint64_t v234;
  _OWORD *v235;
  _OWORD *v236;
  uint64_t v237;
  _OWORD *v238;
  _OWORD *v239;
  uint64_t v240;
  const char *v241;
  _OWORD *v242;
  uint64_t v243;
  _BYTE *v244;
  _OWORD *v245;
  char *v246;
  uint64_t v247;
  _OWORD *v248;
  uint64_t v249;

  if (a2)
  {
    switch(*a2)
    {
      case 0x66u:
        v10 = (_OWORD *)palloc(0x30uLL);
        pg_query__alias__init(v10);
        _outAlias_0(v10, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v10;
        v11 = 1;
        goto LABEL_88;
      case 0x67u:
        v12 = (_OWORD *)palloc(0x50uLL);
        pg_query__range_var__init(v12);
        _outRangeVar_0((uint64_t)v12, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v12;
        v11 = 2;
        goto LABEL_88;
      case 0x68u:
        v13 = (_OWORD *)palloc(0xC0uLL);
        pg_query__table_func__init(v13);
        _outTableFunc_0((uint64_t)v13, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v13;
        v11 = 3;
        goto LABEL_88;
      case 0x69u:
        v14 = palloc(0x18uLL);
        pg_query__expr__init(v14);
        *(_QWORD *)(a1 + 32) = v14;
        v11 = 4;
        goto LABEL_88;
      case 0x6Au:
        v15 = (_DWORD *)palloc(0x48uLL);
        pg_query__var__init((uint64_t)v15);
        _outVar_0(v15, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v15;
        v11 = 5;
        goto LABEL_88;
      case 0x6Cu:
        v16 = (_DWORD *)palloc(0x38uLL);
        pg_query__param__init((uint64_t)v16);
        _outParam_0(v16, a2);
        *(_QWORD *)(a1 + 32) = v16;
        v11 = 6;
        goto LABEL_88;
      case 0x6Du:
        v17 = (_OWORD *)palloc(0xB0uLL);
        pg_query__aggref__init(v17);
        _outAggref_0((uint64_t)v17, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v17;
        v11 = 7;
        goto LABEL_88;
      case 0x6Eu:
        v18 = palloc(0x58uLL);
        pg_query__grouping_func__init(v18);
        _outGroupingFunc_0(v18, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v18;
        v11 = 8;
        goto LABEL_88;
      case 0x6Fu:
        v19 = palloc(0x58uLL);
        pg_query__window_func__init(v19);
        _outWindowFunc_0(v19, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v19;
        v11 = 9;
        goto LABEL_88;
      case 0x70u:
        v20 = (_OWORD *)palloc(0x60uLL);
        pg_query__subscripting_ref__init(v20);
        _outSubscriptingRef_0((uint64_t)v20, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v20;
        v11 = 10;
        goto LABEL_88;
      case 0x71u:
        v21 = palloc(0x58uLL);
        pg_query__func_expr__init(v21);
        _outFuncExpr_0(v21, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v21;
        v11 = 11;
        goto LABEL_88;
      case 0x72u:
        v22 = palloc(0x38uLL);
        pg_query__named_arg_expr__init(v22);
        _outNamedArgExpr_0(v22, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v22;
        v11 = 12;
        goto LABEL_88;
      case 0x73u:
        v23 = (_OWORD *)palloc(0x50uLL);
        pg_query__op_expr__init(v23);
        _outOpExpr_0((uint64_t)v23, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v23;
        v11 = 13;
        goto LABEL_88;
      case 0x74u:
        v24 = (_OWORD *)palloc(0x50uLL);
        pg_query__distinct_expr__init(v24);
        _outOpExpr_0((uint64_t)v24, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v24;
        v11 = 14;
        goto LABEL_88;
      case 0x75u:
        v25 = (_OWORD *)palloc(0x50uLL);
        pg_query__null_if_expr__init(v25);
        _outOpExpr_0((uint64_t)v25, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v25;
        v11 = 15;
        goto LABEL_88;
      case 0x76u:
        v26 = palloc(0x48uLL);
        pg_query__scalar_array_op_expr__init(v26);
        _outScalarArrayOpExpr_0(v26, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v26;
        v11 = 16;
        goto LABEL_88;
      case 0x77u:
        v27 = (_OWORD *)palloc(0x40uLL);
        pg_query__BOOL_expr__init(v27);
        _outBoolExpr_0((uint64_t)v27, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v27;
        v11 = 17;
        goto LABEL_88;
      case 0x78u:
        v28 = (_OWORD *)palloc(0x50uLL);
        pg_query__sub_link__init(v28);
        _outSubLink_0((uint64_t)v28, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v28;
        v11 = 18;
        goto LABEL_88;
      case 0x79u:
        v29 = palloc(0xA8uLL);
        pg_query__sub_plan__init(v29);
        _outSubPlan_0(v29, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v29;
        v11 = 19;
        goto LABEL_88;
      case 0x7Au:
        v30 = (_OWORD *)palloc(0x30uLL);
        pg_query__alternative_sub_plan__init(v30);
        _outAlternativeSubPlan_0((uint64_t)v30, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v30;
        v11 = 20;
        goto LABEL_88;
      case 0x7Bu:
        v31 = palloc(0x38uLL);
        pg_query__field_select__init(v31);
        _outFieldSelect_0(v31, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v31;
        v11 = 21;
        goto LABEL_88;
      case 0x7Cu:
        v32 = (_OWORD *)palloc(0x50uLL);
        pg_query__field_store__init(v32);
        _outFieldStore_0((uint64_t)v32, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v32;
        v11 = 22;
        goto LABEL_88;
      case 0x7Du:
        v33 = (_OWORD *)palloc(0x40uLL);
        pg_query__relabel_type__init(v33);
        _outRelabelType_0((uint64_t)v33, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v33;
        v11 = 23;
        goto LABEL_88;
      case 0x7Eu:
        v34 = palloc(0x38uLL);
        pg_query__coerce_via_io__init(v34);
        _outCoerceViaIO_0(v34, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v34;
        v11 = 24;
        goto LABEL_88;
      case 0x7Fu:
        v35 = palloc(0x48uLL);
        pg_query__array_coerce_expr__init(v35);
        _outArrayCoerceExpr_0(v35, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v35;
        v11 = 25;
        goto LABEL_88;
      case 0x80u:
        v36 = palloc(0x38uLL);
        pg_query__convert_rowtype_expr__init(v36);
        _outConvertRowtypeExpr_0(v36, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v36;
        v11 = 26;
        goto LABEL_88;
      case 0x81u:
        v37 = (_OWORD *)palloc(0x30uLL);
        pg_query__collate_expr__init(v37);
        _outCollateExpr_0((uint64_t)v37, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v37;
        v11 = 27;
        goto LABEL_88;
      case 0x82u:
        v38 = (_OWORD *)palloc(0x50uLL);
        pg_query__case_expr__init(v38);
        _outCaseExpr_0((uint64_t)v38, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v38;
        v11 = 28;
        goto LABEL_88;
      case 0x83u:
        v39 = palloc(0x38uLL);
        pg_query__case_when__init(v39);
        _outCaseWhen_0(v39, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v39;
        v11 = 29;
        goto LABEL_88;
      case 0x84u:
        v40 = palloc(0x30uLL);
        pg_query__case_test_expr__init((_OWORD *)v40);
        *(_DWORD *)(v40 + 32) = a2[1];
        *(_DWORD *)(v40 + 36) = a2[2];
        *(_DWORD *)(v40 + 40) = a2[3];
        *(_QWORD *)(a1 + 32) = v40;
        v11 = 30;
        goto LABEL_88;
      case 0x85u:
        v41 = palloc(0x48uLL);
        pg_query__array_expr__init(v41);
        _outArrayExpr_0(v41, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v41;
        v11 = 31;
        goto LABEL_88;
      case 0x86u:
        v42 = (_OWORD *)palloc(0x50uLL);
        pg_query__row_expr__init(v42);
        _outRowExpr_0((uint64_t)v42, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v42;
        v11 = 32;
        goto LABEL_88;
      case 0x87u:
        v43 = palloc(0x78uLL);
        pg_query__row_compare_expr__init(v43);
        _outRowCompareExpr_0(v43, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v43;
        v11 = 33;
        goto LABEL_88;
      case 0x88u:
        v44 = (_OWORD *)palloc(0x40uLL);
        pg_query__coalesce_expr__init(v44);
        _outCoalesceExpr_0((uint64_t)v44, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v44;
        v11 = 34;
        goto LABEL_88;
      case 0x89u:
        v45 = palloc(0x48uLL);
        pg_query__min_max_expr__init(v45);
        _outMinMaxExpr_0(v45, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v45;
        v11 = 35;
        goto LABEL_88;
      case 0x8Au:
        v46 = (_OWORD *)palloc(0x30uLL);
        pg_query__sqlvalue_function__init(v46);
        _outSQLValueFunction_0(v46, a2);
        *(_QWORD *)(a1 + 32) = v46;
        v11 = 36;
        goto LABEL_88;
      case 0x8Bu:
        v47 = (_OWORD *)palloc(0x70uLL);
        pg_query__xml_expr__init(v47);
        _outXmlExpr_0((uint64_t)v47, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v47;
        v11 = 37;
        goto LABEL_88;
      case 0x8Cu:
        v48 = palloc(0x38uLL);
        pg_query__null_test__init(v48);
        _outNullTest_0(v48, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v48;
        v11 = 38;
        goto LABEL_88;
      case 0x8Du:
        v49 = (_OWORD *)palloc(0x30uLL);
        pg_query__BOOLean_test__init(v49);
        _outBooleanTest_0((uint64_t)v49, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v49;
        v11 = 39;
        goto LABEL_88;
      case 0x8Eu:
        v50 = (_OWORD *)palloc(0x40uLL);
        pg_query__coerce_to_domain__init(v50);
        _outRelabelType_0((uint64_t)v50, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v50;
        v11 = 40;
        goto LABEL_88;
      case 0x8Fu:
        v51 = palloc(0x30uLL);
        pg_query__coerce_to_domain_value__init((_OWORD *)v51);
        *(_DWORD *)(v51 + 32) = a2[1];
        *(_DWORD *)(v51 + 36) = a2[2];
        *(_DWORD *)(v51 + 40) = a2[3];
        *(_DWORD *)(v51 + 44) = a2[4];
        *(_QWORD *)(a1 + 32) = v51;
        v11 = 41;
        goto LABEL_88;
      case 0x90u:
        v52 = palloc(0x30uLL);
        pg_query__set_to_default__init((_OWORD *)v52);
        *(_DWORD *)(v52 + 32) = a2[1];
        *(_DWORD *)(v52 + 36) = a2[2];
        *(_DWORD *)(v52 + 40) = a2[3];
        *(_DWORD *)(v52 + 44) = a2[4];
        *(_QWORD *)(a1 + 32) = v52;
        v11 = 42;
        goto LABEL_88;
      case 0x91u:
        v53 = palloc(0x38uLL);
        pg_query__current_of_expr__init(v53);
        *(_DWORD *)(v53 + 32) = a2[1];
        v54 = (const char *)*((_QWORD *)a2 + 1);
        if (v54)
          *(_QWORD *)(v53 + 40) = pstrdup(v54);
        *(_DWORD *)(v53 + 48) = a2[4];
        *(_QWORD *)(a1 + 32) = v53;
        v11 = 43;
        goto LABEL_88;
      case 0x92u:
        v55 = palloc(0x28uLL);
        pg_query__next_value_expr__init(v55);
        *(_DWORD *)(v55 + 32) = a2[1];
        *(_DWORD *)(v55 + 36) = a2[2];
        *(_QWORD *)(a1 + 32) = v55;
        v11 = 44;
        goto LABEL_88;
      case 0x93u:
        v56 = (_OWORD *)palloc(0x30uLL);
        pg_query__inference_elem__init(v56);
        _outCollateExpr_0((uint64_t)v56, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v56;
        v11 = 45;
        goto LABEL_88;
      case 0x94u:
        v57 = palloc(0x48uLL);
        pg_query__target_entry__init(v57);
        _outTargetEntry_0(v57, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v57;
        v11 = 46;
        goto LABEL_88;
      case 0x95u:
        v58 = palloc(0x20uLL);
        pg_query__range_tbl_ref__init((_OWORD *)v58);
        *(_DWORD *)(v58 + 24) = a2[1];
        *(_QWORD *)(a1 + 32) = v58;
        v11 = 47;
        goto LABEL_88;
      case 0x96u:
        v59 = palloc(0x58uLL);
        pg_query__join_expr__init(v59);
        _outJoinExpr_0(v59, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v59;
        v11 = 48;
        goto LABEL_88;
      case 0x97u:
        v60 = (_OWORD *)palloc(0x30uLL);
        pg_query__from_expr__init(v60);
        _outFromExpr_0((uint64_t)v60, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v60;
        v11 = 49;
        goto LABEL_88;
      case 0x98u:
        v61 = (_OWORD *)palloc(0x70uLL);
        pg_query__on_conflict_expr__init(v61);
        _outOnConflictExpr_0((uint64_t)v61, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v61;
        v11 = 50;
        goto LABEL_88;
      case 0x99u:
        v62 = palloc(0x68uLL);
        pg_query__into_clause__init(v62);
        _outIntoClause_0(v62, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v62;
        v11 = 51;
        goto LABEL_88;
      case 0xDDu:
        v63 = palloc(0x20uLL);
        pg_query__integer__init((_OWORD *)v63);
        *(_DWORD *)(v63 + 24) = a2[2];
        *(_QWORD *)(a1 + 32) = v63;
        v11 = 221;
        goto LABEL_88;
      case 0xDEu:
        v64 = palloc(0x20uLL);
        pg_query__float__init((_OWORD *)v64);
        *(_QWORD *)(v64 + 24) = *((_QWORD *)a2 + 1);
        *(_QWORD *)(a1 + 32) = v64;
        v11 = 222;
        goto LABEL_88;
      case 0xDFu:
        v65 = palloc(0x20uLL);
        pg_query__string__init((_OWORD *)v65);
        *(_QWORD *)(v65 + 24) = *((_QWORD *)a2 + 1);
        *(_QWORD *)(a1 + 32) = v65;
        v11 = 223;
        goto LABEL_88;
      case 0xE0u:
        v66 = palloc(0x20uLL);
        pg_query__bit_string__init((_OWORD *)v66);
        *(_QWORD *)(v66 + 24) = *((_QWORD *)a2 + 1);
        *(_QWORD *)(a1 + 32) = v66;
        v11 = 224;
        goto LABEL_88;
      case 0xE1u:
        v67 = palloc(0x18uLL);
        pg_query__null__init(v67);
        *(_QWORD *)(a1 + 32) = v67;
        v11 = 225;
        goto LABEL_88;
      case 0xE2u:
        v68 = palloc(0x28uLL);
        pg_query__list__init(v68);
        _outList_0(v68, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v68;
        v11 = 226;
        goto LABEL_88;
      case 0xE3u:
        v69 = palloc(0x28uLL);
        pg_query__int_list__init(v69);
        _outList_0(v69, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v69;
        v11 = 227;
        goto LABEL_88;
      case 0xE4u:
        v70 = palloc(0x28uLL);
        pg_query__oid_list__init(v70);
        _outList_0(v70, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v70;
        v11 = 228;
        goto LABEL_88;
      case 0xE6u:
        v71 = palloc(0x28uLL);
        pg_query__raw_stmt__init(v71);
        _outRawStmt_0(v71, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v71;
        v11 = 52;
        goto LABEL_88;
      case 0xE7u:
        v72 = (_DWORD *)palloc(0x160uLL);
        pg_query__query__init(v72);
        _outQuery_0(v72, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v72;
        v11 = 53;
        goto LABEL_88;
      case 0xE9u:
        v73 = (_OWORD *)palloc(0x60uLL);
        pg_query__insert_stmt__init(v73);
        _outInsertStmt_0((uint64_t)v73, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v73;
        v11 = 54;
        goto LABEL_88;
      case 0xEAu:
        v74 = (_OWORD *)palloc(0x50uLL);
        pg_query__delete_stmt__init(v74);
        _outDeleteStmt_0((uint64_t)v74, (uint64_t *)a2);
        *(_QWORD *)(a1 + 32) = v74;
        v11 = 55;
        goto LABEL_88;
      case 0xEBu:
        v75 = (_OWORD *)palloc(0x60uLL);
        pg_query__update_stmt__init(v75);
        _outUpdateStmt_0((uint64_t)v75, (uint64_t *)a2);
        *(_QWORD *)(a1 + 32) = v75;
        v11 = 56;
        goto LABEL_88;
      case 0xECu:
        v76 = palloc(0xE8uLL);
        pg_query__select_stmt__init(v76);
        _outSelectStmt_0(v76, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v76;
        v11 = 57;
        goto LABEL_88;
      case 0xEDu:
        v77 = palloc(0x38uLL);
        pg_query__alter_table_stmt__init(v77);
        _outAlterTableStmt_0(v77, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v77;
        v11 = 58;
        goto LABEL_88;
      case 0xEEu:
        v78 = palloc(0x48uLL);
        pg_query__alter_table_cmd__init(v78);
        _outAlterTableCmd_0(v78, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v78;
        v11 = 59;
        goto LABEL_88;
      case 0xEFu:
        v79 = palloc(0x48uLL);
        pg_query__alter_domain_stmt__init(v79);
        _outAlterDomainStmt_0(v79, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v79;
        v11 = 60;
        goto LABEL_88;
      case 0xF0u:
        v80 = (_OWORD *)palloc(0x70uLL);
        pg_query__set_operation_stmt__init(v80);
        _outSetOperationStmt_0((uint64_t)v80, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v80;
        v11 = 61;
        goto LABEL_88;
      case 0xF1u:
        v81 = (_OWORD *)palloc(0x60uLL);
        pg_query__grant_stmt__init(v81);
        _outGrantStmt_0((uint64_t)v81, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v81;
        v11 = 62;
        goto LABEL_88;
      case 0xF2u:
        v82 = (_OWORD *)palloc(0x50uLL);
        pg_query__grant_role_stmt__init(v82);
        _outGrantRoleStmt_0((uint64_t)v82, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v82;
        v11 = 63;
        goto LABEL_88;
      case 0xF3u:
        v83 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_default_privileges_stmt__init(v83);
        _outAlterDefaultPrivilegesStmt_0((uint64_t)v83, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v83;
        v11 = 64;
        goto LABEL_88;
      case 0xF4u:
        v84 = palloc(0x20uLL);
        pg_query__close_portal_stmt__init((_OWORD *)v84);
        v85 = (const char *)*((_QWORD *)a2 + 1);
        if (v85)
          *(_QWORD *)(v84 + 24) = pstrdup(v85);
        *(_QWORD *)(a1 + 32) = v84;
        v11 = 65;
        goto LABEL_88;
      case 0xF5u:
        v86 = (_OWORD *)palloc(0x30uLL);
        pg_query__cluster_stmt__init(v86);
        _outClusterStmt_0((uint64_t)v86, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v86;
        v11 = 66;
        goto LABEL_88;
      case 0xF6u:
        v87 = (_OWORD *)palloc(0x60uLL);
        pg_query__copy_stmt__init(v87);
        _outCopyStmt_0((uint64_t)v87, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v87;
        v11 = 67;
        goto LABEL_88;
      case 0xF7u:
        v88 = palloc(0x98uLL);
        pg_query__create_stmt__init(v88);
        _outCreateStmt_0(v88, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v88;
        v11 = 68;
        goto LABEL_88;
      case 0xF8u:
        v89 = palloc(0x58uLL);
        pg_query__define_stmt__init(v89);
        _outDefineStmt_0(v89, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v89;
        v11 = 69;
        goto LABEL_88;
      case 0xF9u:
        v90 = palloc(0x38uLL);
        pg_query__drop_stmt__init(v90);
        _outDropStmt_0(v90, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v90;
        v11 = 70;
        goto LABEL_88;
      case 0xFAu:
        v91 = (_OWORD *)palloc(0x30uLL);
        pg_query__truncate_stmt__init(v91);
        _outTruncateStmt_0((uint64_t)v91, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v91;
        v11 = 71;
LABEL_88:
        *(_DWORD *)(a1 + 24) = v11;
        break;
      case 0xFBu:
        v92 = (_OWORD *)palloc(0x30uLL);
        pg_query__comment_stmt__init(v92);
        _outCommentStmt_0((uint64_t)v92, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v92;
        *(_DWORD *)(a1 + 24) = 72;
        break;
      case 0xFCu:
        v93 = palloc(0x38uLL);
        pg_query__fetch_stmt__init(v93);
        _outFetchStmt_0(v93, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v93;
        *(_DWORD *)(a1 + 24) = 73;
        break;
      case 0xFDu:
        v94 = (_OWORD *)palloc(0xC0uLL);
        pg_query__index_stmt__init(v94);
        _outIndexStmt_0((uint64_t)v94, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v94;
        *(_DWORD *)(a1 + 24) = 74;
        break;
      case 0xFEu:
        v95 = palloc(0x58uLL);
        pg_query__create_function_stmt__init(v95);
        _outCreateFunctionStmt_0(v95, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v95;
        *(_DWORD *)(a1 + 24) = 75;
        break;
      case 0xFFu:
        v96 = palloc(0x38uLL);
        pg_query__alter_function_stmt__init(v96);
        _outAlterFunctionStmt_0(v96, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v96;
        *(_DWORD *)(a1 + 24) = 76;
        break;
      case 0x100u:
        v97 = palloc(0x28uLL);
        pg_query__do_stmt__init(v97);
        _outDoStmt_0(v97, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v97;
        *(_DWORD *)(a1 + 24) = 77;
        break;
      case 0x101u:
        v98 = palloc(0x48uLL);
        pg_query__rename_stmt__init(v98);
        _outRenameStmt_0(v98, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v98;
        *(_DWORD *)(a1 + 24) = 78;
        break;
      case 0x102u:
        v99 = (_OWORD *)palloc(0x50uLL);
        pg_query__rule_stmt__init(v99);
        _outRuleStmt_0((uint64_t)v99, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v99;
        *(_DWORD *)(a1 + 24) = 79;
        break;
      case 0x103u:
        v100 = palloc(0x28uLL);
        pg_query__notify_stmt__init(v100);
        _outNotifyStmt_0(v100, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v100;
        *(_DWORD *)(a1 + 24) = 80;
        break;
      case 0x104u:
        v101 = palloc(0x20uLL);
        pg_query__listen_stmt__init((_OWORD *)v101);
        v102 = (const char *)*((_QWORD *)a2 + 1);
        if (v102)
          *(_QWORD *)(v101 + 24) = pstrdup(v102);
        *(_QWORD *)(a1 + 32) = v101;
        *(_DWORD *)(a1 + 24) = 81;
        break;
      case 0x105u:
        v103 = palloc(0x20uLL);
        pg_query__unlisten_stmt__init((_OWORD *)v103);
        v104 = (const char *)*((_QWORD *)a2 + 1);
        if (v104)
          *(_QWORD *)(v103 + 24) = pstrdup(v104);
        *(_QWORD *)(a1 + 32) = v103;
        *(_DWORD *)(a1 + 24) = 82;
        break;
      case 0x106u:
        v105 = palloc(0x48uLL);
        pg_query__transaction_stmt__init(v105);
        _outTransactionStmt_0(v105, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v105;
        *(_DWORD *)(a1 + 24) = 83;
        break;
      case 0x107u:
        v106 = palloc(0x58uLL);
        pg_query__view_stmt__init(v106);
        _outViewStmt_0(v106, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v106;
        *(_DWORD *)(a1 + 24) = 84;
        break;
      case 0x108u:
        v107 = palloc(0x20uLL);
        pg_query__load_stmt__init((_OWORD *)v107);
        v108 = (const char *)*((_QWORD *)a2 + 1);
        if (v108)
          *(_QWORD *)(v107 + 24) = pstrdup(v108);
        *(_QWORD *)(a1 + 32) = v107;
        *(_DWORD *)(a1 + 24) = 85;
        break;
      case 0x109u:
        v109 = palloc(0x48uLL);
        pg_query__create_domain_stmt__init(v109);
        _outCreateDomainStmt_0(v109, a2);
        *(_QWORD *)(a1 + 32) = v109;
        *(_DWORD *)(a1 + 24) = 86;
        break;
      case 0x10Au:
        v110 = (_OWORD *)palloc(0x30uLL);
        pg_query__createdb_stmt__init(v110);
        _outAlias_0(v110, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v110;
        *(_DWORD *)(a1 + 24) = 87;
        break;
      case 0x10Bu:
        v111 = palloc(0x38uLL);
        pg_query__dropdb_stmt__init(v111);
        _outDropdbStmt_0(v111, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v111;
        *(_DWORD *)(a1 + 24) = 88;
        break;
      case 0x10Cu:
        v112 = (_OWORD *)palloc(0x40uLL);
        pg_query__vacuum_stmt__init(v112);
        _outVacuumStmt_0((uint64_t)v112, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v112;
        *(_DWORD *)(a1 + 24) = 89;
        break;
      case 0x10Du:
        v113 = (_OWORD *)palloc(0x30uLL);
        pg_query__explain_stmt__init(v113);
        _outExplainStmt_0((uint64_t)v113, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v113;
        *(_DWORD *)(a1 + 24) = 90;
        break;
      case 0x10Eu:
        v114 = (const char *)palloc(0x38uLL);
        pg_query__create_table_as_stmt__init((uint64_t)v114);
        _outCreateTableAsStmt_0(v114, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v114;
        *(_DWORD *)(a1 + 24) = 91;
        break;
      case 0x10Fu:
        v115 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_seq_stmt__init(v115);
        _outCreateSeqStmt_0((uint64_t)v115, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v115;
        *(_DWORD *)(a1 + 24) = 92;
        break;
      case 0x110u:
        v116 = palloc(0x38uLL);
        pg_query__alter_seq_stmt__init(v116);
        _outAlterSeqStmt_0(v116, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v116;
        *(_DWORD *)(a1 + 24) = 93;
        break;
      case 0x111u:
        v117 = (_OWORD *)palloc(0x40uLL);
        pg_query__variable_set_stmt__init(v117);
        _outVariableSetStmt_0((uint64_t)v117, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v117;
        *(_DWORD *)(a1 + 24) = 94;
        break;
      case 0x112u:
        v118 = palloc(0x20uLL);
        pg_query__variable_show_stmt__init((_OWORD *)v118);
        v119 = (const char *)*((_QWORD *)a2 + 1);
        if (v119)
          *(_QWORD *)(v118 + 24) = pstrdup(v119);
        *(_QWORD *)(a1 + 32) = v118;
        *(_DWORD *)(a1 + 24) = 95;
        break;
      case 0x113u:
        v120 = palloc(0x20uLL);
        pg_query__discard_stmt__init((_OWORD *)v120);
        v121 = a2[1];
        if (v121 < 4)
          v122 = v121 + 1;
        else
          v122 = -1;
        *(_DWORD *)(v120 + 24) = v122;
        *(_QWORD *)(a1 + 32) = v120;
        *(_DWORD *)(a1 + 24) = 96;
        break;
      case 0x114u:
        v123 = palloc(0x98uLL);
        pg_query__create_trig_stmt__init(v123);
        _outCreateTrigStmt_0(v123, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v123;
        *(_DWORD *)(a1 + 24) = 97;
        break;
      case 0x115u:
        v124 = (_OWORD *)palloc(0x60uLL);
        pg_query__create_plang_stmt__init(v124);
        _outCreatePLangStmt_0((uint64_t)v124, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v124;
        *(_DWORD *)(a1 + 24) = 98;
        break;
      case 0x116u:
        v125 = palloc(0x38uLL);
        pg_query__create_role_stmt__init(v125);
        _outCreateRoleStmt_0(v125, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v125;
        *(_DWORD *)(a1 + 24) = 99;
        break;
      case 0x117u:
        v126 = (const char *)palloc(0x38uLL);
        pg_query__alter_role_stmt__init((uint64_t)v126);
        _outAlterRoleStmt_0(v126, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v126;
        *(_DWORD *)(a1 + 24) = 100;
        break;
      case 0x118u:
        v127 = (_OWORD *)palloc(0x30uLL);
        pg_query__drop_role_stmt__init(v127);
        _outDropRoleStmt_0((uint64_t)v127, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v127;
        *(_DWORD *)(a1 + 24) = 101;
        break;
      case 0x119u:
        v128 = (_OWORD *)palloc(0x30uLL);
        pg_query__lock_stmt__init(v128);
        _outLockStmt_0((uint64_t)v128, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v128;
        *(_DWORD *)(a1 + 24) = 102;
        break;
      case 0x11Au:
        v129 = (_OWORD *)palloc(0x30uLL);
        pg_query__constraints_set_stmt__init(v129);
        _outDropRoleStmt_0((uint64_t)v129, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v129;
        *(_DWORD *)(a1 + 24) = 103;
        break;
      case 0x11Bu:
        v130 = palloc(0x38uLL);
        pg_query__reindex_stmt__init(v130);
        _outReindexStmt_0(v130, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v130;
        *(_DWORD *)(a1 + 24) = 104;
        break;
      case 0x11Cu:
        v131 = palloc(0x18uLL);
        pg_query__check_point_stmt__init(v131);
        *(_QWORD *)(a1 + 32) = v131;
        *(_DWORD *)(a1 + 24) = 105;
        break;
      case 0x11Du:
        v132 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_schema_stmt__init(v132);
        _outCreateSchemaStmt_0((uint64_t)v132, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v132;
        *(_DWORD *)(a1 + 24) = 106;
        break;
      case 0x11Eu:
        v133 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_database_stmt__init(v133);
        _outAlias_0(v133, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v133;
        *(_DWORD *)(a1 + 24) = 107;
        break;
      case 0x11Fu:
        v134 = palloc(0x28uLL);
        pg_query__alter_database_set_stmt__init(v134);
        _outAlterDatabaseSetStmt_0(v134, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v134;
        *(_DWORD *)(a1 + 24) = 108;
        break;
      case 0x120u:
        v135 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_role_set_stmt__init(v135);
        _outAlterRoleSetStmt_0(v135, a2);
        *(_QWORD *)(a1 + 32) = v135;
        *(_DWORD *)(a1 + 24) = 109;
        break;
      case 0x121u:
        v136 = (_OWORD *)palloc(0x50uLL);
        pg_query__create_conversion_stmt__init(v136);
        _outCreateConversionStmt_0((uint64_t)v136, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v136;
        *(_DWORD *)(a1 + 24) = 110;
        break;
      case 0x122u:
        v137 = palloc(0x38uLL);
        pg_query__create_cast_stmt__init(v137);
        _outCreateCastStmt_0(v137, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v137;
        *(_DWORD *)(a1 + 24) = 111;
        break;
      case 0x123u:
        v138 = (_OWORD *)palloc(0x60uLL);
        pg_query__create_op_class_stmt__init(v138);
        _outCreateOpClassStmt_0((uint64_t)v138, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v138;
        *(_DWORD *)(a1 + 24) = 112;
        break;
      case 0x124u:
        v139 = (_OWORD *)palloc(0x30uLL);
        pg_query__create_op_family_stmt__init(v139);
        _outCreateOpFamilyStmt_0(v139, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v139;
        *(_DWORD *)(a1 + 24) = 113;
        break;
      case 0x125u:
        v140 = palloc(0x48uLL);
        pg_query__alter_op_family_stmt__init(v140);
        _outAlterOpFamilyStmt_0(v140, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v140;
        *(_DWORD *)(a1 + 24) = 114;
        break;
      case 0x126u:
        v141 = (_QWORD *)palloc(0x38uLL);
        pg_query__prepare_stmt__init((uint64_t)v141);
        _outPrepareStmt_0(v141, a2);
        *(_QWORD *)(a1 + 32) = v141;
        *(_DWORD *)(a1 + 24) = 115;
        break;
      case 0x127u:
        v142 = (_OWORD *)palloc(0x30uLL);
        pg_query__execute_stmt__init(v142);
        _outAlias_0(v142, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v142;
        *(_DWORD *)(a1 + 24) = 116;
        break;
      case 0x128u:
        v143 = palloc(0x20uLL);
        pg_query__deallocate_stmt__init((_OWORD *)v143);
        v144 = (const char *)*((_QWORD *)a2 + 1);
        if (v144)
          *(_QWORD *)(v143 + 24) = pstrdup(v144);
        *(_QWORD *)(a1 + 32) = v143;
        *(_DWORD *)(a1 + 24) = 117;
        break;
      case 0x129u:
        v145 = (_OWORD *)palloc(0x30uLL);
        pg_query__declare_cursor_stmt__init(v145);
        _outDeclareCursorStmt_0((uint64_t)v145, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v145;
        *(_DWORD *)(a1 + 24) = 118;
        break;
      case 0x12Au:
        v146 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_table_space_stmt__init(v146);
        _outCreateTableSpaceStmt_0(v146, a2);
        *(_QWORD *)(a1 + 32) = v146;
        *(_DWORD *)(a1 + 24) = 119;
        break;
      case 0x12Bu:
        v147 = palloc(0x28uLL);
        pg_query__drop_table_space_stmt__init(v147);
        v148 = (const char *)*((_QWORD *)a2 + 1);
        if (v148)
          *(_QWORD *)(v147 + 24) = pstrdup(v148);
        *(_DWORD *)(v147 + 32) = *((unsigned __int8 *)a2 + 16);
        *(_QWORD *)(a1 + 32) = v147;
        *(_DWORD *)(a1 + 24) = 120;
        break;
      case 0x12Cu:
        v149 = (char *)palloc(0x40uLL);
        pg_query__alter_object_depends_stmt__init(v149);
        _outAlterObjectDependsStmt_0(v149, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v149;
        *(_DWORD *)(a1 + 24) = 121;
        break;
      case 0x12Du:
        v150 = (_OWORD *)palloc(0x40uLL);
        pg_query__alter_object_schema_stmt__init(v150);
        _outAlterObjectSchemaStmt_0((uint64_t)v150, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v150;
        *(_DWORD *)(a1 + 24) = 122;
        break;
      case 0x12Eu:
        v151 = (_QWORD *)palloc(0x38uLL);
        pg_query__alter_owner_stmt__init((uint64_t)v151);
        _outAlterOwnerStmt_0(v151, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v151;
        *(_DWORD *)(a1 + 24) = 123;
        break;
      case 0x12Fu:
        v152 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_operator_stmt__init(v152);
        _outAlterOperatorStmt_0((uint64_t)v152, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v152;
        *(_DWORD *)(a1 + 24) = 124;
        break;
      case 0x130u:
        v153 = palloc(0x38uLL);
        pg_query__alter_type_stmt__init(v153);
        _outAlterTypeStmt_0(v153, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v153;
        *(_DWORD *)(a1 + 24) = 125;
        break;
      case 0x131u:
        v154 = (_OWORD *)palloc(0x30uLL);
        pg_query__drop_owned_stmt__init(v154);
        _outDropOwnedStmt_0((uint64_t)v154, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v154;
        *(_DWORD *)(a1 + 24) = 126;
        break;
      case 0x132u:
        v155 = (_OWORD *)palloc(0x30uLL);
        pg_query__reassign_owned_stmt__init(v155);
        _outReassignOwnedStmt_0((uint64_t)v155, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v155;
        *(_DWORD *)(a1 + 24) = 127;
        break;
      case 0x133u:
        v156 = (_OWORD *)palloc(0x30uLL);
        pg_query__composite_type_stmt__init(v156);
        _outCompositeTypeStmt_0((uint64_t)v156, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v156;
        *(_DWORD *)(a1 + 24) = 128;
        break;
      case 0x134u:
        v157 = palloc(0x38uLL);
        pg_query__create_enum_stmt__init(v157);
        _outAlterTypeStmt_0(v157, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v157;
        *(_DWORD *)(a1 + 24) = 129;
        break;
      case 0x135u:
        v158 = palloc(0x38uLL);
        pg_query__create_range_stmt__init(v158);
        _outAlterTypeStmt_0(v158, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v158;
        *(_DWORD *)(a1 + 24) = 130;
        break;
      case 0x136u:
        v159 = palloc(0x48uLL);
        pg_query__alter_enum_stmt__init(v159);
        _outAlterEnumStmt_0(v159, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v159;
        *(_DWORD *)(a1 + 24) = 131;
        break;
      case 0x137u:
        v160 = palloc(0x38uLL);
        pg_query__alter_tsdictionary_stmt__init(v160);
        _outAlterTypeStmt_0(v160, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v160;
        *(_DWORD *)(a1 + 24) = 132;
        break;
      case 0x138u:
        v161 = (_OWORD *)palloc(0x60uLL);
        pg_query__alter_tsconfiguration_stmt__init(v161);
        _outAlterTSConfigurationStmt_0((uint64_t)v161, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v161;
        *(_DWORD *)(a1 + 24) = 133;
        break;
      case 0x139u:
        v162 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_fdw_stmt__init(v162);
        _outCreateFdwStmt_0(v162, a2);
        *(_QWORD *)(a1 + 32) = v162;
        *(_DWORD *)(a1 + 24) = 134;
        break;
      case 0x13Au:
        v163 = (_OWORD *)palloc(0x40uLL);
        pg_query__alter_fdw_stmt__init(v163);
        _outCreateFdwStmt_0(v163, a2);
        *(_QWORD *)(a1 + 32) = v163;
        *(_DWORD *)(a1 + 24) = 135;
        break;
      case 0x13Bu:
        v164 = (_OWORD *)palloc(0x50uLL);
        pg_query__create_foreign_server_stmt__init(v164);
        _outCreateForeignServerStmt_0((uint64_t)v164, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v164;
        *(_DWORD *)(a1 + 24) = 136;
        break;
      case 0x13Cu:
        v165 = (_OWORD *)palloc(0x40uLL);
        pg_query__alter_foreign_server_stmt__init(v165);
        _outAlterForeignServerStmt_0((uint64_t)v165, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v165;
        *(_DWORD *)(a1 + 24) = 137;
        break;
      case 0x13Du:
        v166 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_user_mapping_stmt__init(v166);
        _outCreateUserMappingStmt_0((uint64_t)v166, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v166;
        *(_DWORD *)(a1 + 24) = 138;
        break;
      case 0x13Eu:
        v167 = (_QWORD *)palloc(0x38uLL);
        pg_query__alter_user_mapping_stmt__init((uint64_t)v167);
        _outAlterUserMappingStmt_0(v167, a2);
        *(_QWORD *)(a1 + 32) = v167;
        *(_DWORD *)(a1 + 24) = 139;
        break;
      case 0x13Fu:
        v168 = (_OWORD *)palloc(0x30uLL);
        pg_query__drop_user_mapping_stmt__init(v168);
        _outDropUserMappingStmt_0((uint64_t)v168, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v168;
        *(_DWORD *)(a1 + 24) = 140;
        break;
      case 0x140u:
        v169 = palloc(0x38uLL);
        pg_query__alter_table_space_options_stmt__init(v169);
        _outAlterTableSpaceOptionsStmt_0(v169, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v169;
        *(_DWORD *)(a1 + 24) = 141;
        break;
      case 0x141u:
        v170 = palloc(0x48uLL);
        pg_query__alter_table_move_all_stmt__init(v170);
        _outAlterTableMoveAllStmt_0(v170, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v170;
        *(_DWORD *)(a1 + 24) = 142;
        break;
      case 0x142u:
        v171 = palloc(0x38uLL);
        pg_query__sec_label_stmt__init(v171);
        _outSecLabelStmt_0(v171, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v171;
        *(_DWORD *)(a1 + 24) = 143;
        break;
      case 0x143u:
        v172 = (_QWORD *)palloc(0x38uLL);
        pg_query__create_foreign_table_stmt__init((uint64_t)v172);
        _outCreateForeignTableStmt_0(v172, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v172;
        *(_DWORD *)(a1 + 24) = 144;
        break;
      case 0x144u:
        v173 = palloc(0x58uLL);
        pg_query__import_foreign_schema_stmt__init(v173);
        _outImportForeignSchemaStmt_0(v173, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v173;
        *(_DWORD *)(a1 + 24) = 145;
        break;
      case 0x145u:
        v174 = palloc(0x38uLL);
        pg_query__create_extension_stmt__init(v174);
        _outDropdbStmt_0(v174, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v174;
        *(_DWORD *)(a1 + 24) = 146;
        break;
      case 0x146u:
        v175 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_extension_stmt__init(v175);
        _outAlias_0(v175, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v175;
        *(_DWORD *)(a1 + 24) = 147;
        break;
      case 0x147u:
        v176 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_extension_contents_stmt__init(v176);
        _outAlterExtensionContentsStmt_0((uint64_t)v176, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v176;
        *(_DWORD *)(a1 + 24) = 148;
        break;
      case 0x148u:
        v177 = (_QWORD *)palloc(0x48uLL);
        pg_query__create_event_trig_stmt__init((uint64_t)v177);
        _outCreateEventTrigStmt_0(v177, a2);
        *(_QWORD *)(a1 + 32) = v177;
        *(_DWORD *)(a1 + 24) = 149;
        break;
      case 0x149u:
        v178 = palloc(0x28uLL);
        pg_query__alter_event_trig_stmt__init(v178);
        _outAlterEventTrigStmt_0(v178, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v178;
        *(_DWORD *)(a1 + 24) = 150;
        break;
      case 0x14Au:
        v179 = (char *)palloc(0x28uLL);
        pg_query__refresh_mat_view_stmt__init((uint64_t)v179);
        _outRefreshMatViewStmt_0(v179, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v179;
        *(_DWORD *)(a1 + 24) = 151;
        break;
      case 0x14Bu:
        v180 = palloc(0x28uLL);
        pg_query__replica_identity_stmt__init(v180);
        _outReplicaIdentityStmt_0(v180, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v180;
        *(_DWORD *)(a1 + 24) = 152;
        break;
      case 0x14Cu:
        v181 = (char *)palloc(0x20uLL);
        pg_query__alter_system_stmt__init(v181);
        _outAlterSystemStmt_0(v181, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v181;
        *(_DWORD *)(a1 + 24) = 153;
        break;
      case 0x14Du:
        v182 = palloc(0x58uLL);
        pg_query__create_policy_stmt__init(v182);
        _outCreatePolicyStmt_0(v182, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v182;
        *(_DWORD *)(a1 + 24) = 154;
        break;
      case 0x14Eu:
        v183 = (_QWORD *)palloc(0x48uLL);
        pg_query__alter_policy_stmt__init((uint64_t)v183);
        _outAlterPolicyStmt_0(v183, a2);
        *(_QWORD *)(a1 + 32) = v183;
        *(_DWORD *)(a1 + 24) = 155;
        break;
      case 0x14Fu:
        v184 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_transform_stmt__init(v184);
        _outCreateTransformStmt_0((uint64_t)v184, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v184;
        *(_DWORD *)(a1 + 24) = 156;
        break;
      case 0x150u:
        v185 = (_QWORD *)palloc(0x38uLL);
        pg_query__create_am_stmt__init((uint64_t)v185);
        _outCreateAmStmt_0(v185, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v185;
        *(_DWORD *)(a1 + 24) = 157;
        break;
      case 0x151u:
        v186 = palloc(0x48uLL);
        pg_query__create_publication_stmt__init(v186);
        _outCreatePublicationStmt_0(v186, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v186;
        *(_DWORD *)(a1 + 24) = 158;
        break;
      case 0x152u:
        v187 = palloc(0x48uLL);
        pg_query__alter_publication_stmt__init(v187);
        _outAlterPublicationStmt_0(v187, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v187;
        *(_DWORD *)(a1 + 24) = 159;
        break;
      case 0x153u:
        v188 = (_QWORD *)palloc(0x48uLL);
        pg_query__create_subscription_stmt__init((uint64_t)v188);
        _outCreateEventTrigStmt_0(v188, a2);
        *(_QWORD *)(a1 + 32) = v188;
        *(_DWORD *)(a1 + 24) = 160;
        break;
      case 0x154u:
        v189 = (_OWORD *)palloc(0x50uLL);
        pg_query__alter_subscription_stmt__init(v189);
        _outAlterSubscriptionStmt_0((uint64_t)v189, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v189;
        *(_DWORD *)(a1 + 24) = 161;
        break;
      case 0x155u:
        v190 = palloc(0x28uLL);
        pg_query__drop_subscription_stmt__init(v190);
        _outDropSubscriptionStmt_0(v190, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v190;
        *(_DWORD *)(a1 + 24) = 162;
        break;
      case 0x156u:
        v191 = palloc(0x68uLL);
        pg_query__create_stats_stmt__init(v191);
        _outCreateStatsStmt_0(v191, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v191;
        *(_DWORD *)(a1 + 24) = 163;
        break;
      case 0x157u:
        v192 = palloc(0x28uLL);
        pg_query__alter_collation_stmt__init(v192);
        _outDoStmt_0(v192, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v192;
        *(_DWORD *)(a1 + 24) = 164;
        break;
      case 0x158u:
        v193 = palloc(0x28uLL);
        pg_query__call_stmt__init(v193);
        _outCallStmt_0(v193, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v193;
        *(_DWORD *)(a1 + 24) = 165;
        break;
      case 0x159u:
        v194 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_stats_stmt__init(v194);
        _outLockStmt_0((uint64_t)v194, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v194;
        *(_DWORD *)(a1 + 24) = 166;
        break;
      case 0x15Au:
        v195 = palloc(0x48uLL);
        pg_query__a__expr__init(v195);
        _outAExpr_0(v195, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v195;
        *(_DWORD *)(a1 + 24) = 167;
        break;
      case 0x15Bu:
        v196 = (_OWORD *)palloc(0x30uLL);
        pg_query__column_ref__init(v196);
        _outColumnRef_0((uint64_t)v196, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v196;
        *(_DWORD *)(a1 + 24) = 168;
        break;
      case 0x15Cu:
        v197 = palloc(0x20uLL);
        pg_query__param_ref__init((_OWORD *)v197);
        *(_DWORD *)(v197 + 24) = a2[1];
        *(_DWORD *)(v197 + 28) = a2[2];
        *(_QWORD *)(a1 + 32) = v197;
        *(_DWORD *)(a1 + 24) = 169;
        break;
      case 0x15Du:
        v198 = palloc(0x28uLL);
        pg_query__a__const__init(v198);
        _outAConst_0(v198, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v198;
        *(_DWORD *)(a1 + 24) = 170;
        break;
      case 0x15Eu:
        v199 = (_OWORD *)palloc(0x70uLL);
        pg_query__func_call__init(v199);
        _outFuncCall_0((uint64_t)v199, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v199;
        *(_DWORD *)(a1 + 24) = 171;
        break;
      case 0x15Fu:
        v200 = palloc(0x18uLL);
        pg_query__a__star__init(v200);
        *(_QWORD *)(a1 + 32) = v200;
        *(_DWORD *)(a1 + 24) = 172;
        break;
      case 0x160u:
        v201 = (_OWORD *)palloc(0x30uLL);
        pg_query__a__indices__init(v201);
        _outAIndices_0((uint64_t)v201, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v201;
        *(_DWORD *)(a1 + 24) = 173;
        break;
      case 0x161u:
        v202 = (_OWORD *)palloc(0x30uLL);
        pg_query__a__indirection__init(v202);
        _outExplainStmt_0((uint64_t)v202, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v202;
        *(_DWORD *)(a1 + 24) = 174;
        break;
      case 0x162u:
        v203 = (_OWORD *)palloc(0x30uLL);
        pg_query__a__array_expr__init(v203);
        _outColumnRef_0((uint64_t)v203, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v203;
        *(_DWORD *)(a1 + 24) = 175;
        break;
      case 0x163u:
        v204 = (_OWORD *)palloc(0x40uLL);
        pg_query__res_target__init(v204);
        _outResTarget_0((uint64_t)v204, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v204;
        *(_DWORD *)(a1 + 24) = 176;
        break;
      case 0x164u:
        v205 = palloc(0x28uLL);
        pg_query__multi_assign_ref__init(v205);
        _outRawStmt_0(v205, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v205;
        *(_DWORD *)(a1 + 24) = 177;
        break;
      case 0x165u:
        v206 = (_OWORD *)palloc(0x30uLL);
        pg_query__type_cast__init(v206);
        _outTypeCast_0((uint64_t)v206, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v206;
        *(_DWORD *)(a1 + 24) = 178;
        break;
      case 0x166u:
        v207 = palloc(0x38uLL);
        pg_query__collate_clause__init(v207);
        _outCollateClause_0(v207, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v207;
        *(_DWORD *)(a1 + 24) = 179;
        break;
      case 0x167u:
        v208 = (_OWORD *)palloc(0x40uLL);
        pg_query__sort_by__init(v208);
        _outSortBy_0((uint64_t)v208, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v208;
        *(_DWORD *)(a1 + 24) = 180;
        break;
      case 0x168u:
        v209 = palloc(0x68uLL);
        pg_query__window_def__init(v209);
        _outWindowDef_0(v209, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v209;
        *(_DWORD *)(a1 + 24) = 181;
        break;
      case 0x169u:
        v210 = (char *)palloc(0x30uLL);
        pg_query__range_subselect__init(v210);
        _outRangeSubselect_0(v210, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v210;
        *(_DWORD *)(a1 + 24) = 182;
        break;
      case 0x16Au:
        v211 = (_OWORD *)palloc(0x50uLL);
        pg_query__range_function__init(v211);
        _outRangeFunction_0((uint64_t)v211, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v211;
        *(_DWORD *)(a1 + 24) = 183;
        break;
      case 0x16Bu:
        v212 = (_OWORD *)palloc(0x50uLL);
        pg_query__range_table_sample__init(v212);
        _outRangeTableSample_0((uint64_t)v212, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v212;
        *(_DWORD *)(a1 + 24) = 184;
        break;
      case 0x16Cu:
        v213 = (_OWORD *)palloc(0x60uLL);
        pg_query__range_table_func__init(v213);
        _outRangeTableFunc_0((uint64_t)v213, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v213;
        *(_DWORD *)(a1 + 24) = 185;
        break;
      case 0x16Du:
        v214 = palloc(0x48uLL);
        pg_query__range_table_func_col__init(v214);
        _outRangeTableFuncCol_0(v214, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v214;
        *(_DWORD *)(a1 + 24) = 186;
        break;
      case 0x16Eu:
        v215 = palloc(0x68uLL);
        pg_query__type_name__init(v215);
        _outTypeName_0(v215, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v215;
        *(_DWORD *)(a1 + 24) = 187;
        break;
      case 0x16Fu:
        v216 = (_OWORD *)palloc(0xA0uLL);
        pg_query__column_def__init(v216);
        _outColumnDef_0((uint64_t)v216, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v216;
        *(_DWORD *)(a1 + 24) = 188;
        break;
      case 0x170u:
        v217 = palloc(0x68uLL);
        pg_query__index_elem__init(v217);
        _outIndexElem_0(v217, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v217;
        *(_DWORD *)(a1 + 24) = 189;
        break;
      case 0x171u:
        v218 = (void *)palloc(0x118uLL);
        pg_query__constraint__init(v218);
        _outConstraint_0((uint64_t)v218, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v218;
        *(_DWORD *)(a1 + 24) = 190;
        break;
      case 0x172u:
        v219 = palloc(0x38uLL);
        pg_query__def_elem__init(v219);
        _outDefElem_0(v219, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v219;
        *(_DWORD *)(a1 + 24) = 191;
        break;
      case 0x173u:
        v220 = (void *)palloc(0x178uLL);
        pg_query__range_tbl_entry__init(v220);
        _outRangeTblEntry_0((uint64_t)v220, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v220;
        *(_DWORD *)(a1 + 24) = 192;
        break;
      case 0x174u:
        v221 = palloc(0x78uLL);
        pg_query__range_tbl_function__init(v221);
        _outRangeTblFunction_0(v221, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v221;
        *(_DWORD *)(a1 + 24) = 193;
        break;
      case 0x175u:
        v222 = palloc(0x38uLL);
        pg_query__table_sample_clause__init(v222);
        _outTableSampleClause_0(v222, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v222;
        *(_DWORD *)(a1 + 24) = 194;
        break;
      case 0x176u:
        v223 = (_OWORD *)palloc(0x40uLL);
        pg_query__with_check_option__init(v223);
        _outWithCheckOption_0((uint64_t)v223, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v223;
        *(_DWORD *)(a1 + 24) = 195;
        break;
      case 0x177u:
        v224 = palloc(0x30uLL);
        pg_query__sort_group_clause__init((_OWORD *)v224);
        *(_DWORD *)(v224 + 24) = a2[1];
        *(_DWORD *)(v224 + 28) = a2[2];
        *(_DWORD *)(v224 + 32) = a2[3];
        *(_DWORD *)(v224 + 36) = *((unsigned __int8 *)a2 + 16);
        *(_DWORD *)(v224 + 40) = *((unsigned __int8 *)a2 + 17);
        *(_QWORD *)(a1 + 32) = v224;
        *(_DWORD *)(a1 + 24) = 196;
        break;
      case 0x178u:
        v225 = palloc(0x38uLL);
        pg_query__grouping_set__init(v225);
        _outGroupingSet_0(v225, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v225;
        *(_DWORD *)(a1 + 24) = 197;
        break;
      case 0x179u:
        v226 = (_OWORD *)palloc(0x80uLL);
        pg_query__window_clause__init(v226);
        _outWindowClause_0((uint64_t)v226, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v226;
        *(_DWORD *)(a1 + 24) = 198;
        break;
      case 0x17Au:
        v227 = (_OWORD *)palloc(0x40uLL);
        pg_query__object_with_args__init(v227);
        _outVacuumStmt_0((uint64_t)v227, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v227;
        *(_DWORD *)(a1 + 24) = 199;
        break;
      case 0x17Bu:
        v228 = (_OWORD *)palloc(0x30uLL);
        pg_query__access_priv__init(v228);
        _outAlias_0(v228, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v228;
        *(_DWORD *)(a1 + 24) = 200;
        break;
      case 0x17Cu:
        v229 = palloc(0x58uLL);
        pg_query__create_op_class_item__init(v229);
        _outCreateOpClassItem_0(v229, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v229;
        *(_DWORD *)(a1 + 24) = 201;
        break;
      case 0x17Du:
        v230 = (char *)palloc(0x28uLL);
        pg_query__table_like_clause__init((uint64_t)v230);
        _outTableLikeClause_0(v230, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v230;
        *(_DWORD *)(a1 + 24) = 202;
        break;
      case 0x17Eu:
        v231 = palloc(0x38uLL);
        pg_query__function_parameter__init(v231);
        _outFunctionParameter_0(v231, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v231;
        *(_DWORD *)(a1 + 24) = 203;
        break;
      case 0x17Fu:
        v232 = (_OWORD *)palloc(0x30uLL);
        pg_query__locking_clause__init(v232);
        _outLockingClause_0((uint64_t)v232, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v232;
        *(_DWORD *)(a1 + 24) = 204;
        break;
      case 0x180u:
        v233 = (_DWORD *)palloc(0x28uLL);
        pg_query__row_mark_clause__init((uint64_t)v233);
        _outRowMarkClause_0(v233, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v233;
        *(_DWORD *)(a1 + 24) = 205;
        break;
      case 0x181u:
        v234 = palloc(0x38uLL);
        pg_query__xml_serialize__init(v234);
        _outXmlSerialize_0(v234, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v234;
        *(_DWORD *)(a1 + 24) = 206;
        break;
      case 0x182u:
        v235 = (_OWORD *)palloc(0x30uLL);
        pg_query__with_clause__init(v235);
        _outWithClause_0((uint64_t)v235, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v235;
        *(_DWORD *)(a1 + 24) = 207;
        break;
      case 0x183u:
        v236 = (_OWORD *)palloc(0x40uLL);
        pg_query__infer_clause__init(v236);
        _outInferClause_0((uint64_t)v236, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v236;
        *(_DWORD *)(a1 + 24) = 208;
        break;
      case 0x184u:
        v237 = palloc(0x48uLL);
        pg_query__on_conflict_clause__init(v237);
        _outOnConflictClause_0(v237, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v237;
        *(_DWORD *)(a1 + 24) = 209;
        break;
      case 0x185u:
        v238 = (_OWORD *)palloc(0x90uLL);
        pg_query__common_table_expr__init(v238);
        _outCommonTableExpr_0((uint64_t)v238, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v238;
        *(_DWORD *)(a1 + 24) = 210;
        break;
      case 0x186u:
        v239 = (_OWORD *)palloc(0x30uLL);
        pg_query__role_spec__init(v239);
        _outRoleSpec_0((uint64_t)v239, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v239;
        *(_DWORD *)(a1 + 24) = 211;
        break;
      case 0x187u:
        v240 = palloc(0x28uLL);
        pg_query__trigger_transition__init(v240);
        v241 = (const char *)*((_QWORD *)a2 + 1);
        if (v241)
          *(_QWORD *)(v240 + 24) = pstrdup(v241);
        *(_DWORD *)(v240 + 32) = *((unsigned __int8 *)a2 + 16);
        *(_DWORD *)(v240 + 36) = *((unsigned __int8 *)a2 + 17);
        *(_QWORD *)(a1 + 32) = v240;
        *(_DWORD *)(a1 + 24) = 212;
        break;
      case 0x188u:
        v242 = (_OWORD *)palloc(0x50uLL);
        pg_query__partition_elem__init(v242);
        _outPartitionElem_0((uint64_t)v242, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v242;
        *(_DWORD *)(a1 + 24) = 213;
        break;
      case 0x189u:
        v243 = palloc(0x38uLL);
        pg_query__partition_spec__init(v243);
        _outPartitionSpec_0(v243, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v243;
        *(_DWORD *)(a1 + 24) = 214;
        break;
      case 0x18Au:
        v244 = (_BYTE *)palloc(0x68uLL);
        pg_query__partition_bound_spec__init((uint64_t)v244);
        _outPartitionBoundSpec_0(v244, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v244;
        *(_DWORD *)(a1 + 24) = 215;
        break;
      case 0x18Bu:
        v245 = (_OWORD *)palloc(0x30uLL);
        pg_query__partition_range_datum__init(v245);
        _outPartitionRangeDatum_0((uint64_t)v245, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v245;
        *(_DWORD *)(a1 + 24) = 216;
        break;
      case 0x18Cu:
        v246 = (char *)palloc(0x28uLL);
        pg_query__partition_cmd__init((uint64_t)v246);
        _outPartitionCmd_0(v246, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v246;
        *(_DWORD *)(a1 + 24) = 217;
        break;
      case 0x18Du:
        v247 = palloc(0x38uLL);
        pg_query__vacuum_relation__init(v247);
        _outVacuumRelation_0(v247, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v247;
        *(_DWORD *)(a1 + 24) = 218;
        break;
      case 0x19Au:
        v248 = (_OWORD *)palloc(0x30uLL);
        pg_query__inline_code_block__init(v248);
        _outInlineCodeBlock_0((uint64_t)v248, (uint64_t)a2);
        *(_QWORD *)(a1 + 32) = v248;
        *(_DWORD *)(a1 + 24) = 219;
        break;
      case 0x1A0u:
        v249 = palloc(0x20uLL);
        pg_query__call_context__init((_OWORD *)v249);
        *(_DWORD *)(v249 + 24) = *((unsigned __int8 *)a2 + 4);
        *(_QWORD *)(a1 + 32) = v249;
        *(_DWORD *)(a1 + 24) = 220;
        break;
      default:
        pg_printf("could not dump unrecognized node type: %d", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a2);
        if (errstart(19, 0))
        {
          errmsg_internal("could not dump unrecognized node type: %d", *a2);
          errfinish("src/pg_query_outfuncs_protobuf.c", 198, (uint64_t)"_outNode");
        }
        break;
    }
  }
}

uint64_t _outList_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  double node__init;

  v4 = *(int *)(a2 + 4);
  *(_QWORD *)(a1 + 24) = v4;
  result = palloc(8 * v4);
  *(_QWORD *)(a1 + 32) = result;
  if (*(int *)(a2 + 4) >= 1)
  {
    v6 = 0;
    do
    {
      v7 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = palloc(0x28uLL);
      node__init = pg_query__node__init(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6));
      result = _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6), *(_QWORD *)(v7 + 8 * v6), node__init);
      ++v6;
    }
    while (v6 < *(int *)(a2 + 4));
  }
  return result;
}

const char *_outAlias_0(_QWORD *a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[3] = result;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    a1[4] = v6;
    result = (const char *)palloc(8 * v6);
    a1[5] = result;
    if (a1[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(a1[5] + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (a1[4] > v7);
    }
  }
  return result;
}

char *_outRangeVar_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *v5;
  char *result;
  _OWORD *v7;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  v5 = *(const char **)(a2 + 16);
  if (v5)
    *(_QWORD *)(a1 + 32) = pstrdup(v5);
  result = *(char **)(a2 + 24);
  if (result)
  {
    result = (char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  *(_DWORD *)(a1 + 48) = *(unsigned __int8 *)(a2 + 32);
  if (*(_BYTE *)(a2 + 33))
  {
    result = (char *)palloc(2uLL);
    *(_QWORD *)(a1 + 56) = result;
    *result = *(_BYTE *)(a2 + 33);
    *(_BYTE *)(*(_QWORD *)(a1 + 56) + 1) = 0;
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v7 = (_OWORD *)palloc(0x30uLL);
    pg_query__alias__init(v7);
    result = (char *)_outAlias_0(v7, *(_QWORD *)(a2 + 40));
    *(_QWORD *)(a1 + 64) = v7;
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t _outTableFunc_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  int v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  double v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  double v55;
  uint64_t result;
  int v57;
  int v58;
  int v59;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = palloc(8 * v5);
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = v8;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(a1 + 24) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(a1 + 40) = v11;
    *(_QWORD *)(a1 + 48) = palloc(8 * v11);
    if (*(_QWORD *)(a1 + 40))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v12) = v14;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(a1 + 40) > v12);
    }
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v16 = palloc(0x28uLL);
    v17 = pg_query__node__init(v16);
    *(_QWORD *)(a1 + 56) = v16;
    _outNode_0(v16, *(_QWORD *)(a2 + 24), v17);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v18 = palloc(0x28uLL);
    v19 = pg_query__node__init(v18);
    *(_QWORD *)(a1 + 64) = v18;
    _outNode_0(v18, *(_QWORD *)(a2 + 32), v19);
  }
  v20 = *(_QWORD *)(a2 + 40);
  if (v20)
  {
    v21 = *(int *)(v20 + 4);
    *(_QWORD *)(a1 + 72) = v21;
    *(_QWORD *)(a1 + 80) = palloc(8 * v21);
    if (*(_QWORD *)(a1 + 72))
    {
      v22 = 0;
      v23 = 1;
      do
      {
        v24 = palloc(0x28uLL);
        v25 = pg_query__node__init(v24);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v22) = v24;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v22), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v22), v25);
        v22 = v23++;
      }
      while (*(_QWORD *)(a1 + 72) > v22);
    }
  }
  v26 = *(_QWORD *)(a2 + 48);
  if (v26)
  {
    v27 = *(int *)(v26 + 4);
    *(_QWORD *)(a1 + 88) = v27;
    *(_QWORD *)(a1 + 96) = palloc(8 * v27);
    if (*(_QWORD *)(a1 + 88))
    {
      v28 = 0;
      v29 = 1;
      do
      {
        v30 = palloc(0x28uLL);
        v31 = pg_query__node__init(v30);
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v28) = v30;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v28), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v28), v31);
        v28 = v29++;
      }
      while (*(_QWORD *)(a1 + 88) > v28);
    }
  }
  v32 = *(_QWORD *)(a2 + 56);
  if (v32)
  {
    v33 = *(int *)(v32 + 4);
    *(_QWORD *)(a1 + 104) = v33;
    *(_QWORD *)(a1 + 112) = palloc(8 * v33);
    if (*(_QWORD *)(a1 + 104))
    {
      v34 = 0;
      v35 = 1;
      do
      {
        v36 = palloc(0x28uLL);
        v37 = pg_query__node__init(v36);
        *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v34) = v36;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v34), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v34), v37);
        v34 = v35++;
      }
      while (*(_QWORD *)(a1 + 104) > v34);
    }
  }
  v38 = *(_QWORD *)(a2 + 64);
  if (v38)
  {
    v39 = *(int *)(v38 + 4);
    *(_QWORD *)(a1 + 120) = v39;
    *(_QWORD *)(a1 + 128) = palloc(8 * v39);
    if (*(_QWORD *)(a1 + 120))
    {
      v40 = 0;
      v41 = 1;
      do
      {
        v42 = palloc(0x28uLL);
        v43 = pg_query__node__init(v42);
        *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v40) = v42;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v40), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16) + 8 * v40), v43);
        v40 = v41++;
      }
      while (*(_QWORD *)(a1 + 120) > v40);
    }
  }
  v44 = *(_QWORD *)(a2 + 72);
  if (v44)
  {
    v45 = *(int *)(v44 + 4);
    *(_QWORD *)(a1 + 136) = v45;
    *(_QWORD *)(a1 + 144) = palloc(8 * v45);
    if (*(_QWORD *)(a1 + 136))
    {
      v46 = 0;
      v47 = 1;
      do
      {
        v48 = palloc(0x28uLL);
        v49 = pg_query__node__init(v48);
        *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * v46) = v48;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * v46), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16) + 8 * v46), v49);
        v46 = v47++;
      }
      while (*(_QWORD *)(a1 + 136) > v46);
    }
  }
  v50 = *(_QWORD *)(a2 + 80);
  if (v50)
  {
    v51 = *(int *)(v50 + 4);
    *(_QWORD *)(a1 + 152) = v51;
    *(_QWORD *)(a1 + 160) = palloc(8 * v51);
    if (*(_QWORD *)(a1 + 152))
    {
      v52 = 0;
      v53 = 1;
      do
      {
        v54 = palloc(0x28uLL);
        v55 = pg_query__node__init(v54);
        *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * v52) = v54;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * v52), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16) + 8 * v52), v55);
        v52 = v53++;
      }
      while (*(_QWORD *)(a1 + 152) > v52);
    }
  }
  result = bms_is_empty(*(unsigned int **)(a2 + 88));
  if ((result & 1) == 0)
  {
    v57 = bms_num_members(*(unsigned int **)(a2 + 88));
    *(_QWORD *)(a1 + 168) = v57;
    *(_QWORD *)(a1 + 176) = palloc(8 * v57);
    result = bms_first_member(*(_DWORD **)(a2 + 88));
    if ((result & 0x80000000) == 0)
    {
      v58 = 0;
      do
      {
        v59 = v58 + 1;
        *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8 * v58) = result;
        result = bms_first_member(*(_DWORD **)(a2 + 88));
        v58 = v59;
      }
      while ((result & 0x80000000) == 0);
    }
  }
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 100);
  return result;
}

_DWORD *_outVar_0(_DWORD *result, uint64_t a2)
{
  result[8] = *(_DWORD *)(a2 + 4);
  result[9] = *(__int16 *)(a2 + 8);
  result[10] = *(_DWORD *)(a2 + 12);
  result[11] = *(_DWORD *)(a2 + 16);
  result[12] = *(_DWORD *)(a2 + 20);
  result[13] = *(_DWORD *)(a2 + 24);
  result[14] = *(_DWORD *)(a2 + 28);
  result[15] = *(__int16 *)(a2 + 32);
  result[16] = *(_DWORD *)(a2 + 36);
  return result;
}

_DWORD *_outParam_0(_DWORD *result, _DWORD *a2)
{
  unsigned int v2;
  int v3;

  v2 = a2[1];
  if (v2 < 4)
    v3 = v2 + 1;
  else
    v3 = -1;
  result[8] = v3;
  result[9] = a2[2];
  result[10] = a2[3];
  result[11] = a2[4];
  result[12] = a2[5];
  result[13] = a2[6];
  return result;
}

uint64_t _outAggref_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  double v33;
  uint64_t v34;
  double v35;
  int v36;
  int v37;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 20);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 56) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 64) = result;
    if (*(_QWORD *)(v3 + 56))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 56) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 32);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 72) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 80) = result;
    if (*(_QWORD *)(v3 + 72))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 80) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 72) > v12);
    }
  }
  v16 = *(_QWORD *)(a2 + 40);
  if (v16)
  {
    v17 = *(int *)(v16 + 4);
    *(_QWORD *)(v3 + 88) = v17;
    result = palloc(8 * v17);
    *(_QWORD *)(v3 + 96) = result;
    if (*(_QWORD *)(v3 + 88))
    {
      v18 = 0;
      v19 = 1;
      do
      {
        v20 = palloc(0x28uLL);
        v21 = pg_query__node__init(v20);
        *(_QWORD *)(*(_QWORD *)(v3 + 96) + 8 * v18) = v20;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 96) + 8 * v18), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v18), v21);
        v18 = v19++;
      }
      while (*(_QWORD *)(v3 + 88) > v18);
    }
  }
  v22 = *(_QWORD *)(a2 + 48);
  if (v22)
  {
    v23 = *(int *)(v22 + 4);
    *(_QWORD *)(v3 + 104) = v23;
    result = palloc(8 * v23);
    *(_QWORD *)(v3 + 112) = result;
    if (*(_QWORD *)(v3 + 104))
    {
      v24 = 0;
      v25 = 1;
      do
      {
        v26 = palloc(0x28uLL);
        v27 = pg_query__node__init(v26);
        *(_QWORD *)(*(_QWORD *)(v3 + 112) + 8 * v24) = v26;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 112) + 8 * v24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v24), v27);
        v24 = v25++;
      }
      while (*(_QWORD *)(v3 + 104) > v24);
    }
  }
  v28 = *(_QWORD *)(a2 + 56);
  if (v28)
  {
    v29 = *(int *)(v28 + 4);
    *(_QWORD *)(v3 + 120) = v29;
    result = palloc(8 * v29);
    *(_QWORD *)(v3 + 128) = result;
    if (*(_QWORD *)(v3 + 120))
    {
      v30 = 0;
      v31 = 1;
      do
      {
        v32 = palloc(0x28uLL);
        v33 = pg_query__node__init(v32);
        *(_QWORD *)(*(_QWORD *)(v3 + 128) + 8 * v30) = v32;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 128) + 8 * v30), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v30), v33);
        v30 = v31++;
      }
      while (*(_QWORD *)(v3 + 120) > v30);
    }
  }
  if (*(_QWORD *)(a2 + 64))
  {
    v34 = palloc(0x28uLL);
    v35 = pg_query__node__init(v34);
    *(_QWORD *)(v3 + 136) = v34;
    result = _outNode_0(v34, *(_QWORD *)(a2 + 64), v35);
  }
  *(_DWORD *)(v3 + 144) = *(unsigned __int8 *)(a2 + 72);
  *(_DWORD *)(v3 + 148) = *(unsigned __int8 *)(a2 + 73);
  if (*(_BYTE *)(a2 + 74))
  {
    result = palloc(2uLL);
    *(_QWORD *)(v3 + 152) = result;
    *(_BYTE *)result = *(_BYTE *)(a2 + 74);
    *(_BYTE *)(*(_QWORD *)(v3 + 152) + 1) = 0;
  }
  *(_DWORD *)(v3 + 160) = *(_DWORD *)(a2 + 76);
  v36 = *(_DWORD *)(a2 + 80);
  if (v36)
  {
    if (v36 == 9)
    {
      v37 = 3;
    }
    else if (v36 == 6)
    {
      v37 = 2;
    }
    else
    {
      v37 = -1;
    }
  }
  else
  {
    v37 = 1;
  }
  *(_DWORD *)(v3 + 164) = v37;
  *(_DWORD *)(v3 + 168) = *(_DWORD *)(a2 + 84);
  return result;
}

uint64_t _outGroupingFunc_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 32) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 32) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 48) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 48) > v12);
    }
  }
  v16 = *(_QWORD *)(a2 + 24);
  if (v16)
  {
    v17 = *(int *)(v16 + 4);
    *(_QWORD *)(v3 + 64) = v17;
    result = palloc(8 * v17);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v18 = 0;
      v19 = 1;
      do
      {
        v20 = palloc(0x28uLL);
        v21 = pg_query__node__init(v20);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v18) = v20;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v18), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v18), v21);
        v18 = v19++;
      }
      while (*(_QWORD *)(v3 + 64) > v18);
    }
  }
  *(_DWORD *)(v3 + 80) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(v3 + 84) = *(_DWORD *)(a2 + 36);
  return result;
}

uint64_t _outWindowFunc_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  double v11;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 48) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 48) > v6);
    }
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v10 = palloc(0x28uLL);
    v11 = pg_query__node__init(v10);
    *(_QWORD *)(v3 + 64) = v10;
    result = _outNode_0(v10, *(_QWORD *)(a2 + 32), v11);
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(v3 + 76) = *(unsigned __int8 *)(a2 + 44);
  *(_DWORD *)(v3 + 80) = *(unsigned __int8 *)(a2 + 45);
  *(_DWORD *)(v3 + 84) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t _outSubscriptingRef_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  double v19;

  v3 = (_QWORD *)result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 48) = v5;
    result = palloc(8 * v5);
    v3[7] = result;
    if (v3[6])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[7] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[7] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[6] > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 32);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    v3[8] = v11;
    result = palloc(8 * v11);
    v3[9] = result;
    if (v3[8])
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(v3[9] + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(v3[9] + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (v3[8] > v12);
    }
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v16 = palloc(0x28uLL);
    v17 = pg_query__node__init(v16);
    v3[10] = v16;
    result = _outNode_0(v16, *(_QWORD *)(a2 + 40), v17);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    v18 = palloc(0x28uLL);
    v19 = pg_query__node__init(v18);
    v3[11] = v18;
    return _outNode_0(v18, *(_QWORD *)(a2 + 48), v19);
  }
  return result;
}

uint64_t _outFuncExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(unsigned __int8 *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(unsigned __int8 *)(a2 + 13);
  v4 = *(_DWORD *)(a2 + 16);
  if (v4 < 3)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 48) = v5;
  *(_DWORD *)(result + 52) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(result + 56) = *(_DWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 32);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(result + 64) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 64) > v8);
    }
  }
  *(_DWORD *)(v3 + 80) = *(_DWORD *)(a2 + 40);
  return result;
}

const char *_outNamedArgExpr_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  double node__init;
  const char *result;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(a1 + 32) = v4;
    _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outOpExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(unsigned __int8 *)(a2 + 16);
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(result + 52) = *(_DWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 32);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 56) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 64) = result;
    if (*(_QWORD *)(v3 + 56))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 56) > v6);
    }
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  return result;
}

uint64_t _outScalarArrayOpExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(unsigned __int8 *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 48) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 48) > v6);
    }
  }
  *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outBoolExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 3)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 32) = v5;
  v6 = *(_QWORD *)(a2 + 8);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(result + 40) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 40) > v8);
    }
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 16);
  return result;
}

uint64_t _outSubLink_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  double node__init;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  double v15;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 32) = v5;
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    *(_QWORD *)(v3 + 40) = v6;
    result = _outNode_0(v6, *(_QWORD *)(a2 + 16), node__init);
  }
  v8 = *(_QWORD *)(a2 + 24);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *(_QWORD *)(v3 + 48) = v9;
    result = palloc(8 * v9);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        v13 = pg_query__node__init(v12);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v10) = v12;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v10), v13);
        v10 = v11++;
      }
      while (*(_QWORD *)(v3 + 48) > v10);
    }
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v14 = palloc(0x28uLL);
    v15 = pg_query__node__init(v14);
    *(_QWORD *)(v3 + 64) = v14;
    result = _outNode_0(v14, *(_QWORD *)(a2 + 32), v15);
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  return result;
}

double _outSubPlan_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  double node__init;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  double v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  uint64_t v31;
  double v32;
  double result;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 32) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    *(_QWORD *)(a1 + 40) = v6;
    _outNode_0(v6, *(_QWORD *)(a2 + 8), node__init);
  }
  v8 = *(_QWORD *)(a2 + 16);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *(_QWORD *)(a1 + 48) = v9;
    *(_QWORD *)(a1 + 56) = palloc(8 * v9);
    if (*(_QWORD *)(a1 + 48))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        v13 = pg_query__node__init(v12);
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v10) = v12;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v10), v13);
        v10 = v11++;
      }
      while (*(_QWORD *)(a1 + 48) > v10);
    }
  }
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 24);
  v14 = *(const char **)(a2 + 32);
  if (v14)
    *(_QWORD *)(a1 + 72) = pstrdup(v14);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 92) = *(unsigned __int8 *)(a2 + 52);
  *(_DWORD *)(a1 + 96) = *(unsigned __int8 *)(a2 + 53);
  *(_DWORD *)(a1 + 100) = *(unsigned __int8 *)(a2 + 54);
  v15 = *(_QWORD *)(a2 + 56);
  if (v15)
  {
    v16 = *(int *)(v15 + 4);
    *(_QWORD *)(a1 + 104) = v16;
    *(_QWORD *)(a1 + 112) = palloc(8 * v16);
    if (*(_QWORD *)(a1 + 104))
    {
      v17 = 0;
      v18 = 1;
      do
      {
        v19 = palloc(0x28uLL);
        v20 = pg_query__node__init(v19);
        *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v17) = v19;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v17), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v17), v20);
        v17 = v18++;
      }
      while (*(_QWORD *)(a1 + 104) > v17);
    }
  }
  v21 = *(_QWORD *)(a2 + 64);
  if (v21)
  {
    v22 = *(int *)(v21 + 4);
    *(_QWORD *)(a1 + 120) = v22;
    *(_QWORD *)(a1 + 128) = palloc(8 * v22);
    if (*(_QWORD *)(a1 + 120))
    {
      v23 = 0;
      v24 = 1;
      do
      {
        v25 = palloc(0x28uLL);
        v26 = pg_query__node__init(v25);
        *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v23) = v25;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v23), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16) + 8 * v23), v26);
        v23 = v24++;
      }
      while (*(_QWORD *)(a1 + 120) > v23);
    }
  }
  v27 = *(_QWORD *)(a2 + 72);
  if (v27)
  {
    v28 = *(int *)(v27 + 4);
    *(_QWORD *)(a1 + 136) = v28;
    *(_QWORD *)(a1 + 144) = palloc(8 * v28);
    if (*(_QWORD *)(a1 + 136))
    {
      v29 = 0;
      v30 = 1;
      do
      {
        v31 = palloc(0x28uLL);
        v32 = pg_query__node__init(v31);
        *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * v29) = v31;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * v29), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16) + 8 * v29), v32);
        v29 = v30++;
      }
      while (*(_QWORD *)(a1 + 136) > v29);
    }
  }
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 80);
  result = *(double *)(a2 + 88);
  *(double *)(a1 + 160) = result;
  return result;
}

uint64_t _outAlternativeSubPlan_0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2)
  {
    v4 = result;
    v5 = *(int *)(v2 + 4);
    *(_QWORD *)(result + 32) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v4 + 40) = result;
    if (*(_QWORD *)(v4 + 32))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v4 + 40) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v4 + 32) > v6);
    }
  }
  return result;
}

uint64_t _outFieldSelect_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 40) = *(__int16 *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 52) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outFieldStore_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(v3 + 40) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        v11 = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v8), v11);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 40) > v8);
    }
  }
  v12 = *(_QWORD *)(a2 + 24);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(v3 + 56) = v13;
    result = palloc(8 * v13);
    *(_QWORD *)(v3 + 64) = result;
    if (*(_QWORD *)(v3 + 56))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v14) = v16;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(v3 + 56) > v14);
    }
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outRelabelType_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  unsigned int v6;
  int v7;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  v6 = *(_DWORD *)(a2 + 28);
  if (v6 < 3)
    v7 = v6 + 1;
  else
    v7 = -1;
  *(_DWORD *)(v3 + 52) = v7;
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outCoerceViaIO_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  unsigned int v6;
  int v7;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  v6 = *(_DWORD *)(a2 + 24);
  if (v6 < 3)
    v7 = v6 + 1;
  else
    v7 = -1;
  *(_DWORD *)(v3 + 48) = v7;
  *(_DWORD *)(v3 + 52) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outArrayCoerceExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  double v7;
  unsigned int v8;
  int v9;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x28uLL);
    v7 = pg_query__node__init(v6);
    *(_QWORD *)(v3 + 40) = v6;
    result = _outNode_0(v6, *(_QWORD *)(a2 + 16), v7);
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 52) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 32);
  v8 = *(_DWORD *)(a2 + 36);
  if (v8 < 3)
    v9 = v8 + 1;
  else
    v9 = -1;
  *(_DWORD *)(v3 + 60) = v9;
  *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 40);
  return result;
}

uint64_t _outConvertRowtypeExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  unsigned int v6;
  int v7;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 16);
  v6 = *(_DWORD *)(a2 + 20);
  if (v6 < 3)
    v7 = v6 + 1;
  else
    v7 = -1;
  *(_DWORD *)(v3 + 44) = v7;
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outCollateExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  return result;
}

uint64_t _outCaseExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  double v13;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  if (*(_QWORD *)(a2 + 16))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 40) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 16), node__init);
  }
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(v3 + 48) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        v11 = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v8), v11);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 48) > v8);
    }
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v12 = palloc(0x28uLL);
    v13 = pg_query__node__init(v12);
    *(_QWORD *)(v3 + 64) = v12;
    result = _outNode_0(v12, *(_QWORD *)(a2 + 32), v13);
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  return result;
}

uint64_t _outCaseWhen_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  double v7;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x28uLL);
    v7 = pg_query__node__init(v6);
    *(_QWORD *)(v3 + 40) = v6;
    result = _outNode_0(v6, *(_QWORD *)(a2 + 16), v7);
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outArrayExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 12);
  v4 = *(_QWORD *)(a2 + 16);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 48) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 48) > v6);
    }
  }
  *(_DWORD *)(v3 + 64) = *(unsigned __int8 *)(a2 + 24);
  *(_DWORD *)(v3 + 68) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outRowExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 32) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 32) > v6);
    }
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 16);
  v10 = *(_DWORD *)(a2 + 20);
  if (v10 < 3)
    v11 = v10 + 1;
  else
    v11 = -1;
  *(_DWORD *)(v3 + 52) = v11;
  v12 = *(_QWORD *)(a2 + 24);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(v3 + 56) = v13;
    result = palloc(8 * v13);
    *(_QWORD *)(v3 + 64) = result;
    if (*(_QWORD *)(v3 + 56))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v14) = v16;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(v3 + 56) > v14);
    }
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outRowCompareExpr_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  double v34;

  v3 = (_QWORD *)result;
  v4 = *(_DWORD *)(a2 + 4);
  if ((v4 - 1) >= 6)
    v4 = -1;
  *(_DWORD *)(result + 32) = v4;
  v5 = *(_QWORD *)(a2 + 8);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(result + 40) = v6;
    result = palloc(8 * v6);
    v3[6] = result;
    if (v3[5])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(v3[6] + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(v3[6] + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (v3[5] > v7);
    }
  }
  v11 = *(_QWORD *)(a2 + 16);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    v3[7] = v12;
    result = palloc(8 * v12);
    v3[8] = result;
    if (v3[7])
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(v3[8] + 8 * v13) = v15;
        result = _outNode_0(*(_QWORD *)(v3[8] + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (v3[7] > v13);
    }
  }
  v17 = *(_QWORD *)(a2 + 24);
  if (v17)
  {
    v18 = *(int *)(v17 + 4);
    v3[9] = v18;
    result = palloc(8 * v18);
    v3[10] = result;
    if (v3[9])
    {
      v19 = 0;
      v20 = 1;
      do
      {
        v21 = palloc(0x28uLL);
        v22 = pg_query__node__init(v21);
        *(_QWORD *)(v3[10] + 8 * v19) = v21;
        result = _outNode_0(*(_QWORD *)(v3[10] + 8 * v19), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v19), v22);
        v19 = v20++;
      }
      while (v3[9] > v19);
    }
  }
  v23 = *(_QWORD *)(a2 + 32);
  if (v23)
  {
    v24 = *(int *)(v23 + 4);
    v3[11] = v24;
    result = palloc(8 * v24);
    v3[12] = result;
    if (v3[11])
    {
      v25 = 0;
      v26 = 1;
      do
      {
        v27 = palloc(0x28uLL);
        v28 = pg_query__node__init(v27);
        *(_QWORD *)(v3[12] + 8 * v25) = v27;
        result = _outNode_0(*(_QWORD *)(v3[12] + 8 * v25), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v25), v28);
        v25 = v26++;
      }
      while (v3[11] > v25);
    }
  }
  v29 = *(_QWORD *)(a2 + 40);
  if (v29)
  {
    v30 = *(int *)(v29 + 4);
    v3[13] = v30;
    result = palloc(8 * v30);
    v3[14] = result;
    if (v3[13])
    {
      v31 = 0;
      v32 = 1;
      do
      {
        v33 = palloc(0x28uLL);
        v34 = pg_query__node__init(v33);
        *(_QWORD *)(v3[14] + 8 * v31) = v33;
        result = _outNode_0(*(_QWORD *)(v3[14] + 8 * v31), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v31), v34);
        v31 = v32++;
      }
      while (v3[13] > v31);
    }
  }
  return result;
}

uint64_t _outCoalesceExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 16);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 40) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 40) > v6);
    }
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outMinMaxExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double node__init;

  v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 12);
  v4 = *(_DWORD *)(a2 + 16);
  if (v4 == 1)
    v5 = 2;
  else
    v5 = -1;
  if (v4)
    v6 = v5;
  else
    v6 = 1;
  *(_DWORD *)(result + 44) = v6;
  v7 = *(_QWORD *)(a2 + 24);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    *(_QWORD *)(result + 48) = v8;
    result = palloc(8 * v8);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        node__init = pg_query__node__init(v11);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v9) = v11;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v9), node__init);
        v9 = v10++;
      }
      while (*(_QWORD *)(v3 + 48) > v9);
    }
  }
  *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 32);
  return result;
}

_DWORD *_outSQLValueFunction_0(_DWORD *result, _DWORD *a2)
{
  unsigned int v2;
  int v3;

  v2 = a2[1];
  if (v2 < 0xF)
    v3 = v2 + 1;
  else
    v3 = -1;
  result[8] = v3;
  result[9] = a2[2];
  result[10] = a2[3];
  result[11] = a2[4];
  return result;
}

const char *_outXmlExpr_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  const char *result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double node__init;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  double v24;
  int v25;
  int v26;
  int v27;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 32) = v5;
  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  v7 = *(_QWORD *)(a2 + 16);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    *(_QWORD *)(a1 + 48) = v8;
    result = (const char *)palloc(8 * v8);
    *(_QWORD *)(a1 + 56) = result;
    if (*(_QWORD *)(a1 + 48))
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        node__init = pg_query__node__init(v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v9) = v11;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v9), node__init);
        v9 = v10++;
      }
      while (*(_QWORD *)(a1 + 48) > v9);
    }
  }
  v13 = *(_QWORD *)(a2 + 24);
  if (v13)
  {
    v14 = *(int *)(v13 + 4);
    *(_QWORD *)(a1 + 64) = v14;
    result = (const char *)palloc(8 * v14);
    *(_QWORD *)(a1 + 72) = result;
    if (*(_QWORD *)(a1 + 64))
    {
      v15 = 0;
      v16 = 1;
      do
      {
        v17 = palloc(0x28uLL);
        v18 = pg_query__node__init(v17);
        *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v15) = v17;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v15), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v15), v18);
        v15 = v16++;
      }
      while (*(_QWORD *)(a1 + 64) > v15);
    }
  }
  v19 = *(_QWORD *)(a2 + 32);
  if (v19)
  {
    v20 = *(int *)(v19 + 4);
    *(_QWORD *)(a1 + 80) = v20;
    result = (const char *)palloc(8 * v20);
    *(_QWORD *)(a1 + 88) = result;
    if (*(_QWORD *)(a1 + 80))
    {
      v21 = 0;
      v22 = 1;
      do
      {
        v23 = palloc(0x28uLL);
        v24 = pg_query__node__init(v23);
        *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8 * v21) = v23;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8 * v21), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v21), v24);
        v21 = v22++;
      }
      while (*(_QWORD *)(a1 + 80) > v21);
    }
  }
  v25 = *(_DWORD *)(a2 + 40);
  if (v25 == 1)
    v26 = 2;
  else
    v26 = -1;
  if (v25)
    v27 = v26;
  else
    v27 = 1;
  *(_DWORD *)(a1 + 96) = v27;
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 108) = *(_DWORD *)(a2 + 52);
  return result;
}

uint64_t _outNullTest_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  int v6;
  int v7;
  int v8;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  v6 = *(_DWORD *)(a2 + 16);
  if (v6 == 1)
    v7 = 2;
  else
    v7 = -1;
  if (v6)
    v8 = v7;
  else
    v8 = 1;
  *(_DWORD *)(v3 + 40) = v8;
  *(_DWORD *)(v3 + 44) = *(unsigned __int8 *)(a2 + 20);
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outBooleanTest_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  unsigned int v6;
  int v7;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  v6 = *(_DWORD *)(a2 + 16);
  if (v6 < 6)
    v7 = v6 + 1;
  else
    v7 = -1;
  *(_DWORD *)(v3 + 40) = v7;
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  return result;
}

const char *_outTargetEntry_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  double node__init;
  const char *result;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(a1 + 32) = v4;
    _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  *(_DWORD *)(a1 + 40) = *(__int16 *)(a2 + 16);
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 48) = result;
  }
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 64) = *(__int16 *)(a2 + 40);
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a2 + 42);
  return result;
}

uint64_t _outJoinExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  double node__init;
  uint64_t v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  double v17;
  _OWORD *v18;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 24) = v5;
  *(_DWORD *)(result + 28) = *(unsigned __int8 *)(a2 + 8);
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    *(_QWORD *)(v3 + 32) = v6;
    result = _outNode_0(v6, *(_QWORD *)(a2 + 16), node__init);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v8 = palloc(0x28uLL);
    v9 = pg_query__node__init(v8);
    *(_QWORD *)(v3 + 40) = v8;
    result = _outNode_0(v8, *(_QWORD *)(a2 + 24), v9);
  }
  v10 = *(_QWORD *)(a2 + 32);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 48) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 48) > v12);
    }
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v16 = palloc(0x28uLL);
    v17 = pg_query__node__init(v16);
    *(_QWORD *)(v3 + 64) = v16;
    result = _outNode_0(v16, *(_QWORD *)(a2 + 40), v17);
  }
  if (*(_QWORD *)(a2 + 48))
  {
    v18 = (_OWORD *)palloc(0x30uLL);
    pg_query__alias__init(v18);
    result = (uint64_t)_outAlias_0(v18, *(_QWORD *)(a2 + 48));
    *(_QWORD *)(v3 + 72) = v18;
  }
  *(_DWORD *)(v3 + 80) = *(_DWORD *)(a2 + 56);
  return result;
}

uint64_t _outFromExpr_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  double v11;

  v3 = (_QWORD *)result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    v3[4] = result;
    if (v3[3])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[4] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[4] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[3] > v6);
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v10 = palloc(0x28uLL);
    v11 = pg_query__node__init(v10);
    v3[5] = v10;
    return _outNode_0(v10, *(_QWORD *)(a2 + 16), v11);
  }
  return result;
}

uint64_t _outOnConflictExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  double v27;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 3)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 24) = v5;
  v6 = *(_QWORD *)(a2 + 8);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(result + 32) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 32) > v8);
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v12 = palloc(0x28uLL);
    v13 = pg_query__node__init(v12);
    *(_QWORD *)(v3 + 48) = v12;
    result = _outNode_0(v12, *(_QWORD *)(a2 + 16), v13);
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 24);
  v14 = *(_QWORD *)(a2 + 32);
  if (v14)
  {
    v15 = *(int *)(v14 + 4);
    *(_QWORD *)(v3 + 64) = v15;
    result = palloc(8 * v15);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = palloc(0x28uLL);
        v19 = pg_query__node__init(v18);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v16) = v18;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v16), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v16), v19);
        v16 = v17++;
      }
      while (*(_QWORD *)(v3 + 64) > v16);
    }
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v20 = palloc(0x28uLL);
    v21 = pg_query__node__init(v20);
    *(_QWORD *)(v3 + 80) = v20;
    result = _outNode_0(v20, *(_QWORD *)(a2 + 40), v21);
  }
  *(_DWORD *)(v3 + 88) = *(_DWORD *)(a2 + 48);
  v22 = *(_QWORD *)(a2 + 56);
  if (v22)
  {
    v23 = *(int *)(v22 + 4);
    *(_QWORD *)(v3 + 96) = v23;
    result = palloc(8 * v23);
    *(_QWORD *)(v3 + 104) = result;
    if (*(_QWORD *)(v3 + 96))
    {
      v24 = 0;
      v25 = 1;
      do
      {
        v26 = palloc(0x28uLL);
        v27 = pg_query__node__init(v26);
        *(_QWORD *)(*(_QWORD *)(v3 + 104) + 8 * v24) = v26;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 104) + 8 * v24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v24), v27);
        v24 = v25++;
      }
      while (*(_QWORD *)(v3 + 96) > v24);
    }
  }
  return result;
}

const char *_outIntoClause_0(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;
  unsigned int v18;
  int v19;
  const char *result;
  uint64_t v21;
  double v22;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    _outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 24) = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 32) = v6;
    *(_QWORD *)(a1 + 40) = palloc(8 * v6);
    if (*(_QWORD *)(a1 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7) = v9;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 32) > v7);
    }
  }
  v11 = *(const char **)(a2 + 24);
  if (v11)
    *(_QWORD *)(a1 + 48) = pstrdup(v11);
  v12 = *(_QWORD *)(a2 + 32);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(a1 + 56) = v13;
    *(_QWORD *)(a1 + 64) = palloc(8 * v13);
    if (*(_QWORD *)(a1 + 56))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14) = v16;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(a1 + 56) > v14);
    }
  }
  v18 = *(_DWORD *)(a2 + 40);
  if (v18 < 4)
    v19 = v18 + 1;
  else
    v19 = -1;
  *(_DWORD *)(a1 + 72) = v19;
  result = *(const char **)(a2 + 48);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 80) = result;
  }
  if (*(_QWORD *)(a2 + 56))
  {
    v21 = palloc(0x28uLL);
    v22 = pg_query__node__init(v21);
    *(_QWORD *)(a1 + 88) = v21;
    result = (const char *)_outNode_0(v21, *(_QWORD *)(a2 + 56), v22);
  }
  *(_DWORD *)(a1 + 96) = *(unsigned __int8 *)(a2 + 64);
  return result;
}

_DWORD *_outQuery_0(_DWORD *result, uint64_t a2)
{
  _DWORD *v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;
  _OWORD *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  double v28;
  unsigned int v29;
  int v30;
  _OWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  int v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  double v49;
  uint64_t v50;
  double v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  int v55;
  uint64_t v56;
  double v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  double v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  int v67;
  uint64_t v68;
  double v69;
  uint64_t v70;
  double v71;
  uint64_t v72;
  double v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  int v79;
  uint64_t v80;
  double v81;
  uint64_t v82;
  double v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  int v87;
  uint64_t v88;
  double v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  uint64_t v94;
  double v95;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 7)
    v5 = v4 + 1;
  else
    v5 = -1;
  result[6] = v5;
  v6 = *(_DWORD *)(a2 + 8);
  if (v6 < 5)
    v7 = v6 + 1;
  else
    v7 = -1;
  result[7] = v7;
  result[8] = *(unsigned __int8 *)(a2 + 24);
  if (*(_QWORD *)(a2 + 32))
  {
    v8 = palloc(0x28uLL);
    node__init = pg_query__node__init(v8);
    *((_QWORD *)v3 + 5) = v8;
    result = (_DWORD *)_outNode_0(v8, *(_QWORD *)(a2 + 32), node__init);
  }
  v3[12] = *(_DWORD *)(a2 + 40);
  v3[13] = *(unsigned __int8 *)(a2 + 44);
  v3[14] = *(unsigned __int8 *)(a2 + 45);
  v3[15] = *(unsigned __int8 *)(a2 + 46);
  v3[16] = *(unsigned __int8 *)(a2 + 47);
  v3[17] = *(unsigned __int8 *)(a2 + 48);
  v3[18] = *(unsigned __int8 *)(a2 + 49);
  v3[19] = *(unsigned __int8 *)(a2 + 50);
  v3[20] = *(unsigned __int8 *)(a2 + 51);
  v3[21] = *(unsigned __int8 *)(a2 + 52);
  v10 = *(_QWORD *)(a2 + 56);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *((_QWORD *)v3 + 11) = v11;
    result = (_DWORD *)palloc(8 * v11);
    *((_QWORD *)v3 + 12) = result;
    if (*((_QWORD *)v3 + 11))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*((_QWORD *)v3 + 12) + 8 * v12) = v14;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 12) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*((_QWORD *)v3 + 11) > v12);
    }
  }
  v16 = *(_QWORD *)(a2 + 64);
  if (v16)
  {
    v17 = *(int *)(v16 + 4);
    *((_QWORD *)v3 + 13) = v17;
    result = (_DWORD *)palloc(8 * v17);
    *((_QWORD *)v3 + 14) = result;
    if (*((_QWORD *)v3 + 13))
    {
      v18 = 0;
      v19 = 1;
      do
      {
        v20 = palloc(0x28uLL);
        v21 = pg_query__node__init(v20);
        *(_QWORD *)(*((_QWORD *)v3 + 14) + 8 * v18) = v20;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 14) + 8 * v18), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16) + 8 * v18), v21);
        v18 = v19++;
      }
      while (*((_QWORD *)v3 + 13) > v18);
    }
  }
  if (*(_QWORD *)(a2 + 72))
  {
    v22 = (_OWORD *)palloc(0x30uLL);
    pg_query__from_expr__init(v22);
    result = (_DWORD *)_outFromExpr_0((uint64_t)v22, *(_QWORD *)(a2 + 72));
    *((_QWORD *)v3 + 15) = v22;
  }
  v23 = *(_QWORD *)(a2 + 80);
  if (v23)
  {
    v24 = *(int *)(v23 + 4);
    *((_QWORD *)v3 + 16) = v24;
    result = (_DWORD *)palloc(8 * v24);
    *((_QWORD *)v3 + 17) = result;
    if (*((_QWORD *)v3 + 16))
    {
      v25 = 0;
      v26 = 1;
      do
      {
        v27 = palloc(0x28uLL);
        v28 = pg_query__node__init(v27);
        *(_QWORD *)(*((_QWORD *)v3 + 17) + 8 * v25) = v27;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 17) + 8 * v25), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16) + 8 * v25), v28);
        v25 = v26++;
      }
      while (*((_QWORD *)v3 + 16) > v25);
    }
  }
  v29 = *(_DWORD *)(a2 + 88);
  if (v29 < 3)
    v30 = v29 + 1;
  else
    v30 = -1;
  v3[36] = v30;
  if (*(_QWORD *)(a2 + 96))
  {
    v31 = (_OWORD *)palloc(0x70uLL);
    pg_query__on_conflict_expr__init(v31);
    result = (_DWORD *)_outOnConflictExpr_0((uint64_t)v31, *(_QWORD *)(a2 + 96));
    *((_QWORD *)v3 + 19) = v31;
  }
  v32 = *(_QWORD *)(a2 + 104);
  if (v32)
  {
    v33 = *(int *)(v32 + 4);
    *((_QWORD *)v3 + 20) = v33;
    result = (_DWORD *)palloc(8 * v33);
    *((_QWORD *)v3 + 21) = result;
    if (*((_QWORD *)v3 + 20))
    {
      v34 = 0;
      v35 = 1;
      do
      {
        v36 = palloc(0x28uLL);
        v37 = pg_query__node__init(v36);
        *(_QWORD *)(*((_QWORD *)v3 + 21) + 8 * v34) = v36;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 21) + 8 * v34), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 104) + 16) + 8 * v34), v37);
        v34 = v35++;
      }
      while (*((_QWORD *)v3 + 20) > v34);
    }
  }
  v38 = *(_QWORD *)(a2 + 112);
  if (v38)
  {
    v39 = *(int *)(v38 + 4);
    *((_QWORD *)v3 + 22) = v39;
    result = (_DWORD *)palloc(8 * v39);
    *((_QWORD *)v3 + 23) = result;
    if (*((_QWORD *)v3 + 22))
    {
      v40 = 0;
      v41 = 1;
      do
      {
        v42 = palloc(0x28uLL);
        v43 = pg_query__node__init(v42);
        *(_QWORD *)(*((_QWORD *)v3 + 23) + 8 * v40) = v42;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 23) + 8 * v40), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 16) + 8 * v40), v43);
        v40 = v41++;
      }
      while (*((_QWORD *)v3 + 22) > v40);
    }
  }
  v44 = *(_QWORD *)(a2 + 120);
  if (v44)
  {
    v45 = *(int *)(v44 + 4);
    *((_QWORD *)v3 + 24) = v45;
    result = (_DWORD *)palloc(8 * v45);
    *((_QWORD *)v3 + 25) = result;
    if (*((_QWORD *)v3 + 24))
    {
      v46 = 0;
      v47 = 1;
      do
      {
        v48 = palloc(0x28uLL);
        v49 = pg_query__node__init(v48);
        *(_QWORD *)(*((_QWORD *)v3 + 25) + 8 * v46) = v48;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 25) + 8 * v46), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 120) + 16) + 8 * v46), v49);
        v46 = v47++;
      }
      while (*((_QWORD *)v3 + 24) > v46);
    }
  }
  if (*(_QWORD *)(a2 + 128))
  {
    v50 = palloc(0x28uLL);
    v51 = pg_query__node__init(v50);
    *((_QWORD *)v3 + 26) = v50;
    result = (_DWORD *)_outNode_0(v50, *(_QWORD *)(a2 + 128), v51);
  }
  v52 = *(_QWORD *)(a2 + 136);
  if (v52)
  {
    v53 = *(int *)(v52 + 4);
    *((_QWORD *)v3 + 27) = v53;
    result = (_DWORD *)palloc(8 * v53);
    *((_QWORD *)v3 + 28) = result;
    if (*((_QWORD *)v3 + 27))
    {
      v54 = 0;
      v55 = 1;
      do
      {
        v56 = palloc(0x28uLL);
        v57 = pg_query__node__init(v56);
        *(_QWORD *)(*((_QWORD *)v3 + 28) + 8 * v54) = v56;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 28) + 8 * v54), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 136) + 16) + 8 * v54), v57);
        v54 = v55++;
      }
      while (*((_QWORD *)v3 + 27) > v54);
    }
  }
  v58 = *(_QWORD *)(a2 + 144);
  if (v58)
  {
    v59 = *(int *)(v58 + 4);
    *((_QWORD *)v3 + 29) = v59;
    result = (_DWORD *)palloc(8 * v59);
    *((_QWORD *)v3 + 30) = result;
    if (*((_QWORD *)v3 + 29))
    {
      v60 = 0;
      v61 = 1;
      do
      {
        v62 = palloc(0x28uLL);
        v63 = pg_query__node__init(v62);
        *(_QWORD *)(*((_QWORD *)v3 + 30) + 8 * v60) = v62;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 30) + 8 * v60), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 144) + 16) + 8 * v60), v63);
        v60 = v61++;
      }
      while (*((_QWORD *)v3 + 29) > v60);
    }
  }
  v64 = *(_QWORD *)(a2 + 152);
  if (v64)
  {
    v65 = *(int *)(v64 + 4);
    *((_QWORD *)v3 + 31) = v65;
    result = (_DWORD *)palloc(8 * v65);
    *((_QWORD *)v3 + 32) = result;
    if (*((_QWORD *)v3 + 31))
    {
      v66 = 0;
      v67 = 1;
      do
      {
        v68 = palloc(0x28uLL);
        v69 = pg_query__node__init(v68);
        *(_QWORD *)(*((_QWORD *)v3 + 32) + 8 * v66) = v68;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 32) + 8 * v66), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 152) + 16) + 8 * v66), v69);
        v66 = v67++;
      }
      while (*((_QWORD *)v3 + 31) > v66);
    }
  }
  if (*(_QWORD *)(a2 + 160))
  {
    v70 = palloc(0x28uLL);
    v71 = pg_query__node__init(v70);
    *((_QWORD *)v3 + 33) = v70;
    result = (_DWORD *)_outNode_0(v70, *(_QWORD *)(a2 + 160), v71);
  }
  if (*(_QWORD *)(a2 + 168))
  {
    v72 = palloc(0x28uLL);
    v73 = pg_query__node__init(v72);
    *((_QWORD *)v3 + 34) = v72;
    result = (_DWORD *)_outNode_0(v72, *(_QWORD *)(a2 + 168), v73);
  }
  v74 = *(_DWORD *)(a2 + 176);
  if (v74 < 3)
    v75 = v74 + 1;
  else
    v75 = -1;
  v3[70] = v75;
  v76 = *(_QWORD *)(a2 + 184);
  if (v76)
  {
    v77 = *(int *)(v76 + 4);
    *((_QWORD *)v3 + 36) = v77;
    result = (_DWORD *)palloc(8 * v77);
    *((_QWORD *)v3 + 37) = result;
    if (*((_QWORD *)v3 + 36))
    {
      v78 = 0;
      v79 = 1;
      do
      {
        v80 = palloc(0x28uLL);
        v81 = pg_query__node__init(v80);
        *(_QWORD *)(*((_QWORD *)v3 + 37) + 8 * v78) = v80;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 37) + 8 * v78), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 184) + 16) + 8 * v78), v81);
        v78 = v79++;
      }
      while (*((_QWORD *)v3 + 36) > v78);
    }
  }
  if (*(_QWORD *)(a2 + 192))
  {
    v82 = palloc(0x28uLL);
    v83 = pg_query__node__init(v82);
    *((_QWORD *)v3 + 38) = v82;
    result = (_DWORD *)_outNode_0(v82, *(_QWORD *)(a2 + 192), v83);
  }
  v84 = *(_QWORD *)(a2 + 200);
  if (v84)
  {
    v85 = *(int *)(v84 + 4);
    *((_QWORD *)v3 + 39) = v85;
    result = (_DWORD *)palloc(8 * v85);
    *((_QWORD *)v3 + 40) = result;
    if (*((_QWORD *)v3 + 39))
    {
      v86 = 0;
      v87 = 1;
      do
      {
        v88 = palloc(0x28uLL);
        v89 = pg_query__node__init(v88);
        *(_QWORD *)(*((_QWORD *)v3 + 40) + 8 * v86) = v88;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 40) + 8 * v86), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 200) + 16) + 8 * v86), v89);
        v86 = v87++;
      }
      while (*((_QWORD *)v3 + 39) > v86);
    }
  }
  v90 = *(_QWORD *)(a2 + 208);
  if (v90)
  {
    v91 = *(int *)(v90 + 4);
    *((_QWORD *)v3 + 41) = v91;
    result = (_DWORD *)palloc(8 * v91);
    *((_QWORD *)v3 + 42) = result;
    if (*((_QWORD *)v3 + 41))
    {
      v92 = 0;
      v93 = 1;
      do
      {
        v94 = palloc(0x28uLL);
        v95 = pg_query__node__init(v94);
        *(_QWORD *)(*((_QWORD *)v3 + 42) + 8 * v92) = v94;
        result = (_DWORD *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 42) + 8 * v92), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 208) + 16) + 8 * v92), v95);
        v92 = v93++;
      }
      while (*((_QWORD *)v3 + 41) > v92);
    }
  }
  v3[86] = *(_DWORD *)(a2 + 216);
  v3[87] = *(_DWORD *)(a2 + 220);
  return result;
}

uint64_t _outInsertStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  double v19;
  _OWORD *v20;
  unsigned int v21;
  int v22;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(v3 + 24) = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(v3 + 32) = v6;
    result = palloc(8 * v6);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(v3 + 32) > v7);
    }
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v11 = palloc(0x28uLL);
    v12 = pg_query__node__init(v11);
    *(_QWORD *)(v3 + 48) = v11;
    result = _outNode_0(v11, *(_QWORD *)(a2 + 24), v12);
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v13 = palloc(0x48uLL);
    pg_query__on_conflict_clause__init(v13);
    result = _outOnConflictClause_0(v13, *(_QWORD *)(a2 + 32));
    *(_QWORD *)(v3 + 56) = v13;
  }
  v14 = *(_QWORD *)(a2 + 40);
  if (v14)
  {
    v15 = *(int *)(v14 + 4);
    *(_QWORD *)(v3 + 64) = v15;
    result = palloc(8 * v15);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = palloc(0x28uLL);
        v19 = pg_query__node__init(v18);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v16) = v18;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v16), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v16), v19);
        v16 = v17++;
      }
      while (*(_QWORD *)(v3 + 64) > v16);
    }
  }
  if (*(_QWORD *)(a2 + 48))
  {
    v20 = (_OWORD *)palloc(0x30uLL);
    pg_query__with_clause__init(v20);
    result = _outWithClause_0((uint64_t)v20, *(_QWORD *)(a2 + 48));
    *(_QWORD *)(v3 + 80) = v20;
  }
  v21 = *(_DWORD *)(a2 + 56);
  if (v21 < 3)
    v22 = v21 + 1;
  else
    v22 = -1;
  *(_DWORD *)(v3 + 88) = v22;
  return result;
}

uint64_t _outDeleteStmt_0(uint64_t result, uint64_t *a2)
{
  _QWORD *v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  double v18;
  _OWORD *v19;

  v3 = (_QWORD *)result;
  if (a2[1])
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, a2[1]);
    v3[3] = v4;
  }
  v5 = a2[2];
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    v3[4] = v6;
    result = palloc(8 * v6);
    v3[5] = result;
    if (v3[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(v3[5] + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(v3[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(a2[2] + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (v3[4] > v7);
    }
  }
  if (a2[3])
  {
    v11 = palloc(0x28uLL);
    v12 = pg_query__node__init(v11);
    v3[6] = v11;
    result = _outNode_0(v11, a2[3], v12);
  }
  v13 = a2[4];
  if (v13)
  {
    v14 = *(int *)(v13 + 4);
    v3[7] = v14;
    result = palloc(8 * v14);
    v3[8] = result;
    if (v3[7])
    {
      v15 = 0;
      v16 = 1;
      do
      {
        v17 = palloc(0x28uLL);
        v18 = pg_query__node__init(v17);
        *(_QWORD *)(v3[8] + 8 * v15) = v17;
        result = _outNode_0(*(_QWORD *)(v3[8] + 8 * v15), *(_QWORD *)(*(_QWORD *)(a2[4] + 16) + 8 * v15), v18);
        v15 = v16++;
      }
      while (v3[7] > v15);
    }
  }
  if (a2[5])
  {
    v19 = (_OWORD *)palloc(0x30uLL);
    pg_query__with_clause__init(v19);
    result = _outWithClause_0((uint64_t)v19, a2[5]);
    v3[9] = v19;
  }
  return result;
}

uint64_t _outUpdateStmt_0(uint64_t result, uint64_t *a2)
{
  _QWORD *v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  double v24;
  _OWORD *v25;

  v3 = (_QWORD *)result;
  if (a2[1])
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, a2[1]);
    v3[3] = v4;
  }
  v5 = a2[2];
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    v3[4] = v6;
    result = palloc(8 * v6);
    v3[5] = result;
    if (v3[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(v3[5] + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(v3[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(a2[2] + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (v3[4] > v7);
    }
  }
  if (a2[3])
  {
    v11 = palloc(0x28uLL);
    v12 = pg_query__node__init(v11);
    v3[6] = v11;
    result = _outNode_0(v11, a2[3], v12);
  }
  v13 = a2[4];
  if (v13)
  {
    v14 = *(int *)(v13 + 4);
    v3[7] = v14;
    result = palloc(8 * v14);
    v3[8] = result;
    if (v3[7])
    {
      v15 = 0;
      v16 = 1;
      do
      {
        v17 = palloc(0x28uLL);
        v18 = pg_query__node__init(v17);
        *(_QWORD *)(v3[8] + 8 * v15) = v17;
        result = _outNode_0(*(_QWORD *)(v3[8] + 8 * v15), *(_QWORD *)(*(_QWORD *)(a2[4] + 16) + 8 * v15), v18);
        v15 = v16++;
      }
      while (v3[7] > v15);
    }
  }
  v19 = a2[5];
  if (v19)
  {
    v20 = *(int *)(v19 + 4);
    v3[9] = v20;
    result = palloc(8 * v20);
    v3[10] = result;
    if (v3[9])
    {
      v21 = 0;
      v22 = 1;
      do
      {
        v23 = palloc(0x28uLL);
        v24 = pg_query__node__init(v23);
        *(_QWORD *)(v3[10] + 8 * v21) = v23;
        result = _outNode_0(*(_QWORD *)(v3[10] + 8 * v21), *(_QWORD *)(*(_QWORD *)(a2[5] + 16) + 8 * v21), v24);
        v21 = v22++;
      }
      while (v3[9] > v21);
    }
  }
  if (a2[6])
  {
    v25 = (_OWORD *)palloc(0x30uLL);
    pg_query__with_clause__init(v25);
    result = _outWithClause_0((uint64_t)v25, a2[6]);
    v3[11] = v25;
  }
  return result;
}

uint64_t _outSelectStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  double v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  double v30;
  uint64_t v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  double v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  int v42;
  uint64_t v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  double v50;
  uint64_t v51;
  double v52;
  uint64_t v53;
  double v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  int v60;
  uint64_t v61;
  double v62;
  _OWORD *v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  double select_stmt__init;
  uint64_t v68;
  double v69;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v10 = palloc(0x68uLL);
    pg_query__into_clause__init(v10);
    result = (uint64_t)_outIntoClause_0(v10, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(v3 + 40) = v10;
  }
  v11 = *(_QWORD *)(a2 + 24);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    *(_QWORD *)(v3 + 48) = v12;
    result = palloc(8 * v12);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v13) = v15;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (*(_QWORD *)(v3 + 48) > v13);
    }
  }
  v17 = *(_QWORD *)(a2 + 32);
  if (v17)
  {
    v18 = *(int *)(v17 + 4);
    *(_QWORD *)(v3 + 64) = v18;
    result = palloc(8 * v18);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v19 = 0;
      v20 = 1;
      do
      {
        v21 = palloc(0x28uLL);
        v22 = pg_query__node__init(v21);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v19) = v21;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v19), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v19), v22);
        v19 = v20++;
      }
      while (*(_QWORD *)(v3 + 64) > v19);
    }
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v23 = palloc(0x28uLL);
    v24 = pg_query__node__init(v23);
    *(_QWORD *)(v3 + 80) = v23;
    result = _outNode_0(v23, *(_QWORD *)(a2 + 40), v24);
  }
  v25 = *(_QWORD *)(a2 + 48);
  if (v25)
  {
    v26 = *(int *)(v25 + 4);
    *(_QWORD *)(v3 + 88) = v26;
    result = palloc(8 * v26);
    *(_QWORD *)(v3 + 96) = result;
    if (*(_QWORD *)(v3 + 88))
    {
      v27 = 0;
      v28 = 1;
      do
      {
        v29 = palloc(0x28uLL);
        v30 = pg_query__node__init(v29);
        *(_QWORD *)(*(_QWORD *)(v3 + 96) + 8 * v27) = v29;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 96) + 8 * v27), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v27), v30);
        v27 = v28++;
      }
      while (*(_QWORD *)(v3 + 88) > v27);
    }
  }
  if (*(_QWORD *)(a2 + 56))
  {
    v31 = palloc(0x28uLL);
    v32 = pg_query__node__init(v31);
    *(_QWORD *)(v3 + 104) = v31;
    result = _outNode_0(v31, *(_QWORD *)(a2 + 56), v32);
  }
  v33 = *(_QWORD *)(a2 + 64);
  if (v33)
  {
    v34 = *(int *)(v33 + 4);
    *(_QWORD *)(v3 + 112) = v34;
    result = palloc(8 * v34);
    *(_QWORD *)(v3 + 120) = result;
    if (*(_QWORD *)(v3 + 112))
    {
      v35 = 0;
      v36 = 1;
      do
      {
        v37 = palloc(0x28uLL);
        v38 = pg_query__node__init(v37);
        *(_QWORD *)(*(_QWORD *)(v3 + 120) + 8 * v35) = v37;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 120) + 8 * v35), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16) + 8 * v35), v38);
        v35 = v36++;
      }
      while (*(_QWORD *)(v3 + 112) > v35);
    }
  }
  v39 = *(_QWORD *)(a2 + 72);
  if (v39)
  {
    v40 = *(int *)(v39 + 4);
    *(_QWORD *)(v3 + 128) = v40;
    result = palloc(8 * v40);
    *(_QWORD *)(v3 + 136) = result;
    if (*(_QWORD *)(v3 + 128))
    {
      v41 = 0;
      v42 = 1;
      do
      {
        v43 = palloc(0x28uLL);
        v44 = pg_query__node__init(v43);
        *(_QWORD *)(*(_QWORD *)(v3 + 136) + 8 * v41) = v43;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 136) + 8 * v41), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16) + 8 * v41), v44);
        v41 = v42++;
      }
      while (*(_QWORD *)(v3 + 128) > v41);
    }
  }
  v45 = *(_QWORD *)(a2 + 80);
  if (v45)
  {
    v46 = *(int *)(v45 + 4);
    *(_QWORD *)(v3 + 144) = v46;
    result = palloc(8 * v46);
    *(_QWORD *)(v3 + 152) = result;
    if (*(_QWORD *)(v3 + 144))
    {
      v47 = 0;
      v48 = 1;
      do
      {
        v49 = palloc(0x28uLL);
        v50 = pg_query__node__init(v49);
        *(_QWORD *)(*(_QWORD *)(v3 + 152) + 8 * v47) = v49;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 152) + 8 * v47), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 16) + 8 * v47), v50);
        v47 = v48++;
      }
      while (*(_QWORD *)(v3 + 144) > v47);
    }
  }
  if (*(_QWORD *)(a2 + 88))
  {
    v51 = palloc(0x28uLL);
    v52 = pg_query__node__init(v51);
    *(_QWORD *)(v3 + 160) = v51;
    result = _outNode_0(v51, *(_QWORD *)(a2 + 88), v52);
  }
  if (*(_QWORD *)(a2 + 96))
  {
    v53 = palloc(0x28uLL);
    v54 = pg_query__node__init(v53);
    *(_QWORD *)(v3 + 168) = v53;
    result = _outNode_0(v53, *(_QWORD *)(a2 + 96), v54);
  }
  v55 = *(_DWORD *)(a2 + 104);
  if (v55 < 3)
    v56 = v55 + 1;
  else
    v56 = -1;
  *(_DWORD *)(v3 + 176) = v56;
  v57 = *(_QWORD *)(a2 + 112);
  if (v57)
  {
    v58 = *(int *)(v57 + 4);
    *(_QWORD *)(v3 + 184) = v58;
    result = palloc(8 * v58);
    *(_QWORD *)(v3 + 192) = result;
    if (*(_QWORD *)(v3 + 184))
    {
      v59 = 0;
      v60 = 1;
      do
      {
        v61 = palloc(0x28uLL);
        v62 = pg_query__node__init(v61);
        *(_QWORD *)(*(_QWORD *)(v3 + 192) + 8 * v59) = v61;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 192) + 8 * v59), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 16) + 8 * v59), v62);
        v59 = v60++;
      }
      while (*(_QWORD *)(v3 + 184) > v59);
    }
  }
  if (*(_QWORD *)(a2 + 120))
  {
    v63 = (_OWORD *)palloc(0x30uLL);
    pg_query__with_clause__init(v63);
    result = _outWithClause_0((uint64_t)v63, *(_QWORD *)(a2 + 120));
    *(_QWORD *)(v3 + 200) = v63;
  }
  v64 = *(_DWORD *)(a2 + 128);
  if (v64 < 4)
    v65 = v64 + 1;
  else
    v65 = -1;
  *(_DWORD *)(v3 + 208) = v65;
  *(_DWORD *)(v3 + 212) = *(unsigned __int8 *)(a2 + 132);
  if (*(_QWORD *)(a2 + 136))
  {
    v66 = palloc(0xE8uLL);
    select_stmt__init = pg_query__select_stmt__init(v66);
    result = _outSelectStmt_0(v66, *(_QWORD *)(a2 + 136), select_stmt__init);
    *(_QWORD *)(v3 + 216) = v66;
  }
  if (*(_QWORD *)(a2 + 144))
  {
    v68 = palloc(0xE8uLL);
    v69 = pg_query__select_stmt__init(v68);
    result = _outSelectStmt_0(v68, *(_QWORD *)(a2 + 144), v69);
    *(_QWORD *)(v3 + 224) = v68;
  }
  return result;
}

uint64_t _outAlterTableStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  unsigned int v11;
  int v12;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(v3 + 24) = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(v3 + 32) = v6;
    result = palloc(8 * v6);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(v3 + 32) > v7);
    }
  }
  v11 = *(_DWORD *)(a2 + 24);
  if (v11 < 0x32)
    v12 = v11 + 1;
  else
    v12 = -1;
  *(_DWORD *)(v3 + 48) = v12;
  *(_DWORD *)(v3 + 52) = *(unsigned __int8 *)(a2 + 28);
  return result;
}

const char *_outAlterTableCmd_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  const char *result;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  double node__init;
  int v13;
  int v14;
  int v15;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x43)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  *(_DWORD *)(a1 + 40) = *(__int16 *)(a2 + 16);
  if (*(_QWORD *)(a2 + 24))
  {
    v7 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v7);
    v8 = *(_QWORD *)(a2 + 24);
    v9 = *(_DWORD *)(v8 + 4);
    if (v9 < 4)
      v10 = v9 + 1;
    else
      v10 = -1;
    *(_DWORD *)(v7 + 24) = v10;
    result = *(const char **)(v8 + 8);
    if (result)
    {
      result = (const char *)pstrdup(result);
      *(_QWORD *)(v7 + 32) = result;
    }
    *(_DWORD *)(v7 + 40) = *(_DWORD *)(v8 + 16);
    *(_QWORD *)(a1 + 48) = v7;
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v11 = palloc(0x28uLL);
    node__init = pg_query__node__init(v11);
    *(_QWORD *)(a1 + 56) = v11;
    result = (const char *)_outNode_0(v11, *(_QWORD *)(a2 + 32), node__init);
  }
  v13 = *(_DWORD *)(a2 + 40);
  if (v13 == 1)
    v14 = 2;
  else
    v14 = -1;
  if (v13)
    v15 = v14;
  else
    v15 = 1;
  *(_DWORD *)(a1 + 64) = v15;
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a2 + 44);
  return result;
}

const char *_outAlterDomainStmt_0(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  const char *result;
  uint64_t v12;
  double v13;
  int v14;
  int v15;
  int v16;

  if (*(_BYTE *)(a2 + 4))
  {
    v4 = (_BYTE *)palloc(2uLL);
    *(_QWORD *)(a1 + 24) = v4;
    *v4 = *(_BYTE *)(a2 + 4);
    *(_BYTE *)(*(_QWORD *)(a1 + 24) + 1) = 0;
  }
  v5 = *(_QWORD *)(a2 + 8);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 32) = v6;
    *(_QWORD *)(a1 + 40) = palloc(8 * v6);
    if (*(_QWORD *)(a1 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7) = v9;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 32) > v7);
    }
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 48) = result;
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v12 = palloc(0x28uLL);
    v13 = pg_query__node__init(v12);
    *(_QWORD *)(a1 + 56) = v12;
    result = (const char *)_outNode_0(v12, *(_QWORD *)(a2 + 24), v13);
  }
  v14 = *(_DWORD *)(a2 + 32);
  if (v14 == 1)
    v15 = 2;
  else
    v15 = -1;
  if (v14)
    v16 = v15;
  else
    v16 = 1;
  *(_DWORD *)(a1 + 64) = v16;
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a2 + 36);
  return result;
}

uint64_t _outSetOperationStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  double node__init;
  uint64_t v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  double v33;

  v3 = (_QWORD *)result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 4)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 24) = v5;
  *(_DWORD *)(result + 28) = *(unsigned __int8 *)(a2 + 8);
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    v3[4] = v6;
    result = _outNode_0(v6, *(_QWORD *)(a2 + 16), node__init);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v8 = palloc(0x28uLL);
    v9 = pg_query__node__init(v8);
    v3[5] = v8;
    result = _outNode_0(v8, *(_QWORD *)(a2 + 24), v9);
  }
  v10 = *(_QWORD *)(a2 + 32);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    v3[6] = v11;
    result = palloc(8 * v11);
    v3[7] = result;
    if (v3[6])
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(v3[7] + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(v3[7] + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (v3[6] > v12);
    }
  }
  v16 = *(_QWORD *)(a2 + 40);
  if (v16)
  {
    v17 = *(int *)(v16 + 4);
    v3[8] = v17;
    result = palloc(8 * v17);
    v3[9] = result;
    if (v3[8])
    {
      v18 = 0;
      v19 = 1;
      do
      {
        v20 = palloc(0x28uLL);
        v21 = pg_query__node__init(v20);
        *(_QWORD *)(v3[9] + 8 * v18) = v20;
        result = _outNode_0(*(_QWORD *)(v3[9] + 8 * v18), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v18), v21);
        v18 = v19++;
      }
      while (v3[8] > v18);
    }
  }
  v22 = *(_QWORD *)(a2 + 48);
  if (v22)
  {
    v23 = *(int *)(v22 + 4);
    v3[10] = v23;
    result = palloc(8 * v23);
    v3[11] = result;
    if (v3[10])
    {
      v24 = 0;
      v25 = 1;
      do
      {
        v26 = palloc(0x28uLL);
        v27 = pg_query__node__init(v26);
        *(_QWORD *)(v3[11] + 8 * v24) = v26;
        result = _outNode_0(*(_QWORD *)(v3[11] + 8 * v24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v24), v27);
        v24 = v25++;
      }
      while (v3[10] > v24);
    }
  }
  v28 = *(_QWORD *)(a2 + 56);
  if (v28)
  {
    v29 = *(int *)(v28 + 4);
    v3[12] = v29;
    result = palloc(8 * v29);
    v3[13] = result;
    if (v3[12])
    {
      v30 = 0;
      v31 = 1;
      do
      {
        v32 = palloc(0x28uLL);
        v33 = pg_query__node__init(v32);
        *(_QWORD *)(v3[13] + 8 * v30) = v32;
        result = _outNode_0(*(_QWORD *)(v3[13] + 8 * v30), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v30), v33);
        v30 = v31++;
      }
      while (v3[12] > v30);
    }
  }
  return result;
}

uint64_t _outGrantStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double node__init;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  double v25;
  int v26;
  int v27;
  int v28;

  v3 = result;
  *(_DWORD *)(result + 24) = *(unsigned __int8 *)(a2 + 4);
  v4 = *(_DWORD *)(a2 + 8);
  if (v4 < 3)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 28) = v5;
  v6 = *(_DWORD *)(a2 + 12);
  if (v6 < 0x32)
    v7 = v6 + 1;
  else
    v7 = -1;
  *(_DWORD *)(result + 32) = v7;
  v8 = *(_QWORD *)(a2 + 16);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *(_QWORD *)(result + 40) = v9;
    result = palloc(8 * v9);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        node__init = pg_query__node__init(v12);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v10) = v12;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v10), node__init);
        v10 = v11++;
      }
      while (*(_QWORD *)(v3 + 40) > v10);
    }
  }
  v14 = *(_QWORD *)(a2 + 24);
  if (v14)
  {
    v15 = *(int *)(v14 + 4);
    *(_QWORD *)(v3 + 56) = v15;
    result = palloc(8 * v15);
    *(_QWORD *)(v3 + 64) = result;
    if (*(_QWORD *)(v3 + 56))
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = palloc(0x28uLL);
        v19 = pg_query__node__init(v18);
        *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v16) = v18;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v16), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v16), v19);
        v16 = v17++;
      }
      while (*(_QWORD *)(v3 + 56) > v16);
    }
  }
  v20 = *(_QWORD *)(a2 + 32);
  if (v20)
  {
    v21 = *(int *)(v20 + 4);
    *(_QWORD *)(v3 + 72) = v21;
    result = palloc(8 * v21);
    *(_QWORD *)(v3 + 80) = result;
    if (*(_QWORD *)(v3 + 72))
    {
      v22 = 0;
      v23 = 1;
      do
      {
        v24 = palloc(0x28uLL);
        v25 = pg_query__node__init(v24);
        *(_QWORD *)(*(_QWORD *)(v3 + 80) + 8 * v22) = v24;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 8 * v22), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v22), v25);
        v22 = v23++;
      }
      while (*(_QWORD *)(v3 + 72) > v22);
    }
  }
  *(_DWORD *)(v3 + 88) = *(unsigned __int8 *)(a2 + 40);
  v26 = *(_DWORD *)(a2 + 44);
  if (v26 == 1)
    v27 = 2;
  else
    v27 = -1;
  if (v26)
    v28 = v27;
  else
    v28 = 1;
  *(_DWORD *)(v3 + 92) = v28;
  return result;
}

uint64_t _outGrantRoleStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 40) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 40) > v12);
    }
  }
  *(_DWORD *)(v3 + 56) = *(unsigned __int8 *)(a2 + 24);
  *(_DWORD *)(v3 + 60) = *(unsigned __int8 *)(a2 + 25);
  if (*(_QWORD *)(a2 + 32))
  {
    v16 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v16);
    v17 = *(_QWORD *)(a2 + 32);
    v18 = *(_DWORD *)(v17 + 4);
    if (v18 < 4)
      v19 = v18 + 1;
    else
      v19 = -1;
    *(_DWORD *)(v16 + 24) = v19;
    result = *(_QWORD *)(v17 + 8);
    if (result)
    {
      result = (uint64_t)pstrdup((const char *)result);
      *(_QWORD *)(v16 + 32) = result;
    }
    *(_DWORD *)(v16 + 40) = *(_DWORD *)(v17 + 16);
    *(_QWORD *)(v3 + 64) = v16;
  }
  v20 = *(_DWORD *)(a2 + 40);
  if (v20 == 1)
    v21 = 2;
  else
    v21 = -1;
  if (v20)
    v22 = v21;
  else
    v22 = 1;
  *(_DWORD *)(v3 + 72) = v22;
  return result;
}

uint64_t _outAlterDefaultPrivilegesStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  _OWORD *v10;

  v3 = (_QWORD *)result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    v3[4] = result;
    if (v3[3])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[4] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[4] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[3] > v6);
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v10 = (_OWORD *)palloc(0x60uLL);
    pg_query__grant_stmt__init(v10);
    result = _outGrantStmt_0((uint64_t)v10, *(_QWORD *)(a2 + 16));
    v3[5] = v10;
  }
  return result;
}

const char *_outClusterStmt_0(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  const char *result;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    _outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 24) = v4;
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 24);
  return result;
}

const char *_outCopyStmt_0(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  uint64_t v5;
  double node__init;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double v12;
  const char *result;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  double v21;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    _outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 24) = v4;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = palloc(0x28uLL);
    node__init = pg_query__node__init(v5);
    *(_QWORD *)(a1 + 32) = v5;
    _outNode_0(v5, *(_QWORD *)(a2 + 16), node__init);
  }
  v7 = *(_QWORD *)(a2 + 24);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    *(_QWORD *)(a1 + 40) = v8;
    *(_QWORD *)(a1 + 48) = palloc(8 * v8);
    if (*(_QWORD *)(a1 + 40))
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        v12 = pg_query__node__init(v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9) = v11;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v9), v12);
        v9 = v10++;
      }
      while (*(_QWORD *)(a1 + 40) > v9);
    }
  }
  *(_DWORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 32);
  *(_DWORD *)(a1 + 60) = *(unsigned __int8 *)(a2 + 33);
  result = *(const char **)(a2 + 40);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 64) = result;
  }
  v14 = *(_QWORD *)(a2 + 48);
  if (v14)
  {
    v15 = *(int *)(v14 + 4);
    *(_QWORD *)(a1 + 72) = v15;
    result = (const char *)palloc(8 * v15);
    *(_QWORD *)(a1 + 80) = result;
    if (*(_QWORD *)(a1 + 72))
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = palloc(0x28uLL);
        v19 = pg_query__node__init(v18);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v16) = v18;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v16), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v16), v19);
        v16 = v17++;
      }
      while (*(_QWORD *)(a1 + 72) > v16);
    }
  }
  if (*(_QWORD *)(a2 + 56))
  {
    v20 = palloc(0x28uLL);
    v21 = pg_query__node__init(v20);
    *(_QWORD *)(a1 + 88) = v20;
    return (const char *)_outNode_0(v20, *(_QWORD *)(a2 + 56), v21);
  }
  return result;
}

const char *_outCreateStmt_0(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  double v31;
  unsigned int v32;
  int v33;
  const char *v34;
  const char *result;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    _outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 24) = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 32) = v6;
    *(_QWORD *)(a1 + 40) = palloc(8 * v6);
    if (*(_QWORD *)(a1 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7) = v9;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 32) > v7);
    }
  }
  v11 = *(_QWORD *)(a2 + 24);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    *(_QWORD *)(a1 + 48) = v12;
    *(_QWORD *)(a1 + 56) = palloc(8 * v12);
    if (*(_QWORD *)(a1 + 48))
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v13) = v15;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (*(_QWORD *)(a1 + 48) > v13);
    }
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v17 = (_BYTE *)palloc(0x68uLL);
    pg_query__partition_bound_spec__init((uint64_t)v17);
    _outPartitionBoundSpec_0(v17, *(_QWORD *)(a2 + 32));
    *(_QWORD *)(a1 + 64) = v17;
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v18 = palloc(0x38uLL);
    pg_query__partition_spec__init(v18);
    _outPartitionSpec_0(v18, *(_QWORD *)(a2 + 40));
    *(_QWORD *)(a1 + 72) = v18;
  }
  if (*(_QWORD *)(a2 + 48))
  {
    v19 = palloc(0x68uLL);
    pg_query__type_name__init(v19);
    _outTypeName_0(v19, *(_QWORD *)(a2 + 48));
    *(_QWORD *)(a1 + 80) = v19;
  }
  v20 = *(_QWORD *)(a2 + 56);
  if (v20)
  {
    v21 = *(int *)(v20 + 4);
    *(_QWORD *)(a1 + 88) = v21;
    *(_QWORD *)(a1 + 96) = palloc(8 * v21);
    if (*(_QWORD *)(a1 + 88))
    {
      v22 = 0;
      v23 = 1;
      do
      {
        v24 = palloc(0x28uLL);
        v25 = pg_query__node__init(v24);
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v22) = v24;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v22), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v22), v25);
        v22 = v23++;
      }
      while (*(_QWORD *)(a1 + 88) > v22);
    }
  }
  v26 = *(_QWORD *)(a2 + 64);
  if (v26)
  {
    v27 = *(int *)(v26 + 4);
    *(_QWORD *)(a1 + 104) = v27;
    *(_QWORD *)(a1 + 112) = palloc(8 * v27);
    if (*(_QWORD *)(a1 + 104))
    {
      v28 = 0;
      v29 = 1;
      do
      {
        v30 = palloc(0x28uLL);
        v31 = pg_query__node__init(v30);
        *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v28) = v30;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v28), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 64) + 16) + 8 * v28), v31);
        v28 = v29++;
      }
      while (*(_QWORD *)(a1 + 104) > v28);
    }
  }
  v32 = *(_DWORD *)(a2 + 72);
  if (v32 < 4)
    v33 = v32 + 1;
  else
    v33 = -1;
  *(_DWORD *)(a1 + 120) = v33;
  v34 = *(const char **)(a2 + 80);
  if (v34)
    *(_QWORD *)(a1 + 128) = pstrdup(v34);
  result = *(const char **)(a2 + 88);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 136) = result;
  }
  *(_DWORD *)(a1 + 144) = *(unsigned __int8 *)(a2 + 96);
  return result;
}

uint64_t _outDefineStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  double v23;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 24) = v5;
  *(_DWORD *)(result + 28) = *(unsigned __int8 *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(result + 32) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 32) > v8);
    }
  }
  v12 = *(_QWORD *)(a2 + 24);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(v3 + 48) = v13;
    result = palloc(8 * v13);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v14) = v16;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(v3 + 48) > v14);
    }
  }
  v18 = *(_QWORD *)(a2 + 32);
  if (v18)
  {
    v19 = *(int *)(v18 + 4);
    *(_QWORD *)(v3 + 64) = v19;
    result = palloc(8 * v19);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v20 = 0;
      v21 = 1;
      do
      {
        v22 = palloc(0x28uLL);
        v23 = pg_query__node__init(v22);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v20) = v22;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v20), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v20), v23);
        v20 = v21++;
      }
      while (*(_QWORD *)(v3 + 64) > v20);
    }
  }
  *(_DWORD *)(v3 + 80) = *(unsigned __int8 *)(a2 + 40);
  *(_DWORD *)(v3 + 84) = *(unsigned __int8 *)(a2 + 41);
  return result;
}

uint64_t _outDropStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  int v14;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  v10 = *(_DWORD *)(a2 + 16);
  if (v10 < 0x32)
    v11 = v10 + 1;
  else
    v11 = -1;
  *(_DWORD *)(v3 + 40) = v11;
  v12 = *(_DWORD *)(a2 + 20);
  if (v12 == 1)
    v13 = 2;
  else
    v13 = -1;
  if (v12)
    v14 = v13;
  else
    v14 = 1;
  *(_DWORD *)(v3 + 44) = v14;
  *(_DWORD *)(v3 + 48) = *(unsigned __int8 *)(a2 + 24);
  *(_DWORD *)(v3 + 52) = *(unsigned __int8 *)(a2 + 25);
  return result;
}

uint64_t _outTruncateStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  int v10;
  int v11;
  int v12;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  *(_DWORD *)(v3 + 40) = *(unsigned __int8 *)(a2 + 16);
  v10 = *(_DWORD *)(a2 + 20);
  if (v10 == 1)
    v11 = 2;
  else
    v11 = -1;
  if (v10)
    v12 = v11;
  else
    v12 = 1;
  *(_DWORD *)(v3 + 44) = v12;
  return result;
}

const char *_outCommentStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  double node__init;
  const char *result;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    *(_QWORD *)(a1 + 32) = v6;
    _outNode_0(v6, *(_QWORD *)(a2 + 8), node__init);
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  return result;
}

const char *_outFetchStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  const char *result;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 4)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 8);
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  *(_DWORD *)(a1 + 48) = *(unsigned __int8 *)(a2 + 24);
  return result;
}

const char *_outIndexStmt_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  _OWORD *v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double node__init;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  double v33;
  const char *result;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v5);
    _outRangeVar_0((uint64_t)v5, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(a1 + 32) = v5;
  }
  v6 = *(const char **)(a2 + 24);
  if (v6)
    *(_QWORD *)(a1 + 40) = pstrdup(v6);
  v7 = *(const char **)(a2 + 32);
  if (v7)
    *(_QWORD *)(a1 + 48) = pstrdup(v7);
  v8 = *(_QWORD *)(a2 + 40);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *(_QWORD *)(a1 + 56) = v9;
    *(_QWORD *)(a1 + 64) = palloc(8 * v9);
    if (*(_QWORD *)(a1 + 56))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        node__init = pg_query__node__init(v12);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v10) = v12;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v10), node__init);
        v10 = v11++;
      }
      while (*(_QWORD *)(a1 + 56) > v10);
    }
  }
  v14 = *(_QWORD *)(a2 + 48);
  if (v14)
  {
    v15 = *(int *)(v14 + 4);
    *(_QWORD *)(a1 + 72) = v15;
    *(_QWORD *)(a1 + 80) = palloc(8 * v15);
    if (*(_QWORD *)(a1 + 72))
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = palloc(0x28uLL);
        v19 = pg_query__node__init(v18);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v16) = v18;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v16), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v16), v19);
        v16 = v17++;
      }
      while (*(_QWORD *)(a1 + 72) > v16);
    }
  }
  v20 = *(_QWORD *)(a2 + 56);
  if (v20)
  {
    v21 = *(int *)(v20 + 4);
    *(_QWORD *)(a1 + 88) = v21;
    *(_QWORD *)(a1 + 96) = palloc(8 * v21);
    if (*(_QWORD *)(a1 + 88))
    {
      v22 = 0;
      v23 = 1;
      do
      {
        v24 = palloc(0x28uLL);
        v25 = pg_query__node__init(v24);
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v22) = v24;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v22), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 56) + 16) + 8 * v22), v25);
        v22 = v23++;
      }
      while (*(_QWORD *)(a1 + 88) > v22);
    }
  }
  if (*(_QWORD *)(a2 + 64))
  {
    v26 = palloc(0x28uLL);
    v27 = pg_query__node__init(v26);
    *(_QWORD *)(a1 + 104) = v26;
    _outNode_0(v26, *(_QWORD *)(a2 + 64), v27);
  }
  v28 = *(_QWORD *)(a2 + 72);
  if (v28)
  {
    v29 = *(int *)(v28 + 4);
    *(_QWORD *)(a1 + 112) = v29;
    *(_QWORD *)(a1 + 120) = palloc(8 * v29);
    if (*(_QWORD *)(a1 + 112))
    {
      v30 = 0;
      v31 = 1;
      do
      {
        v32 = palloc(0x28uLL);
        v33 = pg_query__node__init(v32);
        *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8 * v30) = v32;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8 * v30), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16) + 8 * v30), v33);
        v30 = v31++;
      }
      while (*(_QWORD *)(a1 + 112) > v30);
    }
  }
  result = *(const char **)(a2 + 80);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 128) = result;
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a1 + 140) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 100);
  *(_DWORD *)(a1 + 152) = *(unsigned __int8 *)(a2 + 104);
  *(_DWORD *)(a1 + 156) = *(unsigned __int8 *)(a2 + 105);
  *(_DWORD *)(a1 + 160) = *(unsigned __int8 *)(a2 + 106);
  *(_DWORD *)(a1 + 164) = *(unsigned __int8 *)(a2 + 107);
  *(_DWORD *)(a1 + 168) = *(unsigned __int8 *)(a2 + 108);
  *(_DWORD *)(a1 + 172) = *(unsigned __int8 *)(a2 + 109);
  *(_DWORD *)(a1 + 176) = *(unsigned __int8 *)(a2 + 110);
  *(_DWORD *)(a1 + 180) = *(unsigned __int8 *)(a2 + 111);
  *(_DWORD *)(a1 + 184) = *(unsigned __int8 *)(a2 + 112);
  return result;
}

uint64_t _outCreateFunctionStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  double v22;

  v3 = (_QWORD *)result;
  *(_DWORD *)(result + 24) = *(unsigned __int8 *)(a2 + 4);
  *(_DWORD *)(result + 28) = *(unsigned __int8 *)(a2 + 5);
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 32) = v5;
    result = palloc(8 * v5);
    v3[5] = result;
    if (v3[4])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[5] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[5] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[4] > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    v3[6] = v11;
    result = palloc(8 * v11);
    v3[7] = result;
    if (v3[6])
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(v3[7] + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(v3[7] + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (v3[6] > v12);
    }
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v16 = palloc(0x68uLL);
    pg_query__type_name__init(v16);
    result = _outTypeName_0(v16, *(_QWORD *)(a2 + 24));
    v3[8] = v16;
  }
  v17 = *(_QWORD *)(a2 + 32);
  if (v17)
  {
    v18 = *(int *)(v17 + 4);
    v3[9] = v18;
    result = palloc(8 * v18);
    v3[10] = result;
    if (v3[9])
    {
      v19 = 0;
      v20 = 1;
      do
      {
        v21 = palloc(0x28uLL);
        v22 = pg_query__node__init(v21);
        *(_QWORD *)(v3[10] + 8 * v19) = v21;
        result = _outNode_0(*(_QWORD *)(v3[10] + 8 * v19), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v19), v22);
        v19 = v20++;
      }
      while (v3[9] > v19);
    }
  }
  return result;
}

uint64_t _outAlterFunctionStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  unsigned int v4;
  int v5;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double node__init;

  v3 = (_QWORD *)result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 24) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = (_OWORD *)palloc(0x40uLL);
    pg_query__object_with_args__init(v6);
    result = _outVacuumStmt_0((uint64_t)v6, *(_QWORD *)(a2 + 8));
    v3[4] = v6;
  }
  v7 = *(_QWORD *)(a2 + 16);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    v3[5] = v8;
    result = palloc(8 * v8);
    v3[6] = result;
    if (v3[5])
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        node__init = pg_query__node__init(v11);
        *(_QWORD *)(v3[6] + 8 * v9) = v11;
        result = _outNode_0(*(_QWORD *)(v3[6] + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v9), node__init);
        v9 = v10++;
      }
      while (v3[5] > v9);
    }
  }
  return result;
}

uint64_t _outDoStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2)
  {
    v4 = result;
    v5 = *(int *)(v2 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v4 + 32) = result;
    if (*(_QWORD *)(v4 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v4 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v4 + 24) > v6);
    }
  }
  return result;
}

const char *_outRenameStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  _OWORD *v8;
  uint64_t v9;
  double node__init;
  const char *v11;
  const char *result;
  int v13;
  int v14;
  int v15;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  v6 = *(_DWORD *)(a2 + 8);
  if (v6 < 0x32)
    v7 = v6 + 1;
  else
    v7 = -1;
  *(_DWORD *)(a1 + 28) = v7;
  if (*(_QWORD *)(a2 + 16))
  {
    v8 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v8);
    _outRangeVar_0((uint64_t)v8, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(a1 + 32) = v8;
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v9 = palloc(0x28uLL);
    node__init = pg_query__node__init(v9);
    *(_QWORD *)(a1 + 40) = v9;
    _outNode_0(v9, *(_QWORD *)(a2 + 24), node__init);
  }
  v11 = *(const char **)(a2 + 32);
  if (v11)
    *(_QWORD *)(a1 + 48) = pstrdup(v11);
  result = *(const char **)(a2 + 40);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 56) = result;
  }
  v13 = *(_DWORD *)(a2 + 48);
  if (v13 == 1)
    v14 = 2;
  else
    v14 = -1;
  if (v13)
    v15 = v14;
  else
    v15 = 1;
  *(_DWORD *)(a1 + 64) = v15;
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a2 + 52);
  return result;
}

const char *_outRuleStmt_0(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  const char *result;
  uint64_t v6;
  double node__init;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    _outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 24) = v4;
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    *(_QWORD *)(a1 + 40) = v6;
    result = (const char *)_outNode_0(v6, *(_QWORD *)(a2 + 24), node__init);
  }
  v8 = *(_DWORD *)(a2 + 32);
  if (v8 < 7)
    v9 = v8 + 1;
  else
    v9 = -1;
  *(_DWORD *)(a1 + 48) = v9;
  *(_DWORD *)(a1 + 52) = *(unsigned __int8 *)(a2 + 36);
  v10 = *(_QWORD *)(a2 + 40);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(a1 + 56) = v11;
    result = (const char *)palloc(8 * v11);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v12) = v14;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(a1 + 56) > v12);
    }
  }
  *(_DWORD *)(a1 + 72) = *(unsigned __int8 *)(a2 + 48);
  return result;
}

const char *_outNotifyStmt_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *result;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  return result;
}

const char *_outTransactionStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  const char *v12;
  const char *result;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0xA)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  v6 = *(_QWORD *)(a2 + 8);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(a1 + 32) = v7;
    *(_QWORD *)(a1 + 40) = palloc(8 * v7);
    if (*(_QWORD *)(a1 + 32))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v8) = v10;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(a1 + 32) > v8);
    }
  }
  v12 = *(const char **)(a2 + 16);
  if (v12)
    *(_QWORD *)(a1 + 48) = pstrdup(v12);
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 56) = result;
  }
  *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(a2 + 32);
  return result;
}

uint64_t _outViewStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  double v18;
  unsigned int v19;
  int v20;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(v3 + 24) = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(v3 + 32) = v6;
    result = palloc(8 * v6);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(v3 + 32) > v7);
    }
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v11 = palloc(0x28uLL);
    v12 = pg_query__node__init(v11);
    *(_QWORD *)(v3 + 48) = v11;
    result = _outNode_0(v11, *(_QWORD *)(a2 + 24), v12);
  }
  *(_DWORD *)(v3 + 56) = *(unsigned __int8 *)(a2 + 32);
  v13 = *(_QWORD *)(a2 + 40);
  if (v13)
  {
    v14 = *(int *)(v13 + 4);
    *(_QWORD *)(v3 + 64) = v14;
    result = palloc(8 * v14);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v15 = 0;
      v16 = 1;
      do
      {
        v17 = palloc(0x28uLL);
        v18 = pg_query__node__init(v17);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v15) = v17;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v15), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v15), v18);
        v15 = v16++;
      }
      while (*(_QWORD *)(v3 + 64) > v15);
    }
  }
  v19 = *(_DWORD *)(a2 + 48);
  if (v19 < 3)
    v20 = v19 + 1;
  else
    v20 = -1;
  *(_DWORD *)(v3 + 80) = v20;
  return result;
}

uint64_t _outCreateDomainStmt_0(uint64_t result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;

  v3 = (_QWORD *)result;
  v4 = a2[1];
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    v3[4] = result;
    if (v3[3])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[4] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[4] + 8 * v6), *(_QWORD *)(*(_QWORD *)(a2[1] + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[3] > v6);
    }
  }
  if (a2[2])
  {
    v10 = palloc(0x68uLL);
    pg_query__type_name__init(v10);
    result = _outTypeName_0(v10, a2[2]);
    v3[5] = v10;
  }
  if (a2[3])
  {
    v11 = palloc(0x38uLL);
    pg_query__collate_clause__init(v11);
    result = _outCollateClause_0(v11, a2[3]);
    v3[6] = v11;
  }
  v12 = a2[4];
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    v3[7] = v13;
    result = palloc(8 * v13);
    v3[8] = result;
    if (v3[7])
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(v3[8] + 8 * v14) = v16;
        result = _outNode_0(*(_QWORD *)(v3[8] + 8 * v14), *(_QWORD *)(*(_QWORD *)(a2[4] + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (v3[7] > v14);
    }
  }
  return result;
}

const char *_outDropdbStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  *(_DWORD *)(a1 + 32) = *(unsigned __int8 *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 24);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 40) = v6;
    result = (const char *)palloc(8 * v6);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 40) > v7);
    }
  }
  return result;
}

uint64_t _outVacuumStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 40) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 40) > v12);
    }
  }
  *(_DWORD *)(v3 + 56) = *(unsigned __int8 *)(a2 + 24);
  return result;
}

uint64_t _outExplainStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double v11;

  v3 = (_QWORD *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    v3[3] = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    v3[4] = v7;
    result = palloc(8 * v7);
    v3[5] = result;
    if (v3[4])
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        v11 = pg_query__node__init(v10);
        *(_QWORD *)(v3[5] + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(v3[5] + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v8), v11);
        v8 = v9++;
      }
      while (v3[4] > v8);
    }
  }
  return result;
}

const char *_outCreateTableAsStmt_0(const char *result, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  unsigned int v7;
  int v8;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *((_QWORD *)v3 + 3) = v4;
    result = (const char *)_outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x68uLL);
    pg_query__into_clause__init(v6);
    result = _outIntoClause_0(v6, *(_QWORD *)(a2 + 16));
    *((_QWORD *)v3 + 4) = v6;
  }
  v7 = *(_DWORD *)(a2 + 24);
  if (v7 < 0x32)
    v8 = v7 + 1;
  else
    v8 = -1;
  *((_DWORD *)v3 + 10) = v8;
  *((_DWORD *)v3 + 11) = *(unsigned __int8 *)(a2 + 28);
  *((_DWORD *)v3 + 12) = *(unsigned __int8 *)(a2 + 29);
  return result;
}

uint64_t _outCreateSeqStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(v3 + 24) = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(v3 + 32) = v6;
    result = palloc(8 * v6);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(v3 + 32) > v7);
    }
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 52) = *(unsigned __int8 *)(a2 + 28);
  *(_DWORD *)(v3 + 56) = *(unsigned __int8 *)(a2 + 29);
  return result;
}

uint64_t _outAlterSeqStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(v3 + 24) = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(v3 + 32) = v6;
    result = palloc(8 * v6);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(v3 + 32) > v7);
    }
  }
  *(_DWORD *)(v3 + 48) = *(unsigned __int8 *)(a2 + 24);
  *(_DWORD *)(v3 + 52) = *(unsigned __int8 *)(a2 + 25);
  return result;
}

const char *_outVariableSetStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  const char *result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double node__init;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 6)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  v7 = *(_QWORD *)(a2 + 16);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    *(_QWORD *)(a1 + 40) = v8;
    result = (const char *)palloc(8 * v8);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        node__init = pg_query__node__init(v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9) = v11;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v9), node__init);
        v9 = v10++;
      }
      while (*(_QWORD *)(a1 + 40) > v9);
    }
  }
  *(_DWORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 24);
  return result;
}

const char *_outCreateTrigStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  double v31;
  _OWORD *v32;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v5);
    result = _outRangeVar_0((uint64_t)v5, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(a1 + 32) = v5;
  }
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(a1 + 40) = v7;
    result = (const char *)palloc(8 * v7);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v8) = v10;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(a1 + 40) > v8);
    }
  }
  v12 = *(_QWORD *)(a2 + 32);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(a1 + 56) = v13;
    result = (const char *)palloc(8 * v13);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14) = v16;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(a1 + 56) > v14);
    }
  }
  *(_DWORD *)(a1 + 72) = *(unsigned __int8 *)(a2 + 40);
  *(_DWORD *)(a1 + 76) = *(__int16 *)(a2 + 42);
  *(_DWORD *)(a1 + 80) = *(__int16 *)(a2 + 44);
  v18 = *(_QWORD *)(a2 + 48);
  if (v18)
  {
    v19 = *(int *)(v18 + 4);
    *(_QWORD *)(a1 + 88) = v19;
    result = (const char *)palloc(8 * v19);
    *(_QWORD *)(a1 + 96) = result;
    if (*(_QWORD *)(a1 + 88))
    {
      v20 = 0;
      v21 = 1;
      do
      {
        v22 = palloc(0x28uLL);
        v23 = pg_query__node__init(v22);
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v20) = v22;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v20), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v20), v23);
        v20 = v21++;
      }
      while (*(_QWORD *)(a1 + 88) > v20);
    }
  }
  if (*(_QWORD *)(a2 + 56))
  {
    v24 = palloc(0x28uLL);
    v25 = pg_query__node__init(v24);
    *(_QWORD *)(a1 + 104) = v24;
    result = (const char *)_outNode_0(v24, *(_QWORD *)(a2 + 56), v25);
  }
  *(_DWORD *)(a1 + 112) = *(unsigned __int8 *)(a2 + 64);
  v26 = *(_QWORD *)(a2 + 72);
  if (v26)
  {
    v27 = *(int *)(v26 + 4);
    *(_QWORD *)(a1 + 120) = v27;
    result = (const char *)palloc(8 * v27);
    *(_QWORD *)(a1 + 128) = result;
    if (*(_QWORD *)(a1 + 120))
    {
      v28 = 0;
      v29 = 1;
      do
      {
        v30 = palloc(0x28uLL);
        v31 = pg_query__node__init(v30);
        *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v28) = v30;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v28), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 16) + 8 * v28), v31);
        v28 = v29++;
      }
      while (*(_QWORD *)(a1 + 120) > v28);
    }
  }
  *(_DWORD *)(a1 + 136) = *(unsigned __int8 *)(a2 + 80);
  *(_DWORD *)(a1 + 140) = *(unsigned __int8 *)(a2 + 81);
  if (*(_QWORD *)(a2 + 88))
  {
    v32 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v32);
    result = _outRangeVar_0((uint64_t)v32, *(_QWORD *)(a2 + 88));
    *(_QWORD *)(a1 + 144) = v32;
  }
  return result;
}

const char *_outCreatePLangStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  double v22;

  *(_DWORD *)(a1 + 24) = *(unsigned __int8 *)(a2 + 4);
  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 40) = v6;
    result = (const char *)palloc(8 * v6);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 40) > v7);
    }
  }
  v11 = *(_QWORD *)(a2 + 24);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    *(_QWORD *)(a1 + 56) = v12;
    result = (const char *)palloc(8 * v12);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13) = v15;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (*(_QWORD *)(a1 + 56) > v13);
    }
  }
  v17 = *(_QWORD *)(a2 + 32);
  if (v17)
  {
    v18 = *(int *)(v17 + 4);
    *(_QWORD *)(a1 + 72) = v18;
    result = (const char *)palloc(8 * v18);
    *(_QWORD *)(a1 + 80) = result;
    if (*(_QWORD *)(a1 + 72))
    {
      v19 = 0;
      v20 = 1;
      do
      {
        v21 = palloc(0x28uLL);
        v22 = pg_query__node__init(v21);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v19) = v21;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v19), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v19), v22);
        v19 = v20++;
      }
      while (*(_QWORD *)(a1 + 72) > v19);
    }
  }
  *(_DWORD *)(a1 + 88) = *(unsigned __int8 *)(a2 + 40);
  return result;
}

const char *_outCreateRoleStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  const char *result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double node__init;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 3)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  v7 = *(_QWORD *)(a2 + 16);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    *(_QWORD *)(a1 + 40) = v8;
    result = (const char *)palloc(8 * v8);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        node__init = pg_query__node__init(v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9) = v11;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v9), node__init);
        v9 = v10++;
      }
      while (*(_QWORD *)(a1 + 40) > v9);
    }
  }
  return result;
}

const char *_outAlterRoleStmt_0(const char *result, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double node__init;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v4);
    v5 = *(_QWORD *)(a2 + 8);
    v6 = *(_DWORD *)(v5 + 4);
    if (v6 < 4)
      v7 = v6 + 1;
    else
      v7 = -1;
    *(_DWORD *)(v4 + 24) = v7;
    result = *(const char **)(v5 + 8);
    if (result)
    {
      result = (const char *)pstrdup(result);
      *(_QWORD *)(v4 + 32) = result;
    }
    *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 16);
    *((_QWORD *)v3 + 3) = v4;
  }
  v8 = *(_QWORD *)(a2 + 16);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *((_QWORD *)v3 + 4) = v9;
    result = (const char *)palloc(8 * v9);
    *((_QWORD *)v3 + 5) = result;
    if (*((_QWORD *)v3 + 4))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        node__init = pg_query__node__init(v12);
        *(_QWORD *)(*((_QWORD *)v3 + 5) + 8 * v10) = v12;
        result = (const char *)_outNode_0(*(_QWORD *)(*((_QWORD *)v3 + 5) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v10), node__init);
        v10 = v11++;
      }
      while (*((_QWORD *)v3 + 4) > v10);
    }
  }
  *((_DWORD *)v3 + 12) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outDropRoleStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  *(_DWORD *)(v3 + 40) = *(unsigned __int8 *)(a2 + 16);
  return result;
}

uint64_t _outLockStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(unsigned __int8 *)(a2 + 20);
  return result;
}

const char *_outReindexStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  _OWORD *v6;
  const char *result;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 5)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v6);
    _outRangeVar_0((uint64_t)v6, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 32) = v6;
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 52) = *(unsigned __int8 *)(a2 + 28);
  return result;
}

const char *_outCreateSchemaStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  double node__init;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v5);
    v6 = *(_QWORD *)(a2 + 16);
    v7 = *(_DWORD *)(v6 + 4);
    if (v7 < 4)
      v8 = v7 + 1;
    else
      v8 = -1;
    *(_DWORD *)(v5 + 24) = v8;
    result = *(const char **)(v6 + 8);
    if (result)
    {
      result = (const char *)pstrdup(result);
      *(_QWORD *)(v5 + 32) = result;
    }
    *(_DWORD *)(v5 + 40) = *(_DWORD *)(v6 + 16);
    *(_QWORD *)(a1 + 32) = v5;
  }
  v9 = *(_QWORD *)(a2 + 24);
  if (v9)
  {
    v10 = *(int *)(v9 + 4);
    *(_QWORD *)(a1 + 40) = v10;
    result = (const char *)palloc(8 * v10);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v11 = 0;
      v12 = 1;
      do
      {
        v13 = palloc(0x28uLL);
        node__init = pg_query__node__init(v13);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v11) = v13;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v11), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v11), node__init);
        v11 = v12++;
      }
      while (*(_QWORD *)(a1 + 40) > v11);
    }
  }
  *(_DWORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 32);
  return result;
}

const char *_outAlterDatabaseSetStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  _OWORD *v5;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = (_OWORD *)palloc(0x40uLL);
    pg_query__variable_set_stmt__init(v5);
    result = _outVariableSetStmt_0((uint64_t)v5, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(a1 + 32) = v5;
  }
  return result;
}

const char *_outAlterRoleSetStmt_0(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  const char *v8;
  const char *result;
  _OWORD *v10;

  if (a2[1])
  {
    v4 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v4);
    v5 = a2[1];
    v6 = *(_DWORD *)(v5 + 4);
    if (v6 < 4)
      v7 = v6 + 1;
    else
      v7 = -1;
    *(_DWORD *)(v4 + 24) = v7;
    v8 = *(const char **)(v5 + 8);
    if (v8)
      *(_QWORD *)(v4 + 32) = pstrdup(v8);
    *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 16);
    a1[3] = v4;
  }
  result = (const char *)a2[2];
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[4] = result;
  }
  if (a2[3])
  {
    v10 = (_OWORD *)palloc(0x40uLL);
    pg_query__variable_set_stmt__init(v10);
    result = _outVariableSetStmt_0((uint64_t)v10, a2[3]);
    a1[5] = v10;
  }
  return result;
}

const char *_outCreateConversionStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  const char *v10;
  const char *result;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = palloc(8 * v5);
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = v8;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(a1 + 24) > v6);
    }
  }
  v10 = *(const char **)(a2 + 16);
  if (v10)
    *(_QWORD *)(a1 + 40) = pstrdup(v10);
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 48) = result;
  }
  v12 = *(_QWORD *)(a2 + 32);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(a1 + 56) = v13;
    result = (const char *)palloc(8 * v13);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14) = v16;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(a1 + 56) > v14);
    }
  }
  *(_DWORD *)(a1 + 72) = *(unsigned __int8 *)(a2 + 40);
  return result;
}

uint64_t _outCreateCastStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _OWORD *v6;
  unsigned int v7;
  int v8;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x68uLL);
    pg_query__type_name__init(v4);
    result = _outTypeName_0(v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(v3 + 24) = v4;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = palloc(0x68uLL);
    pg_query__type_name__init(v5);
    result = _outTypeName_0(v5, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(v3 + 32) = v5;
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v6 = (_OWORD *)palloc(0x40uLL);
    pg_query__object_with_args__init(v6);
    result = _outVacuumStmt_0((uint64_t)v6, *(_QWORD *)(a2 + 24));
    *(_QWORD *)(v3 + 40) = v6;
  }
  v7 = *(_DWORD *)(a2 + 32);
  if (v7 < 3)
    v8 = v7 + 1;
  else
    v8 = -1;
  *(_DWORD *)(v3 + 48) = v8;
  *(_DWORD *)(v3 + 52) = *(unsigned __int8 *)(a2 + 36);
  return result;
}

const char *_outCreateOpClassStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  const char *result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  double v23;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = palloc(8 * v5);
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = v8;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(a1 + 24) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(a1 + 40) = v11;
    *(_QWORD *)(a1 + 48) = palloc(8 * v11);
    if (*(_QWORD *)(a1 + 40))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v12) = v14;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(a1 + 40) > v12);
    }
  }
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 56) = result;
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v17 = palloc(0x68uLL);
    pg_query__type_name__init(v17);
    result = (const char *)_outTypeName_0(v17, *(_QWORD *)(a2 + 32));
    *(_QWORD *)(a1 + 64) = v17;
  }
  v18 = *(_QWORD *)(a2 + 40);
  if (v18)
  {
    v19 = *(int *)(v18 + 4);
    *(_QWORD *)(a1 + 72) = v19;
    result = (const char *)palloc(8 * v19);
    *(_QWORD *)(a1 + 80) = result;
    if (*(_QWORD *)(a1 + 72))
    {
      v20 = 0;
      v21 = 1;
      do
      {
        v22 = palloc(0x28uLL);
        v23 = pg_query__node__init(v22);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v20) = v22;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v20), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v20), v23);
        v20 = v21++;
      }
      while (*(_QWORD *)(a1 + 72) > v20);
    }
  }
  *(_DWORD *)(a1 + 88) = *(unsigned __int8 *)(a2 + 48);
  return result;
}

const char *_outCreateOpFamilyStmt_0(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  const char *result;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    a1[3] = v5;
    a1[4] = palloc(8 * v5);
    if (a1[3])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(a1[4] + 8 * v6) = v8;
        _outNode_0(*(_QWORD *)(a1[4] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (a1[3] > v6);
    }
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[5] = result;
  }
  return result;
}

const char *_outAlterOpFamilyStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  const char *result;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = palloc(8 * v5);
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = v8;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(a1 + 24) > v6);
    }
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  *(_DWORD *)(a1 + 48) = *(unsigned __int8 *)(a2 + 24);
  v11 = *(_QWORD *)(a2 + 32);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    *(_QWORD *)(a1 + 56) = v12;
    result = (const char *)palloc(8 * v12);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13) = v15;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (*(_QWORD *)(a1 + 56) > v13);
    }
  }
  return result;
}

const char *_outPrepareStmt_0(_QWORD *a1, _QWORD *a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  double v12;

  result = (const char *)a2[1];
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[3] = result;
  }
  v5 = a2[2];
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    a1[4] = v6;
    result = (const char *)palloc(8 * v6);
    a1[5] = result;
    if (a1[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(a1[5] + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(a2[2] + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (a1[4] > v7);
    }
  }
  if (a2[3])
  {
    v11 = palloc(0x28uLL);
    v12 = pg_query__node__init(v11);
    a1[6] = v11;
    return (const char *)_outNode_0(v11, a2[3], v12);
  }
  return result;
}

const char *_outDeclareCursorStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  double node__init;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 16);
  if (*(_QWORD *)(a2 + 24))
  {
    v5 = palloc(0x28uLL);
    node__init = pg_query__node__init(v5);
    *(_QWORD *)(a1 + 40) = v5;
    return (const char *)_outNode_0(v5, *(_QWORD *)(a2 + 24), node__init);
  }
  return result;
}

const char *_outCreateTableSpaceStmt_0(_QWORD *a1, _QWORD *a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  const char *v9;
  const char *result;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double node__init;

  v4 = (const char *)a2[1];
  if (v4)
    a1[3] = pstrdup(v4);
  if (a2[2])
  {
    v5 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v5);
    v6 = a2[2];
    v7 = *(_DWORD *)(v6 + 4);
    if (v7 < 4)
      v8 = v7 + 1;
    else
      v8 = -1;
    *(_DWORD *)(v5 + 24) = v8;
    v9 = *(const char **)(v6 + 8);
    if (v9)
      *(_QWORD *)(v5 + 32) = pstrdup(v9);
    *(_DWORD *)(v5 + 40) = *(_DWORD *)(v6 + 16);
    a1[4] = v5;
  }
  result = (const char *)a2[3];
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[5] = result;
  }
  v11 = a2[4];
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    a1[6] = v12;
    result = (const char *)palloc(8 * v12);
    a1[7] = result;
    if (a1[6])
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        node__init = pg_query__node__init(v15);
        *(_QWORD *)(a1[7] + 8 * v13) = v15;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[7] + 8 * v13), *(_QWORD *)(*(_QWORD *)(a2[4] + 16) + 8 * v13), node__init);
        v13 = v14++;
      }
      while (a1[6] > v13);
    }
  }
  return result;
}

char *_outAlterObjectDependsStmt_0(char *result, uint64_t a2)
{
  char *v3;
  unsigned int v4;
  int v5;
  _OWORD *v6;
  uint64_t v7;
  double node__init;
  uint64_t v9;
  double v10;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *((_DWORD *)result + 6) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v6);
    result = _outRangeVar_0((uint64_t)v6, *(_QWORD *)(a2 + 8));
    *((_QWORD *)v3 + 4) = v6;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v7 = palloc(0x28uLL);
    node__init = pg_query__node__init(v7);
    *((_QWORD *)v3 + 5) = v7;
    result = (char *)_outNode_0(v7, *(_QWORD *)(a2 + 16), node__init);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v9 = palloc(0x28uLL);
    v10 = pg_query__node__init(v9);
    *((_QWORD *)v3 + 6) = v9;
    result = (char *)_outNode_0(v9, *(_QWORD *)(a2 + 24), v10);
  }
  *((_DWORD *)v3 + 14) = *(unsigned __int8 *)(a2 + 32);
  return result;
}

const char *_outAlterObjectSchemaStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  _OWORD *v6;
  uint64_t v7;
  double node__init;
  const char *result;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v6);
    _outRangeVar_0((uint64_t)v6, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v7 = palloc(0x28uLL);
    node__init = pg_query__node__init(v7);
    *(_QWORD *)(a1 + 40) = v7;
    _outNode_0(v7, *(_QWORD *)(a2 + 16), node__init);
  }
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 48) = result;
  }
  *(_DWORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 32);
  return result;
}

_QWORD *_outAlterOwnerStmt_0(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  unsigned int v4;
  int v5;
  _OWORD *v6;
  uint64_t v7;
  double node__init;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *((_DWORD *)result + 6) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v6);
    result = _outRangeVar_0((uint64_t)v6, *(_QWORD *)(a2 + 8));
    v3[4] = v6;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v7 = palloc(0x28uLL);
    node__init = pg_query__node__init(v7);
    v3[5] = v7;
    result = (_QWORD *)_outNode_0(v7, *(_QWORD *)(a2 + 16), node__init);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v9 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v9);
    v10 = *(_QWORD *)(a2 + 24);
    v11 = *(_DWORD *)(v10 + 4);
    if (v11 < 4)
      v12 = v11 + 1;
    else
      v12 = -1;
    *(_DWORD *)(v9 + 24) = v12;
    result = *(_QWORD **)(v10 + 8);
    if (result)
    {
      result = pstrdup((const char *)result);
      *(_QWORD *)(v9 + 32) = result;
    }
    *(_DWORD *)(v9 + 40) = *(_DWORD *)(v10 + 16);
    v3[6] = v9;
  }
  return result;
}

uint64_t _outAlterOperatorStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  v3 = (_QWORD *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x40uLL);
    pg_query__object_with_args__init(v4);
    result = _outVacuumStmt_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    v3[3] = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    v3[4] = v6;
    result = palloc(8 * v6);
    v3[5] = result;
    if (v3[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(v3[5] + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(v3[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (v3[4] > v7);
    }
  }
  return result;
}

uint64_t _outAlterTypeStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;

  v3 = (_QWORD *)result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    v3[4] = result;
    if (v3[3])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[4] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[4] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[3] > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    v3[5] = v11;
    result = palloc(8 * v11);
    v3[6] = result;
    if (v3[5])
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(v3[6] + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(v3[6] + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (v3[5] > v12);
    }
  }
  return result;
}

uint64_t _outDropOwnedStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  int v10;
  int v11;
  int v12;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  v10 = *(_DWORD *)(a2 + 16);
  if (v10 == 1)
    v11 = 2;
  else
    v11 = -1;
  if (v10)
    v12 = v11;
  else
    v12 = 1;
  *(_DWORD *)(v3 + 40) = v12;
  return result;
}

uint64_t _outReassignOwnedStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;

  v3 = (_QWORD *)result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    v3[4] = result;
    if (v3[3])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[4] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[4] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[3] > v6);
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v10 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v10);
    v11 = *(_QWORD *)(a2 + 16);
    v12 = *(_DWORD *)(v11 + 4);
    if (v12 < 4)
      v13 = v12 + 1;
    else
      v13 = -1;
    *(_DWORD *)(v10 + 24) = v13;
    result = *(_QWORD *)(v11 + 8);
    if (result)
    {
      result = (uint64_t)pstrdup((const char *)result);
      *(_QWORD *)(v10 + 32) = result;
    }
    *(_DWORD *)(v10 + 40) = *(_DWORD *)(v11 + 16);
    v3[5] = v10;
  }
  return result;
}

uint64_t _outCompositeTypeStmt_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  v3 = (_QWORD *)result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = (uint64_t)_outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    v3[3] = v4;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    v3[4] = v6;
    result = palloc(8 * v6);
    v3[5] = result;
    if (v3[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(v3[5] + 8 * v7) = v9;
        result = _outNode_0(*(_QWORD *)(v3[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (v3[4] > v7);
    }
  }
  return result;
}

const char *_outAlterEnumStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  const char *v10;
  const char *v11;
  const char *result;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = palloc(8 * v5);
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = v8;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(a1 + 24) > v6);
    }
  }
  v10 = *(const char **)(a2 + 16);
  if (v10)
    *(_QWORD *)(a1 + 40) = pstrdup(v10);
  v11 = *(const char **)(a2 + 24);
  if (v11)
    *(_QWORD *)(a1 + 48) = pstrdup(v11);
  result = *(const char **)(a2 + 32);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 56) = result;
  }
  *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(a2 + 40);
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a2 + 41);
  return result;
}

uint64_t _outAlterTSConfigurationStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  double v23;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 5)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 24) = v5;
  v6 = *(_QWORD *)(a2 + 8);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(result + 32) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 32) > v8);
    }
  }
  v12 = *(_QWORD *)(a2 + 16);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(v3 + 48) = v13;
    result = palloc(8 * v13);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v14) = v16;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(v3 + 48) > v14);
    }
  }
  v18 = *(_QWORD *)(a2 + 24);
  if (v18)
  {
    v19 = *(int *)(v18 + 4);
    *(_QWORD *)(v3 + 64) = v19;
    result = palloc(8 * v19);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v20 = 0;
      v21 = 1;
      do
      {
        v22 = palloc(0x28uLL);
        v23 = pg_query__node__init(v22);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v20) = v22;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v20), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v20), v23);
        v20 = v21++;
      }
      while (*(_QWORD *)(v3 + 64) > v20);
    }
  }
  *(_DWORD *)(v3 + 80) = *(unsigned __int8 *)(a2 + 32);
  *(_DWORD *)(v3 + 84) = *(unsigned __int8 *)(a2 + 33);
  *(_DWORD *)(v3 + 88) = *(unsigned __int8 *)(a2 + 34);
  return result;
}

const char *_outCreateFdwStmt_0(_QWORD *a1, _QWORD *a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;

  result = (const char *)a2[1];
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[3] = result;
  }
  v5 = a2[2];
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    a1[4] = v6;
    result = (const char *)palloc(8 * v6);
    a1[5] = result;
    if (a1[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(a1[5] + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(a2[2] + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (a1[4] > v7);
    }
  }
  v11 = a2[3];
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    a1[6] = v12;
    result = (const char *)palloc(8 * v12);
    a1[7] = result;
    if (a1[6])
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(a1[7] + 8 * v13) = v15;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[7] + 8 * v13), *(_QWORD *)(*(_QWORD *)(a2[3] + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (a1[6] > v13);
    }
  }
  return result;
}

const char *_outCreateForeignServerStmt_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *v5;
  const char *v6;
  const char *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double node__init;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  v5 = *(const char **)(a2 + 16);
  if (v5)
    *(_QWORD *)(a1 + 32) = pstrdup(v5);
  v6 = *(const char **)(a2 + 24);
  if (v6)
    *(_QWORD *)(a1 + 40) = pstrdup(v6);
  result = *(const char **)(a2 + 32);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 48) = result;
  }
  *(_DWORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 40);
  v8 = *(_QWORD *)(a2 + 48);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *(_QWORD *)(a1 + 64) = v9;
    result = (const char *)palloc(8 * v9);
    *(_QWORD *)(a1 + 72) = result;
    if (*(_QWORD *)(a1 + 64))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        node__init = pg_query__node__init(v12);
        *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v10) = v12;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v10), node__init);
        v10 = v11++;
      }
      while (*(_QWORD *)(a1 + 64) > v10);
    }
  }
  return result;
}

const char *_outAlterForeignServerStmt_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(a1 + 40) = v7;
    result = (const char *)palloc(8 * v7);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v8) = v10;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(a1 + 40) > v8);
    }
  }
  *(_DWORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 32);
  return result;
}

const char *_outCreateUserMappingStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  const char *v8;
  const char *result;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double node__init;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v4);
    v5 = *(_QWORD *)(a2 + 8);
    v6 = *(_DWORD *)(v5 + 4);
    if (v6 < 4)
      v7 = v6 + 1;
    else
      v7 = -1;
    *(_DWORD *)(v4 + 24) = v7;
    v8 = *(const char **)(v5 + 8);
    if (v8)
      *(_QWORD *)(v4 + 32) = pstrdup(v8);
    *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 16);
    *(_QWORD *)(a1 + 24) = v4;
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  *(_DWORD *)(a1 + 40) = *(unsigned __int8 *)(a2 + 24);
  v10 = *(_QWORD *)(a2 + 32);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(a1 + 48) = v11;
    result = (const char *)palloc(8 * v11);
    *(_QWORD *)(a1 + 56) = result;
    if (*(_QWORD *)(a1 + 48))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        node__init = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v12) = v14;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v12), node__init);
        v12 = v13++;
      }
      while (*(_QWORD *)(a1 + 48) > v12);
    }
  }
  return result;
}

const char *_outAlterUserMappingStmt_0(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  const char *v8;
  const char *result;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double node__init;

  if (a2[1])
  {
    v4 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v4);
    v5 = a2[1];
    v6 = *(_DWORD *)(v5 + 4);
    if (v6 < 4)
      v7 = v6 + 1;
    else
      v7 = -1;
    *(_DWORD *)(v4 + 24) = v7;
    v8 = *(const char **)(v5 + 8);
    if (v8)
      *(_QWORD *)(v4 + 32) = pstrdup(v8);
    *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 16);
    a1[3] = v4;
  }
  result = (const char *)a2[2];
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[4] = result;
  }
  v10 = a2[3];
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    a1[5] = v11;
    result = (const char *)palloc(8 * v11);
    a1[6] = result;
    if (a1[5])
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        node__init = pg_query__node__init(v14);
        *(_QWORD *)(a1[6] + 8 * v12) = v14;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[6] + 8 * v12), *(_QWORD *)(*(_QWORD *)(a2[3] + 16) + 8 * v12), node__init);
        v12 = v13++;
      }
      while (a1[5] > v12);
    }
  }
  return result;
}

const char *_outDropUserMappingStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  const char *v8;
  const char *result;

  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x30uLL);
    pg_query__role_spec__init((_OWORD *)v4);
    v5 = *(_QWORD *)(a2 + 8);
    v6 = *(_DWORD *)(v5 + 4);
    if (v6 < 4)
      v7 = v6 + 1;
    else
      v7 = -1;
    *(_DWORD *)(v4 + 24) = v7;
    v8 = *(const char **)(v5 + 8);
    if (v8)
      *(_QWORD *)(v4 + 32) = pstrdup(v8);
    *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 16);
    *(_QWORD *)(a1 + 24) = v4;
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  *(_DWORD *)(a1 + 40) = *(unsigned __int8 *)(a2 + 24);
  return result;
}

const char *_outAlterTableSpaceOptionsStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 32) = v6;
    result = (const char *)palloc(8 * v6);
    *(_QWORD *)(a1 + 40) = result;
    if (*(_QWORD *)(a1 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 32) > v7);
    }
  }
  *(_DWORD *)(a1 + 48) = *(unsigned __int8 *)(a2 + 24);
  return result;
}

const char *_outAlterTableMoveAllStmt_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double node__init;
  const char *result;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  v5 = *(_DWORD *)(a2 + 16);
  if (v5 < 0x32)
    v6 = v5 + 1;
  else
    v6 = -1;
  *(_DWORD *)(a1 + 32) = v6;
  v7 = *(_QWORD *)(a2 + 24);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    *(_QWORD *)(a1 + 40) = v8;
    *(_QWORD *)(a1 + 48) = palloc(8 * v8);
    if (*(_QWORD *)(a1 + 40))
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        node__init = pg_query__node__init(v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9) = v11;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v9), node__init);
        v9 = v10++;
      }
      while (*(_QWORD *)(a1 + 40) > v9);
    }
  }
  result = *(const char **)(a2 + 32);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 56) = result;
  }
  *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(a2 + 40);
  return result;
}

const char *_outSecLabelStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  double node__init;
  const char *v8;
  const char *result;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x32)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  if (*(_QWORD *)(a2 + 8))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    *(_QWORD *)(a1 + 32) = v6;
    _outNode_0(v6, *(_QWORD *)(a2 + 8), node__init);
  }
  v8 = *(const char **)(a2 + 16);
  if (v8)
    *(_QWORD *)(a1 + 40) = pstrdup(v8);
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 48) = result;
  }
  return result;
}

const char *_outCreateForeignTableStmt_0(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  const char *result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;

  v4 = palloc(0x98uLL);
  pg_query__create_stmt__init(v4);
  _outCreateStmt_0(v4, a2);
  a1[3] = v4;
  result = *(const char **)(a2 + 104);
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[4] = result;
  }
  v6 = *(_QWORD *)(a2 + 112);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    a1[5] = v7;
    result = (const char *)palloc(8 * v7);
    a1[6] = result;
    if (a1[5])
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(a1[6] + 8 * v8) = v10;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[6] + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (a1[5] > v8);
    }
  }
  return result;
}

const char *_outImportForeignSchemaStmt_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *v5;
  const char *result;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  double node__init;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  double v20;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  v5 = *(const char **)(a2 + 16);
  if (v5)
    *(_QWORD *)(a1 + 32) = pstrdup(v5);
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  v7 = *(_DWORD *)(a2 + 32);
  if (v7 < 3)
    v8 = v7 + 1;
  else
    v8 = -1;
  *(_DWORD *)(a1 + 48) = v8;
  v9 = *(_QWORD *)(a2 + 40);
  if (v9)
  {
    v10 = *(int *)(v9 + 4);
    *(_QWORD *)(a1 + 56) = v10;
    result = (const char *)palloc(8 * v10);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v11 = 0;
      v12 = 1;
      do
      {
        v13 = palloc(0x28uLL);
        node__init = pg_query__node__init(v13);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v11) = v13;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v11), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v11), node__init);
        v11 = v12++;
      }
      while (*(_QWORD *)(a1 + 56) > v11);
    }
  }
  v15 = *(_QWORD *)(a2 + 48);
  if (v15)
  {
    v16 = *(int *)(v15 + 4);
    *(_QWORD *)(a1 + 72) = v16;
    result = (const char *)palloc(8 * v16);
    *(_QWORD *)(a1 + 80) = result;
    if (*(_QWORD *)(a1 + 72))
    {
      v17 = 0;
      v18 = 1;
      do
      {
        v19 = palloc(0x28uLL);
        v20 = pg_query__node__init(v19);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v17) = v19;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v17), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 16) + 8 * v17), v20);
        v17 = v18++;
      }
      while (*(_QWORD *)(a1 + 72) > v17);
    }
  }
  return result;
}

const char *_outAlterExtensionContentsStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  unsigned int v5;
  int v6;
  uint64_t v7;
  double node__init;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 16);
  v5 = *(_DWORD *)(a2 + 20);
  if (v5 < 0x32)
    v6 = v5 + 1;
  else
    v6 = -1;
  *(_DWORD *)(a1 + 36) = v6;
  if (*(_QWORD *)(a2 + 24))
  {
    v7 = palloc(0x28uLL);
    node__init = pg_query__node__init(v7);
    *(_QWORD *)(a1 + 40) = v7;
    return (const char *)_outNode_0(v7, *(_QWORD *)(a2 + 24), node__init);
  }
  return result;
}

const char *_outCreateEventTrigStmt_0(_QWORD *a1, _QWORD *a2)
{
  const char *v4;
  const char *result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;

  v4 = (const char *)a2[1];
  if (v4)
    a1[3] = pstrdup(v4);
  result = (const char *)a2[2];
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[4] = result;
  }
  v6 = a2[3];
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    a1[5] = v7;
    result = (const char *)palloc(8 * v7);
    a1[6] = result;
    if (a1[5])
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(a1[6] + 8 * v8) = v10;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[6] + 8 * v8), *(_QWORD *)(*(_QWORD *)(a2[3] + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (a1[5] > v8);
    }
  }
  v12 = a2[4];
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    a1[7] = v13;
    result = (const char *)palloc(8 * v13);
    a1[8] = result;
    if (a1[7])
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(a1[8] + 8 * v14) = v16;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[8] + 8 * v14), *(_QWORD *)(*(_QWORD *)(a2[4] + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (a1[7] > v14);
    }
  }
  return result;
}

char *_outAlterEventTrigStmt_0(uint64_t a1, uint64_t a2)
{
  char *result;

  result = *(char **)(a2 + 8);
  if (result)
  {
    result = (char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  if (*(_BYTE *)(a2 + 16))
  {
    result = (char *)palloc(2uLL);
    *(_QWORD *)(a1 + 32) = result;
    *result = *(_BYTE *)(a2 + 16);
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 1) = 0;
  }
  return result;
}

char *_outRefreshMatViewStmt_0(char *result, uint64_t a2)
{
  char *v3;
  _OWORD *v4;

  *((_DWORD *)result + 6) = *(unsigned __int8 *)(a2 + 4);
  *((_DWORD *)result + 7) = *(unsigned __int8 *)(a2 + 5);
  if (*(_QWORD *)(a2 + 8))
  {
    v3 = result;
    v4 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v4);
    result = _outRangeVar_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *((_QWORD *)v3 + 4) = v4;
  }
  return result;
}

const char *_outReplicaIdentityStmt_0(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  const char *result;

  if (*(_BYTE *)(a2 + 4))
  {
    v4 = (_BYTE *)palloc(2uLL);
    *(_QWORD *)(a1 + 24) = v4;
    *v4 = *(_BYTE *)(a2 + 4);
    *(_BYTE *)(*(_QWORD *)(a1 + 24) + 1) = 0;
  }
  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  return result;
}

const char *_outAlterSystemStmt_0(const char *result, uint64_t a2)
{
  const char *v3;
  _OWORD *v4;

  if (*(_QWORD *)(a2 + 8))
  {
    v3 = result;
    v4 = (_OWORD *)palloc(0x40uLL);
    pg_query__variable_set_stmt__init(v4);
    result = _outVariableSetStmt_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *((_QWORD *)v3 + 3) = v4;
  }
  return result;
}

const char *_outCreatePolicyStmt_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  _OWORD *v5;
  const char *result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  double node__init;
  uint64_t v13;
  double v14;
  uint64_t v15;
  double v16;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v5);
    _outRangeVar_0((uint64_t)v5, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(a1 + 32) = v5;
  }
  result = *(const char **)(a2 + 24);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  *(_DWORD *)(a1 + 48) = *(unsigned __int8 *)(a2 + 32);
  v7 = *(_QWORD *)(a2 + 40);
  if (v7)
  {
    v8 = *(int *)(v7 + 4);
    *(_QWORD *)(a1 + 56) = v8;
    result = (const char *)palloc(8 * v8);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v9 = 0;
      v10 = 1;
      do
      {
        v11 = palloc(0x28uLL);
        node__init = pg_query__node__init(v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v9) = v11;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v9), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v9), node__init);
        v9 = v10++;
      }
      while (*(_QWORD *)(a1 + 56) > v9);
    }
  }
  if (*(_QWORD *)(a2 + 48))
  {
    v13 = palloc(0x28uLL);
    v14 = pg_query__node__init(v13);
    *(_QWORD *)(a1 + 72) = v13;
    result = (const char *)_outNode_0(v13, *(_QWORD *)(a2 + 48), v14);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    v15 = palloc(0x28uLL);
    v16 = pg_query__node__init(v15);
    *(_QWORD *)(a1 + 80) = v15;
    return (const char *)_outNode_0(v15, *(_QWORD *)(a2 + 56), v16);
  }
  return result;
}

const char *_outAlterPolicyStmt_0(_QWORD *a1, _QWORD *a2)
{
  const char *result;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  double v13;
  uint64_t v14;
  double v15;

  result = (const char *)a2[1];
  if (result)
  {
    result = (const char *)pstrdup(result);
    a1[3] = result;
  }
  if (a2[2])
  {
    v5 = (_OWORD *)palloc(0x50uLL);
    pg_query__range_var__init(v5);
    result = _outRangeVar_0((uint64_t)v5, a2[2]);
    a1[4] = v5;
  }
  v6 = a2[3];
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    a1[5] = v7;
    result = (const char *)palloc(8 * v7);
    a1[6] = result;
    if (a1[5])
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(a1[6] + 8 * v8) = v10;
        result = (const char *)_outNode_0(*(_QWORD *)(a1[6] + 8 * v8), *(_QWORD *)(*(_QWORD *)(a2[3] + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (a1[5] > v8);
    }
  }
  if (a2[4])
  {
    v12 = palloc(0x28uLL);
    v13 = pg_query__node__init(v12);
    a1[7] = v12;
    result = (const char *)_outNode_0(v12, a2[4], v13);
  }
  if (a2[5])
  {
    v14 = palloc(0x28uLL);
    v15 = pg_query__node__init(v14);
    a1[8] = v14;
    return (const char *)_outNode_0(v14, a2[5], v15);
  }
  return result;
}

const char *_outCreateTransformStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const char *result;
  _OWORD *v6;
  _OWORD *v7;

  *(_DWORD *)(a1 + 24) = *(unsigned __int8 *)(a2 + 4);
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x68uLL);
    pg_query__type_name__init(v4);
    _outTypeName_0(v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(a1 + 32) = v4;
  }
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v6 = (_OWORD *)palloc(0x40uLL);
    pg_query__object_with_args__init(v6);
    result = (const char *)_outVacuumStmt_0((uint64_t)v6, *(_QWORD *)(a2 + 24));
    *(_QWORD *)(a1 + 48) = v6;
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v7 = (_OWORD *)palloc(0x40uLL);
    pg_query__object_with_args__init(v7);
    result = (const char *)_outVacuumStmt_0((uint64_t)v7, *(_QWORD *)(a2 + 32));
    *(_QWORD *)(a1 + 56) = v7;
  }
  return result;
}

char *_outCreateAmStmt_0(_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;

  result = *(char **)(a2 + 8);
  if (result)
  {
    result = (char *)pstrdup(result);
    a1[3] = result;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    a1[4] = v6;
    result = (char *)palloc(8 * v6);
    a1[5] = result;
    if (a1[4])
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(a1[5] + 8 * v7) = v9;
        result = (char *)_outNode_0(*(_QWORD *)(a1[5] + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (a1[4] > v7);
    }
  }
  if (*(_BYTE *)(a2 + 24))
  {
    result = (char *)palloc(2uLL);
    a1[6] = result;
    *result = *(_BYTE *)(a2 + 24);
    *(_BYTE *)(a1[6] + 1) = 0;
  }
  return result;
}

const char *_outCreatePublicationStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 32) = v6;
    result = (const char *)palloc(8 * v6);
    *(_QWORD *)(a1 + 40) = result;
    if (*(_QWORD *)(a1 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 32) > v7);
    }
  }
  v11 = *(_QWORD *)(a2 + 24);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    *(_QWORD *)(a1 + 48) = v12;
    result = (const char *)palloc(8 * v12);
    *(_QWORD *)(a1 + 56) = result;
    if (*(_QWORD *)(a1 + 48))
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v13) = v15;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (*(_QWORD *)(a1 + 48) > v13);
    }
  }
  *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(a2 + 32);
  return result;
}

const char *_outAlterPublicationStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;
  unsigned int v17;
  int v18;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 32) = v6;
    result = (const char *)palloc(8 * v6);
    *(_QWORD *)(a1 + 40) = result;
    if (*(_QWORD *)(a1 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 32) > v7);
    }
  }
  v11 = *(_QWORD *)(a2 + 24);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    *(_QWORD *)(a1 + 48) = v12;
    result = (const char *)palloc(8 * v12);
    *(_QWORD *)(a1 + 56) = result;
    if (*(_QWORD *)(a1 + 48))
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v13) = v15;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (*(_QWORD *)(a1 + 48) > v13);
    }
  }
  *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(a2 + 32);
  v17 = *(_DWORD *)(a2 + 36);
  if (v17 < 4)
    v18 = v17 + 1;
  else
    v18 = -1;
  *(_DWORD *)(a1 + 68) = v18;
  return result;
}

const char *_outAlterSubscriptionStmt_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  const char *v6;
  const char *result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double node__init;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  double v19;

  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 5)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(a1 + 24) = v5;
  v6 = *(const char **)(a2 + 8);
  if (v6)
    *(_QWORD *)(a1 + 32) = pstrdup(v6);
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 40) = result;
  }
  v8 = *(_QWORD *)(a2 + 24);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *(_QWORD *)(a1 + 48) = v9;
    result = (const char *)palloc(8 * v9);
    *(_QWORD *)(a1 + 56) = result;
    if (*(_QWORD *)(a1 + 48))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        node__init = pg_query__node__init(v12);
        *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v10) = v12;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v10), node__init);
        v10 = v11++;
      }
      while (*(_QWORD *)(a1 + 48) > v10);
    }
  }
  v14 = *(_QWORD *)(a2 + 32);
  if (v14)
  {
    v15 = *(int *)(v14 + 4);
    *(_QWORD *)(a1 + 64) = v15;
    result = (const char *)palloc(8 * v15);
    *(_QWORD *)(a1 + 72) = result;
    if (*(_QWORD *)(a1 + 64))
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = palloc(0x28uLL);
        v19 = pg_query__node__init(v18);
        *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v16) = v18;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v16), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v16), v19);
        v16 = v17++;
      }
      while (*(_QWORD *)(a1 + 64) > v16);
    }
  }
  return result;
}

const char *_outDropSubscriptionStmt_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  int v5;
  int v6;
  int v7;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  *(_DWORD *)(a1 + 32) = *(unsigned __int8 *)(a2 + 16);
  v5 = *(_DWORD *)(a2 + 20);
  if (v5 == 1)
    v6 = 2;
  else
    v6 = -1;
  if (v5)
    v7 = v6;
  else
    v7 = 1;
  *(_DWORD *)(a1 + 36) = v7;
  return result;
}

const char *_outCreateStatsStmt_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  double v27;
  const char *result;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 32) = palloc(8 * v5);
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = v8;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(a1 + 24) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(a1 + 40) = v11;
    *(_QWORD *)(a1 + 48) = palloc(8 * v11);
    if (*(_QWORD *)(a1 + 40))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v12) = v14;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(a1 + 40) > v12);
    }
  }
  v16 = *(_QWORD *)(a2 + 24);
  if (v16)
  {
    v17 = *(int *)(v16 + 4);
    *(_QWORD *)(a1 + 56) = v17;
    *(_QWORD *)(a1 + 64) = palloc(8 * v17);
    if (*(_QWORD *)(a1 + 56))
    {
      v18 = 0;
      v19 = 1;
      do
      {
        v20 = palloc(0x28uLL);
        v21 = pg_query__node__init(v20);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v18) = v20;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v18), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v18), v21);
        v18 = v19++;
      }
      while (*(_QWORD *)(a1 + 56) > v18);
    }
  }
  v22 = *(_QWORD *)(a2 + 32);
  if (v22)
  {
    v23 = *(int *)(v22 + 4);
    *(_QWORD *)(a1 + 72) = v23;
    *(_QWORD *)(a1 + 80) = palloc(8 * v23);
    if (*(_QWORD *)(a1 + 72))
    {
      v24 = 0;
      v25 = 1;
      do
      {
        v26 = palloc(0x28uLL);
        v27 = pg_query__node__init(v26);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v24) = v26;
        _outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v24), v27);
        v24 = v25++;
      }
      while (*(_QWORD *)(a1 + 72) > v24);
    }
  }
  result = *(const char **)(a2 + 40);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 88) = result;
  }
  *(_DWORD *)(a1 + 96) = *(unsigned __int8 *)(a2 + 48);
  return result;
}

uint64_t _outCallStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _OWORD *v4;
  uint64_t v5;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = (_OWORD *)palloc(0x70uLL);
    pg_query__func_call__init(v4);
    result = _outFuncCall_0((uint64_t)v4, *(_QWORD *)(a2 + 8));
    *(_QWORD *)(v3 + 24) = v4;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = palloc(0x58uLL);
    pg_query__func_expr__init(v5);
    result = _outFuncExpr_0(v5, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(v3 + 32) = v5;
  }
  return result;
}

uint64_t _outAExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  double v13;
  uint64_t v14;
  double v15;

  v3 = result;
  v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 0x10)
    v5 = v4 + 1;
  else
    v5 = -1;
  *(_DWORD *)(result + 24) = v5;
  v6 = *(_QWORD *)(a2 + 8);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(result + 32) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 32) > v8);
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v12 = palloc(0x28uLL);
    v13 = pg_query__node__init(v12);
    *(_QWORD *)(v3 + 48) = v12;
    result = _outNode_0(v12, *(_QWORD *)(a2 + 16), v13);
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v14 = palloc(0x28uLL);
    v15 = pg_query__node__init(v14);
    *(_QWORD *)(v3 + 56) = v14;
    result = _outNode_0(v14, *(_QWORD *)(a2 + 24), v15);
  }
  *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outColumnRef_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 16);
  return result;
}

uint64_t _outAConst_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  double node__init;
  uint64_t result;

  v4 = palloc(0x28uLL);
  node__init = pg_query__node__init(v4);
  *(_QWORD *)(a1 + 24) = v4;
  result = _outNode_0(v4, a2 + 8, node__init);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outFuncCall_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  double v23;
  uint64_t v24;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 40) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 40) > v12);
    }
  }
  v16 = *(_QWORD *)(a2 + 24);
  if (v16)
  {
    v17 = *(int *)(v16 + 4);
    *(_QWORD *)(v3 + 56) = v17;
    result = palloc(8 * v17);
    *(_QWORD *)(v3 + 64) = result;
    if (*(_QWORD *)(v3 + 56))
    {
      v18 = 0;
      v19 = 1;
      do
      {
        v20 = palloc(0x28uLL);
        v21 = pg_query__node__init(v20);
        *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v18) = v20;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v18), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v18), v21);
        v18 = v19++;
      }
      while (*(_QWORD *)(v3 + 56) > v18);
    }
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v22 = palloc(0x28uLL);
    v23 = pg_query__node__init(v22);
    *(_QWORD *)(v3 + 72) = v22;
    result = _outNode_0(v22, *(_QWORD *)(a2 + 32), v23);
  }
  *(_DWORD *)(v3 + 80) = *(unsigned __int8 *)(a2 + 40);
  *(_DWORD *)(v3 + 84) = *(unsigned __int8 *)(a2 + 41);
  *(_DWORD *)(v3 + 88) = *(unsigned __int8 *)(a2 + 42);
  *(_DWORD *)(v3 + 92) = *(unsigned __int8 *)(a2 + 43);
  if (*(_QWORD *)(a2 + 48))
  {
    v24 = palloc(0x68uLL);
    pg_query__window_def__init(v24);
    result = (uint64_t)_outWindowDef_0(v24, *(_QWORD *)(a2 + 48));
    *(_QWORD *)(v3 + 96) = v24;
  }
  *(_DWORD *)(v3 + 104) = *(_DWORD *)(a2 + 56);
  return result;
}

uint64_t _outAIndices_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  double v7;

  v3 = result;
  *(_DWORD *)(result + 24) = *(unsigned __int8 *)(a2 + 4);
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x28uLL);
    v7 = pg_query__node__init(v6);
    *(_QWORD *)(v3 + 40) = v6;
    return _outNode_0(v6, *(_QWORD *)(a2 + 16), v7);
  }
  return result;
}

const char *_outResTarget_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  double node__init;
  uint64_t v11;
  double v12;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(int *)(v5 + 4);
    *(_QWORD *)(a1 + 32) = v6;
    result = (const char *)palloc(8 * v6);
    *(_QWORD *)(a1 + 40) = result;
    if (*(_QWORD *)(a1 + 32))
    {
      v7 = 0;
      v8 = 1;
      do
      {
        v9 = palloc(0x28uLL);
        node__init = pg_query__node__init(v9);
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7) = v9;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v7), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v7), node__init);
        v7 = v8++;
      }
      while (*(_QWORD *)(a1 + 32) > v7);
    }
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v11 = palloc(0x28uLL);
    v12 = pg_query__node__init(v11);
    *(_QWORD *)(a1 + 48) = v11;
    result = (const char *)_outNode_0(v11, *(_QWORD *)(a2 + 24), v12);
  }
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outTypeCast_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 24) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x68uLL);
    pg_query__type_name__init(v6);
    result = _outTypeName_0(v6, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(v3 + 32) = v6;
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outCollateClause_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double v11;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 24) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(v3 + 32) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        v11 = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v8), v11);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 32) > v8);
    }
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outSortBy_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 24) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  v6 = *(_DWORD *)(a2 + 16);
  if (v6 < 4)
    v7 = v6 + 1;
  else
    v7 = -1;
  *(_DWORD *)(v3 + 32) = v7;
  v8 = *(_DWORD *)(a2 + 20);
  if (v8 < 3)
    v9 = v8 + 1;
  else
    v9 = -1;
  *(_DWORD *)(v3 + 36) = v9;
  v10 = *(_QWORD *)(a2 + 24);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 40) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 48) = result;
    if (*(_QWORD *)(v3 + 40))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 40) > v12);
    }
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 32);
  return result;
}

const char *_outWindowDef_0(uint64_t a1, uint64_t a2)
{
  const char *v4;
  const char *result;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double node__init;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  double v21;

  v4 = *(const char **)(a2 + 8);
  if (v4)
    *(_QWORD *)(a1 + 24) = pstrdup(v4);
  result = *(const char **)(a2 + 16);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 32) = result;
  }
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(a1 + 40) = v7;
    result = (const char *)palloc(8 * v7);
    *(_QWORD *)(a1 + 48) = result;
    if (*(_QWORD *)(a1 + 40))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        node__init = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v8) = v10;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v8), node__init);
        v8 = v9++;
      }
      while (*(_QWORD *)(a1 + 40) > v8);
    }
  }
  v12 = *(_QWORD *)(a2 + 32);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(a1 + 56) = v13;
    result = (const char *)palloc(8 * v13);
    *(_QWORD *)(a1 + 64) = result;
    if (*(_QWORD *)(a1 + 56))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14) = v16;
        result = (const char *)_outNode_0(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(a1 + 56) > v14);
    }
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 40);
  if (*(_QWORD *)(a2 + 48))
  {
    v18 = palloc(0x28uLL);
    v19 = pg_query__node__init(v18);
    *(_QWORD *)(a1 + 80) = v18;
    result = (const char *)_outNode_0(v18, *(_QWORD *)(a2 + 48), v19);
  }
  if (*(_QWORD *)(a2 + 56))
  {
    v20 = palloc(0x28uLL);
    v21 = pg_query__node__init(v20);
    *(_QWORD *)(a1 + 88) = v20;
    result = (const char *)_outNode_0(v20, *(_QWORD *)(a2 + 56), v21);
  }
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 64);
  return result;
}

const char *_outRangeSubselect_0(const char *result, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  double node__init;
  _OWORD *v6;

  v3 = result;
  *((_DWORD *)result + 6) = *(unsigned __int8 *)(a2 + 4);
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *((_QWORD *)v3 + 4) = v4;
    result = (const char *)_outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = (_OWORD *)palloc(0x30uLL);
    pg_query__alias__init(v6);
    result = _outAlias_0(v6, *(_QWORD *)(a2 + 16));
    *((_QWORD *)v3 + 5) = v6;
  }
  return result;
}

uint64_t _outRangeFunction_0(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  double v16;

  v3 = (_QWORD *)result;
  *(_DWORD *)(result + 24) = *(unsigned __int8 *)(a2 + 4);
  *(_DWORD *)(result + 28) = *(unsigned __int8 *)(a2 + 5);
  *(_DWORD *)(result + 32) = *(unsigned __int8 *)(a2 + 6);
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 40) = v5;
    result = palloc(8 * v5);
    v3[6] = result;
    if (v3[5])
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(v3[6] + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(v3[6] + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (v3[5] > v6);
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v10 = (_OWORD *)palloc(0x30uLL);
    pg_query__alias__init(v10);
    result = (uint64_t)_outAlias_0(v10, *(_QWORD *)(a2 + 16));
    v3[7] = v10;
  }
  v11 = *(_QWORD *)(a2 + 24);
  if (v11)
  {
    v12 = *(int *)(v11 + 4);
    v3[8] = v12;
    result = palloc(8 * v12);
    v3[9] = result;
    if (v3[8])
    {
      v13 = 0;
      v14 = 1;
      do
      {
        v15 = palloc(0x28uLL);
        v16 = pg_query__node__init(v15);
        *(_QWORD *)(v3[9] + 8 * v13) = v15;
        result = _outNode_0(*(_QWORD *)(v3[9] + 8 * v13), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v13), v16);
        v13 = v14++;
      }
      while (v3[8] > v13);
    }
  }
  return result;
}

uint64_t _outRangeTableSample_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  double v19;

  v3 = result;
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 24) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  v6 = *(_QWORD *)(a2 + 16);
  if (v6)
  {
    v7 = *(int *)(v6 + 4);
    *(_QWORD *)(v3 + 32) = v7;
    result = palloc(8 * v7);
    *(_QWORD *)(v3 + 40) = result;
    if (*(_QWORD *)(v3 + 32))
    {
      v8 = 0;
      v9 = 1;
      do
      {
        v10 = palloc(0x28uLL);
        v11 = pg_query__node__init(v10);
        *(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8) = v10;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8 * v8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8 * v8), v11);
        v8 = v9++;
      }
      while (*(_QWORD *)(v3 + 32) > v8);
    }
  }
  v12 = *(_QWORD *)(a2 + 24);
  if (v12)
  {
    v13 = *(int *)(v12 + 4);
    *(_QWORD *)(v3 + 48) = v13;
    result = palloc(8 * v13);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v14 = 0;
      v15 = 1;
      do
      {
        v16 = palloc(0x28uLL);
        v17 = pg_query__node__init(v16);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v14) = v16;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v14), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v14), v17);
        v14 = v15++;
      }
      while (*(_QWORD *)(v3 + 48) > v14);
    }
  }
  if (*(_QWORD *)(a2 + 32))
  {
    v18 = palloc(0x28uLL);
    v19 = pg_query__node__init(v18);
    *(_QWORD *)(v3 + 64) = v18;
    result = _outNode_0(v18, *(_QWORD *)(a2 + 32), v19);
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  return result;
}

uint64_t _outRangeTableFunc_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  double node__init;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  double v19;
  _OWORD *v20;

  v3 = result;
  *(_DWORD *)(result + 24) = *(unsigned __int8 *)(a2 + 4);
  if (*(_QWORD *)(a2 + 8))
  {
    v4 = palloc(0x28uLL);
    node__init = pg_query__node__init(v4);
    *(_QWORD *)(v3 + 32) = v4;
    result = _outNode_0(v4, *(_QWORD *)(a2 + 8), node__init);
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v6 = palloc(0x28uLL);
    v7 = pg_query__node__init(v6);
    *(_QWORD *)(v3 + 40) = v6;
    result = _outNode_0(v6, *(_QWORD *)(a2 + 16), v7);
  }
  v8 = *(_QWORD *)(a2 + 24);
  if (v8)
  {
    v9 = *(int *)(v8 + 4);
    *(_QWORD *)(v3 + 48) = v9;
    result = palloc(8 * v9);
    *(_QWORD *)(v3 + 56) = result;
    if (*(_QWORD *)(v3 + 48))
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v12 = palloc(0x28uLL);
        v13 = pg_query__node__init(v12);
        *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v10) = v12;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8 * v10), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v10), v13);
        v10 = v11++;
      }
      while (*(_QWORD *)(v3 + 48) > v10);
    }
  }
  v14 = *(_QWORD *)(a2 + 32);
  if (v14)
  {
    v15 = *(int *)(v14 + 4);
    *(_QWORD *)(v3 + 64) = v15;
    result = palloc(8 * v15);
    *(_QWORD *)(v3 + 72) = result;
    if (*(_QWORD *)(v3 + 64))
    {
      v16 = 0;
      v17 = 1;
      do
      {
        v18 = palloc(0x28uLL);
        v19 = pg_query__node__init(v18);
        *(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v16) = v18;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8 * v16), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 8 * v16), v19);
        v16 = v17++;
      }
      while (*(_QWORD *)(v3 + 64) > v16);
    }
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v20 = (_OWORD *)palloc(0x30uLL);
    pg_query__alias__init(v20);
    result = (uint64_t)_outAlias_0(v20, *(_QWORD *)(a2 + 40));
    *(_QWORD *)(v3 + 80) = v20;
  }
  *(_DWORD *)(v3 + 88) = *(_DWORD *)(a2 + 48);
  return result;
}

const char *_outRangeTableFuncCol_0(uint64_t a1, uint64_t a2)
{
  const char *result;
  uint64_t v5;
  uint64_t v6;
  double node__init;
  uint64_t v8;
  double v9;

  result = *(const char **)(a2 + 8);
  if (result)
  {
    result = (const char *)pstrdup(result);
    *(_QWORD *)(a1 + 24) = result;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v5 = palloc(0x68uLL);
    pg_query__type_name__init(v5);
    result = (const char *)_outTypeName_0(v5, *(_QWORD *)(a2 + 16));
    *(_QWORD *)(a1 + 32) = v5;
  }
  *(_DWORD *)(a1 + 40) = *(unsigned __int8 *)(a2 + 24);
  *(_DWORD *)(a1 + 44) = *(unsigned __int8 *)(a2 + 25);
  if (*(_QWORD *)(a2 + 32))
  {
    v6 = palloc(0x28uLL);
    node__init = pg_query__node__init(v6);
    *(_QWORD *)(a1 + 48) = v6;
    result = (const char *)_outNode_0(v6, *(_QWORD *)(a2 + 32), node__init);
  }
  if (*(_QWORD *)(a2 + 40))
  {
    v8 = palloc(0x28uLL);
    v9 = pg_query__node__init(v8);
    *(_QWORD *)(a1 + 56) = v8;
    result = (const char *)_outNode_0(v8, *(_QWORD *)(a2 + 40), v9);
  }
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t _outTypeName_0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  double node__init;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    v5 = *(int *)(v4 + 4);
    *(_QWORD *)(result + 24) = v5;
    result = palloc(8 * v5);
    *(_QWORD *)(v3 + 32) = result;
    if (*(_QWORD *)(v3 + 24))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = palloc(0x28uLL);
        node__init = pg_query__node__init(v8);
        *(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6) = v8;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8 * v6), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 16) + 8 * v6), node__init);
        v6 = v7++;
      }
      while (*(_QWORD *)(v3 + 24) > v6);
    }
  }
  *(_DWORD *)(v3 + 40) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(unsigned __int8 *)(a2 + 20);
  *(_DWORD *)(v3 + 48) = *(unsigned __int8 *)(a2 + 21);
  v10 = *(_QWORD *)(a2 + 24);
  if (v10)
  {
    v11 = *(int *)(v10 + 4);
    *(_QWORD *)(v3 + 56) = v11;
    result = palloc(8 * v11);
    *(_QWORD *)(v3 + 64) = result;
    if (*(_QWORD *)(v3 + 56))
    {
      v12 = 0;
      v13 = 1;
      do
      {
        v14 = palloc(0x28uLL);
        v15 = pg_query__node__init(v14);
        *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v12) = v14;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 8 * v12), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 16) + 8 * v12), v15);
        v12 = v13++;
      }
      while (*(_QWORD *)(v3 + 56) > v12);
    }
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 32);
  v16 = *(_QWORD *)(a2 + 40);
  if (v16)
  {
    v17 = *(int *)(v16 + 4);
    *(_QWORD *)(v3 + 80) = v17;
    result = palloc(8 * v17);
    *(_QWORD *)(v3 + 88) = result;
    if (*(_QWORD *)(v3 + 80))
    {
      v18 = 0;
      v19 = 1;
      do
      {
        v20 = palloc(0x28uLL);
        v21 = pg_query__node__init(v20);
        *(_QWORD *)(*(_QWORD *)(v3 + 88) + 8 * v18) = v20;
        result = _outNode_0(*(_QWORD *)(*(_QWORD *)(v3 + 88) + 8 * v18), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 16) + 8 * v18), v21);
        v18 = v19++;
      }
      while (*(_QWORD *)(v3 + 80) > v18);
    }
  }
  *(_DWORD *)(v3 + 96) = *(_DWORD *)(a2 + 48);
  return result;
}

